[
    {
        "title": "Unique Binary Search Trees II",
        "question_content": "Given an integer n, return all the structurally unique BST's (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order.\n&nbsp;\nExample 1:\n\nInput: n = 3\nOutput: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]\n\nExample 2:\n\nInput: n = 1\nOutput: [[1]]\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 8",
        "solutions": [
            {
                "id": 31508,
                "title": "divide-and-conquer-f-i-g-i-1-g-n-i",
                "content": "This problem is a variant of the problem of [Unique Binary Search Trees][1]. \\n\\nI provided a solution along with explanation for the above problem, in the question [\"DP solution in 6 lines with explanation\"](https://leetcode.com/problems/unique-binary-search-trees/discuss/31666/DP-Solution-in-6-lines-with-explanation.-F(i-n)-G(i-1)-*-G(n-i))\\n\\nIt is intuitive to solve this problem by following the same algorithm. Here is the code in a divide-and-conquer style. \\n\\n    public List<TreeNode> generateTrees(int n) {\\n    \\treturn generateSubtrees(1, n);\\n    }\\n \\n\\tprivate List<TreeNode> generateSubtrees(int s, int e) {\\n\\t\\tList<TreeNode> res = new LinkedList<TreeNode>();\\n\\t\\tif (s > e) {\\n\\t\\t\\tres.add(null); // empty tree\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\tfor (int i = s; i <= e; ++i) {\\n\\t\\t\\tList<TreeNode> leftSubtrees = generateSubtrees(s, i - 1);\\n\\t\\t\\tList<TreeNode> rightSubtrees = generateSubtrees(i + 1, e);\\n\\n\\t\\t\\tfor (TreeNode left : leftSubtrees) {\\n\\t\\t\\t\\tfor (TreeNode right : rightSubtrees) {\\n\\t\\t\\t\\t\\tTreeNode root = new TreeNode(i);\\n\\t\\t\\t\\t\\troot.left = left;\\n\\t\\t\\t\\t\\troot.right = right;\\n\\t\\t\\t\\t\\tres.add(root);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\n  [1]: https://oj.leetcode.com/problems/unique-binary-search-trees/\\n  [2]: https://oj.leetcode.com/discuss/24282/dp-solution-in-6-lines-with-explanation-f-i-g-i-1-g-n-i",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "This problem is a variant of the problem of [Unique Binary Search Trees][1]. \\n\\nI provided a solution along with explanation for the above problem, in the question [\"DP solution in 6 lines with explanation\"](https://leetcode.com/problems/unique-binary-search-trees/discuss/31666/DP-Solution-in-6-lines-with-explanation.-F(i-n)-G(i-1)-*-G(n-i))\\n\\nIt is intuitive to solve this problem by following the same algorithm. Here is the code in a divide-and-conquer style. \\n\\n    public List<TreeNode> generateTrees(int n) {\\n    \\treturn generateSubtrees(1, n);\\n    }\\n \\n\\tprivate List<TreeNode> generateSubtrees(int s, int e) {\\n\\t\\tList<TreeNode> res = new LinkedList<TreeNode>();\\n\\t\\tif (s > e) {\\n\\t\\t\\tres.add(null); // empty tree\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\tfor (int i = s; i <= e; ++i) {\\n\\t\\t\\tList<TreeNode> leftSubtrees = generateSubtrees(s, i - 1);\\n\\t\\t\\tList<TreeNode> rightSubtrees = generateSubtrees(i + 1, e);\\n\\n\\t\\t\\tfor (TreeNode left : leftSubtrees) {\\n\\t\\t\\t\\tfor (TreeNode right : rightSubtrees) {\\n\\t\\t\\t\\t\\tTreeNode root = new TreeNode(i);\\n\\t\\t\\t\\t\\troot.left = left;\\n\\t\\t\\t\\t\\troot.right = right;\\n\\t\\t\\t\\t\\tres.add(root);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\n  [1]: https://oj.leetcode.com/problems/unique-binary-search-trees/\\n  [2]: https://oj.leetcode.com/discuss/24282/dp-solution-in-6-lines-with-explanation-f-i-g-i-1-g-n-i",
                "codeTag": "Unknown"
            },
            {
                "id": 31493,
                "title": "java-solution-with-dp",
                "content": "Here is my java solution with DP:\\n\\n\\n    public static List<TreeNode> generateTrees(int n) {\\n        List<TreeNode>[] result = new List[n + 1];\\n        result[0] = new ArrayList<TreeNode>();\\n        if (n == 0) {\\n            return result[0];\\n        }\\n\\n        result[0].add(null);\\n        for (int len = 1; len <= n; len++) {\\n            result[len] = new ArrayList<TreeNode>();\\n            for (int j = 0; j < len; j++) {\\n                for (TreeNode nodeL : result[j]) {\\n                    for (TreeNode nodeR : result[len - j - 1]) {\\n                        TreeNode node = new TreeNode(j + 1);\\n                        node.left = nodeL;\\n                        node.right = clone(nodeR, j + 1);\\n                        result[len].add(node);\\n                    }\\n                }\\n            }\\n        }\\n        return result[n];\\n    }\\n\\n    private static TreeNode clone(TreeNode n, int offset) {\\n        if (n == null) {\\n            return null;\\n        }\\n        TreeNode node = new TreeNode(n.val + offset);\\n        node.left = clone(n.left, offset);\\n        node.right = clone(n.right, offset);\\n        return node;\\n    }\\n\\n\\n\\n**result[i]** stores the result until length **i**. For the result for length i+1, select the root node j from 0 to i, combine the result from left side and right side. Note for the right side we have to clone the nodes as the value will be offsetted by **j**.",
                "solutionTags": [
                    "Java"
                ],
                "code": "Here is my java solution with DP:\\n\\n\\n    public static List<TreeNode> generateTrees(int n) {\\n        List<TreeNode>[] result = new List[n + 1];\\n        result[0] = new ArrayList<TreeNode>();\\n        if (n == 0) {\\n            return result[0];\\n        }\\n\\n        result[0].add(null);\\n        for (int len = 1; len <= n; len++) {\\n            result[len] = new ArrayList<TreeNode>();\\n            for (int j = 0; j < len; j++) {\\n                for (TreeNode nodeL : result[j]) {\\n                    for (TreeNode nodeR : result[len - j - 1]) {\\n                        TreeNode node = new TreeNode(j + 1);\\n                        node.left = nodeL;\\n                        node.right = clone(nodeR, j + 1);\\n                        result[len].add(node);\\n                    }\\n                }\\n            }\\n        }\\n        return result[n];\\n    }\\n\\n    private static TreeNode clone(TreeNode n, int offset) {\\n        if (n == null) {\\n            return null;\\n        }\\n        TreeNode node = new TreeNode(n.val + offset);\\n        node.left = clone(n.left, offset);\\n        node.right = clone(n.right, offset);\\n        return node;\\n    }\\n\\n\\n\\n**result[i]** stores the result until length **i**. For the result for length i+1, select the root node j from 0 to i, combine the result from left side and right side. Note for the right side we have to clone the nodes as the value will be offsetted by **j**.",
                "codeTag": "Unknown"
            },
            {
                "id": 1849266,
                "title": "c-detailed-explanation-recursive-tree-with-comments",
                "content": "**Problem**\\n> Given n, find all structurally unique BST\\'s (binary search trees) that has n nodes with unique values from 1 to n\\n\\n**Strategy:**\\nWe will use a **recursive helper function** `bst(start, end)` that receives a range (*start to end*, within n) and returns all BST\\'s rooted in that range.\\n\\nNow let\\'s look how our helper function will work!\\n* As there will be trees with root as 1, 2, 3...n.  Iterate through all values from start to end to construct tree rooted at i and construct its left and right subtree recursively.\\n* We know that in Binary Search Tree all nodes in left subtree are smaller than root and in right subtree are larger than root. So for start = 1 and end = n, if we have ith number as root, all numbers from 1 to i-1 will be in left subtree and i+1 to n will be in right subtree. \\n**Therefore, we will build the tree recursively for left and right subtrees rooted at i as `leftSubTree = bst(start, i-1)` and `rightSubtree = bst(i + 1, end)`**\\n* So, till what moment we will recursively find the left and right subtrees?? Answer is until **start < end**!! \\n`So when start > end, add NULL to the list and return`\\nThis will be our base case!\\n* Now, we have leftSubtree and rightSubtree for node with root i. The last thing we need to do is connect leftSubTree and rightSubTree with root and add this tree(rooted at i) to the ans list!\\n\\uD83D\\uDCCC Here, we can have multiple left and right subtrees. So we need to loop through all left and right subtrees and connect every left subTree to right subTree and to current root(i) one by one.\\n\\n**Recursive Tree**\\nSee below recursive tree for more details, expanded for n = 5 and 3 as root!\\n![image](https://assets.leetcode.com/users/images/0b63aeae-a4dd-4f27-80d6-90e94695619a_1647273543.8265834.jpeg)\\n\\n\\t\\n\\t\\t\\n**Code**\\n```cpp\\nvector<TreeNode*> buildTree(int start, int end) {\\n\\tvector<TreeNode*> ans;\\n        \\n    // If start > end, then subtree will be empty so add NULL in the ans and return it.\\n    if(start > end) {\\n\\t\\tans.push_back(NULL);\\n        return ans;\\n    }\\n\\n    // Iterate through all values from start to end to construct left and right subtree recursively\\n\\tfor(int i = start; i <= end; ++i) {\\n\\t\\tvector<TreeNode*> leftSubTree = buildTree(start, i - 1);    // Construct left subtree\\n        vector<TreeNode*> rightSubTree = buildTree(i + 1, end);     // Construct right subtree\\n            \\n\\t\\t// loop through all left and right subtrees and connect them to ith root  \\n\\t\\tfor(int j = 0; j < leftSubTree.size(); j++) {\\n\\t\\t\\tfor(int k = 0; k < rightSubTree.size(); k++) {\\n\\t\\t\\t\\tTreeNode* root = new TreeNode(i);   // Create root with value i\\n\\t\\t\\t\\troot->left = leftSubTree[j];   // Connect left subtree rooted at leftSubTree[j]\\n                root->right = rightSubTree[k];   // Connect right subtree rooted at rightSubTree[k]\\n\\t\\t\\t\\tans.push_back(root);    // Add this tree(rooted at i) to ans data-structure\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n        \\n\\treturn ans;\\n}\\n    \\nvector<TreeNode*> generateTrees(int n) {\\n\\treturn buildTree(1, n);\\n}\\n```\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```cpp\\nvector<TreeNode*> buildTree(int start, int end) {\\n\\tvector<TreeNode*> ans;\\n        \\n    // If start > end, then subtree will be empty so add NULL in the ans and return it.\\n    if(start > end) {\\n\\t\\tans.push_back(NULL);\\n        return ans;\\n    }\\n\\n    // Iterate through all values from start to end to construct left and right subtree recursively\\n\\tfor(int i = start; i <= end; ++i) {\\n\\t\\tvector<TreeNode*> leftSubTree = buildTree(start, i - 1);    // Construct left subtree\\n        vector<TreeNode*> rightSubTree = buildTree(i + 1, end);     // Construct right subtree\\n            \\n\\t\\t// loop through all left and right subtrees and connect them to ith root  \\n\\t\\tfor(int j = 0; j < leftSubTree.size(); j++) {\\n\\t\\t\\tfor(int k = 0; k < rightSubTree.size(); k++) {\\n\\t\\t\\t\\tTreeNode* root = new TreeNode(i);   // Create root with value i\\n\\t\\t\\t\\troot->left = leftSubTree[j];   // Connect left subtree rooted at leftSubTree[j]\\n                root->right = rightSubTree[k];   // Connect right subtree rooted at rightSubTree[k]\\n\\t\\t\\t\\tans.push_back(root);    // Add this tree(rooted at i) to ans data-structure\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n        \\n\\treturn ans;\\n}\\n    \\nvector<TreeNode*> generateTrees(int n) {\\n\\treturn buildTree(1, n);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31495,
                "title": "should-be-6-liner",
                "content": "If only LeetCode had a `TreeNode(val, left, right)` constructor... sigh. Then I wouldn't need to provide my own and my solution would be six lines instead of eleven.\\n\\n    def generateTrees(self, n):\\n        def node(val, left, right):\\n            node = TreeNode(val)\\n            node.left = left\\n            node.right = right\\n            return node\\n        def trees(first, last):\\n            return [node(root, left, right)\\n                    for root in range(first, last+1)\\n                    for left in trees(first, root-1)\\n                    for right in trees(root+1, last)] or [None]\\n        return trees(1, n)\\n\\nOr even just **four** lines, if it's not forbidden to add an optional argument:\\n\\n    def node(val, left, right):\\n        node = TreeNode(val)\\n        node.left = left\\n        node.right = right\\n        return node\\n    \\n    class Solution:\\n        def generateTrees(self, last, first=1):\\n            return [node(root, left, right)\\n                    for root in range(first, last+1)\\n                    for left in self.generateTrees(root-1, first)\\n                    for right in self.generateTrees(last, root+1)] or [None]\\n\\nJust another version, using loops instead of list comprehension:\\n\\n    def generateTrees(self, n):\\n        def generate(first, last):\\n            trees = []\\n            for root in range(first, last+1):\\n                for left in generate(first, root-1):\\n                    for right in generate(root+1, last):\\n                        node = TreeNode(root)\\n                        node.left = left\\n                        node.right = right\\n                        trees += node,\\n            return trees or [None]\\n        return generate(1, n)",
                "solutionTags": [
                    "Python"
                ],
                "code": "If only LeetCode had a `TreeNode(val, left, right)` constructor... sigh. Then I wouldn't need to provide my own and my solution would be six lines instead of eleven.\\n\\n    def generateTrees(self, n):\\n        def node(val, left, right):\\n            node = TreeNode(val)\\n            node.left = left\\n            node.right = right\\n            return node\\n        def trees(first, last):\\n            return [node(root, left, right)\\n                    for root in range(first, last+1)\\n                    for left in trees(first, root-1)\\n                    for right in trees(root+1, last)] or [None]\\n        return trees(1, n)\\n\\nOr even just **four** lines, if it's not forbidden to add an optional argument:\\n\\n    def node(val, left, right):\\n        node = TreeNode(val)\\n        node.left = left\\n        node.right = right\\n        return node\\n    \\n    class Solution:\\n        def generateTrees(self, last, first=1):\\n            return [node(root, left, right)\\n                    for root in range(first, last+1)\\n                    for left in self.generateTrees(root-1, first)\\n                    for right in self.generateTrees(last, root+1)] or [None]\\n\\nJust another version, using loops instead of list comprehension:\\n\\n    def generateTrees(self, n):\\n        def generate(first, last):\\n            trees = []\\n            for root in range(first, last+1):\\n                for left in generate(first, root-1):\\n                    for right in generate(root+1, last):\\n                        node = TreeNode(root)\\n                        node.left = left\\n                        node.right = right\\n                        trees += node,\\n            return trees or [None]\\n        return generate(1, n)",
                "codeTag": "Java"
            },
            {
                "id": 1440128,
                "title": "python-dfs-with-memoization-clean-concise",
                "content": "**Idea**\\n- Let `dfs(left, right)` return all valid BSTs where values in the BST in range `[left..right]`.\\n- Then `dfs(1, n)` is our result.\\n- To solve `dfs(left, right)`, we just\\n\\t- Generate `root` value in range `[left...right]`\\n\\t- Get left subtrees by `leftNodes = dfs(left, root-1)`\\n\\t- Get right subtrees by `rightNodes = dfs(root+1, right)`.\\n\\t- Add all combination between `leftNodes` and `rightNodes` to form `root` trees.\\n- Can we cache the result of `dfs(left, right)` to prevent it to re-compute multiple time.\\n- There is a simillar problem, which is **[894. All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/)**, try to solve it yourself.\\n```python\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:\\n        @lru_cache(None)\\n        def dfs(left, right):\\n            if left > right: return [None]\\n            if left == right: return [TreeNode(left)]\\n            ans = []\\n            for root in range(left, right+1):\\n                leftNodes = dfs(left, root - 1)\\n                rightNodes = dfs(root+1, right)\\n                for leftNode in leftNodes:\\n                    for rightNode in rightNodes:\\n                        rootNode = TreeNode(root, leftNode, rightNode)\\n                        ans.append(rootNode)\\n            return ans\\n        \\n        return dfs(1, n)\\n```\\n**Complexity**\\n- Time: `O(C0+C1+...Cn)`, where `Cn` is the [Catalan number](https://en.wikipedia.org/wiki/Catalan_number), `n <= 8`. Can check this problem [96. Unique Binary Search Trees](https://leetcode.com/problems/unique-binary-search-trees/) to know why the number of nodes in the BST with `n` nodes is a Catalan number.\\n\\t- The Catalan numbers for `n = 0, 1, 2, 3, 4, 5, 6, 7, 8` are `1, 1, 2, 5, 14, 42, 132, 429, 1430`.\\n- Space: `O(n * Cn)`, there is total `Cn` BSTs, each BST has `n` nodes.\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:\\n        @lru_cache(None)\\n        def dfs(left, right):\\n            if left > right: return [None]\\n            if left == right: return [TreeNode(left)]\\n            ans = []\\n            for root in range(left, right+1):\\n                leftNodes = dfs(left, root - 1)\\n                rightNodes = dfs(root+1, right)\\n                for leftNode in leftNodes:\\n                    for rightNode in rightNodes:\\n                        rootNode = TreeNode(root, leftNode, rightNode)\\n                        ans.append(rootNode)\\n            return ans\\n        \\n        return dfs(1, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31516,
                "title": "share-a-c-dp-solution-with-o-1-space",
                "content": "The basic idea is that we can construct the result of n node tree just from the result of n-1 node tree.\\nHere's how we do it: only 2 conditions: 1)  The nth node is the new root, so `newroot->left = oldroot;`\\n2) the nth node is not root, we traverse the old tree, every time the node in the old tree has a right child, we can perform: `old node->right = nth node, nth node ->left = right child;` and when we reach the end of the tree, don't forget we can also add the nth node here.\\nOne thing to notice is that every time we push a TreeNode in our result, I push the clone version of the root, and I recover what I do to the old node immediately. This is because you may use the old tree for several times.\\n   \\n\\n     class Solution {\\n        public:\\n            TreeNode* clone(TreeNode* root){\\n                if(root == nullptr)\\n                    return nullptr;\\n                TreeNode* newroot = new TreeNode(root->val);\\n                newroot->left = clone(root->left);\\n                newroot->right = clone(root->right);\\n                return newroot;\\n            }\\n            vector<TreeNode *> generateTrees(int n) {\\n                vector<TreeNode *> res(1,nullptr);\\n                for(int i = 1; i <= n; i++){\\n                    vector<TreeNode *> tmp;\\n                    for(int j = 0; j<res.size();j++){\\n                        TreeNode* oldroot = res[j];\\n                        TreeNode* root = new TreeNode(i);\\n                        TreeNode* target = clone(oldroot);\\n                        root->left = target;\\n                        tmp.push_back(root);\\n                       \\n                        if(oldroot!=nullptr){\\n                            TreeNode* tmpold = oldroot;\\n                            while(tmpold->right!=nullptr){\\n                                TreeNode* nonroot = new TreeNode(i);\\n                                TreeNode *tright = tmpold->right;\\n                                tmpold->right = nonroot;\\n                                nonroot->left = tright;\\n                                TreeNode *target = clone(oldroot);\\n                                tmp.push_back(target);\\n                                tmpold->right = tright;\\n                                tmpold = tmpold->right;\\n                            }\\n                            tmpold->right = new TreeNode(i);\\n                            TreeNode *target = clone(oldroot);\\n                            tmp.push_back(target);\\n                            tmpold->right = nullptr;\\n                        }\\n                    }\\n                    res=tmp;\\n                }\\n                return res;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            TreeNode* clone(TreeNode* root){\\n                if(root == nullptr)\\n                    return nullptr;\\n                TreeNode* newroot = new TreeNode(root->val);\\n                newroot->left = clone(root->left);\\n                newroot->right = clone(root->right);\\n                return newroot;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 31563,
                "title": "my-accepted-c-solution-recursive-less-than-30-lines",
                "content": "**explaination:**\\nGiven a tree which n nodes, it has the follwing form: \\n(0)root(n-1)\\n(1)root(n-2)\\n(2)root(n-3)\\nwhere (x) denotes the trees with x  nodes.\\n\\nNow take n=3 for example. Given n=3, we have [1 2 3] in which each of them can be used as the tree root.\\n\\nwhen root=1: [1 # 2 # 3]; [1 # 3 2];\\nwhen root=2: [2 1 3]; \\nwhen root=3: (similar with the situations when root=1.)\\n\\nThus, if we write a recursive function who generates a group of trees in which the numbers range from *f* to *t*, we have to generate the left trees and right trees of each tree in the vector. \\n\\nI give the following recursive code and expect to see non-recursive ones. please! \\n\\n**code:**\\n\\n    vector<TreeNode *> generateTree(int from, int to)\\n    {\\n        vector<TreeNode *> ret;\\n        if(to - from < 0) ret.push_back(0);\\n        if(to - from == 0) ret.push_back(new TreeNode(from));\\n        if(to - from > 0)\\n        {\\n            for(int i=from; i<=to; i++)\\n            {\\n                vector<TreeNode *> l = generateTree(from, i-1);\\n                vector<TreeNode *> r = generateTree(i+1, to);\\n\\n                for(int j=0; j<l.size(); j++)\\n                {\\n                    for(int k=0; k<r.size(); k++)\\n                    {\\n                        TreeNode * h = new TreeNode (i);\\n                        h->left = l[j];\\n                        h->right = r[k];\\n                        ret.push_back(h);\\n                    }\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    vector<TreeNode *> generateTrees(int n) {\\n        return generateTree(1, n);\\n    }",
                "solutionTags": [],
                "code": "**explaination:**\\nGiven a tree which n nodes, it has the follwing form: \\n(0)root(n-1)\\n(1)root(n-2)\\n(2)root(n-3)\\nwhere (x) denotes the trees with x  nodes.\\n\\nNow take n=3 for example. Given n=3, we have [1 2 3] in which each of them can be used as the tree root.\\n\\nwhen root=1: [1 # 2 # 3]; [1 # 3 2];\\nwhen root=2: [2 1 3]; \\nwhen root=3: (similar with the situations when root=1.)\\n\\nThus, if we write a recursive function who generates a group of trees in which the numbers range from *f* to *t*, we have to generate the left trees and right trees of each tree in the vector. \\n\\nI give the following recursive code and expect to see non-recursive ones. please! \\n\\n**code:**\\n\\n    vector<TreeNode *> generateTree(int from, int to)\\n    {\\n        vector<TreeNode *> ret;\\n        if(to - from < 0) ret.push_back(0);\\n        if(to - from == 0) ret.push_back(new TreeNode(from));\\n        if(to - from > 0)\\n        {\\n            for(int i=from; i<=to; i++)\\n            {\\n                vector<TreeNode *> l = generateTree(from, i-1);\\n                vector<TreeNode *> r = generateTree(i+1, to);\\n\\n                for(int j=0; j<l.size(); j++)\\n                {\\n                    for(int k=0; k<r.size(); k++)\\n                    {\\n                        TreeNode * h = new TreeNode (i);\\n                        h->left = l[j];\\n                        h->right = r[k];\\n                        ret.push_back(h);\\n                    }\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    vector<TreeNode *> generateTrees(int n) {\\n        return generateTree(1, n);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3864900,
                "title": "recursion-dp-video-catalan-number-unique-bst",
                "content": "Given an integer \\\\( n \\\\), the task is to return all the structurally unique BST\\'s (binary search trees) that have exactly \\\\( n \\\\) nodes of unique values from \\\\( 1 \\\\) to \\\\( n \\\\).\\n\\n# Intuition Recursion & Dynamic Programming\\nThe problem can be solved by utilizing the properties of a BST, where the left subtree has all values less than the root and the right subtree has values greater than the root. We can explore both recursive and dynamic programming (DP) approaches to generate all possible combinations of unique BSTs.\\n\\n# Live Coding & Explenation Recursion\\nhttps://youtu.be/HeB6Oufsg_o\\n\\n# n-th Catalan number\\n\\nIn the context of this task, the \\\\(n\\\\)-th Catalan number gives the number of distinct binary search trees that can be formed with \\\\(n\\\\) unique values. The \\\\(n\\\\)-th Catalan number is given by the formula:\\n\\n$$\\nC_n = \\\\frac{1}{n+1} \\\\binom{2n}{n} = \\\\frac{(2n)!}{(n+1)!n!}\\n$$\\n\\nThe time and space complexity of generating these trees are both $$O(C_n)$$, which is equivalent to $$O\\\\left(\\\\frac{4^n}{n\\\\sqrt{n}}\\\\right)$$.\\n\\nHere\\'s how it relates to the task:\\n\\n1. **Choosing the Root**: For each root value, we\\'re essentially dividing the problem into two subproblems (left and right subtrees), and the number of combinations for each division aligns with the recursive definition of the Catalan numbers.\\n   \\n2. **Recursive and Dynamic Programming Solutions**: Both approaches inherently follow the recursive nature of the Catalan numbers. The recursive approach directly corresponds to the recursive formula for the Catalan numbers, while the dynamic programming approach leverages the computed results for smaller subproblems to build up to the solution.\\n\\n3. **Number of Unique BSTs**: The fact that there are \\\\(C_n\\\\) unique BSTs with \\\\(n\\\\) nodes is a direct application of the Catalan numbers. The complexity of generating all these trees is thus closely tied to the value of the \\\\(n\\\\)-th Catalan number.\\n\\nIn conclusion, the complexity of the problem is inherently linked to the Catalan numbers, as they precisely describe the number of unique structures that can be formed, which in turn dictates the computational resources required to enumerate them.\\n\\n# Approach Short\\n\\n1. **Recursion**: Recursively construct left and right subtrees and combine them with each root.\\n2. **Dynamic Programming**: Use dynamic programming to store the result of subproblems (subtrees) and utilize them for constructing unique BSTs.\\n\\n## Approach Differences\\nThe recursive approach constructs the trees from scratch every time, while the DP approach reuses previously computed subtrees to avoid redundant work.\\n\\n# Approach Recursion\\n\\nThe recursive approach involves the following steps:\\n\\n1. **Base Case**: If the start index is greater than the end index, return a list containing `None`. This represents an empty tree and serves as the base case for the recursion.\\n\\n2. **Choose Root**: For every number \\\\( i \\\\) in the range from `start` to `end`, consider \\\\( i \\\\) as the root of the tree.\\n\\n3. **Generate Left Subtrees**: Recursively call the function to generate all possible left subtrees using numbers from `start` to \\\\( i-1 \\\\). This forms the left child of the root.\\n\\n4. **Generate Right Subtrees**: Recursively call the function to generate all possible right subtrees using numbers from \\\\( i+1 \\\\) to `end`. This forms the right child of the root.\\n\\n5. **Combine Subtrees**: For each combination of left and right subtrees, create a new tree with \\\\( i \\\\) as the root and the corresponding left and right subtrees. Append this tree to the list of all possible trees.\\n\\n6. **Return Trees**: Finally, return the list of all trees generated.\\n\\n# Complexity Recursion\\n- Time complexity: $$O(\\\\frac{4^n}{n\\\\sqrt{n}})$$\\n- Space complexity: $$ O(\\\\frac{4^n}{n\\\\sqrt{n}}) $$\\n\\n# Performance Recursion\\n\\n| Language   | Runtime (ms) | Beats (%) | Memory (MB) | Beats (%) |\\n|------------|--------------|-----------|-------------|-----------|\\n| Rust       | 0            | 100       | 2.5         | 80        |\\n| Java       | 1            | 99.88     | 43.7        | 66.87     |\\n| Go         | 3            | 56.88     | 4.4         | 63.30     |\\n| C++        | 16           | 75.53     | 16.2        | 20.99     |\\n| Python3    | 53           | 97.4      | 18.1        | 27.83     |\\n| JavaScript | 74           | 89.61     | 48.4        | 55.19     |\\n| C#         | 91           | 88.76     | 39.8        | 19.10     |\\n\\n![performance_recursion_updated.png](https://assets.leetcode.com/users/images/bede177d-f334-42bd-85ec-517c600b7ef7_1691199606.5911264.png)\\n\\n\\n# Code Recursion\\n``` Python []\\nclass Solution:\\n    def generateTrees(self, n: int):\\n        def generate_trees(start, end):\\n            if start > end:\\n                return [None,]\\n            \\n            all_trees = []\\n            for i in range(start, end + 1):\\n                left_trees = generate_trees(start, i - 1)\\n                right_trees = generate_trees(i + 1, end)\\n                \\n                for l in left_trees:\\n                    for r in right_trees:\\n                        current_tree = TreeNode(i)\\n                        current_tree.left = l\\n                        current_tree.right = r\\n                        all_trees.append(current_tree)\\n            \\n            return all_trees\\n        \\n        return generate_trees(1, n) if n else []\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        return n ? generate_trees(1, n) : vector<TreeNode*>();\\n    }\\n\\nprivate:\\n    vector<TreeNode*> generate_trees(int start, int end) {\\n        if (start > end) return {nullptr};\\n\\n        vector<TreeNode*> all_trees;\\n        for (int i = start; i <= end; i++) {\\n            vector<TreeNode*> left_trees = generate_trees(start, i - 1);\\n            vector<TreeNode*> right_trees = generate_trees(i + 1, end);\\n\\n            for (TreeNode* l : left_trees) {\\n                for (TreeNode* r : right_trees) {\\n                    TreeNode* current_tree = new TreeNode(i);\\n                    current_tree->left = l;\\n                    current_tree->right = r;\\n                    all_trees.push_back(current_tree);\\n                }\\n            }\\n        }\\n        return all_trees;\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        return n > 0 ? generate_trees(1, n) : new ArrayList<>();\\n    }\\n\\n    private List<TreeNode> generate_trees(int start, int end) {\\n        List<TreeNode> all_trees = new ArrayList<>();\\n        if (start > end) {\\n            all_trees.add(null);\\n            return all_trees;\\n        }\\n\\n        for (int i = start; i <= end; i++) {\\n            List<TreeNode> left_trees = generate_trees(start, i - 1);\\n            List<TreeNode> right_trees = generate_trees(i + 1, end);\\n\\n            for (TreeNode l : left_trees) {\\n                for (TreeNode r : right_trees) {\\n                    TreeNode current_tree = new TreeNode(i);\\n                    current_tree.left = l;\\n                    current_tree.right = r;\\n                    all_trees.add(current_tree);\\n                }\\n            }\\n        }\\n        return all_trees;\\n    }\\n}\\n```\\n``` JavaScript []\\nvar generateTrees = function(n) {\\n    if (n === 0) return [];\\n\\n    function generate_trees(start, end) {\\n        if (start > end) return [null];\\n\\n        const all_trees = [];\\n        for (let i = start; i <= end; i++) {\\n            const left_trees = generate_trees(start, i - 1);\\n            const right_trees = generate_trees(i + 1, end);\\n\\n            for (const l of left_trees) {\\n                for (const r of right_trees) {\\n                    const current_tree = new TreeNode(i);\\n                    current_tree.left = l;\\n                    current_tree.right = r;\\n                    all_trees.push(current_tree);\\n                }\\n            }\\n        }\\n        return all_trees;\\n    }\\n\\n    return generate_trees(1, n);\\n};\\n```\\n``` C# []\\npublic class Solution {\\n    public IList<TreeNode> GenerateTrees(int n) {\\n        return n > 0 ? GenerateTrees(1, n) : new List<TreeNode>();\\n    }\\n\\n    private IList<TreeNode> GenerateTrees(int start, int end) {\\n        if (start > end) return new List<TreeNode> {null};\\n\\n        var all_trees = new List<TreeNode>();\\n        for (int i = start; i <= end; i++) {\\n            var left_trees = GenerateTrees(start, i - 1);\\n            var right_trees = GenerateTrees(i + 1, end);\\n\\n            foreach (var l in left_trees) {\\n                foreach (var r in right_trees) {\\n                    var current_tree = new TreeNode(i, l, r);\\n                    all_trees.Add(current_tree);\\n                }\\n            }\\n        }\\n        return all_trees;\\n    }\\n}\\n```\\n``` Rust []\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn generate_trees(n: i32) -> Vec<Option<Rc<RefCell<TreeNode>>>> {\\n        if n == 0 {\\n            return Vec::new();\\n        }\\n        Self::generate(1, n)\\n    }\\n\\n    fn generate(start: i32, end: i32) -> Vec<Option<Rc<RefCell<TreeNode>>>> {\\n        if start > end {\\n            return vec![None];\\n        }\\n\\n        let mut all_trees = Vec::new();\\n        for i in start..=end {\\n            let left_trees = Self::generate(start, i - 1);\\n            let right_trees = Self::generate(i + 1, end);\\n\\n            for l in &left_trees {\\n                for r in &right_trees {\\n                    let current_tree = Some(Rc::new(RefCell::new(TreeNode::new(i))));\\n                    current_tree.as_ref().unwrap().borrow_mut().left = l.clone();\\n                    current_tree.as_ref().unwrap().borrow_mut().right = r.clone();\\n                    all_trees.push(current_tree);\\n                }\\n            }\\n        }\\n        all_trees\\n    }\\n}\\n```\\n``` Go []\\nfunc generateTrees(n int) []*TreeNode {\\n\\tif n == 0 {\\n\\t\\treturn []*TreeNode{}\\n\\t}\\n\\treturn generate(1, n)\\n}\\n\\nfunc generate(start, end int) []*TreeNode {\\n\\tif start > end {\\n\\t\\treturn []*TreeNode{nil}\\n\\t}\\n\\n\\tvar allTrees []*TreeNode\\n\\tfor i := start; i <= end; i++ {\\n\\t\\tleftTrees := generate(start, i-1)\\n\\t\\trightTrees := generate(i+1, end)\\n\\n\\t\\tfor _, l := range leftTrees {\\n\\t\\t\\tfor _, r := range rightTrees {\\n\\t\\t\\t\\tcurrentTree := &TreeNode{Val: i, Left: l, Right: r}\\n\\t\\t\\t\\tallTrees = append(allTrees, currentTree)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn allTrees\\n}\\n```\\n\\n# Approach Dynamic Programming\\n\\n1. **Initialization**: Create a DP table `dp` where `dp[i]` will store all the unique BSTs with `i` nodes. Initialize `dp[0]` with a single `None` value representing an empty tree.\\n\\n2. **Iterate Over Number of Nodes**: For every number `nodes` from 1 to `n`, iterate and construct all possible trees with `nodes` number of nodes.\\n\\n3. **Choose Root**: For every possible root value within the current `nodes`, iterate and use the root to build trees.\\n\\n4. **Use Previously Computed Subtrees**: For the chosen root, use the previously computed `dp[root - 1]` for left subtrees and `dp[nodes - root]` for right subtrees.\\n\\n5. **Clone Right Subtree**: Since the right subtree\\'s values will be affected by the choice of the root, clone the right subtree with an offset equal to the root value. The `clone` function handles this.\\n\\n6. **Combine Subtrees**: Create a new tree by combining the current root with the left and right subtrees. Append this tree to `dp[nodes]`.\\n\\n7. **Return Result**: Finally, return the trees stored in `dp[n]`.\\n\\n# Complexity Dynamic Programming\\n- Time complexity: $$O(\\\\frac{4^n}{n\\\\sqrt{n}})$$\\n- Space complexity: $$ O(\\\\frac{4^n}{n\\\\sqrt{n}}) $$\\n\\n# Performance Dynamic Programming\\n\\n| Language   | Runtime (ms) | Beats (%) | Memory (MB) | Beats (%) |\\n|------------|--------------|-----------|-------------|-----------|\\n| Rust       | 0            | 100       | 2.7         | 20        |\\n| Java       | 1            | 99.88     | 44.1        | 8.87      |\\n| Go         | 3            | 56.88     | 4.2         | 90.83     |\\n| C++        | 10           | 96.72     | 12.5        | 86.56     |\\n| JavaScript | 67           | 96.75     | 48.5        | 55.19     |\\n| Python3    | 49           | 98.84     | 18.1        | 21.91     |\\n| C#         | 91           | 88.76     | 38.5        | 80.90     |\\n\\n![performance_dynamic_programming.png](https://assets.leetcode.com/users/images/172a4ebb-facf-4b20-8c7b-1c59a891ea05_1691199566.481603.png)\\n\\n\\n# Code Dynamic Programming\\n``` Python []\\nclass Solution:\\n    def generateTrees(self, n: int):\\n        if n == 0:\\n            return []\\n\\n        dp = [[] for _ in range(n + 1)]\\n        dp[0].append(None)\\n        for nodes in range(1, n + 1):\\n            for root in range(1, nodes + 1):\\n                for left_tree in dp[root - 1]:\\n                    for right_tree in dp[nodes - root]:\\n                        root_node = TreeNode(root)\\n                        root_node.left = left_tree\\n                        root_node.right = self.clone(right_tree, root)\\n                        dp[nodes].append(root_node)\\n        return dp[n]\\n    \\n    def clone(self, n: TreeNode, offset: int) -> TreeNode:\\n        if n:\\n            node = TreeNode(n.val + offset)\\n            node.left = self.clone(n.left, offset)\\n            node.right = self.clone(n.right, offset)\\n            return node\\n        return None\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        if (n == 0) return {};\\n\\n        vector<vector<TreeNode*>> dp(n + 1);\\n        dp[0].push_back(nullptr);\\n        for (int nodes = 1; nodes <= n; nodes++) {\\n            for (int root = 1; root <= nodes; root++) {\\n                for (TreeNode* left_tree : dp[root - 1]) {\\n                    for (TreeNode* right_tree : dp[nodes - root]) {\\n                        TreeNode* root_node = new TreeNode(root);\\n                        root_node->left = left_tree;\\n                        root_node->right = clone(right_tree, root);\\n                        dp[nodes].push_back(root_node);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\nprivate:\\n    TreeNode* clone(TreeNode* n, int offset) {\\n        if (n == nullptr) return nullptr;\\n        TreeNode* node = new TreeNode(n->val + offset);\\n        node->left = clone(n->left, offset);\\n        node->right = clone(n->right, offset);\\n        return node;\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        if (n == 0) return new ArrayList<>();\\n\\n        List<TreeNode>[] dp = new ArrayList[n + 1];\\n        dp[0] = new ArrayList<>();\\n        dp[0].add(null);\\n        for (int nodes = 1; nodes <= n; nodes++) {\\n            dp[nodes] = new ArrayList<>();\\n            for (int root = 1; root <= nodes; root++) {\\n                for (TreeNode left_tree : dp[root - 1]) {\\n                    for (TreeNode right_tree : dp[nodes - root]) {\\n                        TreeNode root_node = new TreeNode(root);\\n                        root_node.left = left_tree;\\n                        root_node.right = clone(right_tree, root);\\n                        dp[nodes].add(root_node);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\n    private TreeNode clone(TreeNode n, int offset) {\\n        if (n == null) return null;\\n        TreeNode node = new TreeNode(n.val + offset);\\n        node.left = clone(n.left, offset);\\n        node.right = clone(n.right, offset);\\n        return node;\\n    }\\n}\\n```\\n``` JavaScript []\\nvar generateTrees = function(n) {\\n    if (n === 0) return [];\\n\\n    const dp = Array.from({ length: n + 1 }, () => []);\\n    dp[0].push(null);\\n    for (let nodes = 1; nodes <= n; nodes++) {\\n        for (let root = 1; root <= nodes; root++) {\\n            for (const left_tree of dp[root - 1]) {\\n                for (const right_tree of dp[nodes - root]) {\\n                    const root_node = new TreeNode(root);\\n                    root_node.left = left_tree;\\n                    root_node.right = clone(right_tree, root);\\n                    dp[nodes].push(root_node);\\n                }\\n            }\\n        }\\n    }\\n    return dp[n];\\n};\\n\\nfunction clone(n, offset) {\\n    if (n === null) return null;\\n    const node = new TreeNode(n.val + offset);\\n    node.left = clone(n.left, offset);\\n    node.right = clone(n.right, offset);\\n    return node;\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public IList<TreeNode> GenerateTrees(int n) {\\n        if (n == 0) return new List<TreeNode>();\\n\\n        var dp = new List<TreeNode>[n + 1];\\n        dp[0] = new List<TreeNode> { null };\\n        for (int nodes = 1; nodes <= n; nodes++) {\\n            dp[nodes] = new List<TreeNode>();\\n            for (int root = 1; root <= nodes; root++) {\\n                foreach (var left_tree in dp[root - 1]) {\\n                    foreach (var right_tree in dp[nodes - root]) {\\n                        TreeNode root_node = new TreeNode(root);\\n                        root_node.left = left_tree;\\n                        root_node.right = Clone(right_tree, root);\\n                        dp[nodes].Add(root_node);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\n    private TreeNode Clone(TreeNode n, int offset) {\\n        if (n == null) return null;\\n        TreeNode node = new TreeNode(n.val + offset);\\n        node.left = Clone(n.left, offset);\\n        node.right = Clone(n.right, offset);\\n        return node;\\n    }\\n}\\n```\\n``` Rust []\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn generate_trees(n: i32) -> Vec<Option<Rc<RefCell<TreeNode>>>> {\\n        if n == 0 {\\n            return Vec::new();\\n        }\\n\\n        let mut dp = vec![Vec::new(); (n + 1) as usize];\\n        dp[0].push(None);\\n        for nodes in 1..=n {\\n            let mut trees_per_node = Vec::new();\\n            for root in 1..=nodes {\\n                let left_trees = &dp[(root - 1) as usize];\\n                let right_trees = &dp[(nodes - root) as usize];\\n                for left_tree in left_trees {\\n                    for right_tree in right_trees {\\n                        let root_node = Some(Rc::new(RefCell::new(TreeNode::new(root))));\\n                        root_node.as_ref().unwrap().borrow_mut().left = left_tree.clone();\\n                        root_node.as_ref().unwrap().borrow_mut().right = Solution::clone(right_tree.clone(), root);\\n                        trees_per_node.push(root_node);\\n                    }\\n                }\\n            }\\n            dp[nodes as usize] = trees_per_node;\\n        }\\n        dp[n as usize].clone()\\n    }\\n\\n    fn clone(tree: Option<Rc<RefCell<TreeNode>>>, offset: i32) -> Option<Rc<RefCell<TreeNode>>> {\\n        tree.map(|node| {\\n            Rc::new(RefCell::new(TreeNode {\\n                val: node.borrow().val + offset,\\n                left: Solution::clone(node.borrow().left.clone(), offset),\\n                right: Solution::clone(node.borrow().right.clone(), offset),\\n            }))\\n        })\\n    }\\n}\\n```\\n``` Go []\\nvar generateTrees = function(n) {\\n    if (n === 0) return [];\\n\\n    const dp = Array.from({ length: n + 1 }, () => []);\\n    dp[0].push(null);\\n    for (let nodes = 1; nodes <= n; nodes++) {\\n        for (let root = 1; root <= nodes; root++) {\\n            for (const left_tree of dp[root - 1]) {\\n                for (const right_tree of dp[nodes - root]) {\\n                    const root_node = new TreeNode(root);\\n                    root_node.left = left_tree;\\n                    root_node.right = clone(right_tree, root);\\n                    dp[nodes].push(root_node);\\n                }\\n            }\\n        }\\n    }\\n    return dp[n];\\n};\\n\\nfunction clone(n, offset) {\\n    if (n === null) return null;\\n    const node = new TreeNode(n.val + offset);\\n    node.left = clone(n.left, offset);\\n    node.right = clone(n.right, offset);\\n    return node;\\n}\\n```\\n\\nThe time and space complexity for both approaches are the same. The $$ O(\\\\frac{4^n}{n\\\\sqrt{n}}) $$ complexity arises from the Catalan number, which gives the number of BSTs for a given \\\\( n \\\\).\\n\\nI hope you find this solution helpful in understanding how to generate all structurally unique Binary Search Trees (BSTs) for a given number n. If you have any further questions or need additional clarifications, please don\\'t hesitate to ask. If you understood the solution and found it beneficial, please consider giving it an upvote. Happy coding, and may your coding journey be filled with success and satisfaction! \\uD83D\\uDE80\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB\\uD83D\\uDC69\\u200D\\uD83D\\uDCBB",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def generateTrees(self, n: int):\\n        def generate_trees(start, end):\\n            if start > end:\\n                return [None,]\\n            \\n            all_trees = []\\n            for i in range(start, end + 1):\\n                left_trees = generate_trees(start, i - 1)\\n                right_trees = generate_trees(i + 1, end)\\n                \\n                for l in left_trees:\\n                    for r in right_trees:\\n                        current_tree = TreeNode(i)\\n                        current_tree.left = l\\n                        current_tree.right = r\\n                        all_trees.append(current_tree)\\n            \\n            return all_trees\\n        \\n        return generate_trees(1, n) if n else []\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        return n ? generate_trees(1, n) : vector<TreeNode*>();\\n    }\\n\\nprivate:\\n    vector<TreeNode*> generate_trees(int start, int end) {\\n        if (start > end) return {nullptr};\\n\\n        vector<TreeNode*> all_trees;\\n        for (int i = start; i <= end; i++) {\\n            vector<TreeNode*> left_trees = generate_trees(start, i - 1);\\n            vector<TreeNode*> right_trees = generate_trees(i + 1, end);\\n\\n            for (TreeNode* l : left_trees) {\\n                for (TreeNode* r : right_trees) {\\n                    TreeNode* current_tree = new TreeNode(i);\\n                    current_tree->left = l;\\n                    current_tree->right = r;\\n                    all_trees.push_back(current_tree);\\n                }\\n            }\\n        }\\n        return all_trees;\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        return n > 0 ? generate_trees(1, n) : new ArrayList<>();\\n    }\\n\\n    private List<TreeNode> generate_trees(int start, int end) {\\n        List<TreeNode> all_trees = new ArrayList<>();\\n        if (start > end) {\\n            all_trees.add(null);\\n            return all_trees;\\n        }\\n\\n        for (int i = start; i <= end; i++) {\\n            List<TreeNode> left_trees = generate_trees(start, i - 1);\\n            List<TreeNode> right_trees = generate_trees(i + 1, end);\\n\\n            for (TreeNode l : left_trees) {\\n                for (TreeNode r : right_trees) {\\n                    TreeNode current_tree = new TreeNode(i);\\n                    current_tree.left = l;\\n                    current_tree.right = r;\\n                    all_trees.add(current_tree);\\n                }\\n            }\\n        }\\n        return all_trees;\\n    }\\n}\\n```\n``` JavaScript []\\nvar generateTrees = function(n) {\\n    if (n === 0) return [];\\n\\n    function generate_trees(start, end) {\\n        if (start > end) return [null];\\n\\n        const all_trees = [];\\n        for (let i = start; i <= end; i++) {\\n            const left_trees = generate_trees(start, i - 1);\\n            const right_trees = generate_trees(i + 1, end);\\n\\n            for (const l of left_trees) {\\n                for (const r of right_trees) {\\n                    const current_tree = new TreeNode(i);\\n                    current_tree.left = l;\\n                    current_tree.right = r;\\n                    all_trees.push(current_tree);\\n                }\\n            }\\n        }\\n        return all_trees;\\n    }\\n\\n    return generate_trees(1, n);\\n};\\n```\n``` C# []\\npublic class Solution {\\n    public IList<TreeNode> GenerateTrees(int n) {\\n        return n > 0 ? GenerateTrees(1, n) : new List<TreeNode>();\\n    }\\n\\n    private IList<TreeNode> GenerateTrees(int start, int end) {\\n        if (start > end) return new List<TreeNode> {null};\\n\\n        var all_trees = new List<TreeNode>();\\n        for (int i = start; i <= end; i++) {\\n            var left_trees = GenerateTrees(start, i - 1);\\n            var right_trees = GenerateTrees(i + 1, end);\\n\\n            foreach (var l in left_trees) {\\n                foreach (var r in right_trees) {\\n                    var current_tree = new TreeNode(i, l, r);\\n                    all_trees.Add(current_tree);\\n                }\\n            }\\n        }\\n        return all_trees;\\n    }\\n}\\n```\n``` Rust []\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn generate_trees(n: i32) -> Vec<Option<Rc<RefCell<TreeNode>>>> {\\n        if n == 0 {\\n            return Vec::new();\\n        }\\n        Self::generate(1, n)\\n    }\\n\\n    fn generate(start: i32, end: i32) -> Vec<Option<Rc<RefCell<TreeNode>>>> {\\n        if start > end {\\n            return vec![None];\\n        }\\n\\n        let mut all_trees = Vec::new();\\n        for i in start..=end {\\n            let left_trees = Self::generate(start, i - 1);\\n            let right_trees = Self::generate(i + 1, end);\\n\\n            for l in &left_trees {\\n                for r in &right_trees {\\n                    let current_tree = Some(Rc::new(RefCell::new(TreeNode::new(i))));\\n                    current_tree.as_ref().unwrap().borrow_mut().left = l.clone();\\n                    current_tree.as_ref().unwrap().borrow_mut().right = r.clone();\\n                    all_trees.push(current_tree);\\n                }\\n            }\\n        }\\n        all_trees\\n    }\\n}\\n```\n``` Go []\\nfunc generateTrees(n int) []*TreeNode {\\n\\tif n == 0 {\\n\\t\\treturn []*TreeNode{}\\n\\t}\\n\\treturn generate(1, n)\\n}\\n\\nfunc generate(start, end int) []*TreeNode {\\n\\tif start > end {\\n\\t\\treturn []*TreeNode{nil}\\n\\t}\\n\\n\\tvar allTrees []*TreeNode\\n\\tfor i := start; i <= end; i++ {\\n\\t\\tleftTrees := generate(start, i-1)\\n\\t\\trightTrees := generate(i+1, end)\\n\\n\\t\\tfor _, l := range leftTrees {\\n\\t\\t\\tfor _, r := range rightTrees {\\n\\t\\t\\t\\tcurrentTree := &TreeNode{Val: i, Left: l, Right: r}\\n\\t\\t\\t\\tallTrees = append(allTrees, currentTree)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn allTrees\\n}\\n```\n``` Python []\\nclass Solution:\\n    def generateTrees(self, n: int):\\n        if n == 0:\\n            return []\\n\\n        dp = [[] for _ in range(n + 1)]\\n        dp[0].append(None)\\n        for nodes in range(1, n + 1):\\n            for root in range(1, nodes + 1):\\n                for left_tree in dp[root - 1]:\\n                    for right_tree in dp[nodes - root]:\\n                        root_node = TreeNode(root)\\n                        root_node.left = left_tree\\n                        root_node.right = self.clone(right_tree, root)\\n                        dp[nodes].append(root_node)\\n        return dp[n]\\n    \\n    def clone(self, n: TreeNode, offset: int) -> TreeNode:\\n        if n:\\n            node = TreeNode(n.val + offset)\\n            node.left = self.clone(n.left, offset)\\n            node.right = self.clone(n.right, offset)\\n            return node\\n        return None\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        if (n == 0) return {};\\n\\n        vector<vector<TreeNode*>> dp(n + 1);\\n        dp[0].push_back(nullptr);\\n        for (int nodes = 1; nodes <= n; nodes++) {\\n            for (int root = 1; root <= nodes; root++) {\\n                for (TreeNode* left_tree : dp[root - 1]) {\\n                    for (TreeNode* right_tree : dp[nodes - root]) {\\n                        TreeNode* root_node = new TreeNode(root);\\n                        root_node->left = left_tree;\\n                        root_node->right = clone(right_tree, root);\\n                        dp[nodes].push_back(root_node);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\nprivate:\\n    TreeNode* clone(TreeNode* n, int offset) {\\n        if (n == nullptr) return nullptr;\\n        TreeNode* node = new TreeNode(n->val + offset);\\n        node->left = clone(n->left, offset);\\n        node->right = clone(n->right, offset);\\n        return node;\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        if (n == 0) return new ArrayList<>();\\n\\n        List<TreeNode>[] dp = new ArrayList[n + 1];\\n        dp[0] = new ArrayList<>();\\n        dp[0].add(null);\\n        for (int nodes = 1; nodes <= n; nodes++) {\\n            dp[nodes] = new ArrayList<>();\\n            for (int root = 1; root <= nodes; root++) {\\n                for (TreeNode left_tree : dp[root - 1]) {\\n                    for (TreeNode right_tree : dp[nodes - root]) {\\n                        TreeNode root_node = new TreeNode(root);\\n                        root_node.left = left_tree;\\n                        root_node.right = clone(right_tree, root);\\n                        dp[nodes].add(root_node);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\n    private TreeNode clone(TreeNode n, int offset) {\\n        if (n == null) return null;\\n        TreeNode node = new TreeNode(n.val + offset);\\n        node.left = clone(n.left, offset);\\n        node.right = clone(n.right, offset);\\n        return node;\\n    }\\n}\\n```\n``` JavaScript []\\nvar generateTrees = function(n) {\\n    if (n === 0) return [];\\n\\n    const dp = Array.from({ length: n + 1 }, () => []);\\n    dp[0].push(null);\\n    for (let nodes = 1; nodes <= n; nodes++) {\\n        for (let root = 1; root <= nodes; root++) {\\n            for (const left_tree of dp[root - 1]) {\\n                for (const right_tree of dp[nodes - root]) {\\n                    const root_node = new TreeNode(root);\\n                    root_node.left = left_tree;\\n                    root_node.right = clone(right_tree, root);\\n                    dp[nodes].push(root_node);\\n                }\\n            }\\n        }\\n    }\\n    return dp[n];\\n};\\n\\nfunction clone(n, offset) {\\n    if (n === null) return null;\\n    const node = new TreeNode(n.val + offset);\\n    node.left = clone(n.left, offset);\\n    node.right = clone(n.right, offset);\\n    return node;\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public IList<TreeNode> GenerateTrees(int n) {\\n        if (n == 0) return new List<TreeNode>();\\n\\n        var dp = new List<TreeNode>[n + 1];\\n        dp[0] = new List<TreeNode> { null };\\n        for (int nodes = 1; nodes <= n; nodes++) {\\n            dp[nodes] = new List<TreeNode>();\\n            for (int root = 1; root <= nodes; root++) {\\n                foreach (var left_tree in dp[root - 1]) {\\n                    foreach (var right_tree in dp[nodes - root]) {\\n                        TreeNode root_node = new TreeNode(root);\\n                        root_node.left = left_tree;\\n                        root_node.right = Clone(right_tree, root);\\n                        dp[nodes].Add(root_node);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\n    private TreeNode Clone(TreeNode n, int offset) {\\n        if (n == null) return null;\\n        TreeNode node = new TreeNode(n.val + offset);\\n        node.left = Clone(n.left, offset);\\n        node.right = Clone(n.right, offset);\\n        return node;\\n    }\\n}\\n```\n``` Rust []\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn generate_trees(n: i32) -> Vec<Option<Rc<RefCell<TreeNode>>>> {\\n        if n == 0 {\\n            return Vec::new();\\n        }\\n\\n        let mut dp = vec![Vec::new(); (n + 1) as usize];\\n        dp[0].push(None);\\n        for nodes in 1..=n {\\n            let mut trees_per_node = Vec::new();\\n            for root in 1..=nodes {\\n                let left_trees = &dp[(root - 1) as usize];\\n                let right_trees = &dp[(nodes - root) as usize];\\n                for left_tree in left_trees {\\n                    for right_tree in right_trees {\\n                        let root_node = Some(Rc::new(RefCell::new(TreeNode::new(root))));\\n                        root_node.as_ref().unwrap().borrow_mut().left = left_tree.clone();\\n                        root_node.as_ref().unwrap().borrow_mut().right = Solution::clone(right_tree.clone(), root);\\n                        trees_per_node.push(root_node);\\n                    }\\n                }\\n            }\\n            dp[nodes as usize] = trees_per_node;\\n        }\\n        dp[n as usize].clone()\\n    }\\n\\n    fn clone(tree: Option<Rc<RefCell<TreeNode>>>, offset: i32) -> Option<Rc<RefCell<TreeNode>>> {\\n        tree.map(|node| {\\n            Rc::new(RefCell::new(TreeNode {\\n                val: node.borrow().val + offset,\\n                left: Solution::clone(node.borrow().left.clone(), offset),\\n                right: Solution::clone(node.borrow().right.clone(), offset),\\n            }))\\n        })\\n    }\\n}\\n```\n``` Go []\\nvar generateTrees = function(n) {\\n    if (n === 0) return [];\\n\\n    const dp = Array.from({ length: n + 1 }, () => []);\\n    dp[0].push(null);\\n    for (let nodes = 1; nodes <= n; nodes++) {\\n        for (let root = 1; root <= nodes; root++) {\\n            for (const left_tree of dp[root - 1]) {\\n                for (const right_tree of dp[nodes - root]) {\\n                    const root_node = new TreeNode(root);\\n                    root_node.left = left_tree;\\n                    root_node.right = clone(right_tree, root);\\n                    dp[nodes].push(root_node);\\n                }\\n            }\\n        }\\n    }\\n    return dp[n];\\n};\\n\\nfunction clone(n, offset) {\\n    if (n === null) return null;\\n    const node = new TreeNode(n.val + offset);\\n    node.left = clone(n.left, offset);\\n    node.right = clone(n.right, offset);\\n    return node;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31592,
                "title": "recursive-python-solution",
                "content": "    class Solution(object):\\n        def generateTrees(self, n):\\n            \"\"\"\\n            :type n: int\\n            :rtype: List[TreeNode]\\n            \"\"\"\\n            if n == 0:\\n                return [[]]\\n            return self.dfs(1, n+1)\\n            \\n        def dfs(self, start, end):\\n            if start == end:\\n                return None\\n            result = []\\n            for i in xrange(start, end):\\n                for l in self.dfs(start, i) or [None]:\\n                    for r in self.dfs(i+1, end) or [None]:\\n                        node = TreeNode(i)\\n                        node.left, node.right  = l, r\\n                        result.append(node)\\n            return result\\n\\nUse start/end instead of actual nodes to bosst the program.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def generateTrees(self, n):\\n            \"\"\"\\n            :type n: int\\n            :rtype: List[TreeNode]\\n            \"\"\"\\n            if n == 0:\\n                return [[]]\\n            return self.dfs(1, n+1)\\n            \\n        def dfs(self, start, end):\\n            if start == end:\\n                return None\\n            result = []\\n            for i in xrange(start, end):\\n                for l in self.dfs(start, i) or [None]:\\n                    for r in self.dfs(i+1, end) or [None]:\\n                        node = TreeNode(i)\\n                        node.left, node.right  = l, r\\n                        result.append(node)\\n            return result\\n\\nUse start/end instead of actual nodes to bosst the program.",
                "codeTag": "Java"
            },
            {
                "id": 1440883,
                "title": "small-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n, int s = 1) {\\n        vector<TreeNode*> ans;\\n        if(n < s)\\n            return {nullptr};\\n\\t\\t\\t\\n\\t\\t// Consider every number in range [s,n] as root \\n        for(int i=s; i<=n; i++) {\\n\\t\\t\\n\\t\\t\\t// generate all possible trees in range [s,i)\\n            for(auto left: generateTrees(i-1, s)) {\\n\\t\\t\\t\\n\\t\\t\\t\\t// generate all possible trees in range (i,e]\\n                for(auto right: generateTrees(n, i+1))\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// make new trees with i as the root\\n                    ans.push_back(new TreeNode(i, left, right));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n, int s = 1) {\\n        vector<TreeNode*> ans;\\n        if(n < s)\\n            return {nullptr};\\n\\t\\t\\t\\n\\t\\t// Consider every number in range [s,n] as root \\n        for(int i=s; i<=n; i++) {\\n\\t\\t\\n\\t\\t\\t// generate all possible trees in range [s,i)\\n            for(auto left: generateTrees(i-1, s)) {\\n\\t\\t\\t\\n\\t\\t\\t\\t// generate all possible trees in range (i,e]\\n                for(auto right: generateTrees(n, i+1))\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// make new trees with i as the root\\n                    ans.push_back(new TreeNode(i, left, right));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31552,
                "title": "java-dp-solution-and-brute-force-recursive-solution",
                "content": "The first method that came to mind was the brute force solution as below. \\n\\n     public List<TreeNode> generateTrees(int n) {\\n         return generateTrees(1,n);\\n     }\\n    \\n    public List<TreeNode> generateTrees(int start,int end){             \\n        List<TreeNode> trees = new ArrayList<TreeNode>();\\n        if(start>end){  trees.add(null); return trees;}\\n    \\n        for(int rootValue=start;rootValue<=end;rootValue++){\\n            List<TreeNode> leftSubTrees=generateTrees(start,rootValue-1);\\n            List<TreeNode> rightSubTrees=generateTrees(rootValue+1,end);\\n    \\n            for(TreeNode leftSubTree:leftSubTrees){\\n                for(TreeNode rightSubTree:rightSubTrees){\\n                    TreeNode root=new TreeNode(rootValue);\\n                    root.left=leftSubTree;\\n                    root.right=rightSubTree;\\n                    trees.add(root);\\n                }\\n            }\\n        }\\n        return trees;\\n    }\\n\\n\\n\\nThen @6219221 reminded me it is unnecessary to create the BSTs with all brand new nodes. \\nAssume you have a list of all BSTs with values from 1 to n-1, every possible way to insert value n only involves changing the right tree (root inclusive) because n is always greater than root.val and the left subtree structure is fixed. So all we gotta do is to create a new copy of the right part of the tree and point the new root.left to the original left subtree. This way we reuse the left tree, which saves time and space.\\n\\nHow to insert Node n into the right subtree?\\nGiven any BST on the n - 1 level, it will be only valid to put n on the root.right, root.right.right or root.right.....right locations and then move the right subtree of n.right...right to become the left child of n, in order to keep n on the right-most position as the greatest value in the tree.\\n\\nHere is my implementation. Note that I do the dp from [n] back to [n to 1]. Therefore all the right subtree structures are fixed and new values are inserted into the left side, opposite to making BSTs from 1 to [1 to n].\\n\\n        public List<TreeNode> generateTrees(int n) {\\n            List<TreeNode> res = new ArrayList<>();\\n            res.add(null);\\n            for(; n > 0; n--) {\\n                List<TreeNode> next = new ArrayList<>();\\n                for(TreeNode node: res) {\\n                    //the special case when Node(n) is root of new tree\\n                    TreeNode root = new TreeNode(n); \\n                    root.right = node;\\n                    next.add(root);\\n                   //while loop inserts new value to every possible position into the left tree side\\n                    while(node != null) {\\n                        TreeNode cRoot = new TreeNode(root.right.val);\\n                        //clone left subtree\\n                        cRoot.left = copyTree(root.right.left);\\n                        //reusing - point new root.right to the original right subtree\\n                        cRoot.right = root.right.right;\\n                        //curr is the cutoff node whose right child will be replaced by the new n \\n                        TreeNode curr = getValNode(cRoot, node.val); \\n                        //place n as curr's right child, make curr's original right child as the left child of n.\\n                        TreeNode tmp = curr.left;\\n                        curr.left = new TreeNode(n);\\n                        curr.left.right = tmp;\\n\\n                        next.add(cRoot);\\n                        node = node.left;\\n                    }\\n                }\\n                res = next;\\n            }\\n            return res;\\n        }\\n        private TreeNode getValNode(TreeNode n, int val) { //find the cutoff node in the new tree\\n            while(n != null) {\\n                if(n.val == val) break;\\n                n = n.left;\\n            }\\n            return n;\\n        }\\n\\n        private TreeNode copyTree(TreeNode root) { //clone the right subtree\\n            if(root == null) return null;\\n            TreeNode cRoot = new TreeNode(root.val);\\n            cRoot.left = copyTree(root.left);\\n            cRoot.right = copyTree(root.right);\\n            return cRoot;\\n        }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "The first method that came to mind was the brute force solution as below. \\n\\n     public List<TreeNode> generateTrees(int n) {\\n         return generateTrees(1,n);\\n     }\\n    \\n    public List<TreeNode> generateTrees(int start,int end){             \\n        List<TreeNode> trees = new ArrayList<TreeNode>();\\n        if(start>end){  trees.add(null); return trees;}\\n    \\n        for(int rootValue=start;rootValue<=end;rootValue++){\\n            List<TreeNode> leftSubTrees=generateTrees(start,rootValue-1);\\n            List<TreeNode> rightSubTrees=generateTrees(rootValue+1,end);\\n    \\n            for(TreeNode leftSubTree:leftSubTrees){\\n                for(TreeNode rightSubTree:rightSubTrees){\\n                    TreeNode root=new TreeNode(rootValue);\\n                    root.left=leftSubTree;\\n                    root.right=rightSubTree;\\n                    trees.add(root);\\n                }\\n            }\\n        }\\n        return trees;\\n    }\\n\\n\\n\\nThen @6219221 reminded me it is unnecessary to create the BSTs with all brand new nodes. \\nAssume you have a list of all BSTs with values from 1 to n-1, every possible way to insert value n only involves changing the right tree (root inclusive) because n is always greater than root.val and the left subtree structure is fixed. So all we gotta do is to create a new copy of the right part of the tree and point the new root.left to the original left subtree. This way we reuse the left tree, which saves time and space.\\n\\nHow to insert Node n into the right subtree?\\nGiven any BST on the n - 1 level, it will be only valid to put n on the root.right, root.right.right or root.right.....right locations and then move the right subtree of n.right...right to become the left child of n, in order to keep n on the right-most position as the greatest value in the tree.\\n\\nHere is my implementation. Note that I do the dp from [n] back to [n to 1]. Therefore all the right subtree structures are fixed and new values are inserted into the left side, opposite to making BSTs from 1 to [1 to n].\\n\\n        public List<TreeNode> generateTrees(int n) {\\n            List<TreeNode> res = new ArrayList<>();\\n            res.add(null);\\n            for(; n > 0; n--) {\\n                List<TreeNode> next = new ArrayList<>();\\n                for(TreeNode node: res) {\\n                    //the special case when Node(n) is root of new tree\\n                    TreeNode root = new TreeNode(n); \\n                    root.right = node;\\n                    next.add(root);\\n                   //while loop inserts new value to every possible position into the left tree side\\n                    while(node != null) {\\n                        TreeNode cRoot = new TreeNode(root.right.val);\\n                        //clone left subtree\\n                        cRoot.left = copyTree(root.right.left);\\n                        //reusing - point new root.right to the original right subtree\\n                        cRoot.right = root.right.right;\\n                        //curr is the cutoff node whose right child will be replaced by the new n \\n                        TreeNode curr = getValNode(cRoot, node.val); \\n                        //place n as curr's right child, make curr's original right child as the left child of n.\\n                        TreeNode tmp = curr.left;\\n                        curr.left = new TreeNode(n);\\n                        curr.left.right = tmp;\\n\\n                        next.add(cRoot);\\n                        node = node.left;\\n                    }\\n                }\\n                res = next;\\n            }\\n            return res;\\n        }\\n        private TreeNode getValNode(TreeNode n, int val) { //find the cutoff node in the new tree\\n            while(n != null) {\\n                if(n.val == val) break;\\n                n = n.left;\\n            }\\n            return n;\\n        }\\n\\n        private TreeNode copyTree(TreeNode root) { //clone the right subtree\\n            if(root == null) return null;\\n            TreeNode cRoot = new TreeNode(root.val);\\n            cRoot.left = copyTree(root.left);\\n            cRoot.right = copyTree(root.right);\\n            return cRoot;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 703236,
                "title": "c-simple-and-short",
                "content": "***Plz upvote if you like it***\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> helper(int start,int end) {\\n        vector<TreeNode*> v;\\n        if(start > end) {\\n            v.push_back(NULL);\\n            return v;\\n        }\\n        for(int i = start; i <= end; i++){\\n            auto left = helper(start,i-1);\\n            auto right = helper(i+1,end);\\n            for(auto l : left) {\\n                for(auto r : right){\\n                    TreeNode* newNode = new TreeNode(i, l, r);\\n                    v.push_back(newNode);\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n == 0) \\n            return vector<TreeNode*>();\\n        auto ans = helper(1,n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> helper(int start,int end) {\\n        vector<TreeNode*> v;\\n        if(start > end) {\\n            v.push_back(NULL);\\n            return v;\\n        }\\n        for(int i = start; i <= end; i++){\\n            auto left = helper(start,i-1);\\n            auto right = helper(i+1,end);\\n            for(auto l : left) {\\n                for(auto r : right){\\n                    TreeNode* newNode = new TreeNode(i, l, r);\\n                    v.push_back(newNode);\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n == 0) \\n            return vector<TreeNode*>();\\n        auto ans = helper(1,n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1023791,
                "title": "java-recursion-along-with-recursion-tree-figure-explanation",
                "content": "```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        if (n == 0) {\\n            return new ArrayList<>();\\n        }\\n        return helper(1, n);\\n    }\\n    \\n    private List<TreeNode> helper(int lo, int hi) {\\n        List<TreeNode> result = new ArrayList<>();\\n        //base case\\n        if (lo > hi) {\\n            result.add(null);\\n            return result;\\n        }\\n        \\n        //subproblem to reach boootm\\n        for (int i = lo; i <= hi; i++) {\\n            List<TreeNode> left = helper(lo, i - 1);\\n            List<TreeNode> right = helper(i + 1, hi);\\n            //reconstruct tree from bottom to up\\n            for (TreeNode l : left) {\\n                for (TreeNode r : right) {\\n                    TreeNode root = new TreeNode(i);\\n                    root.left = l;\\n                    root.right = r;\\n                    result.add(root);\\n                }\\n            }\\n        }\\n        //return list of root to last layer\\n        return result;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/12370c10-2924-4705-9b20-4c93fe83945d_1611015319.6731772.png)\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        if (n == 0) {\\n            return new ArrayList<>();\\n        }\\n        return helper(1, n);\\n    }\\n    \\n    private List<TreeNode> helper(int lo, int hi) {\\n        List<TreeNode> result = new ArrayList<>();\\n        //base case\\n        if (lo > hi) {\\n            result.add(null);\\n            return result;\\n        }\\n        \\n        //subproblem to reach boootm\\n        for (int i = lo; i <= hi; i++) {\\n            List<TreeNode> left = helper(lo, i - 1);\\n            List<TreeNode> right = helper(i + 1, hi);\\n            //reconstruct tree from bottom to up\\n            for (TreeNode l : left) {\\n                for (TreeNode r : right) {\\n                    TreeNode root = new TreeNode(i);\\n                    root.left = l;\\n                    root.right = r;\\n                    result.add(root);\\n                }\\n            }\\n        }\\n        //return list of root to last layer\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31575,
                "title": "24ms-c-easy-understanding-solution",
                "content": "    class Solution {\\n    private:\\n        vector<TreeNode*> helper(int start, int end){\\n            vector<TreeNode*> res;\\n            if(start > end) {\\n                res.push_back(NULL);\\n                return res;\\n            }\\n            for(int i = start; i <= end; i++){\\n                vector<TreeNode*> lefts = helper(start, i - 1);\\n                vector<TreeNode*> rights = helper(i + 1, end);\\n                for(int j = 0; j < (int)lefts.size(); j++){\\n                    for(int k = 0; k < (int)rights.size(); k++){\\n                        TreeNode* root = new TreeNode(i);\\n                        root->left = lefts[j];\\n                        root->right = rights[k];\\n                        res.push_back(root);\\n                    }\\n                }\\n            }\\n            return res;\\n        }\\n    public:\\n        vector<TreeNode*> generateTrees(int n) {\\n            if(n == 0) return vector<TreeNode*>(0);\\n            return helper(1,n);\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    private:\\n        vector<TreeNode*> helper(int start, int end){\\n            vector<TreeNode*> res;\\n            if(start > end) {\\n                res.push_back(NULL);\\n                return res;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1440190,
                "title": "c-python-simple-and-short-recursive-solutions-with-explanation",
                "content": "**Idea:**\\nWe will use a recursive helper function that recieves a range (within n) and returns all subtrees in that range.\\nWe have a few cases:\\n1. if `start > end`, which is not supposed to happen, we return a list that contains only a null.\\n2. if `start == end` it means we reached a leaf and we will return a list containing a tree that has only that node.\\n3. Otherwise:\\nfor each option of root, we get all possible subtrees with that root for `left` and `right` children.\\nThen for each possible pair of `left` and `right` we add to the result a new tree.\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> rec(int start, int end) {\\n        vector<TreeNode*> res;\\n        if (start > end) return {NULL};\\n        \\n        if (start == end) return {new TreeNode(start)};\\n        \\n        for (int i = start; i <= end; i++) {\\n            vector<TreeNode*> left = rec(start, i-1), right = rec(i+1, end);\\n            \\n            for (auto l : left)\\n                for (auto r : right)\\n                    res.push_back(new TreeNode(i, l, r));\\n        }\\n        return res;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        vector<TreeNode*> res = rec(1, n);\\n        return res;\\n    }\\n};\\n```\\n**Python:**\\n```\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        def rec(start, end):\\n\\t\\t\\n            if start > end:\\n                return [None]\\n\\t\\t\\t\\t\\n            if start == end:\\n                return [TreeNode(start)]\\n            ret_list = []\\n\\t\\t\\t\\n            for i in range(start, end+1):\\n                left = rec(start, i-1)\\n                right = rec(i+1, end)\\n                for pair in product(left, right):\\n                    ret_list.append(TreeNode(i, pair[0], pair[1]))\\n        \\n            return ret_list\\n        \\n        res = rec(1,n)\\n        return res\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> rec(int start, int end) {\\n        vector<TreeNode*> res;\\n        if (start > end) return {NULL};\\n        \\n        if (start == end) return {new TreeNode(start)};\\n        \\n        for (int i = start; i <= end; i++) {\\n            vector<TreeNode*> left = rec(start, i-1), right = rec(i+1, end);\\n            \\n            for (auto l : left)\\n                for (auto r : right)\\n                    res.push_back(new TreeNode(i, l, r));\\n        }\\n        return res;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        vector<TreeNode*> res = rec(1, n);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        def rec(start, end):\\n\\t\\t\\n            if start > end:\\n                return [None]\\n\\t\\t\\t\\t\\n            if start == end:\\n                return [TreeNode(start)]\\n            ret_list = []\\n\\t\\t\\t\\n            for i in range(start, end+1):\\n                left = rec(start, i-1)\\n                right = rec(i+1, end)\\n                for pair in product(left, right):\\n                    ret_list.append(TreeNode(i, pair[0], pair[1]))\\n        \\n            return ret_list\\n        \\n        res = rec(1,n)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31609,
                "title": "simple-python-solution",
                "content": "    class Solution(object):\\n    def generateTrees(self, n):\\n        return self.cal([i for i in xrange(1, n+1)])\\n        \\n    def cal(self, lst):\\n        if not lst: return [None]\\n        res=[]\\n        for i in xrange(len(lst)):\\n            for left in self.cal(lst[:i]):\\n                for right in self.cal(lst[i+1:]):\\n                    node, node.left, node.right=TreeNode(lst[i]), left, right\\n                    res+=[node]\\n        return res",
                "solutionTags": [],
                "code": "    class Solution(object):\\n    def generateTrees(self, n):\\n        return self.cal([i for i in xrange(1, n+1)])\\n        \\n    def cal(self, lst):\\n        if not lst: return [None]\\n        res=[]\\n        for i in xrange(len(lst)):\\n            for left in self.cal(lst[:i]):\\n                for right in self.cal(lst[i+1:]):\\n                    node, node.left, node.right=TreeNode(lst[i]), left, right\\n                    res+=[node]\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 167055,
                "title": "c-recursive-and-iterative-solutions-beats-100-and-doesn-t-create-frankenstein-trees",
                "content": "# TL;DR\\n### Recursive solution\\n```cpp\\n  /// Returns all insert orderings of [first, last) that will produce a unique tree when inserted into a tree\\n  std::vector<std::vector<int>> unique_orderings(int first, int last)\\n  {\\n    std::vector<std::vector<int>> ret;\\n    if (first == last) {\\n      ret.emplace_back();\\n    } else {\\n      // For each possible root digit\\n      for (int digit = first; digit != last; ++digit) {\\n        \\n        // Get all the orderings to build unique left branches\\n        auto left_orders = unique_orderings(first, digit);\\n        \\n        // Get all the orderings to build unique right branches\\n        auto right_orders = unique_orderings(digit + 1, last);\\n        \\n        // Combine all the possibilities together\\n        for (auto& left : left_orders) {\\n          for (auto& right : right_orders) {\\n            ret.emplace_back(1, digit);\\n            ret.reserve(left.size() + 1 + right.size());\\n            std::copy(left.begin(), left.end(), std::back_inserter(ret.back()));\\n            std::copy(right.begin(), right.end(), std::back_inserter(ret.back()));\\n          }\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n\\n  vector<TreeNode*> generateTrees(int n) {\\n    std::vector<TreeNode*> ret;\\n    \\n    // Get the orderings that will produce unique unique tress using the numbers from [1, n]\\n    // For example, when n is 3, will return [[1, 2, 3], [1, 3, 2], [2, 1, 3], [3, 1, 2], [3, 2, 1]].\\n    // Each ordering will produce a unique tree when inserted from left to right.\\n    auto orderings = unique_orderings(1, n + 1);\\n    if (!orderings.front().empty()) {\\n      std::fill_n(std::back_inserter(ret), orderings.size(), nullptr);\\n      \\n      // Make each unique tree by inserting the digits of each orderings into a tree.\\n      for (int i = 0; i < orderings.size(); ++i) {\\n        for (auto digit : orderings[i]) {\\n          TreeNode** curr = &ret[i];\\n          while (*curr) {\\n            curr = (digit <= (**curr).val) ? &((**curr).left): &((**curr).right);\\n          }\\n          *curr = new TreeNode(digit);\\n        }\\n      }\\n    }\\n    \\n    return ret;\\n  }\\n```\\n### Iterative solution. Using cache for maximum speed\\n```cpp\\n  vector<TreeNode*> generateTrees(int n) {\\n    std::vector<TreeNode*> ret;\\n    \\n    std::vector<std::vector<std::vector<int>>> patterns(1, std::vector<std::vector<int>>(1));\\n   \\n    // Create a template for each level from 0 to n - 1. This lists all the unique patterns for that level. If you take a pattern \\n    // and create a tree by inserting the digits in order, you will produce a unique tree that no other pattern creates\\n    for (int lvl = 1; lvl < n; ++lvl) {\\n      patterns.emplace_back();\\n      // For each possible root digit\\n      for (int digit = 1; digit <= lvl; ++digit) {\\n        // For each possible unique pattern that can be made using digits less than the root\\n        for (auto& left : patterns[digit - 1]) {\\n          // For each possible unique pattern that can be made using digits greater than the root\\n          for (auto& right : patterns[lvl - digit]) {\\n            patterns[lvl].emplace_back();\\n            patterns[lvl].reserve(left.size() + 1 + right.size());\\n            auto it = std::back_inserter(patterns.back().back());\\n            // Add root\\n            *it++ = digit;\\n            \\n            // Add left branch pattern\\n            it = std::copy(left.begin(), left.end(), it);\\n            \\n            // Add right branch pattern, but offsetting the numbers by the root value\\n            it = std::generate_n(it, right.size(), [digit, r_it = right.begin()] () mutable { return digit + *r_it++; });\\n          }\\n        }\\n      }\\n    }\\n\\n    // We now have a template for each level 0 to n - 1. Time to build level n, but this time we must create it as\\n    // actual trees\\n    \\n    // For each possible root digit\\n    for (int digit = 1; digit <= n; ++digit) {\\n      // For each possible unique pattern that can be made using digits less than the root\\n      for (auto& left : patterns[digit - 1]) {\\n        // For each possible unique pattern that can be made using digits greater than the root\\n        for (auto& right : patterns[n - digit]) {\\n          ret.emplace_back(new TreeNode(digit));\\n   \\n          // Create left branch\\n          for (int left_digit : left) {\\n            TreeNode** curr = &ret.back()->left;\\n            while (*curr) {\\n              curr = (left_digit <= (**curr).val) ? &((**curr).left): &((**curr).right);\\n            }\\n            *curr = new TreeNode(left_digit);\\n          }\\n          \\n          // Create right branch, remembering to add the offset\\n          for (int right_digit : right) {\\n            TreeNode** curr = &ret.back()->right;\\n            while (*curr) {\\n              curr = (right_digit + digit <= (**curr).val) ? &((**curr).left): &((**curr).right);\\n            }\\n            *curr = new TreeNode(right_digit + digit);\\n          }\\n        }\\n      }\\n    } \\n    \\n    return ret;\\n  }\\n```\\n# Details\\n### Background\\nMy solutions are an expansion of [unique binary search tree](https://leetcode.com/problems/unique-binary-search-trees/discuss/166725/c++-extremely-short-stl-solution.-4-lines.-With-detailed-explaination). The idea being that if you choose a root node _r_, then there are [1, _r_) numbers to use to build the left branch and [_r_ + 1, _n_) numbers to use to build the right branch. Focusing on the left branch for the moment, it is obviously just the same problem except instead of needing to use the numbers [1, _n_], we now use [1, _r_), where _r_ <= _n_. So we have a decreasing, recursive problem. The right branch is actually exactly the same, just with a different offset, starting position.\\n\\nSo lets get down to how to use this.\\n### Recursive solution\\nA convient way to represent a unique tree is by indicating the order of numbers to be inserted. For example [1, 2, 3] would be;\\n```\\n1\\n \\\\\\n  2\\n   \\\\\\n    3\\n```\\n[3, 1, 2, 4]\\n```\\n  3\\n / \\\\\\n1   4\\n \\\\\\n  2\\n```\\nThis is convient because from above, we will be dividing the numbers around a root. What we\\'re aiming for is a list of numbers like `[root, <left branch>, <right branch>]`. This is what the recursive function `unique_orderings` is producing. Given a range [first, last), return all the unique insert orderings for that range. All that is left to do after that is actually build all the trees to return.\\n\\n**Note: After I implemented my solution, I checked out other peoples solutions. I found a large number of them were returning trees directly from their recursive function. These would then be directly linked to. This results in trees _sharing_ branches. Not something I expect the question is looking for.**\\n```cpp\\nstd::vector<TreeNode*> branches(...)\\n{\\n  ...\\n  auto left = branches(...);\\n  auto right = branches(...);\\n  for (auto l : left) {\\n    for (auto r : right) {\\n      TreeNode* root = new TreeNode(root_val);\\n      root->left = l;    // Every tree points to the _same_ left branch\\n      root->right = r;   // Every tree points to the _same_ right branch\\n      ...\\n    }\\n  }\\n}\\n```\\nIt\\'s hard to visualise, in ascii, but the trees [3, 2, 1, 5, 4] and [3, 2, 1, 4, 5] will be linked very stranglely. Using the same node for node _2_.\\n```\\n   -------\\\\\\n  /\\t   \\\\\\n /   3      \\\\    3\\n \\\\ /   \\\\     ---/ \\\\\\n  2     5          4\\n /     /            \\\\\\n1      4             5\\n```\\t \\nThis is why I choose to build the trees outside of the recursive function. To avoid such an a quirk.\\n### Iterative\\nYou will notice that the recursive solution actually generates the same branches over and over again. To make it faster, we could instead cache our branches, so every time the branch options for [1, 4) was requested, the same values would be returned. We can go further than this though. Consider the case of a _n_ = 7 and using a root node of 4. The left branch with use the range [1, 4), while the right branch will need to use [5, 8). The number of options will be the same for both branches as they have the same, just the starting number will be different. My solution uses this to build all branches from a _pattern_, where each node value is offset to adjust for different start values.\\n\\nThe solution is very fast while still being relatively memory efficent. Once again it doesn\\'t create Frankenstein trees that are share branches.\\n\\n**Please give me a thumbs up if this helped explain this problem for you**",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```cpp\\n  /// Returns all insert orderings of [first, last) that will produce a unique tree when inserted into a tree\\n  std::vector<std::vector<int>> unique_orderings(int first, int last)\\n  {\\n    std::vector<std::vector<int>> ret;\\n    if (first == last) {\\n      ret.emplace_back();\\n    } else {\\n      // For each possible root digit\\n      for (int digit = first; digit != last; ++digit) {\\n        \\n        // Get all the orderings to build unique left branches\\n        auto left_orders = unique_orderings(first, digit);\\n        \\n        // Get all the orderings to build unique right branches\\n        auto right_orders = unique_orderings(digit + 1, last);\\n        \\n        // Combine all the possibilities together\\n        for (auto& left : left_orders) {\\n          for (auto& right : right_orders) {\\n            ret.emplace_back(1, digit);\\n            ret.reserve(left.size() + 1 + right.size());\\n            std::copy(left.begin(), left.end(), std::back_inserter(ret.back()));\\n            std::copy(right.begin(), right.end(), std::back_inserter(ret.back()));\\n          }\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n\\n  vector<TreeNode*> generateTrees(int n) {\\n    std::vector<TreeNode*> ret;\\n    \\n    // Get the orderings that will produce unique unique tress using the numbers from [1, n]\\n    // For example, when n is 3, will return [[1, 2, 3], [1, 3, 2], [2, 1, 3], [3, 1, 2], [3, 2, 1]].\\n    // Each ordering will produce a unique tree when inserted from left to right.\\n    auto orderings = unique_orderings(1, n + 1);\\n    if (!orderings.front().empty()) {\\n      std::fill_n(std::back_inserter(ret), orderings.size(), nullptr);\\n      \\n      // Make each unique tree by inserting the digits of each orderings into a tree.\\n      for (int i = 0; i < orderings.size(); ++i) {\\n        for (auto digit : orderings[i]) {\\n          TreeNode** curr = &ret[i];\\n          while (*curr) {\\n            curr = (digit <= (**curr).val) ? &((**curr).left): &((**curr).right);\\n          }\\n          *curr = new TreeNode(digit);\\n        }\\n      }\\n    }\\n    \\n    return ret;\\n  }\\n```\n```cpp\\n  vector<TreeNode*> generateTrees(int n) {\\n    std::vector<TreeNode*> ret;\\n    \\n    std::vector<std::vector<std::vector<int>>> patterns(1, std::vector<std::vector<int>>(1));\\n   \\n    // Create a template for each level from 0 to n - 1. This lists all the unique patterns for that level. If you take a pattern \\n    // and create a tree by inserting the digits in order, you will produce a unique tree that no other pattern creates\\n    for (int lvl = 1; lvl < n; ++lvl) {\\n      patterns.emplace_back();\\n      // For each possible root digit\\n      for (int digit = 1; digit <= lvl; ++digit) {\\n        // For each possible unique pattern that can be made using digits less than the root\\n        for (auto& left : patterns[digit - 1]) {\\n          // For each possible unique pattern that can be made using digits greater than the root\\n          for (auto& right : patterns[lvl - digit]) {\\n            patterns[lvl].emplace_back();\\n            patterns[lvl].reserve(left.size() + 1 + right.size());\\n            auto it = std::back_inserter(patterns.back().back());\\n            // Add root\\n            *it++ = digit;\\n            \\n            // Add left branch pattern\\n            it = std::copy(left.begin(), left.end(), it);\\n            \\n            // Add right branch pattern, but offsetting the numbers by the root value\\n            it = std::generate_n(it, right.size(), [digit, r_it = right.begin()] () mutable { return digit + *r_it++; });\\n          }\\n        }\\n      }\\n    }\\n\\n    // We now have a template for each level 0 to n - 1. Time to build level n, but this time we must create it as\\n    // actual trees\\n    \\n    // For each possible root digit\\n    for (int digit = 1; digit <= n; ++digit) {\\n      // For each possible unique pattern that can be made using digits less than the root\\n      for (auto& left : patterns[digit - 1]) {\\n        // For each possible unique pattern that can be made using digits greater than the root\\n        for (auto& right : patterns[n - digit]) {\\n          ret.emplace_back(new TreeNode(digit));\\n   \\n          // Create left branch\\n          for (int left_digit : left) {\\n            TreeNode** curr = &ret.back()->left;\\n            while (*curr) {\\n              curr = (left_digit <= (**curr).val) ? &((**curr).left): &((**curr).right);\\n            }\\n            *curr = new TreeNode(left_digit);\\n          }\\n          \\n          // Create right branch, remembering to add the offset\\n          for (int right_digit : right) {\\n            TreeNode** curr = &ret.back()->right;\\n            while (*curr) {\\n              curr = (right_digit + digit <= (**curr).val) ? &((**curr).left): &((**curr).right);\\n            }\\n            *curr = new TreeNode(right_digit + digit);\\n          }\\n        }\\n      }\\n    } \\n    \\n    return ret;\\n  }\\n```\n```\\n1\\n \\\\\\n  2\\n   \\\\\\n    3\\n```\n```\\n  3\\n / \\\\\\n1   4\\n \\\\\\n  2\\n```\n```cpp\\nstd::vector<TreeNode*> branches(...)\\n{\\n  ...\\n  auto left = branches(...);\\n  auto right = branches(...);\\n  for (auto l : left) {\\n    for (auto r : right) {\\n      TreeNode* root = new TreeNode(root_val);\\n      root->left = l;    // Every tree points to the _same_ left branch\\n      root->right = r;   // Every tree points to the _same_ right branch\\n      ...\\n    }\\n  }\\n}\\n```\n```\\n   -------\\\\\\n  /\\t   \\\\\\n /   3      \\\\    3\\n \\\\ /   \\\\     ---/ \\\\\\n  2     5          4\\n /     /            \\\\\\n1      4             5\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3865536,
                "title": "ex-amazon-explains-a-solution-with-a-video-python-javascript-java-and-c",
                "content": "# Intuition\\nThere 3 important things. \\n\\nOne is we try to create subtrees with some range between start(minimum) and end(maximum) value.\\n\\nSecond is calculation of the range. left range should be between start and current root - 1 as end value because all values of left side must be smaller than current root. right range should be between current root + 1 and end becuase all values on the right side should be greater than current root value.\\n\\nThrid is we call the same funtion recursively, so it\\'s good idea to keep results of current start and end, so that we can use the results later. It\\'s time saving.\\n\\n---\\n\\n# Solution Video\\n## *** Please upvote for this article. *** \\n\\nhttps://youtu.be/5G-Kwx8Lm5Q\\n\\n# Subscribe to my channel from here. I have 240 videos as of August 5th\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\n---\\n\\n# Approach\\nThis is based on Python. Other might be different a bit.\\n\\n1. Define a class `Solution` containing a method `generateTrees` which takes an integer `n` as input and returns a list of optional `TreeNode` objects.\\n\\n2. Check if `n` is 0. If it is, return an empty list since there are no possible trees with 0 nodes.\\n\\n3. Initialize an empty dictionary called `memo`. This dictionary will be used to store previously computed results for specific ranges of values to avoid redundant calculations.\\n\\n4. Define an inner function called `generate_trees` that takes two parameters: `start` and `end`, which represent the range of values for which binary search trees need to be generated.\\n\\n5. Inside the `generate_trees` function:\\n   - Check if the tuple `(start, end)` exists as a key in the `memo` dictionary. If it does, return the corresponding value from the `memo` dictionary.\\n   - Initialize an empty list called `trees`. This list will store the generated trees for the current range.\\n   - If `start` is greater than `end`, append `None` to the `trees` list, indicating an empty subtree, and return the `trees` list.\\n   - Loop through each value `root_val` in the range `[start, end]` (inclusive):\\n     - Recursively call the `generate_trees` function for the left subtree with the range `[start, root_val - 1]` and store the result in `left_trees`.\\n     - Recursively call the `generate_trees` function for the right subtree with the range `[root_val + 1, end]` and store the result in `right_trees`.\\n     - Nested loop through each combination of `left_tree` in `left_trees` and `right_tree` in `right_trees`:\\n       - Create a new `TreeNode` instance with `root_val` as the value, `left_tree` as the left child, and `right_tree` as the right child.\\n       - Append the new `TreeNode` to the `trees` list.\\n   - Store the `trees` list in the `memo` dictionary with the key `(start, end)`.\\n   - Return the `trees` list.\\n\\n6. Outside the `generate_trees` function, call `generate_trees` initially with arguments `1` and `n` to generate all unique binary search trees with `n` nodes.\\n\\n7. Return the list of generated trees.\\n\\nThis algorithm generates all possible unique binary search trees with `n` nodes by considering different ranges of root values and recursively generating left and right subtrees for each possible root value. The `memo` dictionary is used to store previously computed results, reducing redundant calculations and improving the efficiency of the algorithm.\\n\\n# Complexity\\n- Time complexity: O(C(n))\\nC is Catalan number.\\n\\n- Space complexity: O(C(n))\\nC is Catalan number.\\n\\nCatalan number\\nhttps://en.wikipedia.org/wiki/Catalan_number\\n\\n```python []\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:\\n        if n == 0:\\n            return []\\n        \\n        memo = {}\\n\\n        def generate_trees(start, end):\\n            if (start, end) in memo:\\n                return memo[(start, end)]\\n            \\n            trees = []\\n            if start > end:\\n                trees.append(None)\\n                return trees\\n            \\n            for root_val in range(start, end + 1):\\n                left_trees = generate_trees(start, root_val - 1)\\n                right_trees = generate_trees(root_val + 1, end)\\n            \\n                for left_tree in left_trees:\\n                    for right_tree in right_trees:\\n                        root = TreeNode(root_val, left_tree, right_tree)\\n                        trees.append(root)\\n            \\n            memo[(start, end)] = trees\\n            return trees\\n\\n        return generate_trees(1, n)\\n```\\n```javascript []\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {number} n\\n * @return {TreeNode[]}\\n */\\nvar generateTrees = function(n) {\\n   if (n === 0) {\\n        return [];\\n    }\\n    \\n    const memo = new Map();\\n\\n    function generateTreesHelper(start, end) {\\n        if (memo.has(`${start}-${end}`)) {\\n            return memo.get(`${start}-${end}`);\\n        }\\n        \\n        const trees = [];\\n        if (start > end) {\\n            trees.push(null);\\n            return trees;\\n        }\\n        \\n        for (let rootVal = start; rootVal <= end; rootVal++) {\\n            const leftTrees = generateTreesHelper(start, rootVal - 1);\\n            const rightTrees = generateTreesHelper(rootVal + 1, end);\\n            \\n            for (const leftTree of leftTrees) {\\n                for (const rightTree of rightTrees) {\\n                    const root = new TreeNode(rootVal, leftTree, rightTree);\\n                    trees.push(root);\\n                }\\n            }\\n        }\\n        \\n        memo.set(`${start}-${end}`, trees);\\n        return trees;\\n    }\\n\\n    return generateTreesHelper(1, n);    \\n};\\n```\\n```java []\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        if (n == 0) {\\n            return new ArrayList<>();\\n        }\\n        \\n        Map<String, List<TreeNode>> memo = new HashMap<>();\\n\\n        return generateTreesHelper(1, n, memo);        \\n    }\\n\\n    private List<TreeNode> generateTreesHelper(int start, int end, Map<String, List<TreeNode>> memo) {\\n        String key = start + \"-\" + end;\\n        if (memo.containsKey(key)) {\\n            return memo.get(key);\\n        }\\n        \\n        List<TreeNode> trees = new ArrayList<>();\\n        if (start > end) {\\n            trees.add(null);\\n            return trees;\\n        }\\n        \\n        for (int rootVal = start; rootVal <= end; rootVal++) {\\n            List<TreeNode> leftTrees = generateTreesHelper(start, rootVal - 1, memo);\\n            List<TreeNode> rightTrees = generateTreesHelper(rootVal + 1, end, memo);\\n            \\n            for (TreeNode leftTree : leftTrees) {\\n                for (TreeNode rightTree : rightTrees) {\\n                    TreeNode root = new TreeNode(rootVal);\\n                    root.left = leftTree;\\n                    root.right = rightTree;\\n                    trees.add(root);\\n                }\\n            }\\n        }\\n        \\n        memo.put(key, trees);\\n        return trees;\\n    }\\n}\\n```\\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        if (n == 0) {\\n            return vector<TreeNode*>();\\n        }\\n        \\n        unordered_map<string, vector<TreeNode*>> memo;\\n\\n        return generateTreesHelper(1, n, memo);        \\n    }\\n\\nprivate:\\n    vector<TreeNode*> generateTreesHelper(int start, int end, unordered_map<string, vector<TreeNode*>>& memo) {\\n        string key = to_string(start) + \"-\" + to_string(end);\\n        if (memo.find(key) != memo.end()) {\\n            return memo[key];\\n        }\\n        \\n        vector<TreeNode*> trees;\\n        if (start > end) {\\n            trees.push_back(nullptr);\\n            return trees;\\n        }\\n        \\n        for (int rootVal = start; rootVal <= end; rootVal++) {\\n            vector<TreeNode*> leftTrees = generateTreesHelper(start, rootVal - 1, memo);\\n            vector<TreeNode*> rightTrees = generateTreesHelper(rootVal + 1, end, memo);\\n            \\n            for (TreeNode* leftTree : leftTrees) {\\n                for (TreeNode* rightTree : rightTrees) {\\n                    TreeNode* root = new TreeNode(rootVal);\\n                    root->left = leftTree;\\n                    root->right = rightTree;\\n                    trees.push_back(root);\\n                }\\n            }\\n        }\\n        \\n        memo[key] = trees;\\n        return trees;\\n    }    \\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:\\n        if n == 0:\\n            return []\\n        \\n        memo = {}\\n\\n        def generate_trees(start, end):\\n            if (start, end) in memo:\\n                return memo[(start, end)]\\n            \\n            trees = []\\n            if start > end:\\n                trees.append(None)\\n                return trees\\n            \\n            for root_val in range(start, end + 1):\\n                left_trees = generate_trees(start, root_val - 1)\\n                right_trees = generate_trees(root_val + 1, end)\\n            \\n                for left_tree in left_trees:\\n                    for right_tree in right_trees:\\n                        root = TreeNode(root_val, left_tree, right_tree)\\n                        trees.append(root)\\n            \\n            memo[(start, end)] = trees\\n            return trees\\n\\n        return generate_trees(1, n)\\n```\n```javascript []\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {number} n\\n * @return {TreeNode[]}\\n */\\nvar generateTrees = function(n) {\\n   if (n === 0) {\\n        return [];\\n    }\\n    \\n    const memo = new Map();\\n\\n    function generateTreesHelper(start, end) {\\n        if (memo.has(`${start}-${end}`)) {\\n            return memo.get(`${start}-${end}`);\\n        }\\n        \\n        const trees = [];\\n        if (start > end) {\\n            trees.push(null);\\n            return trees;\\n        }\\n        \\n        for (let rootVal = start; rootVal <= end; rootVal++) {\\n            const leftTrees = generateTreesHelper(start, rootVal - 1);\\n            const rightTrees = generateTreesHelper(rootVal + 1, end);\\n            \\n            for (const leftTree of leftTrees) {\\n                for (const rightTree of rightTrees) {\\n                    const root = new TreeNode(rootVal, leftTree, rightTree);\\n                    trees.push(root);\\n                }\\n            }\\n        }\\n        \\n        memo.set(`${start}-${end}`, trees);\\n        return trees;\\n    }\\n\\n    return generateTreesHelper(1, n);    \\n};\\n```\n```java []\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        if (n == 0) {\\n            return new ArrayList<>();\\n        }\\n        \\n        Map<String, List<TreeNode>> memo = new HashMap<>();\\n\\n        return generateTreesHelper(1, n, memo);        \\n    }\\n\\n    private List<TreeNode> generateTreesHelper(int start, int end, Map<String, List<TreeNode>> memo) {\\n        String key = start + \"-\" + end;\\n        if (memo.containsKey(key)) {\\n            return memo.get(key);\\n        }\\n        \\n        List<TreeNode> trees = new ArrayList<>();\\n        if (start > end) {\\n            trees.add(null);\\n            return trees;\\n        }\\n        \\n        for (int rootVal = start; rootVal <= end; rootVal++) {\\n            List<TreeNode> leftTrees = generateTreesHelper(start, rootVal - 1, memo);\\n            List<TreeNode> rightTrees = generateTreesHelper(rootVal + 1, end, memo);\\n            \\n            for (TreeNode leftTree : leftTrees) {\\n                for (TreeNode rightTree : rightTrees) {\\n                    TreeNode root = new TreeNode(rootVal);\\n                    root.left = leftTree;\\n                    root.right = rightTree;\\n                    trees.add(root);\\n                }\\n            }\\n        }\\n        \\n        memo.put(key, trees);\\n        return trees;\\n    }\\n}\\n```\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        if (n == 0) {\\n            return vector<TreeNode*>();\\n        }\\n        \\n        unordered_map<string, vector<TreeNode*>> memo;\\n\\n        return generateTreesHelper(1, n, memo);        \\n    }\\n\\nprivate:\\n    vector<TreeNode*> generateTreesHelper(int start, int end, unordered_map<string, vector<TreeNode*>>& memo) {\\n        string key = to_string(start) + \"-\" + to_string(end);\\n        if (memo.find(key) != memo.end()) {\\n            return memo[key];\\n        }\\n        \\n        vector<TreeNode*> trees;\\n        if (start > end) {\\n            trees.push_back(nullptr);\\n            return trees;\\n        }\\n        \\n        for (int rootVal = start; rootVal <= end; rootVal++) {\\n            vector<TreeNode*> leftTrees = generateTreesHelper(start, rootVal - 1, memo);\\n            vector<TreeNode*> rightTrees = generateTreesHelper(rootVal + 1, end, memo);\\n            \\n            for (TreeNode* leftTree : leftTrees) {\\n                for (TreeNode* rightTree : rightTrees) {\\n                    TreeNode* root = new TreeNode(rootVal);\\n                    root->left = leftTree;\\n                    root->right = rightTree;\\n                    trees.push_back(root);\\n                }\\n            }\\n        }\\n        \\n        memo[key] = trees;\\n        return trees;\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1440118,
                "title": "python-divide-and-conquer-with-dp-explained",
                "content": "We can use `dp` technique here, where in `dp[i][j]` we keep all possible trees from numbers `i ... j`. We can also keep only one dimensional `dp`, but then we need to `clone` trees, adding the same values to all elements. However, number of trees is exponential, and I think it is not worth to make this optimization from `O(n^2)` to `O(n)` memory, because problem can be solved for only small `n <= 50`.\\n\\n#### Complexity\\nTime and space complexity is `O(C_{2n}^n)` approximately, because we have Catalan number of trees.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def generateTrees(self, n):\\n        def dp(i, j):\\n            if i > j: return [None]\\n            ans = []\\n            \\n            for k in range(i, j + 1):\\n                for lft, rgh in product(dp(i, k-1), dp(k+1, j)):\\n                    root = ListNode(k)\\n                    root.left = lft\\n                    root.right = rgh\\n                    ans.append(root)            \\n            return ans\\n        \\n        return dp(1, n)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Divide and Conquer",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def generateTrees(self, n):\\n        def dp(i, j):\\n            if i > j: return [None]\\n            ans = []\\n            \\n            for k in range(i, j + 1):\\n                for lft, rgh in product(dp(i, k-1), dp(k+1, j)):\\n                    root = ListNode(k)\\n                    root.left = lft\\n                    root.right = rgh\\n                    ans.append(root)            \\n            return ans\\n        \\n        return dp(1, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 759719,
                "title": "c-very-easy-to-understand-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<TreeNode*> generateBST(int begin, int end)\\n    {\\n        vector<TreeNode*>V;\\n        \\n        if(begin>end)\\n        {\\n            V.push_back(NULL);\\n            return V;\\n        }\\n        \\n        for(int i=begin; i<=end; i++)\\n        {\\n            vector<TreeNode*>left =  generateBST(begin, i-1);\\n            vector<TreeNode*>right =  generateBST(i+1,end);\\n            \\n            for(auto l:left)\\n            {\\n                for(auto r:right)\\n                {\\n                    TreeNode* root = new TreeNode();\\n                    root->val = i;\\n                    root->left = l;\\n                    root->right = r;\\n                    V.push_back(root);\\n                }\\n            }\\n            \\n        }\\n        return V;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        \\n        vector<TreeNode*>V;\\n        if(n==0) return V;\\n        \\n        return generateBST(1,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<TreeNode*> generateBST(int begin, int end)\\n    {\\n        vector<TreeNode*>V;\\n        \\n        if(begin>end)\\n        {\\n            V.push_back(NULL);\\n            return V;\\n        }\\n        \\n        for(int i=begin; i<=end; i++)\\n        {\\n            vector<TreeNode*>left =  generateBST(begin, i-1);\\n            vector<TreeNode*>right =  generateBST(i+1,end);\\n            \\n            for(auto l:left)\\n            {\\n                for(auto r:right)\\n                {\\n                    TreeNode* root = new TreeNode();\\n                    root->val = i;\\n                    root->left = l;\\n                    root->right = r;\\n                    V.push_back(root);\\n                }\\n            }\\n            \\n        }\\n        return V;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        \\n        vector<TreeNode*>V;\\n        if(n==0) return V;\\n        \\n        return generateBST(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31597,
                "title": "30-ms-c-solution",
                "content": "    /**\\n     * Definition for binary tree\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        vector<TreeNode *> generateTrees(int n) {\\n            return helper(1,n);\\n        }\\n        \\n        vector<TreeNode*> helper(int s, int e) {\\n            if (s > e) {\\n                 return vector<TreeNode*>(1,NULL);\\n            }\\n            \\n            vector<TreeNode*> result;\\n            for (int i=s; i <= e; ++i) {\\n                vector<TreeNode*> left, right;\\n                    left = helper(s,i-1);\\n                    right = helper(i+1,e);\\n                    for (int j = 0; j < left.size(); ++j) {\\n                        for (int k = 0; k < right.size(); ++k) {\\n                            TreeNode* root = new TreeNode(i);\\n                            root->left = left[j];\\n                            root->right = right[k];\\n                            result.push_back(root);\\n                        }\\n                    }\\n            }\\n            \\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<TreeNode *> generateTrees(int n) {\\n            return helper(1,n);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 31535,
                "title": "20ms-c-top-down-dp-solution",
                "content": "a bottom up solution looks much better, but I find it's also a little bit harder to understand. Top-down solution is straight forward,\\n\\n   \\n\\n    vector<TreeNode*> generateTrees(int n) {\\n        vector<TreeNode*> ret;\\n        vector<vector<vector<TreeNode*>>> dp(n,vector<vector<TreeNode*>>(n));\\n        helper(1,n,ret,dp);\\n        return ret;\\n    }\\n    \\n    void helper(int start, int end, vector<TreeNode*> &ret,vector<vector<vector<TreeNode*>>> &dp) {\\n        if (start > end) {\\n            ret.push_back(NULL); return;\\n        }\\n        if (!dp[start-1][end-1].empty())  {\\n            ret = dp[start-1][end-1]; return;\\n        }\\n        for (int i = start; i <= end; ++i) {\\n            vector<TreeNode*> left, right;\\n            helper(start, i-1,left,dp);\\n            helper(i+1,end,right,dp);\\n            for(int j = 0; j < left.size(); ++j) {\\n                for (int k = 0; k < right.size(); ++k) {\\n                    TreeNode* node = new TreeNode(i);\\n                    node->left = left[j];\\n                    node->right = right[k];\\n                    ret.push_back(node);\\n                }\\n            }\\n        }\\n        dp[start-1][end-1] = ret;\\n    }",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "a bottom up solution looks much better, but I find it's also a little bit harder to understand. Top-down solution is straight forward,\\n\\n   \\n\\n    vector<TreeNode*> generateTrees(int n) {\\n        vector<TreeNode*> ret;\\n        vector<vector<vector<TreeNode*>>> dp(n,vector<vector<TreeNode*>>(n));\\n        helper(1,n,ret,dp);\\n        return ret;\\n    }\\n    \\n    void helper(int start, int end, vector<TreeNode*> &ret,vector<vector<vector<TreeNode*>>> &dp) {\\n        if (start > end) {\\n            ret.push_back(NULL); return;\\n        }\\n        if (!dp[start-1][end-1].empty())  {\\n            ret = dp[start-1][end-1]; return;\\n        }\\n        for (int i = start; i <= end; ++i) {\\n            vector<TreeNode*> left, right;\\n            helper(start, i-1,left,dp);\\n            helper(i+1,end,right,dp);\\n            for(int j = 0; j < left.size(); ++j) {\\n                for (int k = 0; k < right.size(); ++k) {\\n                    TreeNode* node = new TreeNode(i);\\n                    node->left = left[j];\\n                    node->right = right[k];\\n                    ret.push_back(node);\\n                }\\n            }\\n        }\\n        dp[start-1][end-1] = ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 536107,
                "title": "python-recursive-solution-explained-beats-99-56",
                "content": "The basic idea is to recursively split the conceptual array `[1, ..., n]` in half. During every split, make a new root node for every different combination of left/right subtree structures. For the time complexity of this algorithm, please check the comment below.\\n```python\\ndef generateTrees(self, n: int) -> List[TreeNode]:\\n    def generate(l, r):   # split between [l, r)\\n        if l == r:\\n            return [None]\\n        nodes = []\\n        for i in range(l, r):\\n            for lchild in generate(l, i):\\n                for rchild in generate(i+1, r):\\n                    node = TreeNode(i+1)   # +1 to convert the index to the actual value\\n                    node.left = lchild\\n                    node.right = rchild\\n                    nodes.append(node)\\n        return nodes\\n    return generate(0, n) if n else []\\n```\\nVote up if you find this helpful, thanks!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```python\\ndef generateTrees(self, n: int) -> List[TreeNode]:\\n    def generate(l, r):   # split between [l, r)\\n        if l == r:\\n            return [None]\\n        nodes = []\\n        for i in range(l, r):\\n            for lchild in generate(l, i):\\n                for rchild in generate(i+1, r):\\n                    node = TreeNode(i+1)   # +1 to convert the index to the actual value\\n                    node.left = lchild\\n                    node.right = rchild\\n                    nodes.append(node)\\n        return nodes\\n    return generate(0, n) if n else []\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2503720,
                "title": "6-liner-c-recursive",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n, int s = 1) {\\n        vector<TreeNode*> ans;\\n        if(n < s) return {nullptr};                              \\n         for(int i=s; i<=n; i++) {                \\t                 // Consider every number in range [s,n] as root  \\n            for(auto left: generateTrees(i-1, s)) {                  // generate all possible trees in range [s,i)\\n                for(auto right: generateTrees(n, i+1))               // generate all possible trees in range (i,e]\\n                    ans.push_back(new TreeNode(i, left, right));     // make new trees with i as the root\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please Upvote \\nthank you**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n, int s = 1) {\\n        vector<TreeNode*> ans;\\n        if(n < s) return {nullptr};                              \\n         for(int i=s; i<=n; i++) {                \\t                 // Consider every number in range [s,n] as root  \\n            for(auto left: generateTrees(i-1, s)) {                  // generate all possible trees in range [s,i)\\n                for(auto right: generateTrees(n, i+1))               // generate all possible trees in range (i,e]\\n                    ans.push_back(new TreeNode(i, left, right));     // make new trees with i as the root\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1441066,
                "title": "unique-binary-search-trees-ii-recursion-w-approach-c-python",
                "content": "**Idea**:\\n* We will use a recursive helper function that recieves a range `(within n)` and returns all subtrees in that range.\\n* We have a few cases:\\n\\t* if `start > end`, which is not supposed to happen, we return a list that contains only a `null`.\\n\\t* if `start == end` it means we reached a `leaf` and we will return a `list containing a tree` that has only that node.\\n\\t* Otherwise:\\n\\t\\t* for each option of root, we get `all possible subtrees` with that root for left and right children. Then for each possible pair of left and right we add to the result a new tree.\\n\\n**Solution**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> rec(int start, int end) {\\n        vector<TreeNode*> res;\\n        if (start > end) return {NULL};\\n        if (start == end) return {new TreeNode(start)};\\n        for (int i = start; i <= end; i++) {\\n            vector<TreeNode*> left = rec(start, i-1), right = rec(i+1, end);\\n            for (auto l : left)\\n                for (auto r : right)\\n                    res.push_back(new TreeNode(i, l, r));\\n        }\\n        return res;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        vector<TreeNode*> res = rec(1, n);\\n        return res;\\n    }\\n};\\n```\\n`In Python`\\n```\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        def rec(start, end):\\n\\t\\t\\n            if start > end:\\n                return [None]\\n\\t\\t\\t\\t\\n            if start == end:\\n                return [TreeNode(start)]\\n            ret_list = []\\n\\t\\t\\t\\n            for i in range(start, end+1):\\n                left = rec(start, i-1)\\n                right = rec(i+1, end)\\n                for pair in product(left, right):\\n                    ret_list.append(TreeNode(i, pair[0], pair[1]))\\n        \\n            return ret_list\\n        \\n        res = rec(1,n)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> rec(int start, int end) {\\n        vector<TreeNode*> res;\\n        if (start > end) return {NULL};\\n        if (start == end) return {new TreeNode(start)};\\n        for (int i = start; i <= end; i++) {\\n            vector<TreeNode*> left = rec(start, i-1), right = rec(i+1, end);\\n            for (auto l : left)\\n                for (auto r : right)\\n                    res.push_back(new TreeNode(i, l, r));\\n        }\\n        return res;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        vector<TreeNode*> res = rec(1, n);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        def rec(start, end):\\n\\t\\t\\n            if start > end:\\n                return [None]\\n\\t\\t\\t\\t\\n            if start == end:\\n                return [TreeNode(start)]\\n            ret_list = []\\n\\t\\t\\t\\n            for i in range(start, end+1):\\n                left = rec(start, i-1)\\n                right = rec(i+1, end)\\n                for pair in product(left, right):\\n                    ret_list.append(TreeNode(i, pair[0], pair[1]))\\n        \\n            return ret_list\\n        \\n        res = rec(1,n)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1566092,
                "title": "c-easy-recursive-solution",
                "content": "Let us start by understanding how many unique BSTs are possible for keys 1-n.\\n\\nTo form a structurally unique BST of n nodes, we can take any of the 1-n keys as the root. Let us take key i (1<=i<=n) as the root. Now the left subtrees can contain nodes with keys 1 to i-1 (Since all the values in the left subtree must be smaller than that in the root) and the right subtrees can contain nodes with keys i+1 to n. \\nFor example if n=3, i can be 1 (or) 2 (or) 3\\n```\\n  1           1                2                3               3\\n\\t\\\\           \\\\              / \\\\              /               /\\n\\t 3            2           1   3            2               1\\n    /              \\\\                         /                  \\\\\\n   2                3                      1                     2\\n          i = 1               i = 2                    i = 3   \\n```\\nSo, to construct a BST with a given root, we need to know the number of possible left subtrees(LSTs) and number of possible right subtrees(RSTs).\\nLet the no. possible LSTs be *numTrees(i-1)* and no. of possible BSTs be *numTrees(n-i)* . So the total no. of BSTs possible when i is the root are : *numTrees(i-1) * numTrees(n-i)*\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> constructTrees(int start, int end){\\n        vector<TreeNode*> result;\\n\\t\\t\\n        if(start==end){\\n            TreeNode *root = new TreeNode(start);\\n            result.push_back(root);\\n            return result;\\n        }\\n        if(start>end){\\n            result.push_back(NULL);\\n            return result;\\n        }\\n        \\n        for(int i=start;i<=end;i++){\\n            vector<TreeNode*> leftTrees = constructTrees(start, i-1); /*Total no. of LSTs possible when  is the root*/\\n            vector<TreeNode*> rightTrees = constructTrees(i+1, end); \\n\\t\\t\\t/*Join each left and right subtree to the root to form different BSTs*/\\n            for(auto l: leftTrees){\\n                for(auto r: rightTrees){\\n                    TreeNode *root = new TreeNode(i); \\n                    root->left = l;\\n                    root->right = r;\\n                    result.push_back(root);  /*Add the root of the resulting BST each time to the vector result*/\\n                }\\n            }\\n        }\\n        return result;\\n        \\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        return constructTrees(1, n);\\n    }\\n};\\n```\\n\\nPlease upvote if u like the solution\\uD83D\\uDE4F\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n  1           1                2                3               3\\n\\t\\\\           \\\\              / \\\\              /               /\\n\\t 3            2           1   3            2               1\\n    /              \\\\                         /                  \\\\\\n   2                3                      1                     2\\n          i = 1               i = 2                    i = 3   \\n```\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> constructTrees(int start, int end){\\n        vector<TreeNode*> result;\\n\\t\\t\\n        if(start==end){\\n            TreeNode *root = new TreeNode(start);\\n            result.push_back(root);\\n            return result;\\n        }\\n        if(start>end){\\n            result.push_back(NULL);\\n            return result;\\n        }\\n        \\n        for(int i=start;i<=end;i++){\\n            vector<TreeNode*> leftTrees = constructTrees(start, i-1); /*Total no. of LSTs possible when  is the root*/\\n            vector<TreeNode*> rightTrees = constructTrees(i+1, end); \\n\\t\\t\\t/*Join each left and right subtree to the root to form different BSTs*/\\n            for(auto l: leftTrees){\\n                for(auto r: rightTrees){\\n                    TreeNode *root = new TreeNode(i); \\n                    root->left = l;\\n                    root->right = r;\\n                    result.push_back(root);  /*Add the root of the resulting BST each time to the vector result*/\\n                }\\n            }\\n        }\\n        return result;\\n        \\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        return constructTrees(1, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1440312,
                "title": "an-intuitive-explanation-with-diagrams",
                "content": "***BASICS***\\nBST? A node `x` has node `z` to right with value `z>x` and node `y` to the left with `y<x`.\\n\\n![image](https://assets.leetcode.com/users/images/3c9045fe-eaed-456a-a20b-3bcb09a6b4a2_1630574055.9780717.png)\\n\\n***BUILDING THE INTUITION: OBSERVATIONS***\\n- n = 1 case is trivial\\n- n = 2 case suggests\\n\\t- either swapping is important\\n\\t- or, changing the root is\\n![image](https://assets.leetcode.com/users/images/3f9339f0-279e-42fa-80b9-66d0c40b0939_1630574123.1668983.png)\\n\\n- n = 3 shows us:\\n\\t- swapping idea is too complex for > 2 nodes\\n\\t- the root idea works out better, we can **recursively** find the subtrees\\n\\t- there are repeating structures **DP**\\n![image](https://assets.leetcode.com/users/images/1757d47f-d667-4c66-9d4d-cbc0c621b197_1630574306.0539086.png)\\n\\n***SAMPLE CASE***\\nConsider the case: curr is 4. We split into left and right parts - for which we will call a recursive function again. I have considered the right sub-tree case:\\n![image](https://assets.leetcode.com/users/images/0af12d87-261d-4af0-9b5e-1085b58882c7_1630574322.4836857.png)\\n\\nEach recursion returns the total number of BSTs formed.\\n\\n***CODE***\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:\\n        \\n        @lru_cache(None)\\n        def recurse(l, r):\\n            if l > r: return [None]\\n            trees = []\\n            for i in range(l, r+1):\\n                lefts = recurse(l, i-1)\\n                rights = recurse(i+1, r)\\n            \\n                for left in lefts:\\n                    for right in rights:\\n                        tree = TreeNode(i)\\n                        tree.left = left\\n                        tree.right = right\\n                        trees.append(tree)\\n            \\n            return trees\\n        \\n        return recurse(1, n)\\n```\\n\\n**Upvote if this helps! It gives me feedback :)**",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:\\n        \\n        @lru_cache(None)\\n        def recurse(l, r):\\n            if l > r: return [None]\\n            trees = []\\n            for i in range(l, r+1):\\n                lefts = recurse(l, i-1)\\n                rights = recurse(i+1, r)\\n            \\n                for left in lefts:\\n                    for right in rights:\\n                        tree = TreeNode(i)\\n                        tree.left = left\\n                        tree.right = right\\n                        trees.append(tree)\\n            \\n            return trees\\n        \\n        return recurse(1, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31581,
                "title": "sharing-top-down-dp-python-solution-beats-93-33",
                "content": "    def generateTrees(self, n):\\n        \\n        def gen_trees(s, e, memo):\\n            if e < s:\\n                return [None]\\n            ret_list = []\\n            if (s, e) in memo:\\n                return memo[s, e]\\n            for i in range(s, e + 1):\\n                list_left = gen_trees(s, i - 1, memo)\\n                list_right = gen_trees(i + 1, e, memo)\\n                for left in list_left:\\n                    for right in list_right:\\n                        root = TreeNode(i)\\n                        root.left = left\\n                        root.right = right\\n                        ret_list.append(root)\\n            memo[s, e] = ret_list\\n            return ret_list\\n        \\n        if n == 0:\\n            return []\\n        return gen_trees(1, n, {})",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "    def generateTrees(self, n):\\n        \\n        def gen_trees(s, e, memo):\\n            if e < s:\\n                return [None]\\n            ret_list = []\\n            if (s, e) in memo:\\n                return memo[s, e]\\n            for i in range(s, e + 1):\\n                list_left = gen_trees(s, i - 1, memo)\\n                list_right = gen_trees(i + 1, e, memo)\\n                for left in list_left:\\n                    for right in list_right:\\n                        root = TreeNode(i)\\n                        root.left = left\\n                        root.right = right\\n                        ret_list.append(root)\\n            memo[s, e] = ret_list\\n            return ret_list\\n        \\n        if n == 0:\\n            return []\\n        return gen_trees(1, n, {})",
                "codeTag": "Python3"
            },
            {
                "id": 3866363,
                "title": "c-recursion-day-5",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTree(int size,int s,int e) {\\n        if(size==0){\\n            return {NULL};\\n        }\\n        if(size==1){\\n            TreeNode* temp = new TreeNode(s);\\n            return {temp};\\n        }\\n       vector<TreeNode*>ans;\\n        for(int i=s;i<=e;i++){\\n            vector<TreeNode*>v1 = generateTree(i-s,s,i-1);\\n             vector<TreeNode*>v2 = generateTree(e-i,i+1,e);\\n             for(int j=0;j<v1.size();j++){\\n                 for(int k=0;k<v2.size();k++){\\n                     TreeNode* temp = new TreeNode(i);\\n                     temp->left = v1[j];\\n                     temp->right = v2[k];\\n                     ans.push_back(temp);\\n                 }\\n             }   \\n        }\\n        return ans;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        return generateTree(n,1,n);\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/abcf0777-a48c-4c76-ab0a-0c126e6b8ca7_1691226748.0385122.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTree(int size,int s,int e) {\\n        if(size==0){\\n            return {NULL};\\n        }\\n        if(size==1){\\n            TreeNode* temp = new TreeNode(s);\\n            return {temp};\\n        }\\n       vector<TreeNode*>ans;\\n        for(int i=s;i<=e;i++){\\n            vector<TreeNode*>v1 = generateTree(i-s,s,i-1);\\n             vector<TreeNode*>v2 = generateTree(e-i,i+1,e);\\n             for(int j=0;j<v1.size();j++){\\n                 for(int k=0;k<v2.size();k++){\\n                     TreeNode* temp = new TreeNode(i);\\n                     temp->left = v1[j];\\n                     temp->right = v2[k];\\n                     ans.push_back(temp);\\n                 }\\n             }   \\n        }\\n        return ans;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        return generateTree(n,1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865068,
                "title": "beats-100-video-java-c-python",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/4Ca9t6LYRDI\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    Map<Pair<Integer, Integer>, List<TreeNode>> dp; \\n    public List<TreeNode> generateTrees(int n) {\\n        dp = new HashMap<>();\\n        return helper(1, n);\\n    }\\n    \\n    public List<TreeNode> helper(int start, int end) {\\n        List<TreeNode> variations = new ArrayList<>();\\n        if (start > end) {\\n            variations.add(null);\\n            return variations;\\n        }\\n        if (dp.containsKey(new Pair<>(start, end))) {\\n            return dp.get(new Pair<>(start, end));\\n        }\\n        for (int i = start; i <= end; ++i) {\\n            List<TreeNode> leftSubTrees = helper(start, i - 1);\\n            List<TreeNode> rightSubTrees = helper(i + 1, end);\\n            for (TreeNode left: leftSubTrees) {\\n                for (TreeNode right: rightSubTrees) {\\n                    TreeNode root = new TreeNode(i, left, right);\\n                    variations.add(root);\\n                }\\n            }\\n        }\\n        dp.put(new Pair<>(start, end), variations);\\n        return variations;\\n    }   \\n}\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    map<pair<int, int>, vector<TreeNode*>> dp; \\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        return helper(1, n);\\n    }\\n    \\n    vector<TreeNode*> helper(int start, int end) {\\n        vector<TreeNode*> variations;\\n        if (start > end) {\\n            variations.push_back(nullptr);\\n            return variations;\\n        }\\n        if (dp.find(make_pair(start, end)) != dp.end()) {\\n            return dp[make_pair(start, end)];\\n        }\\n        for (int i = start; i <= end; ++i) {\\n            vector<TreeNode*> leftSubTrees = helper(start, i - 1);\\n            vector<TreeNode*> rightSubTrees = helper(i + 1, end);\\n            for (TreeNode* left : leftSubTrees) {\\n                for (TreeNode* right : rightSubTrees) {\\n                    TreeNode* root = new TreeNode(i);\\n                    root->left = left;\\n                    root->right = right;\\n                    variations.push_back(root);\\n                }\\n            }\\n        }\\n        dp[make_pair(start, end)] = variations;\\n        return variations;\\n    }\\n};\\n\\n```\\n\\n```\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        def helper(start, end):\\n            variations = []\\n            if start > end:\\n                variations.append(None)\\n                return variations\\n            if (start, end) in dp:\\n                return dp[(start, end)]\\n            for i in range(start, end + 1):\\n                leftSubTrees = helper(start, i - 1)\\n                rightSubTrees = helper(i + 1, end)\\n                for left in leftSubTrees:\\n                    for right in rightSubTrees:\\n                        root = TreeNode(i)\\n                        root.left = left\\n                        root.right = right\\n                        variations.append(root)\\n            dp[(start, end)] = variations\\n            return variations\\n        \\n        dp = {}\\n        return helper(1, n)\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    Map<Pair<Integer, Integer>, List<TreeNode>> dp; \\n    public List<TreeNode> generateTrees(int n) {\\n        dp = new HashMap<>();\\n        return helper(1, n);\\n    }\\n    \\n    public List<TreeNode> helper(int start, int end) {\\n        List<TreeNode> variations = new ArrayList<>();\\n        if (start > end) {\\n            variations.add(null);\\n            return variations;\\n        }\\n        if (dp.containsKey(new Pair<>(start, end))) {\\n            return dp.get(new Pair<>(start, end));\\n        }\\n        for (int i = start; i <= end; ++i) {\\n            List<TreeNode> leftSubTrees = helper(start, i - 1);\\n            List<TreeNode> rightSubTrees = helper(i + 1, end);\\n            for (TreeNode left: leftSubTrees) {\\n                for (TreeNode right: rightSubTrees) {\\n                    TreeNode root = new TreeNode(i, left, right);\\n                    variations.add(root);\\n                }\\n            }\\n        }\\n        dp.put(new Pair<>(start, end), variations);\\n        return variations;\\n    }   \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    map<pair<int, int>, vector<TreeNode*>> dp; \\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        return helper(1, n);\\n    }\\n    \\n    vector<TreeNode*> helper(int start, int end) {\\n        vector<TreeNode*> variations;\\n        if (start > end) {\\n            variations.push_back(nullptr);\\n            return variations;\\n        }\\n        if (dp.find(make_pair(start, end)) != dp.end()) {\\n            return dp[make_pair(start, end)];\\n        }\\n        for (int i = start; i <= end; ++i) {\\n            vector<TreeNode*> leftSubTrees = helper(start, i - 1);\\n            vector<TreeNode*> rightSubTrees = helper(i + 1, end);\\n            for (TreeNode* left : leftSubTrees) {\\n                for (TreeNode* right : rightSubTrees) {\\n                    TreeNode* root = new TreeNode(i);\\n                    root->left = left;\\n                    root->right = right;\\n                    variations.push_back(root);\\n                }\\n            }\\n        }\\n        dp[make_pair(start, end)] = variations;\\n        return variations;\\n    }\\n};\\n\\n```\n```\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        def helper(start, end):\\n            variations = []\\n            if start > end:\\n                variations.append(None)\\n                return variations\\n            if (start, end) in dp:\\n                return dp[(start, end)]\\n            for i in range(start, end + 1):\\n                leftSubTrees = helper(start, i - 1)\\n                rightSubTrees = helper(i + 1, end)\\n                for left in leftSubTrees:\\n                    for right in rightSubTrees:\\n                        root = TreeNode(i)\\n                        root.left = left\\n                        root.right = right\\n                        variations.append(root)\\n            dp[(start, end)] = variations\\n            return variations\\n        \\n        dp = {}\\n        return helper(1, n)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926204,
                "title": "100-fastest-swift-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    func generateTrees(_ n: Int) -> [TreeNode?] {\\n        var nums: [Int] = []\\n        \\n        func copyNodes(_ node: TreeNode?, _ left: TreeNode?, _ right: TreeNode?) -> TreeNode? {\\n            if node == nil { return nil } \\n            else {\\n                let newNode = TreeNode(node!.val)\\n                newNode.left = copyNodes(left, left?.left, left?.right)\\n                newNode.right = copyNodes(right, right?.left, right?.right)\\n                return newNode\\n            }\\n        }\\n\\n        func generateNodes(_ node: TreeNode?, _ left: [TreeNode?], _ right: [TreeNode?]) -> [TreeNode?] {\\n            let leftCount = left.count > 0 ? left.count : 1\\n            let rightCount = right.count > 0 ? right.count : 1\\n            var res: [TreeNode?] = []\\n            \\n            for i in 0..<leftCount {\\n                let leftNode = left.count > 0 ? left[i] : nil\\n                for j in 0..<rightCount {\\n                    let rightNode = right.count > 0 ? right[j] : nil\\n                    res.append(copyNodes(node, leftNode, rightNode))\\n                }\\n            }\\n            return res\\n        }\\n\\n        func nodes(_ nums: [Int]) -> [TreeNode?] {\\n            if nums.count == 0 { return [] }\\n            var res: [TreeNode?] = []\\n\\n            for (i, num) in nums.enumerated() {\\n                let node = TreeNode(num)\\n                let leftNodes = i > 0 ? nodes(Array(nums[0..<i])) : nodes([])\\n                let rightNodes = i < nums.count - 1 ? nodes(Array(nums[i + 1...nums.count - 1])) : nodes([])\\n                res += generateNodes(node, leftNodes, rightNodes)\\n            }\\n            return res\\n        }\\n        \\n        for num in 1...n { nums.append(num) }\\n        return nodes(nums)\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    func generateTrees(_ n: Int) -> [TreeNode?] {\\n        var nums: [Int] = []\\n        \\n        func copyNodes(_ node: TreeNode?, _ left: TreeNode?, _ right: TreeNode?) -> TreeNode? {\\n            if node == nil { return nil } \\n            else {\\n                let newNode = TreeNode(node!.val)\\n                newNode.left = copyNodes(left, left?.left, left?.right)\\n                newNode.right = copyNodes(right, right?.left, right?.right)\\n                return newNode\\n            }\\n        }\\n\\n        func generateNodes(_ node: TreeNode?, _ left: [TreeNode?], _ right: [TreeNode?]) -> [TreeNode?] {\\n            let leftCount = left.count > 0 ? left.count : 1\\n            let rightCount = right.count > 0 ? right.count : 1\\n            var res: [TreeNode?] = []\\n            \\n            for i in 0..<leftCount {\\n                let leftNode = left.count > 0 ? left[i] : nil\\n                for j in 0..<rightCount {\\n                    let rightNode = right.count > 0 ? right[j] : nil\\n                    res.append(copyNodes(node, leftNode, rightNode))\\n                }\\n            }\\n            return res\\n        }\\n\\n        func nodes(_ nums: [Int]) -> [TreeNode?] {\\n            if nums.count == 0 { return [] }\\n            var res: [TreeNode?] = []\\n\\n            for (i, num) in nums.enumerated() {\\n                let node = TreeNode(num)\\n                let leftNodes = i > 0 ? nodes(Array(nums[0..<i])) : nodes([])\\n                let rightNodes = i < nums.count - 1 ? nodes(Array(nums[i + 1...nums.count - 1])) : nodes([])\\n                res += generateNodes(node, leftNodes, rightNodes)\\n            }\\n            return res\\n        }\\n        \\n        for num in 1...n { nums.append(num) }\\n        return nodes(nums)\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 410074,
                "title": "java-recursion-iteration-solutions-dp-clone-memoization",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/unique-binary-search-trees-ii/)\\nDifficulty: <span class=\"orange\">Medium</span>\\n\\n## Problem\\n\\n> Given an integer `n`, generate all structurally unique BST\\'s (binary search trees) that store values `1 ... n`.\\n\\n**Example:**\\n\\n```java\\nInput: 3\\nOutput:\\n[\\n  [1,null,3,2],\\n  [3,2,null,1],\\n  [3,1,null,null,2],\\n  [2,1,3],\\n  [1,null,2,null,3]\\n]\\nExplanation:\\nThe above output corresponds to the 5 unique BST\\'s shown below:\\n\\n   1         3     3      2      1\\n    \\\\       /     /      / \\\\      \\\\\\n     3     2     1      1   3      2\\n    /     /       \\\\                 \\\\\\n   2     1         2                 3\\n```\\n\\n\\n## Analysis\\n\\n### Recursion\\n\\nIf we directly apply the solution in `96. Unique Binary Search Trees`, we have an incorrect result. Consider the following example.\\n\\n```java\\nn = 5, i = 3\\n2 left nodes:  [1, 2]\\n2 right nodes: [4, 5]\\n\\nn = 10, i = 8\\n7 left nodes:  [1, 2, 3, 4, 5, 6, 7]\\n2 right nodes: [9, 10]\\n```\\n\\nAs you can see, although there are still 2 nodes in the right subtrees, the values are not the same. In the previous approach, it did not handle this situation.\\n\\nSo rather than passing a parameter `n` (number of nodes), we now pass down two parameters `lo` and `hi` indicating the range of values of a tree.\\n\\nFor example, `generateTrees(1, 5)` generate trees whose values range from `1` to `5`, and each of them has a chance to be the root, which also includes the information of number of nodes `n`. Say when the root is `3`, we calculate `generateTrees(1, 2)` and `generateTrees(4, 5)`.\\n\\n**Note:** When `n == 0`, it returns `[]` instead of `[[null]]`.\\n\\n```java\\npublic List<TreeNode> generateTrees(int n) {\\n  if (n == 0) {\\n    return new ArrayList<>();\\n  }\\n  return generateTrees(1, n);\\n}\\n\\nprivate List<TreeNode> generateTrees(int lo, int hi) {\\n  int n = hi - lo + 1;\\n  if (n == 0) {\\n    List<TreeNode> L = new ArrayList<>();\\n    L.add(null);\\n    return L;\\n  }\\n  List<TreeNode> result = new ArrayList<>();\\n  for (int i = lo; i <= hi; ++i) {\\n    List<TreeNode> leftSubtrees = generateTrees(lo, i - 1);\\n    List<TreeNode> rightSubtrees = generateTrees(i + 1, hi);\\n    for (TreeNode leftSub : leftSubtrees) {\\n      for (TreeNode rightSub : rightSubtrees) {\\n        TreeNode newTree = new TreeNode(i);\\n        newTree.left = leftSub;\\n        newTree.right = rightSub;\\n        result.add(newTree);\\n      }\\n    }\\n  }\\n  return result;\\n}\\n```\\n\\n**Time:** It is at most bounded by `O(N x N!)`. A tighter bound would be Catalan number times `N` since we\\'ve done `N` times, which is `N x G_N = O(Nx\\\\frac{4^N}{N^{3/2}}) = O(\\\\frac{4^N}{N^{1/2}})`.\\n**Space:** `O(N x G_N) = O(\\\\frac{4^N}{N^{1/2}})`\\n\\n\\n\\n### DP (Clone)\\n\\nReference: [link](https://leetcode.wang/leetCode-95-Unique-Binary-Search-TreesII.html)\\n\\nLet\\'s denote `tree[i]` as the list of trees of size `i`. Think of `tree[i]` as our building blocks for a larger tree.\\n\\n```java\\nExample: n = 3\\n\\ntree[0]:\\nnull\\n\\ntree[1]:\\n[1]\\n[2]\\n[3]\\n\\ntree[2]:\\n[1 2]\\n1\\n \\\\\\n  2      // 2 structures\\n  2\\n /\\n1\\n[2 3]\\n2\\n \\\\\\n  3\\n  3\\n /\\n2        // [1 3] is not possible\\n\\ntree[3]:  // (based on tree[1], tree[2])\\n   3\\n  /\\n[1 2]\\n   1\\n    \\\\\\n   [2 3]\\n   2\\n /  \\\\\\n[1] [3]\\n```\\n\\nSo we can compute all possible trees for `tree[1]`, `tree[2]`, ..., then we can construct `tree[n]` by previous results.\\n\\nFor a small `n = 3` , we notice that when we calculate `tree[2]` we want all possible combinations for `tree[2]` (`[1 2]`, `[2 3]`). **Furthermore**, if we have a large `n = 100`, we want all the combinations as follows `[1 2]`, `[2 3]`, `[3 4]`, ..., `[99 100]` (each of them has two structures).\\n\\nSince these trees have the same two types of structures:\\n\\n```java\\nx       y\\n \\\\     /\\n  y   x\\n```\\n\\nWe can actually construct all the trees by `[1 2]` plus some constant, say `offset`. For example, `[5 6]` can be constructed as follows:\\n\\n```java\\n1    +4    5\\n \\\\          \\\\\\n  2    +4    6\\n------------------\\n  2    +4    6\\n /          /\\n1    +4    5\\n```\\n\\nSay the problem is `n = 100`. During the execution of the algorithm when `i = 98`, we want to get all possible trees for `i = 98` as the root. The size of the left subtree is `97` and the subtree is picked from `tree[97]`; the size of the right subtree is `2` and the subtree is picked from `tree[2]`.\\n\\nFor the left subtree, we already have `tree[97]` computed as `[1 2 3 ... 97]`.\\n\\nFor the right subtree, we want `[99 100]`, which can be computed by `[1 2]` plus `offset = 98`.\\n\\n```java\\n1    +98    99\\n \\\\            \\\\\\n  2    +98    100\\n------------------\\n  2    +98    100\\n /            /\\n1    +98     99\\n```\\n\\nTherefore, given a tree `root`, we can generate a new tree by cloning with an `offset`.\\n\\n```java\\n// adding offset to each node of a tree root\\nprivate TreeNode clone(TreeNode root, int offset) {\\n  if (n == null) {\\n    return null;\\n  }\\n  TreeNode node = new TreeNode(root.val + offset);\\n  node.left = clone(root.left, offset);\\n  node.right = clone(root.right, offset);\\n  return node;\\n}\\n```\\n\\nFor input `n`, the result we want is `tree[n]` (`[1 2 3 ... n]`). Here is the code for `generateTrees(n)`:\\n\\n```java\\npublic List<TreeNode> generateTrees(int n) {\\n  List<TreeNode>[] tree = new ArrayList[n + 1];\\n  tree[0] = new ArrayList<>();\\n  if (n == 0) {\\n    return tree[0];\\n  }\\n  tree[0].add(null);\\n  // Calculate all lengths\\n  for (int len = 1; len <= n; ++len) {\\n    tree[len] = new ArrayList<>(); // contains all trees we construct\\n    // Consider each as the root\\n    for (int i = 1; i <= len; ++i) {\\n      int leftSize = i - 1;\\n      int rightSize = len - i;\\n      for (TreeNode leftTree : tree[leftSize]) [\\n        for (TreeNode rightTree : tree[rightSize]) {\\n          TreeNode tree = new TreeNode(i);\\n          tree.left = leftTree;  // left subtree requires no cloning\\n          tree.right = clone(rightTree, i); // add i as the offset\\n          tree[len].add(tree);\\n        }\\n      ]\\n    }\\n  }\\n  return tree[n];\\n}\\n```\\n\\n**Time:** <span class=\"purple\">N/A</span> (I don\\'t know T_T)\\n**Space:** <span class=\"purple\">N/A</span> (I don\\'t know T_T)\\n\\n\\n### DP (2D)\\n\\nJudge: `1ms`, faster than `99.95%`. I have nothing to say.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/sz3zr.jpg)\\n\\nHere is the code I wrote:\\n\\n```java\\npublic List<TreeNode> generateTrees(int n) {\\n  if (n == 0) {\\n    return new ArrayList<>();\\n  }\\n  List<TreeNode>[][] g = new ArrayList[n + 1][n + 1];\\n  // init\\n  List<TreeNode> nullList = new ArrayList<>(); nullList.add(null);\\n  g[0][0] = nullList;\\n  for (int k = 1; k <= n; ++k) { // g(0, k)\\n    g[0][k] = nullList;\\n  }\\n  for (int k = 1; k <= n; ++k) { // diagonal: one node (itself)\\n    List<TreeNode> oneList = new ArrayList<>(); oneList.add(new TreeNode(k));\\n    g[k][k] = oneList;\\n  }\\n  for (int k = 1; k <= n; ++k) { // one node above diagonal: nullList\\n    g[k][k - 1] = nullList;\\n  }\\n  // dp\\n  for (int i = n - 1; i >= 1; --i) {\\n    for (int j = i + 1; j <= n; ++j) {\\n      List<TreeNode> result = new ArrayList<>();\\n      for (int k = i ; k <= j; ++k) { // for each k as root [i, j]\\n        List<TreeNode> leftList = (k - 1 <= n) ? g[i][k - 1] : nullList;\\n        List<TreeNode> rightList = (k + 1 <= n) ? g[k + 1][j] : nullList;\\n        for (TreeNode left : leftList) {\\n          for (TreeNode right: rightList) {\\n            TreeNode newTree = new TreeNode(k);\\n            newTree.left = left;\\n            newTree.right = right;\\n            result.add(newTree);\\n          }\\n        }\\n      }\\n      g[i][j] = result;\\n    }\\n  }\\n  return g[1][n];\\n}\\n```\\n\\n**Time:** <span class=\"purple\">N/A</span> (I don\\'t know T_T)\\n**Space:** <span class=\"purple\">N/A</span> (I don\\'t know T_T)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```java\\nInput: 3\\nOutput:\\n[\\n  [1,null,3,2],\\n  [3,2,null,1],\\n  [3,1,null,null,2],\\n  [2,1,3],\\n  [1,null,2,null,3]\\n]\\nExplanation:\\nThe above output corresponds to the 5 unique BST\\'s shown below:\\n\\n   1         3     3      2      1\\n    \\\\       /     /      / \\\\      \\\\\\n     3     2     1      1   3      2\\n    /     /       \\\\                 \\\\\\n   2     1         2                 3\\n```\n```java\\nn = 5, i = 3\\n2 left nodes:  [1, 2]\\n2 right nodes: [4, 5]\\n\\nn = 10, i = 8\\n7 left nodes:  [1, 2, 3, 4, 5, 6, 7]\\n2 right nodes: [9, 10]\\n```\n```java\\npublic List<TreeNode> generateTrees(int n) {\\n  if (n == 0) {\\n    return new ArrayList<>();\\n  }\\n  return generateTrees(1, n);\\n}\\n\\nprivate List<TreeNode> generateTrees(int lo, int hi) {\\n  int n = hi - lo + 1;\\n  if (n == 0) {\\n    List<TreeNode> L = new ArrayList<>();\\n    L.add(null);\\n    return L;\\n  }\\n  List<TreeNode> result = new ArrayList<>();\\n  for (int i = lo; i <= hi; ++i) {\\n    List<TreeNode> leftSubtrees = generateTrees(lo, i - 1);\\n    List<TreeNode> rightSubtrees = generateTrees(i + 1, hi);\\n    for (TreeNode leftSub : leftSubtrees) {\\n      for (TreeNode rightSub : rightSubtrees) {\\n        TreeNode newTree = new TreeNode(i);\\n        newTree.left = leftSub;\\n        newTree.right = rightSub;\\n        result.add(newTree);\\n      }\\n    }\\n  }\\n  return result;\\n}\\n```\n```java\\nExample: n = 3\\n\\ntree[0]:\\nnull\\n\\ntree[1]:\\n[1]\\n[2]\\n[3]\\n\\ntree[2]:\\n[1 2]\\n1\\n \\\\\\n  2      // 2 structures\\n  2\\n /\\n1\\n[2 3]\\n2\\n \\\\\\n  3\\n  3\\n /\\n2        // [1 3] is not possible\\n\\ntree[3]:  // (based on tree[1], tree[2])\\n   3\\n  /\\n[1 2]\\n   1\\n    \\\\\\n   [2 3]\\n   2\\n /  \\\\\\n[1] [3]\\n```\n```java\\nx       y\\n \\\\     /\\n  y   x\\n```\n```java\\n1    +4    5\\n \\\\          \\\\\\n  2    +4    6\\n------------------\\n  2    +4    6\\n /          /\\n1    +4    5\\n```\n```java\\n1    +98    99\\n \\\\            \\\\\\n  2    +98    100\\n------------------\\n  2    +98    100\\n /            /\\n1    +98     99\\n```\n```java\\n// adding offset to each node of a tree root\\nprivate TreeNode clone(TreeNode root, int offset) {\\n  if (n == null) {\\n    return null;\\n  }\\n  TreeNode node = new TreeNode(root.val + offset);\\n  node.left = clone(root.left, offset);\\n  node.right = clone(root.right, offset);\\n  return node;\\n}\\n```\n```java\\npublic List<TreeNode> generateTrees(int n) {\\n  List<TreeNode>[] tree = new ArrayList[n + 1];\\n  tree[0] = new ArrayList<>();\\n  if (n == 0) {\\n    return tree[0];\\n  }\\n  tree[0].add(null);\\n  // Calculate all lengths\\n  for (int len = 1; len <= n; ++len) {\\n    tree[len] = new ArrayList<>(); // contains all trees we construct\\n    // Consider each as the root\\n    for (int i = 1; i <= len; ++i) {\\n      int leftSize = i - 1;\\n      int rightSize = len - i;\\n      for (TreeNode leftTree : tree[leftSize]) [\\n        for (TreeNode rightTree : tree[rightSize]) {\\n          TreeNode tree = new TreeNode(i);\\n          tree.left = leftTree;  // left subtree requires no cloning\\n          tree.right = clone(rightTree, i); // add i as the offset\\n          tree[len].add(tree);\\n        }\\n      ]\\n    }\\n  }\\n  return tree[n];\\n}\\n```\n```java\\npublic List<TreeNode> generateTrees(int n) {\\n  if (n == 0) {\\n    return new ArrayList<>();\\n  }\\n  List<TreeNode>[][] g = new ArrayList[n + 1][n + 1];\\n  // init\\n  List<TreeNode> nullList = new ArrayList<>(); nullList.add(null);\\n  g[0][0] = nullList;\\n  for (int k = 1; k <= n; ++k) { // g(0, k)\\n    g[0][k] = nullList;\\n  }\\n  for (int k = 1; k <= n; ++k) { // diagonal: one node (itself)\\n    List<TreeNode> oneList = new ArrayList<>(); oneList.add(new TreeNode(k));\\n    g[k][k] = oneList;\\n  }\\n  for (int k = 1; k <= n; ++k) { // one node above diagonal: nullList\\n    g[k][k - 1] = nullList;\\n  }\\n  // dp\\n  for (int i = n - 1; i >= 1; --i) {\\n    for (int j = i + 1; j <= n; ++j) {\\n      List<TreeNode> result = new ArrayList<>();\\n      for (int k = i ; k <= j; ++k) { // for each k as root [i, j]\\n        List<TreeNode> leftList = (k - 1 <= n) ? g[i][k - 1] : nullList;\\n        List<TreeNode> rightList = (k + 1 <= n) ? g[k + 1][j] : nullList;\\n        for (TreeNode left : leftList) {\\n          for (TreeNode right: rightList) {\\n            TreeNode newTree = new TreeNode(k);\\n            newTree.left = left;\\n            newTree.right = right;\\n            result.add(newTree);\\n          }\\n        }\\n      }\\n      g[i][j] = result;\\n    }\\n  }\\n  return g[1][n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 332563,
                "title": "explanation-with-diagrams-dp-solution",
                "content": "Again I am going to explain a DP solution using diagrams.\\nFirst I define a two-dimension list res[0..n][0..n].(res[0][0] is of no use,just for readability,so we will ignore them later.)\\nres[i][j] stores the root TreeNode of all possible BST formed by integers from i to j.Then our goal is res[1][n].\\nTo calculate res[1][n],we can review last problem,to find out the recursion formula.\\nTake n=3 into consideration first,we want to know res[1][3].\\n![image](https://assets.leetcode.com/users/planegoose/image_1562855139.png)\\n\\n![image](https://assets.leetcode.com/users/planegoose/image_1562855122.png)\\nFrom the picture we can find that solving res[1][3] needs res[2][3],res[1][1],res[3][3] and res[1][2].\\n![image](https://assets.leetcode.com/users/planegoose/image_1562855224.png)\\n\\nTo be specific,for instance,if we have known res[2][3],by simply set \\n```\\nfor oneNode of res[2][3] :\\n    t = TreeNode(1)\\n    t.left = null\\n    t.right = oneNode\\n    res[1][3].append(t)\\n```\\nwe can get some possible solution of res[1][3].By the same method we can solve out all solutions of res[1][3].\\nThen we turn to res[2][3].As is the same,res[2][3] rely on res[2][2] and res[3][3]\\n,and res[1][2] rely on res[1][1] and res[2][2].\\n![image](https://assets.leetcode.com/users/planegoose/image_1562855195.png)\\n![image](https://assets.leetcode.com/users/planegoose/image_1562855252.png)\\nIt is obvious that res[i][i] = [i].\\nSo we only need to fill the matrix along every diagonal line one by one,from middle diagonal line to the right-top corner.\\n![image](https://assets.leetcode.com/users/planegoose/image_1562855271.png)\\n![image](https://assets.leetcode.com/users/planegoose/image_1562855278.png)\\n![image](https://assets.leetcode.com/users/planegoose/image_1562855281.png)\\nThen we can use bottom-up DP to solve every diagonal line,and finally get res[1][n].\\n\\n**Supplement**\\n(res begins at 0,ends at n,just for readability.Of course it will occupy less space if we let it end at n-1.)\\n(There are many vacant grid occupied(colored in gray) at left-bottom.Maybe we can improve the algorithms in this term.)\\n(My code is somewhat too long,though excelling 98% in time and 97% in space,but I haven\\'t compacted it,so I feel shamed to put it up.)\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nfor oneNode of res[2][3] :\\n    t = TreeNode(1)\\n    t.left = null\\n    t.right = oneNode\\n    res[1][3].append(t)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 151394,
                "title": "javascript-dfs-with-memo",
                "content": "```js\\nfunction generateTrees(n) {\\n  if (n < 1) return [];\\n  const dp = [...Array(n+1)].map(r => Array(n+1));\\n  return generate(1, n);\\n  \\n  function generate(s, e) {\\n    if (s > e) return [null];\\n    if (dp[s][e]) return dp[s][e];\\n    \\n    const res = [];\\n    for (let root = s; root <= e; root++) {\\n      for (let left of generate(s, root-1)) {\\n        for (let right of generate(root+1, e)) {\\n          const newTree = new TreeNode(root);\\n          newTree.left = left;\\n          newTree.right = right;\\n          res.push(newTree);\\n        }\\n      }\\n    }\\n    \\n    dp[s][e] = res;\\n    return res;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction generateTrees(n) {\\n  if (n < 1) return [];\\n  const dp = [...Array(n+1)].map(r => Array(n+1));\\n  return generate(1, n);\\n  \\n  function generate(s, e) {\\n    if (s > e) return [null];\\n    if (dp[s][e]) return dp[s][e];\\n    \\n    const res = [];\\n    for (let root = s; root <= e; root++) {\\n      for (let left of generate(s, root-1)) {\\n        for (let right of generate(root+1, e)) {\\n          const newTree = new TreeNode(root);\\n          newTree.left = left;\\n          newTree.right = right;\\n          res.push(newTree);\\n        }\\n      }\\n    }\\n    \\n    dp[s][e] = res;\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1670103,
                "title": "easy-to-understand-dp-solution-iterative-space-optimised-better-runtime",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* newTreeRight(TreeNode* root, int j){\\n        if(root==NULL){\\n            return root;\\n        }\\n        TreeNode* newRoot = new TreeNode(root->val + j);\\n        newRoot->left = newTreeRight(root->left, j);\\n        newRoot->right = newTreeRight(root->right, j);\\n        return newRoot;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n==1){\\n            return {new TreeNode(1)};\\n        }\\n        vector<vector<TreeNode*>> dp(n+1);\\n        TreeNode* root = new TreeNode(1);\\n        dp[1].push_back(root);\\n        for(int i = 2; i<=n; i++){\\n            for(int j = 1; j<=i; j++){\\n                int left = j-1;\\n                int right = i-j;\\n                if(left==0){\\n                    for(int k = 0; k<dp[right].size(); k++){\\n                        root = new TreeNode(j);\\n                        TreeNode *newRoot = newTreeRight(dp[right][k], j);\\n                        root->right = newRoot;\\n                        dp[i].push_back(root);\\n                    }\\n                }else if(right==0){\\n                    for(int k = 0; k<dp[left].size(); k++){\\n                        root = new TreeNode(j);\\n                        root->left = dp[left][k];\\n                        dp[i].push_back(root);\\n                    }\\n                }else{\\n                    for(int k = 0; k<dp[left].size(); k++){\\n                        for(int l = 0; l<dp[right].size(); l++){\\n                            root = new TreeNode(j);\\n                            root->left = dp[left][k];\\n                            TreeNode *newRoot = newTreeRight(dp[right][l], j);\\n                            root->right = newRoot;\\n                            dp[i].push_back(root);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* newTreeRight(TreeNode* root, int j){\\n        if(root==NULL){\\n            return root;\\n        }\\n        TreeNode* newRoot = new TreeNode(root->val + j);\\n        newRoot->left = newTreeRight(root->left, j);\\n        newRoot->right = newTreeRight(root->right, j);\\n        return newRoot;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n==1){\\n            return {new TreeNode(1)};\\n        }\\n        vector<vector<TreeNode*>> dp(n+1);\\n        TreeNode* root = new TreeNode(1);\\n        dp[1].push_back(root);\\n        for(int i = 2; i<=n; i++){\\n            for(int j = 1; j<=i; j++){\\n                int left = j-1;\\n                int right = i-j;\\n                if(left==0){\\n                    for(int k = 0; k<dp[right].size(); k++){\\n                        root = new TreeNode(j);\\n                        TreeNode *newRoot = newTreeRight(dp[right][k], j);\\n                        root->right = newRoot;\\n                        dp[i].push_back(root);\\n                    }\\n                }else if(right==0){\\n                    for(int k = 0; k<dp[left].size(); k++){\\n                        root = new TreeNode(j);\\n                        root->left = dp[left][k];\\n                        dp[i].push_back(root);\\n                    }\\n                }else{\\n                    for(int k = 0; k<dp[left].size(); k++){\\n                        for(int l = 0; l<dp[right].size(); l++){\\n                            root = new TreeNode(j);\\n                            root->left = dp[left][k];\\n                            TreeNode *newRoot = newTreeRight(dp[right][l], j);\\n                            root->right = newRoot;\\n                            dp[i].push_back(root);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31631,
                "title": "a-simple-bottom-up-dp-solution",
                "content": "The optimal substructure is that for any BST with nodes 1 to n, pick i-th node as root, then the left subtree will contain nodes from 1 to (i-1), and the right subtree will contain nodes from (i+1) to n. I use a 3-d vector to store all possible trees for subtrees with nodes from i to j (0 <= i <= j <=n+1 ), if i==j, there is only one-node tree; if j = i-1, then there is no actual node(storing NULL pointer).  Use a bottom up solution to generate all possible subtrees with nodes i to j. Finally the result will be the subtree set with nodes 1 to n, \\n    \\n    \\tvector<TreeNode *> generateTrees(int n) {\\n\\t\\tif(n == 0)\\treturn vector<TreeNode *>(1, NULL);\\n\\t\\tvector<vector<vector<TreeNode*>>> subtree(n+2, vector<vector<TreeNode*>>(n+2, vector<TreeNode*>()));\\n\\t\\tfor(int i=1; i<=n+1; ++i){\\n\\t\\t\\tsubtree[i][i].push_back(new TreeNode(i));\\n\\t\\t    subtree[i][i-1].push_back(NULL);\\t\\n\\t\\t}\\n\\t\\tfor(int l=2; l<=n; ++l){\\n\\t\\t\\tfor(int i=1; i<=n-l+1; ++i){\\n\\t\\t\\t\\tfor(int j=i; j<=i+l-1; ++j){\\n\\t\\t\\t\\t\\tfor(int k=0; k<subtree[j+1][i+l-1].size(); ++k){\\n\\t\\t\\t\\t\\t    for(int m=0; m<subtree[i][j-1].size(); ++m){\\n\\t\\t\\t\\t\\t        TreeNode *T = new TreeNode(j);\\n\\t\\t\\t\\t\\t        T->left = subtree[i][j-1][m];\\n\\t\\t\\t\\t\\t        T->right = subtree[j+1][i+l-1][k];\\n\\t\\t\\t\\t            subtree[i][i+l-1].push_back(T);    \\n\\t\\t\\t\\t\\t    }\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn subtree[1][n];\\n\\t}",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Tree"
                ],
                "code": "The optimal substructure is that for any BST with nodes 1 to n, pick i-th node as root, then the left subtree will contain nodes from 1 to (i-1), and the right subtree will contain nodes from (i+1) to n. I use a 3-d vector to store all possible trees for subtrees with nodes from i to j (0 <= i <= j <=n+1 ), if i==j, there is only one-node tree; if j = i-1, then there is no actual node(storing NULL pointer).  Use a bottom up solution to generate all possible subtrees with nodes i to j. Finally the result will be the subtree set with nodes 1 to n, \\n    \\n    \\tvector<TreeNode *> generateTrees(int n) {\\n\\t\\tif(n == 0)\\treturn vector<TreeNode *>(1, NULL);\\n\\t\\tvector<vector<vector<TreeNode*>>> subtree(n+2, vector<vector<TreeNode*>>(n+2, vector<TreeNode*>()));\\n\\t\\tfor(int i=1; i<=n+1; ++i){\\n\\t\\t\\tsubtree[i][i].push_back(new TreeNode(i));\\n\\t\\t    subtree[i][i-1].push_back(NULL);\\t\\n\\t\\t}\\n\\t\\tfor(int l=2; l<=n; ++l){\\n\\t\\t\\tfor(int i=1; i<=n-l+1; ++i){\\n\\t\\t\\t\\tfor(int j=i; j<=i+l-1; ++j){\\n\\t\\t\\t\\t\\tfor(int k=0; k<subtree[j+1][i+l-1].size(); ++k){\\n\\t\\t\\t\\t\\t    for(int m=0; m<subtree[i][j-1].size(); ++m){\\n\\t\\t\\t\\t\\t        TreeNode *T = new TreeNode(j);\\n\\t\\t\\t\\t\\t        T->left = subtree[i][j-1][m];\\n\\t\\t\\t\\t\\t        T->right = subtree[j+1][i+l-1][k];\\n\\t\\t\\t\\t            subtree[i][i+l-1].push_back(T);    \\n\\t\\t\\t\\t\\t    }\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn subtree[1][n];\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1321506,
                "title": "java-easy-solution-recursion",
                "content": "```\\n\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        return recursion(1,n);\\n    }\\n    List<TreeNode> recursion(int start ,int end)\\n    {\\n        List<TreeNode> list = new ArrayList<>();\\n        if(start > end)\\n        {\\n            list.add(null);\\n            return list;\\n        }\\n        if(start == end)\\n        {\\n            list.add(new TreeNode(start));\\n            return list;\\n        }\\n        List<TreeNode> left,right;\\n        for(int i = start;i<=end;i++)\\n        {\\n            left = recursion(start,i-1);\\n            right = recursion(i+1,end);\\n            for(TreeNode lst : left)\\n            {\\n                for(TreeNode rst : right)\\n                {\\n                    TreeNode root = new TreeNode(i);\\n                    root.left = lst;\\n                    root.right = rst;\\n                    list.add(root);\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        return recursion(1,n);\\n    }\\n    List<TreeNode> recursion(int start ,int end)\\n    {\\n        List<TreeNode> list = new ArrayList<>();\\n        if(start > end)\\n        {\\n            list.add(null);\\n            return list;\\n        }\\n        if(start == end)\\n        {\\n            list.add(new TreeNode(start));\\n            return list;\\n        }\\n        List<TreeNode> left,right;\\n        for(int i = start;i<=end;i++)\\n        {\\n            left = recursion(start,i-1);\\n            right = recursion(i+1,end);\\n            for(TreeNode lst : left)\\n            {\\n                for(TreeNode rst : right)\\n                {\\n                    TreeNode root = new TreeNode(i);\\n                    root.left = lst;\\n                    root.right = rst;\\n                    list.add(root);\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865004,
                "title": "c-recursion",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n![image](https://assets.leetcode.com/users/images/5be019ea-898c-4178-b92a-afdd521465c9_1691201173.537878.jpeg)\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    vector<TreeNode*> build(int start, int end){\\n        if(start>end) return {NULL};\\n        if(start==end) return {new TreeNode(start)};\\n        \\n        vector<TreeNode*> ans;\\n        for(int i=start;i<=end;i++){\\n            // inorder of BST is sorted i.e left -> root-> right\\n            vector<TreeNode*> left=build(start,i-1);\\n            vector<TreeNode*> right=build(i+1,end);\\n            \\n            // building all possible combinations with left having smaller than root & right having bigger values than root\\n            for(TreeNode* l : left){\\n                for(TreeNode* r : right){\\n                    TreeNode* root=new TreeNode(i);\\n                    root->left=l;\\n                    root->right=r;\\n                    \\n                    ans.push_back(root);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        return build(1,n);\\n    }\\n};\\n```\\n\\n**Do upvote if it helps :)**",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    vector<TreeNode*> build(int start, int end){\\n        if(start>end) return {NULL};\\n        if(start==end) return {new TreeNode(start)};\\n        \\n        vector<TreeNode*> ans;\\n        for(int i=start;i<=end;i++){\\n            // inorder of BST is sorted i.e left -> root-> right\\n            vector<TreeNode*> left=build(start,i-1);\\n            vector<TreeNode*> right=build(i+1,end);\\n            \\n            // building all possible combinations with left having smaller than root & right having bigger values than root\\n            for(TreeNode* l : left){\\n                for(TreeNode* r : right){\\n                    TreeNode* root=new TreeNode(i);\\n                    root->left=l;\\n                    root->right=r;\\n                    \\n                    ans.push_back(root);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        return build(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2280436,
                "title": "c-pure-recursion-to-dp-only-with-addition-of-2-lines",
                "content": "There is a significant amount of improvement in the 2nd solution compared to the effort made to code that one over the inital recursive un-memoized solution.\\n\\n# 1. Pure Recursion (43 ms)\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> buildTrees(int l, int r) {\\n        \\n        if(l > r) return {nullptr};\\n        \\n        vector<TreeNode*> ans;\\n        \\n        for(int i=l; i<=r; ++i)\\n        {\\n\\t\\t\\t// set of BST\\'s we can make using values [l, i-1] \\n\\t\\t\\t\\n            vector<TreeNode*> left = buildTrees(l, i-1);\\n            \\n\\t\\t\\t// set of BST\\'s we can make using values [i+1, r]\\n\\t\\t\\t\\n            vector<TreeNode*> right = buildTrees(i+1, r);\\n            \\n\\t\\t\\t// creating all the possible different combinations using left and right vectors\\n\\t\\t\\t\\n            for(int j=0; j<left.size(); ++j)\\n            {\\n                for(int k=0; k<right.size(); ++k)\\n                {\\n                    ans.push_back(new TreeNode(i, left[j], right[k]));\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        return buildTrees(1, n);\\n    }\\n};\\n```\\n\\n# 2. Top-Down DP (11 ms)\\n```\\nclass Solution {\\npublic:\\n    map<pair<int,int>, vector<TreeNode*>> m; //Line #1\\n    \\n    vector<TreeNode*> buildTrees(int l, int r) {\\n        \\n        if(l > r) return {nullptr};\\n        \\n        if(m.find({l, r}) != m.end()) return m[{l, r}]; //Line #2\\n        \\n        vector<TreeNode*> ans;\\n        \\n        for(int i=l; i<=r; ++i)\\n        {\\n            vector<TreeNode*> left = buildTrees(l, i-1);\\n            \\n            vector<TreeNode*> right = buildTrees(i+1, r);\\n            \\n            for(int j=0; j<left.size(); ++j)\\n            {\\n                for(int k=0; k<right.size(); ++k)\\n                {\\n                    ans.push_back(new TreeNode(i, left[j], right[k]));\\n                }\\n            }\\n        }\\n        \\n        return m[{l, r}] = ans; //Line #3\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        return buildTrees(1, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> buildTrees(int l, int r) {\\n        \\n        if(l > r) return {nullptr};\\n        \\n        vector<TreeNode*> ans;\\n        \\n        for(int i=l; i<=r; ++i)\\n        {\\n\\t\\t\\t// set of BST\\'s we can make using values [l, i-1] \\n\\t\\t\\t\\n            vector<TreeNode*> left = buildTrees(l, i-1);\\n            \\n\\t\\t\\t// set of BST\\'s we can make using values [i+1, r]\\n\\t\\t\\t\\n            vector<TreeNode*> right = buildTrees(i+1, r);\\n            \\n\\t\\t\\t// creating all the possible different combinations using left and right vectors\\n\\t\\t\\t\\n            for(int j=0; j<left.size(); ++j)\\n            {\\n                for(int k=0; k<right.size(); ++k)\\n                {\\n                    ans.push_back(new TreeNode(i, left[j], right[k]));\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        return buildTrees(1, n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    map<pair<int,int>, vector<TreeNode*>> m; //Line #1\\n    \\n    vector<TreeNode*> buildTrees(int l, int r) {\\n        \\n        if(l > r) return {nullptr};\\n        \\n        if(m.find({l, r}) != m.end()) return m[{l, r}]; //Line #2\\n        \\n        vector<TreeNode*> ans;\\n        \\n        for(int i=l; i<=r; ++i)\\n        {\\n            vector<TreeNode*> left = buildTrees(l, i-1);\\n            \\n            vector<TreeNode*> right = buildTrees(i+1, r);\\n            \\n            for(int j=0; j<left.size(); ++j)\\n            {\\n                for(int k=0; k<right.size(); ++k)\\n                {\\n                    ans.push_back(new TreeNode(i, left[j], right[k]));\\n                }\\n            }\\n        }\\n        \\n        return m[{l, r}] = ans; //Line #3\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        return buildTrees(1, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337271,
                "title": "recursive-c-solution-faster-than-97-c-submissions",
                "content": "**INTUTION:**\\nFor every element in range 1 to n lets say (temp), we try to find its corresponding left and right subtrees by helper(start,i-1) && helper(i+1,end) iterate through all possibilities of them and set temp\\'s left and right sub trees and push back to some vector and return.\\n```\\nvector<TreeNode*> generateTrees(int n) \\n    {\\n        return helper(1,n);\\n    }\\n    \\n    vector<TreeNode*> helper(int start,int end)\\n    {\\n        vector<TreeNode*> ans;\\n        if(start>end)\\n        {\\n            ans.push_back(NULL);\\n            return ans;\\n        }\\n        \\n        for(int i=start;i<=end;i++)\\n        {\\n            vector<TreeNode*> left = helper(start,i-1);\\n            vector<TreeNode*> right = helper(i+1,end);\\n            \\n            for(int j=0;j<left.size();j++)\\n            {\\n                for(int k=0;k<right.size();k++)\\n                {\\n                    TreeNode* root = new TreeNode(i);\\n                    root->left=left[j];\\n                    root->right=right[k];\\n                    ans.push_back(root);\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "**INTUTION:**\\nFor every element in range 1 to n lets say (temp), we try to find its corresponding left and right subtrees by helper(start,i-1) && helper(i+1,end) iterate through all possibilities of them and set temp\\'s left and right sub trees and push back to some vector and return.\\n```\\nvector<TreeNode*> generateTrees(int n) \\n    {\\n        return helper(1,n);\\n    }\\n    \\n    vector<TreeNode*> helper(int start,int end)\\n    {\\n        vector<TreeNode*> ans;\\n        if(start>end)\\n        {\\n            ans.push_back(NULL);\\n            return ans;\\n        }\\n        \\n        for(int i=start;i<=end;i++)\\n        {\\n            vector<TreeNode*> left = helper(start,i-1);\\n            vector<TreeNode*> right = helper(i+1,end);\\n            \\n            for(int j=0;j<left.size();j++)\\n            {\\n                for(int k=0;k<right.size();k++)\\n                {\\n                    TreeNode* root = new TreeNode(i);\\n                    root->left=left[j];\\n                    root->right=right[k];\\n                    ans.push_back(root);\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1172462,
                "title": "approach-code",
                "content": "Honestly I was not able to solve the problem in one go. I was able to get the idea to solve the problem but wasn\\'t able to implement it. \\nFirstly try to solve the problem Unique Binary Search Tree\\nSo here is my approach:\\n1) We need to generate a ***BST*** which means that left child will contain the node value lesser than root and right child will contain the value greater than the value of root.\\n2) And also I have ***n*** number of choices for the root node. \\n3) So i will iterate from ***1 to n*** and will generate left and rightsubtree recursivly.\\n4) Then create a tree from all the possible left and right subtree an then finally add to the solution list.\\n5) Also do not forget to add the base condition.\\nBase condition will be when my ***start>end***\\nSo here is my code:\\n```\\n vector<TreeNode*> generate(int start,int end)\\n    { vector<TreeNode*>list;\\n        if(start>end)\\n        {\\n            list.push_back(nullptr);\\n            return list;\\n        }\\n        for(int i=start;i<=end;i++)\\n        {\\n           vector<TreeNode*>leftsubtree=generate(start,i-1);\\n           vector<TreeNode*>rightsubtree=generate(i+1,end);\\n            for(int j=0;j<leftsubtree.size();j++)\\n            {\\n                TreeNode* left=leftsubtree[j];\\n                for(int k=0;k<rightsubtree.size();k++)\\n                {\\n                    TreeNode* right=rightsubtree[k];\\n                    TreeNode* node=new TreeNode(i);\\n                    node->left=left;\\n                    node->right=right;\\n                  list.push_back(node);\\n                }\\n            }\\n           \\n            \\n        }\\n     return list;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n   // binary search tree left node contain ->(1,i-1)and right child contain (i+1,n)\\n     vector<TreeNode*>ans=generate(1,n);   \\n        return ans;\\n    }\\n\\t//HappyCoding\\n\\t//Stay Safe and healthy\\n\\t//Also if you like the post do upvote and comment",
                "solutionTags": [],
                "code": "Honestly I was not able to solve the problem in one go. I was able to get the idea to solve the problem but wasn\\'t able to implement it. \\nFirstly try to solve the problem Unique Binary Search Tree\\nSo here is my approach:\\n1) We need to generate a ***BST*** which means that left child will contain the node value lesser than root and right child will contain the value greater than the value of root.\\n2) And also I have ***n*** number of choices for the root node. \\n3) So i will iterate from ***1 to n*** and will generate left and rightsubtree recursivly.\\n4) Then create a tree from all the possible left and right subtree an then finally add to the solution list.\\n5) Also do not forget to add the base condition.\\nBase condition will be when my ***start>end***\\nSo here is my code:\\n```\\n vector<TreeNode*> generate(int start,int end)\\n    { vector<TreeNode*>list;\\n        if(start>end)\\n        {\\n            list.push_back(nullptr);\\n            return list;\\n        }\\n        for(int i=start;i<=end;i++)\\n        {\\n           vector<TreeNode*>leftsubtree=generate(start,i-1);\\n           vector<TreeNode*>rightsubtree=generate(i+1,end);\\n            for(int j=0;j<leftsubtree.size();j++)\\n            {\\n                TreeNode* left=leftsubtree[j];\\n                for(int k=0;k<rightsubtree.size();k++)\\n                {\\n                    TreeNode* right=rightsubtree[k];\\n                    TreeNode* node=new TreeNode(i);\\n                    node->left=left;\\n                    node->right=right;\\n                  list.push_back(node);\\n                }\\n            }\\n           \\n            \\n        }\\n     return list;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n   // binary search tree left node contain ->(1,i-1)and right child contain (i+1,n)\\n     vector<TreeNode*>ans=generate(1,n);   \\n        return ans;\\n    }\\n\\t//HappyCoding\\n\\t//Stay Safe and healthy\\n\\t//Also if you like the post do upvote and comment",
                "codeTag": "Unknown"
            },
            {
                "id": 164932,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def generateTrees(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[TreeNode]\\n        \"\"\"\\n        def generate(i,j):\\n            if j-i < 0:\\n                return [None]\\n            elif j-i == 0:\\n                return [TreeNode(i)]\\n            else:\\n                res = []\\n                for k in range(i,j+1):\\n                    left = generate(i,k-1)\\n                    right = generate(k+1,j)\\n                    for l in left:\\n                        for r in right:\\n                            root = TreeNode(k)\\n                            root.left = l\\n                            root.right = r\\n                            res.append(root)\\n                return res\\n        if n == 0:\\n            return []\\n        else:\\n            return generate(1,n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def generateTrees(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[TreeNode]\\n        \"\"\"\\n        def generate(i,j):\\n            if j-i < 0:\\n                return [None]\\n            elif j-i == 0:\\n                return [TreeNode(i)]\\n            else:\\n                res = []\\n                for k in range(i,j+1):\\n                    left = generate(i,k-1)\\n                    right = generate(k+1,j)\\n                    for l in left:\\n                        for r in right:\\n                            root = TreeNode(k)\\n                            root.left = l\\n                            root.right = r\\n                            res.append(root)\\n                return res\\n        if n == 0:\\n            return []\\n        else:\\n            return generate(1,n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31523,
                "title": "dp-solution-in-python",
                "content": "----------\\n\\nclass Solution:\\n    # @return a list of tree node\\n\\n    def generateTrees(self, n):\\n        if n == 0:\\n            return [None]\\n        tree_list = [[[None]] * (n + 2) for i in range(n + 2)]\\n        for i in range(1, n + 1):\\n            tree_list[i][i] = [TreeNode(i)]\\n            for j in reversed(range(1, i)):\\n                tree_list[j][i] = []\\n                for k in range(j, i + 1):\\n                    for left in tree_list[j][k - 1]:\\n                        for right in tree_list[k + 1][i]:\\n                            root = TreeNode(k)\\n                            (root.left, root.right) = (left, right)\\n                            tree_list[j][i].append(root)\\n        return tree_list[1][n]",
                "solutionTags": [],
                "code": "----------\\n\\nclass Solution:\\n    # @return a list of tree node\\n\\n    def generateTrees(self, n):\\n        if n == 0:\\n            return [None]\\n        tree_list = [[[None]] * (n + 2) for i in range(n + 2)]\\n        for i in range(1, n + 1):\\n            tree_list[i][i] = [TreeNode(i)]\\n            for j in reversed(range(1, i)):\\n                tree_list[j][i] = []\\n                for k in range(j, i + 1):\\n                    for left in tree_list[j][k - 1]:\\n                        for right in tree_list[k + 1][i]:\\n                            root = TreeNode(k)\\n                            (root.left, root.right) = (left, right)\\n                            tree_list[j][i].append(root)\\n        return tree_list[1][n]",
                "codeTag": "Java"
            },
            {
                "id": 31639,
                "title": "help-simplify-my-code-the-second-one",
                "content": "    class Solution {\\n    private:\\n    \\tvector<TreeNode*> generateTreesRec(int start, int end){\\n    \\t\\tvector<TreeNode*> v;\\n    \\t\\tif(start > end){\\n    \\t\\t\\tv.push_back(NULL);\\n    \\t\\t\\treturn v;\\n    \\t\\t}\\n    \\t\\tfor(int i = start; i <= end; ++i){\\n    \\t\\t\\tvector<TreeNode*> left = generateTreesRec(start, i - 1);\\n    \\t\\t\\tvector<TreeNode*> right = generateTreesRec(i + 1, end);\\n    \\t\\t\\tTreeNode *node;\\n    \\t\\t\\tfor(int j = 0; j < left.size(); ++j){\\n    \\t\\t\\t\\tfor(int k = 0; k < right.size(); ++k){\\n    \\t\\t\\t\\t\\tnode = new TreeNode(i);\\n    \\t\\t\\t\\t\\tnode->left = left[j];\\n    \\t\\t\\t\\t\\tnode->right = right[k];\\n    \\t\\t\\t\\t\\tv.push_back(node);\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn v;\\n    \\t}\\n    public:\\n        vector<TreeNode *> generateTrees(int n) {\\n            return generateTreesRec(1, n);\\n        }\\n    };\\n\\nI think one defect of the above code is that it constructs trees interleaving with rather than being independent of each other. For example, if `n == 5` and `3` is selected as root, you'll get four trees as follow:\\n\\n<a href=\"http://www.freeimagehosting.net/xepj1\"><img src=\"http://www.freeimagehosting.net/t/xepj1.jpg\"></a>\\n\\nI prefer to construct independent trees so I write the following code...\\n\\n    class Solution {\\n    private:\\n    \\tTreeNode *constructBSTRec(const string &preorder, int ps, int pe, int is, int ie){\\n    \\t\\tif(ps > pe || is > ie || pe - ps != ie - is) return NULL;\\n    \\t\\tTreeNode *root = new TreeNode(preorder[ps] - '0');\\n    \\t\\tint i = preorder[ps] - '0' - 1;\\n    \\t\\tint leftLen = i - is;\\n    \\t\\troot->left = constructBSTRec(preorder, ps + 1, ps + leftLen, is, i - 1);\\n    \\t\\troot->right = constructBSTRec(preorder, ps + leftLen + 1, pe, i + 1, ie);\\n    \\t\\treturn root;\\n    \\t}\\n    \\tTreeNode *constructBST(const string &preorder){\\n    \\t\\treturn constructBSTRec(preorder, 0, preorder.size() - 1, 0, preorder.size() - 1);\\n    \\t}\\n    \\tvector<string> combine(vector<string> &s1, vector<string> &s2){\\n    \\t\\tif(s1.empty() || s2.empty()){\\n    \\t\\t\\treturn s1.empty() ? s2 : s1;\\n    \\t\\t}\\n    \\t\\tvector<string> v;\\n    \\t\\tfor(int i = 0; i < s1.size(); ++i){\\n    \\t\\t\\tfor(int j = 0; j < s2.size(); ++j){\\n    \\t\\t\\t\\tv.push_back(s1[i] + s2[j]);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn v;\\n    \\t}\\n    \\tvector<string> preorderSequence(int start, int end){\\n    \\t\\tvector<string> v;\\n    \\t\\tfor(int i = start; i <= end; ++i){\\n    \\t\\t\\tvector<string> tmp;\\n    \\t\\t\\ttmp.push_back(string(1, i + '0'));\\n    \\t\\t\\tvector<string> left = preorderSequence(start, i - 1);\\n    \\t\\t\\tvector<string> right = preorderSequence(i + 1, end);\\n    \\t\\t\\ttmp = combine(tmp, left);\\n    \\t\\t\\ttmp = combine(tmp, right);\\n    \\t\\t\\tfor(int i = 0; i < tmp.size(); ++i){\\n    \\t\\t\\t\\tv.push_back(tmp[i]);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn v;\\n    \\t}\\n    public:\\n        vector<TreeNode *> generateTrees(int n) {\\n        \\tvector<TreeNode*> trees;\\n        \\tif(n < 0) return trees;\\n        \\tif(n == 0){\\n        \\t\\ttrees.push_back(NULL);\\n        \\t\\treturn trees;\\n        \\t}\\n        \\tvector<string> v = preorderSequence(1, n);\\n        \\tfor(int i = 0; i < v.size(); ++i){\\n        \\t\\ttrees.push_back(constructBST(v[i]));\\n        \\t}\\n        \\treturn trees;\\n        }\\n    };\\n\\nThe main idea is to generate preorder sequences of unique BSTs and construct independent BSTs in the end. But I am afraid it's lack of readability. Can you help me simplify it? Any advice?\\n\\n\\n  [1]: http://www.freeimagehosting.net/xepj1",
                "solutionTags": [],
                "code": "class Solution {\\n    private:\\n    \\tvector<TreeNode*> generateTreesRec(int start, int end){\\n    \\t\\tvector<TreeNode*> v;\\n    \\t\\tif(start > end){\\n    \\t\\t\\tv.push_back(NULL);\\n    \\t\\t\\treturn v;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2212994,
                "title": "dp-solution-in-c-and-java",
                "content": "**Code in C++**\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        return subTrees(1, n);\\n    }\\nprivate:\\n    vector<TreeNode*> subTrees(int start, int end){\\n        vector<TreeNode*> res;\\n        if(start>end){\\n            res.push_back(NULL);\\n            return res;\\n        }\\n        for(int i=start; i<=end; i++){\\n            vector<TreeNode*> left = subTrees(start, i-1);\\n            vector<TreeNode*> right = subTrees(i+1, end);\\n            for(TreeNode* l: left){\\n                for(TreeNode* r: right){\\n                    TreeNode* root = new TreeNode(i);\\n                    root->left = l;\\n                    root->right = r;\\n                    res.push_back(root);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Code in Java**\\n```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        return subTrees(1, n);\\n    }\\n    private List<TreeNode> subTrees(int start, int end){\\n        List<TreeNode> res = new ArrayList();\\n        if(start>end) {\\n            res.add(null);\\n            return res;\\n        }\\n        for(int i=start; i<=end; i++){\\n            List<TreeNode> left = subTrees(start, i-1);\\n            List<TreeNode> right = subTrees(i+1, end);\\n            for(TreeNode l: left){\\n                for(TreeNode r: right){\\n                    TreeNode root = new TreeNode(i);\\n                    root.left = l;\\n                    root.right = r;\\n                    res.add(root);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n}\\n```\\n**Please upvote if you found the solution helpful**\\n*Feel free to ask any questions in the comment section*",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        return subTrees(1, n);\\n    }\\nprivate:\\n    vector<TreeNode*> subTrees(int start, int end){\\n        vector<TreeNode*> res;\\n        if(start>end){\\n            res.push_back(NULL);\\n            return res;\\n        }\\n        for(int i=start; i<=end; i++){\\n            vector<TreeNode*> left = subTrees(start, i-1);\\n            vector<TreeNode*> right = subTrees(i+1, end);\\n            for(TreeNode* l: left){\\n                for(TreeNode* r: right){\\n                    TreeNode* root = new TreeNode(i);\\n                    root->left = l;\\n                    root->right = r;\\n                    res.push_back(root);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        return subTrees(1, n);\\n    }\\n    private List<TreeNode> subTrees(int start, int end){\\n        List<TreeNode> res = new ArrayList();\\n        if(start>end) {\\n            res.add(null);\\n            return res;\\n        }\\n        for(int i=start; i<=end; i++){\\n            List<TreeNode> left = subTrees(start, i-1);\\n            List<TreeNode> right = subTrees(i+1, end);\\n            for(TreeNode l: left){\\n                for(TreeNode r: right){\\n                    TreeNode root = new TreeNode(i);\\n                    root.left = l;\\n                    root.right = r;\\n                    res.add(root);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 730933,
                "title": "easy-java-solution-faster-than-96",
                "content": "```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        if(n < 1)return Collections.EMPTY_LIST;\\n        return helper(1,n);\\n    }\\n    \\n    private List<TreeNode> helper(int start , int end){\\n        List<TreeNode> ans = new ArrayList<>();\\n        if(start > end){\\n            ans.add(null);\\n            return ans;\\n        }\\n        \\n       for(int i = start ; i <= end ;i++ ){\\n           List<TreeNode> left = helper(start , i - 1);\\n           List<TreeNode> right = helper(i + 1 , end);\\n           \\n           for(TreeNode l : left){\\n               for(TreeNode r : right){\\n                 TreeNode root = new TreeNode(i);\\n                   root.left = l;\\n                   root.right = r;\\n                   ans.add(root);\\n               }\\n           }\\n           \\n       }\\n     return ans;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        if(n < 1)return Collections.EMPTY_LIST;\\n        return helper(1,n);\\n    }\\n    \\n    private List<TreeNode> helper(int start , int end){\\n        List<TreeNode> ans = new ArrayList<>();\\n        if(start > end){\\n            ans.add(null);\\n            return ans;\\n        }\\n        \\n       for(int i = start ; i <= end ;i++ ){\\n           List<TreeNode> left = helper(start , i - 1);\\n           List<TreeNode> right = helper(i + 1 , end);\\n           \\n           for(TreeNode l : left){\\n               for(TreeNode r : right){\\n                 TreeNode root = new TreeNode(i);\\n                   root.left = l;\\n                   root.right = r;\\n                   ans.add(root);\\n               }\\n           }\\n           \\n       }\\n     return ans;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720284,
                "title": "python-recursive-explanation",
                "content": "1. For every node with value `val`\\n\\t* **Left subtree\\'s root**\\'s value must be in `[1, val - 1]`\\n\\n\\t* **Right subtree\\'s root**\\'s value must be in `[val + 1, n]` \\n\\n2. Now, what **root value** do we get to try in each recursive call? We try root values in `[start, end]`\\n\\n3. This means for each root, there is a combination / list of `left` and `right` sub**trees** we get to try. (This explains the 2 `for-loops` in the recursive call)\\n\\n4. Therefore, this is what the `build` function does.\\n\\n\\t* Generates a **root** with `val` between `[start, end]`\\n\\n\\t* Generates **all** possible **left** subtree roots with value between `[start, val - 1]`\\n\\n\\t* Generates **all** possible **right** subtree roots with value between `[val + 1, end]`\\n\\n\\t* For **every of these combinations**, it creates a brand new tree and adds it to `trees` before returning it in each recursive call\\n \\n<br><br>\\n\\n```\\nclass Solution:\\n    \\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        \\n        # EDGE CASE\\n        if n == 0:\\n            return []\\n        \\n\\t\\t# CALL ON  BUILD() TO RETURN THE LIST OF ROOTS\\n        return self.build(1, n)\\n    \\n        \\n    def build(self, start, end):\\n        trees = []\\n        \\n        # CHOOSE A ROOT VALUE ANYWHERE BETWEEN [START, END]\\n        for val in range(start, end + 1):\\n            \\n            # ATTACH ROOT TO EVERY POSSIBLE LEFT SUBTREE\\n            for left in self.build(start, val - 1):\\n                \\n                # ATTACH ROOT TO EVERY POSSIBLE RIGHT SUBTREE\\n                for right in self.build(val + 1, end):\\n                    \\n                    # CREATE A TREE AND ADD IT\\n                    trees.append(TreeNode(val, left, right))\\n                    \\n        # [NONE] = THE EMPTY TREE\\n        return trees or [None]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        \\n        # EDGE CASE\\n        if n == 0:\\n            return []\\n        \\n\\t\\t# CALL ON  BUILD() TO RETURN THE LIST OF ROOTS\\n        return self.build(1, n)\\n    \\n        \\n    def build(self, start, end):\\n        trees = []\\n        \\n        # CHOOSE A ROOT VALUE ANYWHERE BETWEEN [START, END]\\n        for val in range(start, end + 1):\\n            \\n            # ATTACH ROOT TO EVERY POSSIBLE LEFT SUBTREE\\n            for left in self.build(start, val - 1):\\n                \\n                # ATTACH ROOT TO EVERY POSSIBLE RIGHT SUBTREE\\n                for right in self.build(val + 1, end):\\n                    \\n                    # CREATE A TREE AND ADD IT\\n                    trees.append(TreeNode(val, left, right))\\n                    \\n        # [NONE] = THE EMPTY TREE\\n        return trees or [None]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688947,
                "title": "javascript-solution-top-down-bottom-up-approach",
                "content": "**Top-Down Approach:**\\n\\n```\\nvar generateTrees = function(n) {\\n    if (n == 0) return [];\\n    \\n    return findAllUniqueTrees(1, n);\\n\\n    function findAllUniqueTrees(start, end) {\\n        const ans = [];\\n        \\n        // base case\\n        if (start > end) {\\n            ans.push(null);\\n            return ans;\\n        };\\n        \\n        if (start == end) {\\n            ans.push(new TreeNode(start));\\n            return ans;\\n        }\\n        \\n        for (let i = start; i <= end; i++) {\\n            const leftSubTrees = findAllUniqueTrees(start, i - 1);\\n            const rightSubTrees = findAllUniqueTrees(i + 1, end);\\n            \\n            for (const leftSubTree of leftSubTrees) {\\n                for (const rightSubTree of rightSubTrees) {\\n                    const root = new TreeNode(i);\\n                    root.left = leftSubTree;\\n                    root.right = rightSubTree;\\n                    ans.push(root);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n<br>\\n\\n---\\n\\n<br>\\n\\n**Bottom-Up Approach:**\\n\\nI did not implement a clone/copy function for the subtrees. Instead, I connected multiple roots to each subtrees. I know this might not be ideal, but it seem to be an acceptable approach from observing solutions to other similar questions.\\n\\nFew personal comments about this problem. There were parts of it that I found difficult which generally transfer over to dynamic programming problems. One was keeping track of the off-by-one issues involving the index of the dp grid vs. the actual number used for root. Also, prior to this problem, I did not quite grasp the relationship amongst the indexes of the 3 nested for-loops. Although not completely, but I felt that this problem gave me a better understanding of them and was definitely was a good practice. Second, thanks to [@zmj97](https://leetcode.com/problems/unique-binary-search-trees-ii/discuss/671388/javascript-dp-solution) providing the idea of what to do when there is no left or right subtree. Like many people, dynamic programming is a problem that I have found difficult to master. However, recently I have committed myself to improving that weakness and hopefully will get better in due time. If anybody has any questions or constructive criticism of ways of improving my solution or approaches to dynamic programming in general, please feel free to leave your comments below. Thank you.\\n\\n<br>\\n\\n```\\nvar generateTrees = function(n) {\\n    if (n === 0) return [];\\n\\n    var dp = [];\\n    \\n    for (var i = 0; i < n; i++) {\\n        dp[i] = [];\\n        for (var j = 0; j < n; j++) {\\n            dp[i][j] = [];\\n        }\\n    }\\n\\n    for (var len = 2; len <= n; len++) {\\n        for (var start = 1; start <= n - len + 1; start++) {\\n            const end = start + len - 1;\\n            for (let mid = start; mid <= end; mid++) {\\n                const leftSubTrees = mid - 1 - 1 < 0 ? [] : dp[start - 1][mid - 1 - 1];\\n                const rightSubTrees = mid + 1 - 1 >= n ? [] : dp[mid + 1 - 1][end - 1];\\n                \\n                if (leftSubTrees.length == 0) leftSubTrees.push(null);\\n                if (rightSubTrees.length == 0) rightSubTrees.push(null);\\n                \\n                for (const leftSubTree of leftSubTrees) {\\n                    for (const rightSubTree of rightSubTrees) {\\n                        const root = new TreeNode(mid);\\n                        root.left = leftSubTree;\\n                        root.right = rightSubTree;\\n                        dp[start - 1][end - 1].push(root);\\n                    }\\n                }\\n            }\\n        }\\n    \\n    }\\n\\n    return dp[0][n - 1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar generateTrees = function(n) {\\n    if (n == 0) return [];\\n    \\n    return findAllUniqueTrees(1, n);\\n\\n    function findAllUniqueTrees(start, end) {\\n        const ans = [];\\n        \\n        // base case\\n        if (start > end) {\\n            ans.push(null);\\n            return ans;\\n        };\\n        \\n        if (start == end) {\\n            ans.push(new TreeNode(start));\\n            return ans;\\n        }\\n        \\n        for (let i = start; i <= end; i++) {\\n            const leftSubTrees = findAllUniqueTrees(start, i - 1);\\n            const rightSubTrees = findAllUniqueTrees(i + 1, end);\\n            \\n            for (const leftSubTree of leftSubTrees) {\\n                for (const rightSubTree of rightSubTrees) {\\n                    const root = new TreeNode(i);\\n                    root.left = leftSubTree;\\n                    root.right = rightSubTree;\\n                    ans.push(root);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nvar generateTrees = function(n) {\\n    if (n === 0) return [];\\n\\n    var dp = [];\\n    \\n    for (var i = 0; i < n; i++) {\\n        dp[i] = [];\\n        for (var j = 0; j < n; j++) {\\n            dp[i][j] = [];\\n        }\\n    }\\n\\n    for (var len = 2; len <= n; len++) {\\n        for (var start = 1; start <= n - len + 1; start++) {\\n            const end = start + len - 1;\\n            for (let mid = start; mid <= end; mid++) {\\n                const leftSubTrees = mid - 1 - 1 < 0 ? [] : dp[start - 1][mid - 1 - 1];\\n                const rightSubTrees = mid + 1 - 1 >= n ? [] : dp[mid + 1 - 1][end - 1];\\n                \\n                if (leftSubTrees.length == 0) leftSubTrees.push(null);\\n                if (rightSubTrees.length == 0) rightSubTrees.push(null);\\n                \\n                for (const leftSubTree of leftSubTrees) {\\n                    for (const rightSubTree of rightSubTrees) {\\n                        const root = new TreeNode(mid);\\n                        root.left = leftSubTree;\\n                        root.right = rightSubTree;\\n                        dp[start - 1][end - 1].push(root);\\n                    }\\n                }\\n            }\\n        }\\n    \\n    }\\n\\n    return dp[0][n - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31600,
                "title": "quite-clean-java-solution-with-explanation",
                "content": "For all possible root of the trees (i.e. 1, 2, ..., n), get the list of left subtrees and list of right subtrees, recursively. Now, for every left and right subtree combination, create a new tree and add to resultant list.\\n\\nHere, \"start > end\" becomes the base case for recursion, for which I add \"null\" as the only element of list, which will form the only possible left or right subtree. (To understand why this works, check with n = 1).\\n\\nn = 0 is handled separately, since leetcode expects an empty list, rather than a list with a null value.\\n\\n    public class Solution {\\n        public List<TreeNode> generateTrees(int n) {\\n            if(n == 0)\\n                return new ArrayList<TreeNode>();\\n            return generateTrees(1, n);\\n        }\\n        \\n        List<TreeNode> generateTrees(int start, int end) {\\n            List<TreeNode> result = new ArrayList<TreeNode>();\\n            if(start > end) {\\n                result.add(null);\\n                return result;\\n            }\\n            for(int i = start; i <= end; i++) {\\n                List<TreeNode> leftSubTrees = generateTrees(start, i - 1);\\n                List<TreeNode> rightSubTrees = generateTrees(i + 1, end);\\n                for(TreeNode left : leftSubTrees) {\\n                    for(TreeNode right : rightSubTrees) {\\n                        TreeNode root = new TreeNode(i);\\n                        root.left = left;\\n                        root.right = right;\\n                        result.add(root);\\n                    }\\n                }\\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<TreeNode> generateTrees(int n) {\\n            if(n == 0)\\n                return new ArrayList<TreeNode>();\\n            return generateTrees(1, n);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3187679,
                "title": "94-15-unique-binary-search-trees-ii-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo generate all structurally unique BST\\'s with n nodes, we can use a recursive approach. The idea is to fix each number i (1 <= i <= n) as the root of the tree and then recursively generate all the left and right subtrees that can be formed using the remaining numbers (1, 2, ..., i-1) and (i+1, i+2, ..., n) respectively.\\n\\nFor example, to generate all the BST\\'s with 3 nodes, we can fix 1 as the root and recursively generate all the BST\\'s with 0 and 2 nodes respectively. Then we can fix 2 as the root and recursively generate all the BST\\'s with 1 node on the left and 1 node on the right. Finally, we can fix 3 as the root and recursively generate all the BST\\'s with 2 and 0 nodes respectively.\\n\\nTo avoid generating duplicate trees, we can use memoization to store the trees generated for each combination of left and right subtree sizes.\\n\\n# Complexity\\n- Time complexity:\\nBeats\\n89.57%\\n\\n- Space complexity:\\nBeats\\n94.15%\\n\\n# Code\\n```\\nclass TreeNode:\\n    def __init__(self, val=0, left=None, right=None):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n\\nclass Solution:\\n   def generateTrees(self, n: \\'int\\') -> \\'List[TreeNode]\\':\\n    memo = {}\\n    \\n    def generate_trees_helper(start: int, end: int) -> List[TreeNode]:\\n        if start > end:\\n            return [None]\\n        \\n        if (start, end) in memo:\\n            return memo[(start, end)]\\n        \\n        result = []\\n        \\n        for i in range(start, end+1):\\n            left_subtrees = generate_trees_helper(start, i-1)\\n            right_subtrees = generate_trees_helper(i+1, end)\\n            \\n            for left in left_subtrees:\\n                for right in right_subtrees:\\n                    root = TreeNode(i)\\n                    root.left = left\\n                    root.right = right\\n                    result.append(root)\\n        \\n        memo[(start, end)] = result\\n        \\n        return result\\n    \\n    return generate_trees_helper(1, n)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass TreeNode:\\n    def __init__(self, val=0, left=None, right=None):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n\\nclass Solution:\\n   def generateTrees(self, n: \\'int\\') -> \\'List[TreeNode]\\':\\n    memo = {}\\n    \\n    def generate_trees_helper(start: int, end: int) -> List[TreeNode]:\\n        if start > end:\\n            return [None]\\n        \\n        if (start, end) in memo:\\n            return memo[(start, end)]\\n        \\n        result = []\\n        \\n        for i in range(start, end+1):\\n            left_subtrees = generate_trees_helper(start, i-1)\\n            right_subtrees = generate_trees_helper(i+1, end)\\n            \\n            for left in left_subtrees:\\n                for right in right_subtrees:\\n                    root = TreeNode(i)\\n                    root.left = left\\n                    root.right = right\\n                    result.append(root)\\n        \\n        memo[(start, end)] = result\\n        \\n        return result\\n    \\n    return generate_trees_helper(1, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 299072,
                "title": "c-16ms-beats-98-1-of-cpp-submissions",
                "content": "```\\nvector<TreeNode*> genTreesUtil(int beg, int end) {\\n\\tif (end < beg) return { nullptr };\\n\\tif (end == beg) return { new TreeNode(beg) };\\n\\n\\tvector<TreeNode*> trees;\\n\\tfor (int i = beg; i <= end; ++i) {\\n\\n\\t\\tauto leftTrees = genTreesUtil(beg, i - 1);\\n\\t\\tauto rightTrees = genTreesUtil(i + 1, end);\\n\\n\\t\\tfor (auto& l : leftTrees)\\n\\t\\t\\tfor (auto& r : rightTrees) {\\n\\t\\t\\t\\tauto t = new TreeNode(i);\\n\\t\\t\\t\\tt->left = l;\\n\\t\\t\\t\\tt->right = r;\\n\\n\\t\\t\\t\\ttrees.push_back(t);\\n\\t\\t\\t}\\n\\t}\\n\\n\\treturn trees;\\n}\\n\\nvector<TreeNode*> generateTrees(int n) {\\n\\tif (n == 0) return {};\\n\\treturn genTreesUtil(1, n);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nvector<TreeNode*> genTreesUtil(int beg, int end) {\\n\\tif (end < beg) return { nullptr };\\n\\tif (end == beg) return { new TreeNode(beg) };\\n\\n\\tvector<TreeNode*> trees;\\n\\tfor (int i = beg; i <= end; ++i) {\\n\\n\\t\\tauto leftTrees = genTreesUtil(beg, i - 1);\\n\\t\\tauto rightTrees = genTreesUtil(i + 1, end);\\n\\n\\t\\tfor (auto& l : leftTrees)\\n\\t\\t\\tfor (auto& r : rightTrees) {\\n\\t\\t\\t\\tauto t = new TreeNode(i);\\n\\t\\t\\t\\tt->left = l;\\n\\t\\t\\t\\tt->right = r;\\n\\n\\t\\t\\t\\ttrees.push_back(t);\\n\\t\\t\\t}\\n\\t}\\n\\n\\treturn trees;\\n}\\n\\nvector<TreeNode*> generateTrees(int n) {\\n\\tif (n == 0) return {};\\n\\treturn genTreesUtil(1, n);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31627,
                "title": "a-straightforward-python-solution",
                "content": "    from itertools import product\\n    \\n    class Solution:\\n        # @param {integer} n\\n        # @return {TreeNode[]}\\n        def generateTrees(self, n):\\n            return self.BST([i+1 for i in range(n)])\\n            \\n        def BST(self, nodes):\\n            trees = []\\n            for i in range(len(nodes)):\\n                for leftSubTree, rightSubTree in product(self.BST(nodes[:i]), self.BST(nodes[i+1:])):\\n                    root = TreeNode(nodes[i])\\n                    root.left, root.right = leftSubTree, rightSubTree\\n                    trees.append(root)\\n                \\n            return trees or [None]",
                "solutionTags": [],
                "code": "class Solution:\\n        # @param {integer}",
                "codeTag": "Java"
            },
            {
                "id": 31638,
                "title": "python-accepted-python-code",
                "content": "    class Solution:\\n        # @return a list of tree node\\n        def generate(self,s,t):\\n            '''recursion with left and right branches'''\\n            if s>t:return [None];\\n            if s==t:return [TreeNode(s)];\\n            re=[];\\n            for i in range(s,t+1):\\n                left=self.generate(s,i-1);\\n                right=self.generate(i+1,t);\\n                for l in left:\\n                    for r in right:\\n                        tmp=TreeNode(i);\\n                        tmp.left=l;\\n                        tmp.right=r;\\n                        re.append(tmp);\\n            return re;\\n        def generateTrees(self, n):\\n            return self.generate(1,n);\\n\\nthe code is straight forward,first generate the left tree, then generate the right tree. for each left and right tree, generate the tree with root.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @return a list of tree node\\n        def generate(self,s,t):\\n            '''recursion with left and right branches'''\\n            if s>t:return [None];\\n            if s==t:return [TreeNode(s)];\\n            re=[];\\n            for i in range(s,t+1):\\n                left=self.generate(s,i-1);\\n                right=self.generate(i+1,t);\\n                for l in left:\\n                    for r in right:\\n                        tmp=TreeNode(i);\\n                        tmp.left=l;\\n                        tmp.right=r;\\n                        re.append(tmp);\\n            return re;\\n        def generateTrees(self, n):\\n            return self.generate(1,n);\\n\\nthe code is straight forward,first generate the left tree, then generate the right tree. for each left and right tree, generate the tree with root.",
                "codeTag": "Java"
            },
            {
                "id": 3837403,
                "title": "c-recursive-catalan-number-like-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse 3D array for TreeNode* as memoization. Solve it recursely with memo. Again a DP solution is done. \\n\\nThis code generates all possible unique binary search trees  for a given range [1, n] using dynamic programming. It uses a 3D vector \\'dp\\' to store computed values and avoids redundant calculations. The function \\'BSTree\\' recursively forms BSTs for each range [s, e], combining left and right subtrees. The \\'generateTrees\\' function initializes \\'dp\\', then calls \\'BSTree\\' with range [1, n] to compute all unique BSTs. The approach is efficient and relates to Catalan numbers, representing the number of BSTs that can be formed using \\'n\\' nodes.\\n\\n# Catalan numbers\\nCatalan numbers can be given by a recursive way as follows\\n$$ \\nG(0)=1, G(n)=\\\\sum_{i=1}^nG(i-1)G(n-i)\\n$$\\nThe solution is related to this recursive recurrence.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimilar idea as in solving the hard question 894. All Possible Full Binary Trees.\\n[Please Turn on English subtitles if neccessary]\\n[https://youtu.be/AVbHDf6H_gE](https://youtu.be/AVbHDf6H_gE)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(n * G(n))$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(n^2 * G(n))$\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<vector<TreeNode*>>> dp;\\n    \\n    vector<TreeNode*> BSTree(int s, int e){\\n        if (s > e) return {NULL};\\n        if (s == e) return {new TreeNode(s)};\\n        \\n        if (dp[s][e].size()>0) return dp[s][e];\\n        \\n        vector<TreeNode*> ans;\\n        for (int j = s; j <= e; j++) {\\n            vector<TreeNode*> Left = BSTree(s, j - 1);\\n            vector<TreeNode*> Right = BSTree(j + 1, e);\\n            \\n            for (TreeNode* l : Left) {\\n                for (TreeNode* r : Right) {\\n                    TreeNode* root = new TreeNode(j, l, r);\\n                    ans.push_back(root);\\n                }\\n            }\\n        }\\n        return dp[s][e] = ans;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        dp.assign(n+1, vector(n+1, vector<TreeNode*>()));\\n        return BSTree(1, n);\\n    }\\n};\\n```\\n# Code with Explanation in comments\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    vector<vector<vector<TreeNode*>>> dp; // 3D vector to store computed values for dynamic programming\\n    \\n    // Function to generate all possible unique binary search trees given a range [s, e]\\n    vector<TreeNode*> BSTree(int s, int e) {\\n        // Base cases: If the range is invalid or contains a single element, return appropriate values.\\n        if (s > e) return {NULL}; // A single element in the range [s, e] cannot form a tree, so return NULL.\\n        if (s == e) return {new TreeNode(s)}; // A single element in the range is a valid tree by itself.\\n\\n        if (dp[s][e].size() > 0) return dp[s][e]; // If the value has already been computed, return it from the dp array.\\n\\n        vector<TreeNode*> ans; // Vector to store all possible BSTs in the range [s, e].\\n\\n        // Loop through each possible root node value (j) in the range [s, e]\\n        for (int j = s; j <= e; j++) {\\n            // Recursively generate all possible left subtrees (Left) from range [s, j-1]\\n            vector<TreeNode*> Left = BSTree(s, j - 1);\\n\\n            // Recursively generate all possible right subtrees (Right) from range [j+1, e]\\n            vector<TreeNode*> Right = BSTree(j + 1, e);\\n\\n            // Combine all possible combinations of left and right subtrees with the current root value (j)\\n            for (TreeNode* l : Left) {\\n                for (TreeNode* r : Right) {\\n                    TreeNode* root = new TreeNode(j, l, r); // Create a new tree with root value (j), left subtree (l), and right subtree (r).\\n                    ans.push_back(root); // Add the current tree to the result vector.\\n                }\\n            }\\n        }\\n\\n        return dp[s][e] = ans; // Store the computed value in the dp array and return the result.\\n    }\\n\\n    vector<TreeNode*> generateTrees(int n) {\\n        dp.assign(n + 1, vector(n + 1, vector<TreeNode*>())); // Initialize the dp array with dimensions (n+1) x (n+1) x unknown.\\n        return BSTree(1, n); // Call the helper function with the range [1, n] to generate all possible BSTs from 1 to n.\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<vector<TreeNode*>>> dp;\\n    \\n    vector<TreeNode*> BSTree(int s, int e){\\n        if (s > e) return {NULL};\\n        if (s == e) return {new TreeNode(s)};\\n        \\n        if (dp[s][e].size()>0) return dp[s][e];\\n        \\n        vector<TreeNode*> ans;\\n        for (int j = s; j <= e; j++) {\\n            vector<TreeNode*> Left = BSTree(s, j - 1);\\n            vector<TreeNode*> Right = BSTree(j + 1, e);\\n            \\n            for (TreeNode* l : Left) {\\n                for (TreeNode* r : Right) {\\n                    TreeNode* root = new TreeNode(j, l, r);\\n                    ans.push_back(root);\\n                }\\n            }\\n        }\\n        return dp[s][e] = ans;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        dp.assign(n+1, vector(n+1, vector<TreeNode*>()));\\n        return BSTree(1, n);\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    vector<vector<vector<TreeNode*>>> dp; // 3D vector to store computed values for dynamic programming\\n    \\n    // Function to generate all possible unique binary search trees given a range [s, e]\\n    vector<TreeNode*> BSTree(int s, int e) {\\n        // Base cases: If the range is invalid or contains a single element, return appropriate values.\\n        if (s > e) return {NULL}; // A single element in the range [s, e] cannot form a tree, so return NULL.\\n        if (s == e) return {new TreeNode(s)}; // A single element in the range is a valid tree by itself.\\n\\n        if (dp[s][e].size() > 0) return dp[s][e]; // If the value has already been computed, return it from the dp array.\\n\\n        vector<TreeNode*> ans; // Vector to store all possible BSTs in the range [s, e].\\n\\n        // Loop through each possible root node value (j) in the range [s, e]\\n        for (int j = s; j <= e; j++) {\\n            // Recursively generate all possible left subtrees (Left) from range [s, j-1]\\n            vector<TreeNode*> Left = BSTree(s, j - 1);\\n\\n            // Recursively generate all possible right subtrees (Right) from range [j+1, e]\\n            vector<TreeNode*> Right = BSTree(j + 1, e);\\n\\n            // Combine all possible combinations of left and right subtrees with the current root value (j)\\n            for (TreeNode* l : Left) {\\n                for (TreeNode* r : Right) {\\n                    TreeNode* root = new TreeNode(j, l, r); // Create a new tree with root value (j), left subtree (l), and right subtree (r).\\n                    ans.push_back(root); // Add the current tree to the result vector.\\n                }\\n            }\\n        }\\n\\n        return dp[s][e] = ans; // Store the computed value in the dp array and return the result.\\n    }\\n\\n    vector<TreeNode*> generateTrees(int n) {\\n        dp.assign(n + 1, vector(n + 1, vector<TreeNode*>())); // Initialize the dp array with dimensions (n+1) x (n+1) x unknown.\\n        return BSTree(1, n); // Call the helper function with the range [1, n] to generate all possible BSTs from 1 to n.\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491113,
                "title": "python-elegant-short-three-lines-top-down-dp-lru-cache",
                "content": "# Complexity\\n- Time complexity: $$O(n!)$$\\n- Space complexity: $$O(n^{3})$$\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:\\n        return self.__generate(lo=1, hi=n)\\n\\n    @classmethod\\n    @cache\\n    def __generate(cls, lo: int, hi: int) -> list:\\n        if lo > hi:\\n            return [None]\\n        return [\\n            TreeNode(root, left, right)\\n            for root in range(lo, hi + 1)              # All possible roots for the current subarray\\n            for left in cls.__generate(lo, root - 1)   # All possible trees to the left of the root element\\n            for right in cls.__generate(root + 1, hi)  # All possible trees to the right of the root element\\n        ]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n\\n    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:\\n        return self.__generate(lo=1, hi=n)\\n\\n    @classmethod\\n    @cache\\n    def __generate(cls, lo: int, hi: int) -> list:\\n        if lo > hi:\\n            return [None]\\n        return [\\n            TreeNode(root, left, right)\\n            for root in range(lo, hi + 1)              # All possible roots for the current subarray\\n            for left in cls.__generate(lo, root - 1)   # All possible trees to the left of the root element\\n            for right in cls.__generate(root + 1, hi)  # All possible trees to the right of the root element\\n        ]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1495639,
                "title": "12-ms-97-faster-cpp-solution-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> helper(int start, int end){\\n        vector<TreeNode*> ans;\\n        if(start > end){\\n            ans.push_back(NULL);\\n            return ans;\\n        }\\n        \\n        for(int i = start; i <= end; i++){\\n            auto left = helper(start, i - 1);\\n            auto right = helper(i + 1, end);\\n            \\n            for(auto l : left){\\n                for(auto r : right){\\n                    TreeNode* root = new TreeNode(i);\\n                    \\n                    root->left = l;\\n                    root->right = r;\\n                    ans.push_back(root);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        auto h = helper(1, n);\\n        return h;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> helper(int start, int end){\\n        vector<TreeNode*> ans;\\n        if(start > end){\\n            ans.push_back(NULL);\\n            return ans;\\n        }\\n        \\n        for(int i = start; i <= end; i++){\\n            auto left = helper(start, i - 1);\\n            auto right = helper(i + 1, end);\\n            \\n            for(auto l : left){\\n                for(auto r : right){\\n                    TreeNode* root = new TreeNode(i);\\n                    \\n                    root->left = l;\\n                    root->right = r;\\n                    ans.push_back(root);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        auto h = helper(1, n);\\n        return h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 865956,
                "title": "simple-java-solution-with-comments-1-ms-recursive",
                "content": "Algorithm:\\n\\n- Imagine the input as a continuous array of integers.\\n- move in a sliding window fashion considering every element as possible root.\\n- For every element chosen as root\\n\\t- everything in the array on the left will form the possible left subtrees\\n\\t- everything in the array on the right will form the possible right subtrees\\n- Use this list of generated subtrees to form the complete forest\\n\\n```\\nclass Solution {\\n    \\n    public List<TreeNode> generateTrees(int n) {\\n        return treeBuilder(1, n);\\n    }\\n    \\n    private List<TreeNode> treeBuilder(int start, int end) {\\n        if(start > end) return Collections.emptyList();\\n        List<TreeNode> res = new ArrayList<>();\\n        // n == 1\\n        if(start == end) {\\n            res.add(new TreeNode(start));\\n            return res;\\n        }\\n        \\n        // n == 2\\n        if( start+1 == end) {\\n            res.add(new TreeNode(start, null, new TreeNode(start+1)));\\n            res.add(new TreeNode(start+1, new TreeNode(start), null));\\n            return res;\\n        }\\n        \\n        for(int i=start; i<=end; i++) {\\n            TreeNode newRoot = new TreeNode(i);\\n            List<TreeNode> left = treeBuilder(start, i-1); // build trees only using left elements\\n            List<TreeNode> right = treeBuilder(i+1, end); // build trees only using right elements\\n            \\n            if(left.size() == 0) { // No left subtrees possible\\n                for(TreeNode node : right) {\\n                    newRoot.right = node;\\n                    res.add(copyTree(newRoot));\\n                    newRoot.right = null;\\n                }\\n            } else if(right.size() == 0) { // No right subtrees possible\\n                for(TreeNode node : left) {\\n                    newRoot.left = node;\\n                    res.add(copyTree(newRoot));\\n                    newRoot.left = null;\\n                }\\n            } else {\\n\\t\\t\\t\\t// For every left subtree; process every possibility of right subtree\\n\\t\\t\\t\\t// This is analogous to taking a cartesian product of possibilities\\n                for (TreeNode node : left) {\\n                    newRoot.left = node;\\n                    for(TreeNode node1 : right) {\\n                        newRoot.right = node1;\\n                        res.add(copyTree(newRoot));\\n                        newRoot.right = null;\\n                    }\\n                    newRoot.left = null;\\n                }\\n            }\\n            \\n        }\\n        \\n        return res;\\n    }\\n    \\n    // Helper Function to deep copy a given tree\\n    private TreeNode copyTree (TreeNode head) {\\n        if(head == null) return head;\\n        TreeNode temp = new TreeNode(head.val);\\n        temp.left = copyTree(head.left);\\n        temp.right = copyTree(head.right);\\n        return temp;\\n    }\\n}\\n```\\n\\n**Please Vote up, if this helped you!!**\\n\\nHappy Coding! :)",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public List<TreeNode> generateTrees(int n) {\\n        return treeBuilder(1, n);\\n    }\\n    \\n    private List<TreeNode> treeBuilder(int start, int end) {\\n        if(start > end) return Collections.emptyList();\\n        List<TreeNode> res = new ArrayList<>();\\n        // n == 1\\n        if(start == end) {\\n            res.add(new TreeNode(start));\\n            return res;\\n        }\\n        \\n        // n == 2\\n        if( start+1 == end) {\\n            res.add(new TreeNode(start, null, new TreeNode(start+1)));\\n            res.add(new TreeNode(start+1, new TreeNode(start), null));\\n            return res;\\n        }\\n        \\n        for(int i=start; i<=end; i++) {\\n            TreeNode newRoot = new TreeNode(i);\\n            List<TreeNode> left = treeBuilder(start, i-1); // build trees only using left elements\\n            List<TreeNode> right = treeBuilder(i+1, end); // build trees only using right elements\\n            \\n            if(left.size() == 0) { // No left subtrees possible\\n                for(TreeNode node : right) {\\n                    newRoot.right = node;\\n                    res.add(copyTree(newRoot));\\n                    newRoot.right = null;\\n                }\\n            } else if(right.size() == 0) { // No right subtrees possible\\n                for(TreeNode node : left) {\\n                    newRoot.left = node;\\n                    res.add(copyTree(newRoot));\\n                    newRoot.left = null;\\n                }\\n            } else {\\n\\t\\t\\t\\t// For every left subtree; process every possibility of right subtree\\n\\t\\t\\t\\t// This is analogous to taking a cartesian product of possibilities\\n                for (TreeNode node : left) {\\n                    newRoot.left = node;\\n                    for(TreeNode node1 : right) {\\n                        newRoot.right = node1;\\n                        res.add(copyTree(newRoot));\\n                        newRoot.right = null;\\n                    }\\n                    newRoot.left = null;\\n                }\\n            }\\n            \\n        }\\n        \\n        return res;\\n    }\\n    \\n    // Helper Function to deep copy a given tree\\n    private TreeNode copyTree (TreeNode head) {\\n        if(head == null) return head;\\n        TreeNode temp = new TreeNode(head.val);\\n        temp.left = copyTree(head.left);\\n        temp.right = copyTree(head.right);\\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526542,
                "title": "c-simple-recursive-solution-detailed-explanation",
                "content": "```\\n/*\\n    95. Unique Binary Search Trees II\\n    https://leetcode.com/problems/unique-binary-search-trees-ii/\\n*/\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> createTree(int start, int end) {\\n        // base case: return nullptr\\n        if(end < start)\\n            return vector<TreeNode*>{nullptr};\\n\\n        vector<TreeNode*> ans;\\n        // for current interval each number is taken as root once\\n        for(int i = start; i <= end; i++) {\\n            vector<TreeNode*> left_subtree, right_subtree;\\n            // recurse for left and right subtrees\\n            left_subtree = createTree(start, i-1);\\n            right_subtree = createTree(i+1, end);\\n            \\n            // fixing the current root, traverse through the ]\\n            // different root nodes of left and right subtrees and\\n            // make them the child nodes one by one\\n            for(int j = 0; j < left_subtree.size(); j++) {\\n                for(int k = 0; k < right_subtree.size(); k++) {\\n                    // create the root \\n                    TreeNode* root = new TreeNode(i);\\n                    root->left = left_subtree[j];\\n                    root->right = right_subtree[k];\\n                    ans.emplace_back(root);\\n                }\\n            }\\n\\n        }\\n\\n        return ans;\\n    }\\n\\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n <= 0)\\n            return vector<TreeNode*>{};\\n        return createTree(1, n);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n    95. Unique Binary Search Trees II\\n    https://leetcode.com/problems/unique-binary-search-trees-ii/\\n*/\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> createTree(int start, int end) {\\n        // base case: return nullptr\\n        if(end < start)\\n            return vector<TreeNode*>{nullptr};\\n\\n        vector<TreeNode*> ans;\\n        // for current interval each number is taken as root once\\n        for(int i = start; i <= end; i++) {\\n            vector<TreeNode*> left_subtree, right_subtree;\\n            // recurse for left and right subtrees\\n            left_subtree = createTree(start, i-1);\\n            right_subtree = createTree(i+1, end);\\n            \\n            // fixing the current root, traverse through the ]\\n            // different root nodes of left and right subtrees and\\n            // make them the child nodes one by one\\n            for(int j = 0; j < left_subtree.size(); j++) {\\n                for(int k = 0; k < right_subtree.size(); k++) {\\n                    // create the root \\n                    TreeNode* root = new TreeNode(i);\\n                    root->left = left_subtree[j];\\n                    root->right = right_subtree[k];\\n                    ans.emplace_back(root);\\n                }\\n            }\\n\\n        }\\n\\n        return ans;\\n    }\\n\\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n <= 0)\\n            return vector<TreeNode*>{};\\n        return createTree(1, n);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 480196,
                "title": "two-python-sol-based-on-dp-and-recursion-with-memorization-with-explanation",
                "content": "Two Python sol. based on DP and recursion with memorization\\n\\n------------------------------------------\\n\\nMethod_#1: bottom-up dynamic programming\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    \\n    \\n    def clone_with_offset(self, node: TreeNode, offset):\\n        \\n        if not node:\\n            return None\\n        \\n        else:\\n            \\n            # Clone whole tree with constant value offset\\n            root_node = TreeNode( node.val + offset )\\n            root_node.left = self.clone_with_offset( node.left, offset )\\n            root_node.right = self.clone_with_offset( node.right, offset )\\n            \\n            return root_node\\n    \\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        \\n        \\n        if n == 0:\\n            # Quick response for empty tree\\n            return []\\n        \\n        # dynamic programming table\\n        bst_dp_table = [ None for i in range(n+1) ]\\n        \\n        # base case: \\n        bst_dp_table[0] = [None]\\n        \\n        \\n        # bottom-up. build bst with k nodes, k from 1 to n\\n        for number_of_nodes in range(1, n+1):\\n            \\n            bst_dp_table[number_of_nodes] = []\\n            \\n            # for root node of bst:     1 node                            \\n            # for left-subtree of bst : (number_of_nodes_on_left) nodes     \\n            # for right-subtrr of bst : (k-1-number_of_nodes_on_left) nodes \\n            for number_of_nodes_on_left in range(0, number_of_nodes):\\n                \\n                for left_subtree in bst_dp_table[number_of_nodes_on_left]:\\n                    \\n                    number_of_nodes_on_right = number_of_nodes-1-number_of_nodes_on_left\\n                    \\n                    for right_subtree in bst_dp_table[number_of_nodes_on_right]:\\n                        \\n                        # construct one unique bst\\n                        root_of_bst = TreeNode( number_of_nodes_on_left+1 )\\n                        root_of_bst.left = left_subtree\\n                        root_of_bst.right = self.clone_with_offset(right_subtree, number_of_nodes_on_left+1)\\n                        \\n                        # update dynamic programming table\\n                        bst_dp_table[number_of_nodes].append( root_of_bst )\\n            \\n        return bst_dp_table[n]\\n```\\n\\n---------------------------------------------------------------------------------\\n\\nMethod_#2: top-down recursion with memorization\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n\\n    def __init__(self):\\n        \\n        # memorization table\\n        # key   : (lower bound of bst, upper bound of bst)\\n        # value : a list of bst, all nodes\\' value in range lower bound to upper bound.\\n        self.bst_dict = dict()\\n    \\n    def tree_factory(self, min_val, max_val):\\n        \\n        tree_list = []\\n        \\n        if min_val > max_val:\\n            # Invalid case\\n            tree_list.append( None )\\n            return tree_list\\n        \\n        if (min_val, max_val) in self.bst_dict:\\n            # speed-up by looking memorization table\\n            return self.bst_dict[(min_val, max_val)]\\n        \\n        \\n        # generate binary search trees from all possible root node value\\n        for root_node_value in range( min_val, max_val+1):\\n            \\n            left_sub_trees = self.tree_factory( min_val, root_node_value-1 )\\n            right_sub_trees = self.tree_factory( root_node_value+1, max_val )\\n            \\n            for left_subtree in left_sub_trees:\\n                for right_subtree in right_sub_trees:\\n                    \\n\\t\\t\\t\\t\\t# construct one unique bst\\n                    root_node = TreeNode( root_node_value )\\n                    root_node.left = left_subtree\\n                    root_node.right = right_subtree\\n                    \\n                    tree_list.append( root_node )\\n        \\n        # update memorization table\\n        self.bst_dict[(min_val, max_val)] = tree_list            \\n        return tree_list\\n        \\n        \\n        \\n    \\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        if n == 0:\\n            # Quick response for empty tree\\n            return []\\n        else:\\n            return self.tree_factory( min_val = 1, max_val = n )\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    \\n    \\n    def clone_with_offset(self, node: TreeNode, offset):\\n        \\n        if not node:\\n            return None\\n        \\n        else:\\n            \\n            # Clone whole tree with constant value offset\\n            root_node = TreeNode( node.val + offset )\\n            root_node.left = self.clone_with_offset( node.left, offset )\\n            root_node.right = self.clone_with_offset( node.right, offset )\\n            \\n            return root_node\\n    \\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        \\n        \\n        if n == 0:\\n            # Quick response for empty tree\\n            return []\\n        \\n        # dynamic programming table\\n        bst_dp_table = [ None for i in range(n+1) ]\\n        \\n        # base case: \\n        bst_dp_table[0] = [None]\\n        \\n        \\n        # bottom-up. build bst with k nodes, k from 1 to n\\n        for number_of_nodes in range(1, n+1):\\n            \\n            bst_dp_table[number_of_nodes] = []\\n            \\n            # for root node of bst:     1 node                            \\n            # for left-subtree of bst : (number_of_nodes_on_left) nodes     \\n            # for right-subtrr of bst : (k-1-number_of_nodes_on_left) nodes \\n            for number_of_nodes_on_left in range(0, number_of_nodes):\\n                \\n                for left_subtree in bst_dp_table[number_of_nodes_on_left]:\\n                    \\n                    number_of_nodes_on_right = number_of_nodes-1-number_of_nodes_on_left\\n                    \\n                    for right_subtree in bst_dp_table[number_of_nodes_on_right]:\\n                        \\n                        # construct one unique bst\\n                        root_of_bst = TreeNode( number_of_nodes_on_left+1 )\\n                        root_of_bst.left = left_subtree\\n                        root_of_bst.right = self.clone_with_offset(right_subtree, number_of_nodes_on_left+1)\\n                        \\n                        # update dynamic programming table\\n                        bst_dp_table[number_of_nodes].append( root_of_bst )\\n            \\n        return bst_dp_table[n]\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n\\n    def __init__(self):\\n        \\n        # memorization table\\n        # key   : (lower bound of bst, upper bound of bst)\\n        # value : a list of bst, all nodes\\' value in range lower bound to upper bound.\\n        self.bst_dict = dict()\\n    \\n    def tree_factory(self, min_val, max_val):\\n        \\n        tree_list = []\\n        \\n        if min_val > max_val:\\n            # Invalid case\\n            tree_list.append( None )\\n            return tree_list\\n        \\n        if (min_val, max_val) in self.bst_dict:\\n            # speed-up by looking memorization table\\n            return self.bst_dict[(min_val, max_val)]\\n        \\n        \\n        # generate binary search trees from all possible root node value\\n        for root_node_value in range( min_val, max_val+1):\\n            \\n            left_sub_trees = self.tree_factory( min_val, root_node_value-1 )\\n            right_sub_trees = self.tree_factory( root_node_value+1, max_val )\\n            \\n            for left_subtree in left_sub_trees:\\n                for right_subtree in right_sub_trees:\\n                    \\n\\t\\t\\t\\t\\t# construct one unique bst\\n                    root_node = TreeNode( root_node_value )\\n                    root_node.left = left_subtree\\n                    root_node.right = right_subtree\\n                    \\n                    tree_list.append( root_node )\\n        \\n        # update memorization table\\n        self.bst_dict[(min_val, max_val)] = tree_list            \\n        return tree_list\\n        \\n        \\n        \\n    \\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        if n == 0:\\n            # Quick response for empty tree\\n            return []\\n        else:\\n            return self.tree_factory( min_val = 1, max_val = n )\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 163620,
                "title": "divide-and-conquer-in-java-scala",
                "content": "> **Divide into subproblems**\\nThe root candidate can be selected from `[1, N]`.\\n\\n> **Recursively solve subproblems**\\nAfter we decide a root `x`, two subtrees (i.e. subproblems) generated. One contains nodes with values with the range `[1, x - 1]`, while the other contains nodes with values within the range `[x + 1, N]`. \\nWe can solve subproblems separately following the pattern described above.\\nUntil there is no nodes left to set as root (detected by `start > end`), we terminate the recursion after we add `null` to the current placement.\\n\\n>**Conquer results of subproblems**\\nCombine the results of subproblems, i.e. try all possible combinations of a node\\'s left child and right child to construct subtrees from bottom to top. \\n\\n\\n**More on Recursion**\\nThe return type of `generateTreesFrom()` is `List<TreeNode>`, which indicates all roots of generated trees until now. We receive the results(`i.e. leftSub, rightSub`), construct trees by all combinations of them, and add roots to the newly created result list of the current stack frame. The pseudo-code is as below:\\n```\\n            init curret result;\\n            for  leftNode in leftSub {\\n                for rightNode in rightSub {\\n                    create root node with value x;\\n                    attach leftNode, rightNode to root \\n                    add root to curret result; \\n                }\\n            }\\n\\t\\t\\treturn curret result;\\n```\\n****\\n> Java\\n```\\n    public List<TreeNode> generateTrees(int n) {\\n        if (n == 0) return new ArrayList<>();\\n        if (n == 1) return new ArrayList<>(Arrays.asList(new TreeNode(n)));\\n        \\n        // Map start + \" \" + end to list of placement.\\n        Map<String, List<TreeNode>> memo = new HashMap<>(); \\n        \\n        return place(1, n, memo);\\n    }\\n    \\n    private List<TreeNode> place(int start, int end, Map<String, List<TreeNode>> memo) {\\n        List<TreeNode> placement = new ArrayList<>(); // List of root of each placement.\\n        // Base cases.\\n        if (start > end) {\\n            placement.add(null);\\n            return placement;\\n        }\\n        if (start == end) {\\n            placement.add(new TreeNode(start));\\n            return placement;\\n        }\\n        \\n        String memoKey = start + \" \" + end;\\n        if (memo.containsKey(memoKey)) return memo.get(memoKey);\\n        \\n        for (int x = start; x <= end; x++) {\\n            List<TreeNode> leftPlacement = place(start, x - 1, memo);\\n            List<TreeNode> rightPlacement = place(x + 1, end, memo);\\n            TreeNode root;\\n            for (TreeNode leftNode: leftPlacement) {\\n                for (TreeNode rightNode: rightPlacement) {\\n                    root = new TreeNode(x);\\n                    root.left = leftNode;\\n                    root.right = rightNode;\\n                    placement.add(root);\\n                }\\n            }\\n        }\\n        \\n        memo.put(memoKey, placement);\\n        return placement;\\n    }\\n```\\n> Scala\\n```\\nimport scala.collection.mutable.{ListBuffer, HashMap}\\n\\nobject Solution {\\n  def generateTrees(n: Int): List[TreeNode] = {\\n    if (n < 1) List()\\n    else generate(1, n, new HashMap[String, List[TreeNode]]())\\n  }\\n  \\n  def generate(start: Int, end: Int, memo: HashMap[String, List[TreeNode]]): List[TreeNode] = {\\n    val memoKey = start + \" \" + end\\n    \\n    if (!(memo contains memoKey)) {\\n      val rootList = new ListBuffer[TreeNode]()\\n      \\n      if (start > end) rootList += null\\n      else if (start == end) rootList += new TreeNode(start)\\n      else {\\n        for (x <- start to end) {\\n          val leftList = generate(start, x - 1, memo)\\n          val rightList = generate(x + 1, end, memo)\\n          for (leftNode <- leftList) {\\n            for (rightNode <- rightList) {\\n              val root = new TreeNode(x)\\n              root.left = leftNode\\n              root.right = rightNode\\n              rootList += root\\n            }\\n          }\\n        }\\n      }\\n      \\n      memo += memoKey -> rootList.toList\\n    }\\n    \\n    memo.get(memoKey).get\\n  }\\n}\\n```\\n\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n            init curret result;\\n            for  leftNode in leftSub {\\n                for rightNode in rightSub {\\n                    create root node with value x;\\n                    attach leftNode, rightNode to root \\n                    add root to curret result; \\n                }\\n            }\\n\\t\\t\\treturn curret result;\\n```\n```\\n    public List<TreeNode> generateTrees(int n) {\\n        if (n == 0) return new ArrayList<>();\\n        if (n == 1) return new ArrayList<>(Arrays.asList(new TreeNode(n)));\\n        \\n        // Map start + \" \" + end to list of placement.\\n        Map<String, List<TreeNode>> memo = new HashMap<>(); \\n        \\n        return place(1, n, memo);\\n    }\\n    \\n    private List<TreeNode> place(int start, int end, Map<String, List<TreeNode>> memo) {\\n        List<TreeNode> placement = new ArrayList<>(); // List of root of each placement.\\n        // Base cases.\\n        if (start > end) {\\n            placement.add(null);\\n            return placement;\\n        }\\n        if (start == end) {\\n            placement.add(new TreeNode(start));\\n            return placement;\\n        }\\n        \\n        String memoKey = start + \" \" + end;\\n        if (memo.containsKey(memoKey)) return memo.get(memoKey);\\n        \\n        for (int x = start; x <= end; x++) {\\n            List<TreeNode> leftPlacement = place(start, x - 1, memo);\\n            List<TreeNode> rightPlacement = place(x + 1, end, memo);\\n            TreeNode root;\\n            for (TreeNode leftNode: leftPlacement) {\\n                for (TreeNode rightNode: rightPlacement) {\\n                    root = new TreeNode(x);\\n                    root.left = leftNode;\\n                    root.right = rightNode;\\n                    placement.add(root);\\n                }\\n            }\\n        }\\n        \\n        memo.put(memoKey, placement);\\n        return placement;\\n    }\\n```\n```\\nimport scala.collection.mutable.{ListBuffer, HashMap}\\n\\nobject Solution {\\n  def generateTrees(n: Int): List[TreeNode] = {\\n    if (n < 1) List()\\n    else generate(1, n, new HashMap[String, List[TreeNode]]())\\n  }\\n  \\n  def generate(start: Int, end: Int, memo: HashMap[String, List[TreeNode]]): List[TreeNode] = {\\n    val memoKey = start + \" \" + end\\n    \\n    if (!(memo contains memoKey)) {\\n      val rootList = new ListBuffer[TreeNode]()\\n      \\n      if (start > end) rootList += null\\n      else if (start == end) rootList += new TreeNode(start)\\n      else {\\n        for (x <- start to end) {\\n          val leftList = generate(start, x - 1, memo)\\n          val rightList = generate(x + 1, end, memo)\\n          for (leftNode <- leftList) {\\n            for (rightNode <- rightList) {\\n              val root = new TreeNode(x)\\n              root.left = leftNode\\n              root.right = rightNode\\n              rootList += root\\n            }\\n          }\\n        }\\n      }\\n      \\n      memo += memoKey -> rootList.toList\\n    }\\n    \\n    memo.get(memoKey).get\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 31582,
                "title": "java-concise-recursive-solution-3ms",
                "content": "public class Solution {\\n\\n    public List<TreeNode> generateTrees(int n) {\\n        return n > 0 ? helper(1, n) : new ArrayList<TreeNode>();\\n    }\\n    \\n    private List<TreeNode> helper(int from, int n) {\\n\\t\\tList<TreeNode> trees = new ArrayList<TreeNode>();\\n\\t\\tfor (int i = 0; i <= n - 1; ++i) {\\n\\t\\t\\t//left i, right n-1-i\\n\\t\\t\\tList<TreeNode> leftList = helper(from, i);\\n\\t\\t\\tList<TreeNode> rightList = helper(from + i + 1, n - 1 - i);\\n\\t\\t\\tfor (TreeNode left : leftList)\\n\\t\\t\\t\\tfor (TreeNode right : rightList) {\\n\\t\\t\\t\\t\\tTreeNode root = new TreeNode(from + i);\\n\\t\\t\\t\\t\\troot.left = left;\\n\\t\\t\\t\\t\\troot.right = right;\\n\\t\\t\\t\\t\\ttrees.add(root);\\n\\t\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (trees.size() == 0)\\n\\t\\t\\ttrees.add(null);\\n\\t\\treturn trees;\\n\\t}\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\n    public List<TreeNode> generateTrees(int n) {\\n        return n > 0 ? helper(1, n) : new ArrayList<TreeNode>();\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 31604,
                "title": "why-is-the-expected-result-when-the-return-type-is-just-a-list-and-not-list-of-list",
                "content": "Hi,\\n\\n8/9 test cases are passed except the following edge case:-\\n\\nInput : 0\\nOutput : [ ]\\nExpected : [ [ ] ]\\n\\nIt seems expected output is like a List of list. Can someone clarify what is going wrong.\\n\\nBelow is my java code :-\\n\\n    public class Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        if(n == 0) {\\n            List<TreeNode> result = new ArrayList<TreeNode>();\\n            return result;\\n        }\\n            \\n        int[] arr = new int[n];\\n        for(int i = 0; i < n; i++)\\n            arr[i] = i + 1;\\n        return generate(arr, 0, n - 1);\\n    }\\n    \\n    List<TreeNode> generate(int[] arr, int begin, int end) {\\n        if(begin > end)\\n            return null;\\n        List<TreeNode> result = new ArrayList<TreeNode>();\\n        if(begin == end) {\\n            result.add(new TreeNode(arr[begin]));\\n            return result;\\n        }\\n        \\n        for(int i = begin; i <= end; i++) {\\n            \\n            List<TreeNode> leftTrees = generate(arr, begin, i - 1);\\n            List<TreeNode> rightTrees = generate(arr, i + 1, end);\\n            if(leftTrees == null) {\\n                for(TreeNode node : rightTrees) {\\n                    TreeNode root = new TreeNode(arr[i]);\\n                    root.right = node;\\n                    result.add(root);\\n                }\\n            } else if(rightTrees == null) {\\n                for(TreeNode node : leftTrees) {\\n                    TreeNode root = new TreeNode(arr[i]);\\n                    root.left = node;\\n                    result.add(root);\\n                }\\n            } else {\\n                for(TreeNode left : leftTrees) {\\n                    for(TreeNode right : rightTrees) {\\n                        TreeNode root = new TreeNode(arr[i]);\\n                        root.left = left;\\n                        root.right = right;\\n                        result.add(root);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        if(n == 0) {\\n            List<TreeNode> result = new ArrayList<TreeNode>();\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3865866,
                "title": "very-easy-recursion-memoization-dp-java-99-faster",
                "content": "# Approach\\n- Try out all ways, i.e, Recursion\\n- Memoize the recursion for repeating subproblem\\n\\n# Code\\n```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        List<TreeNode>[][] dp = new List[n + 1][n + 1];\\n        return f(1, n, dp);\\n    }\\n    private List<TreeNode> f(int low, int high, List<TreeNode>[][] dp){\\n        List<TreeNode> bst = new ArrayList<>();\\n        if (low > high){\\n            bst.add(null);\\n            return bst;\\n        }\\n        if (dp[low][high] != null)\\n            return dp[low][high];\\n\\n        for (int i = low; i <= high; i++){\\n            List<TreeNode> leftSubTree = f(low, i - 1, dp);\\n            List<TreeNode> rightSubTree = f(i + 1, high, dp);\\n            for (TreeNode left : leftSubTree){\\n                for (TreeNode right : rightSubTree){\\n                    bst.add(new TreeNode(i, left, right));\\n                }\\n            }\\n        }\\n        return dp[low][high] = bst;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        List<TreeNode>[][] dp = new List[n + 1][n + 1];\\n        return f(1, n, dp);\\n    }\\n    private List<TreeNode> f(int low, int high, List<TreeNode>[][] dp){\\n        List<TreeNode> bst = new ArrayList<>();\\n        if (low > high){\\n            bst.add(null);\\n            return bst;\\n        }\\n        if (dp[low][high] != null)\\n            return dp[low][high];\\n\\n        for (int i = low; i <= high; i++){\\n            List<TreeNode> leftSubTree = f(low, i - 1, dp);\\n            List<TreeNode> rightSubTree = f(i + 1, high, dp);\\n            for (TreeNode left : leftSubTree){\\n                for (TreeNode right : rightSubTree){\\n                    bst.add(new TreeNode(i, left, right));\\n                }\\n            }\\n        }\\n        return dp[low][high] = bst;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1440987,
                "title": "java-solution-explained-tc-92-better-variable-naming",
                "content": "# Basic Approach\\nwe create another function called generateBSTs which takes two parameters, the strart node value and the end node value\\n1. If the start node value is greater than the end node then add the null to the currentBST list and return it\\n2. for every node from start to end, make it as our root node value do\\n3. call generateBSTs to generate leftSubtree with start as current start and end as value before until current root value ,which returns the list of roots of unique left subtrees formed with values from start to currentroot value - 1 \\n4. call generateBSTs to generate rightSubtree with start as current currentrootvalue + 1 and end as current end ,which returns the list of roots of unique right subtrees formed with values from currentroot value + 1 to end\\n5. now to get all combinations of left subtrees and right subtrees for the current root, traverse using two for loops and create a root with value as current root value and add the leftchild and rightchild with the help of for loops\\n6. add the root node to the currentBST list\\n7. return the currentBST list \\n# Code\\n```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        return generateBSTs(1, n);\\n    }\\n    List<TreeNode> generateBSTs(int start, int end) {\\n        List<TreeNode> currentBSTs = new ArrayList<>();\\n        if(start > end) currentBSTs.add(null);        \\n        else {\\n            for(int rootVal = start; rootVal <= end; rootVal ++) {                \\n                List<TreeNode> leftSubtreeRoots = generateBSTs(start, rootVal - 1);\\n                List<TreeNode> rightSubtreeRoots = generateBSTs(rootVal + 1, end);\\n                for(TreeNode leftChild : leftSubtreeRoots) {                    \\n                    for(TreeNode rightChild : rightSubtreeRoots) {\\n                        TreeNode root = new TreeNode(rootVal);\\n                        root.left = leftChild;\\n                        root.right = rightChild;\\n                        currentBSTs.add(root);\\n                    }\\n                }\\n            }\\n        }\\n        return currentBSTs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        return generateBSTs(1, n);\\n    }\\n    List<TreeNode> generateBSTs(int start, int end) {\\n        List<TreeNode> currentBSTs = new ArrayList<>();\\n        if(start > end) currentBSTs.add(null);        \\n        else {\\n            for(int rootVal = start; rootVal <= end; rootVal ++) {                \\n                List<TreeNode> leftSubtreeRoots = generateBSTs(start, rootVal - 1);\\n                List<TreeNode> rightSubtreeRoots = generateBSTs(rootVal + 1, end);\\n                for(TreeNode leftChild : leftSubtreeRoots) {                    \\n                    for(TreeNode rightChild : rightSubtreeRoots) {\\n                        TreeNode root = new TreeNode(rootVal);\\n                        root.left = leftChild;\\n                        root.right = rightChild;\\n                        currentBSTs.add(root);\\n                    }\\n                }\\n            }\\n        }\\n        return currentBSTs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806941,
                "title": "c-simple-and-elegant",
                "content": "**Runtime: 8 ms, faster than 99.46% of C++ online submissions for Unique Binary Search Trees II.\\nMemory Usage: 14 MB, less than 63.64% of C++ online submissions for Unique Binary Search Trees II.**\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    vector<TreeNode *> helper(int start, int end)\\n    {\\n        if(start > end)\\n            return vector<TreeNode*>(1, NULL);\\n        if(start == end)\\n            return vector<TreeNode*>(1, new TreeNode(start));\\n        \\n        vector<TreeNode *> result, left, right;\\n        \\n        for(int i = start; i <= end; i++)\\n        {\\n            left = helper(start, i - 1);\\n            right = helper(i + 1, end);\\n            \\n            for(TreeNode *lNode: left)\\n            {\\n                for(TreeNode *rNode: right)\\n                    result.push_back(new TreeNode(i, lNode, rNode));\\n            }\\n        }\\n        return result;\\n    }\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n == 0)\\n            return vector<TreeNode*>();\\n        return helper(1, n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    vector<TreeNode *> helper(int start, int end)\\n    {\\n        if(start > end)\\n            return vector<TreeNode*>(1, NULL);\\n        if(start == end)\\n            return vector<TreeNode*>(1, new TreeNode(start));\\n        \\n        vector<TreeNode *> result, left, right;\\n        \\n        for(int i = start; i <= end; i++)\\n        {\\n            left = helper(start, i - 1);\\n            right = helper(i + 1, end);\\n            \\n            for(TreeNode *lNode: left)\\n            {\\n                for(TreeNode *rNode: right)\\n                    result.push_back(new TreeNode(i, lNode, rNode));\\n            }\\n        }\\n        return result;\\n    }\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n == 0)\\n            return vector<TreeNode*>();\\n        return helper(1, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 551479,
                "title": "c-miminalizm",
                "content": "```cpp\\nvector<TreeNode*> generateTrees(int end, int start = 0) {\\n    if (start > end)\\n        return { nullptr };\\n    vector<TreeNode*> res;\\n    for (auto i = max(1, start); i <= end; ++i) {\\n        for (auto l : generateTrees(i - 1, max(1, start)))\\n            for (auto r : generateTrees(end, i + 1)) {\\n                res.push_back(new TreeNode(i));\\n                res.back()->left = l;\\n                res.back()->right = r;\\n            }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<TreeNode*> generateTrees(int end, int start = 0) {\\n    if (start > end)\\n        return { nullptr };\\n    vector<TreeNode*> res;\\n    for (auto i = max(1, start); i <= end; ++i) {\\n        for (auto l : generateTrees(i - 1, max(1, start)))\\n            for (auto r : generateTrees(end, i + 1)) {\\n                res.push_back(new TreeNode(i));\\n                res.back()->left = l;\\n                res.back()->right = r;\\n            }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 457492,
                "title": "javascript-8-line-solution",
                "content": "```js\\nvar generateTrees = function(n, l = 1, r = n, res = []) {\\n    for(let i = l; i <= r; i++){\\n        for(const left of generateTrees(n, l, i - 1)){\\n            for(const right of generateTrees(n, i + 1, r)){\\n                res.push({val: i, left, right});\\n            }\\n        }\\n    }\\n    return n ? res.length ? res : [null] : [];\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar generateTrees = function(n, l = 1, r = n, res = []) {\\n    for(let i = l; i <= r; i++){\\n        for(const left of generateTrees(n, l, i - 1)){\\n            for(const right of generateTrees(n, i + 1, r)){\\n                res.push({val: i, left, right});\\n            }\\n        }\\n    }\\n    return n ? res.length ? res : [null] : [];\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 350718,
                "title": "cpp-easy-to-understand-recursive-solution-with-explanation",
                "content": "Explanation :\\nEvery element in the array[1,n] can be a root sometime, because of the BST property, \\nif ith element is chosen as the root, then the elements from [1,i-1] will form the left subtree & [i+1,n] will form the right subtree.\\nWhat we ask recursion to do is , for each ith element , return all possible combinations of left subtree & right subtree, then we will attach the root(ith element) in all possible combinations.\\nThat\\'s it.\\nkEEP it simple, keep coding :)\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n    if (n==0) return {};\\n    return helper(1,n);\\n    }\\n    \\n    \\n    vector <TreeNode*> helper(int start, int end){\\n        if (start>end) return {nullptr};\\n      vector <TreeNode* > ans;\\n        for (int i=start; i <= end; ++i)\\n        {\\n        auto leftSubTree = helper(start, i-1);\\n        auto rightSubTree = helper(i+1,end);\\n            for (auto a:leftSubTree){\\n                  for (auto b:rightSubTree){\\n                      TreeNode *Node = new TreeNode(i); \\n                      Node->left= a;\\n                      Node->right= b;\\n                      ans.push_back(Node);\\n                  }   \\n            }\\n        }\\n        return ans;   \\n    } \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n    if (n==0) return {};\\n    return helper(1,n);\\n    }\\n    \\n    \\n    vector <TreeNode*> helper(int start, int end){\\n        if (start>end) return {nullptr};\\n      vector <TreeNode* > ans;\\n        for (int i=start; i <= end; ++i)\\n        {\\n        auto leftSubTree = helper(start, i-1);\\n        auto rightSubTree = helper(i+1,end);\\n            for (auto a:leftSubTree){\\n                  for (auto b:rightSubTree){\\n                      TreeNode *Node = new TreeNode(i); \\n                      Node->left= a;\\n                      Node->right= b;\\n                      ans.push_back(Node);\\n                  }   \\n            }\\n        }\\n        return ans;   \\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 262915,
                "title": "c-iterative-dp-solution-reuse-tree-nodes-both-100",
                "content": "Runtime: 16 ms, faster than 100.00% of C++ online submissions for Unique Binary Search Trees II.\\nMemory Usage: 11.6 MB, less than 100.00% of C++ online submissions for Unique Binary Search Trees II.\\n\\nBTW, I think {NULL} should be returned in the case n = 0, but I have to return {} to pass the test case; I think this is LC\\'s mistake.\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        if (n == 0) return {};\\n        vector<TreeNode*> nul = {NULL};\\n        vector<vector<vector<TreeNode*>>> trees(n);\\n        // all trees in trees[i][j] contain exactly the numbers from j+1 to j+i+1\\n        for (int i = 0; i < n; ++i) {\\n            trees[i].resize(n-i);\\n            for (int j = 0; j < n-i; ++j) {\\n                for (int k = 0; k <= i; ++k) {\\n                    auto jk1 = j+k+1;\\n                    auto& left = k == 0 ? nul : trees[k-1][j];\\n                    auto& right = k == i ? nul : trees[i-k-1][jk1];\\n                    for (auto l : left) for (auto r : right) {\\n                        trees[i][j].emplace_back(new TreeNode(jk1));\\n                        trees[i][j].back()->left = l;\\n                        trees[i][j].back()->right = r;\\n                    }\\n                }                    \\n            }\\n        }\\n        return trees.back()[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        if (n == 0) return {};\\n        vector<TreeNode*> nul = {NULL};\\n        vector<vector<vector<TreeNode*>>> trees(n);\\n        // all trees in trees[i][j] contain exactly the numbers from j+1 to j+i+1\\n        for (int i = 0; i < n; ++i) {\\n            trees[i].resize(n-i);\\n            for (int j = 0; j < n-i; ++j) {\\n                for (int k = 0; k <= i; ++k) {\\n                    auto jk1 = j+k+1;\\n                    auto& left = k == 0 ? nul : trees[k-1][j];\\n                    auto& right = k == i ? nul : trees[i-k-1][jk1];\\n                    for (auto l : left) for (auto r : right) {\\n                        trees[i][j].emplace_back(new TreeNode(jk1));\\n                        trees[i][j].back()->left = l;\\n                        trees[i][j].back()->right = r;\\n                    }\\n                }                    \\n            }\\n        }\\n        return trees.back()[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31529,
                "title": "unique-binary-search-trees-ii-c-shallow-copy-deep-copy",
                "content": "**Shallow Copy** - TreeNodes are shared between trees:\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        return n == 0 ? vector<TreeNode*>() : generate(1, n);\\n    }\\n\\n    vector<TreeNode*> generate(int lo, int hi) {\\n        vector<TreeNode*> trees;\\n        if (lo > hi) {\\n            trees.push_back(nullptr);\\n            return trees;\\n        }\\n\\n        for (int i = lo; i <= hi; i++) {\\n            vector<TreeNode*> lefts = generate(lo, i - 1);\\n            vector<TreeNode*> rights = generate(i + 1, hi);\\n            for (TreeNode* left : lefts) {\\n                for (TreeNode* right : rights) {\\n                    TreeNode* node = new TreeNode(i);\\n                    node->left = left;\\n                    node->right = right;\\n                    trees.push_back(node);\\n                }\\n            }\\n        }\\n        \\n        return trees;\\n    }\\n};\\n````\\n\\n**Deep Copy** - All trees use its own nodes;\\n***Matrix***\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        return n == 0 ? vector<TreeNode*>() : generate(1, n);\\n    }\\n\\nprivate:\\n    vector<TreeNode*> generate(int lo, int hi) {\\n        vector<TreeNode*> trees;\\n        if (lo > hi) {\\n            trees.push_back(nullptr);\\n            return trees;\\n        }\\n\\n        for (int k = lo; k <= hi; k++) {\\n            vector<vector<TreeNode*>> lefts(1, generate(lo, k - 1));\\n            vector<vector<TreeNode*>> rights(1, generate(k + 1, hi));\\n            int l = lefts[0].size(), r = rights[0].size();\\n            for (int i = 0; i < l; i++) {\\n                for (int j = 0; j < r; j++) {\\n                    if (j >= lefts.size()) lefts.push_back(generate(lo, k - 1));\\n                    if (i >= rights.size()) rights.push_back(generate(k + 1, hi));\\n                    TreeNode* node = new TreeNode(k);\\n                    node->left = lefts[j][i];\\n                    node->right = rights[i][j];\\n                    trees.push_back(node);\\n                }\\n            }\\n        }\\n\\n        return trees;\\n    }\\n};\\n```\\n\\n***Clone***\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        return n == 0 ? vector<TreeNode*>() : generate(1, n);\\n    }\\n\\n    vector<TreeNode*> generate(int lo, int hi) {\\n        vector<TreeNode*> trees;\\n        if (lo > hi) {\\n            trees.push_back(nullptr);\\n            return trees;\\n        }\\n\\n        for (int i = lo; i <= hi; i++) {\\n            // TreeNode in this vector should only be used while combining with the first TreeNode in rights, for the rest use clone;\\n            vector<TreeNode*> lefts = generate(lo, i - 1);\\n            for (TreeNode* left : lefts) {\\n                vector<TreeNode*> rights = generate(i + 1, hi);\\n                bool first = true;\\n                for (TreeNode* right : rights) {\\n                    TreeNode* node = new TreeNode(i);\\n                    node->left = first ? left : clone(left);    // the first node in rights use left, other use cloned left;\\n                    node->right = right;\\n                    trees.push_back(node);\\n                    first = false;\\n                }\\n            }\\n        }\\n        \\n        return trees;\\n    }\\n\\nprivate:\\n    /* Check null both at node and left,right */\\n    TreeNode* clone(TreeNode* node) {\\n        if (!node) {\\n            return nullptr;\\n        }\\n        TreeNode* copy = new TreeNode(node->val);\\n        if (node->left) {\\n            copy->left = clone(node->left);\\n        }\\n        if (node->right) {\\n            copy->right = clone(node->right);\\n        }\\n        return copy;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        return n == 0 ? vector<TreeNode*>() : generate(1, n);\\n    }\\n\\n    vector<TreeNode*> generate(int lo, int hi) {\\n        vector<TreeNode*> trees;\\n        if (lo > hi) {\\n            trees.push_back(nullptr);\\n            return trees;\\n        }\\n\\n        for (int i = lo; i <= hi; i++) {\\n            vector<TreeNode*> lefts = generate(lo, i - 1);\\n            vector<TreeNode*> rights = generate(i + 1, hi);\\n            for (TreeNode* left : lefts) {\\n                for (TreeNode* right : rights) {\\n                    TreeNode* node = new TreeNode(i);\\n                    node->left = left;\\n                    node->right = right;\\n                    trees.push_back(node);\\n                }\\n            }\\n        }\\n        \\n        return trees;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        return n == 0 ? vector<TreeNode*>() : generate(1, n);\\n    }\\n\\nprivate:\\n    vector<TreeNode*> generate(int lo, int hi) {\\n        vector<TreeNode*> trees;\\n        if (lo > hi) {\\n            trees.push_back(nullptr);\\n            return trees;\\n        }\\n\\n        for (int k = lo; k <= hi; k++) {\\n            vector<vector<TreeNode*>> lefts(1, generate(lo, k - 1));\\n            vector<vector<TreeNode*>> rights(1, generate(k + 1, hi));\\n            int l = lefts[0].size(), r = rights[0].size();\\n            for (int i = 0; i < l; i++) {\\n                for (int j = 0; j < r; j++) {\\n                    if (j >= lefts.size()) lefts.push_back(generate(lo, k - 1));\\n                    if (i >= rights.size()) rights.push_back(generate(k + 1, hi));\\n                    TreeNode* node = new TreeNode(k);\\n                    node->left = lefts[j][i];\\n                    node->right = rights[i][j];\\n                    trees.push_back(node);\\n                }\\n            }\\n        }\\n\\n        return trees;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        return n == 0 ? vector<TreeNode*>() : generate(1, n);\\n    }\\n\\n    vector<TreeNode*> generate(int lo, int hi) {\\n        vector<TreeNode*> trees;\\n        if (lo > hi) {\\n            trees.push_back(nullptr);\\n            return trees;\\n        }\\n\\n        for (int i = lo; i <= hi; i++) {\\n            // TreeNode in this vector should only be used while combining with the first TreeNode in rights, for the rest use clone;\\n            vector<TreeNode*> lefts = generate(lo, i - 1);\\n            for (TreeNode* left : lefts) {\\n                vector<TreeNode*> rights = generate(i + 1, hi);\\n                bool first = true;\\n                for (TreeNode* right : rights) {\\n                    TreeNode* node = new TreeNode(i);\\n                    node->left = first ? left : clone(left);    // the first node in rights use left, other use cloned left;\\n                    node->right = right;\\n                    trees.push_back(node);\\n                    first = false;\\n                }\\n            }\\n        }\\n        \\n        return trees;\\n    }\\n\\nprivate:\\n    /* Check null both at node and left,right */\\n    TreeNode* clone(TreeNode* node) {\\n        if (!node) {\\n            return nullptr;\\n        }\\n        TreeNode* copy = new TreeNode(node->val);\\n        if (node->left) {\\n            copy->left = clone(node->left);\\n        }\\n        if (node->right) {\\n            copy->right = clone(node->right);\\n        }\\n        return copy;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31634,
                "title": "my-non-recursive-c-solution",
                "content": "    vector<TreeNode *> generateTrees(int n) {\\n        vector<TreeNode *> tmp;\\n        vector<TreeNode *> ret;\\n        tmp.push_back(NULL);        \\n        ret.push_back(new TreeNode(1));\\n        if (!n) return tmp;\\n\\n\\t\\t/* insert the largeset number into previously contructed trees */\\n        for (int i = 2; i <= n; i++) {\\n            tmp.clear();\\n            for (int j = 0; j < ret.size(); j++) {\\n\\t\\t\\t\\t/* firstly, put the largest number on the top of tree */\\n                TreeNode *orgTree = ret[j];                \\n                TreeNode *newNode = new TreeNode(i);\\n                newNode->left = copy(orgTree);\\n                tmp.push_back(newNode);\\n                \\n\\t\\t\\t\\t/* traverse thru the right-most branch, \\n\\t\\t\\t\\t * insert the largest number one position after another */\\n                TreeNode *orgRunner = orgTree;\\n                while (orgRunner) {\\n                    newNode = new TreeNode(i);\\n                    newNode->left = orgRunner->right;\\n                    orgRunner->right = newNode;\\n                    tmp.push_back(copy(orgTree));\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t/* recover the original tree */\\n                    orgRunner->right = orgRunner->right->left;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t/* for the next loop */\\n                    orgRunner = orgRunner->right;\\n                }\\n            }\\n            ret =  tmp;\\n        }\\n        return ret;\\n    }\\n    \\n    TreeNode *copy (TreeNode *root) {\\n        TreeNode *ret = NULL;\\n        if (root) {\\n            ret = new TreeNode(root->val);\\n            ret->left = copy(root->left);\\n            ret->right = copy(root->right);\\n        }\\n        return ret;\\n    }",
                "solutionTags": [],
                "code": "    vector<TreeNode *> generateTrees(int n) {\\n        vector<TreeNode *> tmp;\\n        vector<TreeNode *> ret;\\n        tmp.push_back(NULL);        \\n        ret.push_back(new TreeNode(1));\\n        if (!n) return tmp;\\n\\n\\t\\t/* insert the largeset number into previously contructed trees */\\n        for (int i = 2; i <= n; i++) {\\n            tmp.clear();\\n            for (int j = 0; j < ret.size(); j++) {\\n\\t\\t\\t\\t/* firstly, put the largest number on the top of tree */\\n                TreeNode *orgTree = ret[j];                \\n                TreeNode *newNode = new TreeNode(i);\\n                newNode->left = copy(orgTree);\\n                tmp.push_back(newNode);\\n                \\n\\t\\t\\t\\t/* traverse thru the right-most branch, \\n\\t\\t\\t\\t * insert the largest number one position after another */\\n                TreeNode *orgRunner = orgTree;\\n                while (orgRunner) {\\n                    newNode = new TreeNode(i);\\n                    newNode->left = orgRunner->right;\\n                    orgRunner->right = newNode;\\n                    tmp.push_back(copy(orgTree));\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t/* recover the original tree */\\n                    orgRunner->right = orgRunner->right->left;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t/* for the next loop */\\n                    orgRunner = orgRunner->right;\\n                }\\n            }\\n            ret =  tmp;\\n        }\\n        return ret;\\n    }\\n    \\n    TreeNode *copy (TreeNode *root) {\\n        TreeNode *ret = NULL;\\n        if (root) {\\n            ret = new TreeNode(root->val);\\n            ret->left = copy(root->left);\\n            ret->right = copy(root->right);\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31626,
                "title": "python-generator-solution",
                "content": "credit goes to https://leetcode.com/discuss/3440/help-simplify-my-code-the-second-one?show=4884#a4884\\n\\n    # Definition for a  binary tree node\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @return a list of tree node\\n        # 2:30\\n        def generateTrees(self, n):\\n            nodes = map(TreeNode, range(1, n+1))\\n            return map(copy.deepcopy, self.buildTree(nodes))\\n    \\n        def buildTree(self, nodes):\\n            n = len(nodes)\\n            if n == 0:\\n                yield None\\n                return\\n    \\n            for i in range(n):\\n                root = nodes[i]\\n                for left in self.buildTree(nodes[:i]):\\n                    for right in self.buildTree(nodes[i+1:]):\\n                        root.left, root.right = left, right\\n                        yield root",
                "solutionTags": [
                    "Python"
                ],
                "code": "credit goes to https://leetcode.com/discuss/3440/help-simplify-my-code-the-second-one?show=4884#a4884\\n\\n    # Definition for a  binary tree node\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @return a list of tree node\\n        # 2:30\\n        def generateTrees(self, n):\\n            nodes = map(TreeNode, range(1, n+1))\\n            return map(copy.deepcopy, self.buildTree(nodes))\\n    \\n        def buildTree(self, nodes):\\n            n = len(nodes)\\n            if n == 0:\\n                yield None\\n                return\\n    \\n            for i in range(n):\\n                root = nodes[i]\\n                for left in self.buildTree(nodes[:i]):\\n                    for right in self.buildTree(nodes[i+1:]):\\n                        root.left, root.right = left, right\\n                        yield root",
                "codeTag": "Java"
            },
            {
                "id": 3865479,
                "title": "c-detailed-explanation-of-the-recursive-approach",
                "content": "# Intuition\\n- The Trees can have root nodes from 1 to n\\n- Left Subtree will have elements less than the root node\\n- Right Subtree will have elements greater than the root node\\n- Each left and right subtree can be treated as an individual tree which can have previousRoot-1 (starting from prevousRoot-1 till the left bound) number of root nodes and n-prevRoot (starting from previousRoot+1 till right end) number of root nodes respectively \\n\\n# Approach\\n- Base Case 1: For invalid boundary an empty tree can be created which is returned\\n- Base Case 2: When there is only a single node left the left and right value will be equal the value is pushed in the result as a node an returned\\n- For Every Tree/Subtree fix 1 node as the root node (i) and find all possible left and right Subtrees for that node.\\n- Every left Subtree can be combined with each of the right Subtrees to give a unique tree and vice versa\\n- Generate all possible combinations for the root node and push the root node in the result vector.\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<TreeNode*> f(int left,int right){\\n\\n        vector<TreeNode*> res;\\n\\n        //Base case 1:\\n        if(left>right){\\n            res.push_back(NULL);\\n            return res;\\n        }\\n        //Base case 2:\\n        if(left==right){\\n            TreeNode* node= new TreeNode(left);\\n            res.push_back(node);\\n            return res;\\n        }\\n\\n        //Fix the root node in i\\n        for(int i=left; i<=right; i++){\\n        //The left subtree will have elements from the left bound till i-1\\n            vector<TreeNode*> leftSubtree=f(left,i-1);\\n        //The right subtree will have elements from i+1 till the right bound\\n            vector<TreeNode*> rightSubtree=f(i+1,right);\\n        //Add all possibilities of the combinations of the left subtrees and the right subtrees for the root node i\\n            for(int j=0; j<leftSubtree.size(); j++){\\n                for(int k=0; k<rightSubtree.size(); k++){\\n                    TreeNode* node=new TreeNode(i);\\n                    node->left=leftSubtree[j];\\n                    node->right=rightSubtree[k];\\n                    res.push_back(node);\\n                }\\n            }\\n\\n        }\\n        return res;\\n    }\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        return f(1,n);\\n    }\\n};\\n```\\n\\nPlease **UPVOTE** if you understood!",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<TreeNode*> f(int left,int right){\\n\\n        vector<TreeNode*> res;\\n\\n        //Base case 1:\\n        if(left>right){\\n            res.push_back(NULL);\\n            return res;\\n        }\\n        //Base case 2:\\n        if(left==right){\\n            TreeNode* node= new TreeNode(left);\\n            res.push_back(node);\\n            return res;\\n        }\\n\\n        //Fix the root node in i\\n        for(int i=left; i<=right; i++){\\n        //The left subtree will have elements from the left bound till i-1\\n            vector<TreeNode*> leftSubtree=f(left,i-1);\\n        //The right subtree will have elements from i+1 till the right bound\\n            vector<TreeNode*> rightSubtree=f(i+1,right);\\n        //Add all possibilities of the combinations of the left subtrees and the right subtrees for the root node i\\n            for(int j=0; j<leftSubtree.size(); j++){\\n                for(int k=0; k<rightSubtree.size(); k++){\\n                    TreeNode* node=new TreeNode(i);\\n                    node->left=leftSubtree[j];\\n                    node->right=rightSubtree[k];\\n                    res.push_back(node);\\n                }\\n            }\\n\\n        }\\n        return res;\\n    }\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        return f(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865297,
                "title": "easy-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n\\n        return upvote(1,n);\\n    }\\n\\n    private List<TreeNode> upvote(int s, int e){\\n        List<TreeNode> ans = new ArrayList<>();\\n\\n        if(s>e){\\n            ans.add(null);\\n            return ans;\\n        }\\n\\n        for(int i = s;i <= e;i++){\\n            List<TreeNode> left = upvote(s, i-1);\\n            List<TreeNode> right = upvote(i+1, e);\\n\\n            for(TreeNode l : left){\\n                for(TreeNode r : right){\\n                    TreeNode res = new TreeNode(i,l,r);\\n                    ans.add(res);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n\\n        return upvote(1,n);\\n    }\\n\\n    private List<TreeNode> upvote(int s, int e){\\n        List<TreeNode> ans = new ArrayList<>();\\n\\n        if(s>e){\\n            ans.add(null);\\n            return ans;\\n        }\\n\\n        for(int i = s;i <= e;i++){\\n            List<TreeNode> left = upvote(s, i-1);\\n            List<TreeNode> right = upvote(i+1, e);\\n\\n            for(TreeNode l : left){\\n                for(TreeNode r : right){\\n                    TreeNode res = new TreeNode(i,l,r);\\n                    ans.add(res);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864986,
                "title": "unique-binary-search-trees-ii-a-rusty-approach",
                "content": "Have you ever tried to generate all unique binary search trees (BSTs) with a given number of nodes? It\\'s a crab-tastic challenge, but don\\'t worry; Rust is here to help you out!\\n\\n## Intuition\\nImagine you have \\\\( n \\\\) distinct numbers. You can pick any number as the root of the BST. Once you pick a root, the remaining numbers are divided into two groups, forming the left and right subtrees. You can recursively build the subtrees and combine them to form all possible BSTs.\\n\\n## Approach\\nWe use dynamic programming to efficiently construct all possible trees. We start by building trees with 1 node, then 2 nodes, up to \\\\( n \\\\) nodes. We use previously computed solutions to build trees with more nodes, making the process fast and memory-efficient.\\n\\n### Example Explanation\\nFor \\\\( n = 3 \\\\), the output is:\\n```\\n[\\n    [1,null,2,null,3],\\n    [1,null,3,2],\\n    [2,1,3],\\n    [3,1,null,null,2],\\n    [3,2,null,1]\\n]\\n```\\nIt means there are 5 different ways to form a BST using numbers from 1 to 3.\\n\\n## Complexity\\n- Time complexity: $$ O\\\\left(\\\\frac{{4^n}}{{n\\\\sqrt{n}}}\\\\right) $$\\n- Space complexity: $$ O\\\\left(\\\\frac{{4^n}}{{n\\\\sqrt{n}}}\\\\right) $$\\n\\n## Code\\nThe Rust code below generates all unique BSTs for a given number of nodes, using dynamic programming.\\n\\n``` Rust []\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn generate_trees(n: i32) -> Vec<Option<Rc<RefCell<TreeNode>>>> {\\n        if n == 0 {\\n            return Vec::new();\\n        }\\n\\n        let mut dp = vec![Vec::new(); (n + 1) as usize];\\n        dp[0].push(None);\\n        for nodes in 1..=n {\\n            let mut trees_per_node = Vec::new();\\n            for root in 1..=nodes {\\n                let left_trees = &dp[(root - 1) as usize];\\n                let right_trees = &dp[(nodes - root) as usize];\\n                for left_tree in left_trees {\\n                    for right_tree in right_trees {\\n                        let root_node = Some(Rc::new(RefCell::new(TreeNode::new(root))));\\n                        root_node.as_ref().unwrap().borrow_mut().left = left_tree.clone();\\n                        root_node.as_ref().unwrap().borrow_mut().right = Solution::clone(right_tree.clone(), root);\\n                        trees_per_node.push(root_node);\\n                    }\\n                }\\n            }\\n            dp[nodes as usize] = trees_per_node;\\n        }\\n        dp[n as usize].clone()\\n    }\\n\\n    fn clone(tree: Option<Rc<RefCell<TreeNode>>>, offset: i32) -> Option<Rc<RefCell<TreeNode>>> {\\n        tree.map(|node| {\\n            Rc::new(RefCell::new(TreeNode {\\n                val: node.borrow().val + offset,\\n                left: Solution::clone(node.borrow().left.clone(), offset),\\n                right: Solution::clone(node.borrow().right.clone(), offset),\\n            }))\\n        })\\n    }\\n}\\n```\\n``` Go []\\nvar generateTrees = function(n) {\\n    if (n === 0) return [];\\n\\n    const dp = Array.from({ length: n + 1 }, () => []);\\n    dp[0].push(null);\\n    for (let nodes = 1; nodes <= n; nodes++) {\\n        for (let root = 1; root <= nodes; root++) {\\n            for (const left_tree of dp[root - 1]) {\\n                for (const right_tree of dp[nodes - root]) {\\n                    const root_node = new TreeNode(root);\\n                    root_node.left = left_tree;\\n                    root_node.right = clone(right_tree, root);\\n                    dp[nodes].push(root_node);\\n                }\\n            }\\n        }\\n    }\\n    return dp[n];\\n};\\n\\nfunction clone(n, offset) {\\n    if (n === null) return null;\\n    const node = new TreeNode(n.val + offset);\\n    node.left = clone(n.left, offset);\\n    node.right = clone(n.right, offset);\\n    return node;\\n}\\n```\\n``` Python []\\nclass Solution:\\n    def generateTrees(self, n: int):\\n        if n == 0:\\n            return []\\n\\n        dp = [[] for _ in range(n + 1)]\\n        dp[0].append(None)\\n        for nodes in range(1, n + 1):\\n            for root in range(1, nodes + 1):\\n                for left_tree in dp[root - 1]:\\n                    for right_tree in dp[nodes - root]:\\n                        root_node = TreeNode(root)\\n                        root_node.left = left_tree\\n                        root_node.right = self.clone(right_tree, root)\\n                        dp[nodes].append(root_node)\\n        return dp[n]\\n    \\n    def clone(self, n: TreeNode, offset: int) -> TreeNode:\\n        if n:\\n            node = TreeNode(n.val + offset)\\n            node.left = self.clone(n.left, offset)\\n            node.right = self.clone(n.right, offset)\\n            return node\\n        return None\\n```\\nExplore the beauty of constructing binary trees and have fun with Rust! If you find this solution helpful, don\\'t forget to upvote and share it with fellow Rustaceans. Happy coding! \\uD83E\\uDD80",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "```\\n[\\n    [1,null,2,null,3],\\n    [1,null,3,2],\\n    [2,1,3],\\n    [3,1,null,null,2],\\n    [3,2,null,1]\\n]\\n```\n``` Rust []\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn generate_trees(n: i32) -> Vec<Option<Rc<RefCell<TreeNode>>>> {\\n        if n == 0 {\\n            return Vec::new();\\n        }\\n\\n        let mut dp = vec![Vec::new(); (n + 1) as usize];\\n        dp[0].push(None);\\n        for nodes in 1..=n {\\n            let mut trees_per_node = Vec::new();\\n            for root in 1..=nodes {\\n                let left_trees = &dp[(root - 1) as usize];\\n                let right_trees = &dp[(nodes - root) as usize];\\n                for left_tree in left_trees {\\n                    for right_tree in right_trees {\\n                        let root_node = Some(Rc::new(RefCell::new(TreeNode::new(root))));\\n                        root_node.as_ref().unwrap().borrow_mut().left = left_tree.clone();\\n                        root_node.as_ref().unwrap().borrow_mut().right = Solution::clone(right_tree.clone(), root);\\n                        trees_per_node.push(root_node);\\n                    }\\n                }\\n            }\\n            dp[nodes as usize] = trees_per_node;\\n        }\\n        dp[n as usize].clone()\\n    }\\n\\n    fn clone(tree: Option<Rc<RefCell<TreeNode>>>, offset: i32) -> Option<Rc<RefCell<TreeNode>>> {\\n        tree.map(|node| {\\n            Rc::new(RefCell::new(TreeNode {\\n                val: node.borrow().val + offset,\\n                left: Solution::clone(node.borrow().left.clone(), offset),\\n                right: Solution::clone(node.borrow().right.clone(), offset),\\n            }))\\n        })\\n    }\\n}\\n```\n``` Go []\\nvar generateTrees = function(n) {\\n    if (n === 0) return [];\\n\\n    const dp = Array.from({ length: n + 1 }, () => []);\\n    dp[0].push(null);\\n    for (let nodes = 1; nodes <= n; nodes++) {\\n        for (let root = 1; root <= nodes; root++) {\\n            for (const left_tree of dp[root - 1]) {\\n                for (const right_tree of dp[nodes - root]) {\\n                    const root_node = new TreeNode(root);\\n                    root_node.left = left_tree;\\n                    root_node.right = clone(right_tree, root);\\n                    dp[nodes].push(root_node);\\n                }\\n            }\\n        }\\n    }\\n    return dp[n];\\n};\\n\\nfunction clone(n, offset) {\\n    if (n === null) return null;\\n    const node = new TreeNode(n.val + offset);\\n    node.left = clone(n.left, offset);\\n    node.right = clone(n.right, offset);\\n    return node;\\n}\\n```\n``` Python []\\nclass Solution:\\n    def generateTrees(self, n: int):\\n        if n == 0:\\n            return []\\n\\n        dp = [[] for _ in range(n + 1)]\\n        dp[0].append(None)\\n        for nodes in range(1, n + 1):\\n            for root in range(1, nodes + 1):\\n                for left_tree in dp[root - 1]:\\n                    for right_tree in dp[nodes - root]:\\n                        root_node = TreeNode(root)\\n                        root_node.left = left_tree\\n                        root_node.right = self.clone(right_tree, root)\\n                        dp[nodes].append(root_node)\\n        return dp[n]\\n    \\n    def clone(self, n: TreeNode, offset: int) -> TreeNode:\\n        if n:\\n            node = TreeNode(n.val + offset)\\n            node.left = self.clone(n.left, offset)\\n            node.right = self.clone(n.right, offset)\\n            return node\\n        return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399086,
                "title": "java-memoization-beats-99-on-space-and-time-15-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  Map<Pair<Integer, Integer>, List<TreeNode>> memo = new HashMap<>();\\n\\n  private List<TreeNode> generateTrees(int l, int r) {\\n    if (l > r)\\n      return new ArrayList<>() {{add(null);}};\\n\\n    var list = new ArrayList<TreeNode>();\\n    var pair = new Pair(l, r);\\n\\n    if (memo.containsKey(pair))\\n      return memo.get(pair);\\n  \\n    for (var i=l; i<=r; i++)\\n      for (var left : generateTrees(l, i-1))\\n        for (var right : generateTrees(i+1, r))\\n          list.add(new TreeNode(i, left, right));\\n    \\n    memo.put(pair, list);\\n    return list;\\n  }\\n\\n  public List<TreeNode> generateTrees(int n) {\\n    return generateTrees(1, n);\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n  Map<Pair<Integer, Integer>, List<TreeNode>> memo = new HashMap<>();\\n\\n  private List<TreeNode> generateTrees(int l, int r) {\\n    if (l > r)\\n      return new ArrayList<>() {{add(null);}};\\n\\n    var list = new ArrayList<TreeNode>();\\n    var pair = new Pair(l, r);\\n\\n    if (memo.containsKey(pair))\\n      return memo.get(pair);\\n  \\n    for (var i=l; i<=r; i++)\\n      for (var left : generateTrees(l, i-1))\\n        for (var right : generateTrees(i+1, r))\\n          list.add(new TreeNode(i, left, right));\\n    \\n    memo.put(pair, list);\\n    return list;\\n  }\\n\\n  public List<TreeNode> generateTrees(int n) {\\n    return generateTrees(1, n);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246485,
                "title": "c-divide-and-conquer-easy-to-understand",
                "content": "# Algorithm\\n1. Pick a number `i` from `1 .. n`\\n2. Use it as the root of the current tree\\n3. Solve 2 subproblems `1 .. i - 1` and `i + 1 .. n`\\n4. Repeat for every `i` from `1 .. n`\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public IList<TreeNode> GenerateTrees(int n) {\\n        return GenerateTrees(1, n);\\n    }\\n\\n    public IList<TreeNode> GenerateTrees(int left, int right)\\n    {\\n        var res = new List<TreeNode>();\\n\\n        if(left > right)\\n        {\\n            res.Add(null);\\n            return res;\\n        }\\n\\n        for(var i = left; i <= right; i++)\\n        {\\n            var leftNodes = GenerateTrees(left, i - 1);\\n            var rightNodes = GenerateTrees(i + 1, right);\\n            \\n            foreach(var leftNode in leftNodes)\\n            {\\n                foreach(var rightNode in rightNodes)\\n                {\\n                    var node = new TreeNode(i, leftNode, rightNode);\\n                    res.Add(node);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Divide and Conquer"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public IList<TreeNode> GenerateTrees(int n) {\\n        return GenerateTrees(1, n);\\n    }\\n\\n    public IList<TreeNode> GenerateTrees(int left, int right)\\n    {\\n        var res = new List<TreeNode>();\\n\\n        if(left > right)\\n        {\\n            res.Add(null);\\n            return res;\\n        }\\n\\n        for(var i = left; i <= right; i++)\\n        {\\n            var leftNodes = GenerateTrees(left, i - 1);\\n            var rightNodes = GenerateTrees(i + 1, right);\\n            \\n            foreach(var leftNode in leftNodes)\\n            {\\n                foreach(var rightNode in rightNodes)\\n                {\\n                    var node = new TreeNode(i, leftNode, rightNode);\\n                    res.Add(node);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104988,
                "title": "c-short-solution-recursion",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    vector<TreeNode*> generate(int n,int start){\\n        if(start>n)return {NULL};\\n        vector<TreeNode*>res;\\n        for(int i=start;i<=n;i++){\\n            for(auto left:generate(i-1,start)){\\n                for(auto right:generate(n,i+1)){\\n                    res.push_back(new TreeNode(i,left,right));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        return generate(n,1);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    vector<TreeNode*> generate(int n,int start){\\n        if(start>n)return {NULL};\\n        vector<TreeNode*>res;\\n        for(int i=start;i<=n;i++){\\n            for(auto left:generate(i-1,start)){\\n                for(auto right:generate(n,i+1)){\\n                    res.push_back(new TreeNode(i,left,right));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        return generate(n,1);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2986322,
                "title": "c-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    vector<TreeNode*> solve(int start, int end) {\\n        vector<TreeNode*> ans;\\n        if(start > end) return {NULL};\\n        if(start == end) return {new TreeNode(start)};\\n        for(int i=start; i<=end; i++) {\\n            vector<TreeNode*> left = solve(start, i-1);\\n            vector<TreeNode*> right = solve(i+1, end);\\n            for(auto l: left)\\n                for(auto r: right)\\n                    ans.push_back(new TreeNode(i, l, r));\\n        }\\n        return ans;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        vector<TreeNode*> ans = solve(1, n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    vector<TreeNode*> solve(int start, int end) {\\n        vector<TreeNode*> ans;\\n        if(start > end) return {NULL};\\n        if(start == end) return {new TreeNode(start)};\\n        for(int i=start; i<=end; i++) {\\n            vector<TreeNode*> left = solve(start, i-1);\\n            vector<TreeNode*> right = solve(i+1, end);\\n            for(auto l: left)\\n                for(auto r: right)\\n                    ans.push_back(new TreeNode(i, l, r));\\n        }\\n        return ans;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        vector<TreeNode*> ans = solve(1, n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2611185,
                "title": "c-recursion-very-fast-minimum-line",
                "content": "\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<TreeNode*> generateTrees(int n, int s = 1) {\\n\\t\\t\\t\\tvector<TreeNode*> ans;\\n\\t\\t\\t\\tif(n < s) return {nullptr};                              \\n\\t\\t\\t\\t for(int i=s; i<=n; i++) {                \\t                 // Consider every number in range [s,n] as root  \\n\\t\\t\\t\\t\\tfor(auto left: generateTrees(i-1, s)) {                  // generate all possible trees in range [s,i)\\n\\t\\t\\t\\t\\t\\tfor(auto right: generateTrees(n, i+1))               // generate all possible trees in range (i,e]\\n\\t\\t\\t\\t\\t\\t\\tans.push_back(new TreeNode(i, left, right));     // make new trees with i as the root \\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<TreeNode*> generateTrees(int n, int s = 1) {\\n\\t\\t\\t\\tvector<TreeNode*> ans;\\n\\t\\t\\t\\tif(n < s) return {nullptr}",
                "codeTag": "Java"
            },
            {
                "id": 2435086,
                "title": "trust-me-boys-and-girls-by-recursion",
                "content": "**Solution -->**\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<TreeNode*> generateBST(int begin, int end)\\n    {\\n        vector<TreeNode*> arr;\\n        \\n        if(begin>end)\\n        {\\n            arr.push_back(NULL);\\n            return arr;\\n        }\\n        \\n        for(int i=begin; i<=end; i++)\\n        {\\n            vector<TreeNode*>left =  generateBST(begin, i-1);\\n            vector<TreeNode*>right =  generateBST(i+1,end);\\n            \\n            for(auto l:left)\\n            {\\n                for(auto r:right)\\n                {\\n                    TreeNode* root = new TreeNode();\\n                    root->val = i;\\n                    root->left = l;\\n                    root->right = r;\\n                    arr.push_back(root);\\n                }\\n            }\\n            \\n        }\\n        return arr;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        \\n        vector<TreeNode*>arr;\\n        if(n==0) return arr;\\n        \\n        return generateBST(1,n);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<TreeNode*> generateBST(int begin, int end)\\n    {\\n        vector<TreeNode*> arr;\\n        \\n        if(begin>end)\\n        {\\n            arr.push_back(NULL);\\n            return arr;\\n        }\\n        \\n        for(int i=begin; i<=end; i++)\\n        {\\n            vector<TreeNode*>left =  generateBST(begin, i-1);\\n            vector<TreeNode*>right =  generateBST(i+1,end);\\n            \\n            for(auto l:left)\\n            {\\n                for(auto r:right)\\n                {\\n                    TreeNode* root = new TreeNode();\\n                    root->val = i;\\n                    root->left = l;\\n                    root->right = r;\\n                    arr.push_back(root);\\n                }\\n            }\\n            \\n        }\\n        return arr;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        \\n        vector<TreeNode*>arr;\\n        if(n==0) return arr;\\n        \\n        return generateBST(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276413,
                "title": "java-recursion-beginner-friendly",
                "content": "```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        return solve(1,n) ;\\n    }\\n    \\n    public List<TreeNode> solve(int left,int right){\\n        List<TreeNode> ans = new ArrayList<>() ;\\n        if(left > right){\\n            ans.add(null) ;\\n            return ans ;\\n        }\\n        for(int i = left ; i <= right ; i++){\\n            List<TreeNode> lft = solve(left,i-1) ;\\n            List<TreeNode> ryt = solve(i+1,right) ;\\n            for(TreeNode l : lft){\\n                for(TreeNode r : ryt){\\n                    ans.add(new TreeNode(i,l,r)) ;\\n                }\\n            }\\n        }\\n        return ans ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        return solve(1,n) ;\\n    }\\n    \\n    public List<TreeNode> solve(int left,int right){\\n        List<TreeNode> ans = new ArrayList<>() ;\\n        if(left > right){\\n            ans.add(null) ;\\n            return ans ;\\n        }\\n        for(int i = left ; i <= right ; i++){\\n            List<TreeNode> lft = solve(left,i-1) ;\\n            List<TreeNode> ryt = solve(i+1,right) ;\\n            for(TreeNode l : lft){\\n                for(TreeNode r : ryt){\\n                    ans.add(new TreeNode(i,l,r)) ;\\n                }\\n            }\\n        }\\n        return ans ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074851,
                "title": "easy-understandable-recursion-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generate(int start,int end){\\n        vector<TreeNode*> ans;  // to store subtree for current node.\\n        if(start>end){  // means null\\n            ans.push_back(NULL);\\n            return ans;\\n        }\\n        \\n        for(int i=start;i<=end;i++){\\n            vector<TreeNode*> left_nodes=generate(start,i-1); // store all left child node here.\\n            vector<TreeNode*> right_nodes=generate(i+1,end);  // store all right child node here.\\n            \\n            // with every left child and right child , form a tree and push it in ans array.\\n            for(auto left: left_nodes){\\n                for(auto right: right_nodes){\\n                    TreeNode* root=new TreeNode(i,left,right);\\n                    ans.push_back(root);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        return generate(1,n);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generate(int start,int end){\\n        vector<TreeNode*> ans;  // to store subtree for current node.\\n        if(start>end){  // means null\\n            ans.push_back(NULL);\\n            return ans;\\n        }\\n        \\n        for(int i=start;i<=end;i++){\\n            vector<TreeNode*> left_nodes=generate(start,i-1); // store all left child node here.\\n            vector<TreeNode*> right_nodes=generate(i+1,end);  // store all right child node here.\\n            \\n            // with every left child and right child , form a tree and push it in ans array.\\n            for(auto left: left_nodes){\\n                for(auto right: right_nodes){\\n                    TreeNode* root=new TreeNode(i,left,right);\\n                    ans.push_back(root);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        return generate(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1949237,
                "title": "this-was-tough-to-come-up-with-explained-c-beats-97",
                "content": "This one\\'s a bit tricky to come up with,\\n\\n1. We will start building unique BSTs for each number(1-n) by keeping it as a root of current BST \\n2. for this will need all unique BSTs to the left of current root and all unique BSTs to the right of current root,\\n3. for example we have numbers 1-2-3-4-5, keeping \\'3\\' as root we need :\\n* all unique BSTs to the left of 3, which will be generated recursively for (1-2) ->[2,1,null] & [1,null,2]\\n* all unique BSTs to the right of 3, which will be generated recursively for (4-5)->[5,4,null] & [4,null,5]\\nfor each of the unique left BST (keeping 3 as root) e.g.[2,1,null] join all unique right BSTs(root) to the right of 3\\nwhich is [5,4,null] & [4,null,5]\\n\\nThis will generate all unique BSTs recursively, also note while adding a BST to the left or right of current BST we add only root of that BST(since the remaining BST will be made recursively) \\n\\nfor recursion BASE CASE -> when start>end(this means no node can exist to the left or right of current root)\\nreturn {NULL}\\nwhen start==end , which means there is only 1 unique BST that can be made with current node which is the node itself return {new Node(start)}\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> fn(int start,int end){\\n        vector<TreeNode*> res;\\n        //case when left or right subtree for a given node cant be generated \\n        if(start>end) return {NULL};\\n        //case when there is only one node \\n        if(start==end) return {new TreeNode(start)};\\n        \\n        for(int i=start;i<=end;i++){\\n            //generate all left subtrees when i is the root \\n            vector<TreeNode*> left=fn(start,i-1);\\n            // all right subtrees when i is the root \\n            vector<TreeNode*> right=fn(i+1,end);\\n            \\n            for(auto lnode:left){\\n                //for every left subtree with root=i, add all rightsubtrees to it\\n                for(auto rnode:right){\\n                    TreeNode *root=new TreeNode(i,lnode,rnode);\\n                    res.push_back(root); //store one unique BST as result \\n                }\\n                    \\n            }\\n        }\\n        \\n        return res;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        vector<TreeNode*> res=fn(1,n);\\n        return res;\\n    }\\n};\\n```\\n\\nPlease upvote if you found it helpful :)",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> fn(int start,int end){\\n        vector<TreeNode*> res;\\n        //case when left or right subtree for a given node cant be generated \\n        if(start>end) return {NULL};\\n        //case when there is only one node \\n        if(start==end) return {new TreeNode(start)};\\n        \\n        for(int i=start;i<=end;i++){\\n            //generate all left subtrees when i is the root \\n            vector<TreeNode*> left=fn(start,i-1);\\n            // all right subtrees when i is the root \\n            vector<TreeNode*> right=fn(i+1,end);\\n            \\n            for(auto lnode:left){\\n                //for every left subtree with root=i, add all rightsubtrees to it\\n                for(auto rnode:right){\\n                    TreeNode *root=new TreeNode(i,lnode,rnode);\\n                    res.push_back(root); //store one unique BST as result \\n                }\\n                    \\n            }\\n        }\\n        \\n        return res;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        vector<TreeNode*> res=fn(1,n);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934099,
                "title": "java-fast-clean-concise-memoized-recursion-explained-0ms-100",
                "content": "**Intuition** We can break the problem into a subproblem by asking what are all of structures for a given root value.  If we do this, then by virtue of the definition of a binary search tree, all the values less than our root value will be within a left subtree, and al the values greater than our root value will be within a right subtree.  But then, we can repeat this process for both the left and right children, suggesting that recursion will be of help.\\n\\n**Optimization** The input limit n=8 is not very high, but if we want to squeeze every millisecond out of our solution, we should consider one more thing.  We are going to run into a lot of the same small subtrees over and over.  We can remember these for quick lookup instead of rebuilding them each time.  This will also save some space.  This combined with an array-based cache (see **Java Syntax Cleanup**) will put our solution in the fastest class of Java solutions.\\n\\n**Jave Syntax Cleanup** It\\'s nice to use arrays for memoization because they are faster and read more cleanly.  For example, `memo[1][2]` looks nicer (and is faster) than `memo.get(1).get(2)`.  But when you want to create an array out of `List<TreeNode>` elements, Java makes it disgustingly hard to do this without casting, etc.  But there\\'s a trick - you can create a subclass such as `TreeNodeList` which extends a list of a given type (such as `ArrayList<TreeNode>`, but doesn\\'t add any methods.  It\\'s purely an extension to specify a type parameter.  Then we can create `TreeNodeList` arrays for memoization, where each `TreeNodeList` element is a `List<TreeNode>`.  By having an array-based instead of list-based cache, we\\'ll also jump into the top tier in terms of performance of java solutions, with runtimes of 0-1ms for the test suite.\\n\\n**Java Code** O(n^2) space, O(n^2) time.  Space is n^2 due to memoization.  Time would be 2^n except using memoization, we short curcuit frequently.  If we assume that only tree-building is an operation, and a cache hit is not, then due to the size of our cache, we can do at most (n+2)(n+2) operations to fill it, which is O(n^2).\\n\\n```\\nclass Solution {\\n\\n    public List<TreeNode> generateTrees(int n) {\\n        final int limit = n + 1; // upper bound, exclusive\\n        TreeNodeList[][] memo = new TreeNodeList[limit + 1][limit + 1];\\n        return generateTrees(1, limit, memo);\\n    }\\n\\n    private TreeNodeList generateTrees(int low, int limit, TreeNodeList[][] memo) {\\n        TreeNodeList cached = memo[low][limit];\\n        if (cached != null) {\\n            return cached;\\n        }\\n        TreeNodeList out = new TreeNodeList();\\n        for (int r = low; r < limit; ++r) {\\n            TreeNodeList leftNodes = generateTrees(low, r, memo);\\n            TreeNodeList rightNodes = generateTrees(r + 1, limit, memo);\\n            for (TreeNode left : leftNodes) {\\n                for (TreeNode right : rightNodes) {\\n                    TreeNode root = new TreeNode(r);\\n                    root.left = left;\\n                    root.right = right;\\n                    out.add(root);\\n                }\\n            }\\n        }\\n        // Small correction: the list of all trees we can make without any values is [null],\\n\\t\\t// not [].  That is, if we have no node values, there is one possible tree: null.\\n\\t\\t// So we correct empty lists by making them lists of a single null element, instead.\\n        // This makes looping and generating left and right children more straight-forward.\\n        if (out.isEmpty()) {\\n            out.add(null);\\n        }\\n        memo[low][limit] = out;\\n        return out;\\n    }\\n\\n    static class TreeNodeList extends ArrayList<TreeNode> {\\n        // This class exists simply for the convenience of creating arrays without a type parameter.\\n    }\\n\\n}\\n```\\n\\nIf you found this explanation and thought process helpful, please consider an upvote so someone else is more likely to find it, too. And if not, I would sincerely appreciate your constructive criticism so I can learn to write better solutions. Thanks for your time, and happy problem-solving!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\n    public List<TreeNode> generateTrees(int n) {\\n        final int limit = n + 1; // upper bound, exclusive\\n        TreeNodeList[][] memo = new TreeNodeList[limit + 1][limit + 1];\\n        return generateTrees(1, limit, memo);\\n    }\\n\\n    private TreeNodeList generateTrees(int low, int limit, TreeNodeList[][] memo) {\\n        TreeNodeList cached = memo[low][limit];\\n        if (cached != null) {\\n            return cached;\\n        }\\n        TreeNodeList out = new TreeNodeList();\\n        for (int r = low; r < limit; ++r) {\\n            TreeNodeList leftNodes = generateTrees(low, r, memo);\\n            TreeNodeList rightNodes = generateTrees(r + 1, limit, memo);\\n            for (TreeNode left : leftNodes) {\\n                for (TreeNode right : rightNodes) {\\n                    TreeNode root = new TreeNode(r);\\n                    root.left = left;\\n                    root.right = right;\\n                    out.add(root);\\n                }\\n            }\\n        }\\n        // Small correction: the list of all trees we can make without any values is [null],\\n\\t\\t// not [].  That is, if we have no node values, there is one possible tree: null.\\n\\t\\t// So we correct empty lists by making them lists of a single null element, instead.\\n        // This makes looping and generating left and right children more straight-forward.\\n        if (out.isEmpty()) {\\n            out.add(null);\\n        }\\n        memo[low][limit] = out;\\n        return out;\\n    }\\n\\n    static class TreeNodeList extends ArrayList<TreeNode> {\\n        // This class exists simply for the convenience of creating arrays without a type parameter.\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713746,
                "title": "simple-c-code-with-full-explanation-recursive-approach-runtime-16ms",
                "content": "**if you like my approach please don\\'t forget to hit upvote button ! : )**\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    // total no. of binary search tree (countBST) =  2nCn/(n+1)\\n    // node values goes from 1 to n. [SORTED HONA JAROORI HAI - inorder traversal type generate honge]\\n    // if instead of n, we have given vector of different random values to construct BSTs from all those values, then\\n    // you should sort the vector , and then use. approach is same as below...\\n    \\n    // Time Complexity : O(C*n)\\n    // Space Complexity : O(C*n), where C is catalan number \\n    // TC for Outermost loops is simply O(n)\\n    // TC for inner nested loops is O(C)\\n    vector<TreeNode*> rec(int l, int r) \\n    {\\n        if (l > r) return {NULL};\\n        if (l == r) return {new TreeNode(l)};\\n        \\n        vector<TreeNode*> ans;\\n        for (int root = l; root <= r; root++) // fixed at every root\\n        {\\n            vector<TreeNode*> left = rec(l, root-1); //  Have roots of all BSTs which are present in left of \"root\"\\n            vector<TreeNode*> right = rec(root+1, r); // Have roots of all BSTs which are present in right of \"root\"\\n            \\n            // suppose left 4 root, and right has 3 roots, then total BSTs formed for current root is 4 X 3 = 12.\\n            // For each of the 4 left roots, there is 3 roots....means we have to use nested loops for connection with\\n            // current root.\\n            for (auto node_l : left){\\n                for (auto node_r : right){\\n                    \\n                    TreeNode *rootNode = new TreeNode(root);\\n                    rootNode->left = node_l;\\n                    rootNode->right = node_r;\\n                    ans.push_back(rootNode);\\n                }\\n            }\\n                \\n        }\\n        \\n        return ans;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        vector<TreeNode*>ans = rec(1, n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    // total no. of binary search tree (countBST) =  2nCn/(n+1)\\n    // node values goes from 1 to n. [SORTED HONA JAROORI HAI - inorder traversal type generate honge]\\n    // if instead of n, we have given vector of different random values to construct BSTs from all those values, then\\n    // you should sort the vector , and then use. approach is same as below...\\n    \\n    // Time Complexity : O(C*n)\\n    // Space Complexity : O(C*n), where C is catalan number \\n    // TC for Outermost loops is simply O(n)\\n    // TC for inner nested loops is O(C)\\n    vector<TreeNode*> rec(int l, int r) \\n    {\\n        if (l > r) return {NULL};\\n        if (l == r) return {new TreeNode(l)};\\n        \\n        vector<TreeNode*> ans;\\n        for (int root = l; root <= r; root++) // fixed at every root\\n        {\\n            vector<TreeNode*> left = rec(l, root-1); //  Have roots of all BSTs which are present in left of \"root\"\\n            vector<TreeNode*> right = rec(root+1, r); // Have roots of all BSTs which are present in right of \"root\"\\n            \\n            // suppose left 4 root, and right has 3 roots, then total BSTs formed for current root is 4 X 3 = 12.\\n            // For each of the 4 left roots, there is 3 roots....means we have to use nested loops for connection with\\n            // current root.\\n            for (auto node_l : left){\\n                for (auto node_r : right){\\n                    \\n                    TreeNode *rootNode = new TreeNode(root);\\n                    rootNode->left = node_l;\\n                    rootNode->right = node_r;\\n                    ans.push_back(rootNode);\\n                }\\n            }\\n                \\n        }\\n        \\n        return ans;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        vector<TreeNode*>ans = rec(1, n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620543,
                "title": "clean-c-recursive-solution-with-explanation",
                "content": "Basic idea here is to make every node a root and the nodes less than its value will go to its left side and nodes greater than it will go to right side and repeat the same process on those nodes also.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> solve(int l,int r)\\n    {\\n       vector<TreeNode*>ans;\\n        \\n        if(l>r)\\n       {\\n            ans.push_back(NULL);\\n            return ans;\\n        }\\n        \\n        if(l==r)\\n        {\\n            ans.push_back(new TreeNode(l));\\n            return ans;\\n        }\\n        \\n        \\n         for(int i=l;i<=r;i++)\\n        {\\n             int mid=(l+r)/2;\\n             vector<TreeNode*>left=solve(l,i-1);\\n             vector<TreeNode*>right=solve(i+1,r);\\n             \\n             for(auto l:left)\\n             {\\n                 for(auto r:right)\\n                 {\\n                   TreeNode* root=new TreeNode(i);\\n                     root->left=l;\\n                     root->right=r;\\n                     ans.push_back(root);\\n                 }\\n             }\\n        }\\n        \\n       return ans;\\n    }\\n    \\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        return solve(1,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> solve(int l,int r)\\n    {\\n       vector<TreeNode*>ans;\\n        \\n        if(l>r)\\n       {\\n            ans.push_back(NULL);\\n            return ans;\\n        }\\n        \\n        if(l==r)\\n        {\\n            ans.push_back(new TreeNode(l));\\n            return ans;\\n        }\\n        \\n        \\n         for(int i=l;i<=r;i++)\\n        {\\n             int mid=(l+r)/2;\\n             vector<TreeNode*>left=solve(l,i-1);\\n             vector<TreeNode*>right=solve(i+1,r);\\n             \\n             for(auto l:left)\\n             {\\n                 for(auto r:right)\\n                 {\\n                   TreeNode* root=new TreeNode(i);\\n                     root->left=l;\\n                     root->right=r;\\n                     ans.push_back(root);\\n                 }\\n             }\\n        }\\n        \\n       return ans;\\n    }\\n    \\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        return solve(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1441985,
                "title": "swift-readable-solution-recursion",
                "content": "```\\nclass Solution {\\n    func generateTrees(_ n: Int) -> [TreeNode?] {\\n        return generateTrees(start: 1, end: n)\\n    }\\n\\n    private func generateTrees(start: Int, end: Int) -> [TreeNode?] {\\n        var answer: [TreeNode?] = []\\n        if start > end {\\n            answer.append(nil)\\n            return answer\\n        }\\n\\n        for root in start...end {\\n            let leftTrees = generateTrees(start: start, end: root-1)\\n            let rightTrees = generateTrees(start: root+1, end: end)\\n            for leftRoot in leftTrees {\\n                for rightRoot in rightTrees {\\n                    let rootNode = TreeNode(root)\\n                    rootNode.left = leftRoot\\n                    rootNode.right = rightRoot\\n                    answer.append(rootNode)\\n                }\\n            }\\n        }\\n        return answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    func generateTrees(_ n: Int) -> [TreeNode?] {\\n        return generateTrees(start: 1, end: n)\\n    }\\n\\n    private func generateTrees(start: Int, end: Int) -> [TreeNode?] {\\n        var answer: [TreeNode?] = []\\n        if start > end {\\n            answer.append(nil)\\n            return answer\\n        }\\n\\n        for root in start...end {\\n            let leftTrees = generateTrees(start: start, end: root-1)\\n            let rightTrees = generateTrees(start: root+1, end: end)\\n            for leftRoot in leftTrees {\\n                for rightRoot in rightTrees {\\n                    let rootNode = TreeNode(root)\\n                    rootNode.left = leftRoot\\n                    rootNode.right = rightRoot\\n                    answer.append(rootNode)\\n                }\\n            }\\n        }\\n        return answer\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1441709,
                "title": "c-solution",
                "content": "```\\nstruct TreeNode** creatTrees(int low, int high, int *size)\\n{ \\n    if(low > high)\\n    {\\n        struct TreeNode ** out = (struct TreeNode **)malloc(sizeof(struct TreeNode*));\\n        *size = 1;\\n        out[0] = NULL;\\n        return out;\\n    }\\n    struct TreeNode ** out = (struct TreeNode **)malloc(2000*sizeof(struct TreeNode*));\\n    *size = 0;\\n    for(int i=low; i<=high; i++)\\n    {\\n        int leftSize = 0, rightSize = 0;\\n        struct TreeNode ** leftNodes = creatTrees(low, i-1, &leftSize);\\n        struct TreeNode ** rightNodes = creatTrees(i+1, high, &rightSize);\\n        for(int k=0; k<leftSize; k++)\\n            for(int j=0; j<rightSize; j++)\\n            {\\n                out[*size] = (struct TreeNode *)malloc(sizeof(struct TreeNode));\\n                out[*size]->val = i;\\n                out[*size]->left = leftNodes[k];\\n                out[*size]->right = rightNodes[j];\\n                *size += 1;\\n            }\\n    }\\n    return out;\\n}\\nstruct TreeNode** generateTrees(int n, int* returnSize){\\n    return creatTrees(1, n, returnSize);\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nstruct TreeNode** creatTrees(int low, int high, int *size)\\n{ \\n    if(low > high)\\n    {\\n        struct TreeNode ** out = (struct TreeNode **)malloc(sizeof(struct TreeNode*));\\n        *size = 1;\\n        out[0] = NULL;\\n        return out;\\n    }\\n    struct TreeNode ** out = (struct TreeNode **)malloc(2000*sizeof(struct TreeNode*));\\n    *size = 0;\\n    for(int i=low; i<=high; i++)\\n    {\\n        int leftSize = 0, rightSize = 0;\\n        struct TreeNode ** leftNodes = creatTrees(low, i-1, &leftSize);\\n        struct TreeNode ** rightNodes = creatTrees(i+1, high, &rightSize);\\n        for(int k=0; k<leftSize; k++)\\n            for(int j=0; j<rightSize; j++)\\n            {\\n                out[*size] = (struct TreeNode *)malloc(sizeof(struct TreeNode));\\n                out[*size]->val = i;\\n                out[*size]->left = leftNodes[k];\\n                out[*size]->right = rightNodes[j];\\n                *size += 1;\\n            }\\n    }\\n    return out;\\n}\\nstruct TreeNode** generateTrees(int n, int* returnSize){\\n    return creatTrees(1, n, returnSize);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1440845,
                "title": "simple-solution-with-detailed-explanation-and-comments",
                "content": "**Intuition:**\\nThe idea is to generate trees in inorder fashion , making each number in the range[1.n] as the root one by one and recursively obtaining its left and right subtrees ensuring that BST properties doesnt gets violated.\\nIf the Root Value is i\\n* Left subtree will contain values in range[start,i-1]\\n* right subrees will contain valyes in range[i+1,end]\\n\\nfor a particular root value \\'i\\' there are many left and right subtrees possible , so generate all of them and combine all of them and appending to our final result vector of all BSTs.\\n\\n**Base Case:**\\nThere are two base cases:\\n*  If start exceeds end; start>end, there is no tree possible, so instead of returning empty list (which will cause unexpected loop termination in the parent recursive call) , we will append null to the result list and return result.\\n*  if start=end, there is only one number in range i.e. start, so only one Tree possible rooted at start and left and right subtree as null, so, make this tree and add to result list and return.\\n\\nHere is my code:\\n```\\n\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        return helper(1,n);//To generate all the BST possible in range(1,n) \\n    }\\n    vector<TreeNode*> helper(int start, int end){\\n        vector<TreeNode*> allTrees;//vector to store all bsts\\n        if(start>end)//base case\\n        {\\n            allTrees.push_back(NULL); //No Tree is possible if start>end so push none and return\\n            return allTrees;\\n        }\\n        if(start==end) // Base case 2 \\n        {\\n            TreeNode* root=new TreeNode(start); // if there is only 1 number in range i.e. start=end then make th\\n                                                // only number as root node and return\\n            allTrees.push_back(root);\\n            return allTrees;\\n            \\n        }\\n        // making all numbers from start to end as root one by one and generating their left and right subtrees according to BST rules\\n        for(int CurRootVal=start;CurRootVal<=end;CurRootVal++)\\n        {\\n        vector<TreeNode*>allLeftSubtrees=helper(start,CurRootVal-1); // generated Leftsubtrees contains values in range[start,currootvalue-1]\\n            vector<TreeNode*>allRightSubtrees=helper(CurRootVal+1,end); //generated rightsubtrees contains values in range[currootvalue+1,end]\\n            for(auto leftsubtree : allLeftSubtrees) // traversing each of the left subtrees generated\\n            {\\n                for(auto rightsubtree : allRightSubtrees) // for each left subtree, all the right subtrees generated are traversed and combined as below \\n                {\\n                    TreeNode* curRoot=new TreeNode(CurRootVal); // making root node of value curRootVal\\n                    curRoot->left=leftsubtree; // adding leftsubtree to the left child of current root\\n                    curRoot->right=rightsubtree;// adding right subtree to the right child of current root\\n                    allTrees.push_back(curRoot);// appending the tree generated to the result alltrees\\n                }\\n            }\\n            \\n        }\\n        return allTrees;\\n        \\n    }\\n};\\n```\\n\\nComment down in case of any queries.\\n\\n**Please upvote if it helps you :)**",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        return helper(1,n);//To generate all the BST possible in range(1,n) \\n    }\\n    vector<TreeNode*> helper(int start, int end){\\n        vector<TreeNode*> allTrees;//vector to store all bsts\\n        if(start>end)//base case\\n        {\\n            allTrees.push_back(NULL); //No Tree is possible if start>end so push none and return\\n            return allTrees;\\n        }\\n        if(start==end) // Base case 2 \\n        {\\n            TreeNode* root=new TreeNode(start); // if there is only 1 number in range i.e. start=end then make th\\n                                                // only number as root node and return\\n            allTrees.push_back(root);\\n            return allTrees;\\n            \\n        }\\n        // making all numbers from start to end as root one by one and generating their left and right subtrees according to BST rules\\n        for(int CurRootVal=start;CurRootVal<=end;CurRootVal++)\\n        {\\n        vector<TreeNode*>allLeftSubtrees=helper(start,CurRootVal-1); // generated Leftsubtrees contains values in range[start,currootvalue-1]\\n            vector<TreeNode*>allRightSubtrees=helper(CurRootVal+1,end); //generated rightsubtrees contains values in range[currootvalue+1,end]\\n            for(auto leftsubtree : allLeftSubtrees) // traversing each of the left subtrees generated\\n            {\\n                for(auto rightsubtree : allRightSubtrees) // for each left subtree, all the right subtrees generated are traversed and combined as below \\n                {\\n                    TreeNode* curRoot=new TreeNode(CurRootVal); // making root node of value curRootVal\\n                    curRoot->left=leftsubtree; // adding leftsubtree to the left child of current root\\n                    curRoot->right=rightsubtree;// adding right subtree to the right child of current root\\n                    allTrees.push_back(curRoot);// appending the tree generated to the result alltrees\\n                }\\n            }\\n            \\n        }\\n        return allTrees;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325098,
                "title": "c-easy-to-understand-recursive-approach-with-comments",
                "content": "Hi,\\n\\n**If this helps please do UPVOTE or if you have any query or doubt COMMENT it down.**\\n```\\nclass Solution {\\npublic:\\n    \\n\\t// function that takes sub parameters left and right value\\n    vector<TreeNode*> solve(int l,int r){\\n        vector<TreeNode*> ans;\\n        \\n\\t\\t// if l>r just return null\\n        if(l>r){\\n            ans.push_back(NULL);\\n            return ans;\\n        }\\n\\t\\t// if l==r  then we have only 1 node with value l or r\\n        if(l==r){\\n            TreeNode* temp=new TreeNode(l);\\n            ans.push_back(temp);\\n            return ans;\\n        }\\n        \\n\\t\\t// else for every k between l to r append subtree of values left to it to left child and subtrees of values right to it to right child of k\\n        vector<TreeNode*> ansl; // stores pointer to left subtree\\n        vector<TreeNode*> ansr; // stores pointer to right subtree\\n\\n        for(int k=l;k<=r;k++){\\n            ansl = solve(l,k-1);\\n            ansr = solve(k+1,r);\\n            if(ansl.size()==0) ansl.push_back(NULL);\\n            if(ansr.size()==0) ansr.push_back(NULL);\\n\\t\\t\\t\\n\\t\\t\\t// make all combinations with left current and right\\n            for(int i=0;i<ansl.size();i++){\\n                for(int j=0;j<ansr.size();j++){\\n                    TreeNode* temp = new TreeNode(k,ansl[i],ansr[j]);\\n                    ans.push_back(temp);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        \\n        return solve(1,n);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\t// function that takes sub parameters left and right value\\n    vector<TreeNode*> solve(int l,int r){\\n        vector<TreeNode*> ans;\\n        \\n\\t\\t// if l>r just return null\\n        if(l>r){\\n            ans.push_back(NULL);\\n            return ans;\\n        }\\n\\t\\t// if l==r  then we have only 1 node with value l or r\\n        if(l==r){\\n            TreeNode* temp=new TreeNode(l);\\n            ans.push_back(temp);\\n            return ans;\\n        }\\n        \\n\\t\\t// else for every k between l to r append subtree of values left to it to left child and subtrees of values right to it to right child of k\\n        vector<TreeNode*> ansl; // stores pointer to left subtree\\n        vector<TreeNode*> ansr; // stores pointer to right subtree\\n\\n        for(int k=l;k<=r;k++){\\n            ansl = solve(l,k-1);\\n            ansr = solve(k+1,r);\\n            if(ansl.size()==0) ansl.push_back(NULL);\\n            if(ansr.size()==0) ansr.push_back(NULL);\\n\\t\\t\\t\\n\\t\\t\\t// make all combinations with left current and right\\n            for(int i=0;i<ansl.size();i++){\\n                for(int j=0;j<ansr.size();j++){\\n                    TreeNode* temp = new TreeNode(k,ansl[i],ansr[j]);\\n                    ans.push_back(temp);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        \\n        return solve(1,n);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1214387,
                "title": "python-array-recursion",
                "content": "```\\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        \\n        def f(arr):\\n\\t\\t    #Base conditions\\n            if len(arr) < 1:\\n                return [None]\\n            if len(arr) == 1:\\n                return [TreeNode(arr[0])]\\n            \\n            ret = []\\n            for i,item in enumerate(arr):\\n                leftTrees = f(arr[0:i])\\n                rightTrees = f(arr[i+1:])\\n                \\n                for lt in leftTrees:\\n                    for rt in rightTrees:\\n                        r = TreeNode(arr[i])\\n                        r.left = lt\\n                        r.right = rt\\n                        ret.append(r)\\n            return ret\\n        \\n        return f(list(range(1,n+1)))\\n```",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        \\n        def f(arr):\\n\\t\\t    #Base conditions\\n            if len(arr) < 1:\\n                return [None]\\n            if len(arr) == 1:\\n                return [TreeNode(arr[0])]\\n            \\n            ret = []\\n            for i,item in enumerate(arr):\\n                leftTrees = f(arr[0:i])\\n                rightTrees = f(arr[i+1:])\\n                \\n                for lt in leftTrees:\\n                    for rt in rightTrees:\\n                        r = TreeNode(arr[i])\\n                        r.left = lt\\n                        r.right = rt\\n                        ret.append(r)\\n            return ret\\n        \\n        return f(list(range(1,n+1)))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1168576,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        \\n        \\n        List<TreeNode> ans = constructTrees(1, n);\\n        return ans;\\n        \\n    }\\n    public List<TreeNode> constructTrees(int start, int end){\\n        List<TreeNode> list = new ArrayList<>();\\n        //  if start > end   then subtree will be empty so returning NULL in the list\\n        if (start > end) \\n        { \\n            list.add(null); \\n            return list; \\n        } \\n    \\n        // iterate all values from start to end for constructing left and right subtree using recursion\\n        for (int i = start; i <= end; i++) \\n        { \\n            // constructing left subtree \\n            List<TreeNode> leftSubtree  = constructTrees(start, i - 1); \\n    \\n            // constructing right subtree\\n            List<TreeNode> rightSubtree = constructTrees(i + 1, end); \\n    \\n            // now loop through all left and right subtrees and connecting them to ith root\\n            for (int j = 0; j < leftSubtree.size(); j++) \\n            { \\n                TreeNode left = leftSubtree.get(j); \\n                for (int k = 0; k < rightSubtree.size(); k++) \\n                { \\n                    TreeNode right = rightSubtree.get(k); \\n                    TreeNode node = new TreeNode(i);        // making value i as root \\n                    node.left = left;                       // connect left subtree \\n                    node.right = right;                     // connect right subtree \\n                    list.add(node);                         // add this tree to list \\n                } \\n            } \\n        } \\n        return list; \\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        \\n        \\n        List<TreeNode> ans = constructTrees(1, n);\\n        return ans;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 864407,
                "title": "bottom-up-dp-solution-20ms-c",
                "content": "```\\n   TreeNode* cloneAndAddX(TreeNode* root,int x) {\\n        if(root) {\\n            TreeNode* node = new TreeNode(root->val+x);\\n            node->left = cloneAndAddX(root->left,x);\\n            node->right = cloneAndAddX(root->right,x);\\n            return node;\\n        }\\n        return nullptr;\\n    }\\n\\t\\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n == 0) return {};\\n        vector<vector<TreeNode*>> dp(n+1);\\n        dp[0].push_back(nullptr);\\n        dp[1].push_back(new TreeNode(1));\\n        for(int i=2;i<=n;i++) {\\n            for(int j=1;j<=i;j++) {\\n                int leftSize = j-1;\\n                int rightSize = i-j;\\n                for(TreeNode* l: dp[leftSize]) {\\n                    for(TreeNode* r: dp[rightSize]) {\\n                        TreeNode* node = new TreeNode(j);\\n                        node->left = cloneAndAddX(l,0);\\n                        node->right = cloneAndAddX(r,j);\\n                        dp[i].push_back(node);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   TreeNode* cloneAndAddX(TreeNode* root,int x) {\\n        if(root) {\\n            TreeNode* node = new TreeNode(root->val+x);\\n            node->left = cloneAndAddX(root->left,x);\\n            node->right = cloneAndAddX(root->right,x);\\n            return node;\\n        }\\n        return nullptr;\\n    }\\n\\t\\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n == 0) return {};\\n        vector<vector<TreeNode*>> dp(n+1);\\n        dp[0].push_back(nullptr);\\n        dp[1].push_back(new TreeNode(1));\\n        for(int i=2;i<=n;i++) {\\n            for(int j=1;j<=i;j++) {\\n                int leftSize = j-1;\\n                int rightSize = i-j;\\n                for(TreeNode* l: dp[leftSize]) {\\n                    for(TreeNode* r: dp[rightSize]) {\\n                        TreeNode* node = new TreeNode(j);\\n                        node->left = cloneAndAddX(l,0);\\n                        node->right = cloneAndAddX(r,j);\\n                        dp[i].push_back(node);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 780397,
                "title": "c-recursion-and-easy-to-understand",
                "content": "Idea : You have to calculate all the binary search trees from 1 to n. Therefore, for a number in the middle say i, the left subtree would be 1 to i-1 and right subtree would be i+1 to n. So it divides into two sub problems. Solve it for left and right subtree and then iterate through all the combinations of the left and right subtree assigning the left pick from left subtree as the left child and right pick from right subtree as the right child. Return the resulting vecotr of combinations. \\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> genTrees(int start, int end){\\n        vector<TreeNode*>res;\\n        if(start>end){\\n            res.push_back(NULL);\\n            return res;\\n        }\\n        for(int i=start;i<=end;i++){\\n            vector<TreeNode*>leftTree = genTrees(start, i-1);\\n            vector<TreeNode*>rightTree = genTrees(i+1, end);\\n            for(auto leftNode:leftTree){\\n                for(auto rightNode:rightTree){\\n                    TreeNode* root = new TreeNode(i);\\n                    root->left = leftNode;\\n                    root->right = rightNode;\\n                    res.push_back(root);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n==0)return {};\\n        return genTrees(1,n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> genTrees(int start, int end){\\n        vector<TreeNode*>res;\\n        if(start>end){\\n            res.push_back(NULL);\\n            return res;\\n        }\\n        for(int i=start;i<=end;i++){\\n            vector<TreeNode*>leftTree = genTrees(start, i-1);\\n            vector<TreeNode*>rightTree = genTrees(i+1, end);\\n            for(auto leftNode:leftTree){\\n                for(auto rightNode:rightTree){\\n                    TreeNode* root = new TreeNode(i);\\n                    root->left = leftNode;\\n                    root->right = rightNode;\\n                    res.push_back(root);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n==0)return {};\\n        return genTrees(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 474776,
                "title": "go-simple-solution",
                "content": "```go\\nfunc generateTrees(n int) []*TreeNode {\\n\\tif n <= 0 {\\n\\t\\treturn []*TreeNode{}\\n\\t}\\n\\treturn helper(1, n)\\n}\\n\\nfunc helper(min, max int) []*TreeNode {\\n\\tretSlice := []*TreeNode{}\\n\\tfor i := min; i <= max; i++ {\\n\\t\\tleft := helper(min, i-1)\\n\\t\\tright := helper(i+1, max)\\n\\t\\tfor _, l := range left {\\n\\t\\t\\tfor _, r := range right {\\n\\t\\t\\t\\tretSlice = append(retSlice, &TreeNode{\\n\\t\\t\\t\\t\\tVal:   i,\\n\\t\\t\\t\\t\\tLeft:  l,\\n\\t\\t\\t\\t\\tRight: r,\\n\\t\\t\\t\\t})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t// if empty, we need a nil node\\n\\tif len(retSlice) == 0 {\\n\\t\\tretSlice = append(retSlice, nil)\\n\\t}\\n\\treturn retSlice\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc generateTrees(n int) []*TreeNode {\\n\\tif n <= 0 {\\n\\t\\treturn []*TreeNode{}\\n\\t}\\n\\treturn helper(1, n)\\n}\\n\\nfunc helper(min, max int) []*TreeNode {\\n\\tretSlice := []*TreeNode{}\\n\\tfor i := min; i <= max; i++ {\\n\\t\\tleft := helper(min, i-1)\\n\\t\\tright := helper(i+1, max)\\n\\t\\tfor _, l := range left {\\n\\t\\t\\tfor _, r := range right {\\n\\t\\t\\t\\tretSlice = append(retSlice, &TreeNode{\\n\\t\\t\\t\\t\\tVal:   i,\\n\\t\\t\\t\\t\\tLeft:  l,\\n\\t\\t\\t\\t\\tRight: r,\\n\\t\\t\\t\\t})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t// if empty, we need a nil node\\n\\tif len(retSlice) == 0 {\\n\\t\\tretSlice = append(retSlice, nil)\\n\\t}\\n\\treturn retSlice\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 285636,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    public IList<TreeNode> GenerateTrees(int n) {\\n        if (n == 0) return new List<TreeNode>();\\n        return DFS(1, n);\\n    }\\n\\n    private IList<TreeNode> DFS(int start, int end) {\\n        if (start > end) {\\n            return new List<TreeNode>() { null };\\n        }\\n        var result = new List<TreeNode>();\\n        for (int i = start; i <= end; i++) {\\n            var leftList = DFS(start, i - 1);\\n            var rightList = DFS(i + 1, end);\\n\\n            foreach (var left in leftList) {\\n                foreach (var right in rightList) {\\n                    var root = new TreeNode(i);\\n                    root.left = left;\\n                    root.right = right;\\n                    result.Add(root);\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<TreeNode> GenerateTrees(int n) {\\n        if (n == 0) return new List<TreeNode>();\\n        return DFS(1, n);\\n    }\\n\\n    private IList<TreeNode> DFS(int start, int end) {\\n        if (start > end) {\\n            return new List<TreeNode>() { null };\\n        }\\n        var result = new List<TreeNode>();\\n        for (int i = start; i <= end; i++) {\\n            var leftList = DFS(start, i - 1);\\n            var rightList = DFS(i + 1, end);\\n\\n            foreach (var left in leftList) {\\n                foreach (var right in rightList) {\\n                    var root = new TreeNode(i);\\n                    root.left = left;\\n                    root.right = right;\\n                    result.Add(root);\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 243362,
                "title": "java-dp-runtime-1-ms-faster-than-100-00",
                "content": "The origin DP.Not use backup,nout use iteration\\uFF0Cso can be optimize more quickly.\\n```\\nF(1...n) =f(2,n)+f(1,1)*f(3,n)+...+f(1,i-1)*f(i+1,n)+...+f(1,n-1).\\n```\\nExplanation: n node,\\ncan be represent root 1,the left is null,the right can be represent (2,n) child problem,\\nplus  root 2,the left is (1,1) child problem ,the right can be represent (3,n) child problem,\\nplus root 3,the left is (1,2) child problem ,the right can be represent (4,n) child problem,...\\nplus root i,the left is (1,i-1) child problem ,the right can be represent (i+1,n) child problem, and so on.\\n```\\n     public List<TreeNode> generateTrees(int n) {\\n       if (n == 0) {\\n            return new ArrayList<>();\\n        }\\n        List<TreeNode> results = generateTrees(1, n);\\n        return results;\\n    }\\n\\n    private List<TreeNode> generateTrees(int begin, int end) {\\n        List<TreeNode> results = new ArrayList<>();\\n        if (begin > end) {\\n            results.add(null);\\n            return results;\\n        }\\n        if (begin == end) {\\n            results.add(new TreeNode(begin));\\n            return results;\\n        }\\n\\n        for (int i = begin; i <= end; i++) {\\n            List<TreeNode> lstLeft = generateTrees(begin, i - 1);\\n            List<TreeNode> lstRight = generateTrees(i + 1, end);\\n\\n            for (int j = 0; j < lstLeft.size(); j++) {\\n                TreeNode lNode = lstLeft.get(j);\\n                for (int k = 0; k < lstRight.size(); k++) {\\n                    TreeNode rNode = lstRight.get(k);\\n                    TreeNode root = new TreeNode(i);\\n                    root.left = lNode;\\n                    root.right = rNode;\\n                    results.add(root);\\n                }\\n            }\\n        }\\n        return results;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nF(1...n) =f(2,n)+f(1,1)*f(3,n)+...+f(1,i-1)*f(i+1,n)+...+f(1,n-1).\\n```\n```\\n     public List<TreeNode> generateTrees(int n) {\\n       if (n == 0) {\\n            return new ArrayList<>();\\n        }\\n        List<TreeNode> results = generateTrees(1, n);\\n        return results;\\n    }\\n\\n    private List<TreeNode> generateTrees(int begin, int end) {\\n        List<TreeNode> results = new ArrayList<>();\\n        if (begin > end) {\\n            results.add(null);\\n            return results;\\n        }\\n        if (begin == end) {\\n            results.add(new TreeNode(begin));\\n            return results;\\n        }\\n\\n        for (int i = begin; i <= end; i++) {\\n            List<TreeNode> lstLeft = generateTrees(begin, i - 1);\\n            List<TreeNode> lstRight = generateTrees(i + 1, end);\\n\\n            for (int j = 0; j < lstLeft.size(); j++) {\\n                TreeNode lNode = lstLeft.get(j);\\n                for (int k = 0; k < lstRight.size(); k++) {\\n                    TreeNode rNode = lstRight.get(k);\\n                    TreeNode root = new TreeNode(i);\\n                    root.left = lNode;\\n                    root.right = rNode;\\n                    results.add(root);\\n                }\\n            }\\n        }\\n        return results;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 141443,
                "title": "a-simple-python-dp-solution",
                "content": "```python\\nclass Solution(object):\\n    def generateTrees(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[TreeNode]\\n        \"\"\"\\n        if n == 0:\\n            return []\\n        return self.gen_helper({}, 1, n)\\n        \\n    def gen_helper(self, memo, start, end):\\n        if start > end:\\n            return [None]\\n        if (start, end) in memo:\\n            return memo[(start, end)]\\n        memo[(start, end)] = []\\n        for root_val in xrange(start, end+1):\\n            for left_child in self.gen_helper(memo, start, root_val-1):\\n                for right_child in self.gen_helper(memo, root_val+1, end):\\n                    root = TreeNode(root_val)\\n                    root.left, root.right = left_child, right_child\\n                    memo[(start, end)].append(root)\\n        return memo[(start, end)]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def generateTrees(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[TreeNode]\\n        \"\"\"\\n        if n == 0:\\n            return []\\n        return self.gen_helper({}, 1, n)\\n        \\n    def gen_helper(self, memo, start, end):\\n        if start > end:\\n            return [None]\\n        if (start, end) in memo:\\n            return memo[(start, end)]\\n        memo[(start, end)] = []\\n        for root_val in xrange(start, end+1):\\n            for left_child in self.gen_helper(memo, start, root_val-1):\\n                for right_child in self.gen_helper(memo, root_val+1, end):\\n                    root = TreeNode(root_val)\\n                    root.left, root.right = left_child, right_child\\n                    memo[(start, end)].append(root)\\n        return memo[(start, end)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31498,
                "title": "short-c-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n == 0) return {};\\n        return DFS(1, n);\\n    }\\n    \\n    vector<TreeNode*> DFS(int l, int r){\\n        vector<TreeNode*>res;\\n        if(l > r) return {NULL};\\n        for(int i = l; i <= r; i++){\\n            auto left = DFS(l, i - 1);\\n            auto right = DFS(i + 1, r);\\n            for(auto x: left)\\n                for(auto y: right){\\n                    TreeNode* root = new TreeNode(i);\\n                    root->left = x;\\n                    root->right = y;\\n                    res.push_back(root);\\n                }    \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n == 0) return {};\\n        return DFS(1, n);\\n    }\\n    \\n    vector<TreeNode*> DFS(int l, int r){\\n        vector<TreeNode*>res;\\n        if(l > r) return {NULL};\\n        for(int i = l; i <= r; i++){\\n            auto left = DFS(l, i - 1);\\n            auto right = DFS(i + 1, r);\\n            for(auto x: left)\\n                for(auto y: right){\\n                    TreeNode* root = new TreeNode(i);\\n                    root->left = x;\\n                    root->right = y;\\n                    res.push_back(root);\\n                }    \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31553,
                "title": "very-simple-python-recursive-solution",
                "content": "```\\nclass Solution(object):\\n    def generate(self, i, j):\\n        l = []\\n        if i > j: l.append(None)\\n        for k in xrange(i, j+1):\\n            left = self.generate(i, k-1)\\n            right = self.generate(k+1, j)\\n            for nodeleft in left:\\n                for noderight in right:\\n                    root = TreeNode(k)\\n                    root.left = nodeleft\\n                    root.right = noderight\\n                    l.append(root)\\n        return l\\n    \\n    def generateTrees(self, n):\\n        if n == 0: return []\\n        return self.generate(1, n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def generate(self, i, j):\\n        l = []\\n        if i > j: l.append(None)\\n        for k in xrange(i, j+1):\\n            left = self.generate(i, k-1)\\n            right = self.generate(k+1, j)\\n            for nodeleft in left:\\n                for noderight in right:\\n                    root = TreeNode(k)\\n                    root.left = nodeleft\\n                    root.right = noderight\\n                    l.append(root)\\n        return l\\n    \\n    def generateTrees(self, n):\\n        if n == 0: return []\\n        return self.generate(1, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31555,
                "title": "recursive-c-15-lines",
                "content": "``` \\nclass Solution {\\npublic:\\n   std::vector<TreeNode*> generateTrees(int n2, int n1=1) {\\n      std::vector<TreeNode*> TreeHeads;\\n      for(int i=n1; i<=n2; ++i) {\\n         auto LeftTrees = i==n1 ? std::vector<TreeNode*>{nullptr} : generateTrees(i-1, n1);\\n         auto RightTrees = i==n2 ? std::vector<TreeNode*>{nullptr} : generateTrees(n2, i+1);\\n         for( auto pleft : LeftTrees )\\n            for( auto pright : RightTrees ) {\\n               auto head = new TreeNode(i);\\n               head->left = pleft; head->right = pright;\\n               TreeHeads.push_back(head);\\n            }\\n      }\\n      return TreeHeads;\\n   }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "``` \\nclass Solution {\\npublic:\\n   std::vector<TreeNode*> generateTrees(int n2, int n1=1) {\\n      std::vector<TreeNode*> TreeHeads;\\n      for(int i=n1; i<=n2; ++i) {\\n         auto LeftTrees = i==n1 ? std::vector<TreeNode*>{nullptr} : generateTrees(i-1, n1);\\n         auto RightTrees = i==n2 ? std::vector<TreeNode*>{nullptr} : generateTrees(n2, i+1);\\n         for( auto pleft : LeftTrees )\\n            for( auto pright : RightTrees ) {\\n               auto head = new TreeNode(i);\\n               head->left = pleft; head->right = pright;\\n               TreeHeads.push_back(head);\\n            }\\n      }\\n      return TreeHeads;\\n   }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31568,
                "title": "share-my-dp-c-solution-uff0cbeats-91-82-uff0ceasy-understand",
                "content": "    void genTree(TreeNode* root, TreeNode* left, TreeNode* right,int &num){\\n        if(left){\\n            root->left = new TreeNode(left->val);\\n            genTree(root->left,left->left,left->right,num);\\n        }\\n        root->val = ++ num;\\n        if(right){\\n            root->right = new TreeNode(right->val);\\n            genTree(root->right,right->left,right->right,num);\\n        }\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        vector<vector<TreeNode*> > res(n + 1);\\n        if(!n) return res[0];\\n        res[0] = {NULL};\\n        res[1] = {new TreeNode(1)};\\n        for(int i = 2;i <= n; ++ i){\\n            for(int j = 1;j <= i; ++ j){\\n                for(int x = 0; x < res[j - 1].size(); ++ x)\\n                    for(int y = 0; y < res[i - j].size(); ++ y)\\n                    {\\n                        int num = 0;\\n                        TreeNode *tmp = new TreeNode(j);\\n                        genTree(tmp,res[j - 1][x],res[i - j][y],num);\\n                        res[i].push_back(tmp);\\n                    }\\n            }\\n        }\\n        return res[n];\\n    }",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "    void genTree(TreeNode* root, TreeNode* left, TreeNode* right,int &num){\\n        if(left){\\n            root->left = new TreeNode(left->val);\\n            genTree(root->left,left->left,left->right,num);\\n        }\\n        root->val = ++ num;\\n        if(right){\\n            root->right = new TreeNode(right->val);\\n            genTree(root->right,right->left,right->right,num);\\n        }\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        vector<vector<TreeNode*> > res(n + 1);\\n        if(!n) return res[0];\\n        res[0] = {NULL};\\n        res[1] = {new TreeNode(1)};\\n        for(int i = 2;i <= n; ++ i){\\n            for(int j = 1;j <= i; ++ j){\\n                for(int x = 0; x < res[j - 1].size(); ++ x)\\n                    for(int y = 0; y < res[i - j].size(); ++ y)\\n                    {\\n                        int num = 0;\\n                        TreeNode *tmp = new TreeNode(j);\\n                        genTree(tmp,res[j - 1][x],res[i - j][y],num);\\n                        res[i].push_back(tmp);\\n                    }\\n            }\\n        }\\n        return res[n];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31544,
                "title": "the-trap-i-meet-with-c",
                "content": "dURING my implementation.\\n\\nI make one mistake as follows:\\n\\n        if(s>e)  return NULL;\\n\\n        should be\\n\\n        if(s>e)  return { NULL };\\n\\n\\nAs we will loop left and right result to combine with the root node.\\n\\nHere is the AC implementation\\n\\n    class Solution {\\n    public:\\n        vector<TreeNode*> generateTrees(int n) {\\n            if(n==0)  return vector<TreeNode*>{};\\n            return help(1, n);\\n        }\\n        \\n        vector<TreeNode*> help(int s, int e){\\n            vector<TreeNode*> result;\\n            if(s>e)  return {NULL};\\n            for(int i=s; i<=e; i++){\\n                vector<TreeNode*> left=help(s, i-1);\\n                vector<TreeNode*> right=help(i+1, e);\\n                for(auto l:left){\\n                    for(auto r:right){\\n                        TreeNode* root=new TreeNode(i);\\n                        root->left=l;\\n                        root->right=r;\\n                        result.push_back(root);\\n                    }\\n                }\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<TreeNode*> generateTrees(int n) {\\n            if(n==0)  return vector<TreeNode*>{}",
                "codeTag": "Java"
            },
            {
                "id": 31578,
                "title": "java-2ms-solution-beats-92",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * public class TreeNode {\\n     *     int val;\\n     *     TreeNode left;\\n     *     TreeNode right;\\n     *     TreeNode(int x) { val = x; }\\n     * }\\n     */\\n    public class Solution {\\n        public List<TreeNode> generateTrees(int n) {\\n            if(n==0) return new ArrayList<TreeNode>();\\n            return generateTress(1, n);\\n        }\\n        \\n        private List<TreeNode> generateTress(int start, int end){\\n            if(start>end) {\\n                List<TreeNode> list = new ArrayList<TreeNode>();\\n                list.add(null);\\n                return list;\\n            }\\n            if(start==end) {\\n                List<TreeNode> list = new ArrayList<TreeNode>();\\n                list.add(new TreeNode(start)); return list;\\n            }\\n            List<TreeNode> roots = new ArrayList<TreeNode>();\\n            for(int i=start;i<=end;i++){\\n                List<TreeNode> leftTrees = generateTress(start, i-1);\\n                List<TreeNode> rightTrees = generateTress(i+1, end);\\n                for(int j=0;j<leftTrees.size();j++){\\n                    for(int k=0;k<rightTrees.size();k++){\\n                        TreeNode root = new TreeNode(i);\\n                        root.left = leftTrees.get(j);\\n                        root.right = rightTrees.get(k);\\n                        roots.add(root);\\n                    }\\n                }\\n                \\n            }\\n            return roots;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<TreeNode> generateTrees(int n) {\\n            if(n==0) return new ArrayList<TreeNode>();\\n            return generateTress(1, n);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 31640,
                "title": "accepted-iterative-java-solution",
                "content": "The idea is to generate binary trees for every number from 1 and store them in map. And for every next N get roots from 1 to N and just link left and right subtrees generated previously. All values in right subtree should be encreased by the root value.\\n\\n    public List<TreeNode> generateTrees(int n) {\\n        Map<Integer, List<TreeNode>> lists = new HashMap<Integer, List<TreeNode>>();\\n        \\n        List<TreeNode> list = new LinkedList<TreeNode>();\\n        list.add(null);\\n        if (n==0) return list;\\n        lists.put(0, list);\\n        \\n        list = new LinkedList<TreeNode>();\\n        TreeNode root = new TreeNode(1);\\n        list.add(root);\\n        lists.put(1, list);\\n        \\n        for (int i=2; i<=n; i++) {\\n        \\tlist = new LinkedList<TreeNode>();\\n        \\tfor (int j=1; j<=i; j++) {\\n        \\t\\tfor (TreeNode left:lists.get(j-1)) {\\n        \\t\\t\\tfor (TreeNode right:lists.get(i-j)) {\\n        \\t\\t\\t\\troot = new TreeNode(j);\\n            \\t\\t\\troot.left = left;\\n        \\t\\t\\t\\troot.right = greaterCopy(right, j);\\n        \\t\\t\\t\\tlist.add(root);\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        \\tlists.put(i, list);\\n        }\\n        return list;\\n    }\\n\\t\\n\\tprivate TreeNode greaterCopy(TreeNode node, int add) {\\n\\t\\tif (node == null) return null;\\n\\t\\tTreeNode copy = new TreeNode(node.val + add);\\n\\t\\tcopy.left = greaterCopy(node.left, add);\\n\\t\\tcopy.right = greaterCopy(node.right, add);\\n\\t\\treturn copy;\\n\\t}",
                "solutionTags": [],
                "code": "The idea is to generate binary trees for every number from 1 and store them in map. And for every next N get roots from 1 to N and just link left and right subtrees generated previously. All values in right subtree should be encreased by the root value.\\n\\n    public List<TreeNode> generateTrees(int n) {\\n        Map<Integer, List<TreeNode>> lists = new HashMap<Integer, List<TreeNode>>();\\n        \\n        List<TreeNode> list = new LinkedList<TreeNode>();\\n        list.add(null);\\n        if (n==0) return list;\\n        lists.put(0, list);\\n        \\n        list = new LinkedList<TreeNode>();\\n        TreeNode root = new TreeNode(1);\\n        list.add(root);\\n        lists.put(1, list);\\n        \\n        for (int i=2; i<=n; i++) {\\n        \\tlist = new LinkedList<TreeNode>();\\n        \\tfor (int j=1; j<=i; j++) {\\n        \\t\\tfor (TreeNode left:lists.get(j-1)) {\\n        \\t\\t\\tfor (TreeNode right:lists.get(i-j)) {\\n        \\t\\t\\t\\troot = new TreeNode(j);\\n            \\t\\t\\troot.left = left;\\n        \\t\\t\\t\\troot.right = greaterCopy(right, j);\\n        \\t\\t\\t\\tlist.add(root);\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        \\tlists.put(i, list);\\n        }\\n        return list;\\n    }\\n\\t\\n\\tprivate TreeNode greaterCopy(TreeNode node, int add) {\\n\\t\\tif (node == null) return null;\\n\\t\\tTreeNode copy = new TreeNode(node.val + add);\\n\\t\\tcopy.left = greaterCopy(node.left, add);\\n\\t\\tcopy.right = greaterCopy(node.right, add);\\n\\t\\treturn copy;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3867714,
                "title": "java-tabulation-solution-beats-99-6-explained-efficiently-upvote-if-it-helps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code aims to generate all unique Binary Search Trees (BSTs) that can be formed using the values from 1 to `n`. It uses a recursive approach along with memoization (dynamic programming) to avoid redundant calculations and optimize the solution.\\n\\n**Logic:**\\n1. The `generateTrees` function is the entry point of the algorithm, which takes an integer `n` as input representing the number of nodes in the desired BSTs.\\n\\n2. It initializes a 2D array `dp` of `List<TreeNode>` to store the results of subproblems related to generating BSTs from different ranges of values.\\n\\n3. It calls the `addBst` function with `low = 1` and `high = n` to generate all BSTs that can be formed using the values from 1 to `n`.\\n\\n4. The `addBst` function is the main recursive function used to generate all unique BSTs for a given range of values between `low` and `high`.\\n\\n5. It checks the base case: if `low > high`, it means there are no valid values to form a BST in this range. So, it returns a list containing a single `null` element, representing an empty tree.\\n\\n6. If the result for the current range (`low` to `high`) is already computed and cached in the `dp` array, it directly returns that result, avoiding redundant calculations.\\n\\n7. If the result is not cached, it proceeds to generate all possible unique BSTs for the range of values between `low` and `high`.\\n\\n8. It iterates from `low` to `high`, choosing each value `i` as the root node.\\n\\n9. For each value `i`, it recursively calls the `addBst` function to generate all possible left subtrees and right subtrees.\\n\\n10. It then combines each left subtree with each right subtree and creates a new BST with the current root value `i`.\\n\\n11. The generated BSTs are added to a list, representing all the unique BSTs that can be formed using the range of values between `low` and `high`.\\n\\n12. Finally, the list of BSTs is stored in the `dp` array at index `[low][high]` to cache the result for future use.\\n\\n**Memoization:**\\nThe dynamic programming (DP) aspect comes into play with memoization. The `dp` array is used to store the results of subproblems (i.e., unique BSTs) for different ranges of values. By storing and reusing the results of subproblems, the algorithm avoids redundant calculations and significantly improves the overall efficiency.\\n\\n**Storing in the `dp` array (`dp[i][j]`):**\\nThe `dp` array stores the list of all possible unique BSTs that can be formed from the range of values between `i` and `j`. The idea is to compute the BSTs for smaller ranges first and store the results in the `dp` array. Then, when larger ranges require the same subproblems, the algorithm can directly fetch the precomputed results from the `dp` array, reducing the number of recursive calls and redundant computations.\\n\\nIn summary, the code employs a recursive approach with memoization to generate all unique Binary Search Trees from the given range of values (1 to `n`). It stores the results of subproblems in the `dp` array, allowing it to efficiently build up the solutions for larger ranges of values by reusing the previously computed results. This approach significantly improves the efficiency of generating all possible unique BSTs for the given range of values.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the given algorithm is approximately exponential, specifically O((4^n) / \\u221An). As \\'n\\' increases, the number of recursive calls and the time spent inside each call grow rapidly, making the algorithm inefficient for larger \\'n\\' values.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        List<TreeNode>[][] dp = new List[n + 1][n + 1];\\n        return addBst(1, n, dp);\\n    }\\n\\n    public List<TreeNode> addBst(int low, int high, List<TreeNode>[][] dp) {\\n        if (low > high) {\\n            List<TreeNode> list = new ArrayList<>();\\n            list.add(null);\\n            return list;\\n        }\\n        if (dp[low][high] != null) {\\n            return dp[low][high];\\n        }\\n\\n        List<TreeNode> list = new ArrayList<>();\\n        for (int i = low; i <= high; i++) {\\n            List<TreeNode> leftSubtree = addBst(low, i - 1, dp);\\n            List<TreeNode> rightSubtree = addBst(i + 1, high, dp);\\n\\n            for (TreeNode left : leftSubtree) {\\n                for (TreeNode right : rightSubtree) {\\n                    list.add(new TreeNode(i, left, right));\\n                }\\n            }\\n        }\\n        return dp[low][high] = list;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Backtracking",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        List<TreeNode>[][] dp = new List[n + 1][n + 1];\\n        return addBst(1, n, dp);\\n    }\\n\\n    public List<TreeNode> addBst(int low, int high, List<TreeNode>[][] dp) {\\n        if (low > high) {\\n            List<TreeNode> list = new ArrayList<>();\\n            list.add(null);\\n            return list;\\n        }\\n        if (dp[low][high] != null) {\\n            return dp[low][high];\\n        }\\n\\n        List<TreeNode> list = new ArrayList<>();\\n        for (int i = low; i <= high; i++) {\\n            List<TreeNode> leftSubtree = addBst(low, i - 1, dp);\\n            List<TreeNode> rightSubtree = addBst(i + 1, high, dp);\\n\\n            for (TreeNode left : leftSubtree) {\\n                for (TreeNode right : rightSubtree) {\\n                    list.add(new TreeNode(i, left, right));\\n                }\\n            }\\n        }\\n        return dp[low][high] = list;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865312,
                "title": "c-solution-recursion-supereasy-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The function `generateTrees` takes two parameters: `n`, which represents the number of nodes to be used for constructing BSTs, and `start`, which represents the starting value of the node range.\\n\\n2. The function uses recursion to generate all possible BSTs. The base case for the recursion is when n is less than start. In this case, the function returns a vector containing a single element with a value of `nullptr`. This is because there are no nodes available to construct a BST.\\n\\n3. If the base case is not triggered, the function proceeds with the generation of BSTs.\\n\\n4. The function initializes an empty vector `res` that will store the root nodes of all generated BSTs.\\n\\n5. It then iterates through a loop from `i = start` to `i = n`.\\n Inside the loop, the function performs a nested loop for `leftSubTree` and `rightSubTree` using recursive calls to generateTrees.\\n\\n6. The recursive call `generateTrees(i - 1, start)` generates all possible `left subtrees` of the current root node with values ranging from `start to i - 1`.\\n\\n7. The recursive call `generateTrees(n, i + 1)` generates all possible `right subtrees` of the current root node with values ranging from `i + 1 to n`.\\n\\n8. For each combination of left and right subtrees, the function creates a new BST by creating a new TreeNode with the value `i` as the root and setting the left and right subtrees accordingly.The newly created BST\\'s root node is added to the `res` vector.\\n\\n9. The process repeats for each i in the loop, generating different combinations of BSTs.\\n\\n10. After the loop is complete, the function returns the `res` vector, which contains pointers to the root nodes of all the generated BSTs.\\n\\n# Complexity\\n***Here  C(n) represents the nth Catalan number.***\\n- Time complexity: $$O(C(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n * C(n))$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n,int start=1) {\\n        \\n        //base case\\n        if(n<start){\\n            return {nullptr};\\n        }\\n\\n        vector<TreeNode*> res;\\n\\n        for(int i=start;i<=n;i++){\\n            for(auto leftSubTree:generateTrees(i-1,start)){\\n                for(auto rightSubTree:generateTrees(n,i+1)){\\n                    res.push_back(new TreeNode(i,leftSubTree,rightSubTree));\\n                }\\n\\n            }\\n        }\\n\\n        return res;\\n\\n    }\\n};\\n```\\n\\n![upvote lc.jpeg](https://assets.leetcode.com/users/images/4adc0ee4-e71a-45fd-bb4d-4fa397ebe276_1691227351.1175337.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n,int start=1) {\\n        \\n        //base case\\n        if(n<start){\\n            return {nullptr};\\n        }\\n\\n        vector<TreeNode*> res;\\n\\n        for(int i=start;i<=n;i++){\\n            for(auto leftSubTree:generateTrees(i-1,start)){\\n                for(auto rightSubTree:generateTrees(n,i+1)){\\n                    res.push_back(new TreeNode(i,leftSubTree,rightSubTree));\\n                }\\n\\n            }\\n        }\\n\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3192975,
                "title": "best-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n, int s = 1) {\\n        vector<TreeNode*> ans;\\n        if(n < s) return {nullptr};                              \\n         for(int i=s; i<=n; i++) {                \\t                 \\n            for(auto left: generateTrees(i-1, s)) {                \\n                for(auto right: generateTrees(n, i+1))               \\n                    ans.push_back(new TreeNode(i, left, right));   \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n, int s = 1) {\\n        vector<TreeNode*> ans;\\n        if(n < s) return {nullptr};                              \\n         for(int i=s; i<=n; i++) {                \\t                 \\n            for(auto left: generateTrees(i-1, s)) {                \\n                for(auto right: generateTrees(n, i+1))               \\n                    ans.push_back(new TreeNode(i, left, right));   \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2318945,
                "title": "c-recursion-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> solve(int start,int end)\\n    {\\n        vector<TreeNode*> ans;\\n        if(start>end)\\n            return {NULL};\\n        if(start==end)\\n            return {new TreeNode(start)};\\n        for(int i=start;i<=end;i++)\\n        {\\n            vector<TreeNode*> left=solve(start,i-1);\\n            vector<TreeNode*> right=solve(i+1,end);\\n            for(auto l:left)\\n            {\\n                for(auto r:right)\\n                {\\n                    ans.push_back(new TreeNode(i,l,r));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<TreeNode*> generateTrees(int n) \\n    {\\n        vector<TreeNode*> res=solve(1,n);\\n        return res;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    vector<TreeNode*> solve(int start,int end)\\n    {\\n        vector<TreeNode*> ans;\\n        if(start>end)\\n            return {NULL}",
                "codeTag": "Java"
            },
            {
                "id": 2195106,
                "title": "short-recursive-solution-c-recursion",
                "content": "```\\nclass Solution {\\npublic:    \\n    vector<TreeNode*> generateTrees(int end, int start = 1) {\\n        vector<TreeNode*> res;\\n        if(start > end) return { NULL };\\n        for(int i = start;i<=end;i++)\\n        {\\n            vector<TreeNode*> left = generateTrees(i-1,start);\\n            vector<TreeNode*> right = generateTrees(end,i+1);\\n            for(auto &l: left)\\n            {\\n                for(auto &r: right)\\n                {\\n                    TreeNode *q = new TreeNode(i,l,r);\\n                    res.push_back(q);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    vector<TreeNode*> generateTrees(int end, int start = 1) {\\n        vector<TreeNode*> res;\\n        if(start > end) return { NULL };\\n        for(int i = start;i<=end;i++)\\n        {\\n            vector<TreeNode*> left = generateTrees(i-1,start);\\n            vector<TreeNode*> right = generateTrees(end,i+1);\\n            for(auto &l: left)\\n            {\\n                for(auto &r: right)\\n                {\\n                    TreeNode *q = new TreeNode(i,l,r);\\n                    res.push_back(q);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061160,
                "title": "python-very-short-and-fast",
                "content": "Actually my code was 100 lines!\\nI gradually removed unneccesary parts\\nFrankly speaking I don\\'t even understand the code below myself :)\\n\\nPS: because **leetcode** checks iterable solutions by *for loop* (not strict equality) we can return a **generator object** instead of a list.\\n```\\nclass Solution:\\n    def generateTrees(self, n):\\n        def dp(vals):\\n            if not vals: yield None\\n            for i, n in enumerate(vals):\\n                for left in dp(vals[:i]):\\n                    for right in dp(vals[i + 1:]):\\n                        yield TreeNode(n, left, right)\\n\\n        return dp(list(range(1, n + 1))) \\n```\\nYou can also use 2 pointers to avoid O(n) list slices.\\n```\\nclass Solution:\\n    def generateTrees(self, n):\\n        def dp(l, r):\\n            if l > r: yield None\\n            for n in range(l, r+1):\\n                for left in dp(l, n-1):\\n                    for right in dp(n+1, r):\\n                        yield TreeNode(n, left, right)\\n\\n        return dp(1, n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def generateTrees(self, n):\\n        def dp(vals):\\n            if not vals: yield None\\n            for i, n in enumerate(vals):\\n                for left in dp(vals[:i]):\\n                    for right in dp(vals[i + 1:]):\\n                        yield TreeNode(n, left, right)\\n\\n        return dp(list(range(1, n + 1))) \\n```\n```\\nclass Solution:\\n    def generateTrees(self, n):\\n        def dp(l, r):\\n            if l > r: yield None\\n            for n in range(l, r+1):\\n                for left in dp(l, n-1):\\n                    for right in dp(n+1, r):\\n                        yield TreeNode(n, left, right)\\n\\n        return dp(1, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2002795,
                "title": "beat-simplicity-speed-and-space-python",
                "content": "```\\ndef generateTrees(self, n: int) -> List[Optional[TreeNode]]:\\n        \\n\\t@functools.lru_cache(None)\\n\\tdef helper(left, right):\\n\\t\\tif left > right:\\n\\t\\t\\treturn [None]\\n\\t\\tres = []\\n\\t\\tfor val in range(left, right + 1):\\n\\t\\t\\tfor left_subtree in helper(left, val - 1):\\n\\t\\t\\t\\tfor right_subtree in helper(val + 1, right):\\n\\t\\t\\t\\t\\tres.append(TreeNode(val, left_subtree, right_subtree))\\n\\t\\treturn res\\n\\n\\treturn helper(1, n)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef generateTrees(self, n: int) -> List[Optional[TreeNode]]:\\n        \\n\\t@functools.lru_cache(None)\\n\\tdef helper(left, right):\\n\\t\\tif left > right:\\n\\t\\t\\treturn [None]\\n\\t\\tres = []\\n\\t\\tfor val in range(left, right + 1):\\n\\t\\t\\tfor left_subtree in helper(left, val - 1):\\n\\t\\t\\t\\tfor right_subtree in helper(val + 1, right):\\n\\t\\t\\t\\t\\tres.append(TreeNode(val, left_subtree, right_subtree))\\n\\t\\treturn res\\n\\n\\treturn helper(1, n)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1974739,
                "title": "easy-clean-from-bf-to-dp-w-memorization",
                "content": "**Method 1: Brute Force recursive solution**\\nThe concept is similar to #96, using divide and conquer to solve the problem.\\n\\n```cpp\\nclass Solution {\\n  vector<TreeNode*> generateSubTree(int l, int r) {\\n    vector<TreeNode*> res;\\n    if (l > r){\\n      res.push_back(nullptr);\\n      return res;\\n    }\\n\\n    for (int i = l; i <= r; i++) {\\n      vector<TreeNode*> leftTrees = generateSubTree(l, i-1);\\n      vector<TreeNode*> rightTrees = generateSubTree(i+1, r);\\n      \\n      for (TreeNode *left : leftTrees) {\\n        for (TreeNode *right : rightTrees) {\\n          TreeNode *node = new TreeNode(i);\\n          node->left = left;\\n          node->right = right;\\n          res.push_back(node);\\n        }\\n      }\\n    }\\n    return res;\\n  }\\npublic:\\n  vector<TreeNode*> generateTrees(int n) {\\n    return generateSubTree(1, n);\\n  }\\n};\\n```\\n\\n**Method 2 DP w/ Memorization**\\nFrom above, there are a lot of overlapping subproblems. Therefore, we do not need to recompute every time, using a map to store the previous result which already computed.\\n\\nThis method is very simple, just using left and right as our key, if we find the key existed in memo, just return the value.\\n\\n```cpp\\nclass Solution {\\n  unordered_map<string, vector<TreeNode*>> memo;\\n  vector<TreeNode*> generateSubTree(int l, int r) {\\n    vector<TreeNode*> res;\\n    if (l > r){\\n      res.push_back(nullptr);\\n      return res;\\n    }\\n    string key = to_string(l) + \"_\" + to_string(r);\\n    if (memo.find(key) != memo.end())\\n      return memo.find(key)->second;\\n\\n    for (int i = l; i <= r; i++) {\\n      vector<TreeNode*> leftTrees = generateSubTree(l, i-1);\\n      vector<TreeNode*> rightTrees = generateSubTree(i+1, r);\\n      \\n      for (TreeNode *left : leftTrees) {\\n        for (TreeNode *right : rightTrees) {\\n          TreeNode *node = new TreeNode(i);\\n          node->left = left;\\n          node->right = right;\\n          res.push_back(node);\\n        }\\n      }\\n    }\\n    memo[key] = res;\\n    return res;\\n  }\\npublic:\\n  vector<TreeNode*> generateTrees(int n) {\\n    return generateSubTree(1, n);\\n  }\\n};\\n```\\n\\nRuntime: 12 ms, faster than 96.51% of C++ online submissions for Unique Binary Search Trees II.\\nMemory Usage: 12.3 MB, less than 96.39% of C++ online submissions for Unique Binary Search Trees II.\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\n  vector<TreeNode*> generateSubTree(int l, int r) {\\n    vector<TreeNode*> res;\\n    if (l > r){\\n      res.push_back(nullptr);\\n      return res;\\n    }\\n\\n    for (int i = l; i <= r; i++) {\\n      vector<TreeNode*> leftTrees = generateSubTree(l, i-1);\\n      vector<TreeNode*> rightTrees = generateSubTree(i+1, r);\\n      \\n      for (TreeNode *left : leftTrees) {\\n        for (TreeNode *right : rightTrees) {\\n          TreeNode *node = new TreeNode(i);\\n          node->left = left;\\n          node->right = right;\\n          res.push_back(node);\\n        }\\n      }\\n    }\\n    return res;\\n  }\\npublic:\\n  vector<TreeNode*> generateTrees(int n) {\\n    return generateSubTree(1, n);\\n  }\\n};\\n```\n```cpp\\nclass Solution {\\n  unordered_map<string, vector<TreeNode*>> memo;\\n  vector<TreeNode*> generateSubTree(int l, int r) {\\n    vector<TreeNode*> res;\\n    if (l > r){\\n      res.push_back(nullptr);\\n      return res;\\n    }\\n    string key = to_string(l) + \"_\" + to_string(r);\\n    if (memo.find(key) != memo.end())\\n      return memo.find(key)->second;\\n\\n    for (int i = l; i <= r; i++) {\\n      vector<TreeNode*> leftTrees = generateSubTree(l, i-1);\\n      vector<TreeNode*> rightTrees = generateSubTree(i+1, r);\\n      \\n      for (TreeNode *left : leftTrees) {\\n        for (TreeNode *right : rightTrees) {\\n          TreeNode *node = new TreeNode(i);\\n          node->left = left;\\n          node->right = right;\\n          res.push_back(node);\\n        }\\n      }\\n    }\\n    memo[key] = res;\\n    return res;\\n  }\\npublic:\\n  vector<TreeNode*> generateTrees(int n) {\\n    return generateSubTree(1, n);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772451,
                "title": "simple-recursive-c-solution-with-explaintion",
                "content": "\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        \\n        return helper( 1, n);\\n    }\\n    vector<TreeNode* > helper(  int start, int end){\\n\\t\\n        vector<TreeNode* > res; // to store list of unique bsts\\n        \\n        // eg: n=3, and current root=1;\\n        //left subtree ={1,....,0}                 right subtree= {2,......,3}\\n        //eg:      1\\n        //       /      \\\\\\n        // (1,...,0)     (2,...,3)\\n        \\n        // you can see (1>0) in the left subtree(i.e., no nodes ) (thats why we need to push \"NULL\" and return)\\n        if( start > end){\\n            res.push_back(nullptr);\\n            return res;\\n        }\\n        \\n        // we will make every no. the current rooot and recursively call the left & right subtree\\n        for( int i=start; i<=end; i++){\\n            \\n            vector<TreeNode*> left_sub, right_sub;\\n            left_sub = helper(start, i-1);  // recursively make left subtree\\n            right_sub = helper(i+1, end); // recursively make right subtree\\n            \\n            \\n            // iterate through the alll possible left(values < i) & right(values>i) nodes and do the linkings\\n            // with the current node\\n            for( auto l: left_sub){\\n                for(auto r: right_sub){\\n                    \\n                    //current root\\n                    TreeNode* curr_root= new TreeNode(i);\\n                    \\n                    // link current root with left and right nodes(with every possible combinations)\\n                    curr_root->left = l;\\n                    curr_root->right = r;\\n                    \\n                    res.push_back(curr_root); // push the rooot into the result list\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        \\n        return helper( 1, n);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1686393,
                "title": "c-clean-and-concise",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> recur(int l,int r)\\n    {\\n        if(l>r)\\n            return {NULL};\\n        \\n        vector<TreeNode *>ans;\\n        for(int root=l;root<=r;root++)\\n        {\\n            auto left=recur(l,root-1);\\n            auto right=recur(root+1,r);\\n            \\n            for(auto i:left)\\n            {\\n                for(auto j:right)\\n                {\\n                    TreeNode *newNode=new TreeNode(root,i,j);\\n                    ans.push_back(newNode);\\n                }\\n                    \\n            }\\n        }\\n        return ans;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        \\n        return recur(1,n);\\n    }\\n};\\n```\\n\\n**Pls upvote if you found helpful.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> recur(int l,int r)\\n    {\\n        if(l>r)\\n            return {NULL};\\n        \\n        vector<TreeNode *>ans;\\n        for(int root=l;root<=r;root++)\\n        {\\n            auto left=recur(l,root-1);\\n            auto right=recur(root+1,r);\\n            \\n            for(auto i:left)\\n            {\\n                for(auto j:right)\\n                {\\n                    TreeNode *newNode=new TreeNode(root,i,j);\\n                    ans.push_back(newNode);\\n                }\\n                    \\n            }\\n        }\\n        return ans;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        \\n        return recur(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1504095,
                "title": "recursive-java-solution",
                "content": "For this question suppose the input is 4; That means that from 1 to 4 each of the values can act as the root and can have its own unique BST. SO lets take a start value equal to 1 and an end value equal to the given input n and then use a helper function.\\n \\n In the helper function, lets use a for loop where int i represents the TreeNode present in the list which at first will iterate from 1 to n as each node can be a root. now lets use recursion to find the leftList by defining the start as 1 and the end as (i - 1) and the right list by start as (i + 1) and end as n . By the principle of mathematical induction lets assume that we have recieved the required list of treeNode for the left of i and the right of i.\\n \\n now lets traverse though each of the TreeNode of the left as well as the Right by using a enhanced For Loop. then create a new TreeNode root that will have the data i. and we will have to connect root.left to each node of the leftTree as well as the right tree. Then add the root to the list and return it.\\n ...\\n \\n class Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        \\n        if(n == 0){\\n            return new ArrayList<TreeNode>(null);\\n        }\\n        return generateHelper(1, n);\\n    }\\n\\t// helper function\\n    private List<TreeNode> generateHelper(int start, int end){\\n        List<TreeNode> trees = new ArrayList<>();\\n        if(start > end){\\n            trees.add(null);\\n            return trees;\\n        }\\n        for(int i = start; i <= end; i++){\\n            List<TreeNode> leftTree = generateHelper(start, i - 1);\\n            List<TreeNode> rightTree = generateHelper(i + 1, end);\\n            \\n\\t\\t\\t// traverse to each TreeNode of both the lists\\n            for(TreeNode left : leftTree){\\n                for(TreeNode right : rightTree){\\n                    TreeNode root = new TreeNode(i);\\n                    \\n                    root.left = left;\\n                    root.right = right;\\n                    \\n                    trees.add(root);\\n                }\\n            }\\n        }\\n        return trees;\\n    }\\n}\\n\\n...\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        \\n        if(n == 0){\\n            return new ArrayList<TreeNode>(null);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1446833,
                "title": "java-clean-concise-optimal-code-postorder-traversal-depth-first-search-algorithm",
                "content": "```\\nclass Solution {\\n    \\n    private List<TreeNode> generateTrees (int start, int end) {\\n        \\n        List<TreeNode> allTrees = new ArrayList<> ();\\n        \\n        if (start > end) {\\n            allTrees.add (null);\\n            return allTrees;\\n        }\\n        \\n        for (int i = start; i <= end; i++) {\\n            List<TreeNode> leftTrees = generateTrees (start, i - 1);\\n            List<TreeNode> rightTrees = generateTrees (i + 1, end);\\n            \\n            for (TreeNode l : leftTrees) {\\n                for (TreeNode r : rightTrees) {\\n                    TreeNode node = new TreeNode (i);\\n                    node.left = l;\\n                    node.right = r;\\n                    allTrees.add (node);\\n                }\\n            }\\n        }\\n        \\n        return allTrees;\\n    }\\n    \\n    public List<TreeNode> generateTrees(int n) {\\n        \\n        return generateTrees (1, n);\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private List<TreeNode> generateTrees (int start, int end) {\\n        \\n        List<TreeNode> allTrees = new ArrayList<> ();\\n        \\n        if (start > end) {\\n            allTrees.add (null);\\n            return allTrees;\\n        }\\n        \\n        for (int i = start; i <= end; i++) {\\n            List<TreeNode> leftTrees = generateTrees (start, i - 1);\\n            List<TreeNode> rightTrees = generateTrees (i + 1, end);\\n            \\n            for (TreeNode l : leftTrees) {\\n                for (TreeNode r : rightTrees) {\\n                    TreeNode node = new TreeNode (i);\\n                    node.left = l;\\n                    node.right = r;\\n                    allTrees.add (node);\\n                }\\n            }\\n        }\\n        \\n        return allTrees;\\n    }\\n    \\n    public List<TreeNode> generateTrees(int n) {\\n        \\n        return generateTrees (1, n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1441817,
                "title": "simple-recursive-approach-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<TreeNode*>helper(int start,int end){\\n        if(start>end){\\n            return {NULL};\\n        }\\n        vector<TreeNode*>ans;\\n        for(int i=start;i<=end;i++){\\n            vector<TreeNode*>leftOf =helper(start,i-1);\\n            vector<TreeNode*>rightOf =helper(i+1,end);\\n            for(auto l: leftOf){\\n                for(auto r: rightOf){\\n                    TreeNode* root= new TreeNode(i);\\n                    root->left=l;\\n                    root->right=r;\\n                    ans.push_back(root);                   \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n==0)return vector<TreeNode*>();\\n        return helper(1,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<TreeNode*>helper(int start,int end){\\n        if(start>end){\\n            return {NULL};\\n        }\\n        vector<TreeNode*>ans;\\n        for(int i=start;i<=end;i++){\\n            vector<TreeNode*>leftOf =helper(start,i-1);\\n            vector<TreeNode*>rightOf =helper(i+1,end);\\n            for(auto l: leftOf){\\n                for(auto r: rightOf){\\n                    TreeNode* root= new TreeNode(i);\\n                    root->left=l;\\n                    root->right=r;\\n                    ans.push_back(root);                   \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n==0)return vector<TreeNode*>();\\n        return helper(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1441035,
                "title": "python3-using-dfs",
                "content": "# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n```\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:\\n        return self.dfs(1, n)\\n    \\n    def dfs(self, start, end):\\n        if start > end:\\n            return [None]\\n        if start == end:\\n            return [TreeNode(start)]\\n        result = []\\n        for i in range(start, end+1):\\n            left = self.dfs(start, i-1)\\n            right = self.dfs(i+1, end)\\n            for l in left:\\n                for r in right:\\n                    temp = TreeNode(i)\\n                    temp.left = l\\n                    temp.right = r\\n                    result.append(temp)\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:\\n        return self.dfs(1, n)\\n    \\n    def dfs(self, start, end):\\n        if start > end:\\n            return [None]\\n        if start == end:\\n            return [TreeNode(start)]\\n        result = []\\n        for i in range(start, end+1):\\n            left = self.dfs(start, i-1)\\n            right = self.dfs(i+1, end)\\n            for l in left:\\n                for r in right:\\n                    temp = TreeNode(i)\\n                    temp.left = l\\n                    temp.right = r\\n                    result.append(temp)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1440911,
                "title": "day-2-unique-bst-2-recursion-with-pointers-c-with-explanation",
                "content": "Idea is to build a tree with each subtree by considering an element as a root.\\nTake `i` as root and build trees with `1 to i-1` and `i+1 to n`\\n\\nFor example:\\nTake `n = 3`\\n1. Start with `1` -> build tree from `1 to 0` which is NULL, then build with `2 to 3` for which you can have two types `2->null->3` and `3->2`. Now **attach** these two trees to the main tree i.e. `1` \\nSo, Total combinations you have are: `[1, null, 2, null, 3], [1, null, 3, 2]`\\n\\n\\n2. Start with `2` -> build tree from `1 to 1` which is `1` then build a tree with `3 to 3` which is `3`. Now, attach these two trees to `2`.\\nSo, you only have 1 total combination: `[2, 1, 3]`\\n\\n3. Start with `3` -> build tree from `1 to 2` which are `1->null->null->2` and `2->null->1`. Now attach these two trees to `3`.\\nSo, the combinations are `[3, 1, null, null, 2], [3, 2, null, 1]`\\n\\nLike this we can build for all starting nodes:\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> buildTree(int current, int n) {\\n        vector<TreeNode*> nodeList; // Creating a blank tree list\\n        if (current > n) {\\n            nodeList.push_back(NULL); // for case where current node is greater than n\\n            return nodeList;\\n        }\\n        if (current == n) {\\n            nodeList.push_back(new TreeNode(current)); // for case n just add the element as parent\\n            return nodeList;\\n        }\\n\\t\\t// Loop through all vertices building the tree nodes\\n        for (int i = current; i <= n; i++) {\\n            vector<TreeNode*> leftSubTree = buildTree(current, i-1); // first recursion to loop through all left nodes\\n            vector<TreeNode*> rightSubTree = buildTree(i+1, n); // second recursion to loop through all right nodes\\n\\t\\t\\t// Now we have all lsubtree and rsubtree, we can loop through them and create a tree\\n            for (auto leftTree: leftSubTree) {\\n                for (auto rightTree: rightSubTree) {\\n                    TreeNode *newTree = new TreeNode(i); // create a new tree with the current i as parent\\n                    newTree->left = leftTree; // assign left tree\\n                    newTree->right = rightTree; // assign right tree\\n                    nodeList.push_back(newTree); // push to vector\\n                }\\n            }\\n        }\\n        return nodeList;\\n    }\\n\\t\\n    vector<TreeNode*> generateTrees(int n) {\\n        return buildTree(1, n); // call function from 1 to n\\n    }\\n};\\n```\\n\\nPlease upvote if found helpful!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> buildTree(int current, int n) {\\n        vector<TreeNode*> nodeList; // Creating a blank tree list\\n        if (current > n) {\\n            nodeList.push_back(NULL); // for case where current node is greater than n\\n            return nodeList;\\n        }\\n        if (current == n) {\\n            nodeList.push_back(new TreeNode(current)); // for case n just add the element as parent\\n            return nodeList;\\n        }\\n\\t\\t// Loop through all vertices building the tree nodes\\n        for (int i = current; i <= n; i++) {\\n            vector<TreeNode*> leftSubTree = buildTree(current, i-1); // first recursion to loop through all left nodes\\n            vector<TreeNode*> rightSubTree = buildTree(i+1, n); // second recursion to loop through all right nodes\\n\\t\\t\\t// Now we have all lsubtree and rsubtree, we can loop through them and create a tree\\n            for (auto leftTree: leftSubTree) {\\n                for (auto rightTree: rightSubTree) {\\n                    TreeNode *newTree = new TreeNode(i); // create a new tree with the current i as parent\\n                    newTree->left = leftTree; // assign left tree\\n                    newTree->right = rightTree; // assign right tree\\n                    nodeList.push_back(newTree); // push to vector\\n                }\\n            }\\n        }\\n        return nodeList;\\n    }\\n\\t\\n    vector<TreeNode*> generateTrees(int n) {\\n        return buildTree(1, n); // call function from 1 to n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237072,
                "title": "c-recursion-easy-solution-with-explanation",
                "content": "class Solution {\\npublic:\\n    \\n    // for a list of nodes, I can choose the root node for the tree\\n    // construct the left and right subtrees and return root node of all possible left and right subtrees (low, root-1) and (root+1, high)\\n    // iterate over the left and right subtree root nodes, add it to left and right child of root being considered\\n    \\n    \\n    vector<TreeNode*> constructTree(int low, int high){\\n        if(low>high)\\n            return vector<TreeNode*>{NULL};\\n        // choose the root node\\n        vector<TreeNode*> tree;\\n        vector<TreeNode*> leftSubtrees;\\n        vector<TreeNode*> rightSubtrees;\\n        for(int node = low; node<=high; node++ ){\\n            \\n            leftSubtrees = constructTree(low, node-1);\\n            rightSubtrees = constructTree(node+1, high);\\n            \\n            for(TreeNode* n1 : leftSubtrees){\\n                for(TreeNode* n2: rightSubtrees){\\n                    TreeNode* n = new TreeNode(node);\\n                    n->left = n1;\\n                    n->right = n2;\\n                    tree.push_back(n);\\n                }\\n            }\\n            \\n        } \\n        return tree;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n       if(n==0)\\n           return vector<TreeNode*>();\\n        \\n        return constructTree(1,n);\\n       \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    // for a list of nodes, I can choose the root node for the tree\\n    // construct the left and right subtrees and return root node of all possible left and right subtrees (low, root-1) and (root+1, high)\\n    // iterate over the left and right subtree root nodes, add it to left and right child of root being considered\\n    \\n    \\n    vector<TreeNode*> constructTree(int low, int high){\\n        if(low>high)\\n            return vector<TreeNode*>{NULL}",
                "codeTag": "Java"
            },
            {
                "id": 1199333,
                "title": "c-solution-using-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<TreeNode*> generateBST(int begin, int end)\\n    {\\n        vector<TreeNode*>V;\\n        \\n        if(begin>end)\\n        {\\n            V.push_back(NULL);\\n            return V;\\n        }\\n        \\n        for(int i=begin; i<=end; i++)\\n        {\\n            vector<TreeNode*>left =  generateBST(begin, i-1);\\n            vector<TreeNode*>right =  generateBST(i+1,end);\\n            \\n            for(auto l:left)\\n            {\\n                for(auto r:right)\\n                {\\n                    TreeNode* root = new TreeNode(i);\\n                    root->left = l;\\n                    root->right = r;\\n                    V.push_back(root);\\n                }\\n            }\\n            \\n        }\\n        \\n        return V;\\n        \\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        \\n        vector<TreeNode*>V;\\n        if(n==0) return V;\\n        \\n        return generateBST(1,n);\\n        \\n         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<TreeNode*> generateBST(int begin, int end)\\n    {\\n        vector<TreeNode*>V;\\n        \\n        if(begin>end)\\n        {\\n            V.push_back(NULL);\\n            return V;\\n        }\\n        \\n        for(int i=begin; i<=end; i++)\\n        {\\n            vector<TreeNode*>left =  generateBST(begin, i-1);\\n            vector<TreeNode*>right =  generateBST(i+1,end);\\n            \\n            for(auto l:left)\\n            {\\n                for(auto r:right)\\n                {\\n                    TreeNode* root = new TreeNode(i);\\n                    root->left = l;\\n                    root->right = r;\\n                    V.push_back(root);\\n                }\\n            }\\n            \\n        }\\n        \\n        return V;\\n        \\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        \\n        vector<TreeNode*>V;\\n        if(n==0) return V;\\n        \\n        return generateBST(1,n);\\n        \\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1137417,
                "title": "c-recursion-12ms-simple-and-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n == 0){\\n            return {NULL};\\n        }\\n        return recur(1, n);\\n    }\\n    \\n    vector<TreeNode*> recur(int start, int end){\\n        vector<TreeNode*> V;\\n        if(start > end){\\n            V.push_back(NULL);\\n            return V;\\n        }\\n        for(int i=start;i<=end;i++){\\n            vector<TreeNode*> left = recur(start, i-1);\\n            vector<TreeNode*> right = recur(i+1, end);\\n            \\n            for(auto l: left){\\n                for(auto r: right){\\n                    TreeNode* tree = new TreeNode(i);\\n                    tree->left = l;\\n                    tree->right = r;\\n                    V.push_back(tree);\\n                }\\n            }\\n        }\\n        return V;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n == 0){\\n            return {NULL};\\n        }\\n        return recur(1, n);\\n    }\\n    \\n    vector<TreeNode*> recur(int start, int end){\\n        vector<TreeNode*> V;\\n        if(start > end){\\n            V.push_back(NULL);\\n            return V;\\n        }\\n        for(int i=start;i<=end;i++){\\n            vector<TreeNode*> left = recur(start, i-1);\\n            vector<TreeNode*> right = recur(i+1, end);\\n            \\n            for(auto l: left){\\n                for(auto r: right){\\n                    TreeNode* tree = new TreeNode(i);\\n                    tree->left = l;\\n                    tree->right = r;\\n                    V.push_back(tree);\\n                }\\n            }\\n        }\\n        return V;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121143,
                "title": "python-super-simple-with-documentation",
                "content": "This is actually an Easy difficulty problem. The only thing to remember is the discipline of keeping smaller values to left sub-tree and bigger values to right sub-tree, to ensure we have BSTs, which itself is trivially obvious since we are dealing with BST.\\n```\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        def bstGen(arr:List[int])->List[TreeNode]:\\n            if len(arr)<=0: return [None]                       # terminal condition\\n            result = []                                         \\n            for i in range(len(arr)):                           # for each number in the input list\\n                left, right = bstGen(arr[:i]), bstGen(arr[i+1:])# recursive calls to the lesser and greater numbers\\n                for l in left:                                  # genereate all combinations of left and right subtrees\\n                    for r in right:\\n                        result.append(TreeNode(arr[i], l, r))   # append each combination to the list of trees\\n            return result\\n        return bstGen(list(range(1,n+1)))\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        def bstGen(arr:List[int])->List[TreeNode]:\\n            if len(arr)<=0: return [None]                       # terminal condition\\n            result = []                                         \\n            for i in range(len(arr)):                           # for each number in the input list\\n                left, right = bstGen(arr[:i]), bstGen(arr[i+1:])# recursive calls to the lesser and greater numbers\\n                for l in left:                                  # genereate all combinations of left and right subtrees\\n                    for r in right:\\n                        result.append(TreeNode(arr[i], l, r))   # append each combination to the list of trees\\n            return result\\n        return bstGen(list(range(1,n+1)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075772,
                "title": "c-faster-than-97-5-recursive-with-memoization",
                "content": "1.  We know that all nodes in left subtree are smaller than root and all nodes in right subtree are greater than node in BST.\\n2.  So, if we make ith number as root, 1 to i-1 will be in our left subtree and i+1 to n will be in our right subtree.\\n3.  Now, If 1 to i-1 can form different trees in p ways and i+1 to n can form different trees in q ways. Then our answer will be p * q.\\n4.  Also, we can have n choices to select our root, so we will be iterating over 1 to n for root and another loops for left and right subtree.\\n5.  At last, we can memoize this recursive solution.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> dp[13][13];\\n    vector<TreeNode*> constructBST(int start,int end){\\n        vector<TreeNode*> res;\\n        if(start > end){\\n            res.push_back(NULL); // start > end => subtree will be empty\\n            return res;\\n        }\\n        if(dp[start][end].size() != 0){  // Memoizing recursion calls\\n            return dp[start][end];\\n        }\\n        for(int i = start;i<=end;i++){\\n            vector<TreeNode*> left = constructBST(start,i-1); // constructing left subtree\\n            vector<TreeNode*> right = constructBST(i+1,end); //constructing right subtree\\n            \\n            // now looping through all left and right subtrees and connecting \\n            // them to ith root  below\\n            for(TreeNode* l:left){\\n                for(TreeNode* r:right){\\n                    TreeNode* root = new TreeNode(i);  //making value i as root \\n                    root->left = l;                    //connecting left subtree\\n                    root->right = r;                   //connecting right subtree\\n                    \\n                    res.push_back(root);               // adding tree to list\\n                }\\n            }\\n        }\\n        return dp[start][end] = res;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        \\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                dp[i][j].clear();\\n            }\\n        }\\n        return constructBST(1,n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> dp[13][13];\\n    vector<TreeNode*> constructBST(int start,int end){\\n        vector<TreeNode*> res;\\n        if(start > end){\\n            res.push_back(NULL); // start > end => subtree will be empty\\n            return res;\\n        }\\n        if(dp[start][end].size() != 0){  // Memoizing recursion calls\\n            return dp[start][end];\\n        }\\n        for(int i = start;i<=end;i++){\\n            vector<TreeNode*> left = constructBST(start,i-1); // constructing left subtree\\n            vector<TreeNode*> right = constructBST(i+1,end); //constructing right subtree\\n            \\n            // now looping through all left and right subtrees and connecting \\n            // them to ith root  below\\n            for(TreeNode* l:left){\\n                for(TreeNode* r:right){\\n                    TreeNode* root = new TreeNode(i);  //making value i as root \\n                    root->left = l;                    //connecting left subtree\\n                    root->right = r;                   //connecting right subtree\\n                    \\n                    res.push_back(root);               // adding tree to list\\n                }\\n            }\\n        }\\n        return dp[start][end] = res;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        \\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                dp[i][j].clear();\\n            }\\n        }\\n        return constructBST(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074455,
                "title": "javascript-recursive-solution",
                "content": "```\\nvar generateTrees = function(n) {\\n   \\n    \\n    const constructArray = (start, end) => {\\n        const result = [];\\n        \\n        if(start > end){\\n            return [null];\\n        }\\n        \\n        if(start===end){\\n            return [new TreeNode(start)];\\n        }\\n        \\n        if(end-start===1){\\n            const first = new TreeNode(start, null, new TreeNode(end));\\n            const second = new TreeNode(end, new TreeNode(start), null);\\n            return [first, second];\\n        }\\n        \\n        for(let i=start; i<=end; i++){\\n            const leftSide = constructArray(start, i-1);\\n            const rightSide = constructArray(i+1, end);\\n            \\n            leftSide.forEach(ls => {\\n                rightSide.forEach(rs => {\\n                    const tree = new TreeNode(i, ls, rs);\\n                    \\n                    result.push(tree);\\n                })\\n            })\\n        }\\n        \\n        return result;\\n    }\\n    \\n    return constructArray(1,n);\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar generateTrees = function(n) {\\n   \\n    \\n    const constructArray = (start, end) => {\\n        const result = [];\\n        \\n        if(start > end){\\n            return [null];\\n        }\\n        \\n        if(start===end){\\n            return [new TreeNode(start)];\\n        }\\n        \\n        if(end-start===1){\\n            const first = new TreeNode(start, null, new TreeNode(end));\\n            const second = new TreeNode(end, new TreeNode(start), null);\\n            return [first, second];\\n        }\\n        \\n        for(let i=start; i<=end; i++){\\n            const leftSide = constructArray(start, i-1);\\n            const rightSide = constructArray(i+1, end);\\n            \\n            leftSide.forEach(ls => {\\n                rightSide.forEach(rs => {\\n                    const tree = new TreeNode(i, ls, rs);\\n                    \\n                    result.push(tree);\\n                })\\n            })\\n        }\\n        \\n        return result;\\n    }\\n    \\n    return constructArray(1,n);\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1037235,
                "title": "scala-one-liner",
                "content": "Using separate recursive function\\n```scala\\ndef generateTrees(n: Int): List[TreeNode] = gen(0, n + 1).toList\\ndef gen(l: Int, r: Int): Seq[TreeNode]    =\\n  if (l == r) Seq(null) else for (m <- l until r; tl <- gen(l, m); tr <- gen(m + 1, r)) yield new TreeNode(m, tl, tr)\\n```\\nCan be done as one-liner using cumbersome default argument\\n```scala\\ndef generateTrees(r: Int, l : Int = 1): List[TreeNode] =\\n  if (l > r) List(null) else for (m <- (l to r).toList; tl <- generateTrees(m - 1, l); tr <- generateTrees(r, m + 1)) yield new TreeNode(m, tl, tr)\\n``` \\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```scala\\ndef generateTrees(n: Int): List[TreeNode] = gen(0, n + 1).toList\\ndef gen(l: Int, r: Int): Seq[TreeNode]    =\\n  if (l == r) Seq(null) else for (m <- l until r; tl <- gen(l, m); tr <- gen(m + 1, r)) yield new TreeNode(m, tl, tr)\\n```\n```scala\\ndef generateTrees(r: Int, l : Int = 1): List[TreeNode] =\\n  if (l > r) List(null) else for (m <- (l to r).toList; tl <- generateTrees(m - 1, l); tr <- generateTrees(r, m + 1)) yield new TreeNode(m, tl, tr)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1027430,
                "title": "javascript-simple-dp-memoization",
                "content": "```javascript\\nvar generateTrees = function(n) {\\n    const memo = new Map();\\n    \\n    function buildTree(arr) {\\n        if(!arr.length) return [null];\\n        if(memo.has(arr.join())) return memo.get(arr.join());\\n        const result = [];\\n        \\n        for(let i = 0; i < arr.length; i++) {\\n            const left = buildTree(arr.slice(0, i));\\n            const right = buildTree(arr.slice(i+1));\\n            \\n            for(let curLeft of left) {\\n                for(let curRight of right) {\\n                    const tree = new TreeNode(arr[i]);\\n                    tree.left = curLeft;\\n                    tree.right = curRight;\\n                    result.push(tree);\\n                }\\n            }\\n        }\\n        memo.set(arr.join(), result);\\n        return result;\\n    }\\n    return buildTree([...Array(n)].map((_, i) => i+1));\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```javascript\\nvar generateTrees = function(n) {\\n    const memo = new Map();\\n    \\n    function buildTree(arr) {\\n        if(!arr.length) return [null];\\n        if(memo.has(arr.join())) return memo.get(arr.join());\\n        const result = [];\\n        \\n        for(let i = 0; i < arr.length; i++) {\\n            const left = buildTree(arr.slice(0, i));\\n            const right = buildTree(arr.slice(i+1));\\n            \\n            for(let curLeft of left) {\\n                for(let curRight of right) {\\n                    const tree = new TreeNode(arr[i]);\\n                    tree.left = curLeft;\\n                    tree.right = curRight;\\n                    result.push(tree);\\n                }\\n            }\\n        }\\n        memo.set(arr.join(), result);\\n        return result;\\n    }\\n    return buildTree([...Array(n)].map((_, i) => i+1));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 945834,
                "title": "python-recursive",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        if n < 1: return []\\n        \\n        nums = list(range(1,n+1))\\n        return self.helper(nums)\\n            \\n            \\n    def helper(self, nums):\\n        if not nums:\\n            return [None]\\n        res = []\\n        for i in range(len(nums)):\\n            l = self.helper(nums[:i])\\n            r = self.helper(nums[i+1:])\\n            for ltree in l:\\n                for rtree in r:\\n                    root = TreeNode(nums[i])\\n                    root.left = ltree\\n                    root.right = rtree\\n                    res.append(root)\\n        return res \\n                \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        if n < 1: return []\\n        \\n        nums = list(range(1,n+1))\\n        return self.helper(nums)\\n            \\n            \\n    def helper(self, nums):\\n        if not nums:\\n            return [None]\\n        res = []\\n        for i in range(len(nums)):\\n            l = self.helper(nums[:i])\\n            r = self.helper(nums[i+1:])\\n            for ltree in l:\\n                for rtree in r:\\n                    root = TreeNode(nums[i])\\n                    root.left = ltree\\n                    root.right = rtree\\n                    res.append(root)\\n        return res \\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 810002,
                "title": "for-my-reference-have-a-look",
                "content": "Guys this is for my reference.\\nIf there is any mistake in the comments please do tell. It will me beneficial for everybody \\nThanks and be safe !\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        \\n        if n == 0:\\n            return []\\n        \\n        def helper(start,end):  # my helper function \\n            \\n            if start > end:  # when we reach at the leaf node\\n                return [None]\\n            \\n            res = []                    # for each tree \\n            \\n            for i in range(start,end+1):\\n                \\n                left = helper(start,i-1)  # creating list for left side of the root node\\n                right = helper(i+1,end)   # creating list for right side of the root node\\n                \\n                for l in left:            # iterating over left nodes of the root node\\n                    for r in right:        # iterating over right nodes of the root node            \\n                        node = TreeNode(i)  # creating a node \\n                        node.left = l       # constructing left side\\n                        node.right = r      # constructing right side\\n                        res.append(node)  \\n            print(res)\\n            return res\\n        \\n        return helper(1,n)\\n                        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        \\n        if n == 0:\\n            return []\\n        \\n        def helper(start,end):  # my helper function \\n            \\n            if start > end:  # when we reach at the leaf node\\n                return [None]\\n            \\n            res = []                    # for each tree \\n            \\n            for i in range(start,end+1):\\n                \\n                left = helper(start,i-1)  # creating list for left side of the root node\\n                right = helper(i+1,end)   # creating list for right side of the root node\\n                \\n                for l in left:            # iterating over left nodes of the root node\\n                    for r in right:        # iterating over right nodes of the root node            \\n                        node = TreeNode(i)  # creating a node \\n                        node.left = l       # constructing left side\\n                        node.right = r      # constructing right side\\n                        res.append(node)  \\n            print(res)\\n            return res\\n        \\n        return helper(1,n)\\n                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 789874,
                "title": "python-recursive-solution-with-explanations",
                "content": "```\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        # Edge case:\\n        if n == 0:\\n            return []\\n\\t\\t\\t\\n        # helping recursive function which recieves a range (within n) and returns all subtrees in that range:\\n        def rec(start, end):\\n\\t\\t\\n            # not supposed to happen:\\n            if start > end:\\n                return [None]\\n\\t\\t\\t\\t\\n            # got to a leaf:\\n            if start == end:\\n                return [TreeNode(start)]\\n            ret_list = []\\n\\t\\t\\t\\n            # for each option of root, get all possible subtrees and add to result each pair possible of left and right:\\n            for i in range(start, end+1):\\n                left = rec(start, i-1)\\n                right = rec(i+1, end)\\n                for pair in product(left, right):\\n                    ret_list.append(TreeNode(i, pair[0], pair[1]))\\n        \\n            return ret_list\\n        res = rec(1,n)\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        # Edge case:\\n        if n == 0:\\n            return []\\n\\t\\t\\t\\n        # helping recursive function which recieves a range (within n) and returns all subtrees in that range:\\n        def rec(start, end):\\n\\t\\t\\n            # not supposed to happen:\\n            if start > end:\\n                return [None]\\n\\t\\t\\t\\t\\n            # got to a leaf:\\n            if start == end:\\n                return [TreeNode(start)]\\n            ret_list = []\\n\\t\\t\\t\\n            # for each option of root, get all possible subtrees and add to result each pair possible of left and right:\\n            for i in range(start, end+1):\\n                left = rec(start, i-1)\\n                right = rec(i+1, end)\\n                for pair in product(left, right):\\n                    ret_list.append(TreeNode(i, pair[0], pair[1]))\\n        \\n            return ret_list\\n        res = rec(1,n)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 460045,
                "title": "c-nice-recursion",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<TreeNode*> gen(int l, int r) {\\n        if (l > r) return {nullptr};\\n        if (l == r) return {new TreeNode(l)};\\n        vector<TreeNode*> ans;\\n        for (int i = l; i <= r; ++i) {\\n            vector<TreeNode*> leftL = gen(l, i-1);\\n            vector<TreeNode*> rightL = gen(i+1, r);\\n            for (auto &left: leftL) {\\n                for (auto &right: rightL) {\\n                    TreeNode *head = new TreeNode(i);\\n                    head->left = left;\\n                    head->right = right;\\n                    ans.push_back(head);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        if (n < 1) return {};\\n        return gen(1,n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<TreeNode*> gen(int l, int r) {\\n        if (l > r) return {nullptr};\\n        if (l == r) return {new TreeNode(l)};\\n        vector<TreeNode*> ans;\\n        for (int i = l; i <= r; ++i) {\\n            vector<TreeNode*> leftL = gen(l, i-1);\\n            vector<TreeNode*> rightL = gen(i+1, r);\\n            for (auto &left: leftL) {\\n                for (auto &right: rightL) {\\n                    TreeNode *head = new TreeNode(i);\\n                    head->left = left;\\n                    head->right = right;\\n                    ans.push_back(head);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        if (n < 1) return {};\\n        return gen(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 166620,
                "title": "java-dp-store-both-left-and-right-part",
                "content": "For example: n = 5, so dp[3] is all unique BST with {{1,2,3}, {2,3,4}, {3,4,5}} \\nThe reason to store {2,3,4}, {3,4,5} is we need to use it as right subtree in generate dp[4], dp[5]\\nSo, in generating dp[4], we can let 1/2/3/4 be the root, and the left subtree and right subtree could be retrieved from dp.\\n```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        if(n == 0) return new ArrayList<TreeNode>();\\n        List<List<TreeNode>>[] dp = new List[n + 1];\\n        dp[0] = new ArrayList<List<TreeNode>>();\\n        for(int j = 1; j <= n + 1; j++){\\n            List<TreeNode> temp = new ArrayList<>();\\n            temp.add(null);\\n            dp[0].add(temp);\\n        }        \\n        dp[1] = new ArrayList<List<TreeNode>>();\\n        for(int j = 1; j <= n; j++){\\n            List<TreeNode> temp = new ArrayList<>();\\n            TreeNode tempNode = new TreeNode(j);\\n            temp.add(tempNode);\\n            dp[1].add(temp);\\n        }        \\n        for(int i = 2; i < dp.length; i++){\\n            dp[i] = new ArrayList<List<TreeNode>>();\\n            generateTreesHelper(dp, i, n);\\n        }\\n        return dp[n].get(0);\\n    }\\n    \\n    public void generateTreesHelper(List<List<TreeNode>>[] dp, int n, int total){\\n        for(int i = 1; i <= total - n + 1; i++){ // for example, n = 4. we need to generate 1234, 2345, 3456\\n            List<TreeNode> l = new ArrayList<>();\\n            for(int j = i; j < n + i; j++){\\n                List<TreeNode> left = dp[j - i].get(i - 1);\\n                List<TreeNode> right = dp[n + i - j - 1].get(j);\\n                for(TreeNode leftNode : left){\\n                    for(TreeNode rightNode : right){\\n                        TreeNode root = new TreeNode(j);\\n                        root.left = leftNode;\\n                        root.right = rightNode;\\n                        l.add(root);\\n                    }\\n                }   \\n            }\\n            dp[n].add(l);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        if(n == 0) return new ArrayList<TreeNode>();\\n        List<List<TreeNode>>[] dp = new List[n + 1];\\n        dp[0] = new ArrayList<List<TreeNode>>();\\n        for(int j = 1; j <= n + 1; j++){\\n            List<TreeNode> temp = new ArrayList<>();\\n            temp.add(null);\\n            dp[0].add(temp);\\n        }        \\n        dp[1] = new ArrayList<List<TreeNode>>();\\n        for(int j = 1; j <= n; j++){\\n            List<TreeNode> temp = new ArrayList<>();\\n            TreeNode tempNode = new TreeNode(j);\\n            temp.add(tempNode);\\n            dp[1].add(temp);\\n        }        \\n        for(int i = 2; i < dp.length; i++){\\n            dp[i] = new ArrayList<List<TreeNode>>();\\n            generateTreesHelper(dp, i, n);\\n        }\\n        return dp[n].get(0);\\n    }\\n    \\n    public void generateTreesHelper(List<List<TreeNode>>[] dp, int n, int total){\\n        for(int i = 1; i <= total - n + 1; i++){ // for example, n = 4. we need to generate 1234, 2345, 3456\\n            List<TreeNode> l = new ArrayList<>();\\n            for(int j = i; j < n + i; j++){\\n                List<TreeNode> left = dp[j - i].get(i - 1);\\n                List<TreeNode> right = dp[n + i - j - 1].get(j);\\n                for(TreeNode leftNode : left){\\n                    for(TreeNode rightNode : right){\\n                        TreeNode root = new TreeNode(j);\\n                        root.left = leftNode;\\n                        root.right = rightNode;\\n                        l.add(root);\\n                    }\\n                }   \\n            }\\n            dp[n].add(l);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161471,
                "title": "a-java-dp-solution-explained",
                "content": "This is a classic DP problem. To get a sense of the thought process that would help you arrive at that conclusion, read on:\\nThe key to this problem is the fundamental structural property of BSTs that all the nodes to the left of the root are smaller than it, and all on the right are greater, the property being true recursively.\\nTherefore, if the root if the integer *i*, then the keys on the left must include all the natural numbers upto *i-1*, and those on the right must contain the integers from *i* to the integer *n*. \\nBut if you look closely, the keys on the right are only a version of the set {0,1,\\u2026.,k}, for some k, wherein each value is incremented by a certain constant. So, getting the BSTs for the right and the left part of the root will have pretty much the same approach. And if you have the BSTs for the left and the right part, then it takes only some *assembling* to get the BST with the key *i* as the root. Well, you have just solved the problem by breaking it down into it\\u2019s **optimal sub-structures**. \\nSo now you make a new function which takes two integers as input, i.e., the beginning and the end, to give all the possible BSTs with the keys in the desired range, and then change the key in the root, to start the process over again. At this point, it becomes nigh-on impossible to miss the fact that you will be repeating some computations that you have done in earlier iterations, for eg:![image](https://s3-lc-upload.s3.amazonaws.com/users/vaibhav98iitd/image_1532463279.png)\\n\\n\\nTherefore, you do see the **overlapping sub-problems**. So to optimize the process, all you need is some sort of a dump where you store the values as you compute them.\\n\\nSo once you have a vague idea of how the problem is structured, it is easy to solve it. You iterate over the numbers {0,1,..........,n} and in each iteration the integer *i* is put into the root, so create a node ***newroot*** and set the value as *i*. Naturally, the numbers *0* to *i-1* would go into the left sub-tree and *i+1* to *n* go to the right. Now, get all the possible BSTs for these two subtrees recursively and put then in All_left_BST and All_right_BST respectively. Then, for every pair  (**left**, **right**), where **left** belongs to All_left_BST and **right** belongs to All_right_BST, set the left child of ***newroot*** as **left** and the right child as **right**, and put them into the result  collection. Now, go over to the next iteration. Note that since for want to do this for all pairs of (**left**,**right**), the loop would run **|All_left_BST|x|All_right_BST|** times. Of course, you can run it in a nested *for* loop where the first one runs over all the trees in All_left_BST and the nested one over all in All_right_BST.\\nYou can find the code attached below.\\nHope it helped.\\n```/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    List[][] dump;\\n    public List<TreeNode> generateTrees(int n) {\\n        List[][] temp=new List[n][n];\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                temp[i][j]=null;\\n            }\\n        }\\n        dump=temp;\\n        return getAns(1,n); }\\n    public List<TreeNode> getAns(int beg, int end)\\n    {\\n        if(beg>end)\\n        {\\n            return new ArrayList<TreeNode>();\\n        }\\n        if(dump[beg-1][end-1]!=null)\\n            return dump[beg-1][end-1];\\n        List<TreeNode> res=new ArrayList<TreeNode>();\\n        if(beg==end)\\n        {            \\n            res.add(new TreeNode(beg));\\n            dump[beg-1][end-1]=res;\\n            return res;\\n        }\\n        for(int i=beg;i<=end;i++)\\n        {\\n            if(i==beg)\\n            {\\n                List<TreeNode> right=getAns(beg+1,end);\\n                for (TreeNode rnode: right)\\n                {\\n                    TreeNode root=new TreeNode(i);\\n                    root.left=null;\\n                    root.right=rnode;\\n                    res.add(root);\\n                }\\n                \\n            }\\n            else if(i==end)\\n            {\\n               // System.out.println(\"sd\");\\n                List<TreeNode> left=getAns(beg,end-1);\\n                for(TreeNode lnode:left)\\n                {\\n                    TreeNode root=new TreeNode(i);\\n                    root.left=lnode;\\n                   // root.right=null;\\n                    res.add(root);\\n                }\\n                \\n            }\\n            else{\\n            List<TreeNode> left=getAns(beg,i-1);\\n            List<TreeNode> right=getAns(i+1,end);\\n            for(TreeNode lnode: left)\\n            {\\n                for(TreeNode rnode:right)\\n                {\\n                    TreeNode root=new TreeNode(i);\\n                    root.left=lnode;\\n                    root.right=rnode;\\n                    res.add(root);\\n                }\\n            }\\n            }\\n            \\n            \\n        }\\n        dump[beg-1][end-1]=res;\\n        return res;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    List[][] dump;\\n    public List<TreeNode> generateTrees(int n) {\\n        List[][] temp=new List[n][n];\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                temp[i][j]=null;\\n            }\\n        }\\n        dump=temp;\\n        return getAns(1,n); }\\n    public List<TreeNode> getAns(int beg, int end)\\n    {\\n        if(beg>end)\\n        {\\n            return new ArrayList<TreeNode>();\\n        }\\n        if(dump[beg-1][end-1]!=null)\\n            return dump[beg-1][end-1];\\n        List<TreeNode> res=new ArrayList<TreeNode>();\\n        if(beg==end)\\n        {            \\n            res.add(new TreeNode(beg));\\n            dump[beg-1][end-1]=res;\\n            return res;\\n        }\\n        for(int i=beg;i<=end;i++)\\n        {\\n            if(i==beg)\\n            {\\n                List<TreeNode> right=getAns(beg+1,end);\\n                for (TreeNode rnode: right)\\n                {\\n                    TreeNode root=new TreeNode(i);\\n                    root.left=null;\\n                    root.right=rnode;\\n                    res.add(root);\\n                }\\n                \\n            }\\n            else if(i==end)\\n            {\\n               // System.out.println(\"sd\");\\n                List<TreeNode> left=getAns(beg,end-1);\\n                for(TreeNode lnode:left)\\n                {\\n                    TreeNode root=new TreeNode(i);\\n                    root.left=lnode;\\n                   // root.right=null;\\n                    res.add(root);\\n                }\\n                \\n            }\\n            else{\\n            List<TreeNode> left=getAns(beg,i-1);\\n            List<TreeNode> right=getAns(i+1,end);\\n            for(TreeNode lnode: left)\\n            {\\n                for(TreeNode rnode:right)\\n                {\\n                    TreeNode root=new TreeNode(i);\\n                    root.left=lnode;\\n                    root.right=rnode;\\n                    res.add(root);\\n                }\\n            }\\n            }\\n            \\n            \\n        }\\n        dump[beg-1][end-1]=res;\\n        return res;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 157293,
                "title": "my-python-ac-dfs-solution",
                "content": "```\\nclass Solution:\\n    def generateTrees(self, n):\\n        def dfs(l, r):\\n            if r < l: return [None]\\n            arr = []\\n            for m in range(l, r + 1):\\n                left = dfs(l, m - 1)\\n                right = dfs(m + 1, r)\\n                for lNode in left:\\n                    for rNode in right:\\n                        new = TreeNode(m)\\n                        new.left = lNode\\n                        new.right = rNode\\n                        arr.append(new)\\n            return arr\\n        res = dfs(1, n)\\n        return [] if res == [None] else res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def generateTrees(self, n):\\n        def dfs(l, r):\\n            if r < l: return [None]\\n            arr = []\\n            for m in range(l, r + 1):\\n                left = dfs(l, m - 1)\\n                right = dfs(m + 1, r)\\n                for lNode in left:\\n                    for rNode in right:\\n                        new = TreeNode(m)\\n                        new.left = lNode\\n                        new.right = rNode\\n                        arr.append(new)\\n            return arr\\n        res = dfs(1, n)\\n        return [] if res == [None] else res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31572,
                "title": "share-my-11-lines-python-code",
                "content": "    def helper(self, n, start):\\n        ret = []\\n        for i in range(start, n + start):\\n            l = self.helper(i - start, start)\\n            r = self.helper(n + start - i - 1, i + 1)\\n            for x in (l if len(l) else [None]):\\n                for y in (r if len(r) else [None]):\\n                    root = TreeNode(i)\\n                    root.left, root.right = x, y\\n                    ret.append(root)\\n        return ret\\n    def generateTrees(self, n):\\n        return self.helper(n, 1)\\n\\nPretty standard top-down recursive approach. \"start\" is the starting number for tree node labeling.",
                "solutionTags": [],
                "code": "    def helper(self, n, start):\\n        ret = []\\n        for i in range(start, n + start):\\n            l = self.helper(i - start, start)\\n            r = self.helper(n + start - i - 1, i + 1)\\n            for x in (l if len(l) else [None]):\\n                for y in (r if len(r) else [None]):\\n                    root = TreeNode(i)\\n                    root.left, root.right = x, y\\n                    ret.append(root)\\n        return ret\\n    def generateTrees(self, n):\\n        return self.helper(n, 1)\\n\\nPretty standard top-down recursive approach. \"start\" is the starting number for tree node labeling.",
                "codeTag": "Python3"
            },
            {
                "id": 31557,
                "title": "clean-and-efficient-accepted-best-in-c",
                "content": "    struct TreeNode* push(struct TreeNode*** arr, int* returnSize, int a)\\n    {\\n        struct TreeNode *t = NULL;\\n        if(a > -1) //only valid value can be allocated;\\n        {\\n            t = (struct TreeNode*)malloc(sizeof(struct TreeNode));\\n            t->left = t->right = NULL;\\n            t->val = a;\\n        }\\n        *returnSize += 1;\\n        *arr = (struct TreeNode**)realloc(*arr, sizeof(struct TreeNode*)*(*returnSize));\\n        (*arr)[*returnSize-1] = t;\\n        return t; //return this node for -> root;\\n    }\\n    struct TreeNode* generate(int begin, int end, int* returnSize)\\n    {\\n        struct TreeNode** arr = (struct TreeNode**)malloc(sizeof(struct TreeNode*));\\n        if(begin >= end)\\n        {\\n            if(begin > end) \\n                push(&arr, returnSize, -1);\\n            if(begin == end)\\n                push(&arr, returnSize, begin);\\n            return arr;\\n        }\\n        for(int i = begin; i <= end; i++) //try to set each value as root;\\n        {\\n            int count0=0, count1=0;\\n            struct TreeNode **arr0 = generate(begin, i-1, &count0);\\n            struct TreeNode **arr1 = generate(i+1, end, &count1);\\n            for(int j = 0; j < count0; j++) //try to use different node as left and right child;\\n                for(int k = 0; k < count1; k++)\\n                {\\n                    struct TreeNode* t = push(&arr, returnSize, i);\\n                    t->left = arr0[j];\\n                    t->right = arr1[k];\\n                }\\n        }\\n        return arr;\\n    }\\n    \\n    //AC - 8ms;\\n    struct TreeNode** generateTrees(int n, int* returnSize)\\n    {\\n        *returnSize = 0;\\n        if(!n) return NULL;\\n        return generate(1, n, returnSize);\\n    }",
                "solutionTags": [],
                "code": "    struct TreeNode* push(struct TreeNode*** arr, int* returnSize, int a)\\n    {\\n        struct TreeNode *t = NULL;\\n        if(a > -1) //only valid value can be allocated;\\n        {\\n            t = (struct TreeNode*)malloc(sizeof(struct TreeNode));\\n            t->left = t->right = NULL;\\n            t->val = a;\\n        }\\n        *returnSize += 1;\\n        *arr = (struct TreeNode**)realloc(*arr, sizeof(struct TreeNode*)*(*returnSize));\\n        (*arr)[*returnSize-1] = t;\\n        return t; //return this node for -> root;\\n    }\\n    struct TreeNode* generate(int begin, int end, int* returnSize)\\n    {\\n        struct TreeNode** arr = (struct TreeNode**)malloc(sizeof(struct TreeNode*));\\n        if(begin >= end)\\n        {\\n            if(begin > end) \\n                push(&arr, returnSize, -1);\\n            if(begin == end)\\n                push(&arr, returnSize, begin);\\n            return arr;\\n        }\\n        for(int i = begin; i <= end; i++) //try to set each value as root;\\n        {\\n            int count0=0, count1=0;\\n            struct TreeNode **arr0 = generate(begin, i-1, &count0);\\n            struct TreeNode **arr1 = generate(i+1, end, &count1);\\n            for(int j = 0; j < count0; j++) //try to use different node as left and right child;\\n                for(int k = 0; k < count1; k++)\\n                {\\n                    struct TreeNode* t = push(&arr, returnSize, i);\\n                    t->left = arr0[j];\\n                    t->right = arr1[k];\\n                }\\n        }\\n        return arr;\\n    }\\n    \\n    //AC - 8ms;\\n    struct TreeNode** generateTrees(int n, int* returnSize)\\n    {\\n        *returnSize = 0;\\n        if(!n) return NULL;\\n        return generate(1, n, returnSize);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31594,
                "title": "10-line-concise-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<TreeNode*> get(int a, int b) {\\n            vector<TreeNode*> ans;\\n            if (a>b) {\\n                ans.push_back(NULL);\\n            } else {\\n                for (int i=a; i<=b; i++)\\n                    for (auto l : get(a, i-1)) \\n                        for (auto r : get(i+1, b))\\n                        {\\n                            ans.push_back(new TreeNode(i));\\n                            ans.back()->left=l, ans.back()->right=r;\\n                        }\\n            }\\n            return ans;\\n        }\\n        \\n        vector<TreeNode*> generateTrees(int n) {\\n            return get(1, n);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<TreeNode*> get(int a, int b) {\\n            vector<TreeNode*> ans;\\n            if (a>b) {\\n                ans.push_back(NULL);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 31612,
                "title": "dp-solution-using-1-tabulation-20ms-and-2-memoization-24ms",
                "content": "Tabulation:\\n\\n    class Solution {\\n        \\n        using Trees = vector<TreeNode*>;\\n        \\n    public:\\n        vector<TreeNode*> generateTrees(int n) {\\n            if (n == 0)\\n            {\\n                return vector<TreeNode*>({NULL});\\n            }\\n            \\n            // the dp table: [i][j] -> all unique BSTs with nodes from i..j inclusive\\n            vector<vector<Trees>> dp(n + 1,\\n                                     vector<vector<TreeNode*>>(n + 1, Trees()));\\n                                     \\n            // initialize the dp table: [i][i] -> a single root node with value i, for all i in [1,n] inclusive\\n            for (int i = 1; i <= n; ++i)\\n            {\\n                dp[i][i].push_back(new TreeNode(i));\\n            }\\n            \\n            // the progressively build the table (bottom-up tabulation)\\n            for (int k = 1; k < n; ++k)\\n            {\\n                for (int i = 1; i <= n - k; ++i)\\n                {\\n                    int j = i + k;\\n                    Trees &unique_trees = dp[i][j]; assert (unique_trees.empty());  // this is what we're building right now\\n                    for (int root = i; root <= j; ++root)\\n                    {\\n                        int end_left = root - 1;\\n                        int start_right = root + 1;\\n                        Trees all_left;\\n                        if (end_left < i)\\n                        {\\n                            all_left.push_back(NULL);\\n                        }\\n                        else\\n                        {\\n                            all_left = dp[i][end_left];\\n                        }\\n                        Trees all_right;\\n                        if (j < start_right)\\n                        {\\n                            all_right.push_back(NULL);\\n                        }\\n                        else\\n                        {\\n                            all_right = dp[start_right][j];\\n                        }\\n                        for (TreeNode *left : all_left)\\n                        {\\n                            for (TreeNode *right : all_right)\\n                            {\\n                                TreeNode *root_node = new TreeNode(root);\\n                                root_node->left = left;\\n                                root_node->right = right;\\n                                unique_trees.push_back(root_node);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            return dp[1][n];\\n        }\\n    };\\n\\n\\nMemoization:\\n\\n    class Solution {\\n    private:\\n    \\n        using cache = map<pair<int, int>, vector<TreeNode*>>;   // {i,j} -> all unique BSTs with nodes from i..j inclusive\\n        \\n        vector<TreeNode*> generate_trees_dp(int start, int end, cache &dp)\\n        {\\n            vector<TreeNode*> result;\\n            \\n            if (end < start)\\n            {\\n                result.push_back(NULL);\\n                return result;\\n            }\\n            \\n            auto it = dp.find({start, end});\\n            if (it != dp.end())\\n            {\\n                return it->second;\\n            }\\n            \\n            for (int i = start; i <= end; ++i)\\n            {\\n                vector<TreeNode*> all_left = generate_trees_dp(start, i - 1, dp);\\n                vector<TreeNode*> all_right = generate_trees_dp(i + 1, end, dp);\\n                for (TreeNode *left_tree : all_left)\\n                {\\n                    for (TreeNode *right_tree : all_right)\\n                    {\\n                        TreeNode *root = new TreeNode(i);\\n                        root->left = left_tree;\\n                        root->right = right_tree;\\n                        result.push_back(root);\\n                    }\\n                }\\n            }\\n            \\n            dp[{start, end}] = result;\\n            return result;\\n        }\\n        \\n    public:\\n        vector<TreeNode*> generateTrees(int n) {\\n            cache dp;\\n            // initialize the dp cache: {i,i} -> a single root node with value i, for all i in [1,n] inclusive\\n            for (int i = 1; i <= n; ++i)\\n            {\\n                dp[{i,i}] = { new TreeNode(i), };\\n            }\\n            \\n            return generate_trees_dp(1, n, dp);\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n        \\n        using Trees = vector<TreeNode*>;\\n        \\n    public:\\n        vector<TreeNode*> generateTrees(int n) {\\n            if (n == 0)\\n            {\\n                return vector<TreeNode*>({NULL}",
                "codeTag": "Java"
            },
            {
                "id": 31637,
                "title": "recursive-java-solution-make-use-of-binary-search-characteristic",
                "content": "Given a consecutive sequence, eg. [2,3,4,5].\\n\\nThe way to generate every possible binary search tree for this sequence is take each number as root node and then assign both child.\\n\\nThus, [2,3,4,5] will be computed as,\\n\\nFirst take 2 as root node, then left child will be null, right child will be sequence [3,4,5].\\n\\nSecond take 3 as root node, then left child will be [2], right child will be sequence [4,5].\\n\\nThird take 4 as root node, then left child will be [2,3], right child will be [5].\\n\\n...\\n\\n    public List<TreeNode> generateTrees(int n) {\\n            return generateTree(1,n+1);\\n        }\\n        \\n        private List<TreeNode> generateTree(int min, int max){\\n            List<TreeNode> list = new ArrayList<TreeNode>();\\n            // base case\\n            if(min >= max){\\n                TreeNode node = null;\\n                list.add(node);\\n            }\\n            // general case\\n            for(int i = min;i < max;i++){\\n                List<TreeNode> left = generateTree(min,i);\\n                List<TreeNode> right = generateTree(i+1,max);\\n                for(int p = 0;p < left.size();p++){\\n                    for(int q = 0;q < right.size();q++){\\n                        TreeNode root = new TreeNode(i);\\n                        root.left = left.get(p);\\n                        root.right = right.get(q);\\n                        list.add(root);\\n                    }\\n                }\\n            }\\n            return list;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Given a consecutive sequence, eg. [2,3,4,5].\\n\\nThe way to generate every possible binary search tree for this sequence is take each number as root node and then assign both child.\\n\\nThus, [2,3,4,5] will be computed as,\\n\\nFirst take 2 as root node, then left child will be null, right child will be sequence [3,4,5].\\n\\nSecond take 3 as root node, then left child will be [2], right child will be sequence [4,5].\\n\\nThird take 4 as root node, then left child will be [2,3], right child will be [5].\\n\\n...\\n\\n    public List<TreeNode> generateTrees(int n) {\\n            return generateTree(1,n+1);\\n        }\\n        \\n        private List<TreeNode> generateTree(int min, int max){\\n            List<TreeNode> list = new ArrayList<TreeNode>();\\n            // base case\\n            if(min >= max){\\n                TreeNode node = null;\\n                list.add(node);\\n            }\\n            // general case\\n            for(int i = min;i < max;i++){\\n                List<TreeNode> left = generateTree(min,i);\\n                List<TreeNode> right = generateTree(i+1,max);\\n                for(int p = 0;p < left.size();p++){\\n                    for(int q = 0;q < right.size();q++){\\n                        TreeNode root = new TreeNode(i);\\n                        root.left = left.get(p);\\n                        root.right = right.get(q);\\n                        list.add(root);\\n                    }\\n                }\\n            }\\n            return list;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 31642,
                "title": "my-c-solution",
                "content": "    class Solution {\\n    private:\\n        vector<TreeNode *> getTrees(int n, int offset) {\\n            vector<TreeNode *> ans;\\n            if(n == 0) {\\n                ans.push_back(nullptr);\\n                return ans;\\n            }\\n            int i, j, k;\\n            for(i=1; i<=n; i++) {\\n                vector<TreeNode *> left = getTrees(i-1, offset);\\n                vector<TreeNode *> right = getTrees(n-i, i+offset);\\n                for(j=0; j<left.size(); j++) {\\n                    for(k=0; k<right.size(); k++) {\\n                        TreeNode *root = new TreeNode(i+offset);\\n                        root->left = left[j];\\n                        root->right = right[k];\\n                        ans.push_back(root);\\n                    }\\n                }\\n            }\\n            return ans;\\n        }\\n    public:\\n        vector<TreeNode *> generateTrees(int n) {\\n            return getTrees(n, 0);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    private:\\n        vector<TreeNode *> getTrees(int n, int offset) {\\n            vector<TreeNode *> ans;\\n            if(n == 0) {\\n                ans.push_back(nullptr);\\n                return ans;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 31655,
                "title": "my-answer-with-c-28-lines",
                "content": "    /**\\n     * Definition for binary tree\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n    \\tint *f;\\n    \\tTreeNode* generateTree(int rank, int base, int n) {\\n    \\t\\tif (n == 0) return NULL;\\n    \\t\\tif (n == 1) return new TreeNode(base);\\n    \\t\\tfor (int i = 0; i < n; ++i) {\\n    \\t\\t\\trank -= f[i] * f[n - 1 - i];\\n    \\t\\t\\tif (rank < 0) {\\n    \\t\\t\\t\\tTreeNode* root = new TreeNode(base + i);\\n    \\t\\t\\t\\trank += f[i] * f[n - 1 - i];\\n    \\t\\t\\t\\troot->left = generateTree(rank % f[i], base, i);\\n    \\t\\t\\t\\troot->right = generateTree(rank / f[i], base + i + 1, n - 1 - i);\\n    \\t\\t\\t\\treturn root;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n        vector<TreeNode *> generateTrees(int n) {\\n            f = new int[n + 1];\\n    \\t\\tf[0] = f[1] = 1;\\n    \\t\\tfor (int i = 2; i <= n; ++i) {\\n    \\t\\t\\tf[i] = 0;\\n    \\t\\t\\tfor (int j = 0; j < i; ++j) f[i] += f[j] * f[i - 1 - j];\\n    \\t\\t}\\n    \\t\\tvector<TreeNode *> result;\\n    \\t\\tfor (int i = 0; i < f[n]; ++i) result.push_back(generateTree(i, 1, n));\\n    \\t\\treturn result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tint *f;\\n    \\tTreeNode* generateTree(int rank, int base, int n) {\\n    \\t\\tif (n == 0) return NULL;\\n    \\t\\tif (n == 1) return new TreeNode(base);\\n    \\t\\tfor (int i = 0; i < n; ++i) {\\n    \\t\\t\\trank -= f[i] * f[n - 1 - i];\\n    \\t\\t\\tif (rank < 0) {\\n    \\t\\t\\t\\tTreeNode* root = new TreeNode(base + i);\\n    \\t\\t\\t\\trank += f[i] * f[n - 1 - i];\\n    \\t\\t\\t\\troot->left = generateTree(rank % f[i], base, i);\\n    \\t\\t\\t\\troot->right = generateTree(rank / f[i], base + i + 1, n - 1 - i);\\n    \\t\\t\\t\\treturn root;\\n    \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3868393,
                "title": "easy-code-with-explanation",
                "content": "Note this code is combination of leetcode problem permutaion and creating bst and preorder traversal.... so if you have done that then do it.\\n# Code\\n```\\n\\n\\n//n points in a line has n! ways to arrange it thus for n=3 there are 6 ways but in answer only 5 are drawn why? since there are 2 fig which are symmetrical thus they are just written once...so how to check that it is unique or not? store it in set and then check.\\n\\n\\nclass Solution {\\npublic:\\nvector<TreeNode*>ans;\\nset<vector<int>>st;\\nvector<int>preo;\\n\\n// preorder\\nvoid traverse(TreeNode*root)\\n{\\n   if(root==NULL)\\n    return;\\n    preo.push_back(root->val);\\n    traverse(root->left);\\n    traverse(root->right);  \\n}\\nbool check(TreeNode*ptr)\\n{\\n  // return true if it is unique\\n   vector<int>preorder;\\n   preo=preorder;//reset the preo since it is global\\n   traverse(ptr);\\n   for(int i=0;i<preo.size();i++)\\n   cout<<preo[i]<<\" \";\\n   cout<<endl;\\n   if(st.find(preo)==st.end())\\n   {\\n     st.insert(preo);\\n   return true;\\n   }\\n   return false;\\n}\\n\\n//creating bst\\n\\nTreeNode*bst(TreeNode*root,int key)\\n{\\n    if(root==NULL)\\n    {\\n      TreeNode*temp=new TreeNode(key);\\n     temp->left=NULL;\\n     temp->right=NULL;\\n     return temp;\\n    }\\n\\n  if(key>root->val)\\n    root->right=bst(root->right,key);\\n  else\\n    root->left=bst(root->left,key);\\n\\n  return root;\\n}\\n\\nvoid create_bst(vector<int>&nums)\\n{\\nTreeNode*root=new TreeNode(nums[0]);//make root\\nroot->left=NULL;\\nroot->right=NULL;\\n\\n  for(int i=1;i<nums.size();i++)\\n   root=bst(root,nums[i]);//get always updated root\\n\\n   if(check(root))\\n    ans.push_back(root);\\n}\\n\\n//make all possible combination..permutation\\nvoid func(vector<int>&nums,int index)\\n{\\n  if(index==nums.size())\\n  {\\n      create_bst(nums);\\n      return;\\n  }\\n  for(int i=index;i<nums.size();i++)\\n  {\\n      swap(nums[index],nums[i]);\\n      func(nums,index+1);\\n      swap(nums[index],nums[i]);\\n  }\\n}\\n    vector<TreeNode*> generateTrees(int n) {\\n        vector<int>nums;\\n        for(int i=1;i<=n;i++)\\n         nums.push_back(i);\\n         func(nums,0);\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n\\n//n points in a line has n! ways to arrange it thus for n=3 there are 6 ways but in answer only 5 are drawn why? since there are 2 fig which are symmetrical thus they are just written once...so how to check that it is unique or not? store it in set and then check.\\n\\n\\nclass Solution {\\npublic:\\nvector<TreeNode*>ans;\\nset<vector<int>>st;\\nvector<int>preo;\\n\\n// preorder\\nvoid traverse(TreeNode*root)\\n{\\n   if(root==NULL)\\n    return;\\n    preo.push_back(root->val);\\n    traverse(root->left);\\n    traverse(root->right);  \\n}\\nbool check(TreeNode*ptr)\\n{\\n  // return true if it is unique\\n   vector<int>preorder;\\n   preo=preorder;//reset the preo since it is global\\n   traverse(ptr);\\n   for(int i=0;i<preo.size();i++)\\n   cout<<preo[i]<<\" \";\\n   cout<<endl;\\n   if(st.find(preo)==st.end())\\n   {\\n     st.insert(preo);\\n   return true;\\n   }\\n   return false;\\n}\\n\\n//creating bst\\n\\nTreeNode*bst(TreeNode*root,int key)\\n{\\n    if(root==NULL)\\n    {\\n      TreeNode*temp=new TreeNode(key);\\n     temp->left=NULL;\\n     temp->right=NULL;\\n     return temp;\\n    }\\n\\n  if(key>root->val)\\n    root->right=bst(root->right,key);\\n  else\\n    root->left=bst(root->left,key);\\n\\n  return root;\\n}\\n\\nvoid create_bst(vector<int>&nums)\\n{\\nTreeNode*root=new TreeNode(nums[0]);//make root\\nroot->left=NULL;\\nroot->right=NULL;\\n\\n  for(int i=1;i<nums.size();i++)\\n   root=bst(root,nums[i]);//get always updated root\\n\\n   if(check(root))\\n    ans.push_back(root);\\n}\\n\\n//make all possible combination..permutation\\nvoid func(vector<int>&nums,int index)\\n{\\n  if(index==nums.size())\\n  {\\n      create_bst(nums);\\n      return;\\n  }\\n  for(int i=index;i<nums.size();i++)\\n  {\\n      swap(nums[index],nums[i]);\\n      func(nums,index+1);\\n      swap(nums[index],nums[i]);\\n  }\\n}\\n    vector<TreeNode*> generateTrees(int n) {\\n        vector<int>nums;\\n        for(int i=1;i<=n;i++)\\n         nums.push_back(i);\\n         func(nums,0);\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3866084,
                "title": "one-liner-java-8-streams",
                "content": "\\n\\n# UPVOTE PLS \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\u2B06\\uFE0F\\u2B06\\uFE0F\\n```java []\\npublic List<TreeNode> generateTrees(int n) {\\n   return generateTrees(1, n).toList();\\n }\\nprivate Stream<TreeNode> generateTrees(int min, int max) {\\n  return  (min > max) ? Stream.of((TreeNode) null) : IntStream.rangeClosed(min, max).boxed().flatMap(i -> generateTrees(min, i - 1).flatMap(left -> generateTrees(i + 1, max).map(right ->new TreeNode(i, left, right))));\\n }\\n```\\n\\n# CLEAN & READABLE WAY\\n\\n```JAVA []\\npublic List<TreeNode> generateTrees(int n) {\\n       return generateTrees(1, n).toList();\\n }\\nprivate Stream<TreeNode> generateTrees(int min, int max) {\\n       return  (min > max) ? Stream.of((TreeNode) null) : \\n       IntStream.rangeClosed(min, max).boxed()\\n       .flatMap(i -> generateTrees(min, i - 1)\\n       .flatMap(left -> generateTrees(i + 1, max)\\n       .map(right ->   new TreeNode(i, left, right))));\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\npublic List<TreeNode> generateTrees(int n) {\\n   return generateTrees(1, n).toList();\\n }\\nprivate Stream<TreeNode> generateTrees(int min, int max) {\\n  return  (min > max) ? Stream.of((TreeNode) null) : IntStream.rangeClosed(min, max).boxed().flatMap(i -> generateTrees(min, i - 1).flatMap(left -> generateTrees(i + 1, max).map(right ->new TreeNode(i, left, right))));\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3865915,
                "title": "video-solution-java-c",
                "content": "# Intuition, approach, and complexity dicussed in detail in video solution.\\n\\nhttps://youtu.be/9A4J6fSO1Ws\\n\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        return buildBST(1, n);\\n    }\\n    private:\\n     vector<TreeNode*> buildBST(int start, int end){\\n        vector<TreeNode*> li;\\n        if(start > end){\\n            li.push_back(NULL);\\n            return li;\\n        }\\n        if(start == end){\\n            li.push_back(new TreeNode(start));\\n            return li;\\n        }\\n        for(int indx = start; indx<=end; indx++){\\n         vector<TreeNode*> leftNodeList = buildBST(start, indx-1);\\n         vector<TreeNode*> rightNodeList = buildBST(indx+1, end);\\n            for(TreeNode* leftSide : leftNodeList){\\n                for(TreeNode* rightSide : rightNodeList){\\n                    TreeNode* root = new TreeNode(indx);\\n                    root->left = leftSide;\\n                    root->right = rightSide;\\n                    li.push_back(root);\\n                }\\n            }\\n        }\\n        return li;\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n\\n        return buildBST(1, n);\\n    }\\n    public List<TreeNode> buildBST(int start, int end){\\n\\n        List<TreeNode> li = new ArrayList<>();\\n\\n        if(start > end){\\n            li.add(null);\\n            return li;\\n        }\\n        if(start == end){\\n            li.add(new TreeNode(start));\\n            return li;\\n        }\\n\\n        for(int indx = start; indx<=end; indx++){\\n         List<TreeNode> leftNodeList = buildBST(start, indx-1);\\n         List<TreeNode> rightNodeList = buildBST(indx+1, end);\\n            for(TreeNode rightSide : rightNodeList){\\n                for(TreeNode leftSide : leftNodeList){\\n                    TreeNode root = new TreeNode(indx);\\n                    root.left = leftSide;\\n                    root.right = rightSide;\\n                    li.add(root);\\n                }\\n            }\\n        }\\n        return li;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        return buildBST(1, n);\\n    }\\n    private:\\n     vector<TreeNode*> buildBST(int start, int end){\\n        vector<TreeNode*> li;\\n        if(start > end){\\n            li.push_back(NULL);\\n            return li;\\n        }\\n        if(start == end){\\n            li.push_back(new TreeNode(start));\\n            return li;\\n        }\\n        for(int indx = start; indx<=end; indx++){\\n         vector<TreeNode*> leftNodeList = buildBST(start, indx-1);\\n         vector<TreeNode*> rightNodeList = buildBST(indx+1, end);\\n            for(TreeNode* leftSide : leftNodeList){\\n                for(TreeNode* rightSide : rightNodeList){\\n                    TreeNode* root = new TreeNode(indx);\\n                    root->left = leftSide;\\n                    root->right = rightSide;\\n                    li.push_back(root);\\n                }\\n            }\\n        }\\n        return li;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n\\n        return buildBST(1, n);\\n    }\\n    public List<TreeNode> buildBST(int start, int end){\\n\\n        List<TreeNode> li = new ArrayList<>();\\n\\n        if(start > end){\\n            li.add(null);\\n            return li;\\n        }\\n        if(start == end){\\n            li.add(new TreeNode(start));\\n            return li;\\n        }\\n\\n        for(int indx = start; indx<=end; indx++){\\n         List<TreeNode> leftNodeList = buildBST(start, indx-1);\\n         List<TreeNode> rightNodeList = buildBST(indx+1, end);\\n            for(TreeNode rightSide : rightNodeList){\\n                for(TreeNode leftSide : leftNodeList){\\n                    TreeNode root = new TreeNode(indx);\\n                    root.left = leftSide;\\n                    root.right = rightSide;\\n                    li.add(root);\\n                }\\n            }\\n        }\\n        return li;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865419,
                "title": "recursion-easy-solution-using-left-and-right-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBy using start and end variables to generate all the trees.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNow let\\'s look how our helper function will work!\\n\\n1. As there will be trees with root as 1, 2, 3...n. Iterate through all values from start to end to construct tree rooted at i and construct its left and right subtree recursively.\\n2. We know that in Binary Search Tree all nodes in left subtree are smaller than root and in right subtree are larger than root. So for start = 1 and end = n, if we have ith number as root, all numbers from 1 to i-1 will be in left subtree and i+1 to n will be in right subtree.\\nTherefore, we will build the tree recursively for left and right subtrees rooted at i as leftSubTree = bst(start, i-1) and rightSubtree = bst(i + 1, end)\\nSo, till what moment we will recursively find the left and right subtrees?? Answer is until start < end!!\\nSo when start > end, add NULL to the list and return\\nThis will be our base case!\\n3. Now, we have leftSubtree and rightSubtree for node with root i. The last thing we need to do is connect leftSubTree and rightSubTree with root and add this tree(rooted at i) to the ans list!\\n\\uD83D\\uDCCC Here, we can have multiple left and right subtrees. So we need to loop through all left and right subtrees and connect every left subTree to right subTree and to current root(i) one by one.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n-> catalan Number(O(4^n/n^1.5)) * O(n) for generating the trees\\n-> O(4^n/n^0.5).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n-> recursion stack space.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generate(int i, int j) {\\n        vector<TreeNode*> res;\\n        if(i > j) {\\n            res.push_back(NULL);\\n            return res;\\n        }\\n        for(int ind = i;ind <= j;ind++) {\\n            vector<TreeNode*> left = generate(i, ind-1);\\n            vector<TreeNode*> right = generate(ind+1, j);\\n            for(auto l: left) {\\n                for(auto r: right) {\\n                    TreeNode* root = new TreeNode(ind, l, r);\\n                    res.push_back(root);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        return generate(1, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generate(int i, int j) {\\n        vector<TreeNode*> res;\\n        if(i > j) {\\n            res.push_back(NULL);\\n            return res;\\n        }\\n        for(int ind = i;ind <= j;ind++) {\\n            vector<TreeNode*> left = generate(i, ind-1);\\n            vector<TreeNode*> right = generate(ind+1, j);\\n            for(auto l: left) {\\n                for(auto r: right) {\\n                    TreeNode* root = new TreeNode(ind, l, r);\\n                    res.push_back(root);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        return generate(1, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865343,
                "title": "c-solution-for-unique-binary-search-trees-ii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to generate all possible structurally unique binary search trees using a recursive approach. For each node in the tree, we consider it as the root and generate all possible left and right subtrees for it. The result will be a combination of these subtrees, forming all the structurally unique BSTs with n nodes and unique values from 1 to n.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach involves a recursive function that takes the range of values (from start to end) and generates all the structurally unique BSTs within that range. It iterates through each possible root value in the range and generates all possible left and right subtrees. The base case is when start > end, in which case we return a list with a single element (null), representing an empty subtree.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is difficult to determine exactly due to the recursive nature. However, we can estimate it as follows: Let T(n) be the total number of unique BSTs generated for n nodes. For each node, we have to generate all possible left and right subtrees, and the total number of combinations will be the product of the number of left subtrees and the number of right subtrees. For i nodes in the left subtree and n-i-1 nodes in the right subtree (since i is the root), the number of combinations will be T(i) * T(n-i-1).\\n\\nSo, the overall time complexity can be approximated as T(n) = Sum(T(i) * T(n-i-1)) for i ranging from 0 to n-1. Calculating this sum is challenging, and it leads to the well-known Catalan Number, which grows at an exponential rate. The exact time complexity will be on the order of O(Catalan(n)), which is upper-bounded by O(4^n / (n^(3/2))). For the given constraints (n <= 8), this is a reasonable runtime.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is determined by the number of unique BSTs generated and stored in the result list. The maximum number of unique BSTs for n nodes will be equal to the n-th Catalan number, which is O(4^n / (n^(3/2))). Therefore, the space complexity is O(4^n / (n^(3/2))). Additionally, the recursive function will use space on the call stack, but since the maximum recursion depth is limited by n, the space complexity on the call stack is O(n).\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public IList<TreeNode> GenerateTrees(int n) {\\n        if (n == 0) return new List<TreeNode>(); // Edge case: no nodes, return an empty list\\n        return GenerateTrees(1, n);\\n    }\\n    private IList<TreeNode> GenerateTrees(int start, int end) {\\n        IList<TreeNode> result = new List<TreeNode>();\\n        \\n        if (start > end) {\\n            result.Add(null);\\n            return result;\\n        }\\n        \\n        for (int i = start; i <= end; i++) {\\n            IList<TreeNode> leftSubtrees = GenerateTrees(start, i - 1);\\n            IList<TreeNode> rightSubtrees = GenerateTrees(i + 1, end);\\n            \\n            foreach (var leftSubtree in leftSubtrees) {\\n                foreach (var rightSubtree in rightSubtrees) {\\n                    TreeNode root = new TreeNode(i);\\n                    root.left = leftSubtree;\\n                    root.right = rightSubtree;\\n                    result.Add(root);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public IList<TreeNode> GenerateTrees(int n) {\\n        if (n == 0) return new List<TreeNode>(); // Edge case: no nodes, return an empty list\\n        return GenerateTrees(1, n);\\n    }\\n    private IList<TreeNode> GenerateTrees(int start, int end) {\\n        IList<TreeNode> result = new List<TreeNode>();\\n        \\n        if (start > end) {\\n            result.Add(null);\\n            return result;\\n        }\\n        \\n        for (int i = start; i <= end; i++) {\\n            IList<TreeNode> leftSubtrees = GenerateTrees(start, i - 1);\\n            IList<TreeNode> rightSubtrees = GenerateTrees(i + 1, end);\\n            \\n            foreach (var leftSubtree in leftSubtrees) {\\n                foreach (var rightSubtree in rightSubtrees) {\\n                    TreeNode root = new TreeNode(i);\\n                    root.left = leftSubtree;\\n                    root.right = rightSubtree;\\n                    result.Add(root);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865261,
                "title": "python3-solution",
                "content": "\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:\\n        @lru_cache\\n        def dfs(start,end):\\n            if start>end:\\n                return [None]\\n\\n            ans=[]\\n            for i in range(start,end+1):\\n                left=dfs(start,i-1)\\n                right=dfs(i+1,end)\\n                for l in left:\\n                    for r in right:\\n                        root=TreeNode(i)\\n                        root.left=l\\n                        root.right=r\\n                        ans.append(root)\\n            return ans\\n\\n        return dfs(1,n)                    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:\\n        @lru_cache\\n        def dfs(start,end):\\n            if start>end:\\n                return [None]\\n\\n            ans=[]\\n            for i in range(start,end+1):\\n                left=dfs(start,i-1)\\n                right=dfs(i+1,end)\\n                for l in left:\\n                    for r in right:\\n                        root=TreeNode(i)\\n                        root.left=l\\n                        root.right=r\\n                        ans.append(root)\\n            return ans\\n\\n        return dfs(1,n)                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865256,
                "title": "kotlin-backtrack-bitmask-hash",
                "content": "![image.png](https://assets.leetcode.com/users/images/80b9e58a-96ec-4d58-b8e7-08e9915a8772_1691208464.22039.png)\\n\\n#### Join me on Telegram\\n\\nhttps://t.me/leetcode_daily_unstoppable/299\\n\\n#### Problem TLDR\\n\\nAll possible Binary Search Trees for 1..n numbers\\n\\n#### Intuition\\n\\nOne way to build all possible BST is to insert numbers in all possible ways. We can do this with a simple backtracking, given the small `n <= 8`. To remove duplicates, we can print the tree and use it as a hash key.\\n\\n#### Approach\\n\\n* use a bit mask and a Stack for backtracking\\n\\n#### Complexity\\n- Time complexity:\\n\\n$$O(n!* nlog(n))$$, as the recursion depth is n, each time iterations go as n * (n - 1) * (n - 2) * ... * 2 * 1, which is equal to n!. The final step of inserting elements is nlog(n), and building a hash is n, which is < nlogn, so not relevant.\\n\\n- Space complexity:\\n\\n$$O(n!)$$, is a number of permutations\\n\\n#### Code\\n\\n```kotlin\\n\\n\\n    fun insert(x: Int, t: TreeNode?): TreeNode = t?.apply {\\n        if (x > `val`) right = insert(x, right)\\n        else left = insert(x, left)\\n      } ?: TreeNode(x)\\n    fun print(t: TreeNode): String = \\n      \"[${t.`val`} ${t.left?.let { print(it) }} ${t.right?.let { print(it) }}]\"\\n    fun generateTrees(n: Int): List<TreeNode?> {\\n      val stack = Stack<Int>()\\n      val lists = mutableListOf<TreeNode>()\\n      fun dfs(m: Int): Unit = if (m == 0) \\n          lists += TreeNode(stack[0]).apply { for (i in 1 until n) insert(stack[i], this) }\\n        else for (i in 0 until n) if (m and (1 shl i) != 0) {\\n          stack.push(i + 1)\\n          dfs(m xor (1 shl i))\\n          stack.pop()\\n        }\\n      dfs((1 shl n) - 1)\\n      return lists.distinctBy { print(it) }\\n    }\\n\\n```\\nAnother divide-and-conquer solution, that I didn\\'t think of\\n![image.png](https://assets.leetcode.com/users/images/470b3a9f-5e0b-432b-a1fc-33a966ab2d36_1691213657.5075893.png)\\n\\n",
                "solutionTags": [
                    "Kotlin",
                    "Backtracking",
                    "Depth-First Search",
                    "Bitmask"
                ],
                "code": "```kotlin\\n\\n\\n    fun insert(x: Int, t: TreeNode?): TreeNode = t?.apply {\\n        if (x > `val`) right = insert(x, right)\\n        else left = insert(x, left)\\n      } ?: TreeNode(x)\\n    fun print(t: TreeNode): String = \\n      \"[${t.`val`} ${t.left?.let { print(it) }} ${t.right?.let { print(it) }}]\"\\n    fun generateTrees(n: Int): List<TreeNode?> {\\n      val stack = Stack<Int>()\\n      val lists = mutableListOf<TreeNode>()\\n      fun dfs(m: Int): Unit = if (m == 0) \\n          lists += TreeNode(stack[0]).apply { for (i in 1 until n) insert(stack[i], this) }\\n        else for (i in 0 until n) if (m and (1 shl i) != 0) {\\n          stack.push(i + 1)\\n          dfs(m xor (1 shl i))\\n          stack.pop()\\n        }\\n      dfs((1 shl n) - 1)\\n      return lists.distinctBy { print(it) }\\n    }\\n\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1735731,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 1849998,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 1751837,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 1574175,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 1965487,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 2000434,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 1571208,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 1567854,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 1567191,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 2000901,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 1735731,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 1849998,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 1751837,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 1574175,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 1965487,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 2000434,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 1571208,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 1567854,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 1567191,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 2000901,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 1567855,
                "content": [
                    {
                        "username": "MitchellHe",
                        "content": "What does [{}] mean? An ArrayList<TreeNode> of length one containing one null value?\\n-------------------------------------------------------------------------------------------------------------\\nWrong Answer:\\n\\nInput: \\t0\\nOutput: \\t[]\\nExpected: \\t[{}]\\n\\nThanks in advance."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is how you represent empty array of array\nor vector<vector<datatype>> (in c++)\nbut here ,  it means that you have a tree with root as null pointer"
                    },
                    {
                        "username": "user6141Q",
                        "content": "Can someone please explain a little more about the question? For example:\\n1. In which order the first example is given?\\n2. Why [1, 2, 3] isn\\'t in the first example\\'s answer?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "2.\\nBecause, [1, 2, 3] IS a Binary Tree, but it IS NOT a Binary Search Tree"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is in level order traversal , that is why [1, 2 , 3] is not in the answer . \\n\\nif you make a binary search tree from [1,2,3]\\nyou will get ->\\n          1\\n        2    3 \\n\\nwhich is not a bst , as 2 > 1 it should be in the right subtree of 1 .\\nhope you got it .\\n  "
                    },
                    {
                        "username": "binhope",
                        "content": "Input:\\t2\\nOutput:\\t[{1,2},{1,#,2}]\\nExpected:\\t[{1,#,2},{2,1}]\\n.i'm confused with the expected.Is the answer is th unique?i think the struct of the tree is right,\\nbut the order is wrong. i want to ask what is the standard answer.thanks:)"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "your tree is wrong {1, 2} actually has 2 as the left child , which is wrong for a binary search tree , 2 > 1 so it should always be in the right subtree of 1 ."
                    },
                    {
                        "username": "makeittrue",
                        "content": "can't pass the judge, but give such output. I think this should be fine according to the problem?\\n\\nInput:\\t2\\nOutput:\\t[{2,#,1},{2,1}]\\nExpected:\\t[{1,#,2},{2,1}]"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "bro  [2, #, 1] is wrong as  1 < 2 it should come in the left subtree , but it is coming in the right subtree , ( see the output is displayed in level order traversal ) "
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is related to Catalan numbers and done few days ago! Resubmit"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "Definitely a hard problem lol. Much harder than previous backtracking mediums"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "It is only Day 5 and Leetcode has decided to laugh on my skill. \\uD83D\\uDC38"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you see the answer in the editorial, it makes a lot more sense. I concur with other people who had a hard time knowing how to approach this... The thought struck me of building all the smaller subtrees first, but I was having a hard time figuring out how to implement it. Editorial is helpful in understanding the solution."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Once you are done with this question, you might want to try the following one which is a variation but is based on the same algorithm.\n\n[894. All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/description/)\n\nIts a bit tricker as well."
                    },
                    {
                        "username": "vrajpatelll",
                        "content": "can i have some hints about solution of this question?"
                    }
                ]
            },
            {
                "id": 1570582,
                "content": [
                    {
                        "username": "MitchellHe",
                        "content": "What does [{}] mean? An ArrayList<TreeNode> of length one containing one null value?\\n-------------------------------------------------------------------------------------------------------------\\nWrong Answer:\\n\\nInput: \\t0\\nOutput: \\t[]\\nExpected: \\t[{}]\\n\\nThanks in advance."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is how you represent empty array of array\nor vector<vector<datatype>> (in c++)\nbut here ,  it means that you have a tree with root as null pointer"
                    },
                    {
                        "username": "user6141Q",
                        "content": "Can someone please explain a little more about the question? For example:\\n1. In which order the first example is given?\\n2. Why [1, 2, 3] isn\\'t in the first example\\'s answer?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "2.\\nBecause, [1, 2, 3] IS a Binary Tree, but it IS NOT a Binary Search Tree"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is in level order traversal , that is why [1, 2 , 3] is not in the answer . \\n\\nif you make a binary search tree from [1,2,3]\\nyou will get ->\\n          1\\n        2    3 \\n\\nwhich is not a bst , as 2 > 1 it should be in the right subtree of 1 .\\nhope you got it .\\n  "
                    },
                    {
                        "username": "binhope",
                        "content": "Input:\\t2\\nOutput:\\t[{1,2},{1,#,2}]\\nExpected:\\t[{1,#,2},{2,1}]\\n.i'm confused with the expected.Is the answer is th unique?i think the struct of the tree is right,\\nbut the order is wrong. i want to ask what is the standard answer.thanks:)"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "your tree is wrong {1, 2} actually has 2 as the left child , which is wrong for a binary search tree , 2 > 1 so it should always be in the right subtree of 1 ."
                    },
                    {
                        "username": "makeittrue",
                        "content": "can't pass the judge, but give such output. I think this should be fine according to the problem?\\n\\nInput:\\t2\\nOutput:\\t[{2,#,1},{2,1}]\\nExpected:\\t[{1,#,2},{2,1}]"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "bro  [2, #, 1] is wrong as  1 < 2 it should come in the left subtree , but it is coming in the right subtree , ( see the output is displayed in level order traversal ) "
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is related to Catalan numbers and done few days ago! Resubmit"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "Definitely a hard problem lol. Much harder than previous backtracking mediums"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "It is only Day 5 and Leetcode has decided to laugh on my skill. \\uD83D\\uDC38"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you see the answer in the editorial, it makes a lot more sense. I concur with other people who had a hard time knowing how to approach this... The thought struck me of building all the smaller subtrees first, but I was having a hard time figuring out how to implement it. Editorial is helpful in understanding the solution."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Once you are done with this question, you might want to try the following one which is a variation but is based on the same algorithm.\n\n[894. All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/description/)\n\nIts a bit tricker as well."
                    },
                    {
                        "username": "vrajpatelll",
                        "content": "can i have some hints about solution of this question?"
                    }
                ]
            },
            {
                "id": 1571209,
                "content": [
                    {
                        "username": "MitchellHe",
                        "content": "What does [{}] mean? An ArrayList<TreeNode> of length one containing one null value?\\n-------------------------------------------------------------------------------------------------------------\\nWrong Answer:\\n\\nInput: \\t0\\nOutput: \\t[]\\nExpected: \\t[{}]\\n\\nThanks in advance."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is how you represent empty array of array\nor vector<vector<datatype>> (in c++)\nbut here ,  it means that you have a tree with root as null pointer"
                    },
                    {
                        "username": "user6141Q",
                        "content": "Can someone please explain a little more about the question? For example:\\n1. In which order the first example is given?\\n2. Why [1, 2, 3] isn\\'t in the first example\\'s answer?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "2.\\nBecause, [1, 2, 3] IS a Binary Tree, but it IS NOT a Binary Search Tree"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is in level order traversal , that is why [1, 2 , 3] is not in the answer . \\n\\nif you make a binary search tree from [1,2,3]\\nyou will get ->\\n          1\\n        2    3 \\n\\nwhich is not a bst , as 2 > 1 it should be in the right subtree of 1 .\\nhope you got it .\\n  "
                    },
                    {
                        "username": "binhope",
                        "content": "Input:\\t2\\nOutput:\\t[{1,2},{1,#,2}]\\nExpected:\\t[{1,#,2},{2,1}]\\n.i'm confused with the expected.Is the answer is th unique?i think the struct of the tree is right,\\nbut the order is wrong. i want to ask what is the standard answer.thanks:)"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "your tree is wrong {1, 2} actually has 2 as the left child , which is wrong for a binary search tree , 2 > 1 so it should always be in the right subtree of 1 ."
                    },
                    {
                        "username": "makeittrue",
                        "content": "can't pass the judge, but give such output. I think this should be fine according to the problem?\\n\\nInput:\\t2\\nOutput:\\t[{2,#,1},{2,1}]\\nExpected:\\t[{1,#,2},{2,1}]"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "bro  [2, #, 1] is wrong as  1 < 2 it should come in the left subtree , but it is coming in the right subtree , ( see the output is displayed in level order traversal ) "
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is related to Catalan numbers and done few days ago! Resubmit"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "Definitely a hard problem lol. Much harder than previous backtracking mediums"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "It is only Day 5 and Leetcode has decided to laugh on my skill. \\uD83D\\uDC38"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you see the answer in the editorial, it makes a lot more sense. I concur with other people who had a hard time knowing how to approach this... The thought struck me of building all the smaller subtrees first, but I was having a hard time figuring out how to implement it. Editorial is helpful in understanding the solution."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Once you are done with this question, you might want to try the following one which is a variation but is based on the same algorithm.\n\n[894. All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/description/)\n\nIts a bit tricker as well."
                    },
                    {
                        "username": "vrajpatelll",
                        "content": "can i have some hints about solution of this question?"
                    }
                ]
            },
            {
                "id": 1571210,
                "content": [
                    {
                        "username": "MitchellHe",
                        "content": "What does [{}] mean? An ArrayList<TreeNode> of length one containing one null value?\\n-------------------------------------------------------------------------------------------------------------\\nWrong Answer:\\n\\nInput: \\t0\\nOutput: \\t[]\\nExpected: \\t[{}]\\n\\nThanks in advance."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is how you represent empty array of array\nor vector<vector<datatype>> (in c++)\nbut here ,  it means that you have a tree with root as null pointer"
                    },
                    {
                        "username": "user6141Q",
                        "content": "Can someone please explain a little more about the question? For example:\\n1. In which order the first example is given?\\n2. Why [1, 2, 3] isn\\'t in the first example\\'s answer?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "2.\\nBecause, [1, 2, 3] IS a Binary Tree, but it IS NOT a Binary Search Tree"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is in level order traversal , that is why [1, 2 , 3] is not in the answer . \\n\\nif you make a binary search tree from [1,2,3]\\nyou will get ->\\n          1\\n        2    3 \\n\\nwhich is not a bst , as 2 > 1 it should be in the right subtree of 1 .\\nhope you got it .\\n  "
                    },
                    {
                        "username": "binhope",
                        "content": "Input:\\t2\\nOutput:\\t[{1,2},{1,#,2}]\\nExpected:\\t[{1,#,2},{2,1}]\\n.i'm confused with the expected.Is the answer is th unique?i think the struct of the tree is right,\\nbut the order is wrong. i want to ask what is the standard answer.thanks:)"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "your tree is wrong {1, 2} actually has 2 as the left child , which is wrong for a binary search tree , 2 > 1 so it should always be in the right subtree of 1 ."
                    },
                    {
                        "username": "makeittrue",
                        "content": "can't pass the judge, but give such output. I think this should be fine according to the problem?\\n\\nInput:\\t2\\nOutput:\\t[{2,#,1},{2,1}]\\nExpected:\\t[{1,#,2},{2,1}]"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "bro  [2, #, 1] is wrong as  1 < 2 it should come in the left subtree , but it is coming in the right subtree , ( see the output is displayed in level order traversal ) "
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is related to Catalan numbers and done few days ago! Resubmit"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "Definitely a hard problem lol. Much harder than previous backtracking mediums"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "It is only Day 5 and Leetcode has decided to laugh on my skill. \\uD83D\\uDC38"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you see the answer in the editorial, it makes a lot more sense. I concur with other people who had a hard time knowing how to approach this... The thought struck me of building all the smaller subtrees first, but I was having a hard time figuring out how to implement it. Editorial is helpful in understanding the solution."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Once you are done with this question, you might want to try the following one which is a variation but is based on the same algorithm.\n\n[894. All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/description/)\n\nIts a bit tricker as well."
                    },
                    {
                        "username": "vrajpatelll",
                        "content": "can i have some hints about solution of this question?"
                    }
                ]
            },
            {
                "id": 2000375,
                "content": [
                    {
                        "username": "MitchellHe",
                        "content": "What does [{}] mean? An ArrayList<TreeNode> of length one containing one null value?\\n-------------------------------------------------------------------------------------------------------------\\nWrong Answer:\\n\\nInput: \\t0\\nOutput: \\t[]\\nExpected: \\t[{}]\\n\\nThanks in advance."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is how you represent empty array of array\nor vector<vector<datatype>> (in c++)\nbut here ,  it means that you have a tree with root as null pointer"
                    },
                    {
                        "username": "user6141Q",
                        "content": "Can someone please explain a little more about the question? For example:\\n1. In which order the first example is given?\\n2. Why [1, 2, 3] isn\\'t in the first example\\'s answer?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "2.\\nBecause, [1, 2, 3] IS a Binary Tree, but it IS NOT a Binary Search Tree"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is in level order traversal , that is why [1, 2 , 3] is not in the answer . \\n\\nif you make a binary search tree from [1,2,3]\\nyou will get ->\\n          1\\n        2    3 \\n\\nwhich is not a bst , as 2 > 1 it should be in the right subtree of 1 .\\nhope you got it .\\n  "
                    },
                    {
                        "username": "binhope",
                        "content": "Input:\\t2\\nOutput:\\t[{1,2},{1,#,2}]\\nExpected:\\t[{1,#,2},{2,1}]\\n.i'm confused with the expected.Is the answer is th unique?i think the struct of the tree is right,\\nbut the order is wrong. i want to ask what is the standard answer.thanks:)"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "your tree is wrong {1, 2} actually has 2 as the left child , which is wrong for a binary search tree , 2 > 1 so it should always be in the right subtree of 1 ."
                    },
                    {
                        "username": "makeittrue",
                        "content": "can't pass the judge, but give such output. I think this should be fine according to the problem?\\n\\nInput:\\t2\\nOutput:\\t[{2,#,1},{2,1}]\\nExpected:\\t[{1,#,2},{2,1}]"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "bro  [2, #, 1] is wrong as  1 < 2 it should come in the left subtree , but it is coming in the right subtree , ( see the output is displayed in level order traversal ) "
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is related to Catalan numbers and done few days ago! Resubmit"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "Definitely a hard problem lol. Much harder than previous backtracking mediums"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "It is only Day 5 and Leetcode has decided to laugh on my skill. \\uD83D\\uDC38"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you see the answer in the editorial, it makes a lot more sense. I concur with other people who had a hard time knowing how to approach this... The thought struck me of building all the smaller subtrees first, but I was having a hard time figuring out how to implement it. Editorial is helpful in understanding the solution."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Once you are done with this question, you might want to try the following one which is a variation but is based on the same algorithm.\n\n[894. All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/description/)\n\nIts a bit tricker as well."
                    },
                    {
                        "username": "vrajpatelll",
                        "content": "can i have some hints about solution of this question?"
                    }
                ]
            },
            {
                "id": 2001657,
                "content": [
                    {
                        "username": "MitchellHe",
                        "content": "What does [{}] mean? An ArrayList<TreeNode> of length one containing one null value?\\n-------------------------------------------------------------------------------------------------------------\\nWrong Answer:\\n\\nInput: \\t0\\nOutput: \\t[]\\nExpected: \\t[{}]\\n\\nThanks in advance."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is how you represent empty array of array\nor vector<vector<datatype>> (in c++)\nbut here ,  it means that you have a tree with root as null pointer"
                    },
                    {
                        "username": "user6141Q",
                        "content": "Can someone please explain a little more about the question? For example:\\n1. In which order the first example is given?\\n2. Why [1, 2, 3] isn\\'t in the first example\\'s answer?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "2.\\nBecause, [1, 2, 3] IS a Binary Tree, but it IS NOT a Binary Search Tree"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is in level order traversal , that is why [1, 2 , 3] is not in the answer . \\n\\nif you make a binary search tree from [1,2,3]\\nyou will get ->\\n          1\\n        2    3 \\n\\nwhich is not a bst , as 2 > 1 it should be in the right subtree of 1 .\\nhope you got it .\\n  "
                    },
                    {
                        "username": "binhope",
                        "content": "Input:\\t2\\nOutput:\\t[{1,2},{1,#,2}]\\nExpected:\\t[{1,#,2},{2,1}]\\n.i'm confused with the expected.Is the answer is th unique?i think the struct of the tree is right,\\nbut the order is wrong. i want to ask what is the standard answer.thanks:)"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "your tree is wrong {1, 2} actually has 2 as the left child , which is wrong for a binary search tree , 2 > 1 so it should always be in the right subtree of 1 ."
                    },
                    {
                        "username": "makeittrue",
                        "content": "can't pass the judge, but give such output. I think this should be fine according to the problem?\\n\\nInput:\\t2\\nOutput:\\t[{2,#,1},{2,1}]\\nExpected:\\t[{1,#,2},{2,1}]"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "bro  [2, #, 1] is wrong as  1 < 2 it should come in the left subtree , but it is coming in the right subtree , ( see the output is displayed in level order traversal ) "
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is related to Catalan numbers and done few days ago! Resubmit"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "Definitely a hard problem lol. Much harder than previous backtracking mediums"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "It is only Day 5 and Leetcode has decided to laugh on my skill. \\uD83D\\uDC38"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you see the answer in the editorial, it makes a lot more sense. I concur with other people who had a hard time knowing how to approach this... The thought struck me of building all the smaller subtrees first, but I was having a hard time figuring out how to implement it. Editorial is helpful in understanding the solution."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Once you are done with this question, you might want to try the following one which is a variation but is based on the same algorithm.\n\n[894. All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/description/)\n\nIts a bit tricker as well."
                    },
                    {
                        "username": "vrajpatelll",
                        "content": "can i have some hints about solution of this question?"
                    }
                ]
            },
            {
                "id": 2000446,
                "content": [
                    {
                        "username": "MitchellHe",
                        "content": "What does [{}] mean? An ArrayList<TreeNode> of length one containing one null value?\\n-------------------------------------------------------------------------------------------------------------\\nWrong Answer:\\n\\nInput: \\t0\\nOutput: \\t[]\\nExpected: \\t[{}]\\n\\nThanks in advance."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is how you represent empty array of array\nor vector<vector<datatype>> (in c++)\nbut here ,  it means that you have a tree with root as null pointer"
                    },
                    {
                        "username": "user6141Q",
                        "content": "Can someone please explain a little more about the question? For example:\\n1. In which order the first example is given?\\n2. Why [1, 2, 3] isn\\'t in the first example\\'s answer?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "2.\\nBecause, [1, 2, 3] IS a Binary Tree, but it IS NOT a Binary Search Tree"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is in level order traversal , that is why [1, 2 , 3] is not in the answer . \\n\\nif you make a binary search tree from [1,2,3]\\nyou will get ->\\n          1\\n        2    3 \\n\\nwhich is not a bst , as 2 > 1 it should be in the right subtree of 1 .\\nhope you got it .\\n  "
                    },
                    {
                        "username": "binhope",
                        "content": "Input:\\t2\\nOutput:\\t[{1,2},{1,#,2}]\\nExpected:\\t[{1,#,2},{2,1}]\\n.i'm confused with the expected.Is the answer is th unique?i think the struct of the tree is right,\\nbut the order is wrong. i want to ask what is the standard answer.thanks:)"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "your tree is wrong {1, 2} actually has 2 as the left child , which is wrong for a binary search tree , 2 > 1 so it should always be in the right subtree of 1 ."
                    },
                    {
                        "username": "makeittrue",
                        "content": "can't pass the judge, but give such output. I think this should be fine according to the problem?\\n\\nInput:\\t2\\nOutput:\\t[{2,#,1},{2,1}]\\nExpected:\\t[{1,#,2},{2,1}]"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "bro  [2, #, 1] is wrong as  1 < 2 it should come in the left subtree , but it is coming in the right subtree , ( see the output is displayed in level order traversal ) "
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is related to Catalan numbers and done few days ago! Resubmit"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "Definitely a hard problem lol. Much harder than previous backtracking mediums"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "It is only Day 5 and Leetcode has decided to laugh on my skill. \\uD83D\\uDC38"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you see the answer in the editorial, it makes a lot more sense. I concur with other people who had a hard time knowing how to approach this... The thought struck me of building all the smaller subtrees first, but I was having a hard time figuring out how to implement it. Editorial is helpful in understanding the solution."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Once you are done with this question, you might want to try the following one which is a variation but is based on the same algorithm.\n\n[894. All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/description/)\n\nIts a bit tricker as well."
                    },
                    {
                        "username": "vrajpatelll",
                        "content": "can i have some hints about solution of this question?"
                    }
                ]
            },
            {
                "id": 2000428,
                "content": [
                    {
                        "username": "MitchellHe",
                        "content": "What does [{}] mean? An ArrayList<TreeNode> of length one containing one null value?\\n-------------------------------------------------------------------------------------------------------------\\nWrong Answer:\\n\\nInput: \\t0\\nOutput: \\t[]\\nExpected: \\t[{}]\\n\\nThanks in advance."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is how you represent empty array of array\nor vector<vector<datatype>> (in c++)\nbut here ,  it means that you have a tree with root as null pointer"
                    },
                    {
                        "username": "user6141Q",
                        "content": "Can someone please explain a little more about the question? For example:\\n1. In which order the first example is given?\\n2. Why [1, 2, 3] isn\\'t in the first example\\'s answer?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "2.\\nBecause, [1, 2, 3] IS a Binary Tree, but it IS NOT a Binary Search Tree"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is in level order traversal , that is why [1, 2 , 3] is not in the answer . \\n\\nif you make a binary search tree from [1,2,3]\\nyou will get ->\\n          1\\n        2    3 \\n\\nwhich is not a bst , as 2 > 1 it should be in the right subtree of 1 .\\nhope you got it .\\n  "
                    },
                    {
                        "username": "binhope",
                        "content": "Input:\\t2\\nOutput:\\t[{1,2},{1,#,2}]\\nExpected:\\t[{1,#,2},{2,1}]\\n.i'm confused with the expected.Is the answer is th unique?i think the struct of the tree is right,\\nbut the order is wrong. i want to ask what is the standard answer.thanks:)"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "your tree is wrong {1, 2} actually has 2 as the left child , which is wrong for a binary search tree , 2 > 1 so it should always be in the right subtree of 1 ."
                    },
                    {
                        "username": "makeittrue",
                        "content": "can't pass the judge, but give such output. I think this should be fine according to the problem?\\n\\nInput:\\t2\\nOutput:\\t[{2,#,1},{2,1}]\\nExpected:\\t[{1,#,2},{2,1}]"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "bro  [2, #, 1] is wrong as  1 < 2 it should come in the left subtree , but it is coming in the right subtree , ( see the output is displayed in level order traversal ) "
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is related to Catalan numbers and done few days ago! Resubmit"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "Definitely a hard problem lol. Much harder than previous backtracking mediums"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "It is only Day 5 and Leetcode has decided to laugh on my skill. \\uD83D\\uDC38"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you see the answer in the editorial, it makes a lot more sense. I concur with other people who had a hard time knowing how to approach this... The thought struck me of building all the smaller subtrees first, but I was having a hard time figuring out how to implement it. Editorial is helpful in understanding the solution."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Once you are done with this question, you might want to try the following one which is a variation but is based on the same algorithm.\n\n[894. All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/description/)\n\nIts a bit tricker as well."
                    },
                    {
                        "username": "vrajpatelll",
                        "content": "can i have some hints about solution of this question?"
                    }
                ]
            },
            {
                "id": 1984547,
                "content": [
                    {
                        "username": "MitchellHe",
                        "content": "What does [{}] mean? An ArrayList<TreeNode> of length one containing one null value?\\n-------------------------------------------------------------------------------------------------------------\\nWrong Answer:\\n\\nInput: \\t0\\nOutput: \\t[]\\nExpected: \\t[{}]\\n\\nThanks in advance."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is how you represent empty array of array\nor vector<vector<datatype>> (in c++)\nbut here ,  it means that you have a tree with root as null pointer"
                    },
                    {
                        "username": "user6141Q",
                        "content": "Can someone please explain a little more about the question? For example:\\n1. In which order the first example is given?\\n2. Why [1, 2, 3] isn\\'t in the first example\\'s answer?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "2.\\nBecause, [1, 2, 3] IS a Binary Tree, but it IS NOT a Binary Search Tree"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is in level order traversal , that is why [1, 2 , 3] is not in the answer . \\n\\nif you make a binary search tree from [1,2,3]\\nyou will get ->\\n          1\\n        2    3 \\n\\nwhich is not a bst , as 2 > 1 it should be in the right subtree of 1 .\\nhope you got it .\\n  "
                    },
                    {
                        "username": "binhope",
                        "content": "Input:\\t2\\nOutput:\\t[{1,2},{1,#,2}]\\nExpected:\\t[{1,#,2},{2,1}]\\n.i'm confused with the expected.Is the answer is th unique?i think the struct of the tree is right,\\nbut the order is wrong. i want to ask what is the standard answer.thanks:)"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "your tree is wrong {1, 2} actually has 2 as the left child , which is wrong for a binary search tree , 2 > 1 so it should always be in the right subtree of 1 ."
                    },
                    {
                        "username": "makeittrue",
                        "content": "can't pass the judge, but give such output. I think this should be fine according to the problem?\\n\\nInput:\\t2\\nOutput:\\t[{2,#,1},{2,1}]\\nExpected:\\t[{1,#,2},{2,1}]"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "bro  [2, #, 1] is wrong as  1 < 2 it should come in the left subtree , but it is coming in the right subtree , ( see the output is displayed in level order traversal ) "
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is related to Catalan numbers and done few days ago! Resubmit"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "Definitely a hard problem lol. Much harder than previous backtracking mediums"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "It is only Day 5 and Leetcode has decided to laugh on my skill. \\uD83D\\uDC38"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you see the answer in the editorial, it makes a lot more sense. I concur with other people who had a hard time knowing how to approach this... The thought struck me of building all the smaller subtrees first, but I was having a hard time figuring out how to implement it. Editorial is helpful in understanding the solution."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Once you are done with this question, you might want to try the following one which is a variation but is based on the same algorithm.\n\n[894. All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/description/)\n\nIts a bit tricker as well."
                    },
                    {
                        "username": "vrajpatelll",
                        "content": "can i have some hints about solution of this question?"
                    }
                ]
            },
            {
                "id": 2069142,
                "content": [
                    {
                        "username": "MitchellHe",
                        "content": "What does [{}] mean? An ArrayList<TreeNode> of length one containing one null value?\\n-------------------------------------------------------------------------------------------------------------\\nWrong Answer:\\n\\nInput: \\t0\\nOutput: \\t[]\\nExpected: \\t[{}]\\n\\nThanks in advance."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is how you represent empty array of array\nor vector<vector<datatype>> (in c++)\nbut here ,  it means that you have a tree with root as null pointer"
                    },
                    {
                        "username": "user6141Q",
                        "content": "Can someone please explain a little more about the question? For example:\\n1. In which order the first example is given?\\n2. Why [1, 2, 3] isn\\'t in the first example\\'s answer?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "2.\\nBecause, [1, 2, 3] IS a Binary Tree, but it IS NOT a Binary Search Tree"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is in level order traversal , that is why [1, 2 , 3] is not in the answer . \\n\\nif you make a binary search tree from [1,2,3]\\nyou will get ->\\n          1\\n        2    3 \\n\\nwhich is not a bst , as 2 > 1 it should be in the right subtree of 1 .\\nhope you got it .\\n  "
                    },
                    {
                        "username": "binhope",
                        "content": "Input:\\t2\\nOutput:\\t[{1,2},{1,#,2}]\\nExpected:\\t[{1,#,2},{2,1}]\\n.i'm confused with the expected.Is the answer is th unique?i think the struct of the tree is right,\\nbut the order is wrong. i want to ask what is the standard answer.thanks:)"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "your tree is wrong {1, 2} actually has 2 as the left child , which is wrong for a binary search tree , 2 > 1 so it should always be in the right subtree of 1 ."
                    },
                    {
                        "username": "makeittrue",
                        "content": "can't pass the judge, but give such output. I think this should be fine according to the problem?\\n\\nInput:\\t2\\nOutput:\\t[{2,#,1},{2,1}]\\nExpected:\\t[{1,#,2},{2,1}]"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "bro  [2, #, 1] is wrong as  1 < 2 it should come in the left subtree , but it is coming in the right subtree , ( see the output is displayed in level order traversal ) "
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is related to Catalan numbers and done few days ago! Resubmit"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "Definitely a hard problem lol. Much harder than previous backtracking mediums"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "It is only Day 5 and Leetcode has decided to laugh on my skill. \\uD83D\\uDC38"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you see the answer in the editorial, it makes a lot more sense. I concur with other people who had a hard time knowing how to approach this... The thought struck me of building all the smaller subtrees first, but I was having a hard time figuring out how to implement it. Editorial is helpful in understanding the solution."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Once you are done with this question, you might want to try the following one which is a variation but is based on the same algorithm.\n\n[894. All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/description/)\n\nIts a bit tricker as well."
                    },
                    {
                        "username": "vrajpatelll",
                        "content": "can i have some hints about solution of this question?"
                    }
                ]
            },
            {
                "id": 2066399,
                "content": [
                    {
                        "username": "puppyslife",
                        "content": "Can someone please help me understand the time complexity for solution 1"
                    },
                    {
                        "username": "SeineAle",
                        "content": "IDK, But where was DP in that ?\\n"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "A naive approach might be (brute force) - for each number from `1` to `n` define values ​​that should be in the left and right subtrees. Do this recursively for each number in the left and right arrays. This recursive function must return the value of the currently processed node and all combinations between the resulting left and right subtrees. I hope this helps someone get closer to the answer or find their own better solution."
                    },
                    {
                        "username": "obbl",
                        "content": "I think that answer  for n = 3\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[2,1,null,null,3]`,[3,2,null,1]]\nis true as well, however it is suggested that the only true answer is\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[3,1,null,null,2]`,[3,2,null,1]]\nwell, they are structurally the same and I don't get why one is true while the other isn't.\nDid I miss something or tests are not covering my solution? If I am wrong, please point where\n"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Does anyone know the time complexity for the brute force solution?"
                    },
                    {
                        "username": "unters",
                        "content": "According to my very rough calculation, time complexity for worst brute force solution is `O( ( (2 ^ n)! * n! * (2 ^ n * n) ) / (2 ^ n - n)! )`.\n\nAs far as I understand, brute force consists of going through all possible arrays, that might or might not represent a valid BST.\n\nAs far as a BST with `n` nodes can not have height greater than `n`, an array representation of such BST can not contain more then `2 ^ n` elements.\n\nThere are `(2 ^ n)! / (2 ^ n - n)!` ways to choose `n` elements in an array of size `2 ^ n`.\n\nFor each choice of `n` elements there are n! ways to assign nodes with distinct values from `1` through `n` to these chosen elements (array is initially filled with `null`s).\n\nBuilding a BST using one array representation takes `O(2 ^ n * n)` time (`2 ^ n` elements in an array; inserting an element takes `O(log(2 ^ n))` time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "To my surprise, pure brute force worked!"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "Man, It fells so good to solve this on my own!! \\uD83E\\uDD70"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Some tips for this problem: Dont worry too much about runtime. So long as you write code somewhat efficiently, using an inefficient algorithm will be fine with this problem as in the input sizes are tiny. (I just mean, dont do foolish things like using .get() on a linked list rather than iterating through it, in that case use an array or an array list, etc). \\n\\nNotice that the left tree must always contain all values less than the head, and the right tree must always contain all values greater than the head. This makes for a really simple recursive solution. It is exponential time, but with a maximum input size of 8, its fine! \\n\\nA tip to make things even easier, just make the argument of your recursive function a list of all the nodes it needs to use. It should anyways output a list of all trees using those nodes. (This isn\\'t necessary at all, but it makes the logic easier atleast for me). "
                    },
                    {
                        "username": "breathermachine",
                        "content": "I didn't even pass in a list to my recursive function, only two int parameters: min and max. The recursive function then generates all trees using all the values from min to max:\n\nhttps://leetcode.com/problems/unique-binary-search-trees-ii/submissions/1013076716/"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/) \n\nThis question is a lot similar but I don't know why it has 82% acceptance rate I couldn't solve it.😢"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "how \n1\n    \\\\\\\\\\\\\n       3\n    /\n2\n\nis a BST? 2 is coming right side to 1. How is it a BST? Anyone please explain."
                    },
                    {
                        "username": "kush_sach",
                        "content": "If you write down the In-order traversal for this tree, as per the recursive rule \"(left subtree) root (right subtree)\", it shall be: 1,2,3. Perfectly correct.\\n\\nRemember that a subtree itself is a tree. So, first you choose 1 as a root, for which the right child is 3. Your order is:    1, <order of right subtree with root as 3>\\nTo fill in the order for the subtree that has 3 as its root, you must treat it as a tree in itself as well. Therefore, evidently, 1, < <left subtree with root as 2> , 3 >\\nWhich is simply: 1, 2, 3\\n\\nWhat I\\'ve said is merely a rephrased version of the other two replies. The in-order traversal is basically the same thing as the condition that all node elements in a left (sub)tree should be lesser than the root element, and the node elements in the right (sub)tree should all be larger."
                    },
                    {
                        "username": "unters",
                        "content": "In BST a key of each internal node is greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. Your BST satisfies this property."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "as per BST, nodes to the right should be greater than root. 2 must come right to 1 only."
                    }
                ]
            },
            {
                "id": 2056253,
                "content": [
                    {
                        "username": "puppyslife",
                        "content": "Can someone please help me understand the time complexity for solution 1"
                    },
                    {
                        "username": "SeineAle",
                        "content": "IDK, But where was DP in that ?\\n"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "A naive approach might be (brute force) - for each number from `1` to `n` define values ​​that should be in the left and right subtrees. Do this recursively for each number in the left and right arrays. This recursive function must return the value of the currently processed node and all combinations between the resulting left and right subtrees. I hope this helps someone get closer to the answer or find their own better solution."
                    },
                    {
                        "username": "obbl",
                        "content": "I think that answer  for n = 3\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[2,1,null,null,3]`,[3,2,null,1]]\nis true as well, however it is suggested that the only true answer is\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[3,1,null,null,2]`,[3,2,null,1]]\nwell, they are structurally the same and I don't get why one is true while the other isn't.\nDid I miss something or tests are not covering my solution? If I am wrong, please point where\n"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Does anyone know the time complexity for the brute force solution?"
                    },
                    {
                        "username": "unters",
                        "content": "According to my very rough calculation, time complexity for worst brute force solution is `O( ( (2 ^ n)! * n! * (2 ^ n * n) ) / (2 ^ n - n)! )`.\n\nAs far as I understand, brute force consists of going through all possible arrays, that might or might not represent a valid BST.\n\nAs far as a BST with `n` nodes can not have height greater than `n`, an array representation of such BST can not contain more then `2 ^ n` elements.\n\nThere are `(2 ^ n)! / (2 ^ n - n)!` ways to choose `n` elements in an array of size `2 ^ n`.\n\nFor each choice of `n` elements there are n! ways to assign nodes with distinct values from `1` through `n` to these chosen elements (array is initially filled with `null`s).\n\nBuilding a BST using one array representation takes `O(2 ^ n * n)` time (`2 ^ n` elements in an array; inserting an element takes `O(log(2 ^ n))` time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "To my surprise, pure brute force worked!"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "Man, It fells so good to solve this on my own!! \\uD83E\\uDD70"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Some tips for this problem: Dont worry too much about runtime. So long as you write code somewhat efficiently, using an inefficient algorithm will be fine with this problem as in the input sizes are tiny. (I just mean, dont do foolish things like using .get() on a linked list rather than iterating through it, in that case use an array or an array list, etc). \\n\\nNotice that the left tree must always contain all values less than the head, and the right tree must always contain all values greater than the head. This makes for a really simple recursive solution. It is exponential time, but with a maximum input size of 8, its fine! \\n\\nA tip to make things even easier, just make the argument of your recursive function a list of all the nodes it needs to use. It should anyways output a list of all trees using those nodes. (This isn\\'t necessary at all, but it makes the logic easier atleast for me). "
                    },
                    {
                        "username": "breathermachine",
                        "content": "I didn't even pass in a list to my recursive function, only two int parameters: min and max. The recursive function then generates all trees using all the values from min to max:\n\nhttps://leetcode.com/problems/unique-binary-search-trees-ii/submissions/1013076716/"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/) \n\nThis question is a lot similar but I don't know why it has 82% acceptance rate I couldn't solve it.😢"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "how \n1\n    \\\\\\\\\\\\\n       3\n    /\n2\n\nis a BST? 2 is coming right side to 1. How is it a BST? Anyone please explain."
                    },
                    {
                        "username": "kush_sach",
                        "content": "If you write down the In-order traversal for this tree, as per the recursive rule \"(left subtree) root (right subtree)\", it shall be: 1,2,3. Perfectly correct.\\n\\nRemember that a subtree itself is a tree. So, first you choose 1 as a root, for which the right child is 3. Your order is:    1, <order of right subtree with root as 3>\\nTo fill in the order for the subtree that has 3 as its root, you must treat it as a tree in itself as well. Therefore, evidently, 1, < <left subtree with root as 2> , 3 >\\nWhich is simply: 1, 2, 3\\n\\nWhat I\\'ve said is merely a rephrased version of the other two replies. The in-order traversal is basically the same thing as the condition that all node elements in a left (sub)tree should be lesser than the root element, and the node elements in the right (sub)tree should all be larger."
                    },
                    {
                        "username": "unters",
                        "content": "In BST a key of each internal node is greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. Your BST satisfies this property."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "as per BST, nodes to the right should be greater than root. 2 must come right to 1 only."
                    }
                ]
            },
            {
                "id": 2048646,
                "content": [
                    {
                        "username": "puppyslife",
                        "content": "Can someone please help me understand the time complexity for solution 1"
                    },
                    {
                        "username": "SeineAle",
                        "content": "IDK, But where was DP in that ?\\n"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "A naive approach might be (brute force) - for each number from `1` to `n` define values ​​that should be in the left and right subtrees. Do this recursively for each number in the left and right arrays. This recursive function must return the value of the currently processed node and all combinations between the resulting left and right subtrees. I hope this helps someone get closer to the answer or find their own better solution."
                    },
                    {
                        "username": "obbl",
                        "content": "I think that answer  for n = 3\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[2,1,null,null,3]`,[3,2,null,1]]\nis true as well, however it is suggested that the only true answer is\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[3,1,null,null,2]`,[3,2,null,1]]\nwell, they are structurally the same and I don't get why one is true while the other isn't.\nDid I miss something or tests are not covering my solution? If I am wrong, please point where\n"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Does anyone know the time complexity for the brute force solution?"
                    },
                    {
                        "username": "unters",
                        "content": "According to my very rough calculation, time complexity for worst brute force solution is `O( ( (2 ^ n)! * n! * (2 ^ n * n) ) / (2 ^ n - n)! )`.\n\nAs far as I understand, brute force consists of going through all possible arrays, that might or might not represent a valid BST.\n\nAs far as a BST with `n` nodes can not have height greater than `n`, an array representation of such BST can not contain more then `2 ^ n` elements.\n\nThere are `(2 ^ n)! / (2 ^ n - n)!` ways to choose `n` elements in an array of size `2 ^ n`.\n\nFor each choice of `n` elements there are n! ways to assign nodes with distinct values from `1` through `n` to these chosen elements (array is initially filled with `null`s).\n\nBuilding a BST using one array representation takes `O(2 ^ n * n)` time (`2 ^ n` elements in an array; inserting an element takes `O(log(2 ^ n))` time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "To my surprise, pure brute force worked!"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "Man, It fells so good to solve this on my own!! \\uD83E\\uDD70"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Some tips for this problem: Dont worry too much about runtime. So long as you write code somewhat efficiently, using an inefficient algorithm will be fine with this problem as in the input sizes are tiny. (I just mean, dont do foolish things like using .get() on a linked list rather than iterating through it, in that case use an array or an array list, etc). \\n\\nNotice that the left tree must always contain all values less than the head, and the right tree must always contain all values greater than the head. This makes for a really simple recursive solution. It is exponential time, but with a maximum input size of 8, its fine! \\n\\nA tip to make things even easier, just make the argument of your recursive function a list of all the nodes it needs to use. It should anyways output a list of all trees using those nodes. (This isn\\'t necessary at all, but it makes the logic easier atleast for me). "
                    },
                    {
                        "username": "breathermachine",
                        "content": "I didn't even pass in a list to my recursive function, only two int parameters: min and max. The recursive function then generates all trees using all the values from min to max:\n\nhttps://leetcode.com/problems/unique-binary-search-trees-ii/submissions/1013076716/"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/) \n\nThis question is a lot similar but I don't know why it has 82% acceptance rate I couldn't solve it.😢"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "how \n1\n    \\\\\\\\\\\\\n       3\n    /\n2\n\nis a BST? 2 is coming right side to 1. How is it a BST? Anyone please explain."
                    },
                    {
                        "username": "kush_sach",
                        "content": "If you write down the In-order traversal for this tree, as per the recursive rule \"(left subtree) root (right subtree)\", it shall be: 1,2,3. Perfectly correct.\\n\\nRemember that a subtree itself is a tree. So, first you choose 1 as a root, for which the right child is 3. Your order is:    1, <order of right subtree with root as 3>\\nTo fill in the order for the subtree that has 3 as its root, you must treat it as a tree in itself as well. Therefore, evidently, 1, < <left subtree with root as 2> , 3 >\\nWhich is simply: 1, 2, 3\\n\\nWhat I\\'ve said is merely a rephrased version of the other two replies. The in-order traversal is basically the same thing as the condition that all node elements in a left (sub)tree should be lesser than the root element, and the node elements in the right (sub)tree should all be larger."
                    },
                    {
                        "username": "unters",
                        "content": "In BST a key of each internal node is greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. Your BST satisfies this property."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "as per BST, nodes to the right should be greater than root. 2 must come right to 1 only."
                    }
                ]
            },
            {
                "id": 2002955,
                "content": [
                    {
                        "username": "puppyslife",
                        "content": "Can someone please help me understand the time complexity for solution 1"
                    },
                    {
                        "username": "SeineAle",
                        "content": "IDK, But where was DP in that ?\\n"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "A naive approach might be (brute force) - for each number from `1` to `n` define values ​​that should be in the left and right subtrees. Do this recursively for each number in the left and right arrays. This recursive function must return the value of the currently processed node and all combinations between the resulting left and right subtrees. I hope this helps someone get closer to the answer or find their own better solution."
                    },
                    {
                        "username": "obbl",
                        "content": "I think that answer  for n = 3\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[2,1,null,null,3]`,[3,2,null,1]]\nis true as well, however it is suggested that the only true answer is\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[3,1,null,null,2]`,[3,2,null,1]]\nwell, they are structurally the same and I don't get why one is true while the other isn't.\nDid I miss something or tests are not covering my solution? If I am wrong, please point where\n"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Does anyone know the time complexity for the brute force solution?"
                    },
                    {
                        "username": "unters",
                        "content": "According to my very rough calculation, time complexity for worst brute force solution is `O( ( (2 ^ n)! * n! * (2 ^ n * n) ) / (2 ^ n - n)! )`.\n\nAs far as I understand, brute force consists of going through all possible arrays, that might or might not represent a valid BST.\n\nAs far as a BST with `n` nodes can not have height greater than `n`, an array representation of such BST can not contain more then `2 ^ n` elements.\n\nThere are `(2 ^ n)! / (2 ^ n - n)!` ways to choose `n` elements in an array of size `2 ^ n`.\n\nFor each choice of `n` elements there are n! ways to assign nodes with distinct values from `1` through `n` to these chosen elements (array is initially filled with `null`s).\n\nBuilding a BST using one array representation takes `O(2 ^ n * n)` time (`2 ^ n` elements in an array; inserting an element takes `O(log(2 ^ n))` time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "To my surprise, pure brute force worked!"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "Man, It fells so good to solve this on my own!! \\uD83E\\uDD70"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Some tips for this problem: Dont worry too much about runtime. So long as you write code somewhat efficiently, using an inefficient algorithm will be fine with this problem as in the input sizes are tiny. (I just mean, dont do foolish things like using .get() on a linked list rather than iterating through it, in that case use an array or an array list, etc). \\n\\nNotice that the left tree must always contain all values less than the head, and the right tree must always contain all values greater than the head. This makes for a really simple recursive solution. It is exponential time, but with a maximum input size of 8, its fine! \\n\\nA tip to make things even easier, just make the argument of your recursive function a list of all the nodes it needs to use. It should anyways output a list of all trees using those nodes. (This isn\\'t necessary at all, but it makes the logic easier atleast for me). "
                    },
                    {
                        "username": "breathermachine",
                        "content": "I didn't even pass in a list to my recursive function, only two int parameters: min and max. The recursive function then generates all trees using all the values from min to max:\n\nhttps://leetcode.com/problems/unique-binary-search-trees-ii/submissions/1013076716/"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/) \n\nThis question is a lot similar but I don't know why it has 82% acceptance rate I couldn't solve it.😢"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "how \n1\n    \\\\\\\\\\\\\n       3\n    /\n2\n\nis a BST? 2 is coming right side to 1. How is it a BST? Anyone please explain."
                    },
                    {
                        "username": "kush_sach",
                        "content": "If you write down the In-order traversal for this tree, as per the recursive rule \"(left subtree) root (right subtree)\", it shall be: 1,2,3. Perfectly correct.\\n\\nRemember that a subtree itself is a tree. So, first you choose 1 as a root, for which the right child is 3. Your order is:    1, <order of right subtree with root as 3>\\nTo fill in the order for the subtree that has 3 as its root, you must treat it as a tree in itself as well. Therefore, evidently, 1, < <left subtree with root as 2> , 3 >\\nWhich is simply: 1, 2, 3\\n\\nWhat I\\'ve said is merely a rephrased version of the other two replies. The in-order traversal is basically the same thing as the condition that all node elements in a left (sub)tree should be lesser than the root element, and the node elements in the right (sub)tree should all be larger."
                    },
                    {
                        "username": "unters",
                        "content": "In BST a key of each internal node is greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. Your BST satisfies this property."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "as per BST, nodes to the right should be greater than root. 2 must come right to 1 only."
                    }
                ]
            },
            {
                "id": 2001639,
                "content": [
                    {
                        "username": "puppyslife",
                        "content": "Can someone please help me understand the time complexity for solution 1"
                    },
                    {
                        "username": "SeineAle",
                        "content": "IDK, But where was DP in that ?\\n"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "A naive approach might be (brute force) - for each number from `1` to `n` define values ​​that should be in the left and right subtrees. Do this recursively for each number in the left and right arrays. This recursive function must return the value of the currently processed node and all combinations between the resulting left and right subtrees. I hope this helps someone get closer to the answer or find their own better solution."
                    },
                    {
                        "username": "obbl",
                        "content": "I think that answer  for n = 3\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[2,1,null,null,3]`,[3,2,null,1]]\nis true as well, however it is suggested that the only true answer is\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[3,1,null,null,2]`,[3,2,null,1]]\nwell, they are structurally the same and I don't get why one is true while the other isn't.\nDid I miss something or tests are not covering my solution? If I am wrong, please point where\n"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Does anyone know the time complexity for the brute force solution?"
                    },
                    {
                        "username": "unters",
                        "content": "According to my very rough calculation, time complexity for worst brute force solution is `O( ( (2 ^ n)! * n! * (2 ^ n * n) ) / (2 ^ n - n)! )`.\n\nAs far as I understand, brute force consists of going through all possible arrays, that might or might not represent a valid BST.\n\nAs far as a BST with `n` nodes can not have height greater than `n`, an array representation of such BST can not contain more then `2 ^ n` elements.\n\nThere are `(2 ^ n)! / (2 ^ n - n)!` ways to choose `n` elements in an array of size `2 ^ n`.\n\nFor each choice of `n` elements there are n! ways to assign nodes with distinct values from `1` through `n` to these chosen elements (array is initially filled with `null`s).\n\nBuilding a BST using one array representation takes `O(2 ^ n * n)` time (`2 ^ n` elements in an array; inserting an element takes `O(log(2 ^ n))` time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "To my surprise, pure brute force worked!"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "Man, It fells so good to solve this on my own!! \\uD83E\\uDD70"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Some tips for this problem: Dont worry too much about runtime. So long as you write code somewhat efficiently, using an inefficient algorithm will be fine with this problem as in the input sizes are tiny. (I just mean, dont do foolish things like using .get() on a linked list rather than iterating through it, in that case use an array or an array list, etc). \\n\\nNotice that the left tree must always contain all values less than the head, and the right tree must always contain all values greater than the head. This makes for a really simple recursive solution. It is exponential time, but with a maximum input size of 8, its fine! \\n\\nA tip to make things even easier, just make the argument of your recursive function a list of all the nodes it needs to use. It should anyways output a list of all trees using those nodes. (This isn\\'t necessary at all, but it makes the logic easier atleast for me). "
                    },
                    {
                        "username": "breathermachine",
                        "content": "I didn't even pass in a list to my recursive function, only two int parameters: min and max. The recursive function then generates all trees using all the values from min to max:\n\nhttps://leetcode.com/problems/unique-binary-search-trees-ii/submissions/1013076716/"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/) \n\nThis question is a lot similar but I don't know why it has 82% acceptance rate I couldn't solve it.😢"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "how \n1\n    \\\\\\\\\\\\\n       3\n    /\n2\n\nis a BST? 2 is coming right side to 1. How is it a BST? Anyone please explain."
                    },
                    {
                        "username": "kush_sach",
                        "content": "If you write down the In-order traversal for this tree, as per the recursive rule \"(left subtree) root (right subtree)\", it shall be: 1,2,3. Perfectly correct.\\n\\nRemember that a subtree itself is a tree. So, first you choose 1 as a root, for which the right child is 3. Your order is:    1, <order of right subtree with root as 3>\\nTo fill in the order for the subtree that has 3 as its root, you must treat it as a tree in itself as well. Therefore, evidently, 1, < <left subtree with root as 2> , 3 >\\nWhich is simply: 1, 2, 3\\n\\nWhat I\\'ve said is merely a rephrased version of the other two replies. The in-order traversal is basically the same thing as the condition that all node elements in a left (sub)tree should be lesser than the root element, and the node elements in the right (sub)tree should all be larger."
                    },
                    {
                        "username": "unters",
                        "content": "In BST a key of each internal node is greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. Your BST satisfies this property."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "as per BST, nodes to the right should be greater than root. 2 must come right to 1 only."
                    }
                ]
            },
            {
                "id": 2001616,
                "content": [
                    {
                        "username": "puppyslife",
                        "content": "Can someone please help me understand the time complexity for solution 1"
                    },
                    {
                        "username": "SeineAle",
                        "content": "IDK, But where was DP in that ?\\n"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "A naive approach might be (brute force) - for each number from `1` to `n` define values ​​that should be in the left and right subtrees. Do this recursively for each number in the left and right arrays. This recursive function must return the value of the currently processed node and all combinations between the resulting left and right subtrees. I hope this helps someone get closer to the answer or find their own better solution."
                    },
                    {
                        "username": "obbl",
                        "content": "I think that answer  for n = 3\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[2,1,null,null,3]`,[3,2,null,1]]\nis true as well, however it is suggested that the only true answer is\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[3,1,null,null,2]`,[3,2,null,1]]\nwell, they are structurally the same and I don't get why one is true while the other isn't.\nDid I miss something or tests are not covering my solution? If I am wrong, please point where\n"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Does anyone know the time complexity for the brute force solution?"
                    },
                    {
                        "username": "unters",
                        "content": "According to my very rough calculation, time complexity for worst brute force solution is `O( ( (2 ^ n)! * n! * (2 ^ n * n) ) / (2 ^ n - n)! )`.\n\nAs far as I understand, brute force consists of going through all possible arrays, that might or might not represent a valid BST.\n\nAs far as a BST with `n` nodes can not have height greater than `n`, an array representation of such BST can not contain more then `2 ^ n` elements.\n\nThere are `(2 ^ n)! / (2 ^ n - n)!` ways to choose `n` elements in an array of size `2 ^ n`.\n\nFor each choice of `n` elements there are n! ways to assign nodes with distinct values from `1` through `n` to these chosen elements (array is initially filled with `null`s).\n\nBuilding a BST using one array representation takes `O(2 ^ n * n)` time (`2 ^ n` elements in an array; inserting an element takes `O(log(2 ^ n))` time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "To my surprise, pure brute force worked!"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "Man, It fells so good to solve this on my own!! \\uD83E\\uDD70"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Some tips for this problem: Dont worry too much about runtime. So long as you write code somewhat efficiently, using an inefficient algorithm will be fine with this problem as in the input sizes are tiny. (I just mean, dont do foolish things like using .get() on a linked list rather than iterating through it, in that case use an array or an array list, etc). \\n\\nNotice that the left tree must always contain all values less than the head, and the right tree must always contain all values greater than the head. This makes for a really simple recursive solution. It is exponential time, but with a maximum input size of 8, its fine! \\n\\nA tip to make things even easier, just make the argument of your recursive function a list of all the nodes it needs to use. It should anyways output a list of all trees using those nodes. (This isn\\'t necessary at all, but it makes the logic easier atleast for me). "
                    },
                    {
                        "username": "breathermachine",
                        "content": "I didn't even pass in a list to my recursive function, only two int parameters: min and max. The recursive function then generates all trees using all the values from min to max:\n\nhttps://leetcode.com/problems/unique-binary-search-trees-ii/submissions/1013076716/"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/) \n\nThis question is a lot similar but I don't know why it has 82% acceptance rate I couldn't solve it.😢"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "how \n1\n    \\\\\\\\\\\\\n       3\n    /\n2\n\nis a BST? 2 is coming right side to 1. How is it a BST? Anyone please explain."
                    },
                    {
                        "username": "kush_sach",
                        "content": "If you write down the In-order traversal for this tree, as per the recursive rule \"(left subtree) root (right subtree)\", it shall be: 1,2,3. Perfectly correct.\\n\\nRemember that a subtree itself is a tree. So, first you choose 1 as a root, for which the right child is 3. Your order is:    1, <order of right subtree with root as 3>\\nTo fill in the order for the subtree that has 3 as its root, you must treat it as a tree in itself as well. Therefore, evidently, 1, < <left subtree with root as 2> , 3 >\\nWhich is simply: 1, 2, 3\\n\\nWhat I\\'ve said is merely a rephrased version of the other two replies. The in-order traversal is basically the same thing as the condition that all node elements in a left (sub)tree should be lesser than the root element, and the node elements in the right (sub)tree should all be larger."
                    },
                    {
                        "username": "unters",
                        "content": "In BST a key of each internal node is greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. Your BST satisfies this property."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "as per BST, nodes to the right should be greater than root. 2 must come right to 1 only."
                    }
                ]
            },
            {
                "id": 2001604,
                "content": [
                    {
                        "username": "puppyslife",
                        "content": "Can someone please help me understand the time complexity for solution 1"
                    },
                    {
                        "username": "SeineAle",
                        "content": "IDK, But where was DP in that ?\\n"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "A naive approach might be (brute force) - for each number from `1` to `n` define values ​​that should be in the left and right subtrees. Do this recursively for each number in the left and right arrays. This recursive function must return the value of the currently processed node and all combinations between the resulting left and right subtrees. I hope this helps someone get closer to the answer or find their own better solution."
                    },
                    {
                        "username": "obbl",
                        "content": "I think that answer  for n = 3\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[2,1,null,null,3]`,[3,2,null,1]]\nis true as well, however it is suggested that the only true answer is\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[3,1,null,null,2]`,[3,2,null,1]]\nwell, they are structurally the same and I don't get why one is true while the other isn't.\nDid I miss something or tests are not covering my solution? If I am wrong, please point where\n"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Does anyone know the time complexity for the brute force solution?"
                    },
                    {
                        "username": "unters",
                        "content": "According to my very rough calculation, time complexity for worst brute force solution is `O( ( (2 ^ n)! * n! * (2 ^ n * n) ) / (2 ^ n - n)! )`.\n\nAs far as I understand, brute force consists of going through all possible arrays, that might or might not represent a valid BST.\n\nAs far as a BST with `n` nodes can not have height greater than `n`, an array representation of such BST can not contain more then `2 ^ n` elements.\n\nThere are `(2 ^ n)! / (2 ^ n - n)!` ways to choose `n` elements in an array of size `2 ^ n`.\n\nFor each choice of `n` elements there are n! ways to assign nodes with distinct values from `1` through `n` to these chosen elements (array is initially filled with `null`s).\n\nBuilding a BST using one array representation takes `O(2 ^ n * n)` time (`2 ^ n` elements in an array; inserting an element takes `O(log(2 ^ n))` time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "To my surprise, pure brute force worked!"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "Man, It fells so good to solve this on my own!! \\uD83E\\uDD70"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Some tips for this problem: Dont worry too much about runtime. So long as you write code somewhat efficiently, using an inefficient algorithm will be fine with this problem as in the input sizes are tiny. (I just mean, dont do foolish things like using .get() on a linked list rather than iterating through it, in that case use an array or an array list, etc). \\n\\nNotice that the left tree must always contain all values less than the head, and the right tree must always contain all values greater than the head. This makes for a really simple recursive solution. It is exponential time, but with a maximum input size of 8, its fine! \\n\\nA tip to make things even easier, just make the argument of your recursive function a list of all the nodes it needs to use. It should anyways output a list of all trees using those nodes. (This isn\\'t necessary at all, but it makes the logic easier atleast for me). "
                    },
                    {
                        "username": "breathermachine",
                        "content": "I didn't even pass in a list to my recursive function, only two int parameters: min and max. The recursive function then generates all trees using all the values from min to max:\n\nhttps://leetcode.com/problems/unique-binary-search-trees-ii/submissions/1013076716/"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/) \n\nThis question is a lot similar but I don't know why it has 82% acceptance rate I couldn't solve it.😢"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "how \n1\n    \\\\\\\\\\\\\n       3\n    /\n2\n\nis a BST? 2 is coming right side to 1. How is it a BST? Anyone please explain."
                    },
                    {
                        "username": "kush_sach",
                        "content": "If you write down the In-order traversal for this tree, as per the recursive rule \"(left subtree) root (right subtree)\", it shall be: 1,2,3. Perfectly correct.\\n\\nRemember that a subtree itself is a tree. So, first you choose 1 as a root, for which the right child is 3. Your order is:    1, <order of right subtree with root as 3>\\nTo fill in the order for the subtree that has 3 as its root, you must treat it as a tree in itself as well. Therefore, evidently, 1, < <left subtree with root as 2> , 3 >\\nWhich is simply: 1, 2, 3\\n\\nWhat I\\'ve said is merely a rephrased version of the other two replies. The in-order traversal is basically the same thing as the condition that all node elements in a left (sub)tree should be lesser than the root element, and the node elements in the right (sub)tree should all be larger."
                    },
                    {
                        "username": "unters",
                        "content": "In BST a key of each internal node is greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. Your BST satisfies this property."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "as per BST, nodes to the right should be greater than root. 2 must come right to 1 only."
                    }
                ]
            },
            {
                "id": 2001592,
                "content": [
                    {
                        "username": "puppyslife",
                        "content": "Can someone please help me understand the time complexity for solution 1"
                    },
                    {
                        "username": "SeineAle",
                        "content": "IDK, But where was DP in that ?\\n"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "A naive approach might be (brute force) - for each number from `1` to `n` define values ​​that should be in the left and right subtrees. Do this recursively for each number in the left and right arrays. This recursive function must return the value of the currently processed node and all combinations between the resulting left and right subtrees. I hope this helps someone get closer to the answer or find their own better solution."
                    },
                    {
                        "username": "obbl",
                        "content": "I think that answer  for n = 3\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[2,1,null,null,3]`,[3,2,null,1]]\nis true as well, however it is suggested that the only true answer is\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[3,1,null,null,2]`,[3,2,null,1]]\nwell, they are structurally the same and I don't get why one is true while the other isn't.\nDid I miss something or tests are not covering my solution? If I am wrong, please point where\n"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Does anyone know the time complexity for the brute force solution?"
                    },
                    {
                        "username": "unters",
                        "content": "According to my very rough calculation, time complexity for worst brute force solution is `O( ( (2 ^ n)! * n! * (2 ^ n * n) ) / (2 ^ n - n)! )`.\n\nAs far as I understand, brute force consists of going through all possible arrays, that might or might not represent a valid BST.\n\nAs far as a BST with `n` nodes can not have height greater than `n`, an array representation of such BST can not contain more then `2 ^ n` elements.\n\nThere are `(2 ^ n)! / (2 ^ n - n)!` ways to choose `n` elements in an array of size `2 ^ n`.\n\nFor each choice of `n` elements there are n! ways to assign nodes with distinct values from `1` through `n` to these chosen elements (array is initially filled with `null`s).\n\nBuilding a BST using one array representation takes `O(2 ^ n * n)` time (`2 ^ n` elements in an array; inserting an element takes `O(log(2 ^ n))` time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "To my surprise, pure brute force worked!"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "Man, It fells so good to solve this on my own!! \\uD83E\\uDD70"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Some tips for this problem: Dont worry too much about runtime. So long as you write code somewhat efficiently, using an inefficient algorithm will be fine with this problem as in the input sizes are tiny. (I just mean, dont do foolish things like using .get() on a linked list rather than iterating through it, in that case use an array or an array list, etc). \\n\\nNotice that the left tree must always contain all values less than the head, and the right tree must always contain all values greater than the head. This makes for a really simple recursive solution. It is exponential time, but with a maximum input size of 8, its fine! \\n\\nA tip to make things even easier, just make the argument of your recursive function a list of all the nodes it needs to use. It should anyways output a list of all trees using those nodes. (This isn\\'t necessary at all, but it makes the logic easier atleast for me). "
                    },
                    {
                        "username": "breathermachine",
                        "content": "I didn't even pass in a list to my recursive function, only two int parameters: min and max. The recursive function then generates all trees using all the values from min to max:\n\nhttps://leetcode.com/problems/unique-binary-search-trees-ii/submissions/1013076716/"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/) \n\nThis question is a lot similar but I don't know why it has 82% acceptance rate I couldn't solve it.😢"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "how \n1\n    \\\\\\\\\\\\\n       3\n    /\n2\n\nis a BST? 2 is coming right side to 1. How is it a BST? Anyone please explain."
                    },
                    {
                        "username": "kush_sach",
                        "content": "If you write down the In-order traversal for this tree, as per the recursive rule \"(left subtree) root (right subtree)\", it shall be: 1,2,3. Perfectly correct.\\n\\nRemember that a subtree itself is a tree. So, first you choose 1 as a root, for which the right child is 3. Your order is:    1, <order of right subtree with root as 3>\\nTo fill in the order for the subtree that has 3 as its root, you must treat it as a tree in itself as well. Therefore, evidently, 1, < <left subtree with root as 2> , 3 >\\nWhich is simply: 1, 2, 3\\n\\nWhat I\\'ve said is merely a rephrased version of the other two replies. The in-order traversal is basically the same thing as the condition that all node elements in a left (sub)tree should be lesser than the root element, and the node elements in the right (sub)tree should all be larger."
                    },
                    {
                        "username": "unters",
                        "content": "In BST a key of each internal node is greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. Your BST satisfies this property."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "as per BST, nodes to the right should be greater than root. 2 must come right to 1 only."
                    }
                ]
            },
            {
                "id": 2001476,
                "content": [
                    {
                        "username": "puppyslife",
                        "content": "Can someone please help me understand the time complexity for solution 1"
                    },
                    {
                        "username": "SeineAle",
                        "content": "IDK, But where was DP in that ?\\n"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "A naive approach might be (brute force) - for each number from `1` to `n` define values ​​that should be in the left and right subtrees. Do this recursively for each number in the left and right arrays. This recursive function must return the value of the currently processed node and all combinations between the resulting left and right subtrees. I hope this helps someone get closer to the answer or find their own better solution."
                    },
                    {
                        "username": "obbl",
                        "content": "I think that answer  for n = 3\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[2,1,null,null,3]`,[3,2,null,1]]\nis true as well, however it is suggested that the only true answer is\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[3,1,null,null,2]`,[3,2,null,1]]\nwell, they are structurally the same and I don't get why one is true while the other isn't.\nDid I miss something or tests are not covering my solution? If I am wrong, please point where\n"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Does anyone know the time complexity for the brute force solution?"
                    },
                    {
                        "username": "unters",
                        "content": "According to my very rough calculation, time complexity for worst brute force solution is `O( ( (2 ^ n)! * n! * (2 ^ n * n) ) / (2 ^ n - n)! )`.\n\nAs far as I understand, brute force consists of going through all possible arrays, that might or might not represent a valid BST.\n\nAs far as a BST with `n` nodes can not have height greater than `n`, an array representation of such BST can not contain more then `2 ^ n` elements.\n\nThere are `(2 ^ n)! / (2 ^ n - n)!` ways to choose `n` elements in an array of size `2 ^ n`.\n\nFor each choice of `n` elements there are n! ways to assign nodes with distinct values from `1` through `n` to these chosen elements (array is initially filled with `null`s).\n\nBuilding a BST using one array representation takes `O(2 ^ n * n)` time (`2 ^ n` elements in an array; inserting an element takes `O(log(2 ^ n))` time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "To my surprise, pure brute force worked!"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "Man, It fells so good to solve this on my own!! \\uD83E\\uDD70"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Some tips for this problem: Dont worry too much about runtime. So long as you write code somewhat efficiently, using an inefficient algorithm will be fine with this problem as in the input sizes are tiny. (I just mean, dont do foolish things like using .get() on a linked list rather than iterating through it, in that case use an array or an array list, etc). \\n\\nNotice that the left tree must always contain all values less than the head, and the right tree must always contain all values greater than the head. This makes for a really simple recursive solution. It is exponential time, but with a maximum input size of 8, its fine! \\n\\nA tip to make things even easier, just make the argument of your recursive function a list of all the nodes it needs to use. It should anyways output a list of all trees using those nodes. (This isn\\'t necessary at all, but it makes the logic easier atleast for me). "
                    },
                    {
                        "username": "breathermachine",
                        "content": "I didn't even pass in a list to my recursive function, only two int parameters: min and max. The recursive function then generates all trees using all the values from min to max:\n\nhttps://leetcode.com/problems/unique-binary-search-trees-ii/submissions/1013076716/"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/) \n\nThis question is a lot similar but I don't know why it has 82% acceptance rate I couldn't solve it.😢"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "how \n1\n    \\\\\\\\\\\\\n       3\n    /\n2\n\nis a BST? 2 is coming right side to 1. How is it a BST? Anyone please explain."
                    },
                    {
                        "username": "kush_sach",
                        "content": "If you write down the In-order traversal for this tree, as per the recursive rule \"(left subtree) root (right subtree)\", it shall be: 1,2,3. Perfectly correct.\\n\\nRemember that a subtree itself is a tree. So, first you choose 1 as a root, for which the right child is 3. Your order is:    1, <order of right subtree with root as 3>\\nTo fill in the order for the subtree that has 3 as its root, you must treat it as a tree in itself as well. Therefore, evidently, 1, < <left subtree with root as 2> , 3 >\\nWhich is simply: 1, 2, 3\\n\\nWhat I\\'ve said is merely a rephrased version of the other two replies. The in-order traversal is basically the same thing as the condition that all node elements in a left (sub)tree should be lesser than the root element, and the node elements in the right (sub)tree should all be larger."
                    },
                    {
                        "username": "unters",
                        "content": "In BST a key of each internal node is greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. Your BST satisfies this property."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "as per BST, nodes to the right should be greater than root. 2 must come right to 1 only."
                    }
                ]
            },
            {
                "id": 2001084,
                "content": [
                    {
                        "username": "puppyslife",
                        "content": "Can someone please help me understand the time complexity for solution 1"
                    },
                    {
                        "username": "SeineAle",
                        "content": "IDK, But where was DP in that ?\\n"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "A naive approach might be (brute force) - for each number from `1` to `n` define values ​​that should be in the left and right subtrees. Do this recursively for each number in the left and right arrays. This recursive function must return the value of the currently processed node and all combinations between the resulting left and right subtrees. I hope this helps someone get closer to the answer or find their own better solution."
                    },
                    {
                        "username": "obbl",
                        "content": "I think that answer  for n = 3\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[2,1,null,null,3]`,[3,2,null,1]]\nis true as well, however it is suggested that the only true answer is\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[3,1,null,null,2]`,[3,2,null,1]]\nwell, they are structurally the same and I don't get why one is true while the other isn't.\nDid I miss something or tests are not covering my solution? If I am wrong, please point where\n"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Does anyone know the time complexity for the brute force solution?"
                    },
                    {
                        "username": "unters",
                        "content": "According to my very rough calculation, time complexity for worst brute force solution is `O( ( (2 ^ n)! * n! * (2 ^ n * n) ) / (2 ^ n - n)! )`.\n\nAs far as I understand, brute force consists of going through all possible arrays, that might or might not represent a valid BST.\n\nAs far as a BST with `n` nodes can not have height greater than `n`, an array representation of such BST can not contain more then `2 ^ n` elements.\n\nThere are `(2 ^ n)! / (2 ^ n - n)!` ways to choose `n` elements in an array of size `2 ^ n`.\n\nFor each choice of `n` elements there are n! ways to assign nodes with distinct values from `1` through `n` to these chosen elements (array is initially filled with `null`s).\n\nBuilding a BST using one array representation takes `O(2 ^ n * n)` time (`2 ^ n` elements in an array; inserting an element takes `O(log(2 ^ n))` time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "To my surprise, pure brute force worked!"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "Man, It fells so good to solve this on my own!! \\uD83E\\uDD70"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Some tips for this problem: Dont worry too much about runtime. So long as you write code somewhat efficiently, using an inefficient algorithm will be fine with this problem as in the input sizes are tiny. (I just mean, dont do foolish things like using .get() on a linked list rather than iterating through it, in that case use an array or an array list, etc). \\n\\nNotice that the left tree must always contain all values less than the head, and the right tree must always contain all values greater than the head. This makes for a really simple recursive solution. It is exponential time, but with a maximum input size of 8, its fine! \\n\\nA tip to make things even easier, just make the argument of your recursive function a list of all the nodes it needs to use. It should anyways output a list of all trees using those nodes. (This isn\\'t necessary at all, but it makes the logic easier atleast for me). "
                    },
                    {
                        "username": "breathermachine",
                        "content": "I didn't even pass in a list to my recursive function, only two int parameters: min and max. The recursive function then generates all trees using all the values from min to max:\n\nhttps://leetcode.com/problems/unique-binary-search-trees-ii/submissions/1013076716/"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/) \n\nThis question is a lot similar but I don't know why it has 82% acceptance rate I couldn't solve it.😢"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "how \n1\n    \\\\\\\\\\\\\n       3\n    /\n2\n\nis a BST? 2 is coming right side to 1. How is it a BST? Anyone please explain."
                    },
                    {
                        "username": "kush_sach",
                        "content": "If you write down the In-order traversal for this tree, as per the recursive rule \"(left subtree) root (right subtree)\", it shall be: 1,2,3. Perfectly correct.\\n\\nRemember that a subtree itself is a tree. So, first you choose 1 as a root, for which the right child is 3. Your order is:    1, <order of right subtree with root as 3>\\nTo fill in the order for the subtree that has 3 as its root, you must treat it as a tree in itself as well. Therefore, evidently, 1, < <left subtree with root as 2> , 3 >\\nWhich is simply: 1, 2, 3\\n\\nWhat I\\'ve said is merely a rephrased version of the other two replies. The in-order traversal is basically the same thing as the condition that all node elements in a left (sub)tree should be lesser than the root element, and the node elements in the right (sub)tree should all be larger."
                    },
                    {
                        "username": "unters",
                        "content": "In BST a key of each internal node is greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. Your BST satisfies this property."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "as per BST, nodes to the right should be greater than root. 2 must come right to 1 only."
                    }
                ]
            },
            {
                "id": 2001067,
                "content": [
                    {
                        "username": "charant587",
                        "content": "I got up with dfs approach after think for an 20 minutes can we use dp for this????"
                    },
                    {
                        "username": "KirtanMakwana",
                        "content": "why unordered_map giving error and map doesnt? while memoization."
                    },
                    {
                        "username": "unters",
                        "content": "`std::unordered_map` organizes its elements using a hash table. This imposes requirements on the key-type:\n\n1. default hash functor `std::hash<>` must be specialized for key-type (there is no such requirement when using `std::map`);\n\n2. A comparison function for equality must be defined for key-type (when using `std::map` the equivalent requirement is that keys must be comparable).\n\nI guess you use a user-defined key-type that has no `std::hash<>` specialization, but that has comparison functions."
                    },
                    {
                        "username": "ahmed___",
                        "content": "Medium??"
                    },
                    {
                        "username": "algoacer",
                        "content": "call to implicitly-deleted default constructor of \\'Solution\\'.  Generate the required memo dp within the generate Trees function. Congrats on completing such an interesting problem."
                    },
                    {
                        "username": "dikshawali",
                        "content": "My solution is beating only 5% of users. \\n1. I have used DP\\n2. Despite having recursive solution, my program is having n3 time complexity.\\ncan anyone suggest ways to decrease time complexity?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Write a helper _generateTrees method that takes in two parameters: the min and the max then use it recursively to generate the subtrees.\\n\\nThe loop looks like:\\n```\\nfor i in min to max:\\n   leftTrees = generateTrees(min, i - 1)\\n   rightTrees = generateTrees(i + 1, max)\\n   // combine left and right subtrees using a double for loop\\nreturn\\n```\\n\\n"
                    },
                    {
                        "username": "sarvesh_mankar",
                        "content": "If you are finding this challenge really tough then try out [Leetcode Challenge 96](https://leetcode.com/problems/unique-binary-search-trees/) first! It will help you in developing this solution."
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "dkochetov",
                        "content": "I overcomplicated my solution by using bitmasking and memoization. You don\\'t need any of these for this problem :)"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Hate to say it but with N<=8 isn\\'t this question easy? "
                    },
                    {
                        "username": "a8hi",
                        "content": "LeetCode Daily Has been Real Kind"
                    }
                ]
            },
            {
                "id": 2000948,
                "content": [
                    {
                        "username": "charant587",
                        "content": "I got up with dfs approach after think for an 20 minutes can we use dp for this????"
                    },
                    {
                        "username": "KirtanMakwana",
                        "content": "why unordered_map giving error and map doesnt? while memoization."
                    },
                    {
                        "username": "unters",
                        "content": "`std::unordered_map` organizes its elements using a hash table. This imposes requirements on the key-type:\n\n1. default hash functor `std::hash<>` must be specialized for key-type (there is no such requirement when using `std::map`);\n\n2. A comparison function for equality must be defined for key-type (when using `std::map` the equivalent requirement is that keys must be comparable).\n\nI guess you use a user-defined key-type that has no `std::hash<>` specialization, but that has comparison functions."
                    },
                    {
                        "username": "ahmed___",
                        "content": "Medium??"
                    },
                    {
                        "username": "algoacer",
                        "content": "call to implicitly-deleted default constructor of \\'Solution\\'.  Generate the required memo dp within the generate Trees function. Congrats on completing such an interesting problem."
                    },
                    {
                        "username": "dikshawali",
                        "content": "My solution is beating only 5% of users. \\n1. I have used DP\\n2. Despite having recursive solution, my program is having n3 time complexity.\\ncan anyone suggest ways to decrease time complexity?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Write a helper _generateTrees method that takes in two parameters: the min and the max then use it recursively to generate the subtrees.\\n\\nThe loop looks like:\\n```\\nfor i in min to max:\\n   leftTrees = generateTrees(min, i - 1)\\n   rightTrees = generateTrees(i + 1, max)\\n   // combine left and right subtrees using a double for loop\\nreturn\\n```\\n\\n"
                    },
                    {
                        "username": "sarvesh_mankar",
                        "content": "If you are finding this challenge really tough then try out [Leetcode Challenge 96](https://leetcode.com/problems/unique-binary-search-trees/) first! It will help you in developing this solution."
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "dkochetov",
                        "content": "I overcomplicated my solution by using bitmasking and memoization. You don\\'t need any of these for this problem :)"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Hate to say it but with N<=8 isn\\'t this question easy? "
                    },
                    {
                        "username": "a8hi",
                        "content": "LeetCode Daily Has been Real Kind"
                    }
                ]
            },
            {
                "id": 2000937,
                "content": [
                    {
                        "username": "charant587",
                        "content": "I got up with dfs approach after think for an 20 minutes can we use dp for this????"
                    },
                    {
                        "username": "KirtanMakwana",
                        "content": "why unordered_map giving error and map doesnt? while memoization."
                    },
                    {
                        "username": "unters",
                        "content": "`std::unordered_map` organizes its elements using a hash table. This imposes requirements on the key-type:\n\n1. default hash functor `std::hash<>` must be specialized for key-type (there is no such requirement when using `std::map`);\n\n2. A comparison function for equality must be defined for key-type (when using `std::map` the equivalent requirement is that keys must be comparable).\n\nI guess you use a user-defined key-type that has no `std::hash<>` specialization, but that has comparison functions."
                    },
                    {
                        "username": "ahmed___",
                        "content": "Medium??"
                    },
                    {
                        "username": "algoacer",
                        "content": "call to implicitly-deleted default constructor of \\'Solution\\'.  Generate the required memo dp within the generate Trees function. Congrats on completing such an interesting problem."
                    },
                    {
                        "username": "dikshawali",
                        "content": "My solution is beating only 5% of users. \\n1. I have used DP\\n2. Despite having recursive solution, my program is having n3 time complexity.\\ncan anyone suggest ways to decrease time complexity?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Write a helper _generateTrees method that takes in two parameters: the min and the max then use it recursively to generate the subtrees.\\n\\nThe loop looks like:\\n```\\nfor i in min to max:\\n   leftTrees = generateTrees(min, i - 1)\\n   rightTrees = generateTrees(i + 1, max)\\n   // combine left and right subtrees using a double for loop\\nreturn\\n```\\n\\n"
                    },
                    {
                        "username": "sarvesh_mankar",
                        "content": "If you are finding this challenge really tough then try out [Leetcode Challenge 96](https://leetcode.com/problems/unique-binary-search-trees/) first! It will help you in developing this solution."
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "dkochetov",
                        "content": "I overcomplicated my solution by using bitmasking and memoization. You don\\'t need any of these for this problem :)"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Hate to say it but with N<=8 isn\\'t this question easy? "
                    },
                    {
                        "username": "a8hi",
                        "content": "LeetCode Daily Has been Real Kind"
                    }
                ]
            },
            {
                "id": 2000916,
                "content": [
                    {
                        "username": "charant587",
                        "content": "I got up with dfs approach after think for an 20 minutes can we use dp for this????"
                    },
                    {
                        "username": "KirtanMakwana",
                        "content": "why unordered_map giving error and map doesnt? while memoization."
                    },
                    {
                        "username": "unters",
                        "content": "`std::unordered_map` organizes its elements using a hash table. This imposes requirements on the key-type:\n\n1. default hash functor `std::hash<>` must be specialized for key-type (there is no such requirement when using `std::map`);\n\n2. A comparison function for equality must be defined for key-type (when using `std::map` the equivalent requirement is that keys must be comparable).\n\nI guess you use a user-defined key-type that has no `std::hash<>` specialization, but that has comparison functions."
                    },
                    {
                        "username": "ahmed___",
                        "content": "Medium??"
                    },
                    {
                        "username": "algoacer",
                        "content": "call to implicitly-deleted default constructor of \\'Solution\\'.  Generate the required memo dp within the generate Trees function. Congrats on completing such an interesting problem."
                    },
                    {
                        "username": "dikshawali",
                        "content": "My solution is beating only 5% of users. \\n1. I have used DP\\n2. Despite having recursive solution, my program is having n3 time complexity.\\ncan anyone suggest ways to decrease time complexity?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Write a helper _generateTrees method that takes in two parameters: the min and the max then use it recursively to generate the subtrees.\\n\\nThe loop looks like:\\n```\\nfor i in min to max:\\n   leftTrees = generateTrees(min, i - 1)\\n   rightTrees = generateTrees(i + 1, max)\\n   // combine left and right subtrees using a double for loop\\nreturn\\n```\\n\\n"
                    },
                    {
                        "username": "sarvesh_mankar",
                        "content": "If you are finding this challenge really tough then try out [Leetcode Challenge 96](https://leetcode.com/problems/unique-binary-search-trees/) first! It will help you in developing this solution."
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "dkochetov",
                        "content": "I overcomplicated my solution by using bitmasking and memoization. You don\\'t need any of these for this problem :)"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Hate to say it but with N<=8 isn\\'t this question easy? "
                    },
                    {
                        "username": "a8hi",
                        "content": "LeetCode Daily Has been Real Kind"
                    }
                ]
            },
            {
                "id": 2000895,
                "content": [
                    {
                        "username": "charant587",
                        "content": "I got up with dfs approach after think for an 20 minutes can we use dp for this????"
                    },
                    {
                        "username": "KirtanMakwana",
                        "content": "why unordered_map giving error and map doesnt? while memoization."
                    },
                    {
                        "username": "unters",
                        "content": "`std::unordered_map` organizes its elements using a hash table. This imposes requirements on the key-type:\n\n1. default hash functor `std::hash<>` must be specialized for key-type (there is no such requirement when using `std::map`);\n\n2. A comparison function for equality must be defined for key-type (when using `std::map` the equivalent requirement is that keys must be comparable).\n\nI guess you use a user-defined key-type that has no `std::hash<>` specialization, but that has comparison functions."
                    },
                    {
                        "username": "ahmed___",
                        "content": "Medium??"
                    },
                    {
                        "username": "algoacer",
                        "content": "call to implicitly-deleted default constructor of \\'Solution\\'.  Generate the required memo dp within the generate Trees function. Congrats on completing such an interesting problem."
                    },
                    {
                        "username": "dikshawali",
                        "content": "My solution is beating only 5% of users. \\n1. I have used DP\\n2. Despite having recursive solution, my program is having n3 time complexity.\\ncan anyone suggest ways to decrease time complexity?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Write a helper _generateTrees method that takes in two parameters: the min and the max then use it recursively to generate the subtrees.\\n\\nThe loop looks like:\\n```\\nfor i in min to max:\\n   leftTrees = generateTrees(min, i - 1)\\n   rightTrees = generateTrees(i + 1, max)\\n   // combine left and right subtrees using a double for loop\\nreturn\\n```\\n\\n"
                    },
                    {
                        "username": "sarvesh_mankar",
                        "content": "If you are finding this challenge really tough then try out [Leetcode Challenge 96](https://leetcode.com/problems/unique-binary-search-trees/) first! It will help you in developing this solution."
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "dkochetov",
                        "content": "I overcomplicated my solution by using bitmasking and memoization. You don\\'t need any of these for this problem :)"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Hate to say it but with N<=8 isn\\'t this question easy? "
                    },
                    {
                        "username": "a8hi",
                        "content": "LeetCode Daily Has been Real Kind"
                    }
                ]
            },
            {
                "id": 2000783,
                "content": [
                    {
                        "username": "charant587",
                        "content": "I got up with dfs approach after think for an 20 minutes can we use dp for this????"
                    },
                    {
                        "username": "KirtanMakwana",
                        "content": "why unordered_map giving error and map doesnt? while memoization."
                    },
                    {
                        "username": "unters",
                        "content": "`std::unordered_map` organizes its elements using a hash table. This imposes requirements on the key-type:\n\n1. default hash functor `std::hash<>` must be specialized for key-type (there is no such requirement when using `std::map`);\n\n2. A comparison function for equality must be defined for key-type (when using `std::map` the equivalent requirement is that keys must be comparable).\n\nI guess you use a user-defined key-type that has no `std::hash<>` specialization, but that has comparison functions."
                    },
                    {
                        "username": "ahmed___",
                        "content": "Medium??"
                    },
                    {
                        "username": "algoacer",
                        "content": "call to implicitly-deleted default constructor of \\'Solution\\'.  Generate the required memo dp within the generate Trees function. Congrats on completing such an interesting problem."
                    },
                    {
                        "username": "dikshawali",
                        "content": "My solution is beating only 5% of users. \\n1. I have used DP\\n2. Despite having recursive solution, my program is having n3 time complexity.\\ncan anyone suggest ways to decrease time complexity?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Write a helper _generateTrees method that takes in two parameters: the min and the max then use it recursively to generate the subtrees.\\n\\nThe loop looks like:\\n```\\nfor i in min to max:\\n   leftTrees = generateTrees(min, i - 1)\\n   rightTrees = generateTrees(i + 1, max)\\n   // combine left and right subtrees using a double for loop\\nreturn\\n```\\n\\n"
                    },
                    {
                        "username": "sarvesh_mankar",
                        "content": "If you are finding this challenge really tough then try out [Leetcode Challenge 96](https://leetcode.com/problems/unique-binary-search-trees/) first! It will help you in developing this solution."
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "dkochetov",
                        "content": "I overcomplicated my solution by using bitmasking and memoization. You don\\'t need any of these for this problem :)"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Hate to say it but with N<=8 isn\\'t this question easy? "
                    },
                    {
                        "username": "a8hi",
                        "content": "LeetCode Daily Has been Real Kind"
                    }
                ]
            },
            {
                "id": 2000771,
                "content": [
                    {
                        "username": "charant587",
                        "content": "I got up with dfs approach after think for an 20 minutes can we use dp for this????"
                    },
                    {
                        "username": "KirtanMakwana",
                        "content": "why unordered_map giving error and map doesnt? while memoization."
                    },
                    {
                        "username": "unters",
                        "content": "`std::unordered_map` organizes its elements using a hash table. This imposes requirements on the key-type:\n\n1. default hash functor `std::hash<>` must be specialized for key-type (there is no such requirement when using `std::map`);\n\n2. A comparison function for equality must be defined for key-type (when using `std::map` the equivalent requirement is that keys must be comparable).\n\nI guess you use a user-defined key-type that has no `std::hash<>` specialization, but that has comparison functions."
                    },
                    {
                        "username": "ahmed___",
                        "content": "Medium??"
                    },
                    {
                        "username": "algoacer",
                        "content": "call to implicitly-deleted default constructor of \\'Solution\\'.  Generate the required memo dp within the generate Trees function. Congrats on completing such an interesting problem."
                    },
                    {
                        "username": "dikshawali",
                        "content": "My solution is beating only 5% of users. \\n1. I have used DP\\n2. Despite having recursive solution, my program is having n3 time complexity.\\ncan anyone suggest ways to decrease time complexity?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Write a helper _generateTrees method that takes in two parameters: the min and the max then use it recursively to generate the subtrees.\\n\\nThe loop looks like:\\n```\\nfor i in min to max:\\n   leftTrees = generateTrees(min, i - 1)\\n   rightTrees = generateTrees(i + 1, max)\\n   // combine left and right subtrees using a double for loop\\nreturn\\n```\\n\\n"
                    },
                    {
                        "username": "sarvesh_mankar",
                        "content": "If you are finding this challenge really tough then try out [Leetcode Challenge 96](https://leetcode.com/problems/unique-binary-search-trees/) first! It will help you in developing this solution."
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "dkochetov",
                        "content": "I overcomplicated my solution by using bitmasking and memoization. You don\\'t need any of these for this problem :)"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Hate to say it but with N<=8 isn\\'t this question easy? "
                    },
                    {
                        "username": "a8hi",
                        "content": "LeetCode Daily Has been Real Kind"
                    }
                ]
            },
            {
                "id": 2000707,
                "content": [
                    {
                        "username": "charant587",
                        "content": "I got up with dfs approach after think for an 20 minutes can we use dp for this????"
                    },
                    {
                        "username": "KirtanMakwana",
                        "content": "why unordered_map giving error and map doesnt? while memoization."
                    },
                    {
                        "username": "unters",
                        "content": "`std::unordered_map` organizes its elements using a hash table. This imposes requirements on the key-type:\n\n1. default hash functor `std::hash<>` must be specialized for key-type (there is no such requirement when using `std::map`);\n\n2. A comparison function for equality must be defined for key-type (when using `std::map` the equivalent requirement is that keys must be comparable).\n\nI guess you use a user-defined key-type that has no `std::hash<>` specialization, but that has comparison functions."
                    },
                    {
                        "username": "ahmed___",
                        "content": "Medium??"
                    },
                    {
                        "username": "algoacer",
                        "content": "call to implicitly-deleted default constructor of \\'Solution\\'.  Generate the required memo dp within the generate Trees function. Congrats on completing such an interesting problem."
                    },
                    {
                        "username": "dikshawali",
                        "content": "My solution is beating only 5% of users. \\n1. I have used DP\\n2. Despite having recursive solution, my program is having n3 time complexity.\\ncan anyone suggest ways to decrease time complexity?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Write a helper _generateTrees method that takes in two parameters: the min and the max then use it recursively to generate the subtrees.\\n\\nThe loop looks like:\\n```\\nfor i in min to max:\\n   leftTrees = generateTrees(min, i - 1)\\n   rightTrees = generateTrees(i + 1, max)\\n   // combine left and right subtrees using a double for loop\\nreturn\\n```\\n\\n"
                    },
                    {
                        "username": "sarvesh_mankar",
                        "content": "If you are finding this challenge really tough then try out [Leetcode Challenge 96](https://leetcode.com/problems/unique-binary-search-trees/) first! It will help you in developing this solution."
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "dkochetov",
                        "content": "I overcomplicated my solution by using bitmasking and memoization. You don\\'t need any of these for this problem :)"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Hate to say it but with N<=8 isn\\'t this question easy? "
                    },
                    {
                        "username": "a8hi",
                        "content": "LeetCode Daily Has been Real Kind"
                    }
                ]
            },
            {
                "id": 2000698,
                "content": [
                    {
                        "username": "charant587",
                        "content": "I got up with dfs approach after think for an 20 minutes can we use dp for this????"
                    },
                    {
                        "username": "KirtanMakwana",
                        "content": "why unordered_map giving error and map doesnt? while memoization."
                    },
                    {
                        "username": "unters",
                        "content": "`std::unordered_map` organizes its elements using a hash table. This imposes requirements on the key-type:\n\n1. default hash functor `std::hash<>` must be specialized for key-type (there is no such requirement when using `std::map`);\n\n2. A comparison function for equality must be defined for key-type (when using `std::map` the equivalent requirement is that keys must be comparable).\n\nI guess you use a user-defined key-type that has no `std::hash<>` specialization, but that has comparison functions."
                    },
                    {
                        "username": "ahmed___",
                        "content": "Medium??"
                    },
                    {
                        "username": "algoacer",
                        "content": "call to implicitly-deleted default constructor of \\'Solution\\'.  Generate the required memo dp within the generate Trees function. Congrats on completing such an interesting problem."
                    },
                    {
                        "username": "dikshawali",
                        "content": "My solution is beating only 5% of users. \\n1. I have used DP\\n2. Despite having recursive solution, my program is having n3 time complexity.\\ncan anyone suggest ways to decrease time complexity?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Write a helper _generateTrees method that takes in two parameters: the min and the max then use it recursively to generate the subtrees.\\n\\nThe loop looks like:\\n```\\nfor i in min to max:\\n   leftTrees = generateTrees(min, i - 1)\\n   rightTrees = generateTrees(i + 1, max)\\n   // combine left and right subtrees using a double for loop\\nreturn\\n```\\n\\n"
                    },
                    {
                        "username": "sarvesh_mankar",
                        "content": "If you are finding this challenge really tough then try out [Leetcode Challenge 96](https://leetcode.com/problems/unique-binary-search-trees/) first! It will help you in developing this solution."
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "dkochetov",
                        "content": "I overcomplicated my solution by using bitmasking and memoization. You don\\'t need any of these for this problem :)"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Hate to say it but with N<=8 isn\\'t this question easy? "
                    },
                    {
                        "username": "a8hi",
                        "content": "LeetCode Daily Has been Real Kind"
                    }
                ]
            },
            {
                "id": 2000494,
                "content": [
                    {
                        "username": "charant587",
                        "content": "I got up with dfs approach after think for an 20 minutes can we use dp for this????"
                    },
                    {
                        "username": "KirtanMakwana",
                        "content": "why unordered_map giving error and map doesnt? while memoization."
                    },
                    {
                        "username": "unters",
                        "content": "`std::unordered_map` organizes its elements using a hash table. This imposes requirements on the key-type:\n\n1. default hash functor `std::hash<>` must be specialized for key-type (there is no such requirement when using `std::map`);\n\n2. A comparison function for equality must be defined for key-type (when using `std::map` the equivalent requirement is that keys must be comparable).\n\nI guess you use a user-defined key-type that has no `std::hash<>` specialization, but that has comparison functions."
                    },
                    {
                        "username": "ahmed___",
                        "content": "Medium??"
                    },
                    {
                        "username": "algoacer",
                        "content": "call to implicitly-deleted default constructor of \\'Solution\\'.  Generate the required memo dp within the generate Trees function. Congrats on completing such an interesting problem."
                    },
                    {
                        "username": "dikshawali",
                        "content": "My solution is beating only 5% of users. \\n1. I have used DP\\n2. Despite having recursive solution, my program is having n3 time complexity.\\ncan anyone suggest ways to decrease time complexity?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Write a helper _generateTrees method that takes in two parameters: the min and the max then use it recursively to generate the subtrees.\\n\\nThe loop looks like:\\n```\\nfor i in min to max:\\n   leftTrees = generateTrees(min, i - 1)\\n   rightTrees = generateTrees(i + 1, max)\\n   // combine left and right subtrees using a double for loop\\nreturn\\n```\\n\\n"
                    },
                    {
                        "username": "sarvesh_mankar",
                        "content": "If you are finding this challenge really tough then try out [Leetcode Challenge 96](https://leetcode.com/problems/unique-binary-search-trees/) first! It will help you in developing this solution."
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "dkochetov",
                        "content": "I overcomplicated my solution by using bitmasking and memoization. You don\\'t need any of these for this problem :)"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Hate to say it but with N<=8 isn\\'t this question easy? "
                    },
                    {
                        "username": "a8hi",
                        "content": "LeetCode Daily Has been Real Kind"
                    }
                ]
            }
        ]
    },
    {
        "title": "Tenth Line",
        "question_content": "<p>Given a text file&nbsp;<code>file.txt</code>, print&nbsp;just the 10th line of the&nbsp;file.</p>\r\n\r\n<p><strong class=\"example\">Example:</strong></p>\r\n\r\n<p>Assume that <code>file.txt</code> has the following content:</p>\r\n\r\n<pre>\r\nLine 1\r\nLine 2\r\nLine 3\r\nLine 4\r\nLine 5\r\nLine 6\r\nLine 7\r\nLine 8\r\nLine 9\r\nLine 10\r\n</pre>\r\n\r\n<p>Your script should output the tenth line, which is:</p>\r\n\r\n<pre>\r\nLine 10\r\n</pre>\r\n\r\n<div class=\"spoilers\"><b>Note:</b><br />\r\n1. If the file contains less than 10 lines, what should you output?<br />\r\n2. There&#39;s at least three different solutions. Try to explore all possibilities.</div>\r\n",
        "solutions": [
            {
                "id": 55544,
                "title": "share-four-different-solutions",
                "content": "\\n    # Solution 1\\n    cnt=0\\n    while read line && [ $cnt -le 10 ]; do\\n      let 'cnt = cnt + 1'\\n      if [ $cnt -eq 10 ]; then\\n        echo $line\\n        exit 0\\n      fi\\n    done < file.txt\\n\\n    # Solution 2\\n    awk 'FNR == 10 {print }'  file.txt\\n    # OR\\n    awk 'NR == 10' file.txt\\n\\n    # Solution 3\\n    sed -n 10p file.txt\\n\\n    # Solution 4\\n    tail -n+10 file.txt|head -1",
                "solutionTags": [],
                "code": "\\n    # Solution 1\\n    cnt=0\\n    while read line && [ $cnt -le 10 ]; do\\n      let 'cnt = cnt + 1'\\n      if [ $cnt -eq 10 ]; then\\n        echo $line\\n        exit 0\\n      fi\\n    done < file.txt\\n\\n    # Solution 2\\n    awk 'FNR == 10 {print }'  file.txt\\n    # OR\\n    awk 'NR == 10' file.txt\\n\\n    # Solution 3\\n    sed -n 10p file.txt\\n\\n    # Solution 4\\n    tail -n+10 file.txt|head -1",
                "codeTag": "Unknown"
            },
            {
                "id": 55537,
                "title": "my-three-simple-solutions",
                "content": "    # Read from the file file.txt and output the tenth line to stdout.\\n    \\n    #Solution One:\\n    #head -n 10 file.txt | tail -n +10\\n    \\n    #Solution Two:\\n    #awk 'NR==10' file.txt\\n    \\n    #Solution Three:\\n    sed -n 10p file.txt",
                "solutionTags": [],
                "code": "    # Read from the file file.txt and output the tenth line to stdout.\\n    \\n    #Solution One:\\n    #head -n 10 file.txt | tail -n +10\\n    \\n    #Solution Two:\\n    #awk 'NR==10' file.txt\\n    \\n    #Solution Three:\\n    sed -n 10p file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 3218908,
                "title": "195-solution-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nExplanation:\\n\\n- The sed command is used to edit a stream of text, and -n option is used to suppress the output.\\n- The 10p command prints only the 10th line of the input file. So, \\'10p\\' prints the 10th line.\\n\\nNote:\\n\\n- If the file has less than 10 lines, then the script will output nothing.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nThis can be solved using the sed command. Here\\'s a one-liner bash script that accomplishes this:\\n\\n```\\nsed -n \\'10p\\' file.txt\\n\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\nsed -n \\'10p\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2281857,
                "title": "easy-explaination-with-1-line-code",
                "content": "```\\nawk \\'NR==10\\' file.txt\\n```\\nHere awk is the build in function which is used to manipulate files, to extract data from files, NR is used for No. of Records which are usually no. of lines in the file. \\nfile.txt is the input file which has to be read.",
                "solutionTags": [],
                "code": "```\\nawk \\'NR==10\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2693040,
                "title": "4-solutions-easy-understanding",
                "content": "**Solution 1**\\n```\\ncnt=0\\nwhile read line && [ $cnt -le 10 ]; do\\n  let \\'cnt = cnt + 1\\'\\n  if [ $cnt -eq 10 ]; then\\n    echo $line\\n    exit 0\\n  fi\\ndone < file.txt\\n```\\n\\n\\n**Solution 2**\\n\\n`awk \\'FNR == 10 {print }\\'  file.txt`\\n \\n**(*Another way of writing*)**\\n\\n```\\nawk \\'NR == 10\\' file.txt\\n```\\n\\n**Solution3**\\n```\\n\\nsed -n 10p file.txt\\n```\\n\\n**Solution 4**\\n\\n```\\n\\ntail -n+10 file.txt|head -1\\n```",
                "solutionTags": [],
                "code": "```\\ncnt=0\\nwhile read line && [ $cnt -le 10 ]; do\\n  let \\'cnt = cnt + 1\\'\\n  if [ $cnt -eq 10 ]; then\\n    echo $line\\n    exit 0\\n  fi\\ndone < file.txt\\n```\n```\\nawk \\'NR == 10\\' file.txt\\n```\n```\\n\\nsed -n 10p file.txt\\n```\n```\\n\\ntail -n+10 file.txt|head -1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 559470,
                "title": "bash-summarize-a-few-solutions",
                "content": "It is natural to consider `head -10 file.txt | tail -1` as the candidate which cannot output the 10th line if the file has fewer than 10 lines. But it can be easily fixed as below. \\n```\\ntail -n+10 file.txt | head -1\\n```\\n\\nAlternatively, `sed`, `awk`, `cut` and `mapfile` can do the job as well (e.g. below)\\n```\\nsed -n \\'10p\\' file.txt\\n```\\n\\n```\\ncut -f10 -d$\\'\\\\n\\' file.txt\\n```\\n\\n```\\nawk \\'NR==10\\' file.txt\\n```\\n\\n```\\nmapfile -s 9 -n 1 array < file.txt\\necho \"${array[0]}\" | head -1\\n```\\n\\nLast but not least, the most flexible solution would be writing ones own script. \\n```\\nno=0                                                                  \\nwhile IFS= read -r line                                               \\ndo                                                                        \\n    ((no=$no+1))\\n    if [[ $no -eq 10 ]]                                                   \\n    then                                                                      \\n        echo $line\\n\\t\\tbreak\\n    fi                                                                \\ndone < \"file.txt\"    \\n```",
                "solutionTags": [],
                "code": "```\\ntail -n+10 file.txt | head -1\\n```\n```\\nsed -n \\'10p\\' file.txt\\n```\n```\\ncut -f10 -d$\\'\\\\n\\' file.txt\\n```\n```\\nawk \\'NR==10\\' file.txt\\n```\n```\\nmapfile -s 9 -n 1 array < file.txt\\necho \"${array[0]}\" | head -1\\n```\n```\\nno=0                                                                  \\nwhile IFS= read -r line                                               \\ndo                                                                        \\n    ((no=$no+1))\\n    if [[ $no -eq 10 ]]                                                   \\n    then                                                                      \\n        echo $line\\n\\t\\tbreak\\n    fi                                                                \\ndone < \"file.txt\"    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1831670,
                "title": "python-one-liner-abomination",
                "content": "```\\npython3 -c \\'a = [l for l in open(\"file.txt\")]; print(\"\" if len(a) < 10 else a[9].strip())\\'\\n```",
                "solutionTags": [],
                "code": "```\\npython3 -c \\'a = [l for l in open(\"file.txt\")]; print(\"\" if len(a) < 10 else a[9].strip())\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1772093,
                "title": "tenth-line",
                "content": "```\\nsed -n 10p file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nsed -n 10p file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2053537,
                "title": "simple-solution-without-using-sed-and-awk",
                "content": "Super Simple Solution....\\nUpvote it, if you like it....\\n\\n```\\na=`cat file.txt | wc -l`\\nb=9\\nif [[ $a -gt 9 ]]\\nthen\\n{\\ncat file.txt | head -n 10 | tail -n 1\\n}\\nfi\\n```",
                "solutionTags": [],
                "code": "```\\na=`cat file.txt | wc -l`\\nb=9\\nif [[ $a -gt 9 ]]\\nthen\\n{\\ncat file.txt | head -n 10 | tail -n 1\\n}\\nfi\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2241809,
                "title": "two-line-bash-code-solution",
                "content": "**Solution -**\\n1. Read first 10 lines from the file into an array.\\n2. Print the value of 10th index of the array.\\n\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\n#!/bin/bash\\n\\nreadarray -n 10 -t arr < \\'file.txt\\' && echo \"${arr[9]}\"\\n```\\n\\nHope it is helpful to you. Please upvote, thank you.",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n#!/bin/bash\\n\\nreadarray -n 10 -t arr < \\'file.txt\\' && echo \"${arr[9]}\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 766136,
                "title": "simple-of-simple",
                "content": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\nindex=0\\ncat file.txt | while read line\\ndo\\n    index=$index+1\\n    if [[ index -eq 10 ]]; then\\n        echo $line\\n        break\\n    fi\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\nindex=0\\ncat file.txt | while read line\\ndo\\n    index=$index+1\\n    if [[ index -eq 10 ]]; then\\n        echo $line\\n        break\\n    fi\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3471767,
                "title": "solution-with-sed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1620364,
                "title": "head-tail-trick",
                "content": "```\\nhead -n 10 file.txt | tail -n +10\\n```\\n\\nI\\'m sure someone already posted this, but....\\n\\n1) Pass file.txt through head, getting only 10 lines.\\n2) Pipe output of head to tail, getting everything from 10th line (which should just be the 10th line).\\n",
                "solutionTags": [],
                "code": "```\\nhead -n 10 file.txt | tail -n +10\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2252727,
                "title": "simple-bash-solution",
                "content": "```\\nsed -n \\'10p\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nsed -n \\'10p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1476608,
                "title": "84-11-faster-than-all-submissions-with-head-tail-command",
                "content": "```\\n head -n 10 file.txt | tail -n +10\\n ```",
                "solutionTags": [],
                "code": "```\\n head -n 10 file.txt | tail -n +10\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1276426,
                "title": "a-few-solutions",
                "content": "`tail -n +10 file.txt | head -1`\\n`sed -n \\'10p\\' file.txt`\\n`awk \\'NR == 10\\' file.txt`\\n```\\n#!/usr/bin/bash\\ni=0 \\nwhile IFS= read -r l; do \\n        (( ++i == 10 )) && { \\n                echo \"$l\"\\n                exit 0\\n        } \\ndone <file.txt\\n```",
                "solutionTags": [],
                "code": "```\\n#!/usr/bin/bash\\ni=0 \\nwhile IFS= read -r l; do \\n        (( ++i == 10 )) && { \\n                echo \"$l\"\\n                exit 0\\n        } \\ndone <file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1185039,
                "title": "pure-bash-solution",
                "content": "```\\n#Read from the file file.txt and output the tenth line to stdout.\\nline=0\\nwhile read l; do\\n    line=$(($line+1))\\n    if [[ $line -eq 10 ]]; then\\n        echo $l;\\n        exit;\\n    fi;\\ndone < file.txt\\necho \"\";\\n```\\n",
                "solutionTags": [],
                "code": "```\\n#Read from the file file.txt and output the tenth line to stdout.\\nline=0\\nwhile read l; do\\n    line=$(($line+1))\\n    if [[ $line -eq 10 ]]; then\\n        echo $l;\\n        exit;\\n    fi;\\ndone < file.txt\\necho \"\";\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1170820,
                "title": "100-faster-easy-solution",
                "content": "```\\nsed -n 10p file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nsed -n 10p file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1115189,
                "title": "simple-solution-with-head-and-tac",
                "content": "Here\\'s my simple solution with `head` and `tac` commands (inverse of `cat`)\\n```\\nhead file.txt | tac | head -n -9\\n```",
                "solutionTags": [],
                "code": "```\\nhead file.txt | tac | head -n -9\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 962969,
                "title": "pure-bash-solution-for-printing-10th-line",
                "content": "No Awk, Sed, Grep, etc.  Just using straight bash scripting. If there is not at least 10 lines it doesn\\'t produce output and if there are more it just stops after the 10th line.\\n\\n# Read from the file file.txt and output the tenth line to stdout.\\n```\\ni=0\\nwhile IFS= read -r line\\ndo\\n        i=$((i+1))\\n        if [ \"$i\" = \"10\" ]; then\\n                echo \"$line\"\\n                break\\n        fi\\ndone < \"file.txt\"\\n```",
                "solutionTags": [],
                "code": "```\\ni=0\\nwhile IFS= read -r line\\ndo\\n        i=$((i+1))\\n        if [ \"$i\" = \"10\" ]; then\\n                echo \"$line\"\\n                break\\n        fi\\ndone < \"file.txt\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 548822,
                "title": "sed-life",
                "content": "```sed -n \\'10\\'p file.txt```",
                "solutionTags": [],
                "code": "```sed -n \\'10\\'p file.txt```",
                "codeTag": "Unknown"
            },
            {
                "id": 55530,
                "title": "5ms-solution-with-sed-beats-94-of-bash-submissions",
                "content": "```\\ncat file.txt | sed -n '10p'\\n```",
                "solutionTags": [],
                "code": "```\\ncat file.txt | sed -n '10p'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3467822,
                "title": "awk-using-nr",
                "content": "# Code\\n```bash\\nawk \\'NR == 10\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```bash\\nawk \\'NR == 10\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2887437,
                "title": "java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nsed \"10q;d\" file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nsed \"10q;d\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2583193,
                "title": "shell-simple-sed-command",
                "content": "```\\nsed -n 10p file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nsed -n 10p file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2552849,
                "title": "simple-solution-using-awk",
                "content": "```\\nawk \\'NR==10\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'NR==10\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2403178,
                "title": "solution-with-head-and-tail-commands-only",
                "content": "```\\nhead -10 file.txt | tail +10\\n```",
                "solutionTags": [],
                "code": "```\\nhead -10 file.txt | tail +10\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1981678,
                "title": "awk-is-the-fastest",
                "content": "```bash\\n# Read from the file file.txt and output the tenth line to stdout.\\n# cat file.txt | tail -n +10 | head -n 1\\n# sed -n \\'10, 10p\\' file.txt\\nawk \\'NR==10\\' file.txt\\n# tail -n +10 file.txt | head -1\\n```\\n- `awk` 34ms faster than 74.46%",
                "solutionTags": [],
                "code": "```bash\\n# Read from the file file.txt and output the tenth line to stdout.\\n# cat file.txt | tail -n +10 | head -n 1\\n# sed -n \\'10, 10p\\' file.txt\\nawk \\'NR==10\\' file.txt\\n# tail -n +10 file.txt | head -1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1963643,
                "title": "simple",
                "content": "![image](https://assets.leetcode.com/users/images/8bdd47a4-f42a-4b9c-a4f0-7f943da59c5c_1650369964.0566795.png)\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed \\'10!d\\' file.txt",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/8bdd47a4-f42a-4b9c-a4f0-7f943da59c5c_1650369964.0566795.png)\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed \\'10!d\\' file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 1385684,
                "title": "pure-bash-and-easy-to-understand",
                "content": "```\\ni=0\\nwhile (( i++ < 10 ))\\ndo\\n  read line\\ndone < file.txt\\necho $line\\n```",
                "solutionTags": [],
                "code": "```\\ni=0\\nwhile (( i++ < 10 ))\\ndo\\n  read line\\ndone < file.txt\\necho $line\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 750564,
                "title": "solution-with-only-sed",
                "content": "```\\nsed -n 10p file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nsed -n 10p file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 653221,
                "title": "simple-using-head-tail",
                "content": "\\n\\n```tail -n +10 file.txt | head -1 || exit```",
                "solutionTags": [],
                "code": "```tail -n +10 file.txt | head -1 || exit```",
                "codeTag": "Unknown"
            },
            {
                "id": 549890,
                "title": "new-to-bash-solution-beats-73",
                "content": "Only started learning bash recently, accepting constructive criticism:\\n```\\ni=$((0))\\nwhile read -r || [[ $REPLY ]]; do\\n    i=$(($i + 1))\\n    if [[ $i -eq 10 ]]; then\\n        echo $REPLY\\n    fi\\ndone < file.txt",
                "solutionTags": [],
                "code": "Only started learning bash recently, accepting constructive criticism:\\n```\\ni=$((0))\\nwhile read -r || [[ $REPLY ]]; do\\n    i=$(($i + 1))\\n    if [[ $i -eq 10 ]]; then\\n        echo $REPLY\\n    fi\\ndone < file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 440631,
                "title": "sed",
                "content": "```bash\\nsed -n 10p file.txt\\n```",
                "solutionTags": [],
                "code": "```bash\\nsed -n 10p file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 435778,
                "title": "my-solutions",
                "content": "One line with awk:\\n```bash\\nawk \\'{if(NR==10){print;exit}}\\' file.txt\\n```\\nOne line with sed, which is faster:\\n```bash\\nsed -n 10p file.txt\\n```\\nBut the fastest is to avoid spawning extra processes:\\n```bash\\nwhile read -r line; do\\n\\ti=$((i+1))\\n\\tif [ $i -eq 10 ]; then\\n\\t\\techo \"$line\"\\n\\t\\tbreak\\n\\tfi\\ndone <file.txt\\n```\\n",
                "solutionTags": [],
                "code": "```bash\\nawk \\'{if(NR==10){print;exit}}\\' file.txt\\n```\n```bash\\nsed -n 10p file.txt\\n```\n```bash\\nwhile read -r line; do\\n\\ti=$((i+1))\\n\\tif [ $i -eq 10 ]; then\\n\\t\\techo \"$line\"\\n\\t\\tbreak\\n\\tfi\\ndone <file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 355296,
                "title": "very-simple-method-using-sed",
                "content": "```\\nsed -n \"10p\" file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nsed -n \"10p\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 285925,
                "title": "1-line-faster-than-100",
                "content": "```\\ntail -n +10 file.txt | head -1\\n```",
                "solutionTags": [],
                "code": "```\\ntail -n +10 file.txt | head -1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55531,
                "title": "a-very-simple-solution-using-cut",
                "content": "```\\ncat file.txt | cut -d $'\\\\n' -f 10\\n```",
                "solutionTags": [],
                "code": "```\\ncat file.txt | cut -d $'\\\\n' -f 10\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55546,
                "title": "12-ms-awk-based-solution",
                "content": "This is all it takes. I tried to do the same thing with sed, but I couldn't remember how to do it with sed.\\n\\n    awk 'NR == 10' < file.txt\\n\\nGiven that the awk binary is slightly larger than the sed binary on my box I wonder if I'll get better runtime using sed, since some of the runtime will be affected by loading that binary before executing it. But given that those binaries are so small (on my OS X box), I wonder if it will make a difference.\\n\\n    panzani leetcode$ which sed\\n    /usr/bin/sed\\n    panzani leetcode$ du -h /usr/bin/sed\\n     20K\\t/usr/bin/sed\\n    panzani leetcode$ which awk \\n    /usr/bin/awk\\n    panzani leetcode$ du -h /usr/bin/awk \\n     52K\\t/usr/bin/awk",
                "solutionTags": [],
                "code": "This is all it takes. I tried to do the same thing with sed, but I couldn't remember how to do it with sed.\\n\\n    awk 'NR == 10' < file.txt\\n\\nGiven that the awk binary is slightly larger than the sed binary on my box I wonder if I'll get better runtime using sed, since some of the runtime will be affected by loading that binary before executing it. But given that those binaries are so small (on my OS X box), I wonder if it will make a difference.\\n\\n    panzani leetcode$ which sed\\n    /usr/bin/sed\\n    panzani leetcode$ du -h /usr/bin/sed\\n     20K\\t/usr/bin/sed\\n    panzani leetcode$ which awk \\n    /usr/bin/awk\\n    panzani leetcode$ du -h /usr/bin/awk \\n     52K\\t/usr/bin/awk",
                "codeTag": "Unknown"
            },
            {
                "id": 3918925,
                "title": "print-tenth-line",
                "content": "# Approach\\n Uses simple while loop to read the file line by line\\n\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nn=1;\\nwhile read line ;\\ndo\\n    if [  $n -eq 10  ]; then\\n        echo \"$line\"\\n    fi\\n    n=$((n+1));\\ndone < file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nn=1;\\nwhile read line ;\\ndo\\n    if [  $n -eq 10  ]; then\\n        echo \"$line\"\\n    fi\\n    n=$((n+1));\\ndone < file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3801067,
                "title": "using-simple-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfile=\"file.txt\"\\ni=1;\\nfor i in {1..10} ; do\\nread line\\n\\tif [ $i == 10 ];\\n\\tthen\\n\\t\\techo $line;\\n    break\\n\\tfi\\n\\t#i=$((i+1))\\ndone < $file;\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nfile=\"file.txt\"\\ni=1;\\nfor i in {1..10} ; do\\nread line\\n\\tif [ $i == 10 ];\\n\\tthen\\n\\t\\techo $line;\\n    break\\n\\tfi\\n\\t#i=$((i+1))\\ndone < $file;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3775483,
                "title": "pure-bash-3-lines-runtime-25-ms-beats-98-31",
                "content": "# Intuition\\nYou don\\'t need to use a for loop to iterate through every line and a counter variable to print the 10th line or empty line if input was less than 10 lines. You also do not need any external tools such as wc or sed (we do use echo in the winning example).\\n\\n# Approach\\nIf you know anything about how iterative arrays (numerical arrays) work in bash, if an array value is not initialized, it will evaluate to empty string and this in conjunction with echo (or printf) will print a newline.\\n\\nUsing the \\'-t\\' flag strips newlines which eliminates the possibility to add a 2nd newline if it read more than 10 lines from file.txt\\n\\nUsing \\'-n\\' flag with the argument \\'10\\' means it will only read a maximum of 10 lines. Because of this, the program runs in constant time (which is still slow because bash is \"too big and too slow\" -- known feature of bash).\\n\\nRemember, iterative arrays are 0-based.\\n\\n\"printf\" is a bash builtin which will work without requiring the use of echo (which is a separate binary and usually part of coreutils), but no runtime advantage was found for the second example.\\n\\nAlso, the declare statements are optional, they are only added for clarity.\\n\\nFor more information on bash...\\n\\nRead the bash manual here https://www.man7.org/linux/man-pages/man7/man.7.html if you are not on a system with online documentation and scroll down to the section for \"mapfile\" / \"readarray\".\\n\\nUse the LeetCode editor to test out your scripts if you don\\'t have bash on your OS. It should be on most Linux distros e.g. Ubuntu (typical distro used with Windows 10/11 and WSL). Otherwise it would be available in Windows 10/11 via Cygwin/MSYS2. Early versions of OS X should have it as the default shell, otherwise you would have to install it with MacPorts or Homebrew.\\n\\nSee examples here https://linuxopsys.com/topics/bash-readarray-with-examples\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\nWinning example using only echo\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\ndeclare -a lines\\nreadarray -n10 -t lines <file.txt\\necho ${lines[9]}\\n```\\n2nd example using pure bash\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\ndeclare -a lines\\nreadarray -n10 -t lines <file.txt\\nprintf \"${lines[9]}\\\\\\\\n\"\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\ndeclare -a lines\\nreadarray -n10 -t lines <file.txt\\necho ${lines[9]}\\n```\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\ndeclare -a lines\\nreadarray -n10 -t lines <file.txt\\nprintf \"${lines[9]}\\\\\\\\n\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3519938,
                "title": "single-line-solution",
                "content": "\\n# Code\\n```\\nsed -n \\'10p\\' file.txt\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\nsed -n \\'10p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3519746,
                "title": "easy-and-simple-solution-with-explanation-wow-0-0",
                "content": "\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n\\n```\\nThis command uses the sed command to print the 10th line of the file. The -n option is used to suppress the default output and \\'10p\\' is used to print the 10th line of the file. Replace file.txt with your file name.",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2525104,
                "title": "tail-head-command-with-explanation",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com\\nIt is very useful, and I just wanted to share it with you.\\nNote: You can bookmark it as a resource, and for another approaches\\n<br>\\n\\n```\\ntail -n+10 file.txt | head -n1\\n```\\n\\nFor explanation please refer\\nhttps://leet-codes.blogspot.com/2022/09/195-tenth-line.html",
                "solutionTags": [],
                "code": "```\\ntail -n+10 file.txt | head -n1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2400814,
                "title": "2-easy-solution-in-bash",
                "content": "# awk \\'NR == 10\\' file.txt\\n**-----------------------------------------------------------------------------**\\n# tail -n+10 file.txt | head -n1",
                "solutionTags": [],
                "code": "# awk \\'NR == 10\\' file.txt\\n**-----------------------------------------------------------------------------**\\n# tail -n+10 file.txt | head -n1",
                "codeTag": "Unknown"
            },
            {
                "id": 2242237,
                "title": "solution-for-tenth-line-problem",
                "content": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\n# variable for counting lines\\ncounter=1\\n\\n# read file\\'s lines iteratively\\nwhile read -r line; do\\n\\n# print the 10th line \\nif [[ $counter -eq 10 ]]\\n    then echo $line\\nfi\\n\\n# incremenet counter after reading each line\\ncounter=$counter+1\\n\\ndone < file.txt\\n```",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\n# variable for counting lines\\ncounter=1\\n\\n# read file\\'s lines iteratively\\nwhile read -r line; do\\n\\n# print the 10th line \\nif [[ $counter -eq 10 ]]\\n    then echo $line\\nfi\\n\\n# incremenet counter after reading each line\\ncounter=$counter+1\\n\\ndone < file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2191372,
                "title": "simple-sed",
                "content": "# Simple Bash Script with sed \\n```bash\\nsed -n \\'10{p;q;}\\' file.text\\n```\\n\\nwill solve the error",
                "solutionTags": [],
                "code": "```bash\\nsed -n \\'10{p;q;}\\' file.text\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2081103,
                "title": "used-cat-head-wc-tail-59-02-time-81-44-space",
                "content": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nif [[ $(cat file.txt | wc -l) -ge 10 ]]\\nthen \\n    cat file.txt | head -n 10 | tail -n 1\\nfi \\n```",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nif [[ $(cat file.txt | wc -l) -ge 10 ]]\\nthen \\n    cat file.txt | head -n 10 | tail -n 1\\nfi \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2021075,
                "title": "bash-for-loop",
                "content": "\\n```bash\\n# Declare a counter\\ni=0\\n\\n# For each line in the file\\ncat file.txt | while read line; do\\n\\t# 1. Count the line\\n    ((i++))\\n\\n\\t# 2. If we\\'ve reached the 10th line, print\\n    if [[ $i -eq 10 ]]; then\\n        echo $line\\n    fi\\ndone\\n```",
                "solutionTags": [],
                "code": "```bash\\n# Declare a counter\\ni=0\\n\\n# For each line in the file\\ncat file.txt | while read line; do\\n\\t# 1. Count the line\\n    ((i++))\\n\\n\\t# 2. If we\\'ve reached the 10th line, print\\n    if [[ $i -eq 10 ]]; then\\n        echo $line\\n    fi\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2003061,
                "title": "bash-using-sed-with-specific-line",
                "content": "Using `sed` command and specific line number.\\n\\n```\\nsed -n 10p file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nsed -n 10p file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1945847,
                "title": "195-tenth-line",
                "content": "sed -n \\'10p\\' file.txt\\nvar=`sed -n \\'10p\\' file.txt`\\n\\nif [ -z \"$var\" ]\\nthen\\n        printf \"No 10th Line in file.txt\\\\n\"\\nfi",
                "solutionTags": [],
                "code": "sed -n \\'10p\\' file.txt\\nvar=`sed -n \\'10p\\' file.txt`\\n\\nif [ -z \"$var\" ]\\nthen\\n        printf \"No 10th Line in file.txt\\\\n\"\\nfi",
                "codeTag": "Unknown"
            },
            {
                "id": 1857511,
                "title": "super-simple-solution-using-while-loop-and-if",
                "content": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\ncount=1\\nwhile read p; do\\n if [ $count -eq 10 ]\\n then\\n  echo \"$p\"\\nfi\\ncount=`expr $count + 1 `\\ndone <file.txt\\n```",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\ncount=1\\nwhile read p; do\\n if [ $count -eq 10 ]\\n then\\n  echo \"$p\"\\nfi\\ncount=`expr $count + 1 `\\ndone <file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1683730,
                "title": "bash-simple-loop",
                "content": "```\\ni=0\\nwhile IFS= read -r row; do\\n    rows[i++]=\"$row\"\\ndone < file.txt\\necho \"${rows[9]}\"\\n```",
                "solutionTags": [],
                "code": "```\\ni=0\\nwhile IFS= read -r row; do\\n    rows[i++]=\"$row\"\\ndone < file.txt\\necho \"${rows[9]}\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1604416,
                "title": "tenth-line-using-head-tail-and-wc",
                "content": "This problem really frustrated me because it doesn\\'t say what you should print if line 10 doesn\\'t exist. It asks in the notes what you think it should output. Does it want us to print the last line? Turns out they want a blank line. So here\\'s my solution:\\n\\n```\\n[ $(wc -l < file.txt) -ge 10 ] && head -n10 file.txt | tail -n1\\n```",
                "solutionTags": [],
                "code": "```\\n[ $(wc -l < file.txt) -ge 10 ] && head -n10 file.txt | tail -n1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1499350,
                "title": "100-fast-solution",
                "content": "```bash\\n# Count number of lines in file.txt\\nnum=$(wc -l < file.txt)\\ncount=9\\nif [ $num -gt $count ]\\nthen \\n\\thead -n 10 file.txt | tail -n 1\\nelse\\n\\techo \"\"\\nfi\\n```\\n",
                "solutionTags": [],
                "code": "```bash\\n# Count number of lines in file.txt\\nnum=$(wc -l < file.txt)\\ncount=9\\nif [ $num -gt $count ]\\nthen \\n\\thead -n 10 file.txt | tail -n 1\\nelse\\n\\techo \"\"\\nfi\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1280083,
                "title": "one-liner-sed-solution",
                "content": "```\\nsed \\'10q;d\\' file.txt\\n```\\nRuntime: 4 ms, faster than 78.08% of Bash online submissions for Tenth Line.\\nMemory Usage: 3.6 MB, less than 82.55% of Bash online submissions for Tenth Line.",
                "solutionTags": [],
                "code": "```\\nsed \\'10q;d\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1162723,
                "title": "awk-solution",
                "content": "```\\nawk \\'NR == 10\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'NR == 10\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1118595,
                "title": "simple-sol-by-sed-w-comment",
                "content": "Simple sol by \"sed\" \\n\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\n# Only print 10th line from input file\\nsed -n \\'10p\\' file.txt\\n```\\n\\n---\\n\\nDemo:\\n\\n![image](https://assets.leetcode.com/users/images/309f2839-c8f2-427d-8464-92900f1ab836_1616245880.7717433.png)\\n\\n---\\n\\nReference:\\n\\n[1] [Stackexchange: What does `-n` option in sed do?](https://superuser.com/questions/852404/what-does-n-option-in-sed-do)\\n\\n[2] [GNU document about sed](https://www.gnu.org/software/sed/manual/html_node/index.html#SEC_Contents)\\n\\n",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\n# Only print 10th line from input file\\nsed -n \\'10p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1084026,
                "title": "195-easy-solution-with-good-resource",
                "content": "resources: 1. [https://www.unix.com/shell-programming-and-scripting/243138-print-nth-line-file.html](http://)\\n\\t\\t\\t\\t  2. https://stackoverflow.com/questions/20675295/fetch-nth-line-of-a-text-file-using-non-interactive-shell-script\\n\\n\\n```\\nsed -n 10p file.txt\\n```\\n",
                "solutionTags": [],
                "code": "```\\nsed -n 10p file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 762047,
                "title": "simple-solution-with-explanation",
                "content": "**Concatenate(cat)**: command is very frequently used in Linux. It reads data from the file and gives their content as output. It helps us to create, view, concatenate files.\\n\\n**Stream Editor (sed)**: It can perform lot\\u2019s of function on file like, searching, find and replace, insertion or deletion. By using SED you can edit files even without opening it, which is much quicker way to find and replace.\\n\\n**Solution:**\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\ncat file.txt | sed -n 10p\\n```\\n\\nThis solution is suggested by @jmcdonagh\\n```\\nsed -n 10p file.txt\\n```",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\ncat file.txt | sed -n 10p\\n```\n```\\nsed -n 10p file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 625831,
                "title": "wc-head-and-tail",
                "content": "Not the most efficient... I didn\\'t know about the sed trick. But hey, it\\'s a one-liner! :)\\n\\n```(( $(wc -l < file.txt) >= 10 )) && head -10 file.txt | tail -1```",
                "solutionTags": [],
                "code": "```(( $(wc -l < file.txt) >= 10 )) && head -10 file.txt | tail -1```",
                "codeTag": "Unknown"
            },
            {
                "id": 496924,
                "title": "simple-solution-using-shell-parameter-expansion",
                "content": "Simple solution using [Shell Parameter Expansion](https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=2ahUKEwi5lYeNqbLnAhXroosKHe1kCPkQFjAAegQIAhAB&url=https%3A%2F%2Fwww.gnu.org%2Fsoftware%2Fbash%2Fmanual%2Fhtml_node%2FShell-Parameter-Expansion.html&usg=AOvVaw2pT2UtRfrmlSSDB_3HLLVhhttp://)\\n```\\nlines=$(cat file.txt | wc -l)\\nif [ \"${lines%% *}\" -ge 10 ]; then\\n    cat file.txt | head -n 10 | tail -n 1\\nfi\\n```",
                "solutionTags": [],
                "code": "```\\nlines=$(cat file.txt | wc -l)\\nif [ \"${lines%% *}\" -ge 10 ]; then\\n    cat file.txt | head -n 10 | tail -n 1\\nfi\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 449313,
                "title": "tail-head",
                "content": "Just a simple line with tail that catches up to the 10th line, then a head that obtains the last result of the tail\\n```\\ntail -n +10 file.txt | head -n 1\\n```",
                "solutionTags": [],
                "code": "```\\ntail -n +10 file.txt | head -n 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 433988,
                "title": "awk-easiest-one",
                "content": "```\\nawk \\'NR==10\\' file.txt \\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'NR==10\\' file.txt \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 415433,
                "title": "cat-awk-faster-than-100",
                "content": "using cat and awk commands\\n\\n```bash\\ncat file.txt | awk \\'NR==10\\'\\n```",
                "solutionTags": [],
                "code": "```bash\\ncat file.txt | awk \\'NR==10\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 374922,
                "title": "sed-awk-solutions-faster-than-100",
                "content": "# sed\\nThe first is with the p (print) command, and the other is with the d (delete) command.\\nThe n option with the print command is used to only print lines explicitly indicated by the command.\\nFor example, sed will output the 10th line of file.txt with each of the commands below:\\n\\nprint/p command\\n```\\ncat file.txt | sed -n \\'10p\\'  # > 73%\\n```\\n \\ndelete/d command\\n```\\ncat file.txt | sed \\'10!d\\'  # > 73%\\n```\\n\\n\\n***\\n\\n# awk\\n\\n awk has a built in variable NR that keeps track of file/stream row numbers.\\n awk syntax and idioms can be hard to read, so below are three different ways to print line 10 of file.txt file using awk.\\n```\\ncat file.txt | awk \\'NR==10\\'     # > 73%\\ncat file.txt | awk \\'NR==10{print}\\'  # > 100%\\ncat file.txt | awk \\'{if(NR==10) print}\\'  # >73%\\n```",
                "solutionTags": [],
                "code": "```\\ncat file.txt | sed -n \\'10p\\'  # > 73%\\n```\n```\\ncat file.txt | sed \\'10!d\\'  # > 73%\\n```\n```\\ncat file.txt | awk \\'NR==10\\'     # > 73%\\ncat file.txt | awk \\'NR==10{print}\\'  # > 100%\\ncat file.txt | awk \\'{if(NR==10) print}\\'  # >73%\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 348906,
                "title": "all-different-way-to-print-10th-line-of-a-file",
                "content": "Different approaches using sed, head & tail, awk, and cut linux command.\\n```\\n#!/bin/bash\\n\\n#tail -n+10 \\'file.txt\\' | head -1\\n#sed -n \\'10p\\' \\'file.txt\\'\\n#awk \"NR==10\" file.txt\\n#cut -f10 -d$\\'\\\\n\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\n#!/bin/bash\\n\\n#tail -n+10 \\'file.txt\\' | head -1\\n#sed -n \\'10p\\' \\'file.txt\\'\\n#awk \"NR==10\" file.txt\\n#cut -f10 -d$\\'\\\\n\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 341942,
                "title": "awk-solution",
                "content": "```\\ncat file.txt | awk \\'{if (NR==10){print $0}}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat file.txt | awk \\'{if (NR==10){print $0}}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 217162,
                "title": "the-shortest",
                "content": "```\\nawk \\'{if(NR==10){print $0}}\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'{if(NR==10){print $0}}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 208499,
                "title": "4-ms-faster-than-100-with-tail-and-head",
                "content": "```tail -n+10 file.txt | head -n1```",
                "solutionTags": [],
                "code": "```tail -n+10 file.txt | head -n1```",
                "codeTag": "Unknown"
            },
            {
                "id": 149734,
                "title": "dead-simple-bash",
                "content": "```\\ncat file.txt | sed -n 10p\\n```",
                "solutionTags": [],
                "code": "```\\ncat file.txt | sed -n 10p\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 128426,
                "title": "simple-solution",
                "content": "```\\nsed \"10q;d\" file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nsed \"10q;d\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 117471,
                "title": "one-line-solution-using-head-and-tail",
                "content": "Check if `#line >= 10` and use `head` + `tail` to print out the 10th line:\n\n```\n[ $(cat file.txt | wc -l) -ge 10 ] && head -n10 file.txt | tail -n1\n```",
                "solutionTags": [],
                "code": "```\n[ $(cat file.txt | wc -l) -ge 10 ] && head -n10 file.txt | tail -n1\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55543,
                "title": "a-pure-bash-solution",
                "content": "    #!/bin/env bash\\n    # Read from the file file.txt and output the tenth line to stdout.\\n    \\n    filename=${1:-file.txt}\\n    lineth=${2:-10}\\n    \\n    i=$lineth\\n    while read line && ((--i))\\n    do\\n        :\\n    done <$filename\\n    \\n    if [[ $i -gt 0 ]]\\n    then\\n        #echo \"This file has not enough lines\"\\n        exit 1\\n    fi\\n    \\n    echo $line\\n\\nI had thought that this solution may has an better efficiency than such as `tail -n+10 file.txt|head -1` which forks other processes, but I am wrong.\\n\\nThe above solution only beats 3% submissions while `tail&&head` combination beats 17% submissions, I don't know why....",
                "solutionTags": [],
                "code": "    #!/bin/env bash\\n    # Read from the file file.txt and output the tenth line to stdout.\\n    \\n    filename=${1:-file.txt}\\n    lineth=${2:-10}\\n    \\n    i=$lineth\\n    while read line && ((--i))\\n    do\\n        :\\n    done <$filename\\n    \\n    if [[ $i -gt 0 ]]\\n    then\\n        #echo \"This file has not enough lines\"\\n        exit 1\\n    fi\\n    \\n    echo $line\\n\\nI had thought that this solution may has an better efficiency than such as `tail -n+10 file.txt|head -1` which forks other processes, but I am wrong.\\n\\nThe above solution only beats 3% submissions while `tail&&head` combination beats 17% submissions, I don't know why....",
                "codeTag": "Unknown"
            },
            {
                "id": 55551,
                "title": "checkout-my-solution-here",
                "content": "    #if file.txt does not contain enough lines, we just pad it with 10 empty lines.\\n    echo \"\\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \" | cat file.txt - | head | tail -n 1\\n\\nI thought it simple enough for this question.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 4088206,
                "title": "print-10th-line-of-the-file",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ncat file.txt | sed -n \\'10p\\'\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ncat file.txt | sed -n \\'10p\\'\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4080340,
                "title": "for-solution",
                "content": "# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\n head -n 10 file.txt | tail -n +10\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n head -n 10 file.txt | tail -n +10\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4077597,
                "title": "it-was-easy",
                "content": "\\u0628\\u0633\\u0645 \\u0627\\u0644\\u0644\\u0647 \\u0627\\u0644\\u0631\\u062D\\u0645\\u0646 \\nThe easiest way to solve this question was to use awk. like this :\\n```bash\\nawk \\'NR==10\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```bash\\nawk \\'NR==10\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4070131,
                "title": "tenth-line",
                "content": "# Intuition\\nThe \"Tenth Line\" problem on LeetCode is typically solved using command-line tools like sed or awk \\n\\n# Approach\\nThis command will print the 10th line of the file, or nothing if the file has fewer than 10 lines. Since this problem is primarily about using command-line tools\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n<!-- \\n- Space complexity:\\nAdd your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n\\n\\n# sed: Invokes the stream editor.\\n# -n: Suppresses automatic printing of pattern space.\\n# \\'10p\\': Specifies to print the 10th line (10p) of the input file.\\n# file.txt: The name of the input file.\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n\\n\\n# sed: Invokes the stream editor.\\n# -n: Suppresses automatic printing of pattern space.\\n# \\'10p\\': Specifies to print the 10th line (10p) of the input file.\\n# file.txt: The name of the input file.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4064540,
                "title": "easy-and-simple-solution-using-just-while-loop",
                "content": "# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\n# cat file.txt | awk \\'{if (NR==10) print$0}\\'\\ncount=0\\nwhile read myVar\\ndo \\n    let count++;\\n    if [[ $count -eq 10 ]]\\n    then \\n        echo $myVar\\n    fi\\n\\ndone < file.txt\\n```\\n\\n# Please Do Upvote the Solution if you like \\uD83D\\uDE0D\\n",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n# cat file.txt | awk \\'{if (NR==10) print$0}\\'\\ncount=0\\nwhile read myVar\\ndo \\n    let count++;\\n    if [[ $count -eq 10 ]]\\n    then \\n        echo $myVar\\n    fi\\n\\ndone < file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4061750,
                "title": "pov",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n 10p file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n 10p file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4051570,
                "title": "print-10-th-line",
                "content": "# Intuition\\nRead line by line till line 10 is reached, then print the line and end the processing.\\n\\n# Approach\\nIn a for loop read a line from the file. Check if the counter is already ten, then print the line and exit the loop. If it\\'s not yet ten, read the next line.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n#!/bin/bash\\n# Read from the file file.txt and output the tenth line to stdout.\\ni=1\\nwhile read line\\ndo\\n  if [[ $i -eq 10 ]]; then\\n    echo $line\\n    break\\n  fi\\n  ((i++))\\ndone <file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n#!/bin/bash\\n# Read from the file file.txt and output the tenth line to stdout.\\ni=1\\nwhile read line\\ndo\\n  if [[ $i -eq 10 ]]; then\\n    echo $line\\n    break\\n  fi\\n  ((i++))\\ndone <file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4044039,
                "title": "bash",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nsed -n \\'10p\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nsed -n \\'10p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4029183,
                "title": "great-performance-99-one-line-with-read-and-counter-one-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nit=0; while read line; do ((it++)); if [ $it -eq 10 ]; then echo ${line}; exit 0; fi; done <file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nit=0; while read line; do ((it++)); if [ $it -eq 10 ]; then echo ${line}; exit 0; fi; done <file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4025435,
                "title": "using-sed",
                "content": "\\n\\nsed \\'10q;d\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "\\n\\nsed \\'10q;d\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4004147,
                "title": "bash-simple-solution-sed",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```bash\\nsed -n \\'10p\\' file.txt\\n```\\n",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```bash\\nsed -n \\'10p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3989029,
                "title": "bash-1-line",
                "content": "\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\n# Use awk to print the 10th line\\nawk \\'NR == 10\\' file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n# Use awk to print the 10th line\\nawk \\'NR == 10\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3976528,
                "title": "awk-3-solution",
                "content": "```\\nawk \\'NR==10 {print $0}\\' file.txt\\n```\\n\\nor\\n\\n```\\nawk \\'FNR==10 {print $0}\\' file.txt\\n```\\n\\nor\\n\\n```\\nawk \\'NR==10 {print $FILENAME}\\' file.txt\\n```\\n",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nawk \\'NR==10 {print $0}\\' file.txt\\n```\n```\\nawk \\'FNR==10 {print $0}\\' file.txt\\n```\n```\\nawk \\'NR==10 {print $FILENAME}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3960197,
                "title": "easy-readable-bash",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\nsed -n \\'10p\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\nsed -n \\'10p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3959332,
                "title": "one-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3942455,
                "title": "head-tail-and-wc",
                "content": "# Code\\n```\\nline_count=$(wc -l < \"file.txt\")\\nif [ \"$line_count\" -lt 10 ]; then\\n    echo \"\"\\nelse \\n    head -n 10 file.txt | tail -n 1\\nfi\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nline_count=$(wc -l < \"file.txt\")\\nif [ \"$line_count\" -lt 10 ]; then\\n    echo \"\"\\nelse \\n    head -n 10 file.txt | tail -n 1\\nfi\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938526,
                "title": "compile-a-c-program-with-gcc-and-run-it-lmao",
                "content": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\ngcc -x c - <<\\'EOF\\' && env PATH=\".:$PATH\" sh -c \\'a.out\\' < file.txt\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <stdint.h>\\nint main(void)\\n{\\n    uint8_t newlines = 0;\\n    int c;\\n    while ((c = getchar()) != EOF && newlines < 9)\\n        if (c == \\'\\\\n\\') ++newlines;\\n\\n    if (c == EOF) return 1;\\n\\n    putchar(c);\\n    while ((c = getchar()) != EOF && c != \\'\\\\n\\') {\\n        putchar(c);\\n    }\\n    return 0;\\n}\\nEOF\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\ngcc -x c - <<\\'EOF\\' && env PATH=\".:$PATH\" sh -c \\'a.out\\' < file.txt\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <stdint.h>\\nint main(void)\\n{\\n    uint8_t newlines = 0;\\n    int c;\\n    while ((c = getchar()) != EOF && newlines < 9)\\n        if (c == \\'\\\\n\\') ++newlines;\\n\\n    if (c == EOF) return 1;\\n\\n    putchar(c);\\n    while ((c = getchar()) != EOF && c != \\'\\\\n\\') {\\n        putchar(c);\\n    }\\n    return 0;\\n}\\nEOF\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3938518,
                "title": "sed",
                "content": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n 10p file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n 10p file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3926688,
                "title": "simple-sed-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -ne \\'10p\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -ne \\'10p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3915081,
                "title": "1-line",
                "content": "```\\nsed \\'10!d\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nsed \\'10!d\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3910075,
                "title": "using-sed-command",
                "content": "# Approach\\nUsing sed\\n\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3905152,
                "title": "bash",
                "content": "```bash\\r\\n# sed -n 10p file.txt\\r\\n# awk NR==10 file.txt\\r\\nhead -10 file.txt | tail +10\\r\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```bash\\r\\n# sed -n 10p file.txt\\r\\n# awk NR==10 file.txt\\r\\nhead -10 file.txt | tail +10\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3900830,
                "title": "sed",
                "content": "\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\nsed -n 10p file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\nsed -n 10p file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3873381,
                "title": "195-tenth-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\ntail -n+10 file.txt | head -n1\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\ntail -n+10 file.txt | head -n1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3825104,
                "title": "cheap-sed-solution-its-bash",
                "content": "# Intuition\\nI needed to be able to get inside of the file quicly, and the line is known. In this case, the solution is statically set to pull that specific line vs some dynamic set/piping, etc. One line should work. I would alias this in my shell if this was a usual command I used daily. \\n\\n# Approach\\nThis should be a 1 line answer, and should use a UNIX command in BASH. The stream editor would work as a way to open the file, and the line can be specified as 10, p for print, and -n to echo the specific line. file.txt was assumed to be in the same directory.\\n\\n# Complexity\\n- Time complexity:\\nN/A\\n\\n- Space complexity:\\nN/A\\n\\n# Code\\n```\\nsed -n \\'10p\\' < file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nsed -n \\'10p\\' < file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3806093,
                "title": "easy-2-solution-using-bash-script",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\n# awk \\'NR == 10 {print; exit}\\' file.txt\\n\\nsed -n \\'10p; 10q\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\n# awk \\'NR == 10 {print; exit}\\' file.txt\\n\\nsed -n \\'10p; 10q\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3805470,
                "title": "bash-sed",
                "content": "```\\n#!bin/bash\\n\\ncat file.txt | sed -n \\'10p\\'\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\n#!bin/bash\\n\\ncat file.txt | sed -n \\'10p\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3791833,
                "title": "one-line-simple-solution-using-sed-command",
                "content": "thi script uses sed command to print the 10th line of the file and the (-n) is used for suppressthe output and for print the 10th line we used \"10p\" and file.txt is the file name.\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\ncat file.txt | sed -n 10p\\n```\\n\\nThis command uses the sed command to print the 10th line of the file. The -n option is used to suppress the default output and \\'10p\\' is used to print the 10th line of the file. Replace file.txt with your file name.",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\ncat file.txt | sed -n 10p\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3785694,
                "title": "another-sed-solution-d",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\\\\\nsed \\'10!d\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\\\\\nsed \\'10!d\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3750010,
                "title": "10th-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3743063,
                "title": "sed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3742153,
                "title": "1-line-easy-code",
                "content": "\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nawk \\'NR==10\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nawk \\'NR==10\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3742151,
                "title": "1-line-easy-code",
                "content": "\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nawk \\'NR==10\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nawk \\'NR==10\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3742150,
                "title": "1-line-easy-code",
                "content": "\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nawk \\'NR==10\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nawk \\'NR==10\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3742149,
                "title": "1-line-easy-code",
                "content": "\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nawk \\'NR==10\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nawk \\'NR==10\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3742146,
                "title": "1-line-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\r\\nawk \\'NR==10\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\r\\nawk \\'NR==10\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3713367,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nawk \\'NR == 10 { print; exit }\\' file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nawk \\'NR == 10 { print; exit }\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3713025,
                "title": "tenth-line-souvik-hazra",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nawk \\'NR == 10\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nawk \\'NR == 10\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3680864,
                "title": "piping-iterative-solution",
                "content": "# Intuition\\nPipe the content until you get only the desired line\\n\\n# Approach\\n1. Show file contents\\n2. Filter to only get lines after 10th\\n3. Only show the first line of the bunch\\nI would not do this on large inputs, as showing the entire file and filtering does not really make sense, but if you just need something on the command line, it\\'s easy, logical and it works.\\n\\nHave also added a solution using an actual bash function\\n\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\ncat file.txt | tail -n +10 | head -n 1\\n\\n# If you need this as a function with arguments:\\n#!/bin/bash\\n\\nshow_file_line () {\\n    FILENAME=$1\\n    LINE_NR=$2\\n\\n    NR_OF_LINES=`head -n $LINE_NR $FILENAME | wc -l`\\n\\n    if [ $NR_OF_LINES -ge $LINE_NR ]; then\\n        head -n $LINE_NR $FILENAME | tail -1\\n    fi\\n}\\n\\nshow_file_line \"file.txt\" 10\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\ncat file.txt | tail -n +10 | head -n 1\\n\\n# If you need this as a function with arguments:\\n#!/bin/bash\\n\\nshow_file_line () {\\n    FILENAME=$1\\n    LINE_NR=$2\\n\\n    NR_OF_LINES=`head -n $LINE_NR $FILENAME | wc -l`\\n\\n    if [ $NR_OF_LINES -ge $LINE_NR ]; then\\n        head -n $LINE_NR $FILENAME | tail -1\\n    fi\\n}\\n\\nshow_file_line \"file.txt\" 10\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3675918,
                "title": "bash",
                "content": "\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed \"10q;d\" file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed \"10q;d\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3670873,
                "title": "bash-command-to-print-last-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\n#solution 1\\nsed -n \\'10p\\' file.txt\\n\\n#solution 2\\nawk \\'NR == 10\\' file.txt\\n\\n#solution 3\\ntail -n+10 file.txt|head -1",
                "solutionTags": [
                    "Bash"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\n#solution 1\\nsed -n \\'10p\\' file.txt\\n\\n#solution 2\\nawk \\'NR == 10\\' file.txt\\n\\n#solution 3\\ntail -n+10 file.txt|head -1",
                "codeTag": "Unknown"
            },
            {
                "id": 3669450,
                "title": "awk",
                "content": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nawk \\'NR==10\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nawk \\'NR==10\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3664907,
                "title": "solution-with-gawk",
                "content": "# Intuition\\nTo these questions which read and handle the text files or the record files, I am very likely to use the tool GAWK.\\n# Approach\\nUse the getline to explicitly read from the specific file, and use a for loop to calculate the number of lines, and when meet the line 10, output it by the print function.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\ngawk \\'BEGIN{i = 0;\\n    while(getline < \"file.txt\")\\n    {\\n        i++;\\n        if(i == 10)\\n            print $0\\n    }\\n    }\\'        \\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\ngawk \\'BEGIN{i = 0;\\n    while(getline < \"file.txt\")\\n    {\\n        i++;\\n        if(i == 10)\\n            print $0\\n    }\\n    }\\'        \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3632868,
                "title": "an-easy-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nnothing to say really, solution was too obvious\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAlternative solution, in case you want to make sure that the file has at least 10 lines and don\\'t want to look at its insides.\\n\\nFILE=\\'file.txt\\'\\n\\nLINE_COUNT=$(wc -l < \"$FILE\")\\n\\nif [ $LINE_COUNT -ge 10 ]; then\\n    sed -n \\'10p\\' \"$FILE\"\\nelse\\n    echo \"The file does not have at least 10 lines.\"\\nfi\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\n#!/bin/bash\\n\\nsed -n \\'10p\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\n#!/bin/bash\\n\\nsed -n \\'10p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3623000,
                "title": "solution-with-sed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed \\'10q;d\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed \\'10q;d\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3612569,
                "title": "bash-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed \"10q;d\" file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed \"10q;d\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3600696,
                "title": "using-counter-variable-bash-hyder-nabi",
                "content": "\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nfile=\"file.txt\"\\ni=1;\\nwhile read line; do\\n\\tif [ $i == 10 ];\\n\\tthen\\n\\t\\techo $line;\\n    break\\n\\tfi\\n\\ti=$((i+1))\\ndone < $file;\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nfile=\"file.txt\"\\ni=1;\\nwhile read line; do\\n\\tif [ $i == 10 ];\\n\\tthen\\n\\t\\techo $line;\\n    break\\n\\tfi\\n\\ti=$((i+1))\\ndone < $file;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3599093,
                "title": "simple-solution-bash",
                "content": "# Code\\n```\\nsed -n \\'10p\\' < file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nsed -n \\'10p\\' < file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3586970,
                "title": "simple",
                "content": "\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt \\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3544103,
                "title": "sed-oneliner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10,10p; 11q\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10,10p; 11q\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3505179,
                "title": "bash-while-loop",
                "content": "# Intuition\\nUse a while loop and line counter variable.\\n\\n# Approach\\nInitialise a variable to zero. Iterate over each line in a while loop. Increment the variable on each iteration. If the variable is 10 then echo the current line. If there are less than ten lines then nothing will be echoed.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\ncount=0\\nwhile read line; do\\n    ((count++))\\n    if [ \"$count\" == 10 ]\\n    then\\n        echo $line\\n    fi\\ndone < file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ncount=0\\nwhile read line; do\\n    ((count++))\\n    if [ \"$count\" == 10 ]\\n    then\\n        echo $line\\n    fi\\ndone < file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3490411,
                "title": "intutive-and-practical-solution",
                "content": "# Intuition\\nWe will start with conventional method to reach the 10th line\\n\\n# Approach\\nDo while loop.\\n\\n# Code\\n```Bash\\n# Read from the file file.txt and output the tenth line to stdout.\\ncnt=0\\nwhile read line && [ $cnt -le 10 ]; do\\n  let \\'cnt = cnt + 1\\'\\n  if [ $cnt -eq 10 ]; then\\n    echo $line\\n    exit 0\\n  fi\\ndone < file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```Bash\\n# Read from the file file.txt and output the tenth line to stdout.\\ncnt=0\\nwhile read line && [ $cnt -le 10 ]; do\\n  let \\'cnt = cnt + 1\\'\\n  if [ $cnt -eq 10 ]; then\\n    echo $line\\n    exit 0\\n  fi\\ndone < file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3489811,
                "title": "print-line-number",
                "content": "Simple command for print line no.\\n\\n\\n---\\n\\n# Code\\n```\\ncat file.txt | sed -n \\'10p\\'\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ncat file.txt | sed -n \\'10p\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3487540,
                "title": "195-tenth-line-solution-with-detailed-explanation",
                "content": "# Intuition\\n- The awk command is a powerful text processing tool that can read a file line by line and perform various operations on each line.\\n- In this solution, we use awk to print only the 10th line of the file.\\nThe awk command uses a pattern-action structure, where the pattern specifies which lines to operate on, and the action specifies what to do with those lines.\\n\\n# Approach\\n- The awk command is a popular tool for text processing in Unix-like systems, as it is fast and efficient.\\n- By using awk to print only the 10th line of the file, we avoid reading and processing the entire file, which can be inefficient for large files.\\n- The NR==10 pattern matches only the 10th line of the file, regardless of how many lines the file contains.\\n- Overall, this solution is a concise and efficient way to print the 10th line of a file using awk.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is O(N), where N is the number of lines in the file. The awk command reads the input file line by line and performs pattern matching to identify the 10th line. This process takes linear time, as it reads each line exactly once.\\n\\n- Space complexity:\\nThe space complexity of this solution is O(1), as it uses a constant amount of additional memory. The awk command processes the input file one line at a time, without storing the entire file in memory. Therefore, the space used by the awk command is constant, regardless of the size of the input file.\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\nawk \\'NR == 10\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\nawk \\'NR == 10\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3464666,
                "title": "unix-printing-the-line-using-sed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\nsed -n 10p file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\nsed -n 10p file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3461864,
                "title": "just-a-one-line-of-code",
                "content": "I would suggest sed like this:\\n\\nsed ```\\'NUMq;d\\'``` file\\nWhere NUM is the number of the line you want to print; so, for example, ```sed \\'239q;d\\'``` file to print the 239th line of file.\\n\\nExplanation:\\n\\n```NUMq``` will quit immediately when the line number is ```NUM```.\\n\\n```d``` will delete the line instead of printing it; this is inhibited on the last line because the ```q``` causes the rest of the script to be skipped when quitting.\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed \\'10q;d\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\'NUMq;d\\'```\n```sed \\'239q;d\\'```\n```NUMq```\n```NUM```\n```d```\n```q```\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed \\'10q;d\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3438299,
                "title": "sed-n-10p-file-txt",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n\\n```\\n# Upvote please if you find it helpful! \\uD83E\\uDD1F",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3437419,
                "title": "output-the-tenth-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\n\\nsed -n 10p file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\n\\nsed -n 10p file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3431456,
                "title": "solution-exiled",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3408345,
                "title": "simple-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3406393,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n```\\n1.awk reads the first line of the file.\\n\\n2. NR==10 {print;exit} is an awk expression that checks if the current line number (NR) is equal to 10. If it is, the expression prints the line (print) and exits the awk program (exit).\\n\\n3.If the current line number is not 10, awk reads the next line of the file and repeats step 2.\\n\\n4.awk continues reading and processing lines of the file until it reaches the end of the file.\\n\\nWhen awk finds the 10th line of the file, it prints the line and exits the program. The exit statement ensures that awk stops processing the file after it finds the 10th line, so it doesn\\'t waste time processing the rest of the file unnecessarily.\\n\\nOverall, the command uses awk\\'s pattern matching capabilities to quickly find the 10th line of the file and print it.\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O()$$ -->\\nO(1)\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\n#awk NR==\\'10\\' file.txt\\n#sed -n \\'10p\\' file.txt\\n#sed \\'10q;d\\' file.txt\\n#tail -n +10 file.txt | head -n 1\\n\\nawk \\'NR==10 {print;exit}\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n1.awk reads the first line of the file.\\n\\n2. NR==10 {print;exit} is an awk expression that checks if the current line number (NR) is equal to 10. If it is, the expression prints the line (print) and exits the awk program (exit).\\n\\n3.If the current line number is not 10, awk reads the next line of the file and repeats step 2.\\n\\n4.awk continues reading and processing lines of the file until it reaches the end of the file.\\n\\nWhen awk finds the 10th line of the file, it prints the line and exits the program. The exit statement ensures that awk stops processing the file after it finds the 10th line, so it doesn\\'t waste time processing the rest of the file unnecessarily.\\n\\nOverall, the command uses awk\\'s pattern matching capabilities to quickly find the 10th line of the file and print it.\\n```\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\n#awk NR==\\'10\\' file.txt\\n#sed -n \\'10p\\' file.txt\\n#sed \\'10q;d\\' file.txt\\n#tail -n +10 file.txt | head -n 1\\n\\nawk \\'NR==10 {print;exit}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3392568,
                "title": "best-4-solutions",
                "content": "# Solution 1\\n`awk` is damn fast when comes to text progression it beast tools like sed, head and head\\n```\\nawk \\'NR==10\\' file.txt\\n```\\n\\n# Solution 2\\nOne can also think of reading the file with read and then print the line when the counter `c` hits 10\\n```\\nc=0 # conuter\\nwhile read -r line\\ndo\\n  c=$((c+1))\\n  if [[ $c -eq 10 ]]; then\\n    echo $line\\n    exit\\n  fi\\ndone < file.txt\\n```\\n\\n# Solution 3\\n`sed` is great too but not as great as awk\\n```\\nsed -n 10p file.txt\\n```\\n\\n# Solution 4\\nUsing `head` and `tail` is also a possible solution\\n```\\ntail -n +10 file.txt | head -n 1\\n```\\n",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nawk \\'NR==10\\' file.txt\\n```\n```\\nc=0 # conuter\\nwhile read -r line\\ndo\\n  c=$((c+1))\\n  if [[ $c -eq 10 ]]; then\\n    echo $line\\n    exit\\n  fi\\ndone < file.txt\\n```\n```\\nsed -n 10p file.txt\\n```\n```\\ntail -n +10 file.txt | head -n 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3386511,
                "title": "print-the-nth-line-from-a-file",
                "content": "# Intuition\\n**sed** works same as **head** and **tail** but **sed** is good for a large file. **head** and **tail** consume more time on large files.\\n\\n# Approach\\nHere **\"10q;d\"** means **10** is the line number that we want, **10q** will quit immediately when the line number is **10**, **d** will delete the line instead of printing it; this is inhibited on the last line because the **q** causes the rest of the script to be skipped when quitting.\\n\\nMake sure if you are using variable instead of 10 the you need to use double quotes instead of single.\\n\\n# Complexity\\n- Time complexity: **33 ms**\\n\\n- Space complexity: **3.6 MB**\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed \"10q;d\" file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed \"10q;d\" file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3370727,
                "title": "195-tenth-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks us to print the 10th line of the given file. If there are fewer than 10 lines, the script should not print anything.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe problem can be solved using multiple approaches, such as using the sed command, the awk command, or the head and tail commands.\\nUsing the sed command:\\nThe sed command can be used to extract the 10th line from the file. The command sed -n \\'10p\\' file.txt prints the 10th line of the file. If the file contains fewer than 10 lines, the command will not print anything.\\n\\nUsing the awk command:\\nThe awk command can also be used to extract the 10th line from the file. The command awk \\'NR==10\\' file.txt prints the 10th line of the file. If the file contains fewer than 10 lines, the command will not print anything.\\n\\nUsing the head and tail commands:\\nThe head and tail commands can be used to extract the 10th line from the file. The command head -n 10 file.txt | tail -n +10 prints the 10th line of the file. If the file contains fewer than 10 lines, the command will not print anything.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAll three approaches have a time complexity of O(n), where n is the number of lines in the file.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nAll three approaches have a space complexity of O(1), as they only require a constant amount of memory to store the commands and output.\\n\\n# Code\\nSolution 1:\\n\\nWe can use the sed command to print the 10th line of the file. The command for this is sed -n 10p file.txt. The -n option is used to suppress the default output, and 10p prints only the 10th line of the file.\\n\\nIf the file contains less than 10 lines, this command will not output anything.\\n\\nTime complexity: O(1) as we are just printing one line.\\nSpace complexity: O(1) as we are not using any extra space.\\n\\nSolution 2:\\n\\nWe can use the head command to print the first 10 lines of the file, and then use tail to print only the last line of that output. The command for this is head -10 file.txt | tail -1.\\n\\nIf the file contains less than 10 lines, this command will not output anything.\\n\\nTime complexity: O(n) as we are reading the first 10 lines of the file.\\nSpace complexity: O(1) as we are not using any extra space.\\n\\nSolution 3:\\n\\nWe can use a loop to read the file line by line, and keep a counter to keep track of the line number. When the counter reaches 10, we print that line and exit the loop. The command for this is:\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\ncounter=0\\nwhile read line && [ $counter -le 9 ]\\ndo\\n    counter=$((counter+1))\\n    if [ $counter -eq 10 ]\\n    then\\n        echo $line\\n        break\\n    fi\\ndone < file.txt\\n\\n```\\nIf the file contains less than 10 lines, this command will not output anything.\\n\\nTime complexity: O(n) as we are reading the file line by line.\\nSpace complexity: O(1) as we are not using any extra space.\\n\\n",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\ncounter=0\\nwhile read line && [ $counter -le 9 ]\\ndo\\n    counter=$((counter+1))\\n    if [ $counter -eq 10 ]\\n    then\\n        echo $line\\n        break\\n    fi\\ndone < file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3368168,
                "title": "solution-using-awk",
                "content": "# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nawk \\'NR==10\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nawk \\'NR==10\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3349059,
                "title": "1-liner-solution-with-awk",
                "content": "\\n\\'\\'\\'\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\n```\\n\\n awk \\'NR==10 {print $0}\\' file.txt",
                "solutionTags": [
                    "Bash"
                ],
                "code": "\\n\\'\\'\\'\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\n```\\n\\n awk \\'NR==10 {print $0}\\' file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 3344472,
                "title": "simple-solution-using-bash-sed-command",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout\\nsed -n \\'10p\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout\\nsed -n \\'10p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3337981,
                "title": "tenth-line-bash-solution-1-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n 10p file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n 10p file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3330966,
                "title": "read-10th-line-of-text-from-a-file",
                "content": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n#!/bin/bash\\n\\nsed -n \\'10p\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n#!/bin/bash\\n\\nsed -n \\'10p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3323503,
                "title": "chatgpt-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3279180,
                "title": "tenth-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nsed \"10q;d\" file.txt\\n```",
                "solutionTags": [
                    "Java",
                    "Bash"
                ],
                "code": "```\\nsed \"10q;d\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3173975,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed \"10q;d\" file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed \"10q;d\" file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3167519,
                "title": "one-liner-with-cat-tr-and-cut",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```\\ncat file.txt\\n```\\nThis reads the file to stdout. \\n\\n```\\ntr -st \\'\\\\n\\' \\'^\\'\\n```\\nCombines different lines with the delimeter \\'^\\' (that does not occur in any string)\\n\\n```\\ncut -d \\'^\\' -f 10\\n```\\nThis \"cuts\" the string with delimeter \\'^\\' and prints the 10th field.\\n\\nThe final command is a combination of the above three commands  connected with pipes:\\n\\n# Code\\n```\\ncat file.txt | tr -st \\'\\\\n\\' \\'^\\' | cut -d \\'^\\' -f 10\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ncat file.txt\\n```\n```\\ntr -st \\'\\\\n\\' \\'^\\'\\n```\n```\\ncut -d \\'^\\' -f 10\\n```\n```\\ncat file.txt | tr -st \\'\\\\n\\' \\'^\\' | cut -d \\'^\\' -f 10\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3165005,
                "title": "print-a-specific-line-from-a-file",
                "content": "# Approach\\nThis code prints the line of a file specified by the line_number variable. The command awk is used to search through the file specified by file_name and print the line that corresponds to the line_number variable.\\n#Code_Source: Grepper\\n\\n# Complexity\\n- Time complexity:\\n\\n    O(1)\\n\\n- Space complexity:\\nO(1) - This code has a constant time complexity as it only requires one pass through the file\\n\\n# Code\\n```\\nawk \\'{if(NR==10) print $0}\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nawk \\'{if(NR==10) print $0}\\' file.txt\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565037,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1565665,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1566370,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1565527,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1570679,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1568457,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1568193,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1567384,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1568618,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1568520,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1565037,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1565665,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1566370,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1565527,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1570679,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1568457,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1568193,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1567384,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1568618,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1568520,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1567912,
                "content": [
                    {
                        "username": "MonsieurWilson",
                        "content": "Since there already have solutions based on `awk` or `sed` or `head | tail`, here is a unique soluton.\\n\\n    IFS=$'\\\\n' ;arr=($(<file.txt)); echo ${arr[9]}"
                    },
                    {
                        "username": "pankajgupta20",
                        "content": "##### awk solution\\n\\tawk \\'NR==10\\' file.txt\\n##### sed solution\\n\\tsed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "jtsa0267",
                        "content": "![image](https://assets.leetcode.com/users/images/49a84700-0198-469f-b60f-5ebff9b85e4b_1593762455.829133.png)\\n"
                    },
                    {
                        "username": "azhar24u",
                        "content": "sed -n 10p file.txt"
                    },
                    {
                        "username": "iziang",
                        "content": "Only one line in awk\\n    \\n    awk 'NR == 10' file.txt"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "\"\\nNote:\\n1. If the file contains less than 10 lines, what should you output?\\n\"\\n\\nWhy would I know, shouldn\\'t it be included in problem description?"
                    },
                    {
                        "username": "crazydar",
                        "content": "Exactly what I was thinking. This is ridiculous - an exercise in mind reading..."
                    },
                    {
                        "username": "powernoob",
                        "content": "sed -n \\'10p\\' file.txt"
                    },
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "apgokul",
                        "content": "The sed command below will retrieve the 10th line from the file `file.txt`\\n\\n#### solution :\\n\\n`sed \\'10q;d\\' file`"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "`awk \\'NR == 10\\' file.txt`"
                    }
                ]
            },
            {
                "id": 1570440,
                "content": [
                    {
                        "username": "MonsieurWilson",
                        "content": "Since there already have solutions based on `awk` or `sed` or `head | tail`, here is a unique soluton.\\n\\n    IFS=$'\\\\n' ;arr=($(<file.txt)); echo ${arr[9]}"
                    },
                    {
                        "username": "pankajgupta20",
                        "content": "##### awk solution\\n\\tawk \\'NR==10\\' file.txt\\n##### sed solution\\n\\tsed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "jtsa0267",
                        "content": "![image](https://assets.leetcode.com/users/images/49a84700-0198-469f-b60f-5ebff9b85e4b_1593762455.829133.png)\\n"
                    },
                    {
                        "username": "azhar24u",
                        "content": "sed -n 10p file.txt"
                    },
                    {
                        "username": "iziang",
                        "content": "Only one line in awk\\n    \\n    awk 'NR == 10' file.txt"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "\"\\nNote:\\n1. If the file contains less than 10 lines, what should you output?\\n\"\\n\\nWhy would I know, shouldn\\'t it be included in problem description?"
                    },
                    {
                        "username": "crazydar",
                        "content": "Exactly what I was thinking. This is ridiculous - an exercise in mind reading..."
                    },
                    {
                        "username": "powernoob",
                        "content": "sed -n \\'10p\\' file.txt"
                    },
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "apgokul",
                        "content": "The sed command below will retrieve the 10th line from the file `file.txt`\\n\\n#### solution :\\n\\n`sed \\'10q;d\\' file`"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "`awk \\'NR == 10\\' file.txt`"
                    }
                ]
            },
            {
                "id": 1570034,
                "content": [
                    {
                        "username": "MonsieurWilson",
                        "content": "Since there already have solutions based on `awk` or `sed` or `head | tail`, here is a unique soluton.\\n\\n    IFS=$'\\\\n' ;arr=($(<file.txt)); echo ${arr[9]}"
                    },
                    {
                        "username": "pankajgupta20",
                        "content": "##### awk solution\\n\\tawk \\'NR==10\\' file.txt\\n##### sed solution\\n\\tsed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "jtsa0267",
                        "content": "![image](https://assets.leetcode.com/users/images/49a84700-0198-469f-b60f-5ebff9b85e4b_1593762455.829133.png)\\n"
                    },
                    {
                        "username": "azhar24u",
                        "content": "sed -n 10p file.txt"
                    },
                    {
                        "username": "iziang",
                        "content": "Only one line in awk\\n    \\n    awk 'NR == 10' file.txt"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "\"\\nNote:\\n1. If the file contains less than 10 lines, what should you output?\\n\"\\n\\nWhy would I know, shouldn\\'t it be included in problem description?"
                    },
                    {
                        "username": "crazydar",
                        "content": "Exactly what I was thinking. This is ridiculous - an exercise in mind reading..."
                    },
                    {
                        "username": "powernoob",
                        "content": "sed -n \\'10p\\' file.txt"
                    },
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "apgokul",
                        "content": "The sed command below will retrieve the 10th line from the file `file.txt`\\n\\n#### solution :\\n\\n`sed \\'10q;d\\' file`"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "`awk \\'NR == 10\\' file.txt`"
                    }
                ]
            },
            {
                "id": 1570011,
                "content": [
                    {
                        "username": "MonsieurWilson",
                        "content": "Since there already have solutions based on `awk` or `sed` or `head | tail`, here is a unique soluton.\\n\\n    IFS=$'\\\\n' ;arr=($(<file.txt)); echo ${arr[9]}"
                    },
                    {
                        "username": "pankajgupta20",
                        "content": "##### awk solution\\n\\tawk \\'NR==10\\' file.txt\\n##### sed solution\\n\\tsed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "jtsa0267",
                        "content": "![image](https://assets.leetcode.com/users/images/49a84700-0198-469f-b60f-5ebff9b85e4b_1593762455.829133.png)\\n"
                    },
                    {
                        "username": "azhar24u",
                        "content": "sed -n 10p file.txt"
                    },
                    {
                        "username": "iziang",
                        "content": "Only one line in awk\\n    \\n    awk 'NR == 10' file.txt"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "\"\\nNote:\\n1. If the file contains less than 10 lines, what should you output?\\n\"\\n\\nWhy would I know, shouldn\\'t it be included in problem description?"
                    },
                    {
                        "username": "crazydar",
                        "content": "Exactly what I was thinking. This is ridiculous - an exercise in mind reading..."
                    },
                    {
                        "username": "powernoob",
                        "content": "sed -n \\'10p\\' file.txt"
                    },
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "apgokul",
                        "content": "The sed command below will retrieve the 10th line from the file `file.txt`\\n\\n#### solution :\\n\\n`sed \\'10q;d\\' file`"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "`awk \\'NR == 10\\' file.txt`"
                    }
                ]
            },
            {
                "id": 1569015,
                "content": [
                    {
                        "username": "MonsieurWilson",
                        "content": "Since there already have solutions based on `awk` or `sed` or `head | tail`, here is a unique soluton.\\n\\n    IFS=$'\\\\n' ;arr=($(<file.txt)); echo ${arr[9]}"
                    },
                    {
                        "username": "pankajgupta20",
                        "content": "##### awk solution\\n\\tawk \\'NR==10\\' file.txt\\n##### sed solution\\n\\tsed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "jtsa0267",
                        "content": "![image](https://assets.leetcode.com/users/images/49a84700-0198-469f-b60f-5ebff9b85e4b_1593762455.829133.png)\\n"
                    },
                    {
                        "username": "azhar24u",
                        "content": "sed -n 10p file.txt"
                    },
                    {
                        "username": "iziang",
                        "content": "Only one line in awk\\n    \\n    awk 'NR == 10' file.txt"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "\"\\nNote:\\n1. If the file contains less than 10 lines, what should you output?\\n\"\\n\\nWhy would I know, shouldn\\'t it be included in problem description?"
                    },
                    {
                        "username": "crazydar",
                        "content": "Exactly what I was thinking. This is ridiculous - an exercise in mind reading..."
                    },
                    {
                        "username": "powernoob",
                        "content": "sed -n \\'10p\\' file.txt"
                    },
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "apgokul",
                        "content": "The sed command below will retrieve the 10th line from the file `file.txt`\\n\\n#### solution :\\n\\n`sed \\'10q;d\\' file`"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "`awk \\'NR == 10\\' file.txt`"
                    }
                ]
            },
            {
                "id": 1892861,
                "content": [
                    {
                        "username": "MonsieurWilson",
                        "content": "Since there already have solutions based on `awk` or `sed` or `head | tail`, here is a unique soluton.\\n\\n    IFS=$'\\\\n' ;arr=($(<file.txt)); echo ${arr[9]}"
                    },
                    {
                        "username": "pankajgupta20",
                        "content": "##### awk solution\\n\\tawk \\'NR==10\\' file.txt\\n##### sed solution\\n\\tsed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "jtsa0267",
                        "content": "![image](https://assets.leetcode.com/users/images/49a84700-0198-469f-b60f-5ebff9b85e4b_1593762455.829133.png)\\n"
                    },
                    {
                        "username": "azhar24u",
                        "content": "sed -n 10p file.txt"
                    },
                    {
                        "username": "iziang",
                        "content": "Only one line in awk\\n    \\n    awk 'NR == 10' file.txt"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "\"\\nNote:\\n1. If the file contains less than 10 lines, what should you output?\\n\"\\n\\nWhy would I know, shouldn\\'t it be included in problem description?"
                    },
                    {
                        "username": "crazydar",
                        "content": "Exactly what I was thinking. This is ridiculous - an exercise in mind reading..."
                    },
                    {
                        "username": "powernoob",
                        "content": "sed -n \\'10p\\' file.txt"
                    },
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "apgokul",
                        "content": "The sed command below will retrieve the 10th line from the file `file.txt`\\n\\n#### solution :\\n\\n`sed \\'10q;d\\' file`"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "`awk \\'NR == 10\\' file.txt`"
                    }
                ]
            },
            {
                "id": 1576126,
                "content": [
                    {
                        "username": "MonsieurWilson",
                        "content": "Since there already have solutions based on `awk` or `sed` or `head | tail`, here is a unique soluton.\\n\\n    IFS=$'\\\\n' ;arr=($(<file.txt)); echo ${arr[9]}"
                    },
                    {
                        "username": "pankajgupta20",
                        "content": "##### awk solution\\n\\tawk \\'NR==10\\' file.txt\\n##### sed solution\\n\\tsed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "jtsa0267",
                        "content": "![image](https://assets.leetcode.com/users/images/49a84700-0198-469f-b60f-5ebff9b85e4b_1593762455.829133.png)\\n"
                    },
                    {
                        "username": "azhar24u",
                        "content": "sed -n 10p file.txt"
                    },
                    {
                        "username": "iziang",
                        "content": "Only one line in awk\\n    \\n    awk 'NR == 10' file.txt"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "\"\\nNote:\\n1. If the file contains less than 10 lines, what should you output?\\n\"\\n\\nWhy would I know, shouldn\\'t it be included in problem description?"
                    },
                    {
                        "username": "crazydar",
                        "content": "Exactly what I was thinking. This is ridiculous - an exercise in mind reading..."
                    },
                    {
                        "username": "powernoob",
                        "content": "sed -n \\'10p\\' file.txt"
                    },
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "apgokul",
                        "content": "The sed command below will retrieve the 10th line from the file `file.txt`\\n\\n#### solution :\\n\\n`sed \\'10q;d\\' file`"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "`awk \\'NR == 10\\' file.txt`"
                    }
                ]
            },
            {
                "id": 1576064,
                "content": [
                    {
                        "username": "MonsieurWilson",
                        "content": "Since there already have solutions based on `awk` or `sed` or `head | tail`, here is a unique soluton.\\n\\n    IFS=$'\\\\n' ;arr=($(<file.txt)); echo ${arr[9]}"
                    },
                    {
                        "username": "pankajgupta20",
                        "content": "##### awk solution\\n\\tawk \\'NR==10\\' file.txt\\n##### sed solution\\n\\tsed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "jtsa0267",
                        "content": "![image](https://assets.leetcode.com/users/images/49a84700-0198-469f-b60f-5ebff9b85e4b_1593762455.829133.png)\\n"
                    },
                    {
                        "username": "azhar24u",
                        "content": "sed -n 10p file.txt"
                    },
                    {
                        "username": "iziang",
                        "content": "Only one line in awk\\n    \\n    awk 'NR == 10' file.txt"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "\"\\nNote:\\n1. If the file contains less than 10 lines, what should you output?\\n\"\\n\\nWhy would I know, shouldn\\'t it be included in problem description?"
                    },
                    {
                        "username": "crazydar",
                        "content": "Exactly what I was thinking. This is ridiculous - an exercise in mind reading..."
                    },
                    {
                        "username": "powernoob",
                        "content": "sed -n \\'10p\\' file.txt"
                    },
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "apgokul",
                        "content": "The sed command below will retrieve the 10th line from the file `file.txt`\\n\\n#### solution :\\n\\n`sed \\'10q;d\\' file`"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "`awk \\'NR == 10\\' file.txt`"
                    }
                ]
            },
            {
                "id": 1576047,
                "content": [
                    {
                        "username": "MonsieurWilson",
                        "content": "Since there already have solutions based on `awk` or `sed` or `head | tail`, here is a unique soluton.\\n\\n    IFS=$'\\\\n' ;arr=($(<file.txt)); echo ${arr[9]}"
                    },
                    {
                        "username": "pankajgupta20",
                        "content": "##### awk solution\\n\\tawk \\'NR==10\\' file.txt\\n##### sed solution\\n\\tsed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "jtsa0267",
                        "content": "![image](https://assets.leetcode.com/users/images/49a84700-0198-469f-b60f-5ebff9b85e4b_1593762455.829133.png)\\n"
                    },
                    {
                        "username": "azhar24u",
                        "content": "sed -n 10p file.txt"
                    },
                    {
                        "username": "iziang",
                        "content": "Only one line in awk\\n    \\n    awk 'NR == 10' file.txt"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "\"\\nNote:\\n1. If the file contains less than 10 lines, what should you output?\\n\"\\n\\nWhy would I know, shouldn\\'t it be included in problem description?"
                    },
                    {
                        "username": "crazydar",
                        "content": "Exactly what I was thinking. This is ridiculous - an exercise in mind reading..."
                    },
                    {
                        "username": "powernoob",
                        "content": "sed -n \\'10p\\' file.txt"
                    },
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "apgokul",
                        "content": "The sed command below will retrieve the 10th line from the file `file.txt`\\n\\n#### solution :\\n\\n`sed \\'10q;d\\' file`"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "`awk \\'NR == 10\\' file.txt`"
                    }
                ]
            },
            {
                "id": 1574756,
                "content": [
                    {
                        "username": "MonsieurWilson",
                        "content": "Since there already have solutions based on `awk` or `sed` or `head | tail`, here is a unique soluton.\\n\\n    IFS=$'\\\\n' ;arr=($(<file.txt)); echo ${arr[9]}"
                    },
                    {
                        "username": "pankajgupta20",
                        "content": "##### awk solution\\n\\tawk \\'NR==10\\' file.txt\\n##### sed solution\\n\\tsed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "jtsa0267",
                        "content": "![image](https://assets.leetcode.com/users/images/49a84700-0198-469f-b60f-5ebff9b85e4b_1593762455.829133.png)\\n"
                    },
                    {
                        "username": "azhar24u",
                        "content": "sed -n 10p file.txt"
                    },
                    {
                        "username": "iziang",
                        "content": "Only one line in awk\\n    \\n    awk 'NR == 10' file.txt"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "\"\\nNote:\\n1. If the file contains less than 10 lines, what should you output?\\n\"\\n\\nWhy would I know, shouldn\\'t it be included in problem description?"
                    },
                    {
                        "username": "crazydar",
                        "content": "Exactly what I was thinking. This is ridiculous - an exercise in mind reading..."
                    },
                    {
                        "username": "powernoob",
                        "content": "sed -n \\'10p\\' file.txt"
                    },
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "apgokul",
                        "content": "The sed command below will retrieve the 10th line from the file `file.txt`\\n\\n#### solution :\\n\\n`sed \\'10q;d\\' file`"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "`awk \\'NR == 10\\' file.txt`"
                    }
                ]
            },
            {
                "id": 1574416,
                "content": [
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "somayyah_mohd",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "user3154L",
                        "content": "`awk \\'NR==10\\' file.txt`"
                    },
                    {
                        "username": "echobash",
                        "content": "cat file.txt | awk \\'{if(NR==10)print} \\'"
                    },
                    {
                        "username": "zhoucego",
                        "content": "awk \\'NR == 10\\' file.txt\\n\\n\\n"
                    },
                    {
                        "username": "chinmay93",
                        "content": "sed \\'10q;d\\' file.txt"
                    },
                    {
                        "username": "variable_infiltration",
                        "content": "`if [ $(wc -l file.txt | awk \\'{print $1}\\') -gt 9 ]; then cat file.txt | head -n10 | tail -1; fi`"
                    },
                    {
                        "username": "hazem1911",
                        "content": "`cat file.txt | cut -d$\\'\\\\n\\' -f10`"
                    },
                    {
                        "username": "Motherbrain",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "RetroCoder80s",
                        "content": "This problem is tagged as \"bash\" so it should be possible to use ANY command line tool that works in bash like \"bat\" - i.e: bat -r 10:10 file.txt !"
                    }
                ]
            },
            {
                "id": 1573754,
                "content": [
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "somayyah_mohd",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "user3154L",
                        "content": "`awk \\'NR==10\\' file.txt`"
                    },
                    {
                        "username": "echobash",
                        "content": "cat file.txt | awk \\'{if(NR==10)print} \\'"
                    },
                    {
                        "username": "zhoucego",
                        "content": "awk \\'NR == 10\\' file.txt\\n\\n\\n"
                    },
                    {
                        "username": "chinmay93",
                        "content": "sed \\'10q;d\\' file.txt"
                    },
                    {
                        "username": "variable_infiltration",
                        "content": "`if [ $(wc -l file.txt | awk \\'{print $1}\\') -gt 9 ]; then cat file.txt | head -n10 | tail -1; fi`"
                    },
                    {
                        "username": "hazem1911",
                        "content": "`cat file.txt | cut -d$\\'\\\\n\\' -f10`"
                    },
                    {
                        "username": "Motherbrain",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "RetroCoder80s",
                        "content": "This problem is tagged as \"bash\" so it should be possible to use ANY command line tool that works in bash like \"bat\" - i.e: bat -r 10:10 file.txt !"
                    }
                ]
            },
            {
                "id": 1573451,
                "content": [
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "somayyah_mohd",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "user3154L",
                        "content": "`awk \\'NR==10\\' file.txt`"
                    },
                    {
                        "username": "echobash",
                        "content": "cat file.txt | awk \\'{if(NR==10)print} \\'"
                    },
                    {
                        "username": "zhoucego",
                        "content": "awk \\'NR == 10\\' file.txt\\n\\n\\n"
                    },
                    {
                        "username": "chinmay93",
                        "content": "sed \\'10q;d\\' file.txt"
                    },
                    {
                        "username": "variable_infiltration",
                        "content": "`if [ $(wc -l file.txt | awk \\'{print $1}\\') -gt 9 ]; then cat file.txt | head -n10 | tail -1; fi`"
                    },
                    {
                        "username": "hazem1911",
                        "content": "`cat file.txt | cut -d$\\'\\\\n\\' -f10`"
                    },
                    {
                        "username": "Motherbrain",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "RetroCoder80s",
                        "content": "This problem is tagged as \"bash\" so it should be possible to use ANY command line tool that works in bash like \"bat\" - i.e: bat -r 10:10 file.txt !"
                    }
                ]
            },
            {
                "id": 1573408,
                "content": [
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "somayyah_mohd",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "user3154L",
                        "content": "`awk \\'NR==10\\' file.txt`"
                    },
                    {
                        "username": "echobash",
                        "content": "cat file.txt | awk \\'{if(NR==10)print} \\'"
                    },
                    {
                        "username": "zhoucego",
                        "content": "awk \\'NR == 10\\' file.txt\\n\\n\\n"
                    },
                    {
                        "username": "chinmay93",
                        "content": "sed \\'10q;d\\' file.txt"
                    },
                    {
                        "username": "variable_infiltration",
                        "content": "`if [ $(wc -l file.txt | awk \\'{print $1}\\') -gt 9 ]; then cat file.txt | head -n10 | tail -1; fi`"
                    },
                    {
                        "username": "hazem1911",
                        "content": "`cat file.txt | cut -d$\\'\\\\n\\' -f10`"
                    },
                    {
                        "username": "Motherbrain",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "RetroCoder80s",
                        "content": "This problem is tagged as \"bash\" so it should be possible to use ANY command line tool that works in bash like \"bat\" - i.e: bat -r 10:10 file.txt !"
                    }
                ]
            },
            {
                "id": 1572640,
                "content": [
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "somayyah_mohd",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "user3154L",
                        "content": "`awk \\'NR==10\\' file.txt`"
                    },
                    {
                        "username": "echobash",
                        "content": "cat file.txt | awk \\'{if(NR==10)print} \\'"
                    },
                    {
                        "username": "zhoucego",
                        "content": "awk \\'NR == 10\\' file.txt\\n\\n\\n"
                    },
                    {
                        "username": "chinmay93",
                        "content": "sed \\'10q;d\\' file.txt"
                    },
                    {
                        "username": "variable_infiltration",
                        "content": "`if [ $(wc -l file.txt | awk \\'{print $1}\\') -gt 9 ]; then cat file.txt | head -n10 | tail -1; fi`"
                    },
                    {
                        "username": "hazem1911",
                        "content": "`cat file.txt | cut -d$\\'\\\\n\\' -f10`"
                    },
                    {
                        "username": "Motherbrain",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "RetroCoder80s",
                        "content": "This problem is tagged as \"bash\" so it should be possible to use ANY command line tool that works in bash like \"bat\" - i.e: bat -r 10:10 file.txt !"
                    }
                ]
            },
            {
                "id": 1572408,
                "content": [
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "somayyah_mohd",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "user3154L",
                        "content": "`awk \\'NR==10\\' file.txt`"
                    },
                    {
                        "username": "echobash",
                        "content": "cat file.txt | awk \\'{if(NR==10)print} \\'"
                    },
                    {
                        "username": "zhoucego",
                        "content": "awk \\'NR == 10\\' file.txt\\n\\n\\n"
                    },
                    {
                        "username": "chinmay93",
                        "content": "sed \\'10q;d\\' file.txt"
                    },
                    {
                        "username": "variable_infiltration",
                        "content": "`if [ $(wc -l file.txt | awk \\'{print $1}\\') -gt 9 ]; then cat file.txt | head -n10 | tail -1; fi`"
                    },
                    {
                        "username": "hazem1911",
                        "content": "`cat file.txt | cut -d$\\'\\\\n\\' -f10`"
                    },
                    {
                        "username": "Motherbrain",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "RetroCoder80s",
                        "content": "This problem is tagged as \"bash\" so it should be possible to use ANY command line tool that works in bash like \"bat\" - i.e: bat -r 10:10 file.txt !"
                    }
                ]
            },
            {
                "id": 1572270,
                "content": [
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "somayyah_mohd",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "user3154L",
                        "content": "`awk \\'NR==10\\' file.txt`"
                    },
                    {
                        "username": "echobash",
                        "content": "cat file.txt | awk \\'{if(NR==10)print} \\'"
                    },
                    {
                        "username": "zhoucego",
                        "content": "awk \\'NR == 10\\' file.txt\\n\\n\\n"
                    },
                    {
                        "username": "chinmay93",
                        "content": "sed \\'10q;d\\' file.txt"
                    },
                    {
                        "username": "variable_infiltration",
                        "content": "`if [ $(wc -l file.txt | awk \\'{print $1}\\') -gt 9 ]; then cat file.txt | head -n10 | tail -1; fi`"
                    },
                    {
                        "username": "hazem1911",
                        "content": "`cat file.txt | cut -d$\\'\\\\n\\' -f10`"
                    },
                    {
                        "username": "Motherbrain",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "RetroCoder80s",
                        "content": "This problem is tagged as \"bash\" so it should be possible to use ANY command line tool that works in bash like \"bat\" - i.e: bat -r 10:10 file.txt !"
                    }
                ]
            },
            {
                "id": 1575820,
                "content": [
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "somayyah_mohd",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "user3154L",
                        "content": "`awk \\'NR==10\\' file.txt`"
                    },
                    {
                        "username": "echobash",
                        "content": "cat file.txt | awk \\'{if(NR==10)print} \\'"
                    },
                    {
                        "username": "zhoucego",
                        "content": "awk \\'NR == 10\\' file.txt\\n\\n\\n"
                    },
                    {
                        "username": "chinmay93",
                        "content": "sed \\'10q;d\\' file.txt"
                    },
                    {
                        "username": "variable_infiltration",
                        "content": "`if [ $(wc -l file.txt | awk \\'{print $1}\\') -gt 9 ]; then cat file.txt | head -n10 | tail -1; fi`"
                    },
                    {
                        "username": "hazem1911",
                        "content": "`cat file.txt | cut -d$\\'\\\\n\\' -f10`"
                    },
                    {
                        "username": "Motherbrain",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "RetroCoder80s",
                        "content": "This problem is tagged as \"bash\" so it should be possible to use ANY command line tool that works in bash like \"bat\" - i.e: bat -r 10:10 file.txt !"
                    }
                ]
            },
            {
                "id": 1574716,
                "content": [
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "somayyah_mohd",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "user3154L",
                        "content": "`awk \\'NR==10\\' file.txt`"
                    },
                    {
                        "username": "echobash",
                        "content": "cat file.txt | awk \\'{if(NR==10)print} \\'"
                    },
                    {
                        "username": "zhoucego",
                        "content": "awk \\'NR == 10\\' file.txt\\n\\n\\n"
                    },
                    {
                        "username": "chinmay93",
                        "content": "sed \\'10q;d\\' file.txt"
                    },
                    {
                        "username": "variable_infiltration",
                        "content": "`if [ $(wc -l file.txt | awk \\'{print $1}\\') -gt 9 ]; then cat file.txt | head -n10 | tail -1; fi`"
                    },
                    {
                        "username": "hazem1911",
                        "content": "`cat file.txt | cut -d$\\'\\\\n\\' -f10`"
                    },
                    {
                        "username": "Motherbrain",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "RetroCoder80s",
                        "content": "This problem is tagged as \"bash\" so it should be possible to use ANY command line tool that works in bash like \"bat\" - i.e: bat -r 10:10 file.txt !"
                    }
                ]
            },
            {
                "id": 2056576,
                "content": [
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "somayyah_mohd",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "user3154L",
                        "content": "`awk \\'NR==10\\' file.txt`"
                    },
                    {
                        "username": "echobash",
                        "content": "cat file.txt | awk \\'{if(NR==10)print} \\'"
                    },
                    {
                        "username": "zhoucego",
                        "content": "awk \\'NR == 10\\' file.txt\\n\\n\\n"
                    },
                    {
                        "username": "chinmay93",
                        "content": "sed \\'10q;d\\' file.txt"
                    },
                    {
                        "username": "variable_infiltration",
                        "content": "`if [ $(wc -l file.txt | awk \\'{print $1}\\') -gt 9 ]; then cat file.txt | head -n10 | tail -1; fi`"
                    },
                    {
                        "username": "hazem1911",
                        "content": "`cat file.txt | cut -d$\\'\\\\n\\' -f10`"
                    },
                    {
                        "username": "Motherbrain",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "RetroCoder80s",
                        "content": "This problem is tagged as \"bash\" so it should be possible to use ANY command line tool that works in bash like \"bat\" - i.e: bat -r 10:10 file.txt !"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Median from Data Stream",
        "question_content": "<p>The <strong>median</strong> is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.</p>\n\n<ul>\n\t<li>For example, for <code>arr = [2,3,4]</code>, the median is <code>3</code>.</li>\n\t<li>For example, for <code>arr = [2,3]</code>, the median is <code>(2 + 3) / 2 = 2.5</code>.</li>\n</ul>\n\n<p>Implement the MedianFinder class:</p>\n\n<ul>\n\t<li><code>MedianFinder()</code> initializes the <code>MedianFinder</code> object.</li>\n\t<li><code>void addNum(int num)</code> adds the integer <code>num</code> from the data stream to the data structure.</li>\n\t<li><code>double findMedian()</code> returns the median of all elements so far. Answers within <code>10<sup>-5</sup></code> of the actual answer will be accepted.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MedianFinder&quot;, &quot;addNum&quot;, &quot;addNum&quot;, &quot;findMedian&quot;, &quot;addNum&quot;, &quot;findMedian&quot;]\n[[], [1], [2], [], [3], []]\n<strong>Output</strong>\n[null, null, null, 1.5, null, 2.0]\n\n<strong>Explanation</strong>\nMedianFinder medianFinder = new MedianFinder();\nmedianFinder.addNum(1);    // arr = [1]\nmedianFinder.addNum(2);    // arr = [1, 2]\nmedianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\nmedianFinder.addNum(3);    // arr[1, 2, 3]\nmedianFinder.findMedian(); // return 2.0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-10<sup>5</sup> &lt;= num &lt;= 10<sup>5</sup></code></li>\n\t<li>There will be at least one element in the data structure before calling <code>findMedian</code>.</li>\n\t<li>At most <code>5 * 10<sup>4</sup></code> calls will be made to <code>addNum</code> and <code>findMedian</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>If all integer numbers from the stream are in the range <code>[0, 100]</code>, how would you optimize your solution?</li>\n\t<li>If <code>99%</code> of all integer numbers from the stream are in the range <code>[0, 100]</code>, how would you optimize your solution?</li>\n</ul>\n",
        "solutions": [
            {
                "id": 74047,
                "title": "java-python-two-heap-solution-o-log-n-add-o-1-find",
                "content": "The invariant of the algorithm is two heaps, small and large, each represent half of the current list. The length of smaller half is kept to be n / 2 at all time and the length of the larger half is either n / 2 or n / 2 + 1 depend on n's parity. \\n\\nThis way we only need to peek the two heaps' top number to calculate median.\\n\\nAny time before we add a new number, there are two scenarios, (total n numbers, k = n / 2):\\n\\n    (1) length of (small, large) == (k, k)\\n    (2) length of (small, large) == (k, k + 1)\\n\\nAfter adding the number, total (n + 1) numbers, they will become:\\n\\n    (1) length of (small, large) == (k, k + 1)\\n    (2) length of (small, large) == (k + 1, k + 1)\\n\\nHere we take the first scenario for example, we know the large will gain one more item and small will remain the same size, but we cannot just push the item into large. What we should do is we push the new number into small and pop the maximum item from small then push it into large (all the pop and push here are heappop and heappush). By doing this kind of operations for the two scenarios we can keep our invariant.\\n\\nTherefore to add a number, we have 3 O(log n) heap operations. Luckily the heapq provided us a function \"heappushpop\" which saves some time by combine two into one. The document says:\\n\\n<blockquote>Push item on the heap, then pop and return the smallest item from the heap. The combined action runs more efficiently than heappush() followed by a separate call to heappop().</blockquote>\\n\\nAlltogether, the add operation is O(logn), The findMedian operation is O(1). \\n\\nNote that the heapq in python is a min heap, thus we need to invert the values in the smaller half to mimic a \"max heap\".\\n\\nA further observation is that the two scenarios take turns when adding numbers, thus it is possible to combine the two into one. For this please see [stefan's post][1]\\n\\n\\n**Java**\\n\\n    private PriorityQueue<Integer> small = new PriorityQueue<>(Collections.reverseOrder());\\n    private PriorityQueue<Integer> large = new PriorityQueue<>();\\n    private boolean even = true;\\n\\n    public double findMedian() {\\n        if (even)\\n            return (small.peek() + large.peek()) / 2.0;\\n        else\\n            return small.peek();\\n    }\\n\\n    public void addNum(int num) {\\n        if (even) {\\n            large.offer(num);\\n            small.offer(large.poll());\\n        } else {\\n            small.offer(num);\\n            large.offer(small.poll());\\n        }\\n        even = !even;\\n    }\\n\\n\\n**Python**\\n\\n    from heapq import *\\n    \\n    \\n    class MedianFinder:\\n        def __init__(self):\\n            self.small = []  # the smaller half of the list, max heap (invert min-heap)\\n            self.large = []  # the larger half of the list, min heap\\n    \\n        def addNum(self, num):\\n            if len(self.small) == len(self.large):\\n                heappush(self.large, -heappushpop(self.small, -num))\\n            else:\\n                heappush(self.small, -heappushpop(self.large, num))\\n    \\n        def findMedian(self):\\n            if len(self.small) == len(self.large):\\n                return float(self.large[0] - self.small[0]) / 2.0\\n            else:\\n                return float(self.large[0])\\n\\n    # 18 / 18 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 388 ms\\n\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/64910/very-short-o-log-n-o-1",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "The invariant of the algorithm is two heaps, small and large, each represent half of the current list. The length of smaller half is kept to be n / 2 at all time and the length of the larger half is either n / 2 or n / 2 + 1 depend on n's parity. \\n\\nThis way we only need to peek the two heaps' top number to calculate median.\\n\\nAny time before we add a new number, there are two scenarios, (total n numbers, k = n / 2):\\n\\n    (1) length of (small, large) == (k, k)\\n    (2) length of (small, large) == (k, k + 1)\\n\\nAfter adding the number, total (n + 1) numbers, they will become:\\n\\n    (1) length of (small, large) == (k, k + 1)\\n    (2) length of (small, large) == (k + 1, k + 1)\\n\\nHere we take the first scenario for example, we know the large will gain one more item and small will remain the same size, but we cannot just push the item into large. What we should do is we push the new number into small and pop the maximum item from small then push it into large (all the pop and push here are heappop and heappush). By doing this kind of operations for the two scenarios we can keep our invariant.\\n\\nTherefore to add a number, we have 3 O(log n) heap operations. Luckily the heapq provided us a function \"heappushpop\" which saves some time by combine two into one. The document says:\\n\\n<blockquote>Push item on the heap, then pop and return the smallest item from the heap. The combined action runs more efficiently than heappush() followed by a separate call to heappop().</blockquote>\\n\\nAlltogether, the add operation is O(logn), The findMedian operation is O(1). \\n\\nNote that the heapq in python is a min heap, thus we need to invert the values in the smaller half to mimic a \"max heap\".\\n\\nA further observation is that the two scenarios take turns when adding numbers, thus it is possible to combine the two into one. For this please see [stefan's post][1]\\n\\n\\n**Java**\\n\\n    private PriorityQueue<Integer> small = new PriorityQueue<>(Collections.reverseOrder());\\n    private PriorityQueue<Integer> large = new PriorityQueue<>();\\n    private boolean even = true;\\n\\n    public double findMedian() {\\n        if (even)\\n            return (small.peek() + large.peek()) / 2.0;\\n        else\\n            return small.peek();\\n    }\\n\\n    public void addNum(int num) {\\n        if (even) {\\n            large.offer(num);\\n            small.offer(large.poll());\\n        } else {\\n            small.offer(num);\\n            large.offer(small.poll());\\n        }\\n        even = !even;\\n    }\\n\\n\\n**Python**\\n\\n    from heapq import *\\n    \\n    \\n    class MedianFinder:\\n        def __init__(self):\\n            self.small = []  # the smaller half of the list, max heap (invert min-heap)\\n            self.large = []  # the larger half of the list, min heap\\n    \\n        def addNum(self, num):\\n            if len(self.small) == len(self.large):\\n                heappush(self.large, -heappushpop(self.small, -num))\\n            else:\\n                heappush(self.small, -heappushpop(self.large, num))\\n    \\n        def findMedian(self):\\n            if len(self.small) == len(self.large):\\n                return float(self.large[0] - self.small[0]) / 2.0\\n            else:\\n                return float(self.large[0])\\n\\n    # 18 / 18 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 388 ms\\n\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/64910/very-short-o-log-n-o-1",
                "codeTag": "Java"
            },
            {
                "id": 74062,
                "title": "short-simple-java-c-python-o-log-n-o-1",
                "content": "I keep two heaps (or priority queues):\\n\\n- Max-heap `small` has the smaller half of the numbers.\\n- Min-heap `large` has the larger half of the numbers.\\n\\nThis gives me direct access to the one or two middle values (they're the tops of the heaps), so getting the median takes O(1) time. And adding a number takes O(log n) time.\\n\\nSupporting both min- and max-heap is more or less cumbersome, depending on the language, so I simply negate the numbers in the heap in which I want the reverse of the default order. To prevent this from causing a bug with -2<sup>31</sup> (which negated is itself, when using 32-bit ints), I use integer types larger than 32 bits.\\n\\nUsing larger integer types also prevents an overflow error when taking the mean of the two middle numbers. I think almost all solutions posted previously have that bug.\\n\\n**Update:** These are pretty short already, but by now I wrote [even shorter ones](https://leetcode.com/discuss/64910/very-short-o-log-n-o-1).\\n\\n---\\n\\n**Java**\\n\\n    class MedianFinder {\\n    \\n        private Queue<Long> small = new PriorityQueue(),\\n                            large = new PriorityQueue();\\n    \\n        public void addNum(int num) {\\n            large.add((long) num);\\n            small.add(-large.poll());\\n            if (large.size() < small.size())\\n                large.add(-small.poll());\\n        }\\n    \\n        public double findMedian() {\\n            return large.size() > small.size()\\n                   ? large.peek()\\n                   : (large.peek() - small.peek()) / 2.0;\\n        }\\n    };\\n\\nProps to [larrywang2014's solution](https://leetcode.com/discuss/64842/32ms-easy-to-understand-java-solution) for making me aware that I can use Queue in the declaration instead of PriorityQueue (that's all I got from him, though (just saying because I just saw he changed his previously longer addNum and it's now equivalent to mine)).\\n\\n---\\n\\n**C++**\\n\\n    class MedianFinder {\\n        priority_queue<long> small, large;\\n    public:\\n    \\n        void addNum(int num) {\\n            small.push(num);\\n            large.push(-small.top());\\n            small.pop();\\n            if (small.size() < large.size()) {\\n                small.push(-large.top());\\n                large.pop();\\n            }\\n        }\\n    \\n        double findMedian() {\\n            return small.size() > large.size()\\n                   ? small.top()\\n                   : (small.top() - large.top()) / 2.0;\\n        }\\n    };\\n\\nBig thanks to jianchao.li.fighter for telling me that C++'s priority_queue is a max-queue (see comments below).\\n\\n---\\n\\n**Python**\\n\\n    from heapq import *\\n    \\n    class MedianFinder:\\n    \\n        def __init__(self):\\n            self.heaps = [], []\\n    \\n        def addNum(self, num):\\n            small, large = self.heaps\\n            heappush(small, -heappushpop(large, num))\\n            if len(large) < len(small):\\n                heappush(large, -heappop(small))\\n    \\n        def findMedian(self):\\n            small, large = self.heaps\\n            if len(large) > len(small):\\n                return float(large[0])\\n            return (large[0] - small[0]) / 2.0",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "I keep two heaps (or priority queues):\\n\\n- Max-heap `small` has the smaller half of the numbers.\\n- Min-heap `large` has the larger half of the numbers.\\n\\nThis gives me direct access to the one or two middle values (they're the tops of the heaps), so getting the median takes O(1) time. And adding a number takes O(log n) time.\\n\\nSupporting both min- and max-heap is more or less cumbersome, depending on the language, so I simply negate the numbers in the heap in which I want the reverse of the default order. To prevent this from causing a bug with -2<sup>31</sup> (which negated is itself, when using 32-bit ints), I use integer types larger than 32 bits.\\n\\nUsing larger integer types also prevents an overflow error when taking the mean of the two middle numbers. I think almost all solutions posted previously have that bug.\\n\\n**Update:** These are pretty short already, but by now I wrote [even shorter ones](https://leetcode.com/discuss/64910/very-short-o-log-n-o-1).\\n\\n---\\n\\n**Java**\\n\\n    class MedianFinder {\\n    \\n        private Queue<Long> small = new PriorityQueue(),\\n                            large = new PriorityQueue();\\n    \\n        public void addNum(int num) {\\n            large.add((long) num);\\n            small.add(-large.poll());\\n            if (large.size() < small.size())\\n                large.add(-small.poll());\\n        }\\n    \\n        public double findMedian() {\\n            return large.size() > small.size()\\n                   ? large.peek()\\n                   : (large.peek() - small.peek()) / 2.0;\\n        }\\n    };\\n\\nProps to [larrywang2014's solution](https://leetcode.com/discuss/64842/32ms-easy-to-understand-java-solution) for making me aware that I can use Queue in the declaration instead of PriorityQueue (that's all I got from him, though (just saying because I just saw he changed his previously longer addNum and it's now equivalent to mine)).\\n\\n---\\n\\n**C++**\\n\\n    class MedianFinder {\\n        priority_queue<long> small, large;\\n    public:\\n    \\n        void addNum(int num) {\\n            small.push(num);\\n            large.push(-small.top());\\n            small.pop();\\n            if (small.size() < large.size()) {\\n                small.push(-large.top());\\n                large.pop();\\n            }\\n        }\\n    \\n        double findMedian() {\\n            return small.size() > large.size()\\n                   ? small.top()\\n                   : (small.top() - large.top()) / 2.0;\\n        }\\n    };\\n\\nBig thanks to jianchao.li.fighter for telling me that C++'s priority_queue is a max-queue (see comments below).\\n\\n---\\n\\n**Python**\\n\\n    from heapq import *\\n    \\n    class MedianFinder:\\n    \\n        def __init__(self):\\n            self.heaps = [], []\\n    \\n        def addNum(self, num):\\n            small, large = self.heaps\\n            heappush(small, -heappushpop(large, num))\\n            if len(large) < len(small):\\n                heappush(large, -heappop(small))\\n    \\n        def findMedian(self):\\n            small, large = self.heaps\\n            if len(large) > len(small):\\n                return float(large[0])\\n            return (large[0] - small[0]) / 2.0",
                "codeTag": "Java"
            },
            {
                "id": 1330646,
                "title": "c-java-python-minheap-maxheap-solution-picture-explain-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: MaxHeap to store a half of low numbers, MinHeap to store a half of high numbers**\\n- The idea is to divide numbers into 2 balanced halves, one half `low` stores low numbers, the other half `high` stores high numbers. To access the median in `O(1)`, we need a data structure that give us the maximum of `low` half and the minimum of `high` half in `O(1)`. That\\'s where `maxHeap` and `minHeap` come into play.\\n- We use `maxHeap` to store a half of **low numbers**, top of the maxHeap is the highest number among low numbers.\\n- We use `minHeap` to store a half of **high numbers**, top of the minHeap is the lowest number among high numbers.\\n- We need to balance the size between `maxHeap` and `minHeap` while processing. Hence after adding `k` elements, \\n\\t- If `k = 2 * i` then `maxHeap.size = minHeap.size = i`\\n\\t- If `k = 2 * i + 1`, let `maxHeap` store 1 element more than `minHeap`, then `maxHeap.size = minHeap.size + 1`.\\n- When adding a new number `num` into our  `MedianFinder`:\\n\\t- Firstly, add `num` to the `maxHeap`, now `maxHeap` may contain the big element (which should belong to `minHeap`). So we need to balance, by removing the highest element from `maxHeap`, and offer it to `minHeap`. \\n\\t- Now, the `minHeap` might hold more elements than `maxHeap`, in that case, we need to balance the size, by removing the lowest element from `minHeap` and offer it back to `maxHeap`.\\n- When doing `findMedian()`:\\n\\t- If `maxHeap.size > minHeap.size` return top of the `maxHeap`, which is the highest number amongs low numbers.\\n\\t- Else if `maxHeap.size == minHeap` return the `(maxHeap.top() + minHeap.top()) / 2`.\\n\\n![image](https://assets.leetcode.com/users/images/0eb8feba-cbfa-4f73-8d26-9aad226bdbc5_1626016093.9717174.png)\\n\\n\\n<iframe src=\"https://leetcode.com/playground/FbECj5Ww/shared\" frameBorder=\"0\" width=\"100%\" height=\"420\"></iframe>\\n\\n**Complexity**\\n- Time:\\n\\t- Constructor: `O(1)`\\n\\t- addNum: `O(logN)`\\n\\t- findMedian: `O(1)`\\n- Space: `O(N)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: SortedList**\\n```python\\nfrom sortedcontainers import SortedList\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        self.arr = SortedList()\\n\\n    def addNum(self, num: int) -> None:\\n        self.arr.add(num)\\n\\n    def findMedian(self) -> float:\\n        n = len(self.arr)\\n        if n % 2 == 1:\\n            return self.arr[n//2]\\n        return (self.arr[n//2] + self.arr[n//2-1]) / 2\\n```\\n**Complexity**\\n- Time:\\n\\t- Constructor: `O(1)`\\n\\t- addNum, findMedian: `O(logN)`\\n- Space: `O(N)`\\n\\n",
                "solutionTags": [],
                "code": "```python\\nfrom sortedcontainers import SortedList\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        self.arr = SortedList()\\n\\n    def addNum(self, num: int) -> None:\\n        self.arr.add(num)\\n\\n    def findMedian(self) -> float:\\n        n = len(self.arr)\\n        if n % 2 == 1:\\n            return self.arr[n//2]\\n        return (self.arr[n//2] + self.arr[n//2-1]) / 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 74163,
                "title": "my-c-priority-queue-based-solution-140-ms",
                "content": "The idea is to use two heaps  (one max heap, one mn heap) to save the input data. firstQ is a max_heap to save the first half of the data with smaller values,  and secQ is a min_heap to save the second half of the data with bigger values. Everytime when inserting a new value, we first compare if it is smaller than the top of firstQ (the largest value of the first half), if so, insert into firstQ. Otherwise, it belongs to the second half.  After inserting, we have to balance the first half and the second half to make sure either they have the same length or the length difference is only 1. \\nThe median will be the mean of two top elements (when they have the same length) or the top element of the queue with a larger length. \\n\\n    class MedianFinder {\\n    private:\\n        priority_queue<int> firstQ; // max_heap for the first half\\n        priority_queue<int, std::vector<int>, std::greater<int> > secQ; // min_heap for the second half\\n    public:\\n        // Adds a number into the data structure.\\n        void addNum(int num) {\\n            if(firstQ.empty() || (firstQ.top()>num)) firstQ.push(num); // if it belongs to the smaller half\\n            else secQ.push(num); \\n            \\n            // rebalance the two halfs to make sure the length difference is no larger than 1\\n            if(firstQ.size() > (secQ.size()+1))\\n            {\\n                secQ.push(firstQ.top());\\n                firstQ.pop();\\n            }\\n            else if(firstQ.size()+1<secQ.size())\\n            {\\n                firstQ.push(secQ.top());\\n                secQ.pop();\\n            }\\n        }\\n    \\n        // Returns the median of current data stream\\n        double findMedian() {\\n            if(firstQ.size() == secQ.size()) return firstQ.empty()?0:( (firstQ.top()+secQ.top())/2.0);\\n            else return (firstQ.size() > secQ.size())? firstQ.top():secQ.top(); \\n        }\\n    };",
                "solutionTags": [],
                "code": "The idea is to use two heaps  (one max heap, one mn heap) to save the input data. firstQ is a max_heap to save the first half of the data with smaller values,  and secQ is a min_heap to save the second half of the data with bigger values. Everytime when inserting a new value, we first compare if it is smaller than the top of firstQ (the largest value of the first half), if so, insert into firstQ. Otherwise, it belongs to the second half.  After inserting, we have to balance the first half and the second half to make sure either they have the same length or the length difference is only 1. \\nThe median will be the mean of two top elements (when they have the same length) or the top element of the queue with a larger length. \\n\\n    class MedianFinder {\\n    private:\\n        priority_queue<int> firstQ; // max_heap for the first half\\n        priority_queue<int, std::vector<int>, std::greater<int> > secQ; // min_heap for the second half\\n    public:\\n        // Adds a number into the data structure.\\n        void addNum(int num) {\\n            if(firstQ.empty() || (firstQ.top()>num)) firstQ.push(num); // if it belongs to the smaller half\\n            else secQ.push(num); \\n            \\n            // rebalance the two halfs to make sure the length difference is no larger than 1\\n            if(firstQ.size() > (secQ.size()+1))\\n            {\\n                secQ.push(firstQ.top());\\n                firstQ.pop();\\n            }\\n            else if(firstQ.size()+1<secQ.size())\\n            {\\n                firstQ.push(secQ.top());\\n                secQ.pop();\\n            }\\n        }\\n    \\n        // Returns the median of current data stream\\n        double findMedian() {\\n            if(firstQ.size() == secQ.size()) return firstQ.empty()?0:( (firstQ.top()+secQ.top())/2.0);\\n            else return (firstQ.size() > secQ.size())? firstQ.top():secQ.top(); \\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 74049,
                "title": "share-my-java-solution-logn-to-insert-o-1-to-query",
                "content": "Not sure why it is marked as hard, i think this is one of the easiest questions on leetcode.\\n\\n    class MedianFinder {\\n        // max queue is always larger or equal to min queue\\n        PriorityQueue<Integer> min = new PriorityQueue();\\n        PriorityQueue<Integer> max = new PriorityQueue(1000, Collections.reverseOrder());\\n        // Adds a number into the data structure.\\n        public void addNum(int num) {\\n            max.offer(num);\\n            min.offer(max.poll());\\n            if (max.size() < min.size()){\\n                max.offer(min.poll());\\n            }\\n        }\\n    \\n        // Returns the median of current data stream\\n        public double findMedian() {\\n            if (max.size() == min.size()) return (max.peek() + min.peek()) /  2.0;\\n            else return max.peek();\\n        }\\n    };",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "Not sure why it is marked as hard, i think this is one of the easiest questions on leetcode.\\n\\n    class MedianFinder {\\n        // max queue is always larger or equal to min queue\\n        PriorityQueue<Integer> min = new PriorityQueue();\\n        PriorityQueue<Integer> max = new PriorityQueue(1000, Collections.reverseOrder());\\n        // Adds a number into the data structure.\\n        public void addNum(int num) {\\n            max.offer(num);\\n            min.offer(max.poll());\\n            if (max.size() < min.size()){\\n                max.offer(min.poll());\\n            }\\n        }\\n    \\n        // Returns the median of current data stream\\n        public double findMedian() {\\n            if (max.size() == min.size()) return (max.peek() + min.peek()) /  2.0;\\n            else return max.peek();\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 74158,
                "title": "python-o-lgn-using-two-heapq-data-sturctures",
                "content": "    class MedianFinder:\\n    import heapq\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.small = [] # store the small half, top is the largest in the small part\\n        self.large = [] # store the large half, top is the smallest in the large part\\n\\n    def addNum(self, num):\\n        \"\"\"\\n        Adds a num into the data structure.\\n        :type num: int\\n        :rtype: void\\n        \"\"\"\\n        if len(self.small) == 0:\\n            heapq.heappush(self.small, -num)\\n            return\\n        if num <= -self.small[0]:\\n            # push to small part\\n            heapq.heappush(self.small, -num)\\n        else:\\n            # push to large part\\n            heapq.heappush(self.large, num)\\n        # adjust small and large balance\\n        if len(self.small) - len(self.large) == 2:\\n            heapq.heappush(self.large, -heapq.heappop(self.small))\\n        elif len(self.small) - len(self.large) == -2:\\n            heapq.heappush(self.small, -heapq.heappop(self.large))\\n\\n    def findMedian(self):\\n        \"\"\"\\n        Returns the median of current data stream\\n        :rtype: float\\n        \"\"\"\\n        if len(self.small) == len(self.large):\\n            return (self.large[0] - self.small[0])/2.0\\n        return -float(self.small[0]) if len(self.small) > len(self.large) else float(self.large[0])",
                "solutionTags": [],
                "code": "    class MedianFinder:\\n    import heapq\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.small = [] # store the small half, top is the largest in the small part\\n        self.large = [] # store the large half, top is the smallest in the large part\\n\\n    def addNum(self, num):\\n        \"\"\"\\n        Adds a num into the data structure.\\n        :type num: int\\n        :rtype: void\\n        \"\"\"\\n        if len(self.small) == 0:\\n            heapq.heappush(self.small, -num)\\n            return\\n        if num <= -self.small[0]:\\n            # push to small part\\n            heapq.heappush(self.small, -num)\\n        else:\\n            # push to large part\\n            heapq.heappush(self.large, num)\\n        # adjust small and large balance\\n        if len(self.small) - len(self.large) == 2:\\n            heapq.heappush(self.large, -heapq.heappop(self.small))\\n        elif len(self.small) - len(self.large) == -2:\\n            heapq.heappush(self.small, -heapq.heappop(self.large))\\n\\n    def findMedian(self):\\n        \"\"\"\\n        Returns the median of current data stream\\n        :rtype: float\\n        \"\"\"\\n        if len(self.small) == len(self.large):\\n            return (self.large[0] - self.small[0])/2.0\\n        return -float(self.small[0]) if len(self.small) > len(self.large) else float(self.large[0])",
                "codeTag": "Java"
            },
            {
                "id": 286238,
                "title": "java-simple-code-follow-up",
                "content": "- If the range of the numbers is in `[0...100]`, we use a bucket to collect the frequency of each number. By accumulating the frequency of elements in the bucket, we can know the median numbers.\\n````\\n\\tclass MedianFinder {\\n        int A[] = new int[101], n = 0;\\n\\t\\t\\n\\t\\t// O(1)\\n        public void addNum(int num) {\\n            A[num]++;\\n            n++;\\n        }\\n\\t\\t\\n\\t\\t// O(100) = O(1)\\n        public double findMedian() {\\n\\t\\t\\n\\t\\t\\t// find 1st median number\\n            int count = 0, i = 0;\\t\\t\\t\\n            while (count < n/2) count += A[i++];\\n\\t\\t\\t\\n\\t\\t\\t// find 2nd median number\\n            int j = i;\\n            while (count < n/2+1) count += A[j++];\\n\\t\\t\\t\\n            return (n%2 == 1) ? i : (i-1+j-1) / 2.0;\\n        }\\n    }\\n````\\n\\n- If `1%` numbers are outside of the range `[0...100]`, we know that when the set of numbers is large, the median numbers must be in the range of `[0...100]`, because this range contains `99%` numbers. We don\\'t need to store values of `1%` numbers, but the counts of these numbers (`countLessZero` & `countGreater100`). The `findMedian` method is almost the same, the difference is we start counting from `countLessZero` value\\n````\\n\\tclass MedianFinder {\\n        int A[] = new int[101], n = 0;\\n\\t\\tint countLessZero = 0;\\n\\t\\t// int countGreater100 = 0; // not needed\\n\\t\\t\\n\\t\\t// O(1)\\n        public void addNum(int num) {\\n\\t\\t\\tif (num < 0) countLessZero++;\\n\\t\\t\\t// else if (num > 100) countGreater100++;\\n\\t\\t\\telse A[num]++;\\n            n++;\\n        }\\n\\t\\t\\n\\t\\t// O(100) = O(1)\\n        public double findMedian() {\\n\\t\\t\\n\\t\\t\\t// find 1st median number\\n            int count = countLessZero, i = 0;\\t\\t\\t\\n            while (count < /2) count += A[i++];\\n\\t\\t\\t\\n\\t\\t\\t// find 2nd median number\\n            int j = i;\\n            while (count < n/2+1) count += A[j++];\\n\\t\\t\\t\\n            return (n%2 == 1) ? i : (i-1+j-1) / 2.0;\\n        }\\n    }\\n````\\n\\nInsert - `O(1)`, Find `O(1)`, Space Complexity `O(1)`\\n\\n",
                "solutionTags": [],
                "code": "````\\n\\tclass MedianFinder {\\n        int A[] = new int[101], n = 0;\\n\\t\\t\\n\\t\\t// O(1)\\n        public void addNum(int num) {\\n            A[num]++;\\n            n++;\\n        }\\n\\t\\t\\n\\t\\t// O(100) = O(1)\\n        public double findMedian() {\\n\\t\\t\\n\\t\\t\\t// find 1st median number\\n            int count = 0, i = 0;\\t\\t\\t\\n            while (count < n/2) count += A[i++];\\n\\t\\t\\t\\n\\t\\t\\t// find 2nd median number\\n            int j = i;\\n            while (count < n/2+1) count += A[j++];\\n\\t\\t\\t\\n            return (n%2 == 1) ? i : (i-1+j-1) / 2.0;\\n        }\\n    }\\n```\n````\\n\\tclass MedianFinder {\\n        int A[] = new int[101], n = 0;\\n\\t\\tint countLessZero = 0;\\n\\t\\t// int countGreater100 = 0; // not needed\\n\\t\\t\\n\\t\\t// O(1)\\n        public void addNum(int num) {\\n\\t\\t\\tif (num < 0) countLessZero++;\\n\\t\\t\\t// else if (num > 100) countGreater100++;\\n\\t\\t\\telse A[num]++;\\n            n++;\\n        }\\n\\t\\t\\n\\t\\t// O(100) = O(1)\\n        public double findMedian() {\\n\\t\\t\\n\\t\\t\\t// find 1st median number\\n            int count = countLessZero, i = 0;\\t\\t\\t\\n            while (count < /2) count += A[i++];\\n\\t\\t\\t\\n\\t\\t\\t// find 2nd median number\\n            int j = i;\\n            while (count < n/2+1) count += A[j++];\\n\\t\\t\\t\\n            return (n%2 == 1) ? i : (i-1+j-1) / 2.0;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805054,
                "title": "python3-max-and-min-heaps-sortedlist-o-log-n",
                "content": "The main issue we need to solve in this problem is to have a list that is always sorted in some way so we can access the middle one/two values easily. A binary search tree is ideal for this since we can add value to it in O(log n). In python, we use SortedList.\\n\\n```\\nfrom sortedcontainers import SortedList\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        self.s = SortedList()\\n\\n    def addNum(self, num: int) -> None:\\n        self.s.add(num)\\n\\n    def findMedian(self) -> float:\\n        l = len(self.s)\\n        if l%2==0:\\n            return (self.s[l//2-1]+self.s[l//2])/2\\n        return self.s[l//2]\\n\\n```\\n\\nI don\\'t think the interviewer is looking for an API call during the interview, so I don\\'t think giving the above answer can pass it. And a follow-up question would be, please implement the binary search tree...\\nAnother idea is to use a ```maxHeap``` to store the numbers in the first half of the list and a ```minHeap``` to store the numbers in the second half of the list. In order to get the median efficiently, we need to balance the two heaps so that the median/s is/are always on the top of the heap/s. To do this, each time when we add a number, we check the length of the two heaps and make sure``` maxHeap``` either has the same length as the ```minHeap``` (the entire list has an even length), or the ``` maxHeap``` has one more value than the ```minHeap``` (the entire list has an odd length).\\n```\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        ### max heap to store the first half of the list\\n        self.maxHeap = []\\n        ### min heap to store the second half of the list\\n        self.minHeap = []\\n\\n    def addNum(self, num: int) -> None:\\n        ### push num into the correct heap\\n        if not self.maxHeap or num <= -self.maxHeap[0]:\\n            heappush(self.maxHeap, -num)\\n        else:\\n            heappush(self.minHeap, num)\\n        \\n        ### banance the two heaps so that each of them representing half of the list\\n        ### for odd length list, len(maxHeap) == len(minHeap)+1\\n        ### for even length list, len(maxHeap) == len(minHeap)\\n        if len(self.minHeap) > len(self.maxHeap):\\n            heappush(self.maxHeap, -heappop(self.minHeap)) \\n        elif len(self.maxHeap) > len(self.minHeap)+1:\\n            heappush(self.minHeap, -heappop(self.maxHeap)) \\n\\n    def findMedian(self) -> float:\\n        \\n        ### if the length of entire list is even, \\n        ### get the mean of the two middle values\\n        if (len(self.maxHeap)+len(self.minHeap))%2==0:\\n            return (-self.maxHeap[0]+self.minHeap[0])/2\\n        \\n        ### when odd, we know that the median is in maxHeap\\n        return -self.maxHeap[0]\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        self.s = SortedList()\\n\\n    def addNum(self, num: int) -> None:\\n        self.s.add(num)\\n\\n    def findMedian(self) -> float:\\n        l = len(self.s)\\n        if l%2==0:\\n            return (self.s[l//2-1]+self.s[l//2])/2\\n        return self.s[l//2]\\n\\n```\n```maxHeap```\n```minHeap```\n``` maxHeap```\n```minHeap```\n``` maxHeap```\n```minHeap```\n```\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        ### max heap to store the first half of the list\\n        self.maxHeap = []\\n        ### min heap to store the second half of the list\\n        self.minHeap = []\\n\\n    def addNum(self, num: int) -> None:\\n        ### push num into the correct heap\\n        if not self.maxHeap or num <= -self.maxHeap[0]:\\n            heappush(self.maxHeap, -num)\\n        else:\\n            heappush(self.minHeap, num)\\n        \\n        ### banance the two heaps so that each of them representing half of the list\\n        ### for odd length list, len(maxHeap) == len(minHeap)+1\\n        ### for even length list, len(maxHeap) == len(minHeap)\\n        if len(self.minHeap) > len(self.maxHeap):\\n            heappush(self.maxHeap, -heappop(self.minHeap)) \\n        elif len(self.maxHeap) > len(self.minHeap)+1:\\n            heappush(self.minHeap, -heappop(self.maxHeap)) \\n\\n    def findMedian(self) -> float:\\n        \\n        ### if the length of entire list is even, \\n        ### get the mean of the two middle values\\n        if (len(self.maxHeap)+len(self.minHeap))%2==0:\\n            return (-self.maxHeap[0]+self.minHeap[0])/2\\n        \\n        ### when odd, we know that the median is in maxHeap\\n        return -self.maxHeap[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1048192,
                "title": "c-easy-understandable-two-heaps-intuitive-solution-o-logn-add-o-1-find",
                "content": "As the data stream continuously come in, we have to consider the middle most element everytime for calculating the median.\\n\\n**TWO HEAP INTUITION :** **We have to consider middle element/s where all other elements are sorted as data stream come. Heaps come into picture with less time complexity to achieve this. So, we keep two heaps, one min heap and one max heap and keep a track of middle elements by balancing each heap.**\\n\\nThe left heap is containing elements in decreasing order (Max to Min) and right heap is in increasing order (Min to Max) but all the elements are greater than the left heap elements. We start pushing the elements in left heap and try to balance it everytime by comparing with the new elements and with heap size and accordingly put it into the right heap.\\n```\\nclass MedianFinder {\\npublic:\\n    /** initialize your data structure here. */\\n    priority_queue<int, vector<int>, greater<int> > minHeap;\\n\\tpriority_queue<int> maxHeap;\\n    MedianFinder(){}\\n\\n    void addNum(int num) {\\n        if (maxHeap.empty() or maxHeap.top() > num) {\\n\\t\\t\\tmaxHeap.push(num);\\n\\t\\t} else {\\n\\t\\t\\tminHeap.push(num);\\n\\t\\t}\\n\\n\\t\\tif (maxHeap.size() > minHeap.size() + 1) {\\n\\t\\t\\tminHeap.push(maxHeap.top());\\n\\t\\t\\tmaxHeap.pop();\\n\\t\\t} else if (minHeap.size() > maxHeap.size() + 1) {\\n\\t\\t\\tmaxHeap.push(minHeap.top());\\n\\t\\t\\tminHeap.pop();\\n\\t\\t}\\n    }\\n    \\n    double findMedian() {\\n        if (maxHeap.size() == minHeap.size()) {\\n\\t\\t\\tif (maxHeap.empty()) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdouble avg = (maxHeap.top() + minHeap.top()) / 2.0;\\n\\t\\t\\t\\treturn avg;\\n\\t\\t\\t}\\n\\n\\t\\t} else {\\n\\t\\t\\treturn maxHeap.size() > minHeap.size() ? maxHeap.top() : minHeap.top();\\n\\t\\t}\\n    }\\n};\\n\\n```\\n\\nPlease upvote if you find the solution helpful :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass MedianFinder {\\npublic:\\n    /** initialize your data structure here. */\\n    priority_queue<int, vector<int>, greater<int> > minHeap;\\n\\tpriority_queue<int> maxHeap;\\n    MedianFinder(){}\\n\\n    void addNum(int num) {\\n        if (maxHeap.empty() or maxHeap.top() > num) {\\n\\t\\t\\tmaxHeap.push(num);\\n\\t\\t} else {\\n\\t\\t\\tminHeap.push(num);\\n\\t\\t}\\n\\n\\t\\tif (maxHeap.size() > minHeap.size() + 1) {\\n\\t\\t\\tminHeap.push(maxHeap.top());\\n\\t\\t\\tmaxHeap.pop();\\n\\t\\t} else if (minHeap.size() > maxHeap.size() + 1) {\\n\\t\\t\\tmaxHeap.push(minHeap.top());\\n\\t\\t\\tminHeap.pop();\\n\\t\\t}\\n    }\\n    \\n    double findMedian() {\\n        if (maxHeap.size() == minHeap.size()) {\\n\\t\\t\\tif (maxHeap.empty()) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdouble avg = (maxHeap.top() + minHeap.top()) / 2.0;\\n\\t\\t\\t\\treturn avg;\\n\\t\\t\\t}\\n\\n\\t\\t} else {\\n\\t\\t\\treturn maxHeap.size() > minHeap.size() ? maxHeap.top() : minHeap.top();\\n\\t\\t}\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696658,
                "title": "python-logic-explained-with-2-heaps-clean-code",
                "content": "```\\n\"\"\"\\n        ## RC ##\\n        ## APPROACH : 2 HEAPS ##\\n        ## LOGIC ##\\n        ## One minheap to store low values and second maxheap to store max values, we keep track and update median every time after insertion ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(logN) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\n        ## EXAMPLE ##\\n        Adding number 41\\n        MaxHeap lo: [41]           // MaxHeap stores the largest value at the top (index 0)\\n        MinHeap hi: []             // MinHeap stores the smallest value at the top (index 0)\\n        Median is 41\\n        =======================\\n        Adding number 35\\n        MaxHeap lo: [35]          // max heap stores smaller half of nums\\n        MinHeap hi: [41]          // min heap stores bigger half of nums\\n        Median is 38\\n        =======================\\n        Adding number 62\\n        MaxHeap lo: [41, 35]\\n        MinHeap hi: [62]\\n        Median is 41\\n        =======================\\n        Adding number 4\\n        MaxHeap lo: [35, 4]\\n        MinHeap hi: [41, 62]\\n        Median is 38\\n        =======================\\n        Adding number 97\\n        MaxHeap lo: [41, 35, 4]\\n        MinHeap hi: [62, 97]\\n        Median is 41\\n        =======================\\n        Adding number 108\\n        MaxHeap lo: [41, 35, 4]\\n        MinHeap hi: [62, 97, 108]\\n        Median is 51.5\\n\"\"\"\\n\\nclass MedianFinder:\\n    def __init__(self):\\n        self.lo = []  \\n        self.hi = []  \\n\\n    def addNum(self, num):\\n        heappush(self.lo, -num)             # lo is maxheap, so -1 * num\\n        heappush(self.hi, -self.lo[0])      # hi is minheap\\n        heappop(self.lo)\\n        \\n        if len(self.lo) < len(self.hi):\\n            heappush(self.lo, -self.hi[0])\\n            heappop(self.hi)\\n            \\n    def findMedian(self):\\n        if len(self.lo) > len(self.hi):\\n            return -self.lo[0]                  \\n        else:\\n            return (self.hi[0] - self.lo[0]) / 2  # - as low has -ve values\\n```\\nPLEASE UPVOTE IF YOU LIKE MY SOLUTION",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\"\"\"\\n        ## RC ##\\n        ## APPROACH : 2 HEAPS ##\\n        ## LOGIC ##\\n        ## One minheap to store low values and second maxheap to store max values, we keep track and update median every time after insertion ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(logN) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\n        ## EXAMPLE ##\\n        Adding number 41\\n        MaxHeap lo: [41]           // MaxHeap stores the largest value at the top (index 0)\\n        MinHeap hi: []             // MinHeap stores the smallest value at the top (index 0)\\n        Median is 41\\n        =======================\\n        Adding number 35\\n        MaxHeap lo: [35]          // max heap stores smaller half of nums\\n        MinHeap hi: [41]          // min heap stores bigger half of nums\\n        Median is 38\\n        =======================\\n        Adding number 62\\n        MaxHeap lo: [41, 35]\\n        MinHeap hi: [62]\\n        Median is 41\\n        =======================\\n        Adding number 4\\n        MaxHeap lo: [35, 4]\\n        MinHeap hi: [41, 62]\\n        Median is 38\\n        =======================\\n        Adding number 97\\n        MaxHeap lo: [41, 35, 4]\\n        MinHeap hi: [62, 97]\\n        Median is 41\\n        =======================\\n        Adding number 108\\n        MaxHeap lo: [41, 35, 4]\\n        MinHeap hi: [62, 97, 108]\\n        Median is 51.5\\n\"\"\"\\n\\nclass MedianFinder:\\n    def __init__(self):\\n        self.lo = []  \\n        self.hi = []  \\n\\n    def addNum(self, num):\\n        heappush(self.lo, -num)             # lo is maxheap, so -1 * num\\n        heappush(self.hi, -self.lo[0])      # hi is minheap\\n        heappop(self.lo)\\n        \\n        if len(self.lo) < len(self.hi):\\n            heappush(self.lo, -self.hi[0])\\n            heappop(self.hi)\\n            \\n    def findMedian(self):\\n        if len(self.lo) > len(self.hi):\\n            return -self.lo[0]                  \\n        else:\\n            return (self.hi[0] - self.lo[0]) / 2  # - as low has -ve values\\n```",
                "codeTag": "Java"
            },
            {
                "id": 74144,
                "title": "easy-to-understand-double-heap-solution-in-java",
                "content": "The basic idea is to maintain two heaps: a max-heap and a min-heap. **The max heap stores the smaller half of all numbers while the min heap stores the larger half.** The sizes of two heaps need to be balanced each time when a new number is inserted so that their size will not be different by more than 1. Therefore each time when findMedian() is called we check if two heaps have the same size. If they do, we should return the average of the two top values of heaps. Otherwise we return the top of the heap which has one more element.\\n\\nTo do that, we first need to add two PriorityQueues to the class as the max-heap and min-heap:\\n\\n        private PriorityQueue<Integer> minH;\\n        private PriorityQueue<Integer> maxH;\\n\\nWe then define the constructor of the class so that the PriorityQueues get initialized. By default, the sorting order of a PriorityQueue is natural order which means it is a min-heap by default. Hence we need to provide a new Comparator to the constructor of the max heap to specify the reversed order.\\n\\n        MedianFinder(){\\n            minH = new PriorityQueue<Integer>();\\n            maxH = new PriorityQueue<Integer>(1, new Comparator<Integer>(){\\n                public int compare(Integer o1, Integer o2) {\\n                    if (o1.intValue()>o2.intValue()) return -1;\\n                    if (o1.intValue()<o2.intValue()) return 1;\\n                    return 0;\\n                }\\n            });\\n        }\\n\\nNow we have the data structure properly built. Let's write the addNum() function next.\\n\\n        public void addNum(int num) {\\n            if ((minH.size()==0)&&(maxH.size()==0)) minH.add(num);\\n            else if ((minH.size())>(maxH.size())) {\\n                if (num>minH.peek()) {\\n                    maxH.add(minH.poll());\\n                    minH.add(num);\\n                } else maxH.add(num);\\n            } else if ((minH.size())<(maxH.size())) {\\n                if (num<maxH.peek()) {\\n                    minH.add(maxH.poll());\\n                    maxH.add(num);\\n                } else minH.add(num);            \\n            } else {\\n                if (num<maxH.peek()) maxH.add(num);\\n                else minH.add(num);             \\n            }\\n        }\\n\\nThere are several possible situations when a new number is inserted: \\n\\n1)If both heap are empty, meaning that we are inserting the first number, we just arbitrarily inserted it into a heap, let's say, the min-heap. \\n\\n2)If min-heap has more elements (later we will argue that the size won't be different by more than 1), we need to compare the new number with the top of the min-heap. If it is larger than that, then the new number belongs to the larger half and it should be added to the min-heap. But since we have to balance the heap, we should move the top element of the min-heap to the max-heap. For the min-heap, we inserted a new number but removed the original top, its size won't change. For the max-heap, we inserted a new element (the top of the min-heap) so its size will increase by 1.\\n\\n3)If max-heap has more elements, we did the similar thing as 2).\\n\\n4)If they have the same size, we just compare the new number with one of the top to determine which heap the new number should be inserted. We just simply inserted it there.\\n\\nIt can be seen that for each insertion if it was in situation 1) and 4), then after insertion the heap size difference will be 1. For 2) and 3), the size of the heap with fewer element will increase by 1 to catch up with the heap with more elements. Hence their sizes are well-balanced and the difference will never exceeds 1.\\n\\nObviously, the median will be the top element of the heap which has one more element (if max-heap and min-heap have different sizes), or the average of the two tops (if max-heap and min-heap have equal sizes). So the findMedian() function is very straightforward:\\n\\n        // Returns the median of current data stream\\n        public double findMedian() {\\n            if ((minH.size()==0)&&(maxH.size()==0)) return 0.0;\\n            if ((minH.size())>(maxH.size())) return (double)(minH.peek());\\n            if ((minH.size())<(maxH.size())) return (double)(maxH.peek());\\n            return ((double)(maxH.peek()+minH.peek()))/2.0;\\n        }\\n\\n\\n\\nThe entire codes are here:\\n\\n    class MedianFinder {\\n        private PriorityQueue<Integer> minH;\\n        private PriorityQueue<Integer> maxH;\\n        \\n        MedianFinder(){\\n            minH = new PriorityQueue<Integer>();\\n            maxH = new PriorityQueue<Integer>(1, new Comparator<Integer>(){\\n                public int compare(Integer o1, Integer o2) {\\n                    if (o1.intValue()>o2.intValue()) return -1;\\n                    if (o1.intValue()<o2.intValue()) return 1;\\n                    return 0;\\n                }\\n            });\\n        }\\n        \\n        \\n        // Adds a number into the data structure.\\n        public void addNum(int num) {\\n            if ((minH.size()==0)&&(maxH.size()==0)) minH.add(num);\\n            else if ((minH.size())>(maxH.size())) {\\n                if (num>minH.peek()) {\\n                    maxH.add(minH.poll());\\n                    minH.add(num);\\n                } else maxH.add(num);\\n            } else if ((minH.size())<(maxH.size())) {\\n                if (num<maxH.peek()) {\\n                    minH.add(maxH.poll());\\n                    maxH.add(num);\\n                } else minH.add(num);            \\n            } else {\\n                if (num<maxH.peek()) maxH.add(num);\\n                else minH.add(num);             \\n            }\\n        }\\n    \\n        // Returns the median of current data stream\\n        public double findMedian() {\\n            if ((minH.size()==0)&&(maxH.size()==0)) return 0.0;\\n            if ((minH.size())>(maxH.size())) return (double)(minH.peek());\\n            if ((minH.size())<(maxH.size())) return (double)(maxH.peek());\\n            return ((double)(maxH.peek()+minH.peek()))/2.0;\\n        }\\n    };\\n    \\n    // Your MedianFinder object will be instantiated and called as such:\\n    // MedianFinder mf = new MedianFinder();\\n    // mf.addNum(1);\\n    // mf.findMedian();",
                "solutionTags": [],
                "code": "The basic idea is to maintain two heaps: a max-heap and a min-heap. **The max heap stores the smaller half of all numbers while the min heap stores the larger half.** The sizes of two heaps need to be balanced each time when a new number is inserted so that their size will not be different by more than 1. Therefore each time when findMedian() is called we check if two heaps have the same size. If they do, we should return the average of the two top values of heaps. Otherwise we return the top of the heap which has one more element.\\n\\nTo do that, we first need to add two PriorityQueues to the class as the max-heap and min-heap:\\n\\n        private PriorityQueue<Integer> minH;\\n        private PriorityQueue<Integer> maxH;\\n\\nWe then define the constructor of the class so that the PriorityQueues get initialized. By default, the sorting order of a PriorityQueue is natural order which means it is a min-heap by default. Hence we need to provide a new Comparator to the constructor of the max heap to specify the reversed order.\\n\\n        MedianFinder(){\\n            minH = new PriorityQueue<Integer>();\\n            maxH = new PriorityQueue<Integer>(1, new Comparator<Integer>(){\\n                public int compare(Integer o1, Integer o2) {\\n                    if (o1.intValue()>o2.intValue()) return -1;\\n                    if (o1.intValue()<o2.intValue()) return 1;\\n                    return 0;\\n                }\\n            });\\n        }\\n\\nNow we have the data structure properly built. Let's write the addNum() function next.\\n\\n        public void addNum(int num) {\\n            if ((minH.size()==0)&&(maxH.size()==0)) minH.add(num);\\n            else if ((minH.size())>(maxH.size())) {\\n                if (num>minH.peek()) {\\n                    maxH.add(minH.poll());\\n                    minH.add(num);\\n                } else maxH.add(num);\\n            } else if ((minH.size())<(maxH.size())) {\\n                if (num<maxH.peek()) {\\n                    minH.add(maxH.poll());\\n                    maxH.add(num);\\n                } else minH.add(num);            \\n            } else {\\n                if (num<maxH.peek()) maxH.add(num);\\n                else minH.add(num);             \\n            }\\n        }\\n\\nThere are several possible situations when a new number is inserted: \\n\\n1)If both heap are empty, meaning that we are inserting the first number, we just arbitrarily inserted it into a heap, let's say, the min-heap. \\n\\n2)If min-heap has more elements (later we will argue that the size won't be different by more than 1), we need to compare the new number with the top of the min-heap. If it is larger than that, then the new number belongs to the larger half and it should be added to the min-heap. But since we have to balance the heap, we should move the top element of the min-heap to the max-heap. For the min-heap, we inserted a new number but removed the original top, its size won't change. For the max-heap, we inserted a new element (the top of the min-heap) so its size will increase by 1.\\n\\n3)If max-heap has more elements, we did the similar thing as 2).\\n\\n4)If they have the same size, we just compare the new number with one of the top to determine which heap the new number should be inserted. We just simply inserted it there.\\n\\nIt can be seen that for each insertion if it was in situation 1) and 4), then after insertion the heap size difference will be 1. For 2) and 3), the size of the heap with fewer element will increase by 1 to catch up with the heap with more elements. Hence their sizes are well-balanced and the difference will never exceeds 1.\\n\\nObviously, the median will be the top element of the heap which has one more element (if max-heap and min-heap have different sizes), or the average of the two tops (if max-heap and min-heap have equal sizes). So the findMedian() function is very straightforward:\\n\\n        // Returns the median of current data stream\\n        public double findMedian() {\\n            if ((minH.size()==0)&&(maxH.size()==0)) return 0.0;\\n            if ((minH.size())>(maxH.size())) return (double)(minH.peek());\\n            if ((minH.size())<(maxH.size())) return (double)(maxH.peek());\\n            return ((double)(maxH.peek()+minH.peek()))/2.0;\\n        }\\n\\n\\n\\nThe entire codes are here:\\n\\n    class MedianFinder {\\n        private PriorityQueue<Integer> minH;\\n        private PriorityQueue<Integer> maxH;\\n        \\n        MedianFinder(){\\n            minH = new PriorityQueue<Integer>();\\n            maxH = new PriorityQueue<Integer>(1, new Comparator<Integer>(){\\n                public int compare(Integer o1, Integer o2) {\\n                    if (o1.intValue()>o2.intValue()) return -1;\\n                    if (o1.intValue()<o2.intValue()) return 1;\\n                    return 0;\\n                }\\n            });\\n        }\\n        \\n        \\n        // Adds a number into the data structure.\\n        public void addNum(int num) {\\n            if ((minH.size()==0)&&(maxH.size()==0)) minH.add(num);\\n            else if ((minH.size())>(maxH.size())) {\\n                if (num>minH.peek()) {\\n                    maxH.add(minH.poll());\\n                    minH.add(num);\\n                } else maxH.add(num);\\n            } else if ((minH.size())<(maxH.size())) {\\n                if (num<maxH.peek()) {\\n                    minH.add(maxH.poll());\\n                    maxH.add(num);\\n                } else minH.add(num);            \\n            } else {\\n                if (num<maxH.peek()) maxH.add(num);\\n                else minH.add(num);             \\n            }\\n        }\\n    \\n        // Returns the median of current data stream\\n        public double findMedian() {\\n            if ((minH.size()==0)&&(maxH.size()==0)) return 0.0;\\n            if ((minH.size())>(maxH.size())) return (double)(minH.peek());\\n            if ((minH.size())<(maxH.size())) return (double)(maxH.peek());\\n            return ((double)(maxH.peek()+minH.peek()))/2.0;\\n        }\\n    };\\n    \\n    // Your MedianFinder object will be instantiated and called as such:\\n    // MedianFinder mf = new MedianFinder();\\n    // mf.addNum(1);\\n    // mf.findMedian();",
                "codeTag": "Java"
            },
            {
                "id": 74057,
                "title": "tired-of-two-heap-set-solutions-see-this-segment-dividing-solution-c",
                "content": "\\n    class MedianFinder {    \\n    \\n    /* The idea of dividing existing numbers into several ranges:\\n    \\n       Say we already have 10k numbers in vector, \\n       each time adding a number requires sorting all 10k numbers, which is slow.\\n    \\n       To optimize, we can store 10k numbers in several (say 10) vectors, \\n       and nums in each vector are sorted.\\n       \\n       Then each time we add a number, just need to find one vector with correct range,\\n       insert the number and sort this vector only. Since its size is relatively small, it's fast.\\n       \\n       When we have a vector's size greater than a threshold, just split it into two halfs.\\n       \\n    */\\n    \\n    public:\\n        vector<vector<int>*> raid; // store all ranges\\n        int total_size;\\n\\n        MedianFinder() {\\n            total_size=0;\\n            raid.push_back(new vector<int> ());\\n        }\\n        \\n        void addNum(int num) {\\n            vector<int>* correctRange=NULL;\\n            int targetIndex;\\n            \\n            // find the correct range to insert given num\\n            for (int i=0; i<raid.size(); i++)\\n                if ( raid.size()==1 ||\\n                     (i==0 && num<=raid[i]->back()) || \\n                     (i==raid.size()-1 && num>=raid[i]->at(0)) ||\\n                     (raid[i]->at(0)<=num && num<=raid[i]->back()) ||\\n                     (num > raid[i]->back() && num < raid[i+1]->front()) )\\n                {\\n                    correctRange = raid[i];\\n                    targetIndex = i;\\n                    break;\\n                }\\n            \\n            // put num at back of correct range, and sort it to keep increasing sequence\\n            total_size++;\\n            correctRange->push_back(num);\\n            sort(correctRange->begin(), correctRange->end());\\n                    \\n            // if current range's size > threshold, split it into two halfs and add them back to this.raid\\n            const int max_size = 30;\\n            int len = correctRange->size();\\n            if (len > max_size) {\\n                vector<int> *half1 = new vector<int>(correctRange->begin(), correctRange->begin()+len/2);\\n                vector<int> *half2 = new vector<int>(correctRange->begin()+len/2, correctRange->end());\\n                \\n                delete correctRange;\\n                raid[targetIndex]=half2;\\n                raid.insert(raid.begin() + targetIndex, half1);\\n            }\\n            \\n        }\\n    \\n        // iterate thru all ranges in this.raid to find median value\\n        double findMedian() {\\n            if (total_size==0)\\n                return 0;\\n            \\n            int mid1 = total_size/2;\\n            int mid2 = mid1 + 1;\\n            \\n            int leftCount=0;\\n            double first, second;\\n            for (auto r : raid) {\\n                if (leftCount<mid1 && mid1<=leftCount+r->size())\\n                    first = r->at(mid1 - leftCount - 1);\\n                    \\n                if (leftCount<mid2 && mid2<=leftCount+r->size()) {\\n                    second = r->at(mid2 - leftCount - 1);\\n                    break;\\n                }\\n                leftCount += r->size();\\n            }\\n            \\n            if (total_size % 2)\\n                return second;\\n            else\\n                return (first + second)/2;\\n        }\\n    };",
                "solutionTags": [],
                "code": "\\n    class MedianFinder {    \\n    \\n    /* The idea of dividing existing numbers into several ranges:\\n    \\n       Say we already have 10k numbers in vector, \\n       each time adding a number requires sorting all 10k numbers, which is slow.\\n    \\n       To optimize, we can store 10k numbers in several (say 10) vectors, \\n       and nums in each vector are sorted.\\n       \\n       Then each time we add a number, just need to find one vector with correct range,\\n       insert the number and sort this vector only. Since its size is relatively small, it's fast.\\n       \\n       When we have a vector's size greater than a threshold, just split it into two halfs.\\n       \\n    */\\n    \\n    public:\\n        vector<vector<int>*> raid; // store all ranges\\n        int total_size;\\n\\n        MedianFinder() {\\n            total_size=0;\\n            raid.push_back(new vector<int> ());\\n        }\\n        \\n        void addNum(int num) {\\n            vector<int>* correctRange=NULL;\\n            int targetIndex;\\n            \\n            // find the correct range to insert given num\\n            for (int i=0; i<raid.size(); i++)\\n                if ( raid.size()==1 ||\\n                     (i==0 && num<=raid[i]->back()) || \\n                     (i==raid.size()-1 && num>=raid[i]->at(0)) ||\\n                     (raid[i]->at(0)<=num && num<=raid[i]->back()) ||\\n                     (num > raid[i]->back() && num < raid[i+1]->front()) )\\n                {\\n                    correctRange = raid[i];\\n                    targetIndex = i;\\n                    break;\\n                }\\n            \\n            // put num at back of correct range, and sort it to keep increasing sequence\\n            total_size++;\\n            correctRange->push_back(num);\\n            sort(correctRange->begin(), correctRange->end());\\n                    \\n            // if current range's size > threshold, split it into two halfs and add them back to this.raid\\n            const int max_size = 30;\\n            int len = correctRange->size();\\n            if (len > max_size) {\\n                vector<int> *half1 = new vector<int>(correctRange->begin(), correctRange->begin()+len/2);\\n                vector<int> *half2 = new vector<int>(correctRange->begin()+len/2, correctRange->end());\\n                \\n                delete correctRange;\\n                raid[targetIndex]=half2;\\n                raid.insert(raid.begin() + targetIndex, half1);\\n            }\\n            \\n        }\\n    \\n        // iterate thru all ranges in this.raid to find median value\\n        double findMedian() {\\n            if (total_size==0)\\n                return 0;\\n            \\n            int mid1 = total_size/2;\\n            int mid2 = mid1 + 1;\\n            \\n            int leftCount=0;\\n            double first, second;\\n            for (auto r : raid) {\\n                if (leftCount<mid1 && mid1<=leftCount+r->size())\\n                    first = r->at(mid1 - leftCount - 1);\\n                    \\n                if (leftCount<mid2 && mid2<=leftCount+r->size()) {\\n                    second = r->at(mid2 - leftCount - 1);\\n                    break;\\n                }\\n                leftCount += r->size();\\n            }\\n            \\n            if (total_size % 2)\\n                return second;\\n            else\\n                return (first + second)/2;\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 74119,
                "title": "18ms-beats-100-java-solution-with-bst",
                "content": "The method is vulnerable to (largely) monotonic inputs, which could push the complexity of `addNum` to O(n), resulting in \"Time Limit Exceeded\" errors.  At the time of the original post (back in 2016), there weren\\'t such test cases.  I believe the \"self-balancing binary search tree\" would do the rescue.\\n\\n    class MedianFinder {\\n        class TreeNode{\\n            int val;\\n            TreeNode parent,left,right;\\n            TreeNode(int val, TreeNode p){\\n                this.val=val;\\n                this.parent=p;\\n                left=null;\\n                right=null;\\n            }\\n            void add(int num){\\n                if(num>=val){\\n                    if(right==null)\\n                        right=new TreeNode(num,this);\\n                    else\\n                        right.add(num);\\n                }else{\\n                    if(left==null)\\n                        left=new TreeNode(num,this);\\n                    else\\n                        left.add(num);\\n                }\\n            }\\n            TreeNode next(){\\n                TreeNode ret;\\n                if(right!=null){\\n                    ret=right;\\n                    while(ret.left!=null)\\n                        ret=ret.left;\\n                }else{\\n                    ret=this;\\n                    while(ret.parent.right==ret)\\n                        ret=ret.parent;\\n                    ret=ret.parent;\\n                }\\n                return ret;\\n            }\\n            TreeNode prev(){\\n                TreeNode ret;\\n                if(left!=null){\\n                    ret=left;\\n                    while(ret.right!=null)\\n                        ret=ret.right;\\n                }else{\\n                    ret=this;\\n                    while(ret.parent.left==ret)\\n                        ret=ret.parent;\\n                    ret=ret.parent;\\n                }\\n                return ret;\\n            }\\n        }\\n        int n;\\n        TreeNode root, curr;\\n        // Adds a number into the data structure.\\n        public void addNum(int num) {\\n            if(root==null){\\n                root = new TreeNode(num,null);\\n                curr=root;\\n                n=1;\\n            }else{\\n                root.add(num);\\n                n++;\\n                if(n%2==1){\\n                    if(curr.val<=num)\\n                        curr=curr.next();\\n                }else\\n                    if(curr.val>num)\\n                        curr=curr.prev();\\n            }\\n        }\\n    \\n        // Returns the median of current data stream\\n        public double findMedian() {\\n            if(n%2==0){\\n                return ((double)curr.next().val+curr.val)/2;\\n            }else\\n                return curr.val;\\n        }\\n    };\\n    \\n    // Your MedianFinder object will be instantiated and called as such:\\n    // MedianFinder mf = new MedianFinder();\\n    // mf.addNum(1);\\n    // mf.findMedian();",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "The method is vulnerable to (largely) monotonic inputs, which could push the complexity of `addNum` to O(n), resulting in \"Time Limit Exceeded\" errors.  At the time of the original post (back in 2016), there weren\\'t such test cases.  I believe the \"self-balancing binary search tree\" would do the rescue.\\n\\n    class MedianFinder {\\n        class TreeNode{\\n            int val;\\n            TreeNode parent,left,right;\\n            TreeNode(int val, TreeNode p){\\n                this.val=val;\\n                this.parent=p;\\n                left=null;\\n                right=null;\\n            }\\n            void add(int num){\\n                if(num>=val){\\n                    if(right==null)\\n                        right=new TreeNode(num,this);\\n                    else\\n                        right.add(num);\\n                }else{\\n                    if(left==null)\\n                        left=new TreeNode(num,this);\\n                    else\\n                        left.add(num);\\n                }\\n            }\\n            TreeNode next(){\\n                TreeNode ret;\\n                if(right!=null){\\n                    ret=right;\\n                    while(ret.left!=null)\\n                        ret=ret.left;\\n                }else{\\n                    ret=this;\\n                    while(ret.parent.right==ret)\\n                        ret=ret.parent;\\n                    ret=ret.parent;\\n                }\\n                return ret;\\n            }\\n            TreeNode prev(){\\n                TreeNode ret;\\n                if(left!=null){\\n                    ret=left;\\n                    while(ret.right!=null)\\n                        ret=ret.right;\\n                }else{\\n                    ret=this;\\n                    while(ret.parent.left==ret)\\n                        ret=ret.parent;\\n                    ret=ret.parent;\\n                }\\n                return ret;\\n            }\\n        }\\n        int n;\\n        TreeNode root, curr;\\n        // Adds a number into the data structure.\\n        public void addNum(int num) {\\n            if(root==null){\\n                root = new TreeNode(num,null);\\n                curr=root;\\n                n=1;\\n            }else{\\n                root.add(num);\\n                n++;\\n                if(n%2==1){\\n                    if(curr.val<=num)\\n                        curr=curr.next();\\n                }else\\n                    if(curr.val>num)\\n                        curr=curr.prev();\\n            }\\n        }\\n    \\n        // Returns the median of current data stream\\n        public double findMedian() {\\n            if(n%2==0){\\n                return ((double)curr.next().val+curr.val)/2;\\n            }else\\n                return curr.val;\\n        }\\n    };\\n    \\n    // Your MedianFinder object will be instantiated and called as such:\\n    // MedianFinder mf = new MedianFinder();\\n    // mf.addNum(1);\\n    // mf.findMedian();",
                "codeTag": "Java"
            },
            {
                "id": 74128,
                "title": "java-easy-version-to-understand",
                "content": "    \\tPriorityQueue<Integer> minHeap = new PriorityQueue<>();//heap is a minimal heap by default\\n\\tPriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());//change to a maximum heap\\n\\n\\t// Adds a number into the data structure.\\n\\tpublic void addNum(int num) {\\n\\t\\tmaxHeap.offer(num);\\n\\t\\tminHeap.offer(maxHeap.poll());\\n\\t\\tif (maxHeap.size() < minHeap.size())\\n\\t\\t\\tmaxHeap.offer(minHeap.poll());\\n\\t}\\n\\n\\t// Returns the median of current data stream\\n\\tpublic double findMedian() {\\n\\t\\tif (maxHeap.size() == minHeap.size())\\n\\t\\t\\treturn (maxHeap.peek() + minHeap.peek()) / 2.0;\\n\\t\\telse\\n\\t\\t\\treturn maxHeap.peek();\\n\\t}",
                "solutionTags": [],
                "code": "    \\tPriorityQueue<Integer> minHeap = new PriorityQueue<>();//heap is a minimal heap by default\\n\\tPriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());//change to a maximum heap\\n\\n\\t// Adds a number into the data structure.\\n\\tpublic void addNum(int num) {\\n\\t\\tmaxHeap.offer(num);\\n\\t\\tminHeap.offer(maxHeap.poll());\\n\\t\\tif (maxHeap.size() < minHeap.size())\\n\\t\\t\\tmaxHeap.offer(minHeap.poll());\\n\\t}\\n\\n\\t// Returns the median of current data stream\\n\\tpublic double findMedian() {\\n\\t\\tif (maxHeap.size() == minHeap.size())\\n\\t\\t\\treturn (maxHeap.peek() + minHeap.peek()) / 2.0;\\n\\t\\telse\\n\\t\\t\\treturn maxHeap.peek();\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2805145,
                "title": "python-c-java-rust-two-heaps-bonus-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs two *Binary Heaps* to maintain quick access to the median elements. Time complexity is logarithmic **O(logN)** to *add* and constant **O(1)** to *find*. Space complexity is linear: **O(N)**.\\n\\n**Comment.** When we have the analogous problem with the *mean*, just updating the sum and the count of all elements would work, becuase that\\'s what the mean is all about. However, to obtain the *median*, we should have access to the precise value of the middle element(s). The problem is that this element changes every time a new one is added from the data stream. This leads us to the conclusion that we need to store all elements. But what data structure to use? The key observation here is that we need to have (and maintain) quick access to at most two elements (or just one in the case of an odd size). Thus, either of two structures would work:\\n1. Two Binary Heaps maintaining small and large halves of numbers. On the top of each heap we would have the value that is closest to the median.\\n2. Sorted array. This would allow to retrieve the median by just \"looking in the middle\".\\n\\nHere, I provide a solution with heaps (in four languagaes). In the **BONUS** section, I also demonstrate the second aproach using Python\\'s *SortedList*.\\n\\n**Python.**\\n```\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        self.sh, self.lh = [], []\\n\\n    def addNum(self, num: int) -> None:\\n\\n        heappush(self.lh, -heappushpop(self.sh,-num))     # [1] always push numbers to the large half first\\n        if len(self.lh) > len(self.sh):                   # [2] if it\\'s longer then transfer to the small one;\\n            heappush(self.sh, -heappop(self.lh))          #     this way, the small one will never be shorter\\n\\n    def findMedian(self) -> float:\\n\\n        if len(self.sh) != len(self.lh):                  # [3] for odd size, the smallest half is the one that \\n            return -self.sh[0]                            #     stores the median by our design in [1] and [2]\\n        else                                              # [4] for even size, take average between two middle\\n            return (-self.sh[0] + self.lh[0]) / 2         #     values, one taken from each of the heaps\\n```\\n\\nThis solution in other languages.\\n\\n<iframe src=\"https://leetcode.com/playground/axhiVgon/shared\" frameBorder=\"0\" width=\"800\" height=\"450\"></iframe>\\n\\n**\\u2705 YOU MADE IT TILL THE BONUS SECTION... YOUR GREAT EFFORT DESERVES UPVOTING THIS POST!**\\n\\nAs a **BONUS**, I provide a solution in **Python** using *SortedList* that maintains a sorted array for the quick access to its middle elements.\\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        self.data = SortedList()\\n\\n    def addNum(self, num: int) -> None:\\n        self.data.add(num)\\n\\n    def findMedian(self) -> float:\\n        n = len(self.data)\\n        return (self.data[n//2] + self.data[(n-1)//2]) / 2\\n```",
                "solutionTags": [],
                "code": "```\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        self.sh, self.lh = [], []\\n\\n    def addNum(self, num: int) -> None:\\n\\n        heappush(self.lh, -heappushpop(self.sh,-num))     # [1] always push numbers to the large half first\\n        if len(self.lh) > len(self.sh):                   # [2] if it\\'s longer then transfer to the small one;\\n            heappush(self.sh, -heappop(self.lh))          #     this way, the small one will never be shorter\\n\\n    def findMedian(self) -> float:\\n\\n        if len(self.sh) != len(self.lh):                  # [3] for odd size, the smallest half is the one that \\n            return -self.sh[0]                            #     stores the median by our design in [1] and [2]\\n        else                                              # [4] for even size, take average between two middle\\n            return (-self.sh[0] + self.lh[0]) / 2         #     values, one taken from each of the heaps\\n```\n```\\nfrom sortedcontainers import SortedList\\n\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        self.data = SortedList()\\n\\n    def addNum(self, num: int) -> None:\\n        self.data.add(num)\\n\\n    def findMedian(self) -> float:\\n        n = len(self.data)\\n        return (self.data[n//2] + self.data[(n-1)//2]) / 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 74044,
                "title": "very-short-o-log-n-o-1",
                "content": "Same idea [as before](https://leetcode.com/discuss/64850/short-simple-java-c-python-o-log-n-o-1), but really exploiting the symmetry of the two heaps by switching them whenever a number is added. Still O(log n) for adding and O(1) for median. Partially inspired by [peisi\\'s updated solution](https://leetcode.com/discuss/64852/ac-python-two-heap-solution-o-log-n-add-o-1-find-388-ms).\\n\\n**Update:** Added a new Java version (the first one).\\n\\n---\\n\\n**Java**\\n\\n    class MedianFinder {\\n        \\n        Queue<Integer> q = new PriorityQueue(), z = q, t,\\n                       Q = new PriorityQueue(Collections.reverseOrder()); \\n    \\n        public void addNum(int num) {\\n            (t=Q).add(num);\\n            (Q=q).add((q=t).poll());\\n        }\\n    \\n        public double findMedian() {\\n            return (Q.peek() + z.peek()) / 2.;\\n        }\\n    };\\n\\nOr:\\n\\n    class MedianFinder {\\n    \\n        Queue[] q = {new PriorityQueue(), new PriorityQueue(Collections.reverseOrder())};\\n        int i = 0;\\n    \\n        public void addNum(int num) {\\n            q[i].add(num);\\n            q[i^=1].add(q[i^1].poll());\\n        }\\n    \\n        public double findMedian() {\\n            return ((int)(q[1].peek()) + (int)(q[i].peek())) / 2.0;\\n        }\\n    };\\n\\n---\\n\\n**Python**\\n\\n    from heapq import *\\n\\n    class MedianFinder:\\n    \\n        def __init__(self):\\n            self.heaps = None, [], []\\n            self.i = 1\\n    \\n        def addNum(self, num):\\n            heappush(self.heaps[-self.i], -heappushpop(self.heaps[self.i], num * self.i))\\n            self.i *= -1\\n    \\n        def findMedian(self):\\n            return (self.heaps[self.i][0] * self.i - self.heaps[-1][0]) / 2.0\\n\\nOr:\\n\\n    from heapq import *\\n\\n    class MedianFinder:\\n    \\n        def __init__(self):\\n            self.data = 1, [], []\\n    \\n        def addNum(self, num):\\n            sign, h1, h2 = self.data\\n            heappush(h2, -heappushpop(h1, num * sign))\\n            self.data = -sign, h2, h1\\n    \\n        def findMedian(self):\\n            sign, h1, h2 = d = self.data\\n            return (h1[0] * sign - d[-sign][0]) / 2.0\\n\\nOr:\\n```\\nclass MedianFinder:\\n    def __init__(s):\\n        h = [[], 1, -1, i := []]\\n        s.addNum = lambda n: heapq.heappush(h[-1], -heapq.heappushpop(h[0], n * h[1])) or h.reverse()\\n        s.findMedian = lambda: (h[0][0] * h[1] - i[0]) / 2\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "Same idea [as before](https://leetcode.com/discuss/64850/short-simple-java-c-python-o-log-n-o-1), but really exploiting the symmetry of the two heaps by switching them whenever a number is added. Still O(log n) for adding and O(1) for median. Partially inspired by [peisi\\'s updated solution](https://leetcode.com/discuss/64852/ac-python-two-heap-solution-o-log-n-add-o-1-find-388-ms).\\n\\n**Update:** Added a new Java version (the first one).\\n\\n---\\n\\n**Java**\\n\\n    class MedianFinder {\\n        \\n        Queue<Integer> q = new PriorityQueue(), z = q, t,\\n                       Q = new PriorityQueue(Collections.reverseOrder()); \\n    \\n        public void addNum(int num) {\\n            (t=Q).add(num);\\n            (Q=q).add((q=t).poll());\\n        }\\n    \\n        public double findMedian() {\\n            return (Q.peek() + z.peek()) / 2.;\\n        }\\n    };\\n\\nOr:\\n\\n    class MedianFinder {\\n    \\n        Queue[] q = {new PriorityQueue(), new PriorityQueue(Collections.reverseOrder())};\\n        int i = 0;\\n    \\n        public void addNum(int num) {\\n            q[i].add(num);\\n            q[i^=1].add(q[i^1].poll());\\n        }\\n    \\n        public double findMedian() {\\n            return ((int)(q[1].peek()) + (int)(q[i].peek())) / 2.0;\\n        }\\n    };\\n\\n---\\n\\n**Python**\\n\\n    from heapq import *\\n\\n    class MedianFinder:\\n    \\n        def __init__(self):\\n            self.heaps = None, [], []\\n            self.i = 1\\n    \\n        def addNum(self, num):\\n            heappush(self.heaps[-self.i], -heappushpop(self.heaps[self.i], num * self.i))\\n            self.i *= -1\\n    \\n        def findMedian(self):\\n            return (self.heaps[self.i][0] * self.i - self.heaps[-1][0]) / 2.0\\n\\nOr:\\n\\n    from heapq import *\\n\\n    class MedianFinder:\\n    \\n        def __init__(self):\\n            self.data = 1, [], []\\n    \\n        def addNum(self, num):\\n            sign, h1, h2 = self.data\\n            heappush(h2, -heappushpop(h1, num * sign))\\n            self.data = -sign, h2, h1\\n    \\n        def findMedian(self):\\n            sign, h1, h2 = d = self.data\\n            return (h1[0] * sign - d[-sign][0]) / 2.0\\n\\nOr:\\n```\\nclass MedianFinder:\\n    def __init__(s):\\n        h = [[], 1, -1, i := []]\\n        s.addNum = lambda n: heapq.heappush(h[-1], -heapq.heappushpop(h[0], n * h[1])) or h.reverse()\\n        s.findMedian = lambda: (h[0][0] * h[1] - i[0]) / 2\\n",
                "codeTag": "Java"
            },
            {
                "id": 1330808,
                "title": "python-2-heaps-solution-explained",
                "content": "The idea is to keep two heaps: one for the top half of our data and another is for down half of our data. \\nIf we have even size `2n`, then we will keep two heaps with size `n`\\nIf we have odd size `2n+1`, then we will keep size of the small heap `n+1` ans the size of large heap `n`.\\n\\nWhen we have new element `num`, we always put it to small heap, and then normalize our heaps: remove biggest element from the small heap and put it to the large heap. After this operation we can be sure that we have the property that the largest element in small heap is smaller than smaller elements in large heap.\\n\\nHowever after this step if we had `n, n` elements, we will have `n, n+1` elements, so we need to put one element from large heap to small heap.\\n\\n#### Complexity\\nTime complexity is just `O(1)` to get median and `O(log n)` to add number. Space complexity is `O(n)` after `n` operations.\\n\\n#### Code\\n```python\\nclass MedianFinder:\\n    def __init__(self):\\n        self.small, self.large = [], [] \\n\\n    def addNum(self, num):\\n        heappush(self.small, -num)           \\n        heappush(self.large, -heappop(self.small))\\n        \\n        if len(self.small) < len(self.large):\\n            heappush(self.small, -heappop(self.large))\\n            \\n    def findMedian(self):\\n        if len(self.large) != len(self.small):\\n            return -self.small[0]                  \\n        else:\\n            return (self.large[0] - self.small[0]) / 2 \\n```\\n\\n#### Remark\\nThere is also solution with `O(log n)` time complexities for both operations, if we use `Sorted List`",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass MedianFinder:\\n    def __init__(self):\\n        self.small, self.large = [], [] \\n\\n    def addNum(self, num):\\n        heappush(self.small, -num)           \\n        heappush(self.large, -heappop(self.small))\\n        \\n        if len(self.small) < len(self.large):\\n            heappush(self.small, -heappop(self.large))\\n            \\n    def findMedian(self):\\n        if len(self.large) != len(self.small):\\n            return -self.small[0]                  \\n        else:\\n            return (self.large[0] - self.small[0]) / 2 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 329657,
                "title": "javascript-max-heap-min-heap",
                "content": "```\\n/**\\n * initialize your data structure here.\\n */\\nvar MedianFinder = function() {\\n    this.maxHeap = new Heap(Heap.maxComparator);\\n    this.minHeap = new Heap(Heap.minComparator);\\n};\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nMedianFinder.prototype.addNum = function(num) {\\n    if(this.maxHeap.peek() === null || num < this.maxHeap.peek()) {\\n        this.maxHeap.add(num);\\n    } else {\\n        this.minHeap.add(num);\\n    }\\n    \\n    if(this.maxHeap.size - this.minHeap.size > 1) {\\n        this.minHeap.add(this.maxHeap.poll());\\n    } else if(this.minHeap.size - this.maxHeap.size > 1) {\\n        this.maxHeap.add(this.minHeap.poll());\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nMedianFinder.prototype.findMedian = function() {\\n    if(this.maxHeap.size > this.minHeap.size) {\\n        return this.maxHeap.peek();\\n    } else if(this.maxHeap.size < this.minHeap.size) {\\n        return this.minHeap.peek();\\n    } else {\\n        return (this.maxHeap.peek() + this.minHeap.peek()) / 2;\\n    }\\n};\\n\\n/** \\n *  custom Heap class\\n */\\nclass Heap {\\n\\tconstructor(comparator) {\\n\\t\\tthis.size = 0;\\n\\t\\tthis.values = [];\\n\\t\\tthis.comparator = comparator || Heap.minComparator;\\n\\t}\\n\\n\\tadd(val) {\\n\\t\\tthis.values.push(val);\\n\\t\\tthis.size ++;\\n\\t\\tthis.bubbleUp();\\n\\t}\\n\\n\\tpeek() {\\n\\t\\treturn this.values[0] || null;\\n\\t}\\n\\n\\tpoll() {\\n\\t\\tconst max = this.values[0];\\n\\t\\tconst end = this.values.pop();\\n\\t\\tthis.size --;\\n\\t\\tif (this.values.length) {\\n\\t\\t\\tthis.values[0] = end;\\n\\t\\t\\tthis.bubbleDown();\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n\\n\\tbubbleUp() {\\n\\t\\tlet index = this.values.length - 1;\\n\\t\\tlet parent = Math.floor((index - 1) / 2);\\n\\n\\t\\twhile (this.comparator(this.values[index], this.values[parent]) < 0) {\\n\\t\\t\\t[this.values[parent], this.values[index]] = [this.values[index], this.values[parent]];\\n\\t\\t\\tindex = parent;\\n\\t\\t\\tparent = Math.floor((index - 1) / 2);\\n\\t\\t}\\n\\t}\\n\\n\\tbubbleDown() {\\n\\t\\tlet index = 0, length = this.values.length;\\n\\n\\t\\twhile (true) {\\n\\t\\t\\tlet left = null,\\n\\t\\t\\t\\tright = null,\\n\\t\\t\\t\\tswap = null,\\n\\t\\t\\t\\tleftIndex = index * 2 + 1,\\n\\t\\t\\t\\trightIndex = index * 2 + 2;\\n\\n\\t\\t\\tif (leftIndex < length) {\\n\\t\\t\\t\\tleft = this.values[leftIndex];\\n\\t\\t\\t\\tif (this.comparator(left, this.values[index]) < 0) swap = leftIndex;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (rightIndex < length) {\\n\\t\\t\\t\\tright = this.values[rightIndex];\\n\\t\\t\\t\\tif ((swap !== null && this.comparator(right, left) < 0) || (swap === null && this.comparator(right, this.values[index]))) {\\n\\t\\t\\t\\t\\tswap = rightIndex;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (swap === null) break;\\n\\n\\t\\t\\t[this.values[index], this.values[swap]] = [this.values[swap], this.values[index]];\\n\\t\\t\\tindex = swap;\\n\\t\\t}\\n\\t}\\n}\\n\\n/** \\n *  Min Comparator\\n */\\nHeap.minComparator = (a, b) => { return a - b; }\\n\\n/** \\n *  Max Comparator\\n */\\nHeap.maxComparator = (a, b) => { return b - a; }\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * initialize your data structure here.\\n */\\nvar MedianFinder = function() {\\n    this.maxHeap = new Heap(Heap.maxComparator);\\n    this.minHeap = new Heap(Heap.minComparator);\\n};\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nMedianFinder.prototype.addNum = function(num) {\\n    if(this.maxHeap.peek() === null || num < this.maxHeap.peek()) {\\n        this.maxHeap.add(num);\\n    } else {\\n        this.minHeap.add(num);\\n    }\\n    \\n    if(this.maxHeap.size - this.minHeap.size > 1) {\\n        this.minHeap.add(this.maxHeap.poll());\\n    } else if(this.minHeap.size - this.maxHeap.size > 1) {\\n        this.maxHeap.add(this.minHeap.poll());\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nMedianFinder.prototype.findMedian = function() {\\n    if(this.maxHeap.size > this.minHeap.size) {\\n        return this.maxHeap.peek();\\n    } else if(this.maxHeap.size < this.minHeap.size) {\\n        return this.minHeap.peek();\\n    } else {\\n        return (this.maxHeap.peek() + this.minHeap.peek()) / 2;\\n    }\\n};\\n\\n/** \\n *  custom Heap class\\n */\\nclass Heap {\\n\\tconstructor(comparator) {\\n\\t\\tthis.size = 0;\\n\\t\\tthis.values = [];\\n\\t\\tthis.comparator = comparator || Heap.minComparator;\\n\\t}\\n\\n\\tadd(val) {\\n\\t\\tthis.values.push(val);\\n\\t\\tthis.size ++;\\n\\t\\tthis.bubbleUp();\\n\\t}\\n\\n\\tpeek() {\\n\\t\\treturn this.values[0] || null;\\n\\t}\\n\\n\\tpoll() {\\n\\t\\tconst max = this.values[0];\\n\\t\\tconst end = this.values.pop();\\n\\t\\tthis.size --;\\n\\t\\tif (this.values.length) {\\n\\t\\t\\tthis.values[0] = end;\\n\\t\\t\\tthis.bubbleDown();\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n\\n\\tbubbleUp() {\\n\\t\\tlet index = this.values.length - 1;\\n\\t\\tlet parent = Math.floor((index - 1) / 2);\\n\\n\\t\\twhile (this.comparator(this.values[index], this.values[parent]) < 0) {\\n\\t\\t\\t[this.values[parent], this.values[index]] = [this.values[index], this.values[parent]];\\n\\t\\t\\tindex = parent;\\n\\t\\t\\tparent = Math.floor((index - 1) / 2);\\n\\t\\t}\\n\\t}\\n\\n\\tbubbleDown() {\\n\\t\\tlet index = 0, length = this.values.length;\\n\\n\\t\\twhile (true) {\\n\\t\\t\\tlet left = null,\\n\\t\\t\\t\\tright = null,\\n\\t\\t\\t\\tswap = null,\\n\\t\\t\\t\\tleftIndex = index * 2 + 1,\\n\\t\\t\\t\\trightIndex = index * 2 + 2;\\n\\n\\t\\t\\tif (leftIndex < length) {\\n\\t\\t\\t\\tleft = this.values[leftIndex];\\n\\t\\t\\t\\tif (this.comparator(left, this.values[index]) < 0) swap = leftIndex;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (rightIndex < length) {\\n\\t\\t\\t\\tright = this.values[rightIndex];\\n\\t\\t\\t\\tif ((swap !== null && this.comparator(right, left) < 0) || (swap === null && this.comparator(right, this.values[index]))) {\\n\\t\\t\\t\\t\\tswap = rightIndex;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (swap === null) break;\\n\\n\\t\\t\\t[this.values[index], this.values[swap]] = [this.values[swap], this.values[index]];\\n\\t\\t\\tindex = swap;\\n\\t\\t}\\n\\t}\\n}\\n\\n/** \\n *  Min Comparator\\n */\\nHeap.minComparator = (a, b) => { return a - b; }\\n\\n/** \\n *  Max Comparator\\n */\\nHeap.maxComparator = (a, b) => { return b - a; }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1506078,
                "title": "java-detailed-code-solutions-for-follow-ups",
                "content": "**Solution for main question**\\n```java\\n/**\\n * Using two heaps\\n * \\n * Time Complexity:\\n * 1) addNum -> O(5 * log (N/2)) = O(log N)\\n * 2) findMedian -> O(1)\\n *\\n * Space Complexity: O(N)\\n *\\n * N = Count of numbers in the data stream.\\n */\\nclass MedianFinder {\\n    PriorityQueue<Integer> smallNums; // Max Heap\\n    PriorityQueue<Integer> largeNums; // Min Heap\\n\\n    public MedianFinder() {\\n        smallNums = new PriorityQueue<>(Collections.reverseOrder());\\n        largeNums = new PriorityQueue<>();\\n    }\\n\\n    public void addNum(int num) {\\n        // Add to maxHeap first (Group of smaller numbers)\\n        smallNums.offer(num);\\n        // Balance the heaps\\n        largeNums.offer(smallNums.poll());\\n        if (largeNums.size() > smallNums.size()) {\\n            smallNums.offer(largeNums.poll());\\n        }\\n    }\\n\\n    public double findMedian() {\\n        if (smallNums.size() != largeNums.size()) {\\n            return smallNums.peek();\\n        }\\n        return (smallNums.peek() + largeNums.peek()) / 2.0;\\n    }\\n}\\n```\\n\\n---\\n**Solution for Follow-Up 1**\\n```java\\n/**\\n * Follow-Up 1 - Numbers are between [0, 100]\\n * Maintain a cumulative count array.\\n *\\n * Time Complexity:\\n * 1) addNum -> O(101) = O(1)\\n * 2) findMedian -> O(log(101)) = O(1)\\n *\\n * Space Complexity: O(101) = O(1)\\n */\\nclass MedianFinder {\\n    int[] count;\\n\\n    public MedianFinder() {\\n        count = new int[101];\\n    }\\n\\n    public void addNum(int num) {\\n        for (int i = num; i < 101; i++) {\\n            count[i]++;\\n        }\\n    }\\n\\n    public double findMedian() {\\n        int totalNums = count[100];\\n        int medianCount = totalNums % 2 == 0 ? totalNums / 2 : (totalNums + 1) / 2;\\n        int idx = binarySearch(count, medianCount);\\n        if (totalNums % 2 == 0) {\\n            if (medianCount < count[idx]) {\\n                return idx;\\n            }\\n            for (int i = idx + 1; i < 101; i++) {\\n                if (count[i] > count[idx]) {\\n                    return (idx + i) / 2.0;\\n                }\\n            }\\n        }\\n        return idx;\\n    }\\n\\n    private int binarySearch(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n        while (start < end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] >= target) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return start;\\n    }\\n}\\n```\\n\\n**Optimized addNum() function to true O(1)**\\n```java\\n/**\\n * Follow-Up 1 - Numbers are between [0, 100]\\n * Maintain a count array. Here Add num is optimized to true O(1)\\n *\\n * Time Complexity:\\n * 1) addNum -> O(1)\\n * 2) findMedian -> O(101) = O(1)\\n *\\n * Space Complexity: O(101) = O(1)\\n */\\nclass MedianFinder {\\n    int[] count;\\n    int totalNums;\\n\\n    public MedianFinder() {\\n        count = new int[101];\\n    }\\n\\n    public void addNum(int num) {\\n        count[num]++;\\n        totalNums++;\\n    }\\n\\n    public double findMedian() {\\n        int medianCount = totalNums % 2 == 0 ? totalNums / 2 : (totalNums + 1) / 2;\\n        int countSum = 0;\\n        int idx = 0;\\n        while (idx <= 100) {\\n            countSum += count[idx];\\n            if (medianCount <= countSum) {\\n                break;\\n            }\\n            idx++;\\n        }\\n        if (totalNums % 2 == 0) {\\n            if (medianCount < countSum) {\\n                return idx;\\n            }\\n            for (int i = idx + 1; i < 101; i++) {\\n                if (count[i] != 0) {\\n                    return (idx + i) / 2.0;\\n                }\\n            }\\n        }\\n        return idx;\\n    }\\n}\\n```\\n\\n---\\n**Solution for Follow-Up 2**\\n```java\\n/**\\n * Follow-Up 2 - 99% Numbers are between [0, 100]\\n * Until a threshold is met use two heaps to find the median. Once the threshold is met\\n * use the cumulative count array.\\n *\\n * Time Complexity:\\n * 1) addNum -> Until threshold O(101 + 5*log(threshold/2)). After threshold O(101)\\n * 2) findMedian -> Until threshold O(1). After threshold O(101)\\n *\\n * Space Complexity: O(101+threshold)\\n */\\nclass MedianFinder {\\n    int[] count;\\n    int lessThanZero;\\n    int totalNums;\\n    int threshold;\\n    PriorityQueue<Integer> smallNums; // Max Heap\\n    PriorityQueue<Integer> largeNums; // Min Heap\\n\\n    public MedianFinder() {\\n        count = new int[101];\\n        threshold = 100;\\n        smallNums = new PriorityQueue<>(Collections.reverseOrder());\\n        largeNums = new PriorityQueue<>();\\n    }\\n\\n    public void addNum(int num) {\\n        if (num < 0) {\\n            lessThanZero++;\\n        }\\n        for (int i = Math.max(num, 0); i < 101; i++) {\\n            count[i]++;\\n        }\\n        totalNums++;\\n        if (totalNums <= threshold) {\\n            smallNums.offer(num);\\n            largeNums.offer(smallNums.poll());\\n            if (largeNums.size() > smallNums.size()) {\\n                smallNums.offer(largeNums.poll());\\n            }\\n        }\\n    }\\n\\n    public double findMedian() {\\n        if (totalNums <= threshold) {\\n            if (smallNums.size() != largeNums.size()) {\\n                return smallNums.peek();\\n            }\\n            return (smallNums.peek() + largeNums.peek()) / 2.0;\\n        }\\n        int medianCount = totalNums % 2 == 0 ? totalNums / 2 : (totalNums + 1) / 2;\\n        int idx = binarySearch(count, medianCount);\\n        if (totalNums % 2 == 0) {\\n            if (medianCount < count[idx]) {\\n                return idx;\\n            }\\n            for (int i = idx + 1; i < 101; i++) {\\n                if (count[i] > count[idx]) {\\n                    return (idx + i) / 2.0;\\n                }\\n            }\\n        }\\n        return idx;\\n    }\\n\\n    private int binarySearch(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n        while (start < end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] >= target) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return start;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\n/**\\n * Using two heaps\\n * \\n * Time Complexity:\\n * 1) addNum -> O(5 * log (N/2)) = O(log N)\\n * 2) findMedian -> O(1)\\n *\\n * Space Complexity: O(N)\\n *\\n * N = Count of numbers in the data stream.\\n */\\nclass MedianFinder {\\n    PriorityQueue<Integer> smallNums; // Max Heap\\n    PriorityQueue<Integer> largeNums; // Min Heap\\n\\n    public MedianFinder() {\\n        smallNums = new PriorityQueue<>(Collections.reverseOrder());\\n        largeNums = new PriorityQueue<>();\\n    }\\n\\n    public void addNum(int num) {\\n        // Add to maxHeap first (Group of smaller numbers)\\n        smallNums.offer(num);\\n        // Balance the heaps\\n        largeNums.offer(smallNums.poll());\\n        if (largeNums.size() > smallNums.size()) {\\n            smallNums.offer(largeNums.poll());\\n        }\\n    }\\n\\n    public double findMedian() {\\n        if (smallNums.size() != largeNums.size()) {\\n            return smallNums.peek();\\n        }\\n        return (smallNums.peek() + largeNums.peek()) / 2.0;\\n    }\\n}\\n```\n```java\\n/**\\n * Follow-Up 1 - Numbers are between [0, 100]\\n * Maintain a cumulative count array.\\n *\\n * Time Complexity:\\n * 1) addNum -> O(101) = O(1)\\n * 2) findMedian -> O(log(101)) = O(1)\\n *\\n * Space Complexity: O(101) = O(1)\\n */\\nclass MedianFinder {\\n    int[] count;\\n\\n    public MedianFinder() {\\n        count = new int[101];\\n    }\\n\\n    public void addNum(int num) {\\n        for (int i = num; i < 101; i++) {\\n            count[i]++;\\n        }\\n    }\\n\\n    public double findMedian() {\\n        int totalNums = count[100];\\n        int medianCount = totalNums % 2 == 0 ? totalNums / 2 : (totalNums + 1) / 2;\\n        int idx = binarySearch(count, medianCount);\\n        if (totalNums % 2 == 0) {\\n            if (medianCount < count[idx]) {\\n                return idx;\\n            }\\n            for (int i = idx + 1; i < 101; i++) {\\n                if (count[i] > count[idx]) {\\n                    return (idx + i) / 2.0;\\n                }\\n            }\\n        }\\n        return idx;\\n    }\\n\\n    private int binarySearch(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n        while (start < end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] >= target) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return start;\\n    }\\n}\\n```\n```java\\n/**\\n * Follow-Up 1 - Numbers are between [0, 100]\\n * Maintain a count array. Here Add num is optimized to true O(1)\\n *\\n * Time Complexity:\\n * 1) addNum -> O(1)\\n * 2) findMedian -> O(101) = O(1)\\n *\\n * Space Complexity: O(101) = O(1)\\n */\\nclass MedianFinder {\\n    int[] count;\\n    int totalNums;\\n\\n    public MedianFinder() {\\n        count = new int[101];\\n    }\\n\\n    public void addNum(int num) {\\n        count[num]++;\\n        totalNums++;\\n    }\\n\\n    public double findMedian() {\\n        int medianCount = totalNums % 2 == 0 ? totalNums / 2 : (totalNums + 1) / 2;\\n        int countSum = 0;\\n        int idx = 0;\\n        while (idx <= 100) {\\n            countSum += count[idx];\\n            if (medianCount <= countSum) {\\n                break;\\n            }\\n            idx++;\\n        }\\n        if (totalNums % 2 == 0) {\\n            if (medianCount < countSum) {\\n                return idx;\\n            }\\n            for (int i = idx + 1; i < 101; i++) {\\n                if (count[i] != 0) {\\n                    return (idx + i) / 2.0;\\n                }\\n            }\\n        }\\n        return idx;\\n    }\\n}\\n```\n```java\\n/**\\n * Follow-Up 2 - 99% Numbers are between [0, 100]\\n * Until a threshold is met use two heaps to find the median. Once the threshold is met\\n * use the cumulative count array.\\n *\\n * Time Complexity:\\n * 1) addNum -> Until threshold O(101 + 5*log(threshold/2)). After threshold O(101)\\n * 2) findMedian -> Until threshold O(1). After threshold O(101)\\n *\\n * Space Complexity: O(101+threshold)\\n */\\nclass MedianFinder {\\n    int[] count;\\n    int lessThanZero;\\n    int totalNums;\\n    int threshold;\\n    PriorityQueue<Integer> smallNums; // Max Heap\\n    PriorityQueue<Integer> largeNums; // Min Heap\\n\\n    public MedianFinder() {\\n        count = new int[101];\\n        threshold = 100;\\n        smallNums = new PriorityQueue<>(Collections.reverseOrder());\\n        largeNums = new PriorityQueue<>();\\n    }\\n\\n    public void addNum(int num) {\\n        if (num < 0) {\\n            lessThanZero++;\\n        }\\n        for (int i = Math.max(num, 0); i < 101; i++) {\\n            count[i]++;\\n        }\\n        totalNums++;\\n        if (totalNums <= threshold) {\\n            smallNums.offer(num);\\n            largeNums.offer(smallNums.poll());\\n            if (largeNums.size() > smallNums.size()) {\\n                smallNums.offer(largeNums.poll());\\n            }\\n        }\\n    }\\n\\n    public double findMedian() {\\n        if (totalNums <= threshold) {\\n            if (smallNums.size() != largeNums.size()) {\\n                return smallNums.peek();\\n            }\\n            return (smallNums.peek() + largeNums.peek()) / 2.0;\\n        }\\n        int medianCount = totalNums % 2 == 0 ? totalNums / 2 : (totalNums + 1) / 2;\\n        int idx = binarySearch(count, medianCount);\\n        if (totalNums % 2 == 0) {\\n            if (medianCount < count[idx]) {\\n                return idx;\\n            }\\n            for (int i = idx + 1; i < 101; i++) {\\n                if (count[i] > count[idx]) {\\n                    return (idx + i) / 2.0;\\n                }\\n            }\\n        }\\n        return idx;\\n    }\\n\\n    private int binarySearch(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n        while (start < end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] >= target) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330697,
                "title": "c-short-and-clean-solution-using-one-multiset-5-lines-of-code",
                "content": "```\\nclass MedianFinder {\\npublic:\\n    MedianFinder() {}\\n    \\n    void addNum(int num) {\\n        nums.insert(num);\\n        is_even = !is_even;\\n        if (it == nums.end() || (is_even && (*it) <= num)) it++;\\n        if (!is_even && (*it) > num) it--;\\n    }\\n    \\n    double findMedian() {\\n        return (!is_even)? *it : (*it + *prev(it)) / 2.0;\\n    }\\n    \\nprivate:\\n    multiset<int> nums;\\n    multiset<int>::iterator it = nums.begin();\\n    bool is_even = true;\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass MedianFinder {\\npublic:\\n    MedianFinder() {}\\n    \\n    void addNum(int num) {\\n        nums.insert(num);\\n        is_even = !is_even;\\n        if (it == nums.end() || (is_even && (*it) <= num)) it++;\\n        if (!is_even && (*it) > num) it--;\\n    }\\n    \\n    double findMedian() {\\n        return (!is_even)? *it : (*it + *prev(it)) / 2.0;\\n    }\\n    \\nprivate:\\n    multiset<int> nums;\\n    multiset<int>::iterator it = nums.begin();\\n    bool is_even = true;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2806191,
                "title": "short-c-explained-solution-beginner-friendly-by-mr-coder",
                "content": "https://www.youtube.com/watch?v=tVe_V74L-Ks\\n**If thumbnail is not showing click on the link directly.**\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**\\n**C++(Heap)**\\n```\\nclass MedianFinder {\\npublic:\\n    priority_queue<int> decreasing;\\n    priority_queue<int, vector<int>, greater<int>> increasing;\\n    bool evn = true;\\n    MedianFinder() {\\n    }\\n    void addNum(int num) {\\n        evn =!evn;\\n        if(!evn){\\n        decreasing.push(num);\\n        increasing.push(decreasing.top());\\n        decreasing.pop();}\\n        else{\\n              increasing.push(num);\\n              decreasing.push(increasing.top());\\n              increasing.pop();\\n        }\\n      \\n    }\\n    double findMedian() {\\n        if (!evn) return increasing.top();\\n        return (decreasing.top() + increasing.top()) / 2.0;\\n    }\\n};\\n```\\n**C++(Multi Set)**\\n```\\nclass MedianFinder {\\nprivate:\\n    multiset<int> mul_set;\\n    multiset<int>::iterator itrtr = mul_set.begin();\\n    bool checkodd = false;\\n    \\npublic:\\n    MedianFinder() {}\\n    \\n    void addNum(int num) {\\n        mul_set.insert(num);\\n        checkodd = !checkodd;\\n        \\n        if (mul_set.size()==1 || (!checkodd && (*itrtr) <= num)) itrtr++;\\n        if (checkodd && (*itrtr) > num) itrtr--;\\n    }\\n    \\n    double findMedian() {\\n        return (checkodd)? *itrtr : (*itrtr + *prev(itrtr)) / 2.0;\\n    }\\n    \\n};\\n```\\n**If you find my solution helpful please upvote it.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass MedianFinder {\\npublic:\\n    priority_queue<int> decreasing;\\n    priority_queue<int, vector<int>, greater<int>> increasing;\\n    bool evn = true;\\n    MedianFinder() {\\n    }\\n    void addNum(int num) {\\n        evn =!evn;\\n        if(!evn){\\n        decreasing.push(num);\\n        increasing.push(decreasing.top());\\n        decreasing.pop();}\\n        else{\\n              increasing.push(num);\\n              decreasing.push(increasing.top());\\n              increasing.pop();\\n        }\\n      \\n    }\\n    double findMedian() {\\n        if (!evn) return increasing.top();\\n        return (decreasing.top() + increasing.top()) / 2.0;\\n    }\\n};\\n```\n```\\nclass MedianFinder {\\nprivate:\\n    multiset<int> mul_set;\\n    multiset<int>::iterator itrtr = mul_set.begin();\\n    bool checkodd = false;\\n    \\npublic:\\n    MedianFinder() {}\\n    \\n    void addNum(int num) {\\n        mul_set.insert(num);\\n        checkodd = !checkodd;\\n        \\n        if (mul_set.size()==1 || (!checkodd && (*itrtr) <= num)) itrtr++;\\n        if (checkodd && (*itrtr) > num) itrtr--;\\n    }\\n    \\n    double findMedian() {\\n        return (checkodd)? *itrtr : (*itrtr + *prev(itrtr)) / 2.0;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 74091,
                "title": "a-clean-solution-using-multiset-in-c",
                "content": "The key point here is to ensure the `midIter` always points to the median or if it's even array then to the first of the median.\\n\\nthe complete solution in C++ as follows.\\n\\n```\\nclass MedianFinder {\\nprivate:\\n    int size; \\n    multiset<int> numsSet;\\n    multiset<int>::iterator midIter;\\npublic:\\n\\n    // Adds a number into the data structure.\\n    void addNum(int num) \\n    {\\n        if(numsSet.empty())\\n        {\\n            midIter = numsSet.insert(num);\\n            size++;\\n            return ; \\n        }\\n        numsSet.insert(num);\\n        if((size&1) && num<*midIter) --midIter; \\n        else if(!(size&1) && num>=*midIter) ++midIter;\\n        size++;\\n    }\\n\\n    // Returns the median of current data stream\\n    double findMedian() \\n    {\\n        if(size & 1) return *midIter;   \\n        else return (double)(*midIter+*next(midIter))/2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass MedianFinder {\\nprivate:\\n    int size; \\n    multiset<int> numsSet;\\n    multiset<int>::iterator midIter;\\npublic:\\n\\n    // Adds a number into the data structure.\\n    void addNum(int num) \\n    {\\n        if(numsSet.empty())\\n        {\\n            midIter = numsSet.insert(num);\\n            size++;\\n            return ; \\n        }\\n        numsSet.insert(num);\\n        if((size&1) && num<*midIter) --midIter; \\n        else if(!(size&1) && num>=*midIter) ++midIter;\\n        size++;\\n    }\\n\\n    // Returns the median of current data stream\\n    double findMedian() \\n    {\\n        if(size & 1) return *midIter;   \\n        else return (double)(*midIter+*next(midIter))/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 74166,
                "title": "solution-using-binary-search-tree",
                "content": "As the input numbers are random, so the height of the binary search tree is O(logN)\\n\\nWe maintain every single node's children's size and it's easy to implement because it just has add operation.\\n\\n    struct BST {\\n        struct node {\\n            int val;\\n            int size;\\n            node* left, *right;\\n            node(int v) : size(1), val(v) {};\\n        } *Null, *root;\\n        \\n        BST() {\\n            Null = new node(0);\\n            Null -> size = 0;\\n            root = Null;\\n        }\\n        \\n        void add(int val, node*& R) {\\n            if(R == Null) {\\n                R = new node(val);\\n                R -> left = R -> right = Null;\\n                return;\\n            }\\n            if(R->val <= val) add(val, R->left);\\n            else add(val, R->right);\\n            R->size = R->left->size + R->right->size + 1;\\n            \\n        }\\n        \\n        int rank(int k) {\\n            node* t = root;\\n            while(true) {\\n                int leftSize =  t -> left -> size;\\n                if(leftSize == k) return t -> val;\\n                if(leftSize > k) {\\n                    t = t -> left;\\n                } else {\\n                    k = k - leftSize - 1;\\n                    t = t -> right;\\n                }\\n            }\\n            return -1;\\n        }\\n    };\\n    \\n    \\n    \\n    \\n    class MedianFinder {\\n    public:\\n        BST* bst;\\n        MedianFinder() {\\n            bst = new BST();\\n        }\\n        // Adds a number into the data structure.\\n        void addNum(int num) {\\n            bst->add(num, bst->root);\\n        }\\n        \\n        // Returns the median of current data stream\\n        double findMedian() {\\n            int sz = bst -> root -> size;\\n            if(sz % 2 == 0) {\\n                return 1.0 * (bst -> rank(sz / 2) + bst -> rank(sz / 2 - 1)) / 2;\\n            } else return bst->rank(sz / 2);\\n            \\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Tree"
                ],
                "code": "As the input numbers are random, so the height of the binary search tree is O(logN)\\n\\nWe maintain every single node's children's size and it's easy to implement because it just has add operation.\\n\\n    struct BST {\\n        struct node {\\n            int val;\\n            int size;\\n            node* left, *right;\\n            node(int v) : size(1), val(v) {};\\n        } *Null, *root;\\n        \\n        BST() {\\n            Null = new node(0);\\n            Null -> size = 0;\\n            root = Null;\\n        }\\n        \\n        void add(int val, node*& R) {\\n            if(R == Null) {\\n                R = new node(val);\\n                R -> left = R -> right = Null;\\n                return;\\n            }\\n            if(R->val <= val) add(val, R->left);\\n            else add(val, R->right);\\n            R->size = R->left->size + R->right->size + 1;\\n            \\n        }\\n        \\n        int rank(int k) {\\n            node* t = root;\\n            while(true) {\\n                int leftSize =  t -> left -> size;\\n                if(leftSize == k) return t -> val;\\n                if(leftSize > k) {\\n                    t = t -> left;\\n                } else {\\n                    k = k - leftSize - 1;\\n                    t = t -> right;\\n                }\\n            }\\n            return -1;\\n        }\\n    };\\n    \\n    \\n    \\n    \\n    class MedianFinder {\\n    public:\\n        BST* bst;\\n        MedianFinder() {\\n            bst = new BST();\\n        }\\n        // Adds a number into the data structure.\\n        void addNum(int num) {\\n            bst->add(num, bst->root);\\n        }\\n        \\n        // Returns the median of current data stream\\n        double findMedian() {\\n            int sz = bst -> root -> size;\\n            if(sz % 2 == 0) {\\n                return 1.0 * (bst -> rank(sz / 2) + bst -> rank(sz / 2 - 1)) / 2;\\n            } else return bst->rank(sz / 2);\\n            \\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 652498,
                "title": "good-for-interviews-python-general-sort-insertion-sort-two-heaps-follow-ups",
                "content": "```\\n# sort O(NlogN)\\nclass MedianFinder:\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.store = []\\n\\n    def addNum(self, num: int) -> None:\\n        self.store.append(num)\\n        \\n    def findMedian(self) -> float:\\n        self.store.sort()\\n        \\n        n = len(self.store)-1\\n        return self.store[n//2] if n % 2 == 0 else (self.store[n//2] + self.store[n//2 + 1])/2.0\\n\\n# insertion sort -> bisect using binary search O(logN)\\n# insert -> O(N)\\n# Time O(N) + O(logN) = O(N)\\nfrom bisect import bisect_left\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.store = []\\n\\n    def addNum(self, num: int) -> None:\\n        if not self.store:\\n            self.store.append(num)\\n        else:\\n            idx = bisect_left(self.store, num)\\n            self.store.insert(idx, num)\\n        \\n    def findMedian(self) -> float:        \\n        n = len(self.store)-1\\n        return self.store[n//2] if n % 2 == 0 else (self.store[n//2] + self.store[n//2 + 1])/2.0\\n\\n# Time O(logN)\\nfrom heapq import heappush, heappop\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        # holds the smaller half\\n        self.max = []\\n        # holds the larger half\\n        self.min = []\\n        \\n\\n    def addNum(self, num: int) -> None:\\n        heappush(self.max, -num)\\n        heappush(self.min, -heappop(self.max))\\n        if len(self.min) > len(self.max):\\n            heappush(self.max, -heappop(self.min))\\n\\n        \\n    def findMedian(self) -> float:\\n        if len(self.max) == len(self.min):\\n            return (self.min[0] - self.max[0])/2.0\\n        else:\\n            return -self.max[0]\\n\\n```\\nOther nice things to mention:\\nUse self-balancing BST, the median is either the root node or children of root, insertion takes O(logN).\\nRed-black trees are better than AVL trees in this scenario because of a lot of insertions happening. \\nMultiset data structures in a lot of languages are implemented using red-black trees.\\n\\nFollow-ups:\\n\\n1. If all integer numbers from the stream are between 0\\xA0and 100, how would you optimize it?\\n- bucket sort, create an array of bucket of length 101, keep the count of numbers in each bucket, and the count of overall numbers, then it\\'s easy to locate the bucket where the median number resides and find the median by looping through the array-> O(1)\\n2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n- 99% of all integer numbers lie in [0,100] means the median is definitely inside [0,100]. Besides the bucket range [0,100] as mentioned above, we just need to keep the count of all numbers, numbers smaller than 0, and numbers larger than 100, and adjust the index of the median element in our buckets of range [0,100].\\nFor example, if we have 100 numbers streamed, and one of the number is smaller than 0, that means the median\\'s index moved forward by 1, we just need to find the 49th element in our buckets in a sorted manner.",
                "solutionTags": [],
                "code": "```\\n# sort O(NlogN)\\nclass MedianFinder:\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.store = []\\n\\n    def addNum(self, num: int) -> None:\\n        self.store.append(num)\\n        \\n    def findMedian(self) -> float:\\n        self.store.sort()\\n        \\n        n = len(self.store)-1\\n        return self.store[n//2] if n % 2 == 0 else (self.store[n//2] + self.store[n//2 + 1])/2.0\\n\\n# insertion sort -> bisect using binary search O(logN)\\n# insert -> O(N)\\n# Time O(N) + O(logN) = O(N)\\nfrom bisect import bisect_left\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.store = []\\n\\n    def addNum(self, num: int) -> None:\\n        if not self.store:\\n            self.store.append(num)\\n        else:\\n            idx = bisect_left(self.store, num)\\n            self.store.insert(idx, num)\\n        \\n    def findMedian(self) -> float:        \\n        n = len(self.store)-1\\n        return self.store[n//2] if n % 2 == 0 else (self.store[n//2] + self.store[n//2 + 1])/2.0\\n\\n# Time O(logN)\\nfrom heapq import heappush, heappop\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        # holds the smaller half\\n        self.max = []\\n        # holds the larger half\\n        self.min = []\\n        \\n\\n    def addNum(self, num: int) -> None:\\n        heappush(self.max, -num)\\n        heappush(self.min, -heappop(self.max))\\n        if len(self.min) > len(self.max):\\n            heappush(self.max, -heappop(self.min))\\n\\n        \\n    def findMedian(self) -> float:\\n        if len(self.max) == len(self.min):\\n            return (self.min[0] - self.max[0])/2.0\\n        else:\\n            return -self.max[0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354195,
                "title": "c-112-ms-99-solution-w-follow-up",
                "content": "The idea behind this solution is to use two prioriy queues and two ints where int1 <= int2. The two ints store potential median, and the two priority queues stores values less than the int1, and greater than int 2. Thus, when we always have the median in ```O(1)``` time. When we add element, we insert according to int1 and int2, and int1/2 are potentially updated. Once that is done, we need to \"shift\" numbers either to left or right, so the size of the two queues are at most 1 apart. Thus, when the two queues are equal in size, median is average of int1 and int2, and when they are not equal, the median is either int1 or int2, depending on which queue you set to have the greater size.\\n\\nThe less queue must have elements sorted in ascending, so we always push out the maximum (previous element in sorted order), while the greater queue must have elements sorted in descending, so we always push out the minimum (next element in sorted order)\\n\\nThe run-time of this algorithm is ```O(nlgn)```, and space complexity is ```O(n)```. \\n\\n**Follow up**:\\n\\nIf the range of the numbers are between 0 and 100, we can use bins to collect the frequency of each number. This makes the insert process ```O(1)```. To get the median, we can simply check what is the cumulative count (if 500 elements inserted, median is the 250th and 251th number. we need to find after which element do we go over count 250 and 251, so we add count for 0, count for 1, etc. until we get to elements covering 250 and 251). This can be done in ```O(1)``` time, since we go at most from 0 up to 100. \\n\\nIf 99% of the numbers are in ```[0, 100]``` but 1% is not, we can simply have two extra counts, one for less than 0, one for greater than 100. This is because we know for sure the median is still in ```[0, 100]``` since it occupies more than 50% of the total counts, so we don\\'t need the values for those 1%. Thus, we simply add in two extra counts when calculating the cumulative count value for median, and do the same thing as before to find the median. For example if we have 107 elements inserted, and there are 2 elements before 0 and 5 after 100. Since total elements = 107, we are looking for 54th element, so we start with count = 2, add count for 0, for 1, etc. until we get the element that increases count over 54.\\n\\n```\\nclass MedianFinder {\\npublic:\\n    MedianFinder(): size(0), v1(0), v2(0) {} // Assert size of g is either equal or greater than 1 than size of l\\n    \\n    void addNum(int num) {\\n        ++size;\\n        if(size == 1) v2 = num;\\n        else if(size == 2) {\\n            v1 = num;\\n            if(v1 > v2) swap(v1, v2);\\n        }\\n        else {\\n            if(num >= v2) g.push(num);\\n            else if(num > v1) {g.push(v2); v2 = num;}\\n            else l.push(num);\\n        }\\n        if(l.size() > g.size()) {\\n            g.push(v2);\\n            v2 = v1;\\n            v1 = l.top(); l.pop();\\n        }\\n        else if(g.size() > l.size()+1) {\\n            l.push(v1);\\n            v1 = v2;\\n            v2 = g.top(); g.pop();\\n        }\\n    }\\n    \\n    double findMedian() {\\n        return size % 2 ? v2 : (v1 + v2)/2.0;\\n    }\\n    int size;\\n    int v1;\\n    int v2;\\n    priority_queue<int, vector<int>, greater<int>> g;\\n    priority_queue<int, vector<int>, less<int>> l;\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```O(1)```\n```O(nlgn)```\n```O(n)```\n```O(1)```\n```O(1)```\n```[0, 100]```\n```[0, 100]```\n```\\nclass MedianFinder {\\npublic:\\n    MedianFinder(): size(0), v1(0), v2(0) {} // Assert size of g is either equal or greater than 1 than size of l\\n    \\n    void addNum(int num) {\\n        ++size;\\n        if(size == 1) v2 = num;\\n        else if(size == 2) {\\n            v1 = num;\\n            if(v1 > v2) swap(v1, v2);\\n        }\\n        else {\\n            if(num >= v2) g.push(num);\\n            else if(num > v1) {g.push(v2); v2 = num;}\\n            else l.push(num);\\n        }\\n        if(l.size() > g.size()) {\\n            g.push(v2);\\n            v2 = v1;\\n            v1 = l.top(); l.pop();\\n        }\\n        else if(g.size() > l.size()+1) {\\n            l.push(v1);\\n            v1 = v2;\\n            v2 = g.top(); g.pop();\\n        }\\n    }\\n    \\n    double findMedian() {\\n        return size % 2 ? v2 : (v1 + v2)/2.0;\\n    }\\n    int size;\\n    int v1;\\n    int v2;\\n    priority_queue<int, vector<int>, greater<int>> g;\\n    priority_queue<int, vector<int>, less<int>> l;\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2805899,
                "title": "java-easy-solution-using-for-loop-arraylist",
                "content": "```\\nclass MedianFinder {\\n    \\n    ArrayList<Integer> list;\\n\\n    public MedianFinder() {\\n        list = new ArrayList<>();\\n    }\\n    \\n    public void addNum(int num) {\\n        int i;\\n        if(list.size() > 0){\\n            for (i = 0; (i < list.size()  && list.get(i) < num); i++);\\n            list.add(i , num);\\n        }else{\\n            list.add(num);\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        // System.out.println(list);\\n        int index = list.size()/2;\\n        if(list.size() % 2 == 0){\\n            return (double) (list.get(index) + list.get(index - 1))/2;\\n        }else{\\n            return list.get(index);\\n        }\\n        \\n    }\\n}\\n```\\n\\n**Upvote Please**",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass MedianFinder {\\n    \\n    ArrayList<Integer> list;\\n\\n    public MedianFinder() {\\n        list = new ArrayList<>();\\n    }\\n    \\n    public void addNum(int num) {\\n        int i;\\n        if(list.size() > 0){\\n            for (i = 0; (i < list.size()  && list.get(i) < num); i++);\\n            list.add(i , num);\\n        }else{\\n            list.add(num);\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        // System.out.println(list);\\n        int index = list.size()/2;\\n        if(list.size() % 2 == 0){\\n            return (double) (list.get(index) + list.get(index - 1))/2;\\n        }else{\\n            return list.get(index);\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404605,
                "title": "short-js-solution-with-explanation-2-heaps-leetcode-s-default-heap",
                "content": "# Basic understanding of the problem\\nAs we need a median for a set of numbers is a sorted order middle value. So for an odd-numbered set, it would be the middle value:\\n`1 2 3 4 5`\\nin this case, it would be 3 which is Math.floor(n/2)\\nFor the even-numbered set it wouldn\\'t have a middle value so we would take 2 middle values and find their average:\\n`1 2 3 4`  (2+3)/2=2.5\\n\\nThe problem is that sorting each time would take too long and we need a way to store and add our elements in such a way that they will be kept sorted. For this, we use 2 heaps and we divide our array into 2 parts one for n/2 and the other one either for n/2 or n/2+1 depending on whether the set is odd or even. For example\\n\\n`1 2 3 4 5` we would keep` 1 2 ` and  `3 4 5` in separate heaps and we can just return the top value of 3 4 5 which would be the median or for\\n`1 2 3 4 ` we would have `1 2`  and  `3 4`  but notice that we cant use 1 and 3, that\\'s why we use 1 max heap and 1 min-heap so they are sorted as \\n`2 1` (max heap)  the top value will be the max\\n`3 4`(min-heap) the top value will be the mean\\n\\n```\\nclass MedianFinder {\\n\\t//Initilize max and min heap\\n    constructor() {\\n        this.minHeap = new MinPriorityQueue() //supported by leetcode\\n        this.maxHeap = new MaxPriorityQueue()\\n    }\\n\\n    addNum(num) {\\n\\t//add to min and pop the top for max to keep them in the order that we want\\n        this.minHeap.enqueue(num);\\n        this.maxHeap.enqueue(this.minHeap.dequeue().element);\\n\\t\\t//balance them\\n        if (this.minHeap.size() < this.maxHeap.size()) {\\n            this.minHeap.enqueue(this.maxHeap.dequeue().element);\\n        }\\n\\t\\t//console.log(this.minHeap.toArray(), this.maxHeap.toArray()) //run this to understand better\\n    }\\n\\n    findMedian() {\\n        if (this.minHeap.size() > this.maxHeap.size()) // if one is bigger 21 and 345 example just pop from 345(min heap)\\n            return this.minHeap.front().element;\\n        else \\n            return (this.minHeap.front().element + this.maxHeap.front().element) / 2; // 21 and 34 example, pop 1 and 3 and find average\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass MedianFinder {\\n\\t//Initilize max and min heap\\n    constructor() {\\n        this.minHeap = new MinPriorityQueue() //supported by leetcode\\n        this.maxHeap = new MaxPriorityQueue()\\n    }\\n\\n    addNum(num) {\\n\\t//add to min and pop the top for max to keep them in the order that we want\\n        this.minHeap.enqueue(num);\\n        this.maxHeap.enqueue(this.minHeap.dequeue().element);\\n\\t\\t//balance them\\n        if (this.minHeap.size() < this.maxHeap.size()) {\\n            this.minHeap.enqueue(this.maxHeap.dequeue().element);\\n        }\\n\\t\\t//console.log(this.minHeap.toArray(), this.maxHeap.toArray()) //run this to understand better\\n    }\\n\\n    findMedian() {\\n        if (this.minHeap.size() > this.maxHeap.size()) // if one is bigger 21 and 345 example just pop from 345(min heap)\\n            return this.minHeap.front().element;\\n        else \\n            return (this.minHeap.front().element + this.maxHeap.front().element) / 2; // 21 and 34 example, pop 1 and 3 and find average\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 786325,
                "title": "java-two-heaps-algo-explained-through-comments",
                "content": "```\\nclass MedianFinder {\\n    \\n    // To store lower half of data stream eg. 1, 2, 3, 6\\n    PriorityQueue<Integer> lowerHalf;\\n    // To store upper half of data stream eg. 8, 9, 11\\n    PriorityQueue<Integer> upperHalf;\\n\\n    /** initialize your data structure here. */\\n    public MedianFinder() {\\n        lowerHalf = new PriorityQueue<>((a,b) -> b - a); // Max heap : To fetch largest\\n        // element from lower half in O(1) time\\n        upperHalf = new PriorityQueue<>(); // Min heap : To fetch lowest \\n        // element from upper half in O(1) time\\n    }\\n    \\n    public void addNum(int num) {\\n        // Insert in lowerHalf is it\\'s empty or if number being inserted is less than the peek of lowerHalf otherwise insert in upperHalf\\n        if(lowerHalf.isEmpty() || num <= lowerHalf.peek()){\\n            lowerHalf.add(num);\\n        }else{\\n            upperHalf.add(num);\\n        }\\n        \\n        // We also need to ensure that the halves are balanced i.e. there is no more than a difference of 1 in size of both halves\\n        // Let lowerHalf be the one to hold one extra element if the size of total data stream is odd otherwise be equal to upperHalf\\n        if(upperHalf.size() > lowerHalf.size()){ // If an element added above made upperHalf have one more element than lowerHalf then we poll it and put it into lowerHalf\\n            lowerHalf.add(upperHalf.poll());\\n        } else if(lowerHalf.size() > upperHalf.size() + 1){\\n            // If an element added above, made lowerHalf have 2 more elements then upperHalf then we put one into upperHalf from lowerHalf\\n            upperHalf.add(lowerHalf.poll());\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        if(lowerHalf.size() == upperHalf.size()){\\n            return (double)(lowerHalf.peek() + upperHalf.peek())/2;\\n        }else{\\n             return (double)(lowerHalf.peek());\\n        }\\n    }\\n}\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder obj = new MedianFinder();\\n * obj.addNum(num);\\n * double param_2 = obj.findMedian();\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass MedianFinder {\\n    \\n    // To store lower half of data stream eg. 1, 2, 3, 6\\n    PriorityQueue<Integer> lowerHalf;\\n    // To store upper half of data stream eg. 8, 9, 11\\n    PriorityQueue<Integer> upperHalf;\\n\\n    /** initialize your data structure here. */\\n    public MedianFinder() {\\n        lowerHalf = new PriorityQueue<>((a,b) -> b - a); // Max heap : To fetch largest\\n        // element from lower half in O(1) time\\n        upperHalf = new PriorityQueue<>(); // Min heap : To fetch lowest \\n        // element from upper half in O(1) time\\n    }\\n    \\n    public void addNum(int num) {\\n        // Insert in lowerHalf is it\\'s empty or if number being inserted is less than the peek of lowerHalf otherwise insert in upperHalf\\n        if(lowerHalf.isEmpty() || num <= lowerHalf.peek()){\\n            lowerHalf.add(num);\\n        }else{\\n            upperHalf.add(num);\\n        }\\n        \\n        // We also need to ensure that the halves are balanced i.e. there is no more than a difference of 1 in size of both halves\\n        // Let lowerHalf be the one to hold one extra element if the size of total data stream is odd otherwise be equal to upperHalf\\n        if(upperHalf.size() > lowerHalf.size()){ // If an element added above made upperHalf have one more element than lowerHalf then we poll it and put it into lowerHalf\\n            lowerHalf.add(upperHalf.poll());\\n        } else if(lowerHalf.size() > upperHalf.size() + 1){\\n            // If an element added above, made lowerHalf have 2 more elements then upperHalf then we put one into upperHalf from lowerHalf\\n            upperHalf.add(lowerHalf.poll());\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        if(lowerHalf.size() == upperHalf.size()){\\n            return (double)(lowerHalf.peek() + upperHalf.peek())/2;\\n        }else{\\n             return (double)(lowerHalf.peek());\\n        }\\n    }\\n}\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder obj = new MedianFinder();\\n * obj.addNum(num);\\n * double param_2 = obj.findMedian();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 677080,
                "title": "well-commented-python-code",
                "content": "```\\nclass MedianFinder:\\n    \\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.lowerhalf = [] # store the small half, top is the largest in the small part\\n        self.upperhalf = [] # store the large half, top is the smallest in the large part\\n\\n    def addNum(self, num):\\n        \"\"\"\\n        Adds a num into the data structure.\\n        :type num: int\\n        :rtype: void\\n        \"\"\"\\n        # The case for the first element, just add to the minheap\\n        if len(self.lowerhalf) == 0:\\n            heapq.heappush(self.lowerhalf, -num)\\n            return\\n        \\n        # Now choose where to add the new element \\n        # If it is less than or equal the top of min heap, it can be accomodated under it else go to max heap\\n        if num <= -self.lowerhalf[0]:\\n            heapq.heappush(self.lowerhalf, -num) # Go to the max Heap \\n            #(-ve sign because to implement max heap using the default heapq in python, we need to negate the values)\\n        else:\\n            heapq.heappush(self.upperhalf, num) # Go to the min Heap\\n            \\n        # Adjusting the balance\\n        \\n        # If the lowerhalf heap has more elements\\n        if len(self.lowerhalf) - len(self.upperhalf) == 2:\\n            heapq.heappush(self.upperhalf, - heapq.heappop(self.lowerhalf))\\n        \\n        # If the upperhalf heap has more elements\\n        elif len(self.upperhalf) - len(self.lowerhalf) == 2:\\n            heapq.heappush(self.lowerhalf, - heapq.heappop(self.upperhalf))\\n        \\n\\n    def findMedian(self):\\n        \"\"\"\\n        Returns the median of current data stream\\n        :rtype: float\\n        \"\"\"\\n        # If both heaps have same number of elements return the avg\\n        # If not, then the root of the one with more elements, is the answer\\n        \\n        if len(self.lowerhalf) == len(self.upperhalf):\\n            return (- self.lowerhalf[0] + self.upperhalf[0] )/2.0 \\n            # - sign because lowerhalf has negative value\\n        elif len(self.lowerhalf) > len(self.upperhalf):\\n            return -float(self.lowerhalf[0])\\n        else:\\n            return float(self.upperhalf[0])\\n\\n# Your MedianFinder object will be instantiated and called as such:\\n# obj = MedianFinder()\\n# obj.addNum(num)\\n# param_2 = obj.findMedian()\\n```\\nBased on video solution from: youtube.com/watch?v=1CxyVdA_654",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass MedianFinder:\\n    \\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.lowerhalf = [] # store the small half, top is the largest in the small part\\n        self.upperhalf = [] # store the large half, top is the smallest in the large part\\n\\n    def addNum(self, num):\\n        \"\"\"\\n        Adds a num into the data structure.\\n        :type num: int\\n        :rtype: void\\n        \"\"\"\\n        # The case for the first element, just add to the minheap\\n        if len(self.lowerhalf) == 0:\\n            heapq.heappush(self.lowerhalf, -num)\\n            return\\n        \\n        # Now choose where to add the new element \\n        # If it is less than or equal the top of min heap, it can be accomodated under it else go to max heap\\n        if num <= -self.lowerhalf[0]:\\n            heapq.heappush(self.lowerhalf, -num) # Go to the max Heap \\n            #(-ve sign because to implement max heap using the default heapq in python, we need to negate the values)\\n        else:\\n            heapq.heappush(self.upperhalf, num) # Go to the min Heap\\n            \\n        # Adjusting the balance\\n        \\n        # If the lowerhalf heap has more elements\\n        if len(self.lowerhalf) - len(self.upperhalf) == 2:\\n            heapq.heappush(self.upperhalf, - heapq.heappop(self.lowerhalf))\\n        \\n        # If the upperhalf heap has more elements\\n        elif len(self.upperhalf) - len(self.lowerhalf) == 2:\\n            heapq.heappush(self.lowerhalf, - heapq.heappop(self.upperhalf))\\n        \\n\\n    def findMedian(self):\\n        \"\"\"\\n        Returns the median of current data stream\\n        :rtype: float\\n        \"\"\"\\n        # If both heaps have same number of elements return the avg\\n        # If not, then the root of the one with more elements, is the answer\\n        \\n        if len(self.lowerhalf) == len(self.upperhalf):\\n            return (- self.lowerhalf[0] + self.upperhalf[0] )/2.0 \\n            # - sign because lowerhalf has negative value\\n        elif len(self.lowerhalf) > len(self.upperhalf):\\n            return -float(self.lowerhalf[0])\\n        else:\\n            return float(self.upperhalf[0])\\n\\n# Your MedianFinder object will be instantiated and called as such:\\n# obj = MedianFinder()\\n# obj.addNum(num)\\n# param_2 = obj.findMedian()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805492,
                "title": "c-solutions",
                "content": "```\\nclass MedianFinder {\\nprivate:\\n    priority_queue<int> firstQ; // max_heap for the first half\\n    priority_queue<int, std::vector<int>, std::greater<int> > secQ; // min_heap for the second half\\npublic:\\n    // Adds a number into the data structure.\\n    void addNum(int num) {\\n        if(firstQ.empty() || (firstQ.top()>num)) firstQ.push(num); // if it belongs to the smaller half\\n        else secQ.push(num); \\n        \\n        // rebalance the two halfs to make sure the length difference is no larger than 1\\n        if(firstQ.size() > (secQ.size()+1))\\n        {\\n            secQ.push(firstQ.top());\\n            firstQ.pop();\\n        }\\n        else if(firstQ.size()+1<secQ.size())\\n        {\\n            firstQ.push(secQ.top());\\n            secQ.pop();\\n        }\\n    }\\n\\n    // Returns the median of current data stream\\n    double findMedian() {\\n        if(firstQ.size() == secQ.size()) return firstQ.empty()?0:( (firstQ.top()+secQ.top())/2.0);\\n        else return (firstQ.size() > secQ.size())? firstQ.top():secQ.top(); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass MedianFinder {\\nprivate:\\n    priority_queue<int> firstQ; // max_heap for the first half\\n    priority_queue<int, std::vector<int>, std::greater<int> > secQ; // min_heap for the second half\\npublic:\\n    // Adds a number into the data structure.\\n    void addNum(int num) {\\n        if(firstQ.empty() || (firstQ.top()>num)) firstQ.push(num); // if it belongs to the smaller half\\n        else secQ.push(num); \\n        \\n        // rebalance the two halfs to make sure the length difference is no larger than 1\\n        if(firstQ.size() > (secQ.size()+1))\\n        {\\n            secQ.push(firstQ.top());\\n            firstQ.pop();\\n        }\\n        else if(firstQ.size()+1<secQ.size())\\n        {\\n            firstQ.push(secQ.top());\\n            secQ.pop();\\n        }\\n    }\\n\\n    // Returns the median of current data stream\\n    double findMedian() {\\n        if(firstQ.size() == secQ.size()) return firstQ.empty()?0:( (firstQ.top()+secQ.top())/2.0);\\n        else return (firstQ.size() > secQ.size())? firstQ.top():secQ.top(); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 271077,
                "title": "c-94-5",
                "content": "````\\npublic class MedianFinder \\n{\\n    List<int> Numbers;\\n    \\n    public MedianFinder() \\n    {\\n        Numbers = new List<int>();\\n    }\\n    \\n    public void AddNum(int num) \\n    {\\n        // Find where to insert this num in Numbers using Binary Search\\n        // NOTE: Binary Search is logarithmic time complexity O(logn) \\n        int position = Numbers.BinarySearch(num);\\n        \\n        // So if BinarySearch returns -1 it means we should insert at the first position\\n        if (position < 0)\\n        {\\n            position = ~position; // Bitwise complement of -1 is 0\\n        }\\n        \\n        Numbers.Insert(position, num);\\n    }\\n    \\n    public double FindMedian() \\n    {\\n        int count = Numbers.Count;\\n        if (count % 2 == 0)\\n        {\\n            // Even number of elements\\n            return (double)((Numbers[count / 2 - 1] + Numbers[count / 2]) * 0.5);\\n        }\\n        else\\n        {\\n            // Odd number of elements\\n            return (double)(Numbers[count / 2]);\\n        }            \\n    }\\n}\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder obj = new MedianFinder();\\n * obj.AddNum(num);\\n * double param_2 = obj.FindMedian();\\n */\\n ````",
                "solutionTags": [],
                "code": "````\\npublic class MedianFinder \\n{\\n    List<int> Numbers;\\n    \\n    public MedianFinder() \\n    {\\n        Numbers = new List<int>();\\n    }\\n    \\n    public void AddNum(int num) \\n    {\\n        // Find where to insert this num in Numbers using Binary Search\\n        // NOTE: Binary Search is logarithmic time complexity O(logn) \\n        int position = Numbers.BinarySearch(num);\\n        \\n        // So if BinarySearch returns -1 it means we should insert at the first position\\n        if (position < 0)\\n        {\\n            position = ~position; // Bitwise complement of -1 is 0\\n        }\\n        \\n        Numbers.Insert(position, num);\\n    }\\n    \\n    public double FindMedian() \\n    {\\n        int count = Numbers.Count;\\n        if (count % 2 == 0)\\n        {\\n            // Even number of elements\\n            return (double)((Numbers[count / 2 - 1] + Numbers[count / 2]) * 0.5);\\n        }\\n        else\\n        {\\n            // Odd number of elements\\n            return (double)(Numbers[count / 2]);\\n        }            \\n    }\\n}\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder obj = new MedianFinder();\\n * obj.AddNum(num);\\n * double param_2 = obj.FindMedian();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 122701,
                "title": "javascript-solution-using-binary-search",
                "content": "```\\nvar MedianFinder = function() {\\n    this.ary = [];\\n};\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nMedianFinder.prototype.addNum = function(num) {\\n   \\n    var low = 0 ; \\n    var high = this.ary.length-1;\\n    \\n    while(low <= high)\\n        {\\n            var mid = Math.floor((high + low)/2);\\n            \\n            if(this.ary[mid]  < num)\\n                {\\n                    low = mid+1;\\n                }\\n            else\\n                {\\n                    high =mid-1;\\n                }\\n        }\\n    \\n    // insert at  location trick for javascript array.\\n    this.ary.splice(low, 0, num);\\n    \\n};\\n\\n/**\\n * @return {number}\\n */\\nMedianFinder.prototype.findMedian = function() {\\n    \\n    if(this.ary.length % 2 ==0)\\n        {\\n            var mid = this.ary.length/2;\\n            return (this.ary[mid] + this.ary[mid-1])/2;\\n        }\\n    else\\n        {\\n            var mid = Math.floor(this.ary.length/2);\\n            return (this.ary[mid]);\\n        }\\n    \\n};\\n",
                "solutionTags": [],
                "code": "```\\nvar MedianFinder = function() {\\n    this.ary = [];\\n};\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nMedianFinder.prototype.addNum = function(num) {\\n   \\n    var low = 0 ; \\n    var high = this.ary.length-1;\\n    \\n    while(low <= high)\\n        {\\n            var mid = Math.floor((high + low)/2);\\n            \\n            if(this.ary[mid]  < num)\\n                {\\n                    low = mid+1;\\n                }\\n            else\\n                {\\n                    high =mid-1;\\n                }\\n        }\\n    \\n    // insert at  location trick for javascript array.\\n    this.ary.splice(low, 0, num);\\n    \\n};\\n\\n/**\\n * @return {number}\\n */\\nMedianFinder.prototype.findMedian = function() {\\n    \\n    if(this.ary.length % 2 ==0)\\n        {\\n            var mid = this.ary.length/2;\\n            return (this.ary[mid] + this.ary[mid-1])/2;\\n        }\\n    else\\n        {\\n            var mid = Math.floor(this.ary.length/2);\\n            return (this.ary[mid]);\\n        }\\n    \\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 969081,
                "title": "python-two-heap-solution-with-full-explanation",
                "content": "```\\nimport heapq\\n\\nclass MedianFinder:\\n    \\n    \\'\\'\\'\\n    We have a max heap representing the sorted left half of the stream, and a min heap representing the sorted right half of the stream.\\n    The tops of these heaps represent the middle of the stream so far.\\n    \\n    To get the median:\\n        - if len(left) == len(right): return (left[0] + right[0]) / 2\\n        - elif len(left) > len(right): return left[0]\\n        - else: return right[0]\\n        \\n    To add a number x:\\n        If x <= left[0], add to left. Else, add to right.\\n        If abs(len(left) - len(right)) > 1: rebalance heaps.\\n        \\n    To rebalance:\\n        Pop an element from the bigger heap and add it to the smaller heap.\\n        \\n    Adding a number: O(log n) time, as there could be at most 2 pushes and 1 pop (log n).\\n    Finding the median: O(1), since we just look at the 0th elements of the heaps.\\n    Space: O(n), since we store every element in the heaps.\\n    \\'\\'\\'\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        \\n        self.left = []\\n        self.right = []\\n        \\n\\n    def addNum(self, num: int) -> None:\\n        if not self.left or num <= -self.left[0]:\\n            heapq.heappush(self.left, -num) # we use negative numbers to make it a max heap, default python heap is a min heap\\n        else:\\n            heapq.heappush(self.right, num)\\n            \\n        # rebalance here\\n        if abs(len(self.left) - len(self.right)) > 1:\\n            if len(self.left) > len(self.right):\\n                elt = -heapq.heappop(self.left) # negate to get it back to original number\\n                heapq.heappush(self.right, elt)\\n            else:\\n                elt = heapq.heappop(self.right)\\n                heapq.heappush(self.left, -elt) # negate due to max heap\\n\\n\\n    def findMedian(self) -> float:\\n        \\n        # remember to negate the left values!\\n        \\n        if len(self.left) == len(self.right):\\n            return (-self.left[0] + self.right[0]) / 2\\n        elif len(self.left) > len(self.right):\\n            return -self.left[0]\\n        else:\\n            return self.right[0]\\n        \\n\\n\\n# Your MedianFinder object will be instantiated and called as such:\\n# obj = MedianFinder()\\n# obj.addNum(num)\\n# param_2 = obj.findMedian()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\n\\nclass MedianFinder:\\n    \\n    \\'\\'\\'\\n    We have a max heap representing the sorted left half of the stream, and a min heap representing the sorted right half of the stream.\\n    The tops of these heaps represent the middle of the stream so far.\\n    \\n    To get the median:\\n        - if len(left) == len(right): return (left[0] + right[0]) / 2\\n        - elif len(left) > len(right): return left[0]\\n        - else: return right[0]\\n        \\n    To add a number x:\\n        If x <= left[0], add to left. Else, add to right.\\n        If abs(len(left) - len(right)) > 1: rebalance heaps.\\n        \\n    To rebalance:\\n        Pop an element from the bigger heap and add it to the smaller heap.\\n        \\n    Adding a number: O(log n) time, as there could be at most 2 pushes and 1 pop (log n).\\n    Finding the median: O(1), since we just look at the 0th elements of the heaps.\\n    Space: O(n), since we store every element in the heaps.\\n    \\'\\'\\'\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        \\n        self.left = []\\n        self.right = []\\n        \\n\\n    def addNum(self, num: int) -> None:\\n        if not self.left or num <= -self.left[0]:\\n            heapq.heappush(self.left, -num) # we use negative numbers to make it a max heap, default python heap is a min heap\\n        else:\\n            heapq.heappush(self.right, num)\\n            \\n        # rebalance here\\n        if abs(len(self.left) - len(self.right)) > 1:\\n            if len(self.left) > len(self.right):\\n                elt = -heapq.heappop(self.left) # negate to get it back to original number\\n                heapq.heappush(self.right, elt)\\n            else:\\n                elt = heapq.heappop(self.right)\\n                heapq.heappush(self.left, -elt) # negate due to max heap\\n\\n\\n    def findMedian(self) -> float:\\n        \\n        # remember to negate the left values!\\n        \\n        if len(self.left) == len(self.right):\\n            return (-self.left[0] + self.right[0]) / 2\\n        elif len(self.left) > len(self.right):\\n            return -self.left[0]\\n        else:\\n            return self.right[0]\\n        \\n\\n\\n# Your MedianFinder object will be instantiated and called as such:\\n# obj = MedianFinder()\\n# obj.addNum(num)\\n# param_2 = obj.findMedian()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278272,
                "title": "python-two-heaps",
                "content": "**Explanation**:\\n`odd = true` is we have odd numbers.\\n`med` is the current median\\n\\n**Time Complexity**:\\n`addNum` function `O(logN)`\\n`findMedian` function `O(1)`\\n\\n**Python:**\\n```\\nclass MedianFinder(object):\\n\\n    def __init__(self):\\n        self.med, self.odd, self.heaps = 0, 0, [[], []]\\n\\n    def addNum(self, x):\\n        big, small = self.heaps\\n        if self.odd:\\n            heapq.heappush(big, max(x, self.med))\\n            heapq.heappush(small, -min(x, self.med))\\n            self.med = (big[0] - small[0]) / 2.0\\n        else:\\n            if x > self.med:\\n                self.med = heapq.heappushpop(big, x)\\n            else:\\n                self.med = -heapq.heappushpop(small, -x)\\n        self.odd ^= 1\\n\\n    def findMedian(self):\\n        return self.med\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass MedianFinder(object):\\n\\n    def __init__(self):\\n        self.med, self.odd, self.heaps = 0, 0, [[], []]\\n\\n    def addNum(self, x):\\n        big, small = self.heaps\\n        if self.odd:\\n            heapq.heappush(big, max(x, self.med))\\n            heapq.heappush(small, -min(x, self.med))\\n            self.med = (big[0] - small[0]) / 2.0\\n        else:\\n            if x > self.med:\\n                self.med = heapq.heappushpop(big, x)\\n            else:\\n                self.med = -heapq.heappushpop(small, -x)\\n        self.odd ^= 1\\n\\n    def findMedian(self):\\n        return self.med\\n```",
                "codeTag": "Java"
            },
            {
                "id": 74147,
                "title": "concise-21-line-c-by-using-2-sorted-sets",
                "content": "    public class MedianFinder {\\n        private int counter = 0;\\n        private SortedSet<int[]> setLow = new SortedSet<int[]>(Comparer<int[]>.Create((a, b) => a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]));\\n        private SortedSet<int[]> setHigh = new SortedSet<int[]>(Comparer<int[]>.Create((a, b) => a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]));\\n        public void AddNum(int num) {\\n            int[] newNum = new int[2]{num, counter++};\\n            if(setLow.Count == setHigh.Count){\\n                if(setLow.Count == 0 || newNum[0] <= setLow.Max[0]) setLow.Add(newNum);\\n                else{\\n                    setHigh.Add(newNum);\\n                    setLow.Add(setHigh.Min);\\n                    setHigh.Remove(setHigh.Min);\\n                }\\n            }\\n            else if(newNum[0] <= setLow.Max[0]){\\n                setLow.Add(newNum);\\n                setHigh.Add(setLow.Max);\\n                setLow.Remove(setLow.Max);\\n            }\\n            else setHigh.Add(newNum);\\n        }\\n        // return the median of current data stream\\n        public double FindMedian() {\\n            if(setLow.Count == 0) return 0;\\n            if(setLow.Count == setHigh.Count) return (setLow.Max[0] + setHigh.Min[0]) / 2d;\\n            else return setLow.Max[0];\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public class MedianFinder {\\n        private int counter = 0;\\n        private SortedSet<int[]> setLow = new SortedSet<int[]>(Comparer<int[]>.Create((a, b) => a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]));\\n        private SortedSet<int[]> setHigh = new SortedSet<int[]>(Comparer<int[]>.Create((a, b) => a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]));\\n        public void AddNum(int num) {\\n            int[] newNum = new int[2]{num, counter++};\\n            if(setLow.Count == setHigh.Count){\\n                if(setLow.Count == 0 || newNum[0] <= setLow.Max[0]) setLow.Add(newNum);\\n                else{\\n                    setHigh.Add(newNum);\\n                    setLow.Add(setHigh.Min);\\n                    setHigh.Remove(setHigh.Min);\\n                }\\n            }\\n            else if(newNum[0] <= setLow.Max[0]){\\n                setLow.Add(newNum);\\n                setHigh.Add(setLow.Max);\\n                setLow.Remove(setLow.Max);\\n            }\\n            else setHigh.Add(newNum);\\n        }\\n        // return the median of current data stream\\n        public double FindMedian() {\\n            if(setLow.Count == 0) return 0;\\n            if(setLow.Count == setHigh.Count) return (setLow.Max[0] + setHigh.Min[0]) / 2d;\\n            else return setLow.Max[0];\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2806024,
                "title": "c-two-approaches-using-vector-min-and-max-heap",
                "content": "**Approach 1: (Using Vector) TLE**\\n```\\nclass MedianFinder {\\npublic:\\n    vector<double> arr;\\n    MedianFinder() {\\n        \\n    }\\n    \\n    void addNum(int num) {\\n        arr.push_back(num);\\n    }\\n    \\n    double findMedian() {\\n        sort(arr.begin(),arr.end());\\n        int n = arr.size();\\n        if(n%2 == 0){\\n            double ans = (arr[(n/2)-1]+arr[n/2])/2;\\n            return ans;\\n        }\\n        return arr[n/2];\\n    }\\n};\\n\\n```\\n**Approach 2: (Max-Min Heap) \\u2705**\\n```\\nclass MedianFinder {\\npublic:\\n    priority_queue<int> max_heap;\\n    priority_queue<int,vector<int>,greater<int>> min_heap;\\n    \\n    MedianFinder() {\\n        \\n    }\\n    \\n    void addNum(int num) {\\n        if(max_heap.size() > 0 && num > max_heap.top())\\n        {\\n            min_heap.push(num);\\n        }\\n        else\\n        {\\n            max_heap.push(num);\\n        }\\n        if(max_heap.size() > min_heap.size()+1)\\n        {\\n            min_heap.push(max_heap.top());\\n            max_heap.pop();\\n        }\\n        if(min_heap.size() > max_heap.size()+1)\\n        {\\n            max_heap.push(min_heap.top());\\n            min_heap.pop();\\n        }\\n    }\\n    \\n    double findMedian() {\\n        if(max_heap.size() == min_heap.size())\\n        {\\n            return (max_heap.top()+min_heap.top())/2.0;\\n        }\\n        if(max_heap.size() > min_heap.size())\\n        {\\n            return max_heap.top();\\n        }\\n        else\\n        {\\n            return min_heap.top();\\n        }\\n    }\\n};\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder* obj = new MedianFinder();\\n * obj->addNum(num);\\n * double param_2 = obj->findMedian();\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass MedianFinder {\\npublic:\\n    vector<double> arr;\\n    MedianFinder() {\\n        \\n    }\\n    \\n    void addNum(int num) {\\n        arr.push_back(num);\\n    }\\n    \\n    double findMedian() {\\n        sort(arr.begin(),arr.end());\\n        int n = arr.size();\\n        if(n%2 == 0){\\n            double ans = (arr[(n/2)-1]+arr[n/2])/2;\\n            return ans;\\n        }\\n        return arr[n/2];\\n    }\\n};\\n\\n```\n```\\nclass MedianFinder {\\npublic:\\n    priority_queue<int> max_heap;\\n    priority_queue<int,vector<int>,greater<int>> min_heap;\\n    \\n    MedianFinder() {\\n        \\n    }\\n    \\n    void addNum(int num) {\\n        if(max_heap.size() > 0 && num > max_heap.top())\\n        {\\n            min_heap.push(num);\\n        }\\n        else\\n        {\\n            max_heap.push(num);\\n        }\\n        if(max_heap.size() > min_heap.size()+1)\\n        {\\n            min_heap.push(max_heap.top());\\n            max_heap.pop();\\n        }\\n        if(min_heap.size() > max_heap.size()+1)\\n        {\\n            max_heap.push(min_heap.top());\\n            min_heap.pop();\\n        }\\n    }\\n    \\n    double findMedian() {\\n        if(max_heap.size() == min_heap.size())\\n        {\\n            return (max_heap.top()+min_heap.top())/2.0;\\n        }\\n        if(max_heap.size() > min_heap.size())\\n        {\\n            return max_heap.top();\\n        }\\n        else\\n        {\\n            return min_heap.top();\\n        }\\n    }\\n};\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder* obj = new MedianFinder();\\n * obj->addNum(num);\\n * double param_2 = obj->findMedian();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 411354,
                "title": "two-heap-approach-with-python-o-log-n-insert-o-1-median",
                "content": "```\\n\"\"\"\\naddNum\\nRuntime: O(log n)\\nSpacetime: O(n)\\n\\nfindMedian\\nRuntime: O(1)\\nSpacetime: O(1)\\n\"\"\"\\nfrom heapq import *\\n\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.min_heap: List[int] = []\\n        self.max_heap: List[int] = []\\n        \\n\\n    def addNum(self, num: int) -> None:\\n        heappush(self.max_heap, -heappushpop(self.min_heap, num))\\n        \\n        if len(self.max_heap) > len(self.min_heap):\\n            heappush(self.min_heap, -heappop(self.max_heap))\\n        \\n\\n    def findMedian(self) -> float:\\n        has_even_count = len(self.max_heap) == len(self.min_heap)\\n\\n        if has_even_count:\\n            return (-self.max_heap[0] + self.min_heap[0]) / 2.0\\n        return float(self.min_heap[0])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\"\"\"\\naddNum\\nRuntime: O(log n)\\nSpacetime: O(n)\\n\\nfindMedian\\nRuntime: O(1)\\nSpacetime: O(1)\\n\"\"\"\\nfrom heapq import *\\n\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.min_heap: List[int] = []\\n        self.max_heap: List[int] = []\\n        \\n\\n    def addNum(self, num: int) -> None:\\n        heappush(self.max_heap, -heappushpop(self.min_heap, num))\\n        \\n        if len(self.max_heap) > len(self.min_heap):\\n            heappush(self.min_heap, -heappop(self.max_heap))\\n        \\n\\n    def findMedian(self) -> float:\\n        has_even_count = len(self.max_heap) == len(self.min_heap)\\n\\n        if has_even_count:\\n            return (-self.max_heap[0] + self.min_heap[0]) / 2.0\\n        return float(self.min_heap[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 129248,
                "title": "heap-thinking-process",
                "content": "Median is the middle value in an ordered integer list, so median will halve the list into `a bigger half and a smaller half` (When the size of list is not even, we can put the middle value in either half).\\n* If the size of the list is even, median is the mean of the two middle value, i.e., `the MEAN of the minimum of the bigger half AND the maximum of the smaller half`. \\n* If the size of the list is odd, median is `the maximum of the smaller half OR the maximum of the smaller half`.\\n\\n**Heap** is designed for the case that we need to repeatly do minimum or  maximum calculation.\\n\\nSo we maintain an invariant that smaller half is in maxHeap, and bigger half is in minHeap. This requires at any time:\\n* maximum of maxHeap < minimum of minHeap\\n* size of maxHeap and minHeap can differ at most 1\\n\\n****\\n```\\nclass MedianFinder {\\n    \\n    private PriorityQueue<Integer> maxHeap; // Smaller half.\\n    private PriorityQueue<Integer> minHeap; // Bigger half.\\n\\n    /** initialize your data structure here. */\\n    public MedianFinder() {\\n        maxHeap = new PriorityQueue<>((a, b) -> Integer.compare(b, a));\\n        minHeap = new PriorityQueue<>();\\n    }\\n    \\n    public void addNum(int num) {\\n        // Maintains the invariant that smaller half is in maxHeap, and bigger half is in minHeap\\n        if (maxHeap.isEmpty() || num <= maxHeap.peek()) { // num belongs to smaller half\\n            maxHeap.offer(num);\\n            if (maxHeap.size() > minHeap.size() + 1) {\\n                minHeap.offer(maxHeap.poll());\\n            }\\n        } else { // num belongs to bigger half\\n            minHeap.offer(num);\\n            if (minHeap.size() > maxHeap.size() + 1) {\\n                maxHeap.offer(minHeap.poll());\\n            }\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        if (minHeap.size() > maxHeap.size()) {\\n            return (double) minHeap.peek();\\n        } else if (minHeap.size() < maxHeap.size()) {\\n            return (double) maxHeap.peek();\\n        } else {\\n            return (minHeap.peek() + maxHeap.peek()) / 2.0;\\n        }\\n    }\\n}\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\nclass MedianFinder {\\n    \\n    private PriorityQueue<Integer> maxHeap; // Smaller half.\\n    private PriorityQueue<Integer> minHeap; // Bigger half.\\n\\n    /** initialize your data structure here. */\\n    public MedianFinder() {\\n        maxHeap = new PriorityQueue<>((a, b) -> Integer.compare(b, a));\\n        minHeap = new PriorityQueue<>();\\n    }\\n    \\n    public void addNum(int num) {\\n        // Maintains the invariant that smaller half is in maxHeap, and bigger half is in minHeap\\n        if (maxHeap.isEmpty() || num <= maxHeap.peek()) { // num belongs to smaller half\\n            maxHeap.offer(num);\\n            if (maxHeap.size() > minHeap.size() + 1) {\\n                minHeap.offer(maxHeap.poll());\\n            }\\n        } else { // num belongs to bigger half\\n            minHeap.offer(num);\\n            if (minHeap.size() > maxHeap.size() + 1) {\\n                maxHeap.offer(minHeap.poll());\\n            }\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        if (minHeap.size() > maxHeap.size()) {\\n            return (double) minHeap.peek();\\n        } else if (minHeap.size() < maxHeap.size()) {\\n            return (double) maxHeap.peek();\\n        } else {\\n            return (minHeap.peek() + maxHeap.peek()) / 2.0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 74077,
                "title": "32ms-easy-to-understand-java-solution",
                "content": "    class MedianFinder {\\n    private Queue<Integer> maxHeap = new PriorityQueue(new Comparator<Integer>(){\\n       @Override\\n       public int compare(Integer i1, Integer i2){\\n           return Integer.compare(i2, i1);\\n       }\\n    });\\n    private Queue<Integer> minHeap = new PriorityQueue(new Comparator<Integer>(){\\n       @Override\\n       public int compare(Integer i1, Integer i2){\\n           return Integer.compare(i1, i2);\\n       }\\n    });\\n    \\n    // Adds a number into the data structure.\\n    public void addNum(int num) {\\n        minHeap.offer(num);\\n        maxHeap.offer(minHeap.poll());\\n        \\n        //if(maxHeap.size() > minHeap.size())\\n        if(maxHeap.size() - minHeap.size() == 1){\\n            minHeap.offer(maxHeap.poll());\\n        }\\n    }\\n\\n    // Returns the median of current data stream\\n    public double findMedian() {\\n        return minHeap.size() > maxHeap.size()\\n             ? (double)minHeap.peek()\\n             : (minHeap.peek() + maxHeap.peek())/2.0;\\n    }\\n};",
                "solutionTags": [],
                "code": "    class MedianFinder {\\n    private Queue<Integer> maxHeap = new PriorityQueue(new Comparator<Integer>(){\\n       @Override\\n       public int compare(Integer i1, Integer i2){\\n           return Integer.compare(i2, i1);\\n       }\\n    });\\n    private Queue<Integer> minHeap = new PriorityQueue(new Comparator<Integer>(){\\n       @Override\\n       public int compare(Integer i1, Integer i2){\\n           return Integer.compare(i1, i2);\\n       }\\n    });\\n    \\n    // Adds a number into the data structure.\\n    public void addNum(int num) {\\n        minHeap.offer(num);\\n        maxHeap.offer(minHeap.poll());\\n        \\n        //if(maxHeap.size() > minHeap.size())\\n        if(maxHeap.size() - minHeap.size() == 1){\\n            minHeap.offer(maxHeap.poll());\\n        }\\n    }\\n\\n    // Returns the median of current data stream\\n    public double findMedian() {\\n        return minHeap.size() > maxHeap.size()\\n             ? (double)minHeap.peek()\\n             : (minHeap.peek() + maxHeap.peek())/2.0;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2489443,
                "title": "c-easy-minheap-maxheap-hindi-comments",
                "content": "```\\nclass MedianFinder {\\nprivate:\\n    priority_queue<int> maxpart;                           //isme sab choto ka descending order rehta\\n    priority_queue<int, vector<int>, greater<int>> minpart;    //isme sab bade bhaiyo ka ascending order rehta\\npublic:\\n    MedianFinder() {\\n        \\n    }\\n    \\n    void addNum(int num) {         \\n        maxpart.push(num);              // maxpart mey num jaata, waha sort hojata. \\n        minpart.push(maxpart.top());    //Phir, maxpart ke top (largest) ku min part mey daalrai\\n        maxpart.pop();                  //bade bhai ku maxpart se nikaaldo    -> min mey neeche chalejaata \\n        if(maxpart.size() < minpart.size()){     //agar bade bhailog zyada hogaye minpart mey \\n            maxpart.push(minpart.top());        //toh unmese sabse chote bade bhai ku choto mey daaldo\\n            minpart.pop();                      //nikaaldo usku phir\\n        }\\n    }\\n    \\n    double findMedian() {\\n        if(maxpart.size() > minpart.size()) //odd number length hai toh hota, aur humesha maxpart(chote\\'s desc.order) ku bada rakhrai\\n            return maxpart.top();   //odd length aaya toh odd one out apne choto mey se rehta, unka sabse bada wala apna banda \\n        return (maxpart.top()+minpart.top())/2.0;    //even length aaya toh, choto ke bade aur bado ke chote ka avg hai ans\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass MedianFinder {\\nprivate:\\n    priority_queue<int> maxpart;                           //isme sab choto ka descending order rehta\\n    priority_queue<int, vector<int>, greater<int>> minpart;    //isme sab bade bhaiyo ka ascending order rehta\\npublic:\\n    MedianFinder() {\\n        \\n    }\\n    \\n    void addNum(int num) {         \\n        maxpart.push(num);              // maxpart mey num jaata, waha sort hojata. \\n        minpart.push(maxpart.top());    //Phir, maxpart ke top (largest) ku min part mey daalrai\\n        maxpart.pop();                  //bade bhai ku maxpart se nikaaldo    -> min mey neeche chalejaata \\n        if(maxpart.size() < minpart.size()){     //agar bade bhailog zyada hogaye minpart mey \\n            maxpart.push(minpart.top());        //toh unmese sabse chote bade bhai ku choto mey daaldo\\n            minpart.pop();                      //nikaaldo usku phir\\n        }\\n    }\\n    \\n    double findMedian() {\\n        if(maxpart.size() > minpart.size()) //odd number length hai toh hota, aur humesha maxpart(chote\\'s desc.order) ku bada rakhrai\\n            return maxpart.top();   //odd length aaya toh odd one out apne choto mey se rehta, unka sabse bada wala apna banda \\n        return (maxpart.top()+minpart.top())/2.0;    //even length aaya toh, choto ke bade aur bado ke chote ka avg hai ans\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227658,
                "title": "c-explained-in-detail-heaps-priority-queue-o-logn",
                "content": "```\\n/* \\nHarshit Gupta | 24th May, 2021\\n\\nC++ program for finding median in a running stream of integers.\\n\\nhttps://leetcode.com/problems/find-median-from-data-stream/\\n\\nSolution: \\n    a.  Create two heaps. One max heap to maintain elements of lower half \\n        and one min heap to maintain elements of higher half at any point of time.\\n    b.  Take initial value of median as 0.\\n    c.  For every newly read element, insert it into either max heap or min heap \\n        and then calulate the median based on the following conditions:\\n        - If the size of max heap is greater than size of min heap and the \\n            element is less than previous median then pop the top element from \\n            max heap and insert into min heap and insert the new element to max \\n            heap else insert the new element to min heap. Calculate the new median \\n            as average of top of elements of both max and min heap.\\n        - If the size of max heap is less than size of min heap and the element \\n            is greater than previous median then pop the top element from min heap \\n            and insert into max heap and insert the new element to min heap else \\n            insert the new element to max heap. Calculate the new median as average \\n            of top of elements of both max and min heap.\\n        - If the size of both heaps are same. Then check if current is less than \\n            previous median or not. If the current element is less than previous \\n            median then insert it to max heap and new median will be equal to top \\n            element of max heap. If the current element is greater than previous \\n            median then insert it to min heap and new median will be equal to top \\n            element of min heap.\\n\\nParadigm: Priority Queues, Heaps.\\n\\nTime Complexity: O(nlogn) to balance the heaps/heapify.\\n\\n*/\\n\\n\\n\\nclass MedianFinder {\\npublic:\\n    // max heap to store the smaller half elements\\n    priority_queue<int> max_heap;\\n    \\n    // min heap to store the greater half elements \\n    priority_queue<int, vector<int>, greater<int>> min_heap;\\n    \\n    // Variable which will contain the median value at all instance of time.\\n    // We can return it in O(1) time.\\n    double median;\\n    \\n    MedianFinder() {\\n        // initializing the median to 0\\n        median = 0;\\n    }\\n    \\n    void addNum(int num) {\\n        \\n        // Case 1: Left side heap has more elements\\n        // Pushing an element would have EVEN number of elements in total, \\n        // so median is average of top of min and max heaps\\n        \\n        // If the size of max heap(s) is greater than the min heap(g)\\n        if(max_heap.size() > min_heap.size()) {\\n            \\n            // And the element is lesser than the median, then it has to be inserted in the max heap\\n            // But if directly inserted it will create imbalance in both heaps, \\n            // so the maximum(top) of max heap(s) is moved to the min heap(g)\\n            // and then the element is inserted to the max heap.\\n            if(num < median) {\\n                // Insert the top of max heap to min heap\\n                min_heap.push(max_heap.top());\\n                // Remove the top element of the max heap.\\n                max_heap.pop();\\n                // Insert the new element in the min heap\\n                max_heap.push(num);\\n            }\\n            // And the element is greater then the current median\\n            else{\\n                // Push it in the min heap. Now both heaps has equal elements.\\n                min_heap.push(num);\\n            }\\n            \\n            median = (double)(min_heap.top() + max_heap.top()) / 2.0;\\n        }\\n        \\n        // Case 2: Right side heap has more elements.\\n        // Pushing an element would have EVEN number of elements in total, \\n        // so median is average of top of min and max heaps\\n        \\n        // If the size of max heap(s) is lesser than the min heap(g). \\n        else if (max_heap.size() < min_heap.size()){\\n            \\n            // And the element is greater than the median, then it has to be inserted in the min heap\\n            // But if directly inserted it will create imbalance in both heaps, \\n            // so the minimum(top) of min heap(g) is moved to the max heap(s)\\n            // and then the element is inserted to the min heap.\\n            if(num > median){\\n                // Insert the top of min heap to the max heap.\\n                max_heap.push(min_heap.top());\\n                // Remove the top element of min heap since it is already inserted in the max heap\\n                min_heap.pop();\\n                // Insert the new element in the max heap.\\n                min_heap.push(num);\\n            }\\n            // And the element is less than the current median\\n            else{\\n                // Push it in the max heap. Now both heaps has equal elements.\\n                max_heap.push(num);\\n            }\\n            \\n            median = (double)(min_heap.top() + max_heap.top()) / 2.0;\\n        }\\n        \\n        // Case 3: Both heaps have equal elements and are balanced.\\n        // If both the heaps has equal elements, then inserting this element \\n        // would make the heaps have \\'ODD\\' number of elements and thus the median now\\n        // would be only one number and not average of two numbers.\\n        else {\\n            // If the element is less than the current median, it is inserted in the max heap\\n            // and now since max heap has more elements, the top of max heap would be the median.\\n            if( num < median){\\n                max_heap.push(num);\\n                median = (double)max_heap.top();\\n            }\\n            // If the element is greater than the current median, it is inserted in the min heap\\n            // and now since min heap has more elements, the top of min heap would be the median.\\n            else{\\n                min_heap.push(num);\\n                median = (double)min_heap.top();\\n            }\\n        }\\n        \\n    }\\n    \\n    double findMedian() {\\n        return median;\\n    }\\n};\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder* obj = new MedianFinder();\\n * obj->addNum(num);\\n * double param_2 = obj->findMedian();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/* \\nHarshit Gupta | 24th May, 2021\\n\\nC++ program for finding median in a running stream of integers.\\n\\nhttps://leetcode.com/problems/find-median-from-data-stream/\\n\\nSolution: \\n    a.  Create two heaps. One max heap to maintain elements of lower half \\n        and one min heap to maintain elements of higher half at any point of time.\\n    b.  Take initial value of median as 0.\\n    c.  For every newly read element, insert it into either max heap or min heap \\n        and then calulate the median based on the following conditions:\\n        - If the size of max heap is greater than size of min heap and the \\n            element is less than previous median then pop the top element from \\n            max heap and insert into min heap and insert the new element to max \\n            heap else insert the new element to min heap. Calculate the new median \\n            as average of top of elements of both max and min heap.\\n        - If the size of max heap is less than size of min heap and the element \\n            is greater than previous median then pop the top element from min heap \\n            and insert into max heap and insert the new element to min heap else \\n            insert the new element to max heap. Calculate the new median as average \\n            of top of elements of both max and min heap.\\n        - If the size of both heaps are same. Then check if current is less than \\n            previous median or not. If the current element is less than previous \\n            median then insert it to max heap and new median will be equal to top \\n            element of max heap. If the current element is greater than previous \\n            median then insert it to min heap and new median will be equal to top \\n            element of min heap.\\n\\nParadigm: Priority Queues, Heaps.\\n\\nTime Complexity: O(nlogn) to balance the heaps/heapify.\\n\\n*/\\n\\n\\n\\nclass MedianFinder {\\npublic:\\n    // max heap to store the smaller half elements\\n    priority_queue<int> max_heap;\\n    \\n    // min heap to store the greater half elements \\n    priority_queue<int, vector<int>, greater<int>> min_heap;\\n    \\n    // Variable which will contain the median value at all instance of time.\\n    // We can return it in O(1) time.\\n    double median;\\n    \\n    MedianFinder() {\\n        // initializing the median to 0\\n        median = 0;\\n    }\\n    \\n    void addNum(int num) {\\n        \\n        // Case 1: Left side heap has more elements\\n        // Pushing an element would have EVEN number of elements in total, \\n        // so median is average of top of min and max heaps\\n        \\n        // If the size of max heap(s) is greater than the min heap(g)\\n        if(max_heap.size() > min_heap.size()) {\\n            \\n            // And the element is lesser than the median, then it has to be inserted in the max heap\\n            // But if directly inserted it will create imbalance in both heaps, \\n            // so the maximum(top) of max heap(s) is moved to the min heap(g)\\n            // and then the element is inserted to the max heap.\\n            if(num < median) {\\n                // Insert the top of max heap to min heap\\n                min_heap.push(max_heap.top());\\n                // Remove the top element of the max heap.\\n                max_heap.pop();\\n                // Insert the new element in the min heap\\n                max_heap.push(num);\\n            }\\n            // And the element is greater then the current median\\n            else{\\n                // Push it in the min heap. Now both heaps has equal elements.\\n                min_heap.push(num);\\n            }\\n            \\n            median = (double)(min_heap.top() + max_heap.top()) / 2.0;\\n        }\\n        \\n        // Case 2: Right side heap has more elements.\\n        // Pushing an element would have EVEN number of elements in total, \\n        // so median is average of top of min and max heaps\\n        \\n        // If the size of max heap(s) is lesser than the min heap(g). \\n        else if (max_heap.size() < min_heap.size()){\\n            \\n            // And the element is greater than the median, then it has to be inserted in the min heap\\n            // But if directly inserted it will create imbalance in both heaps, \\n            // so the minimum(top) of min heap(g) is moved to the max heap(s)\\n            // and then the element is inserted to the min heap.\\n            if(num > median){\\n                // Insert the top of min heap to the max heap.\\n                max_heap.push(min_heap.top());\\n                // Remove the top element of min heap since it is already inserted in the max heap\\n                min_heap.pop();\\n                // Insert the new element in the max heap.\\n                min_heap.push(num);\\n            }\\n            // And the element is less than the current median\\n            else{\\n                // Push it in the max heap. Now both heaps has equal elements.\\n                max_heap.push(num);\\n            }\\n            \\n            median = (double)(min_heap.top() + max_heap.top()) / 2.0;\\n        }\\n        \\n        // Case 3: Both heaps have equal elements and are balanced.\\n        // If both the heaps has equal elements, then inserting this element \\n        // would make the heaps have \\'ODD\\' number of elements and thus the median now\\n        // would be only one number and not average of two numbers.\\n        else {\\n            // If the element is less than the current median, it is inserted in the max heap\\n            // and now since max heap has more elements, the top of max heap would be the median.\\n            if( num < median){\\n                max_heap.push(num);\\n                median = (double)max_heap.top();\\n            }\\n            // If the element is greater than the current median, it is inserted in the min heap\\n            // and now since min heap has more elements, the top of min heap would be the median.\\n            else{\\n                min_heap.push(num);\\n                median = (double)min_heap.top();\\n            }\\n        }\\n        \\n    }\\n    \\n    double findMedian() {\\n        return median;\\n    }\\n};\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder* obj = new MedianFinder();\\n * obj->addNum(num);\\n * double param_2 = obj->findMedian();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343226,
                "title": "python-simple-solutions",
                "content": "Insertion Sort using binary search\\n```python\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.nums = []\\n        \\n    def addNum(self, num: int) -> None:\\n        if not self.nums:\\n            self.nums.append(num)\\n            return \\n        l = 0\\n        r = len(self.nums)-1\\n        while l < r:\\n            m = (l+r)//2\\n            if self.nums[m] == num:\\n                self.nums.insert(m,num)\\n                return \\n            elif self.nums[m] < num:\\n                l = m+1\\n            else:\\n                r = m-1      \\n        if self.nums[l] < num:\\n            self.nums.insert(l+1,num)\\n        else:\\n            self.nums.insert(l,num)\\n\\n    def findMedian(self) -> float:\\n        mid = (0 + len(self.nums)-1 )//2\\n        if (len(self.nums)-1) & 1:\\n            return (self.nums[mid] + self.nums[mid+1])/2\\n        else:\\n            return self.nums[mid]\\n```\\nTwo Heaps\\uFF1A\\nThe length of smaller half is kept to be n / 2 at all time and the length of the larger half is either n / 2 or n / 2 + 1 depend on n\\'s parity.\\n```python\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        import heapq\\n        self.small = [] # maxheap\\n        self.large = [] # minheap\\n        \\n    def addNum(self, num: int) -> None:\\n        if len(self.small) == len(self.large):\\n            heapq.heappush(self.small,-num)\\n            tmp = heapq.heappop(self.small)\\n            heapq.heappush(self.large,-tmp)\\n        else:\\n            heapq.heappush(self.large,num)\\n            tmp = heapq.heappop(self.large)\\n            heapq.heappush(self.small,-tmp)\\n                \\n                \\n    def findMedian(self) -> float:\\n        if len(self.small) == len(self.large):\\n            return (-self.small[0] + self.large[0])/2\\n        else:\\n            return self.large[0]\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.nums = []\\n        \\n    def addNum(self, num: int) -> None:\\n        if not self.nums:\\n            self.nums.append(num)\\n            return \\n        l = 0\\n        r = len(self.nums)-1\\n        while l < r:\\n            m = (l+r)//2\\n            if self.nums[m] == num:\\n                self.nums.insert(m,num)\\n                return \\n            elif self.nums[m] < num:\\n                l = m+1\\n            else:\\n                r = m-1      \\n        if self.nums[l] < num:\\n            self.nums.insert(l+1,num)\\n        else:\\n            self.nums.insert(l,num)\\n\\n    def findMedian(self) -> float:\\n        mid = (0 + len(self.nums)-1 )//2\\n        if (len(self.nums)-1) & 1:\\n            return (self.nums[mid] + self.nums[mid+1])/2\\n        else:\\n            return self.nums[mid]\\n```\n```python\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        import heapq\\n        self.small = [] # maxheap\\n        self.large = [] # minheap\\n        \\n    def addNum(self, num: int) -> None:\\n        if len(self.small) == len(self.large):\\n            heapq.heappush(self.small,-num)\\n            tmp = heapq.heappop(self.small)\\n            heapq.heappush(self.large,-tmp)\\n        else:\\n            heapq.heappush(self.large,num)\\n            tmp = heapq.heappop(self.large)\\n            heapq.heappush(self.small,-tmp)\\n                \\n                \\n    def findMedian(self) -> float:\\n        if len(self.small) == len(self.large):\\n            return (-self.small[0] + self.large[0])/2\\n        else:\\n            return self.large[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 313652,
                "title": "javascript-o-log-n-o-1-binarysearch-minheap",
                "content": "```\\n/**\\n * initialize your data structure here.\\n */\\nvar MedianFinder = function() {\\n    this.arr = [];\\n};\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nMedianFinder.prototype.addNum = function(num) {\\n    const bs = n => {\\n        let start = 0;\\n        let end = this.arr.length;\\n        while (start < end){\\n            let mid = Math.floor((start+end)/2);\\n            if (n > this.arr[mid]) start = mid+1;\\n            else end = mid;\\n        }\\n        this.arr.splice(start,0,n);\\n    }\\n    if (this.arr.length === 0) this.arr.push(num);\\n    else bs(num);\\n};\\n\\n/**\\n * @return {number}\\n */\\nMedianFinder.prototype.findMedian = function() {\\n    const mid = Math.floor(this.arr.length/2);\\n    return (this.arr.length%2===0) ? (this.arr[mid-1]+this.arr[mid])/2 : this.arr[mid];\\n};\\n\\n/** \\n * Your MedianFinder object will be instantiated and called as such:\\n * var obj = new MedianFinder()\\n * obj.addNum(num)\\n * var param_2 = obj.findMedian()\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * initialize your data structure here.\\n */\\nvar MedianFinder = function() {\\n    this.arr = [];\\n};\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nMedianFinder.prototype.addNum = function(num) {\\n    const bs = n => {\\n        let start = 0;\\n        let end = this.arr.length;\\n        while (start < end){\\n            let mid = Math.floor((start+end)/2);\\n            if (n > this.arr[mid]) start = mid+1;\\n            else end = mid;\\n        }\\n        this.arr.splice(start,0,n);\\n    }\\n    if (this.arr.length === 0) this.arr.push(num);\\n    else bs(num);\\n};\\n\\n/**\\n * @return {number}\\n */\\nMedianFinder.prototype.findMedian = function() {\\n    const mid = Math.floor(this.arr.length/2);\\n    return (this.arr.length%2===0) ? (this.arr[mid-1]+this.arr[mid])/2 : this.arr[mid];\\n};\\n\\n/** \\n * Your MedianFinder object will be instantiated and called as such:\\n * var obj = new MedianFinder()\\n * obj.addNum(num)\\n * var param_2 = obj.findMedian()\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 74117,
                "title": "python-solution-using-binary-search",
                "content": "    class MedianFinder:\\n        def __init__(self):\\n            \"\"\"\\n            Initialize your data structure here.\\n            \"\"\"\\n            self.ref_array = []\\n            self.length = 0\\n            \\n        def addNum(self, num):\\n            \"\"\"\\n            Adds a num into the data structure.\\n            :type num: int\\n            :rtype: void\\n            \"\"\"\\n            # keep a sorted array\\n            # use binary search to find insertion index\\n            \\n            low = 0\\n            high = self.length - 1\\n            \\n            while low <= high:\\n                mid = (low+high)//2\\n                if self.ref_array[mid] >= num:\\n                    high = mid - 1\\n                else:\\n                    low = mid + 1\\n                    \\n            self.ref_array.insert(low,num)\\n            self.length += 1\\n                \\n    \\n        def findMedian(self):\\n            \"\"\"\\n            Returns the median of current data stream\\n            :rtype: float\\n            \"\"\"\\n            # as array is always sorted we can always use the same median property\\n            \\n            if self.length % 2 == 0:\\n                temp = self.length // 2\\n                return (self.ref_array[temp]+self.ref_array[temp-1])/2.0\\n            else:\\n                return self.ref_array[self.length // 2]",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "    class MedianFinder:\\n        def __init__(self):\\n            \"\"\"\\n            Initialize your data structure here.\\n            \"\"\"\\n            self.ref_array = []\\n            self.length = 0\\n            \\n        def addNum(self, num):\\n            \"\"\"\\n            Adds a num into the data structure.\\n            :type num: int\\n            :rtype: void\\n            \"\"\"\\n            # keep a sorted array\\n            # use binary search to find insertion index\\n            \\n            low = 0\\n            high = self.length - 1\\n            \\n            while low <= high:\\n                mid = (low+high)//2\\n                if self.ref_array[mid] >= num:\\n                    high = mid - 1\\n                else:\\n                    low = mid + 1\\n                    \\n            self.ref_array.insert(low,num)\\n            self.length += 1\\n                \\n    \\n        def findMedian(self):\\n            \"\"\"\\n            Returns the median of current data stream\\n            :rtype: float\\n            \"\"\"\\n            # as array is always sorted we can always use the same median property\\n            \\n            if self.length % 2 == 0:\\n                temp = self.length // 2\\n                return (self.ref_array[temp]+self.ref_array[temp-1])/2.0\\n            else:\\n                return self.ref_array[self.length // 2]",
                "codeTag": "Java"
            },
            {
                "id": 74071,
                "title": "22ms-java-solution-using-binary-tree-beats-99-82-of-submissions",
                "content": "**Some notes:** This solution uses an ordinary binary tree for simplicity's sake, which means it is likely to be unbalanced. Given enough time one may well use a balanced binary tree implementation to guarantee ```O(logn)``` runtime for ```addNum()```.  It is easy to see that ```findMedian()``` runs in ```O(1)```.\\n\\nBy using a binary tree, we can easily keep the input numbers in nondecreasing order. Observe that whenever a number is added, the numbers used to calculate the median never shift by more than 1 position (in an imagined array representation) to the left or to the right. Let's see an example:\\n```[2]```, number used to calculate median is ```2```.\\n```[2,3]```, numbers used are ```2,3``` (expanding 1 to right)\\n```[0,2,3]```, use ```2``` (shrinking 1 to left)\\n```[0,1,2,3]```, use ```1,2``` (expanding 1 to left)\\n```[0,1,2,3,4]```, use ```2``` (shrinking 1 to right)\\n....and so on.\\n\\nWith this observation, in ```MedianFinder``` I employ 2 variables ```medianLeft``` and ```medianRight``` to keep track of numbers we need to calculate the median. When ```size``` is odd, they point to the same node, otherwise they always point to 2 nodes which have predecessor/successor relationship. When adding a node, we just need to check the size of our ```MedianFinder``` tree, then depending on whether the new number is inserted to the left, inbetween, or to the right of our 2 median trackers, we will change ```medianLeft``` and ```medianRight``` to point to the correct nodes. Because the position never shifts more than 1, we can simply use ```predecessor()``` or ```successor()``` on the desired node to update it. Those 2 methods run in ```O(logn)``` when the tree is balanced, hence the ```O(logn)``` runtime of ```addNum()```.\\n\\nHope this helps!\\n\\n```\\npublic class MedianFinder {\\n    private Node root;\\n    private Node medianLeft;\\n    private Node medianRight;\\n    private int size;\\n    \\n    public MedianFinder() {\\n    }\\n\\n    // Adds a number into the data structure.\\n    public void addNum(int num) {\\n        if (root == null) {\\n            root = new Node(num);\\n            medianLeft = root;\\n            medianRight = root;\\n        }\\n        else {\\n            root.addNode(num);\\n            if (size % 2 == 0) {\\n                if (num < medianLeft.data) {\\n                    medianRight = medianLeft;\\n                }\\n                else if (medianLeft.data <= num && num < medianRight.data) {\\n                    medianLeft = medianLeft.successor();\\n                    medianRight = medianRight.predecessor();\\n                }\\n                else if (medianRight.data <= num) {\\n                    medianLeft = medianRight;\\n                }\\n            }\\n            else {\\n                if (num < medianLeft.data) {\\n                    medianLeft = medianLeft.predecessor();\\n                }\\n                else {\\n                    medianRight = medianRight.successor();\\n                }\\n            }\\n        }\\n        size++;\\n    }\\n\\n    // Returns the median of current data stream\\n    public double findMedian() {\\n        return (medianLeft.data + medianRight.data) / 2.0;\\n    }\\n    \\n    class Node {\\n        private Node parent;\\n        private Node left;\\n        private Node right;\\n        private int data;\\n        \\n        public Node(int data) {\\n            this.data = data;\\n        }\\n        \\n        public void addNode(int data) {\\n            if (data >= this.data) {\\n              if (right == null) {\\n                right = new Node(data);\\n                right.parent = this;\\n              }\\n              else\\n                right.addNode(data);\\n            }\\n            else {\\n              if (left == null) {\\n                left = new Node(data);\\n                left.parent = this;\\n              }\\n              else\\n                left.addNode(data);\\n            }\\n        }\\n        \\n        public Node predecessor() {\\n            if (left != null)\\n                return left.rightMost();\\n            \\n            Node predecessor = parent;\\n            Node child = this;\\n            \\n            while (predecessor != null && child != predecessor.right) {\\n                child = predecessor;\\n                predecessor = predecessor.parent;\\n            }\\n            \\n            return predecessor;\\n        }\\n        \\n        public Node successor() {\\n            if (right != null)\\n                return right.leftMost();\\n            \\n            Node successor = parent;\\n            Node child = this;\\n            \\n            while (successor != null && child != successor.left) {\\n                child = successor;\\n                successor = successor.parent;\\n            }\\n            \\n            return successor;\\n        }\\n        \\n        public Node leftMost(){\\n            if (left == null)\\n                return this;\\n            return left.leftMost();\\n        }\\n        \\n        private Node rightMost() {\\n            if (right == null)\\n                return this;\\n            return right.rightMost();\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```O(logn)```\n```addNum()```\n```findMedian()```\n```O(1)```\n```[2]```\n```2```\n```[2,3]```\n```2,3```\n```[0,2,3]```\n```2```\n```[0,1,2,3]```\n```1,2```\n```[0,1,2,3,4]```\n```2```\n```MedianFinder```\n```medianLeft```\n```medianRight```\n```size```\n```MedianFinder```\n```medianLeft```\n```medianRight```\n```predecessor()```\n```successor()```\n```O(logn)```\n```O(logn)```\n```addNum()```\n```\\npublic class MedianFinder {\\n    private Node root;\\n    private Node medianLeft;\\n    private Node medianRight;\\n    private int size;\\n    \\n    public MedianFinder() {\\n    }\\n\\n    // Adds a number into the data structure.\\n    public void addNum(int num) {\\n        if (root == null) {\\n            root = new Node(num);\\n            medianLeft = root;\\n            medianRight = root;\\n        }\\n        else {\\n            root.addNode(num);\\n            if (size % 2 == 0) {\\n                if (num < medianLeft.data) {\\n                    medianRight = medianLeft;\\n                }\\n                else if (medianLeft.data <= num && num < medianRight.data) {\\n                    medianLeft = medianLeft.successor();\\n                    medianRight = medianRight.predecessor();\\n                }\\n                else if (medianRight.data <= num) {\\n                    medianLeft = medianRight;\\n                }\\n            }\\n            else {\\n                if (num < medianLeft.data) {\\n                    medianLeft = medianLeft.predecessor();\\n                }\\n                else {\\n                    medianRight = medianRight.successor();\\n                }\\n            }\\n        }\\n        size++;\\n    }\\n\\n    // Returns the median of current data stream\\n    public double findMedian() {\\n        return (medianLeft.data + medianRight.data) / 2.0;\\n    }\\n    \\n    class Node {\\n        private Node parent;\\n        private Node left;\\n        private Node right;\\n        private int data;\\n        \\n        public Node(int data) {\\n            this.data = data;\\n        }\\n        \\n        public void addNode(int data) {\\n            if (data >= this.data) {\\n              if (right == null) {\\n                right = new Node(data);\\n                right.parent = this;\\n              }\\n              else\\n                right.addNode(data);\\n            }\\n            else {\\n              if (left == null) {\\n                left = new Node(data);\\n                left.parent = this;\\n              }\\n              else\\n                left.addNode(data);\\n            }\\n        }\\n        \\n        public Node predecessor() {\\n            if (left != null)\\n                return left.rightMost();\\n            \\n            Node predecessor = parent;\\n            Node child = this;\\n            \\n            while (predecessor != null && child != predecessor.right) {\\n                child = predecessor;\\n                predecessor = predecessor.parent;\\n            }\\n            \\n            return predecessor;\\n        }\\n        \\n        public Node successor() {\\n            if (right != null)\\n                return right.leftMost();\\n            \\n            Node successor = parent;\\n            Node child = this;\\n            \\n            while (successor != null && child != successor.left) {\\n                child = successor;\\n                successor = successor.parent;\\n            }\\n            \\n            return successor;\\n        }\\n        \\n        public Node leftMost(){\\n            if (left == null)\\n                return this;\\n            return left.leftMost();\\n        }\\n        \\n        private Node rightMost() {\\n            if (right == null)\\n                return this;\\n            return right.rightMost();\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939433,
                "title": "putta-easy-solution-c-beats-85",
                "content": "\\n# Code\\n```\\nclass MedianFinder {\\npublic:\\n        priority_queue<double> maxheap;\\n        priority_queue<double,vector<double> ,greater<double>> minheap;\\n    MedianFinder() {\\n\\n    }\\n    \\n    void addNum(int num) {\\n        maxheap.push(num);\\n        if(!maxheap.empty() && !minheap.empty() && maxheap.top() > minheap.top()){\\n            double temp = maxheap.top();\\n            maxheap.pop();\\n            minheap.push(temp);\\n        }\\n       if( maxheap.size() > minheap.size() + 1){\\n            double temp = maxheap.top();\\n            maxheap.pop();\\n            minheap.push(temp);\\n        }\\n\\n        if( minheap.size() > maxheap.size()+1){\\n            double temp = minheap.top();\\n            minheap.pop();\\n            maxheap.push(temp);\\n        }\\n    } \\n    \\n    double findMedian() {\\n        if( maxheap.size() > minheap.size()) return maxheap.top();\\n        if( minheap.size() > maxheap.size()) return minheap.top();\\n        return (maxheap.top() + minheap.top())/2;\\n\\n    }\\n};\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder* obj = new MedianFinder();\\n * obj->addNum(num);\\n * double param_2 = obj->findMedian();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Design",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Data Stream"
                ],
                "code": "```\\nclass MedianFinder {\\npublic:\\n        priority_queue<double> maxheap;\\n        priority_queue<double,vector<double> ,greater<double>> minheap;\\n    MedianFinder() {\\n\\n    }\\n    \\n    void addNum(int num) {\\n        maxheap.push(num);\\n        if(!maxheap.empty() && !minheap.empty() && maxheap.top() > minheap.top()){\\n            double temp = maxheap.top();\\n            maxheap.pop();\\n            minheap.push(temp);\\n        }\\n       if( maxheap.size() > minheap.size() + 1){\\n            double temp = maxheap.top();\\n            maxheap.pop();\\n            minheap.push(temp);\\n        }\\n\\n        if( minheap.size() > maxheap.size()+1){\\n            double temp = minheap.top();\\n            minheap.pop();\\n            maxheap.push(temp);\\n        }\\n    } \\n    \\n    double findMedian() {\\n        if( maxheap.size() > minheap.size()) return maxheap.top();\\n        if( minheap.size() > maxheap.size()) return minheap.top();\\n        return (maxheap.top() + minheap.top())/2;\\n\\n    }\\n};\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder* obj = new MedianFinder();\\n * obj->addNum(num);\\n * double param_2 = obj->findMedian();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2806245,
                "title": "c-min-and-max-heap-fast-283ms-100",
                "content": "# Approach 1: min heap and max heap (283ms, 100%?)\\n\\nThis approach uses a min and a max heap to keep track of the elements that are above and below the median and we rebalance them to keep them the same size. Strictly speaking we maintain the following invariant: **The \"above\" heap is the same size as the \"below\" heap or one bigger.**\\n\\n```cpp\\nclass MedianFinder {\\nprivate:\\n    priority_queue<int, vector<int>, greater<int>> above_;\\n    priority_queue<int> below_;\\n\\npublic:\\n    MedianFinder() = default;\\n    \\n    void addNum(int num) {\\n        if (empty(above_) || num >= above_.top()) {\\n            above_.push(num);\\n            if (size(above_) > size(below_) + 1) {\\n                below_.push(above_.top());\\n                above_.pop();\\n            }\\n        } else {\\n            below_.push(num);\\n            if (size(below_) > size(above_)) {\\n                above_.push(below_.top());\\n                below_.pop();\\n            }\\n        }\\n    }\\n    \\n    double findMedian() const {\\n        if (size(below_) == size(above_))\\n            return 0.5 * (below_.top() + above_.top());\\n        \\n        return above_.top();\\n    }\\n};\\n```\\n\\nTo speed up IO, I always add a line like the following to my code:\\n\\n```cpp\\nstatic int fast_io = []() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0; }();\\n```\\n\\n**Complexity Analysis**\\n  * Time Complexity: $$O(n \\\\log n)$$ for the push and pop operations on the heaps.\\n  * Space Complexity: $$O(n)$$ for the two heaps\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass MedianFinder {\\nprivate:\\n    priority_queue<int, vector<int>, greater<int>> above_;\\n    priority_queue<int> below_;\\n\\npublic:\\n    MedianFinder() = default;\\n    \\n    void addNum(int num) {\\n        if (empty(above_) || num >= above_.top()) {\\n            above_.push(num);\\n            if (size(above_) > size(below_) + 1) {\\n                below_.push(above_.top());\\n                above_.pop();\\n            }\\n        } else {\\n            below_.push(num);\\n            if (size(below_) > size(above_)) {\\n                above_.push(below_.top());\\n                below_.pop();\\n            }\\n        }\\n    }\\n    \\n    double findMedian() const {\\n        if (size(below_) == size(above_))\\n            return 0.5 * (below_.top() + above_.top());\\n        \\n        return above_.top();\\n    }\\n};\\n```\n```cpp\\nstatic int fast_io = []() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0; }();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2805119,
                "title": "two-heaps-with-the-follow-up-s-solution",
                "content": "[Leetcode](https://leetcode.com/) [295. Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/).\\n\\n\\n# Intuition\\n\\nWe can simply use a $\\\\texttt{ArrayList}$ to record the number and **sort** the list, then we can easily get the **median** element of the list. However, the **Time Complexity** will be $O(n^2logn)$ and the **Space Complexity** is $O(n)$. \\n\\nIt surely will be **TLE** and we have to find a better solution.\\n\\n\\n# Heap\\n\\nWe can use Two **Priority Queues** (Heaps) to maintain the data of the entire data stream. \\n\\nThe **min Heap** denoted as $\\\\textit{queueMin}$ is used to maintain the number $\\\\textit{num} \\\\leq \\\\textit{median}$. The **max Heap** denoted as $\\\\textit{queueMax}$ is used to maintain the number $\\\\textit{num} \\\\gt \\\\textit{median}$.\\n\\n- When the total number of data stream elements is **Even**: $\\\\texttt{queueMax.size()} = \\\\texttt{queueMin.size()}$, the dynamic median is $\\\\frac{\\\\texttt{queueMax.peek()} + \\\\texttt{queueMin.peek()}}{2}$;\\n\\n- When the total number of data stream elements is **Odd**: $\\\\texttt{queueMin.size()} = \\\\texttt{queueMin.size()} + 1$, the dynamic median is $\\\\texttt{queueMin.peek()}$.\\n\\nWhen we try to add a new number $\\\\textit{num}$ to the **Two Heaps**, the cases can be as follows:\\n\\n- $\\\\textit{num} \\\\leq \\\\max \\\\{\\\\textit{queMin}\\\\}$\\n\\nWe need to add this number to $\\\\textit{queueMin}$. The new median will be less than or equal to the original median, so we may need to move the $\\\\texttt{queueMin.peek()}$ to $\\\\textit{queueMax}$.\\n\\n- $\\\\textit{num} \\\\gt \\\\max \\\\{\\\\textit{queMin}\\\\}$\\n\\nWe need to add this number to $\\\\textit{queueMax}$. The new median will be greater than or equal to the original median, so we may need to move the $\\\\texttt{queueMax.peek()}$ to $\\\\textit{queueMin}$.\\n\\n\\n```java\\n    static class MedianFinder {\\n        PriorityQueue<Integer> queueMin;\\n        PriorityQueue<Integer> queueMax;\\n\\n        public MedianFinder() {\\n            queueMin = new PriorityQueue<>((a, b) -> b - a);\\n            queueMax = new PriorityQueue<>(((a, b) -> a - b));\\n        }\\n\\n        public void addNum(int num) {\\n            if (queueMin.isEmpty() || num <= queueMin.peek()) {\\n                queueMin.offer(num);\\n\\n                if (queueMax.size() + 1 < queueMin.size()) {\\n                    queueMax.offer(queueMin.poll());\\n                }\\n            } else {\\n                queueMax.offer(num);\\n\\n                if (queueMin.size() < queueMax.size()) {\\n                    queueMin.offer(queueMax.poll());\\n                }\\n            }\\n        }\\n\\n        public double findMedian() {\\n            if (queueMin.size() > queueMax.size()) {\\n                return queueMin.peek();\\n            }\\n\\n            return (queueMin.peek() + queueMax.peek()) / 2.0;\\n        }\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(nlogn)$\\n- **Space Complexity**: $O(n)$\\n\\n\\n# Follow Ups\\n\\n#### If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?\\n\\n- We can use a bucket with a length of $101$. Each bucket stores the number of occurrences of each number, and records the total number of elements in the data stream. When searching for the median, calculate the number of the median, and then scan all buckets from front to back to get the answer.\\n\\n#### If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?\\n\\n- As last question, we can still use buckets to store the data. Then use **Two Pointers** to maintain the median. For the number out of range, we can use two arrays to record the number which less than $0$ or greater than $100$. If the median is not in $[0, 100]$, we can perform brute force to find it.\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Data Stream"
                ],
                "code": "```java\\n    static class MedianFinder {\\n        PriorityQueue<Integer> queueMin;\\n        PriorityQueue<Integer> queueMax;\\n\\n        public MedianFinder() {\\n            queueMin = new PriorityQueue<>((a, b) -> b - a);\\n            queueMax = new PriorityQueue<>(((a, b) -> a - b));\\n        }\\n\\n        public void addNum(int num) {\\n            if (queueMin.isEmpty() || num <= queueMin.peek()) {\\n                queueMin.offer(num);\\n\\n                if (queueMax.size() + 1 < queueMin.size()) {\\n                    queueMax.offer(queueMin.poll());\\n                }\\n            } else {\\n                queueMax.offer(num);\\n\\n                if (queueMin.size() < queueMax.size()) {\\n                    queueMin.offer(queueMax.poll());\\n                }\\n            }\\n        }\\n\\n        public double findMedian() {\\n            if (queueMin.size() > queueMax.size()) {\\n                return queueMin.peek();\\n            }\\n\\n            return (queueMin.peek() + queueMax.peek()) / 2.0;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1566734,
                "title": "javascript-using-datastrucutres-js-priority-queue-min-and-max",
                "content": "LeetCode provides the JavaScript environment with 2 packages from NPM to assist with data structures, `datastructures-js/priority-queue` and `datastructures-js/queue`.\\n\\nhttps://support.leetcode.com/hc/en-us/articles/360011833974-What-are-the-environments-for-the-programming-languages-\\n\\nthe API for `priority-queue` is intuitive and well documented. (the only thing I found not well documented is that when you poll using `.dequeue()` or `.front()`, it returns an object with properties `priority` and `element`. in our use case, these values will both equal the element, but imagine that the element you put in was a linked list node, such as in #23 Merge k Sorted Lists - then your priority will be whatever you configure your PQ to use (in that case, ListNode().val), and element will be the ListNode. The imporant takeaway for this problem is to follow all calls `.dequeue()` or `.front()` with `.element`.)\\n\\nhttps://github.com/datastructures-js/priority-queue\\n\\nas for the algorithm itself, just check other top posts, it\\'s implemented the same with the 2 step addNum() process of insertion and balancing.\\n\\n```\\nvar MedianFinder = function() {\\n    // to find median in O(1) time, we will split all numbers coming in into\\n    // 2 Priority Queues - all input from lowest -> median will be stored in \\n    // max, and all input from median -> highest will be stored in min. this\\n    // means that the .front().element of min and max will be in the middle.\\n\\n    const max = new MaxPriorityQueue();\\n    const min = new MinPriorityQueue();\\n    \\n    return { addNum, findMedian }\\n    \\n    function addNum(num) {\\n        if (min.front() != null && num < min.front().element)\\n            max.enqueue(num)\\n        else\\n            min.enqueue(num)\\n        \\n        const diff = min.size() - max.size()\\n        if (diff > 1) \\n            max.enqueue(min.dequeue().element)\\n        if (diff < -1) \\n            min.enqueue(max.dequeue().element)\\n    }\\n    \\n    function findMedian() {\\n        const diff = min.size() - max.size()\\n        if (diff > 0)\\n            return min.front().element\\n        else if (diff < 0)\\n            return max.front().element\\n        else\\n            return (min.front().element + max.front().element)/2\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar MedianFinder = function() {\\n    // to find median in O(1) time, we will split all numbers coming in into\\n    // 2 Priority Queues - all input from lowest -> median will be stored in \\n    // max, and all input from median -> highest will be stored in min. this\\n    // means that the .front().element of min and max will be in the middle.\\n\\n    const max = new MaxPriorityQueue();\\n    const min = new MinPriorityQueue();\\n    \\n    return { addNum, findMedian }\\n    \\n    function addNum(num) {\\n        if (min.front() != null && num < min.front().element)\\n            max.enqueue(num)\\n        else\\n            min.enqueue(num)\\n        \\n        const diff = min.size() - max.size()\\n        if (diff > 1) \\n            max.enqueue(min.dequeue().element)\\n        if (diff < -1) \\n            min.enqueue(max.dequeue().element)\\n    }\\n    \\n    function findMedian() {\\n        const diff = min.size() - max.size()\\n        if (diff > 0)\\n            return min.front().element\\n        else if (diff < 0)\\n            return max.front().element\\n        else\\n            return (min.front().element + max.front().element)/2\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1404291,
                "title": "easy-java-solution-using-priority-queue-with-detailed-explanation",
                "content": "**Please Upvote if you liked the post**\\n\\n```\\nclass MedianFinder {\\n     PriorityQueue<Integer> left;\\n     PriorityQueue<Integer> right;\\n\\n    /** initialize your data structure here. */\\n    public MedianFinder() {\\n         left = new PriorityQueue<>(Collections.reverseOrder()); //max priority Q\\n         right = new PriorityQueue<>(); //min priority Q\\n\\n    }\\n    \\n    public void addNum(int val) {\\n           if(right.size() > 0 && val > right.peek()){\\n            right.add(val);\\n          }else{\\n              left.add(val);\\n          }\\n            //balancing elements in both priority q logic\\n        \\n          if(right.size() - left.size() == 2){  //right has more elements\\n              left.add(right.remove());\\n          }else if(left.size() - right.size() == 2){\\n              right.add(left.remove());\\n          }\\n\\n    }\\n    \\n    public double findMedian() {\\n        if(left.size() == right.size()){\\n              return ((double)left.peek() + (double)right.peek()) / 2;\\n          }else if(left.size() > right.size()){\\n            return (double)left.peek();\\n        }else{                                //right.size() > left.size();\\n              return (double)right.peek();\\n          }\\n    }\\n}\\n\\n/**\\n We want that either size of left and right priority Q is same if yes then median is\\n (leftpeek + rightpeek) /2 because left priority Q stores max element and right\\n priorityQ stores min element , so these peeks contains 2 adjacent elements required\\n for even size median.\\n \\n if size is odd then one priority q will have extra element , one has n elements and other has n + 1 element , so median will be  from peek of  (n + 1 Size) priority Q\\'s.\\n \\n We don\\'t want difference of size more than one . so if difference of size becomes 2 we have to balance it , then only we can get our median.\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass MedianFinder {\\n     PriorityQueue<Integer> left;\\n     PriorityQueue<Integer> right;\\n\\n    /** initialize your data structure here. */\\n    public MedianFinder() {\\n         left = new PriorityQueue<>(Collections.reverseOrder()); //max priority Q\\n         right = new PriorityQueue<>(); //min priority Q\\n\\n    }\\n    \\n    public void addNum(int val) {\\n           if(right.size() > 0 && val > right.peek()){\\n            right.add(val);\\n          }else{\\n              left.add(val);\\n          }\\n            //balancing elements in both priority q logic\\n        \\n          if(right.size() - left.size() == 2){  //right has more elements\\n              left.add(right.remove());\\n          }else if(left.size() - right.size() == 2){\\n              right.add(left.remove());\\n          }\\n\\n    }\\n    \\n    public double findMedian() {\\n        if(left.size() == right.size()){\\n              return ((double)left.peek() + (double)right.peek()) / 2;\\n          }else if(left.size() > right.size()){\\n            return (double)left.peek();\\n        }else{                                //right.size() > left.size();\\n              return (double)right.peek();\\n          }\\n    }\\n}\\n\\n/**\\n We want that either size of left and right priority Q is same if yes then median is\\n (leftpeek + rightpeek) /2 because left priority Q stores max element and right\\n priorityQ stores min element , so these peeks contains 2 adjacent elements required\\n for even size median.\\n \\n if size is odd then one priority q will have extra element , one has n elements and other has n + 1 element , so median will be  from peek of  (n + 1 Size) priority Q\\'s.\\n \\n We don\\'t want difference of size more than one . so if difference of size becomes 2 we have to balance it , then only we can get our median.\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330925,
                "title": "find-median-from-data-stream-java-simple-solution-using-heaps-easy-to-understand",
                "content": "\\n```\\npublic class MedianFinder {\\n\\n    PriorityQueue<Integer> max;     //stores the first half of elements(as present in sorted array)\\n    PriorityQueue<Integer> min;     //stores the second half of elements\\n    public MedianFinder() {\\n        max = new PriorityQueue<>(Collections.reverseOrder());       //maxheap to store first half of elements\\n        min = new PriorityQueue<>();                                                     //minheap to store second half of elements\\n    }\\n    \\n    public void addNum(int num) {\\n        if(max.isEmpty() || num<max.peek()){\\n            max.add(num);       //if element lies in first half,i.e,if element is less than top of maxheap or if maxheap is empty, add to maxheap\\n        }else{\\n            min.add(num);       //else add to min heap\\n        }\\n        if(max.size()>(min.size()+1)){  //balance both heaps if difference of size greater than 1(max difference will be 2 in any case as it is balanced after adding every element)\\n            min.add(max.peek());max.poll();\\n        }else if(min.size()>(max.size()+1)){\\n            max.add(min.peek());min.poll();\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        //System.out.println(max.size()+ \" \"+ min.size());\\n        if(max.size()==min.size()) return (double)(max.peek()+min.peek())/2;\\n        else if(max.size()>min.size()) return max.peek();\\n        else return min.peek();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class MedianFinder {\\n\\n    PriorityQueue<Integer> max;     //stores the first half of elements(as present in sorted array)\\n    PriorityQueue<Integer> min;     //stores the second half of elements\\n    public MedianFinder() {\\n        max = new PriorityQueue<>(Collections.reverseOrder());       //maxheap to store first half of elements\\n        min = new PriorityQueue<>();                                                     //minheap to store second half of elements\\n    }\\n    \\n    public void addNum(int num) {\\n        if(max.isEmpty() || num<max.peek()){\\n            max.add(num);       //if element lies in first half,i.e,if element is less than top of maxheap or if maxheap is empty, add to maxheap\\n        }else{\\n            min.add(num);       //else add to min heap\\n        }\\n        if(max.size()>(min.size()+1)){  //balance both heaps if difference of size greater than 1(max difference will be 2 in any case as it is balanced after adding every element)\\n            min.add(max.peek());max.poll();\\n        }else if(min.size()>(max.size()+1)){\\n            max.add(min.peek());min.poll();\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        //System.out.println(max.size()+ \" \"+ min.size());\\n        if(max.size()==min.size()) return (double)(max.peek()+min.peek())/2;\\n        else if(max.size()>min.size()) return max.peek();\\n        else return min.peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1264541,
                "title": "c-version-two-heap-solution-of-dietpepsi",
                "content": "```\\nclass MedianFinder {\\npublic:\\n    \\n    priority_queue<int> small;\\n    priority_queue<int,vector<int>,greater<int>> large;\\n    bool even;\\n    MedianFinder() {\\n        even = true;\\n    }\\n    \\n    void addNum(int num) {\\n        if(even)\\n        {\\n            large.push(num);\\n            small.push(large.top());\\n            large.pop();\\n        }\\n        else\\n        {\\n            small.push(num);\\n            large.push(small.top());\\n            small.pop();\\n        }\\n        even=!even;\\n    }\\n    \\n    double findMedian() {\\n        if(even)\\n            return (small.top()+large.top())/2.0;\\n        else\\n            return small.top();\\n    }\\n};\\n```\\n\\nComment down for explanation if u have any query",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass MedianFinder {\\npublic:\\n    \\n    priority_queue<int> small;\\n    priority_queue<int,vector<int>,greater<int>> large;\\n    bool even;\\n    MedianFinder() {\\n        even = true;\\n    }\\n    \\n    void addNum(int num) {\\n        if(even)\\n        {\\n            large.push(num);\\n            small.push(large.top());\\n            large.pop();\\n        }\\n        else\\n        {\\n            small.push(num);\\n            large.push(small.top());\\n            small.pop();\\n        }\\n        even=!even;\\n    }\\n    \\n    double findMedian() {\\n        if(even)\\n            return (small.top()+large.top())/2.0;\\n        else\\n            return small.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 329206,
                "title": "python-binary-search-tree-solution",
                "content": "Binary Search Tree implementation in python\\nInspired from https://leetcode.com/problems/find-median-from-data-stream/discuss/74166/Solution-using-Binary-Search-Tree \\n\\n```\\nclass Node:\\n    def __init__(self, val, size=1):\\n        self.val = val\\n        # size represents nodes below this\\n        self.size = size\\n        self.left = None\\n        self.right = None\\n\\nclass Tree:\\n\\n    def __init__(self):\\n        self.root = None\\n\\n    def add_node(self, val, root=None):\\n        # attach node after this node\\n        if not root:\\n            node = Node(val)\\n            # set tree root\\n            if not self.root:\\n                self.root = node\\n            return node\\n        if val <= root.val:\\n            root.left = self.add_node(val, root.left)\\n        else:\\n            root.right = self.add_node(val, root.right)\\n        size = 1\\n        if root.left:\\n            size += root.left.size\\n        if root.right:\\n            size += root.right.size\\n        root.size = size\\n        return root\\n\\n    def rank(self, k):\\n        \"\"\"\\n        Get k rank node\\n        \"\"\"\\n        temp = self.root\\n        while True:\\n            if not temp.left:\\n                left_size = 0 # handle when there is no left child\\n            else:\\n                left_size = temp.left.size\\n            if left_size == k:\\n                # Exactly k nodes in left subtree\\n                # Exactly k nodes smaller than this\\n                return temp.val\\n            if left_size > k:\\n                # Go left\\n                temp = temp.left\\n            else:\\n                # Go right\\n                # remaining number of elements which we have to look\\n                # = exclude left & root (left.size + 1)\\n                k = k - left_size - 1\\n                temp = temp.right\\n        return -1\\n\\n\\nclass MedianFinder:\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.bst = Tree()\\n        \\n    def addNum(self, num):\\n        \"\"\"\\n        Adds a num into the data structure.\\n        :type num: int\\n        :rtype: void\\n        \"\"\"\\n        self.bst.add_node(num, self.bst.root)\\n\\n\\n    def findMedian(self):\\n        \"\"\"\\n        Returns the median of current data stream\\n        :rtype: float\\n        \"\"\"\\n        size = self.bst.root.size\\n        mid = size / 2\\n        if size % 2 == 0:\\n            return (self.bst.rank(mid-1) + self.bst.rank(mid))/ 2.0\\n        else:\\n            return float(self.bst.rank(mid))\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, val, size=1):\\n        self.val = val\\n        # size represents nodes below this\\n        self.size = size\\n        self.left = None\\n        self.right = None\\n\\nclass Tree:\\n\\n    def __init__(self):\\n        self.root = None\\n\\n    def add_node(self, val, root=None):\\n        # attach node after this node\\n        if not root:\\n            node = Node(val)\\n            # set tree root\\n            if not self.root:\\n                self.root = node\\n            return node\\n        if val <= root.val:\\n            root.left = self.add_node(val, root.left)\\n        else:\\n            root.right = self.add_node(val, root.right)\\n        size = 1\\n        if root.left:\\n            size += root.left.size\\n        if root.right:\\n            size += root.right.size\\n        root.size = size\\n        return root\\n\\n    def rank(self, k):\\n        \"\"\"\\n        Get k rank node\\n        \"\"\"\\n        temp = self.root\\n        while True:\\n            if not temp.left:\\n                left_size = 0 # handle when there is no left child\\n            else:\\n                left_size = temp.left.size\\n            if left_size == k:\\n                # Exactly k nodes in left subtree\\n                # Exactly k nodes smaller than this\\n                return temp.val\\n            if left_size > k:\\n                # Go left\\n                temp = temp.left\\n            else:\\n                # Go right\\n                # remaining number of elements which we have to look\\n                # = exclude left & root (left.size + 1)\\n                k = k - left_size - 1\\n                temp = temp.right\\n        return -1\\n\\n\\nclass MedianFinder:\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.bst = Tree()\\n        \\n    def addNum(self, num):\\n        \"\"\"\\n        Adds a num into the data structure.\\n        :type num: int\\n        :rtype: void\\n        \"\"\"\\n        self.bst.add_node(num, self.bst.root)\\n\\n\\n    def findMedian(self):\\n        \"\"\"\\n        Returns the median of current data stream\\n        :rtype: float\\n        \"\"\"\\n        size = self.bst.root.size\\n        mid = size / 2\\n        if size % 2 == 0:\\n            return (self.bst.rank(mid-1) + self.bst.rank(mid))/ 2.0\\n        else:\\n            return float(self.bst.rank(mid))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 262636,
                "title": "binary-search-based-solution",
                "content": "```\\nclass MedianFinder {\\n    ArrayList<Integer> nums;\\n\\n    public int findInsertIndex(int target) {\\n        int low = 0;\\n        int high = nums.size() - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums.get(mid) >= target)\\n                high = mid - 1;\\n            else\\n                low = mid + 1;\\n        }\\n\\n        return low;\\n    }\\n\\n    /**\\n     * initialize your data structure here.\\n     */\\n    public MedianFinder() {\\n        nums = new ArrayList<>();\\n    }\\n\\n    public void addNum(int num) {\\n        if (nums.size() == 0) {\\n            nums.add(num);\\n        } else {\\n            int index = findInsertIndex(num);\\n            if (index == nums.size()) {\\n                nums.add(num);\\n            } else {\\n                nums.add(index, num);\\n            }\\n        }\\n    }\\n\\n    public double findMedian() {\\n        int mid = (nums.size() - 1) / 2;\\n        return nums.size() % 2 == 0 ? (nums.get(mid) + nums.get(mid + 1)) / 2.0 : nums.get(mid);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass MedianFinder {\\n    ArrayList<Integer> nums;\\n\\n    public int findInsertIndex(int target) {\\n        int low = 0;\\n        int high = nums.size() - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums.get(mid) >= target)\\n                high = mid - 1;\\n            else\\n                low = mid + 1;\\n        }\\n\\n        return low;\\n    }\\n\\n    /**\\n     * initialize your data structure here.\\n     */\\n    public MedianFinder() {\\n        nums = new ArrayList<>();\\n    }\\n\\n    public void addNum(int num) {\\n        if (nums.size() == 0) {\\n            nums.add(num);\\n        } else {\\n            int index = findInsertIndex(num);\\n            if (index == nums.size()) {\\n                nums.add(num);\\n            } else {\\n                nums.add(index, num);\\n            }\\n        }\\n    }\\n\\n    public double findMedian() {\\n        int mid = (nums.size() - 1) / 2;\\n        return nums.size() % 2 == 0 ? (nums.get(mid) + nums.get(mid + 1)) / 2.0 : nums.get(mid);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 74065,
                "title": "c-solution-with-binarysearch",
                "content": "    private List<double> m_listNum = new List<double>();\\n    \\n    public void AddNum(double num) {\\n    \\n        int lintPos = m_listNum.BinarySearch( num ) ;\\n        if (lintPos >= 0) {\\n            m_listNum.Insert(lintPos, num);\\n        } else {\\n            lintPos = ~lintPos;\\n            if (lintPos == m_listNum.Count) {\\n                m_listNum.Add(num);\\n            } else {\\n                m_listNum.Insert(lintPos, num);\\n            }\\n        }\\n    }\\n    \\n    // return the median of current data stream\\n    \\n    public double FindMedian() {\\n    \\n        int lintCount = m_listNum.Count ;\\n    \\n        if (lintCount == 0 ) throw new Exception(\"array is empty\");\\n    \\n        if (lintCount % 2 == 0)\\n            return (m_listNum[lintCount / 2 - 1] + m_listNum[lintCount / 2]) / 2;\\n        else \\n            return m_listNum[lintCount / 2];\\n    }",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "    private List<double> m_listNum = new List<double>();\\n    \\n    public void AddNum(double num) {\\n    \\n        int lintPos = m_listNum.BinarySearch( num ) ;\\n        if (lintPos >= 0) {\\n            m_listNum.Insert(lintPos, num);\\n        } else {\\n            lintPos = ~lintPos;\\n            if (lintPos == m_listNum.Count) {\\n                m_listNum.Add(num);\\n            } else {\\n                m_listNum.Insert(lintPos, num);\\n            }\\n        }\\n    }\\n    \\n    // return the median of current data stream\\n    \\n    public double FindMedian() {\\n    \\n        int lintCount = m_listNum.Count ;\\n    \\n        if (lintCount == 0 ) throw new Exception(\"array is empty\");\\n    \\n        if (lintCount % 2 == 0)\\n            return (m_listNum[lintCount / 2 - 1] + m_listNum[lintCount / 2]) / 2;\\n        else \\n            return m_listNum[lintCount / 2];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2805407,
                "title": "simple-ordered-set-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we have to maintain sorted order and also have to  find the element in middle in at most Logn time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor maintaining values sorted and find element by index we have a direct **Data structure Ordered Set** but in we have to maintain a Ordered set that also contain duplicate value.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(Logn)$$ for every Add and Median operation \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nTotal number of add elements = $$O(N)$$\\n# Code\\n```\\n\\n#include <ext/pb_ds/assoc_container.hpp> \\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\ntypedef tree<pair<int,int>, null_type, \\n        less<pair<int,int>>, rb_tree_tag,\\n        tree_order_statistics_node_update>\\n        ordered_set_pair;\\n  \\nclass MedianFinder {\\npublic:\\n    ordered_set_pair st;\\n    int a=0;\\n    MedianFinder() {\\n        \\n    }\\n    \\n    void addNum(int num) {\\n        //insert pair to store duplicate value in Ordered Set\\n        st.insert({num,a++});\\n    }\\n   \\n    double findMedian() { \\n        int n=st.size();\\n        auto itr = st.find_by_order(n/2); \\n        double num= (*itr).first;\\n        if(n%2==0){\\n            auto itr2=st.find_by_order((n-1)/2);\\n            double num1=(*itr2).first;\\n            num=(num+num1)/2;\\n        }\\n        return num;\\n        \\n    }\\n};\\n\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\n\\n#include <ext/pb_ds/assoc_container.hpp> \\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\ntypedef tree<pair<int,int>, null_type, \\n        less<pair<int,int>>, rb_tree_tag,\\n        tree_order_statistics_node_update>\\n        ordered_set_pair;\\n  \\nclass MedianFinder {\\npublic:\\n    ordered_set_pair st;\\n    int a=0;\\n    MedianFinder() {\\n        \\n    }\\n    \\n    void addNum(int num) {\\n        //insert pair to store duplicate value in Ordered Set\\n        st.insert({num,a++});\\n    }\\n   \\n    double findMedian() { \\n        int n=st.size();\\n        auto itr = st.find_by_order(n/2); \\n        double num= (*itr).first;\\n        if(n%2==0){\\n            auto itr2=st.find_by_order((n-1)/2);\\n            double num1=(*itr2).first;\\n            num=(num+num1)/2;\\n        }\\n        return num;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2805329,
                "title": "c-heap-faster-easy-to-understand",
                "content": "* ***Using Heap***\\n\\n* ***Time Complexity :- O(logN) for both add and median function***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass MedianFinder {\\npublic:\\n    \\n    // smaller will contain half smaller elements\\n    \\n    priority_queue<int> smaller;\\n    \\n    // larger will contain half larger elements\\n    \\n    priority_queue<int, vector<int>, greater<int>> larger;\\n    \\n    MedianFinder() {\\n        \\n    }\\n    \\n    void addNum(int num) {\\n        \\n        // push the num into smaller\\n        \\n        smaller.push(num);\\n        \\n        // if largest element of smaller is greater than the smallest element of larger, then push the top of smaller into larger\\n        \\n        if(!smaller.empty() && !larger.empty() && smaller.top() > larger.top())\\n        {\\n            int val = smaller.top();\\n            \\n            smaller.pop();\\n            \\n            larger.push(val);\\n        }\\n        \\n        // if the size of smaller is greater than larger by 2 then push the top of smaller into larger\\n        \\n        if(smaller.size() > larger.size() + 1)\\n        {\\n            int val = smaller.top();\\n            \\n            smaller.pop();\\n            \\n            larger.push(val);\\n        }\\n        \\n        // if the size of larger is greater than smaller by 2 then push the top of larger into smaller\\n        \\n        else if(larger.size() > smaller.size() + 1)\\n        {\\n            int val = larger.top();\\n            \\n            larger.pop();\\n            \\n            smaller.push(val);\\n        }\\n    }\\n    \\n    double findMedian() {\\n        \\n        if(smaller.size() == larger.size())\\n        {\\n            return (double(smaller.top()) + double(larger.top())) / 2;\\n        }\\n        \\n        else if(smaller.size() == larger.size() + 1)\\n        {\\n            return double(smaller.top());\\n        }\\n        \\n        else\\n        {\\n            return double(larger.top());\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass MedianFinder {\\npublic:\\n    \\n    // smaller will contain half smaller elements\\n    \\n    priority_queue<int> smaller;\\n    \\n    // larger will contain half larger elements\\n    \\n    priority_queue<int, vector<int>, greater<int>> larger;\\n    \\n    MedianFinder() {\\n        \\n    }\\n    \\n    void addNum(int num) {\\n        \\n        // push the num into smaller\\n        \\n        smaller.push(num);\\n        \\n        // if largest element of smaller is greater than the smallest element of larger, then push the top of smaller into larger\\n        \\n        if(!smaller.empty() && !larger.empty() && smaller.top() > larger.top())\\n        {\\n            int val = smaller.top();\\n            \\n            smaller.pop();\\n            \\n            larger.push(val);\\n        }\\n        \\n        // if the size of smaller is greater than larger by 2 then push the top of smaller into larger\\n        \\n        if(smaller.size() > larger.size() + 1)\\n        {\\n            int val = smaller.top();\\n            \\n            smaller.pop();\\n            \\n            larger.push(val);\\n        }\\n        \\n        // if the size of larger is greater than smaller by 2 then push the top of larger into smaller\\n        \\n        else if(larger.size() > smaller.size() + 1)\\n        {\\n            int val = larger.top();\\n            \\n            larger.pop();\\n            \\n            smaller.push(val);\\n        }\\n    }\\n    \\n    double findMedian() {\\n        \\n        if(smaller.size() == larger.size())\\n        {\\n            return (double(smaller.top()) + double(larger.top())) / 2;\\n        }\\n        \\n        else if(smaller.size() == larger.size() + 1)\\n        {\\n            return double(smaller.top());\\n        }\\n        \\n        else\\n        {\\n            return double(larger.top());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261677,
                "title": "c-normal-binary-search-approach",
                "content": "Binary Searrch to Find the Index where the num to be fitted.\\n```\\nclass MedianFinder {\\npublic:\\n    /** initialize your data structure here. */\\n    MedianFinder() {\\n        \\n    }\\n    vector<int> ans;\\n    void addNum(int n) {\\n        if(ans.size()==0) ans.push_back(n);\\n        \\n        else{\\n          int l=0, r=ans.size()-1;\\n            int mid;\\n            while(l<=r){\\n                mid=l+(r-l)/2;\\n                if(ans[mid]<n)l=mid+1;\\n                else{\\n                    r=mid-1;\\n                }\\n            }\\n            ans.insert(ans.begin()+l,n);\\n            \\n        }\\n    }\\n    \\n    double findMedian() {\\n         int n=ans.size();\\n       \\n        if(n%2){\\n            return  ans[n/2];\\n        }\\n        \\n        else{\\n            return double((ans[n/2]+ans[(n/2)-1])/2.00000);\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass MedianFinder {\\npublic:\\n    /** initialize your data structure here. */\\n    MedianFinder() {\\n        \\n    }\\n    vector<int> ans;\\n    void addNum(int n) {\\n        if(ans.size()==0) ans.push_back(n);\\n        \\n        else{\\n          int l=0, r=ans.size()-1;\\n            int mid;\\n            while(l<=r){\\n                mid=l+(r-l)/2;\\n                if(ans[mid]<n)l=mid+1;\\n                else{\\n                    r=mid-1;\\n                }\\n            }\\n            ans.insert(ans.begin()+l,n);\\n            \\n        }\\n    }\\n    \\n    double findMedian() {\\n         int n=ans.size();\\n       \\n        if(n%2){\\n            return  ans[n/2];\\n        }\\n        \\n        else{\\n            return double((ans[n/2]+ans[(n/2)-1])/2.00000);\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 336231,
                "title": "c-using-minimum-heap-and-maximum-heap-practice-in-june-2017",
                "content": "July 15, 2019\\n295. Find Median from Data Stream\\n\\nIt is most challenging problem to solve since the optimal solution is to use two data structure, one is minimum heap, and the other one is maximum heap. I was asked to work on the algorithm in phone screen in March 2017. \\n\\nIt is time for me to review the algorithm again. \\n\\n**How to design minimum heap and maximum heap using C#?**\\n\\nUsing C# SortedSet, and also define Comparer. \\n\\n**One tip to make median calcuation easy**\\n\\nIt is a good idea to make minimum heap size is bigger than maximum heap size by 1 if total length is is odd. \\n\\n**Follow up** \\nOct. 23, 2020\\nI reviewed the code and asked myself why SortedSet is used with int[]. I thought about over 10 minutes. After that, I figured out the following reasons:\\n1. SortedSet do not allow duplicated numbers, so in order to store all numbers in the stream, it is better to make all of them unique. Add identity variable with increment one is a good idea.\\n2. C# SortedSet class, another example to use the class to define Heap is hard level algorithm. 358 rearrange string k distance apart. \\n\\n```\\npublic class MedianFinder {\\n\\n    /** initialize your data structure here. */\\n    public MedianFinder() {\\n        \\n    }\\n    \\n    private int counter = 0;\\n\\n        private SortedSet<int[]> setLow = new SortedSet<int[]>(\\n            Comparer<int[]>.Create((a, b) => a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]));\\n\\n        private SortedSet<int[]> setHigh = new SortedSet<int[]>(\\n            Comparer<int[]>.Create((a, b) => a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]));\\n            \\n    public void AddNum(int num) {\\n        var newNum = new int[2] { num, counter++ };\\n\\n            bool twoTreesSameSize = setLow.Count == setHigh.Count;          \\n\\n            if (twoTreesSameSize)\\n            {\\n                if (setLow.Count == 0 || newNum[0] <= setLow.Max[0])\\n                {\\n                    setLow.Add(newNum);\\n                }\\n                else\\n                {\\n                    setHigh.Add(newNum);\\n\\n                    // move the minimum number from setHigh to setLow. \\n                    setLow.Add(setHigh.Min);\\n                    setHigh.Remove(setHigh.Min);\\n                }\\n            }\\n            else if (newNum[0] <= setLow.Max[0])\\n            {\\n                setLow.Add(newNum);\\n\\n                // move the maximum number from setLow to setHigh\\n                setHigh.Add(setLow.Max);\\n                setLow.Remove(setLow.Max);\\n            }\\n            else\\n            {\\n                setHigh.Add(newNum);\\n            }\\n    }\\n    \\n    public double FindMedian() {\\n        if (setLow.Count == 0)\\n            {\\n                return 0;\\n            }\\n\\n            if (setLow.Count == setHigh.Count)\\n            {\\n                return (setLow.Max[0] + setHigh.Min[0]) / 2d;\\n            }\\n            else\\n            {\\n                return setLow.Max[0];\\n            }\\n    }\\n}\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder obj = new MedianFinder();\\n * obj.AddNum(num);\\n * double param_2 = obj.FindMedian();\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\npublic class MedianFinder {\\n\\n    /** initialize your data structure here. */\\n    public MedianFinder() {\\n        \\n    }\\n    \\n    private int counter = 0;\\n\\n        private SortedSet<int[]> setLow = new SortedSet<int[]>(\\n            Comparer<int[]>.Create((a, b) => a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]));\\n\\n        private SortedSet<int[]> setHigh = new SortedSet<int[]>(\\n            Comparer<int[]>.Create((a, b) => a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]));\\n            \\n    public void AddNum(int num) {\\n        var newNum = new int[2] { num, counter++ };\\n\\n            bool twoTreesSameSize = setLow.Count == setHigh.Count;          \\n\\n            if (twoTreesSameSize)\\n            {\\n                if (setLow.Count == 0 || newNum[0] <= setLow.Max[0])\\n                {\\n                    setLow.Add(newNum);\\n                }\\n                else\\n                {\\n                    setHigh.Add(newNum);\\n\\n                    // move the minimum number from setHigh to setLow. \\n                    setLow.Add(setHigh.Min);\\n                    setHigh.Remove(setHigh.Min);\\n                }\\n            }\\n            else if (newNum[0] <= setLow.Max[0])\\n            {\\n                setLow.Add(newNum);\\n\\n                // move the maximum number from setLow to setHigh\\n                setHigh.Add(setLow.Max);\\n                setLow.Remove(setLow.Max);\\n            }\\n            else\\n            {\\n                setHigh.Add(newNum);\\n            }\\n    }\\n    \\n    public double FindMedian() {\\n        if (setLow.Count == 0)\\n            {\\n                return 0;\\n            }\\n\\n            if (setLow.Count == setHigh.Count)\\n            {\\n                return (setLow.Max[0] + setHigh.Min[0]) / 2d;\\n            }\\n            else\\n            {\\n                return setLow.Max[0];\\n            }\\n    }\\n}\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder obj = new MedianFinder();\\n * obj.AddNum(num);\\n * double param_2 = obj.FindMedian();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 137721,
                "title": "java-impl-of-approach-4-multiset-and-two-pointers-from-solution",
                "content": "Plain Java have no multisets, so we have to use (sorted) TreeSet, Node structure and custom comparator. Methods multiSet.lower, multiSet.higher complete with log(N) time complexity (worse than C++ pointers inc/dec), but \"of two evils choose the least\".\\n\\n```\\n    class Node {\\n        int value;\\n        int count;\\n\\n        public Node(int value, int count) {\\n            this.value = value;\\n            this.count = count;\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            if (this == o) return true;\\n            if (o == null || getClass() != o.getClass()) return false;\\n            Node node = (Node) o;\\n            return value == node.value &&\\n                    count == node.count;\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return Objects.hash(value, count);\\n        }\\n    }\\n\\n    final TreeSet<Node> multiSet;\\n    int count = 0;\\n    Node loMedian, hiMedian;\\n\\n    /** initialize your data structure here. */\\n    public MedianFinder3() {\\n        this.multiSet = new TreeSet<>((a, b) -> {\\n            if (a.value == b.value)\\n                return a.count - b.count;\\n            else\\n                return a.value - b.value;\\n        });\\n    }\\n\\n    public void addNum(int num) {\\n        int size = multiSet.size();\\n        Node n = new Node(num, count++);\\n        multiSet.add(n);\\n        if (size == 0) {\\n            loMedian = n;\\n            hiMedian = n;\\n        } else if (size % 2 != 0) {\\n            if (n.value < loMedian.value) {\\n                loMedian = multiSet.lower(loMedian);\\n            } else {\\n                hiMedian = multiSet.higher(hiMedian);\\n            }\\n        } else {\\n            if (n.value > loMedian.value && n.value < hiMedian.value) {\\n                loMedian = multiSet.higher(loMedian);\\n                hiMedian = multiSet.lower(hiMedian);\\n            } else if (n.value >= hiMedian.value) {\\n                loMedian = multiSet.higher(loMedian);\\n            } else {\\n                loMedian = hiMedian = multiSet.lower(hiMedian);\\n            }\\n        }\\n    }\\n\\n    public double findMedian() {\\n        if (loMedian == null && hiMedian == null)\\n            return 0;\\n        else if (loMedian.value == hiMedian.value)\\n            return loMedian.value;\\n        else\\n           return (loMedian.value + hiMedian.value) * 0.5;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    class Node {\\n        int value;\\n        int count;\\n\\n        public Node(int value, int count) {\\n            this.value = value;\\n            this.count = count;\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            if (this == o) return true;\\n            if (o == null || getClass() != o.getClass()) return false;\\n            Node node = (Node) o;\\n            return value == node.value &&\\n                    count == node.count;\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return Objects.hash(value, count);\\n        }\\n    }\\n\\n    final TreeSet<Node> multiSet;\\n    int count = 0;\\n    Node loMedian, hiMedian;\\n\\n    /** initialize your data structure here. */\\n    public MedianFinder3() {\\n        this.multiSet = new TreeSet<>((a, b) -> {\\n            if (a.value == b.value)\\n                return a.count - b.count;\\n            else\\n                return a.value - b.value;\\n        });\\n    }\\n\\n    public void addNum(int num) {\\n        int size = multiSet.size();\\n        Node n = new Node(num, count++);\\n        multiSet.add(n);\\n        if (size == 0) {\\n            loMedian = n;\\n            hiMedian = n;\\n        } else if (size % 2 != 0) {\\n            if (n.value < loMedian.value) {\\n                loMedian = multiSet.lower(loMedian);\\n            } else {\\n                hiMedian = multiSet.higher(hiMedian);\\n            }\\n        } else {\\n            if (n.value > loMedian.value && n.value < hiMedian.value) {\\n                loMedian = multiSet.higher(loMedian);\\n                hiMedian = multiSet.lower(hiMedian);\\n            } else if (n.value >= hiMedian.value) {\\n                loMedian = multiSet.higher(loMedian);\\n            } else {\\n                loMedian = hiMedian = multiSet.lower(hiMedian);\\n            }\\n        }\\n    }\\n\\n    public double findMedian() {\\n        if (loMedian == null && hiMedian == null)\\n            return 0;\\n        else if (loMedian.value == hiMedian.value)\\n            return loMedian.value;\\n        else\\n           return (loMedian.value + hiMedian.value) * 0.5;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 74134,
                "title": "both-o-log-n-red-black-tree-solution-in-python",
                "content": "Just want to give another way to solve this problem. \\n\\nUnlike other solutions using Heap, `Red-Black Tree` solution has `O(log(n))` time complexity for both `addNum` and `findMedian`.\\n\\nI also tried `Treap`, but always got TLE unfortunately.\\n\\n    class RedBlackTreeNode(object):\\n        def __init__(self, val):\\n            self.val = val\\n            self.left = None\\n            self.right = None\\n            self.size = 1\\n            self.isRed = True\\n    \\n    \\n    class RedBlackTree(object):\\n        def __init__(self):\\n            self.root = None\\n    \\n        def sizeOf(self, node):\\n            return node.size if node else 0\\n    \\n        @property\\n        def size(self):\\n            return self.sizeOf(self.root)\\n    \\n        def rotateLeft(self, root):\\n            right = root.right\\n    \\n            root.size, right.size = self.sizeOf(\\n                root.left) + self.sizeOf(right.left) + 1, root.size\\n    \\n            root.right = right.left\\n            right.left = root\\n    \\n            right.isRed = root.isRed\\n            root.isRed = True\\n    \\n            return right\\n    \\n        def rotateRight(self, root):\\n            left = root.left\\n    \\n            root.size, left.size = self.sizeOf(\\n                root.right) + self.sizeOf(left.right) + 1, root.size\\n    \\n            root.left = left.right\\n            left.right = root\\n    \\n            left.isRed = root.isRed\\n            root.isRed = True\\n    \\n            return left\\n    \\n        def flipColor(self, root):\\n            root.left.isRed = False\\n            root.right.isRed = False\\n            root.isRed = True\\n            return root\\n    \\n        def insertTo(self, root, val):\\n            if not root:\\n                return RedBlackTreeNode(val)\\n    \\n            if val > root.val:\\n                root.right = self.insertTo(root.right, val)\\n            else:\\n                root.left = self.insertTo(root.left, val)\\n    \\n            if (root.right and root.right.isRed) and not (\\n                    root.left and root.left.isRed):\\n                root = self.rotateLeft(root)\\n    \\n            if (root.left and root.left.isRed) and (\\n                    root.left.left and root.left.left.isRed):\\n                root = self.rotateRight(root)\\n    \\n            if (root.left and root.left.isRed) and (\\n                    root.right and root.right.isRed):\\n                root = self.flipColor(root)\\n    \\n            root.size = sum(map(self.sizeOf, (root.left, root.right))) + 1\\n            return root\\n    \\n        def insert(self, val):\\n            self.root = self.insertTo(self.root, val)\\n            self.root.isRed = False\\n    \\n        def searchK(self, k, root=None):\\n            root = root or self.root\\n    \\n            size = self.sizeOf(root.left) + 1\\n            if k == size:\\n                return root.val\\n    \\n            return self.searchK(k, root.left) if k < size else self.searchK(\\n                k - size, root.right)\\n    \\n    \\n    class MedianFinder(object):\\n        def __init__(self):\\n            self.tree = RedBlackTree()\\n    \\n        def addNum(self, num):\\n            self.tree.insert(num)\\n    \\n        def findMedian(self):\\n            size = self.tree.size\\n            if size & 1:\\n                return self.tree.searchK(size + 1 >> 1)\\n            return sum(map(self.tree.searchK, (size >> 1, size + 2 >> 1))) / 2.0",
                "solutionTags": [],
                "code": "Just want to give another way to solve this problem. \\n\\nUnlike other solutions using Heap, `Red-Black Tree` solution has `O(log(n))` time complexity for both `addNum` and `findMedian`.\\n\\nI also tried `Treap`, but always got TLE unfortunately.\\n\\n    class RedBlackTreeNode(object):\\n        def __init__(self, val):\\n            self.val = val\\n            self.left = None\\n            self.right = None\\n            self.size = 1\\n            self.isRed = True\\n    \\n    \\n    class RedBlackTree(object):\\n        def __init__(self):\\n            self.root = None\\n    \\n        def sizeOf(self, node):\\n            return node.size if node else 0\\n    \\n        @property\\n        def size(self):\\n            return self.sizeOf(self.root)\\n    \\n        def rotateLeft(self, root):\\n            right = root.right\\n    \\n            root.size, right.size = self.sizeOf(\\n                root.left) + self.sizeOf(right.left) + 1, root.size\\n    \\n            root.right = right.left\\n            right.left = root\\n    \\n            right.isRed = root.isRed\\n            root.isRed = True\\n    \\n            return right\\n    \\n        def rotateRight(self, root):\\n            left = root.left\\n    \\n            root.size, left.size = self.sizeOf(\\n                root.right) + self.sizeOf(left.right) + 1, root.size\\n    \\n            root.left = left.right\\n            left.right = root\\n    \\n            left.isRed = root.isRed\\n            root.isRed = True\\n    \\n            return left\\n    \\n        def flipColor(self, root):\\n            root.left.isRed = False\\n            root.right.isRed = False\\n            root.isRed = True\\n            return root\\n    \\n        def insertTo(self, root, val):\\n            if not root:\\n                return RedBlackTreeNode(val)\\n    \\n            if val > root.val:\\n                root.right = self.insertTo(root.right, val)\\n            else:\\n                root.left = self.insertTo(root.left, val)\\n    \\n            if (root.right and root.right.isRed) and not (\\n                    root.left and root.left.isRed):\\n                root = self.rotateLeft(root)\\n    \\n            if (root.left and root.left.isRed) and (\\n                    root.left.left and root.left.left.isRed):\\n                root = self.rotateRight(root)\\n    \\n            if (root.left and root.left.isRed) and (\\n                    root.right and root.right.isRed):\\n                root = self.flipColor(root)\\n    \\n            root.size = sum(map(self.sizeOf, (root.left, root.right))) + 1\\n            return root\\n    \\n        def insert(self, val):\\n            self.root = self.insertTo(self.root, val)\\n            self.root.isRed = False\\n    \\n        def searchK(self, k, root=None):\\n            root = root or self.root\\n    \\n            size = self.sizeOf(root.left) + 1\\n            if k == size:\\n                return root.val\\n    \\n            return self.searchK(k, root.left) if k < size else self.searchK(\\n                k - size, root.right)\\n    \\n    \\n    class MedianFinder(object):\\n        def __init__(self):\\n            self.tree = RedBlackTree()\\n    \\n        def addNum(self, num):\\n            self.tree.insert(num)\\n    \\n        def findMedian(self):\\n            size = self.tree.size\\n            if size & 1:\\n                return self.tree.searchK(size + 1 >> 1)\\n            return sum(map(self.tree.searchK, (size >> 1, size + 2 >> 1))) / 2.0",
                "codeTag": "Java"
            },
            {
                "id": 74135,
                "title": "simple-java-solution-with-2-heaps-and-explanation",
                "content": "        class MedianFinder {\\n        PriorityQueue<Integer> min = null;\\n        PriorityQueue<Integer> max = null;\\n        int len = 0;\\n        \\n        public MedianFinder(){\\n            min = new PriorityQueue<>();\\n            max = new PriorityQueue<>(Collections.reverseOrder());\\n        }\\n        \\n        //Understanding is we will be maintain 2 heaps max and min. The max heap will store the smaller half\\n        //and the min heap will store the larger half of the incoming numbers. Basically we are trying to mimic a \\n        //balanced tree with this model of representation, which means the max heap at the most can have only one extra\\n        //element than the min heap. We need to maintain the ordering that the root of the max heap < root of min heap\\n        \\n        // Adds a number into the data structure.\\n        public void addNum(int num) {\\n            //if the number of elements is even then we need to add the new element to the max heap\\n            if(len%2==0){\\n                max.offer(num);\\n            }else{\\n                //if the number of elements is odd then we need to add the new element to the maxheap\\n                //then transfer the root of the max heap to the min heap\\n                max.offer(num);\\n                min.offer(max.poll());\\n            }    \\n            \\n            //increment the size\\n            len++;\\n            \\n            //if the root of max heap > root of min heap, then it conficts our order rule\\n            //so we shift the max heap's root to min heap and add the minimum element of our\\n            //min heap to max heap\\n            if(len > 1 && max.peek() > min.peek()){\\n                min.offer(max.poll());\\n                max.offer(min.poll());\\n            }\\n        }\\n    \\n        // Returns the median of current data stream\\n        public double findMedian() {\\n            return (len%2==0)?((double)((max.peek()+min.peek())/2.0)):((double)max.peek());\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "        class MedianFinder {\\n        PriorityQueue<Integer> min = null;\\n        PriorityQueue<Integer> max = null;\\n        int len = 0;\\n        \\n        public MedianFinder(){\\n            min = new PriorityQueue<>();\\n            max = new PriorityQueue<>(Collections.reverseOrder());\\n        }\\n        \\n        //Understanding is we will be maintain 2 heaps max and min. The max heap will store the smaller half\\n        //and the min heap will store the larger half of the incoming numbers. Basically we are trying to mimic a \\n        //balanced tree with this model of representation, which means the max heap at the most can have only one extra\\n        //element than the min heap. We need to maintain the ordering that the root of the max heap < root of min heap\\n        \\n        // Adds a number into the data structure.\\n        public void addNum(int num) {\\n            //if the number of elements is even then we need to add the new element to the max heap\\n            if(len%2==0){\\n                max.offer(num);\\n            }else{\\n                //if the number of elements is odd then we need to add the new element to the maxheap\\n                //then transfer the root of the max heap to the min heap\\n                max.offer(num);\\n                min.offer(max.poll());\\n            }    \\n            \\n            //increment the size\\n            len++;\\n            \\n            //if the root of max heap > root of min heap, then it conficts our order rule\\n            //so we shift the max heap's root to min heap and add the minimum element of our\\n            //min heap to max heap\\n            if(len > 1 && max.peek() > min.peek()){\\n                min.offer(max.poll());\\n                max.offer(min.poll());\\n            }\\n        }\\n    \\n        // Returns the median of current data stream\\n        public double findMedian() {\\n            return (len%2==0)?((double)((max.peek()+min.peek())/2.0)):((double)max.peek());\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 74111,
                "title": "it-seems-there-s-no-c-solution-share-mine-84-ms",
                "content": "I use max heap and min heap, O(logn) for addNum, O(1) for getMedium.\\n\\n\\n    #include <stdio.h>\\n    #include <stdlib.h>\\n    \\n    struct MedianFinder {\\n        int *maxHeap; /* store the smaller half */\\n        int *minHeap; /* store the larger half */\\n        int maxHeapCapacity;\\n        int minHeapCapacity;\\n        int maxHeapSize;\\n        int minHeapSize;\\n        double median;\\n    };\\n    \\n    void swap(int *a, int *b) {\\n        int c = *a;\\n        *a = *b;\\n        *b = c;\\n    }\\n    \\n    void addHeap(int **heap, int *size, int *capacity, int data) {\\n        if (*size == *capacity) {\\n            int newCapacity = (*capacity) * 2; /* resize */\\n            int *newHeap = (int *)malloc(newCapacity * sizeof(int));\\n            for (int i = 0; i < *capacity; i++) {\\n                newHeap[i] = (*heap)[i];\\n            }\\n            if (*heap)\\n                free(*heap);\\n            *heap = newHeap;\\n            *capacity = newCapacity;\\n        }\\n        (*heap)[*size] = data;\\n        (*size)++;\\n    }\\n    \\n    void siftUpMax(int *heap, int size) {\\n        int parent, child;\\n        child = size - 1;\\n        while (child > 0) {\\n            parent = (child - 1) / 2;\\n            if (heap[parent] < heap[child])\\n                swap(&heap[parent], &heap[child]);\\n            child = parent;\\n        }\\n    }\\n    \\n    void siftDownMax(int *heap, int size) {\\n        int parent, child;\\n        parent = 0; child = 1;\\n        while (child < size) {\\n            if (child + 1 < size && heap[child] < heap[child + 1])\\n                child = child + 1;\\n    \\n            if (heap[parent] >= heap[child]) break;\\n            swap(&heap[parent], &heap[child]);\\n            parent = child;\\n            child = parent * 2 + 1;\\n        }\\n    }\\n    \\n    void siftUpMin(int *heap, int size) {\\n        int parent, child;\\n        child = size - 1;\\n        while (child > 0) {\\n            parent = (child - 1) / 2;\\n            if (heap[parent] > heap[child])\\n                swap(&heap[parent], &heap[child]);\\n            child = parent;\\n        }\\n    }\\n    \\n    void siftDownMin(int *heap, int size) {\\n        int parent, child;\\n        parent = 0; child = 1;\\n        while (child < size) {\\n            if (child + 1 < size && heap[child] > heap[child + 1])\\n                child = child + 1;\\n    \\n            if (heap[parent] <= heap[child]) break;\\n            swap(&heap[parent], &heap[child]);\\n            parent = child;\\n            child = parent * 2 + 1;\\n        }\\n    }\\n    \\n    /** Initialize your data structure here. */\\n    struct MedianFinder* MedianFinderCreate() {\\n        struct MedianFinder *mf = (struct MedianFinder *)malloc(sizeof(struct MedianFinder));\\n        mf->maxHeap = (int *)malloc(sizeof(int));\\n        mf->minHeap = (int *)malloc(sizeof(int));\\n        mf->maxHeap[0] = mf->minHeap[0] = 0;\\n        mf->minHeapSize = mf->maxHeapSize = 0;\\n        mf->minHeapCapacity = mf->maxHeapCapacity = 1;\\n        mf->median = 0;\\n        return mf;\\n    }\\n    \\n    /** Inserts a num into the data structure. */\\n    void addNum(struct MedianFinder* mf, int num) {\\n        if (mf == NULL) return;\\n    \\n        if (mf->maxHeapSize == mf->minHeapSize) {\\n            if (num > mf->median) {\\n                addHeap(&mf->minHeap, &mf->minHeapSize, &mf->minHeapCapacity, num);\\n                siftUpMin(mf->minHeap, mf->minHeapSize);\\n                mf->median = mf->minHeap[0];\\n            }\\n            else {\\n                addHeap(&mf->maxHeap, &mf->maxHeapSize, &mf->maxHeapCapacity, num);\\n                siftUpMax(mf->maxHeap, mf->maxHeapSize);\\n                mf->median = mf->maxHeap[0];\\n            }\\n        }\\n        else {\\n            if (num > mf->minHeap[0]) {\\n                addHeap(&mf->minHeap, &mf->minHeapSize, &mf->minHeapCapacity, num);\\n                siftUpMin(mf->minHeap, mf->minHeapSize);\\n                if (mf->minHeapSize >= mf->maxHeapSize + 2) {\\n                    addHeap(&mf->maxHeap, &mf->maxHeapSize, &mf->maxHeapCapacity, mf->minHeap[0]);\\n                    siftUpMax(mf->maxHeap, mf->maxHeapSize);\\n                    swap(&mf->minHeap[0], &mf->minHeap[mf->minHeapSize - 1]);\\n                    mf->minHeapSize--;\\n                    siftDownMin(mf->minHeap, mf->minHeapSize);\\n                }\\n            }\\n            else {\\n                addHeap(&mf->maxHeap, &mf->maxHeapSize, &mf->maxHeapCapacity, num);\\n                siftUpMax(mf->maxHeap, mf->maxHeapSize);\\n                if (mf->maxHeapSize >= mf->minHeapSize + 2) {\\n                    addHeap(&mf->minHeap, &mf->minHeapSize, &mf->minHeapCapacity, mf->maxHeap[0]);\\n                    siftUpMin(mf->minHeap, mf->minHeapSize);\\n                    swap(&mf->maxHeap[0], &mf->maxHeap[mf->maxHeapSize - 1]);\\n                    mf->maxHeapSize--;\\n                    siftDownMax(mf->maxHeap, mf->maxHeapSize);\\n                }\\n            }\\n            mf->median = mf->maxHeap[0] + (mf->minHeap[0] - mf->maxHeap[0]) / 2.0;\\n        }\\n    }\\n    \\n    /** find the median of current data stream */\\n    double findMedian(struct MedianFinder* mf) {\\n        if (mf == NULL) return 0;\\n        return mf->median;\\n    }\\n    \\n    /** Deallocates memory previously allocated for the data structure. */\\n    void MedianFinderFree(struct MedianFinder* mf) {\\n        if (mf == NULL) return;\\n        if (mf->maxHeap) free(mf->maxHeap);\\n        if (mf->minHeap) free(mf->minHeap);\\n        free(mf);\\n    }\\n    \\n    // Your MedianFinder object will be instantiated and called as such:\\n    // struct MedianFinder* mf = MedianFinderCreate();\\n    // addNum(mf, 1.0);\\n    // findMedian(mf);\\n    // MedianFinderFree(mf);\\n    \\n    int main() {\\n        struct MedianFinder* mf = MedianFinderCreate();\\n    \\n        addNum(mf, 1);\\n        printf(\"%lf\\\\n\", findMedian(mf));\\n        addNum(mf, 2);\\n        printf(\"%lf\\\\n\", findMedian(mf));\\n        addNum(mf, 3);\\n        printf(\"%lf\\\\n\", findMedian(mf));\\n        addNum(mf, 4);\\n        printf(\"%lf\\\\n\", findMedian(mf));\\n        addNum(mf, 5);\\n        printf(\"%lf\\\\n\", findMedian(mf));\\n        addNum(mf, 6);\\n        printf(\"%lf\\\\n\", findMedian(mf));\\n        addNum(mf, 7);\\n        printf(\"%lf\\\\n\", findMedian(mf));\\n        addNum(mf, 8);\\n        printf(\"%lf\\\\n\", findMedian(mf));\\n        addNum(mf, 9);\\n        printf(\"%lf\\\\n\", findMedian(mf));\\n        addNum(mf, 10);\\n        printf(\"%lf\\\\n\", findMedian(mf));\\n    \\n        MedianFinderFree(mf);\\n    \\n        return 0;\\n    }",
                "solutionTags": [],
                "code": "I use max heap and min heap, O(logn) for addNum, O(1) for getMedium.\\n\\n\\n    #include <stdio.h>\\n    #include <stdlib.h>\\n    \\n    struct MedianFinder {\\n        int *maxHeap; /* store the smaller half */\\n        int *minHeap; /* store the larger half */\\n        int maxHeapCapacity;\\n        int minHeapCapacity;\\n        int maxHeapSize;\\n        int minHeapSize;\\n        double median;\\n    };\\n    \\n    void swap(int *a, int *b) {\\n        int c = *a;\\n        *a = *b;\\n        *b = c;\\n    }\\n    \\n    void addHeap(int **heap, int *size, int *capacity, int data) {\\n        if (*size == *capacity) {\\n            int newCapacity = (*capacity) * 2; /* resize */\\n            int *newHeap = (int *)malloc(newCapacity * sizeof(int));\\n            for (int i = 0; i < *capacity; i++) {\\n                newHeap[i] = (*heap)[i];\\n            }\\n            if (*heap)\\n                free(*heap);\\n            *heap = newHeap;\\n            *capacity = newCapacity;\\n        }\\n        (*heap)[*size] = data;\\n        (*size)++;\\n    }\\n    \\n    void siftUpMax(int *heap, int size) {\\n        int parent, child;\\n        child = size - 1;\\n        while (child > 0) {\\n            parent = (child - 1) / 2;\\n            if (heap[parent] < heap[child])\\n                swap(&heap[parent], &heap[child]);\\n            child = parent;\\n        }\\n    }\\n    \\n    void siftDownMax(int *heap, int size) {\\n        int parent, child;\\n        parent = 0; child = 1;\\n        while (child < size) {\\n            if (child + 1 < size && heap[child] < heap[child + 1])\\n                child = child + 1;\\n    \\n            if (heap[parent] >= heap[child]) break;\\n            swap(&heap[parent], &heap[child]);\\n            parent = child;\\n            child = parent * 2 + 1;\\n        }\\n    }\\n    \\n    void siftUpMin(int *heap, int size) {\\n        int parent, child;\\n        child = size - 1;\\n        while (child > 0) {\\n            parent = (child - 1) / 2;\\n            if (heap[parent] > heap[child])\\n                swap(&heap[parent], &heap[child]);\\n            child = parent;\\n        }\\n    }\\n    \\n    void siftDownMin(int *heap, int size) {\\n        int parent, child;\\n        parent = 0; child = 1;\\n        while (child < size) {\\n            if (child + 1 < size && heap[child] > heap[child + 1])\\n                child = child + 1;\\n    \\n            if (heap[parent] <= heap[child]) break;\\n            swap(&heap[parent], &heap[child]);\\n            parent = child;\\n            child = parent * 2 + 1;\\n        }\\n    }\\n    \\n    /** Initialize your data structure here. */\\n    struct MedianFinder* MedianFinderCreate() {\\n        struct MedianFinder *mf = (struct MedianFinder *)malloc(sizeof(struct MedianFinder));\\n        mf->maxHeap = (int *)malloc(sizeof(int));\\n        mf->minHeap = (int *)malloc(sizeof(int));\\n        mf->maxHeap[0] = mf->minHeap[0] = 0;\\n        mf->minHeapSize = mf->maxHeapSize = 0;\\n        mf->minHeapCapacity = mf->maxHeapCapacity = 1;\\n        mf->median = 0;\\n        return mf;\\n    }\\n    \\n    /** Inserts a num into the data structure. */\\n    void addNum(struct MedianFinder* mf, int num) {\\n        if (mf == NULL) return;\\n    \\n        if (mf->maxHeapSize == mf->minHeapSize) {\\n            if (num > mf->median) {\\n                addHeap(&mf->minHeap, &mf->minHeapSize, &mf->minHeapCapacity, num);\\n                siftUpMin(mf->minHeap, mf->minHeapSize);\\n                mf->median = mf->minHeap[0];\\n            }\\n            else {\\n                addHeap(&mf->maxHeap, &mf->maxHeapSize, &mf->maxHeapCapacity, num);\\n                siftUpMax(mf->maxHeap, mf->maxHeapSize);\\n                mf->median = mf->maxHeap[0];\\n            }\\n        }\\n        else {\\n            if (num > mf->minHeap[0]) {\\n                addHeap(&mf->minHeap, &mf->minHeapSize, &mf->minHeapCapacity, num);\\n                siftUpMin(mf->minHeap, mf->minHeapSize);\\n                if (mf->minHeapSize >= mf->maxHeapSize + 2) {\\n                    addHeap(&mf->maxHeap, &mf->maxHeapSize, &mf->maxHeapCapacity, mf->minHeap[0]);\\n                    siftUpMax(mf->maxHeap, mf->maxHeapSize);\\n                    swap(&mf->minHeap[0], &mf->minHeap[mf->minHeapSize - 1]);\\n                    mf->minHeapSize--;\\n                    siftDownMin(mf->minHeap, mf->minHeapSize);\\n                }\\n            }\\n            else {\\n                addHeap(&mf->maxHeap, &mf->maxHeapSize, &mf->maxHeapCapacity, num);\\n                siftUpMax(mf->maxHeap, mf->maxHeapSize);\\n                if (mf->maxHeapSize >= mf->minHeapSize + 2) {\\n                    addHeap(&mf->minHeap, &mf->minHeapSize, &mf->minHeapCapacity, mf->maxHeap[0]);\\n                    siftUpMin(mf->minHeap, mf->minHeapSize);\\n                    swap(&mf->maxHeap[0], &mf->maxHeap[mf->maxHeapSize - 1]);\\n                    mf->maxHeapSize--;\\n                    siftDownMax(mf->maxHeap, mf->maxHeapSize);\\n                }\\n            }\\n            mf->median = mf->maxHeap[0] + (mf->minHeap[0] - mf->maxHeap[0]) / 2.0;\\n        }\\n    }\\n    \\n    /** find the median of current data stream */\\n    double findMedian(struct MedianFinder* mf) {\\n        if (mf == NULL) return 0;\\n        return mf->median;\\n    }\\n    \\n    /** Deallocates memory previously allocated for the data structure. */\\n    void MedianFinderFree(struct MedianFinder* mf) {\\n        if (mf == NULL) return;\\n        if (mf->maxHeap) free(mf->maxHeap);\\n        if (mf->minHeap) free(mf->minHeap);\\n        free(mf);\\n    }\\n    \\n    // Your MedianFinder object will be instantiated and called as such:\\n    // struct MedianFinder* mf = MedianFinderCreate();\\n    // addNum(mf, 1.0);\\n    // findMedian(mf);\\n    // MedianFinderFree(mf);\\n    \\n    int main() {\\n        struct MedianFinder* mf = MedianFinderCreate();\\n    \\n        addNum(mf, 1);\\n        printf(\"%lf\\\\n\", findMedian(mf));\\n        addNum(mf, 2);\\n        printf(\"%lf\\\\n\", findMedian(mf));\\n        addNum(mf, 3);\\n        printf(\"%lf\\\\n\", findMedian(mf));\\n        addNum(mf, 4);\\n        printf(\"%lf\\\\n\", findMedian(mf));\\n        addNum(mf, 5);\\n        printf(\"%lf\\\\n\", findMedian(mf));\\n        addNum(mf, 6);\\n        printf(\"%lf\\\\n\", findMedian(mf));\\n        addNum(mf, 7);\\n        printf(\"%lf\\\\n\", findMedian(mf));\\n        addNum(mf, 8);\\n        printf(\"%lf\\\\n\", findMedian(mf));\\n        addNum(mf, 9);\\n        printf(\"%lf\\\\n\", findMedian(mf));\\n        addNum(mf, 10);\\n        printf(\"%lf\\\\n\", findMedian(mf));\\n    \\n        MedianFinderFree(mf);\\n    \\n        return 0;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 3238662,
                "title": "295-time-97-64-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe MedianFinder class maintains two heaps: self.small (a max heap) and self.large (a min heap). The median is either the largest element in self.small, the smallest element in self.large, or the average of these two elements if the heaps have the same size.\\n\\nThe addNum method first pushes the new element onto self.small. If self.small becomes larger than self.large, the largest element in self.small is popped and pushed onto self.large. If self.large becomes larger than self.small, the smallest element in self.large is popped and pushed onto self.small.\\n\\nThe findMedian method returns the median as described above.\\n\\n# Complexity\\n- Time complexity:\\n97.64%\\n\\n- Space complexity:\\n79.57%\\n\\n# Code\\n```\\nimport heapq\\n\\nclass MedianFinder:\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.small = []\\n        self.large = []\\n\\n    def addNum(self, num: int) -> None:\\n        if len(self.small) == len(self.large):\\n            heapq.heappush(self.large, -heapq.heappushpop(self.small, -num))\\n        else:\\n            heapq.heappush(self.small, -heapq.heappushpop(self.large, num))\\n\\n    def findMedian(self) -> float:\\n        if len(self.small) == len(self.large):\\n            return (self.large[0] - self.small[0]) / 2.0\\n        else:\\n            return float(self.large[0])\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Design",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\n\\nclass MedianFinder:\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.small = []\\n        self.large = []\\n\\n    def addNum(self, num: int) -> None:\\n        if len(self.small) == len(self.large):\\n            heapq.heappush(self.large, -heapq.heappushpop(self.small, -num))\\n        else:\\n            heapq.heappush(self.small, -heapq.heappushpop(self.large, num))\\n\\n    def findMedian(self) -> float:\\n        if len(self.small) == len(self.large):\\n            return (self.large[0] - self.small[0]) / 2.0\\n        else:\\n            return float(self.large[0])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805533,
                "title": "python-easy-solution-simple-code-sorting",
                "content": "\\n\\n    def __init__(self):\\n\\n        self.lst=[]       \\'\\'\\'insted of using list we can also use sorted array from library then its time complexity reduces to nlogn to logn then we dont have to sort it\\'\\'\\'\\n\\n    def addNum(self, num: int) -> None:\\n        self.lst.append(num)\\n\\n    def findMedian(self) -> float:\\n        self.lst.sort()\\n        mid=len(self.lst)//2\\n        if len(self.lst)%2==0:\\n            return (self.lst[mid-1]+self.lst[mid])/2\\n        else:\\n            return self.lst[mid]",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Sorting"
                ],
                "code": "\\n\\n    def __init__(self):\\n\\n        self.lst=[]       \\'\\'\\'insted of using list we can also use sorted array from library then its time complexity reduces to nlogn to logn then we dont have to sort it\\'\\'\\'\\n\\n    def addNum(self, num: int) -> None:\\n        self.lst.append(num)\\n\\n    def findMedian(self) -> float:\\n        self.lst.sort()\\n        mid=len(self.lst)//2\\n        if len(self.lst)%2==0:\\n            return (self.lst[mid-1]+self.lst[mid])/2\\n        else:\\n            return self.lst[mid]",
                "codeTag": "Python3"
            },
            {
                "id": 2043080,
                "title": "follow-up-solutions-along-with-easy-solution-to-problem",
                "content": "\\nMain solution link - [ https://leetcode.com/problems/find-median-from-data-stream/discuss/2043083/easy-and-simple-solution )\\n\\n**1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?**\\n\\nWe can maintain an integer array of length 100 to store the count of each number along with a total count. Then, we can iterate over the array to find the middle value to get our median.\\n\\nTime and space complexity would be O(100) = O(1).\\n2. **If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?**\\n\\nAs 99% is between 0-100. So can keep a counter for less_than_hundred and greater_than_hundred.\\nAs we know soluiton will be definately in 0-100 we don\\'t need to know those number which are >100 or <0, only count of them will be enough.\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "\\nMain solution link - [ https://leetcode.com/problems/find-median-from-data-stream/discuss/2043083/easy-and-simple-solution )\\n\\n**1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?**\\n\\nWe can maintain an integer array of length 100 to store the count of each number along with a total count. Then, we can iterate over the array to find the middle value to get our median.\\n\\nTime and space complexity would be O(100) = O(1).\\n2. **If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?**\\n\\nAs 99% is between 0-100. So can keep a counter for less_than_hundred and greater_than_hundred.\\nAs we know soluiton will be definately in 0-100 we don\\'t need to know those number which are >100 or <0, only count of them will be enough.\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 220132,
                "title": "swift-solutions-with-binary-search-732s",
                "content": "```\\nclass MedianFinder {\\n\\tvar nums: [Int]\\n\\n    init() {\\n        self.nums = [Int]()\\n    }\\n    \\nfunc addNum(_ num: Int) {\\n    \\tif nums.isEmpty {\\n    \\t\\tnums.append(num)\\n    \\t\\treturn\\n    \\t}\\n\\n        var start = 0, end = nums.count - 1\\n        while start <= end {\\n        \\tvar mid = start + (end - start)/2\\n        \\tif num > nums[mid] {\\n        \\t\\tstart = mid + 1\\n        \\t} else if num < nums[mid] {\\n        \\t\\tend = mid - 1\\n        \\t} else {\\n        \\t\\tstart = mid\\n        \\t\\tbreak\\n        \\t}\\n        }\\n\\n        nums.insert(num, at: start)\\n    }\\n    \\n    func findMedian() -> Double {\\n      \\tlet count = nums.count\\n      \\tvar median: Double = 0\\n      \\tif count%2 == 0 {\\n      \\t\\tmedian = Double(nums[count/2] + nums[(count-1)/2]) / 2\\n      \\t} else {\\n      \\t\\tmedian = Double(nums[count/2])\\n      \\t}\\n        return median\\n    }\\n}\\n \\n```",
                "solutionTags": [],
                "code": "```\\nclass MedianFinder {\\n\\tvar nums: [Int]\\n\\n    init() {\\n        self.nums = [Int]()\\n    }\\n    \\nfunc addNum(_ num: Int) {\\n    \\tif nums.isEmpty {\\n    \\t\\tnums.append(num)\\n    \\t\\treturn\\n    \\t}\\n\\n        var start = 0, end = nums.count - 1\\n        while start <= end {\\n        \\tvar mid = start + (end - start)/2\\n        \\tif num > nums[mid] {\\n        \\t\\tstart = mid + 1\\n        \\t} else if num < nums[mid] {\\n        \\t\\tend = mid - 1\\n        \\t} else {\\n        \\t\\tstart = mid\\n        \\t\\tbreak\\n        \\t}\\n        }\\n\\n        nums.insert(num, at: start)\\n    }\\n    \\n    func findMedian() -> Double {\\n      \\tlet count = nums.count\\n      \\tvar median: Double = 0\\n      \\tif count%2 == 0 {\\n      \\t\\tmedian = Double(nums[count/2] + nums[(count-1)/2]) / 2\\n      \\t} else {\\n      \\t\\tmedian = Double(nums[count/2])\\n      \\t}\\n        return median\\n    }\\n}\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 172685,
                "title": "easy-python-solution-with-2-heaps",
                "content": "```\\nfrom heapq import heappush, heappop, heapreplace, heapify\\nclass MedianFinder(object):\\n\\n    def __init__(self):\\n        #keep smaller half (size >= 1)\\n        self.maxHeap = []\\n        self.minHeap = []\\n\\n    def addNum(self, num):\\n        heappush(self.maxHeap, -num)\\n        heappush(self.minHeap, -heappop(self.maxHeap))\\n        if len(self.minHeap) > len(self.maxHeap):\\n            heappush(self.maxHeap, -heappop(self.minHeap))\\n            \\n\\n    def findMedian(self):\\n        if len(self.maxHeap) > len(self.minHeap):\\n            return float(-self.maxHeap[0])\\n        return ((-self.maxHeap[0] + self.minHeap[0] + 0.00 )/2)\\n\\t```\\t",
                "solutionTags": [],
                "code": "```\\nfrom heapq import heappush, heappop, heapreplace, heapify\\nclass MedianFinder(object):\\n\\n    def __init__(self):\\n        #keep smaller half (size >= 1)\\n        self.maxHeap = []\\n        self.minHeap = []\\n\\n    def addNum(self, num):\\n        heappush(self.maxHeap, -num)\\n        heappush(self.minHeap, -heappop(self.maxHeap))\\n        if len(self.minHeap) > len(self.maxHeap):\\n            heappush(self.maxHeap, -heappop(self.minHeap))\\n            \\n\\n    def findMedian(self):\\n        if len(self.maxHeap) > len(self.minHeap):\\n            return float(-self.maxHeap[0])\\n        return ((-self.maxHeap[0] + self.minHeap[0] + 0.00 )/2)\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2808178,
                "title": "concise-solution-with-two-heaps",
                "content": "```csharp\\npublic class MedianFinder\\n{\\n    PriorityQueue<int, int> left = new();\\n    PriorityQueue<int, int> right = new();\\n    bool odd = false;\\n\\n    public void AddNum(int n)\\n    {\\n        odd = !odd;\\n        int m = right.EnqueueDequeue(n, -n);\\n        left.Enqueue(m, m);\\n\\n        if (left.Count - 1 > right.Count)\\n        {\\n            m = left.Dequeue();\\n            right.Enqueue(m, -m);\\n        }\\n    }\\n    \\n    public double FindMedian() =>\\n        odd ? left.Peek() : (left.Peek() + right.Peek()) / 2.0;\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Heap (Priority Queue)"
                ],
                "code": "```csharp\\npublic class MedianFinder\\n{\\n    PriorityQueue<int, int> left = new();\\n    PriorityQueue<int, int> right = new();\\n    bool odd = false;\\n\\n    public void AddNum(int n)\\n    {\\n        odd = !odd;\\n        int m = right.EnqueueDequeue(n, -n);\\n        left.Enqueue(m, m);\\n\\n        if (left.Count - 1 > right.Count)\\n        {\\n            m = left.Dequeue();\\n            right.Enqueue(m, -m);\\n        }\\n    }\\n    \\n    public double FindMedian() =>\\n        odd ? left.Peek() : (left.Peek() + right.Peek()) / 2.0;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805701,
                "title": "leetcode-the-hard-way-rust-binaryheap",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\n---\\n\\n```rs\\nuse std::collections::BinaryHeap;\\nuse std::cmp::Reverse;\\n\\n#[derive(Default)]\\nstruct MedianFinder {\\n    lo: BinaryHeap<i32>,\\n    hi: BinaryHeap<Reverse<i32>>\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl MedianFinder {\\n\\n    fn new() -> Self {\\n        Default::default()\\n    }\\n    \\n    fn add_num(&mut self, num: i32) {\\n        self.lo.push(num);\\n        self.hi.push(Reverse(*self.lo.peek().unwrap()));\\n        self.lo.pop();\\n        if (self.lo.len() < self.hi.len()) {\\n            self.lo.push(self.hi.peek().unwrap().0);\\n            self.hi.pop();\\n        }\\n    }\\n    \\n    fn find_median(&self) -> f64 {\\n        if self.lo.len() > self.hi.len() {\\n            return *self.lo.peek().unwrap() as f64;\\n        } \\n        (self.lo.peek().unwrap() + self.hi.peek().unwrap().0) as f64 / 2.0\\n    }\\n}\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * let obj = MedianFinder::new();\\n * obj.add_num(num);\\n * let ret_2: f64 = obj.find_median();\\n */\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rs\\nuse std::collections::BinaryHeap;\\nuse std::cmp::Reverse;\\n\\n#[derive(Default)]\\nstruct MedianFinder {\\n    lo: BinaryHeap<i32>,\\n    hi: BinaryHeap<Reverse<i32>>\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl MedianFinder {\\n\\n    fn new() -> Self {\\n        Default::default()\\n    }\\n    \\n    fn add_num(&mut self, num: i32) {\\n        self.lo.push(num);\\n        self.hi.push(Reverse(*self.lo.peek().unwrap()));\\n        self.lo.pop();\\n        if (self.lo.len() < self.hi.len()) {\\n            self.lo.push(self.hi.peek().unwrap().0);\\n            self.hi.pop();\\n        }\\n    }\\n    \\n    fn find_median(&self) -> f64 {\\n        if self.lo.len() > self.hi.len() {\\n            return *self.lo.peek().unwrap() as f64;\\n        } \\n        (self.lo.peek().unwrap() + self.hi.peek().unwrap().0) as f64 / 2.0\\n    }\\n}\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * let obj = MedianFinder::new();\\n * obj.add_num(num);\\n * let ret_2: f64 = obj.find_median();\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2492199,
                "title": "python-3-min-heap-and-max-heap-approach-explained",
                "content": "If an ordered integer list contains odd elements, then a median is the N//2nd element - i.e [1,2,3,4,5]\\'s median is 3. If an ordered integer list contains even elements, then a median is (N//2nd element + (N//2 + 1)th element) / 2 - i.e. [1,2,3,4,5,6]\\'s median is (3 + 4) / 2 == 3.5. In other words:\\n* the median of an odd-sized list is a largest number of the first half of its elements.\\n* the median of an even-sized list is a (largest number of the first half of its elements + smallest number of the second half of its elements) / 2\\n\\nThe idea is to initialize two data structures: 1) one that stores the first half of its elements (`first_half`) and 2) one that stores the second half of its elements (`second_half`). For the `addNum()` method, we\\'ll need to push a new number into either `first_half` or `second_half`. You may think that we must maintain the elements\\' ordering such that both data structures are sorted in ascending order. However, that\\'s not true because we\\'re only interested in retrieving:\\n* `first_half`\\'s largest number\\n*  `second_half`\\'s smallest number\\n\\nIt seems like max-heap and min-heap is a good candidate for this use-case because the former allows us to retrieve (peek) the largest number in constant time & the latter allows us to retrieve (peek) the smallest number in constant time. \\n\\nNext, we must maintain the heaps such that:\\n* they both have the same exact size when we add an even number of elements in total\\n* `first_half` contains one extra element compared to `second_half` when we add an odd number of elements in total.\\n\\nThe way to achieve this is by:\\n1) heappush the number into `first_half`\\n2) heappop `first_half`\\'s element & heappush it into `second_half`\\n3) If `first_half`\\'s size < `second_half`\\'s size, then we\\'ll heappop the  `second_half`\\'s element & heappush it into `first_half`.\\n\\nTo paint a picture, let\\'s do a quick dry-run:\\n```\\nadd 3\\n=====\\nstep one:\\n---------\\nfirst_half: [-3] (we must multiply by -1 for Python\\'s max-heap)\\nsecond_half: []\\n\\nstep two\\n--------\\nfirst_half: []\\nsecond_half: [3] (first_half current stores negative number. hence, we must multiply it by -1 again)\\n\\nstep three\\n----------\\nfirst_half: [-3] (first_half\\'s length is less than second_half. hence, we must push the number back to it)\\nsecond_half: []\\n\\nadd 5\\n=====\\nstep one:\\n---------\\nfirst_half: [-5, -3] (we must multiply by -1 for Python\\'s max-heap)\\nsecond_half: []\\n\\nstep two\\n--------\\nfirst_half: [-3]\\nsecond_half: [5] (first_half current stores negative number. hence, we must multiply it by -1 again)\\n\\nstep three\\n----------\\nfirst_half: [-3]\\nsecond_half: [5] (we keep as is b/c first_half\\'s size == second_half\\'s size)\\n```\\n\\nFor the `findMedian()` method, we\\'ll check if `first_half`\\'s size == `second_half`\\'s size. If that\\'s the case, then it implies that we\\'ve added an even number of elements in total. Hence, we\\'ll return (`first_half`\\'s first element  + `second_half`\\'s first element) / 2. Otherwise, we\\'ll return `first_half`\\'s first element instead. *FYI: We want to return the first element because max-heap/min-heap\\'s first element is the largest/smallest number.*\\n\\n```\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        self.first_half = []\\n        self.second_half = []\\n\\n    def addNum(self, num: int) -> None:\\n        # We must multiply the number by -1 because\\n        # Python doesn\\'t include built-in max-heap atm.\\n        heappush(self.first_half, -num)\\n        popped_element = heappop(self.first_half)\\n        heappush(self.second_half, -popped_element)\\n        \\n        if len(self.first_half) < len(self.second_half):\\n            popped_element = heappop(self.second_half)\\n            heappush(self.first_half, -popped_element)\\n        \\n    def findMedian(self) -> float:\\n        if len(self.first_half) == len(self.second_half):\\n            return (-self.first_half[0] + self.second_half[0]) / 2\\n        return -self.first_half[0]\\n```\\n\\n\\\\\\n**time/space complexity for addNum()**\\nThe time complexity for the `addNum()` method is O(log(N/2)) ~= O(logN)  because heappush and heappop operation requires logarithmic additional runtime to finish. Although `first_half` and `second_half` contains about N/2 elements, it can be rounded up to N.\\n\\nThe space complexity for the `addNum()` method is O(1) because heappush and heappop operation require constant additional spaces to complete.\\n\\n\\\\\\n**time/space complexity for findMedian()**\\nThe time complexity for the `findMedian()` method is O(1) because we\\'re executing a fixed number of operations.\\n\\nThe space complexity for the `findMedian()` method is O(1) because we\\'re only only retrieving an element from `first_half` and `second_half`.\\n\\n\\\\\\n**time/space complexity throughout the entire problem**\\nThe entire problem entails O(NlogN) additional runtime because every add operation requires logN additional runtime to complete.\\n\\nThe entire problem entails O(N) additional memory because we must store N/2 elements into `first_half` and `second_half` (N/2 + N/2 == N).",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nadd 3\\n=====\\nstep one:\\n---------\\nfirst_half: [-3] (we must multiply by -1 for Python\\'s max-heap)\\nsecond_half: []\\n\\nstep two\\n--------\\nfirst_half: []\\nsecond_half: [3] (first_half current stores negative number. hence, we must multiply it by -1 again)\\n\\nstep three\\n----------\\nfirst_half: [-3] (first_half\\'s length is less than second_half. hence, we must push the number back to it)\\nsecond_half: []\\n\\nadd 5\\n=====\\nstep one:\\n---------\\nfirst_half: [-5, -3] (we must multiply by -1 for Python\\'s max-heap)\\nsecond_half: []\\n\\nstep two\\n--------\\nfirst_half: [-3]\\nsecond_half: [5] (first_half current stores negative number. hence, we must multiply it by -1 again)\\n\\nstep three\\n----------\\nfirst_half: [-3]\\nsecond_half: [5] (we keep as is b/c first_half\\'s size == second_half\\'s size)\\n```\n```\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        self.first_half = []\\n        self.second_half = []\\n\\n    def addNum(self, num: int) -> None:\\n        # We must multiply the number by -1 because\\n        # Python doesn\\'t include built-in max-heap atm.\\n        heappush(self.first_half, -num)\\n        popped_element = heappop(self.first_half)\\n        heappush(self.second_half, -popped_element)\\n        \\n        if len(self.first_half) < len(self.second_half):\\n            popped_element = heappop(self.second_half)\\n            heappush(self.first_half, -popped_element)\\n        \\n    def findMedian(self) -> float:\\n        if len(self.first_half) == len(self.second_half):\\n            return (-self.first_half[0] + self.second_half[0]) / 2\\n        return -self.first_half[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2012997,
                "title": "c-simple-2-heaps-solution-o-logn-o-1",
                "content": "**[C++] Solution for finding median of data stream in O(1) time using 2 heaps:**\\n\\n```\\nclass MedianFinder {\\nprivate:\\n    priority_queue<int> maxHeap;\\n    priority_queue<int, vector<int>, greater<int>> minHeap;\\npublic:\\n    MedianFinder() {}\\n    \\n    void addNum(int num) {\\n        // Adding elements to heap\\n        if (maxHeap.empty() || num<maxHeap.top()) maxHeap.push(num);\\n        else minHeap.push(num);\\n        \\n        // Balancing heaps\\n        if (maxHeap.size()>minHeap.size()+1) {\\n            minHeap.push(maxHeap.top());\\n            maxHeap.pop();\\n        } else if (maxHeap.size()<minHeap.size()) {\\n            maxHeap.push(minHeap.top());\\n            minHeap.pop();\\n        }\\n    }\\n    \\n    double findMedian() {\\n        if (minHeap.size()==maxHeap.size()) return (minHeap.top()+maxHeap.top())/2.0;\\n        else return maxHeap.top();\\n    }\\n};\\n```\\n\\n**Time Complexity for addNum()** : O(logN)\\n**Time Complexity for findMedian()** : O(1)\\n**Space Complexity**: O(N)\\n\\nPlease do **upvote** if you find this helpful.\\nFeel free to ask queries or share feedback in comments.",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass MedianFinder {\\nprivate:\\n    priority_queue<int> maxHeap;\\n    priority_queue<int, vector<int>, greater<int>> minHeap;\\npublic:\\n    MedianFinder() {}\\n    \\n    void addNum(int num) {\\n        // Adding elements to heap\\n        if (maxHeap.empty() || num<maxHeap.top()) maxHeap.push(num);\\n        else minHeap.push(num);\\n        \\n        // Balancing heaps\\n        if (maxHeap.size()>minHeap.size()+1) {\\n            minHeap.push(maxHeap.top());\\n            maxHeap.pop();\\n        } else if (maxHeap.size()<minHeap.size()) {\\n            maxHeap.push(minHeap.top());\\n            minHeap.pop();\\n        }\\n    }\\n    \\n    double findMedian() {\\n        if (minHeap.size()==maxHeap.size()) return (minHeap.top()+maxHeap.top())/2.0;\\n        else return maxHeap.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858530,
                "title": "c-priority-queue-2-heaps-o-log-n-add-o-1-median-easy-clean-code",
                "content": "```\\n    priority_queue<int> q1;\\n    priority_queue<int,vector<int>,greater<int>> q2;\\n    \\n    void balance()\\n    {\\n        while(q1.size()<q2.size())\\n        {\\n            q1.push(q2.top());\\n            q2.pop();\\n        }\\n        \\n        if(q1.size()-q2.size()>1)\\n        {\\n            q2.push(q1.top());\\n            q1.pop();\\n        }\\n    }\\n    \\n    MedianFinder() {\\n        \\n    }\\n    \\n    void addNum(int num) {\\n        \\n        if(q1.empty() || num<q1.top())\\n            q1.push(num);\\n        else\\n            q2.push(num);\\n        \\n        balance();\\n    }\\n    \\n    double findMedian() {\\n        if(q1.size()>q2.size())\\n            return q1.top();\\n        else\\n            return ((float)q1.top()+q2.top())/2;\\n    }\\n```\\n\\n**Do share your suggestions & upvote if you like !!!**  \\uD83D\\uDE04",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    priority_queue<int> q1;\\n    priority_queue<int,vector<int>,greater<int>> q2;\\n    \\n    void balance()\\n    {\\n        while(q1.size()<q2.size())\\n        {\\n            q1.push(q2.top());\\n            q2.pop();\\n        }\\n        \\n        if(q1.size()-q2.size()>1)\\n        {\\n            q2.push(q1.top());\\n            q1.pop();\\n        }\\n    }\\n    \\n    MedianFinder() {\\n        \\n    }\\n    \\n    void addNum(int num) {\\n        \\n        if(q1.empty() || num<q1.top())\\n            q1.push(num);\\n        else\\n            q2.push(num);\\n        \\n        balance();\\n    }\\n    \\n    double findMedian() {\\n        if(q1.size()>q2.size())\\n            return q1.top();\\n        else\\n            return ((float)q1.top()+q2.top())/2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1765776,
                "title": "c-priorityqueue-solution",
                "content": "Approach\\n\\n1. Enqueue each element to min heap \\n2. Dequeue element from min heap and enqueue to max heap -> This will ensure all elements in min heap > max heap\\n3. Balance 2 heaps - when min heap size < max heap size then dequeue element from max heap and enqueue in min heap\\n\\n\\n```\\n    public class MedianFinder\\n    {\\n\\n        private PriorityQueue<int, int> _minHeap;\\n        private PriorityQueue<int, int> _maxHeap;\\n\\n        public MedianFinder()\\n        {\\n            _minHeap = new PriorityQueue<int, int>();\\n            _maxHeap = new PriorityQueue<int, int>(Comparer<int>.Create((a,b) => b.CompareTo(a)));\\n        }\\n\\n        public void AddNum(int num)\\n        {\\n            _minHeap.Enqueue(num, num);\\n            int minHeapPeek = _minHeap.Dequeue();\\n            _maxHeap.Enqueue(minHeapPeek, minHeapPeek);\\n            if (_minHeap.Count < _maxHeap.Count)\\n            {\\n                int maxheapPeek = _maxHeap.Dequeue();\\n                _minHeap.Enqueue(maxheapPeek, maxheapPeek);\\n            }\\n        }\\n\\n        public double FindMedian()\\n        {\\n            return _minHeap.Count > _maxHeap.Count ? \\n                _minHeap.Peek() : \\n                (_minHeap.Peek() + _maxHeap.Peek()) / 2.0;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    public class MedianFinder\\n    {\\n\\n        private PriorityQueue<int, int> _minHeap;\\n        private PriorityQueue<int, int> _maxHeap;\\n\\n        public MedianFinder()\\n        {\\n            _minHeap = new PriorityQueue<int, int>();\\n            _maxHeap = new PriorityQueue<int, int>(Comparer<int>.Create((a,b) => b.CompareTo(a)));\\n        }\\n\\n        public void AddNum(int num)\\n        {\\n            _minHeap.Enqueue(num, num);\\n            int minHeapPeek = _minHeap.Dequeue();\\n            _maxHeap.Enqueue(minHeapPeek, minHeapPeek);\\n            if (_minHeap.Count < _maxHeap.Count)\\n            {\\n                int maxheapPeek = _maxHeap.Dequeue();\\n                _minHeap.Enqueue(maxheapPeek, maxheapPeek);\\n            }\\n        }\\n\\n        public double FindMedian()\\n        {\\n            return _minHeap.Count > _maxHeap.Count ? \\n                _minHeap.Peek() : \\n                (_minHeap.Peek() + _maxHeap.Peek()) / 2.0;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1497698,
                "title": "python-two-heap-easy-to-understand",
                "content": "```\\nfrom heapq import heappush, heappop\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        self.maxheap = []   # Store the lower half\\n        self.minheap = []   # Store the larger half\\n        \\n\\n    def addNum(self, num: int) -> None:\\n        # maxheap length is either equal or 1 greater than minheap length\\n        # always store negative value for maxheap\\n        heappush(self.maxheap, -num)\\n        \\n        # Convert to positive when retrieving from maxheap\\n        maxHeapTop = -heappop(self.maxheap)\\n        \\n        heappush(self.minheap, maxHeapTop)\\n        \\n        # Balance two heap\\n        if len(self.minheap) > len(self.maxheap):\\n            minHeapTop = heappop(self.minheap)\\n            heappush(self.maxheap,-minHeapTop)  \\n        \\n    def findMedian(self) -> float:\\n        if len(self.minheap) == len(self.maxheap):\\n            return (self.minheap[0] + (-self.maxheap[0])) / 2\\n        else:\\n            return -self.maxheap[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heappush, heappop\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        self.maxheap = []   # Store the lower half\\n        self.minheap = []   # Store the larger half\\n        \\n\\n    def addNum(self, num: int) -> None:\\n        # maxheap length is either equal or 1 greater than minheap length\\n        # always store negative value for maxheap\\n        heappush(self.maxheap, -num)\\n        \\n        # Convert to positive when retrieving from maxheap\\n        maxHeapTop = -heappop(self.maxheap)\\n        \\n        heappush(self.minheap, maxHeapTop)\\n        \\n        # Balance two heap\\n        if len(self.minheap) > len(self.maxheap):\\n            minHeapTop = heappop(self.minheap)\\n            heappush(self.maxheap,-minHeapTop)  \\n        \\n    def findMedian(self) -> float:\\n        if len(self.minheap) == len(self.maxheap):\\n            return (self.minheap[0] + (-self.maxheap[0])) / 2\\n        else:\\n            return -self.maxheap[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331923,
                "title": "clean-2-heaps-go-solution",
                "content": "```\\ntype Heap struct {\\n\\tValues   []int\\n\\tLessFunc func(int, int) bool\\n}\\n\\nfunc (h *Heap) Less(i, j int) bool { return h.LessFunc(h.Values[i], h.Values[j]) }\\nfunc (h *Heap) Swap(i, j int)      { h.Values[i], h.Values[j] = h.Values[j], h.Values[i] }\\nfunc (h *Heap) Len() int           { return len(h.Values) }\\nfunc (h *Heap) Peek() int          { return h.Values[0] }\\nfunc (h *Heap) Pop() (v interface{}) {\\n\\th.Values, v = h.Values[:h.Len()-1], h.Values[h.Len()-1]\\n\\treturn v\\n}\\nfunc (h *Heap) Push(v interface{}) { h.Values = append(h.Values, v.(int)) }\\n\\nfunc NewHeap(less func(int, int) bool) *Heap {\\n\\treturn &Heap{LessFunc: less}\\n}\\n\\ntype MedianFinder struct {\\n\\tsmallHeap *Heap\\n\\tlargeHeap *Heap\\n}\\n\\nfunc Constructor() MedianFinder {\\n\\treturn MedianFinder{\\n\\t\\tsmallHeap: NewHeap(func(a, b int) bool {\\n\\t\\t\\treturn a > b\\n\\t\\t}),\\n\\t\\tlargeHeap: NewHeap(func(a, b int) bool {\\n\\t\\t\\treturn a < b\\n\\t\\t}),\\n\\t}\\n}\\n\\nfunc (mf *MedianFinder) AddNum(num int) {\\n\\tif (mf.smallHeap.Len()+mf.largeHeap.Len())%2 == 0 {\\n\\t\\theap.Push(mf.largeHeap, num)\\n\\t\\theap.Push(mf.smallHeap, heap.Pop(mf.largeHeap))\\n\\t} else {\\n\\t\\theap.Push(mf.smallHeap, num)\\n\\t\\theap.Push(mf.largeHeap, heap.Pop(mf.smallHeap))\\n\\t}\\n}\\n\\nfunc (mf *MedianFinder) FindMedian() float64 {\\n\\tif (mf.smallHeap.Len()+mf.largeHeap.Len())%2 == 0 {\\n\\t\\treturn (float64(mf.smallHeap.Peek()) + float64(mf.largeHeap.Peek())) / 2\\n\\t}\\n\\treturn float64(mf.smallHeap.Peek())\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntype Heap struct {\\n\\tValues   []int\\n\\tLessFunc func(int, int) bool\\n}\\n\\nfunc (h *Heap) Less(i, j int) bool { return h.LessFunc(h.Values[i], h.Values[j]) }\\nfunc (h *Heap) Swap(i, j int)      { h.Values[i], h.Values[j] = h.Values[j], h.Values[i] }\\nfunc (h *Heap) Len() int           { return len(h.Values) }\\nfunc (h *Heap) Peek() int          { return h.Values[0] }\\nfunc (h *Heap) Pop() (v interface{}) {\\n\\th.Values, v = h.Values[:h.Len()-1], h.Values[h.Len()-1]\\n\\treturn v\\n}\\nfunc (h *Heap) Push(v interface{}) { h.Values = append(h.Values, v.(int)) }\\n\\nfunc NewHeap(less func(int, int) bool) *Heap {\\n\\treturn &Heap{LessFunc: less}\\n}\\n\\ntype MedianFinder struct {\\n\\tsmallHeap *Heap\\n\\tlargeHeap *Heap\\n}\\n\\nfunc Constructor() MedianFinder {\\n\\treturn MedianFinder{\\n\\t\\tsmallHeap: NewHeap(func(a, b int) bool {\\n\\t\\t\\treturn a > b\\n\\t\\t}),\\n\\t\\tlargeHeap: NewHeap(func(a, b int) bool {\\n\\t\\t\\treturn a < b\\n\\t\\t}),\\n\\t}\\n}\\n\\nfunc (mf *MedianFinder) AddNum(num int) {\\n\\tif (mf.smallHeap.Len()+mf.largeHeap.Len())%2 == 0 {\\n\\t\\theap.Push(mf.largeHeap, num)\\n\\t\\theap.Push(mf.smallHeap, heap.Pop(mf.largeHeap))\\n\\t} else {\\n\\t\\theap.Push(mf.smallHeap, num)\\n\\t\\theap.Push(mf.largeHeap, heap.Pop(mf.smallHeap))\\n\\t}\\n}\\n\\nfunc (mf *MedianFinder) FindMedian() float64 {\\n\\tif (mf.smallHeap.Len()+mf.largeHeap.Len())%2 == 0 {\\n\\t\\treturn (float64(mf.smallHeap.Peek()) + float64(mf.largeHeap.Peek())) / 2\\n\\t}\\n\\treturn float64(mf.smallHeap.Peek())\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1140457,
                "title": "java-treeset-solution-with-two-pointers-and-explanation",
                "content": "For some reason, there is a lack of well documented solution using TreeSet for Java developers in the discussion. Official LC solution uses C++ multiset and iteration there gets easier because of pointers, which is hard to achieve using iterators in Java (considering there is no *peek* functionality in Java iterators).\\n\\nThe following code uses two pointer approach, and becomes a bit long because of using a custom comparator. The idea here is: instead of an iterator, we store both the number and its location in data stream in the TreeSet. This lets us handle cases where identical values are entered in the stream, and closely follows the height balanced trees approach presented in LC solution.\\n\\nThis is an important technique to grasp in case interviewer asks for alternative solutions to the more popular Priority Queue approach.\\n\\nTime complexity for add is O(log(n)) to account for the time to `add` and search (`lower` and `upper` methods of TreeSet).\\nSpace complexity is O(n) since we are storing all elements of the stream here\\n\\n```\\nclass MedianFinder {\\n    TreeSet<int[]> data;\\n    Comparator<int[]> customComparator;\\n    int[] lower, upper;\\n    int index;\\n    /** initialize your data structure here. */\\n    public MedianFinder() {\\n        // Comparator compares first by value of the integer, then by location in stream\\n        customComparator = ((int[] a, int[] b) -> {\\n            if (a[0] != b[0]) {\\n                return Integer.compare(a[0], b[0]);\\n            }\\n            else {\\n                return Integer.compare(a[1], b[1]);\\n            }\\n        });\\n        data = new TreeSet<>(customComparator);\\n        lower = null;\\n        upper = null;\\n        index = 0;\\n    }\\n    \\n    public void addNum(int num) {\\n        int[] curr = new int[] {num, index++};\\n        data.add(curr);\\n        if (data.size() == 1) {\\n            // First addition to the stream\\n            lower = data.first();\\n            upper = data.first();\\n        }\\n        else if (customComparator.compare(lower, upper) == 0) {\\n            // last time it was odd, now it is even\\n            if (customComparator.compare(curr, lower) < 0) {\\n                // num is less than the left median\\n                // Median has shifted one place left\\n                upper = lower;\\n                lower = data.lower(lower);\\n            }\\n            else {\\n                // num is greater than or eaual to the right median\\n                // Median has shifted one place right\\n                lower = upper;\\n                upper = data.higher(upper);\\n            }\\n        }\\n        else {\\n            // last time it was even, this time it is odd\\n            // Three cases\\n            if (customComparator.compare(curr, lower) < 0) {\\n                // Case 1: new number inserted to the left of lower\\n                // lower median is the current median in that case\\n                upper = lower;\\n            }\\n            else  if (customComparator.compare(curr, upper) > 0) {\\n                // Case 2: new number inserted to the right of upper\\n                // upper median is the current median in that case\\n                lower = upper;\\n            }\\n            else{\\n                // Case 3: Either num is equal to one or both of upper, lower, or lies in between\\n                // in that case, num IS our median\\n                lower = curr;\\n                upper = curr;\\n            }\\n        }\\n        \\n    }\\n    \\n    public double findMedian() {\\n        if (lower == null) {\\n            // Safety check\\n            return 0.0;\\n        }\\n        // This function is trivial since we are already tracking two pointers\\n        return ((double)lower[0] + upper[0])/2;\\n    }\\n}\\n```\\n\\nNote: inspired by https://leetcode.com/problems/find-median-from-data-stream/discuss/439595/Java-TreeSet-Solution-beats-93, but wanted to add more commented and clean code.",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass MedianFinder {\\n    TreeSet<int[]> data;\\n    Comparator<int[]> customComparator;\\n    int[] lower, upper;\\n    int index;\\n    /** initialize your data structure here. */\\n    public MedianFinder() {\\n        // Comparator compares first by value of the integer, then by location in stream\\n        customComparator = ((int[] a, int[] b) -> {\\n            if (a[0] != b[0]) {\\n                return Integer.compare(a[0], b[0]);\\n            }\\n            else {\\n                return Integer.compare(a[1], b[1]);\\n            }\\n        });\\n        data = new TreeSet<>(customComparator);\\n        lower = null;\\n        upper = null;\\n        index = 0;\\n    }\\n    \\n    public void addNum(int num) {\\n        int[] curr = new int[] {num, index++};\\n        data.add(curr);\\n        if (data.size() == 1) {\\n            // First addition to the stream\\n            lower = data.first();\\n            upper = data.first();\\n        }\\n        else if (customComparator.compare(lower, upper) == 0) {\\n            // last time it was odd, now it is even\\n            if (customComparator.compare(curr, lower) < 0) {\\n                // num is less than the left median\\n                // Median has shifted one place left\\n                upper = lower;\\n                lower = data.lower(lower);\\n            }\\n            else {\\n                // num is greater than or eaual to the right median\\n                // Median has shifted one place right\\n                lower = upper;\\n                upper = data.higher(upper);\\n            }\\n        }\\n        else {\\n            // last time it was even, this time it is odd\\n            // Three cases\\n            if (customComparator.compare(curr, lower) < 0) {\\n                // Case 1: new number inserted to the left of lower\\n                // lower median is the current median in that case\\n                upper = lower;\\n            }\\n            else  if (customComparator.compare(curr, upper) > 0) {\\n                // Case 2: new number inserted to the right of upper\\n                // upper median is the current median in that case\\n                lower = upper;\\n            }\\n            else{\\n                // Case 3: Either num is equal to one or both of upper, lower, or lies in between\\n                // in that case, num IS our median\\n                lower = curr;\\n                upper = curr;\\n            }\\n        }\\n        \\n    }\\n    \\n    public double findMedian() {\\n        if (lower == null) {\\n            // Safety check\\n            return 0.0;\\n        }\\n        // This function is trivial since we are already tracking two pointers\\n        return ((double)lower[0] + upper[0])/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1061723,
                "title": "java-solutions-for-two-follow-ups",
                "content": "**1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?**\\n\\nWe can use an array with 100 slots to store the count of each number, and then iterate through the array to find the median.\\nAs the size of the array is 101, the time complexity of finding the median is constant.\\n\\n***Java Sample Code:***\\n```\\nclass MedianFinder {\\n    int[] arr;\\n    int size;\\n    /** initialize your data structure here. */\\n    public MedianFinder() {\\n        arr = new int[101];\\n        size = 0;\\n    }\\n    \\n    public void addNum(int num) {\\n        arr[num]++;\\n        size++;\\n    }\\n    \\n    public double findMedian() {\\n        int index = 0, median = size / 2, first = 0;\\n        for(int i = 0; i < 101; i++) {\\n            for(int j = 0; j < arr[i]; j++) {\\n                if(index == median - 1) first = i;\\n                else if(index == median) {\\n                    if(size % 2 == 0) return (first + i) / 2.0;\\n                    else return (double) i;\\n                }\\n                index++;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n**2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?**\\n\\nIt\\'s similar to above, but here are situations we need to talk about.\\n\\n1. If we can make sure we will call `findMedian()` only when we already have most of integer numbers inserted, which assure the median would appear between 0 and 100, we can just use a variable to store the total size of all numbers and the number of elements that are less than 0 respectively and don\\'t have to care about what those numbers are. For those numbers that are greater than 100, we don\\'t have to really care about them to find median as we will iterate through from the lowest number.\\n\\n***Java Sample Code***\\n```\\nclass MedianFinder {\\n    int[] arr;\\n    int size;\\n    int lo;\\n    /** initialize your data structure here. */\\n    public MedianFinder() {\\n        arr = new int[101];\\n        size = 0;\\n        lo = 0;\\n    }\\n    \\n    public void addNum(int num) {\\n        if(num < 0) lo++;\\n        else if(num <= 100 && num >= 0) arr[num]++;\\n        size++;\\n    }\\n    \\n    public double findMedian() {\\n        int index = lo, median = size / 2, first = 0;\\n        for(int i = 0; i < 101; i++) {\\n            for(int j = 0; j < arr[i]; j++) {\\n                if(index == median - 1) first = i;\\n                else if(index == median) {\\n                    if(size % 2 == 0) return (first + i) / 2.0;\\n                    else return (double) i;\\n                }\\n                index++;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n\\n2. But if we don\\'t know when we will call `findMedian()`, we have to make sure we have access to all numbers inserted all the time. Especially, if we insert numbers that are not in the range of 0 to 100 at the very beginning and we call `findMedian`, we need to be able to access those numbers and find the median between them. So we need two more PriorityQueues to help store numbers that are less than 0 or greater than 100.\\nWhy ***PriorityQueue***? As PriorityQueue helps sort the number when we insert it, we could easily find the median by iterating through the PriorityQueue if the median is in one of the PriorityQueue.\\n\\n***Java Sample Code***\\n```\\nclass MedianFinder {\\n    int[] arr;\\n    int size;\\n    PriorityQueue<Integer> lo;\\n    PriorityQueue<Integer> hi;\\n    /** initialize your data structure here. */\\n    public MedianFinder() {\\n        arr = new int[101];\\n        size = 0;\\n        lo = new PriorityQueue<Integer>();\\n        hi = new PriorityQueue<Integer>();\\n    }\\n    \\n    public void addNum(int num) {\\n        if(num < 0) lo.add(num);\\n        else if(num > 100) hi.add(num);\\n        else arr[num]++;\\n        size++;\\n    };\\n    \\n    public double findMedian() {\\n        int median = size / 2, index;\\n        PriorityQueue<Integer> temp;\\n        // If total size is odd number\\n        if(size % 2 != 0) {\\n            if(median < lo.size()) {\\n                // The median is in lo\\n\\t\\t\\t\\t// Todo:\\n            }\\n            else if(median >= size - hi.size()) {\\n                // The median is in hi\\n\\t\\t\\t\\t// Todo:\\n            } \\n            else {\\n                // The median is in arr\\n\\t\\t\\t\\t// Todo:\\n            }\\n        } // If total size is even number\\n        else {\\n            int a, b;\\n            if(median < lo.size()) {\\n                temp = new PrirotyQueue<>(lo);\\n                index = 0;\\n                while(index < median) {\\n                    if(index == median - 1) {\\n                        a = temp.poll();\\n                        b = temp.poll();\\n                        return (a + b) / 2.0;\\n                    } else {\\n                        temp.poll();    \\n                        index++;\\n                    }\\n                }\\n            } else if(median == lo.size()) {\\n                int last = 0;\\n                temp = new PrirotyQueue<>(lo);\\n                while(!temp.isEmpty()) last = temp.poll();\\n                for(int i = 0; i < 101; i++)\\n                    if(arr[i] != 0) \\n                        return (i + last) / 2.0;\\n            } else if(median > size - hi.size()) {\\n                temp = new PrirotyQueue<>(hi);\\n                index = size - hi.size();\\n                while(index < median) {\\n                    if(index == median - 1) {\\n                        a = temp.poll();\\n                        b = temp.poll();\\n                        return (a + b) / 2.0;\\n                    } else {\\n                        temp.poll();\\n                        index++;\\n                    }\\n                }\\n            } else if(median == size - hi.size()) {\\n                int first = hi.peek();\\n                for(int i = 100; i >= 0; i--)\\n                    if(arr[i] != 0)\\n                        return (i + first) / 2.0;                \\n            } else {\\n                // The median is in arr\\n\\t\\t\\t\\t// Todo:\\n            }\\n        }\\n        return 0.0;\\n    }\\n}\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder obj = new MedianFinder();\\n * obj.addNum(num);\\n * double param_2 = obj.findMedian();\\n */\\n ```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MedianFinder {\\n    int[] arr;\\n    int size;\\n    /** initialize your data structure here. */\\n    public MedianFinder() {\\n        arr = new int[101];\\n        size = 0;\\n    }\\n    \\n    public void addNum(int num) {\\n        arr[num]++;\\n        size++;\\n    }\\n    \\n    public double findMedian() {\\n        int index = 0, median = size / 2, first = 0;\\n        for(int i = 0; i < 101; i++) {\\n            for(int j = 0; j < arr[i]; j++) {\\n                if(index == median - 1) first = i;\\n                else if(index == median) {\\n                    if(size % 2 == 0) return (first + i) / 2.0;\\n                    else return (double) i;\\n                }\\n                index++;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass MedianFinder {\\n    int[] arr;\\n    int size;\\n    int lo;\\n    /** initialize your data structure here. */\\n    public MedianFinder() {\\n        arr = new int[101];\\n        size = 0;\\n        lo = 0;\\n    }\\n    \\n    public void addNum(int num) {\\n        if(num < 0) lo++;\\n        else if(num <= 100 && num >= 0) arr[num]++;\\n        size++;\\n    }\\n    \\n    public double findMedian() {\\n        int index = lo, median = size / 2, first = 0;\\n        for(int i = 0; i < 101; i++) {\\n            for(int j = 0; j < arr[i]; j++) {\\n                if(index == median - 1) first = i;\\n                else if(index == median) {\\n                    if(size % 2 == 0) return (first + i) / 2.0;\\n                    else return (double) i;\\n                }\\n                index++;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass MedianFinder {\\n    int[] arr;\\n    int size;\\n    PriorityQueue<Integer> lo;\\n    PriorityQueue<Integer> hi;\\n    /** initialize your data structure here. */\\n    public MedianFinder() {\\n        arr = new int[101];\\n        size = 0;\\n        lo = new PriorityQueue<Integer>();\\n        hi = new PriorityQueue<Integer>();\\n    }\\n    \\n    public void addNum(int num) {\\n        if(num < 0) lo.add(num);\\n        else if(num > 100) hi.add(num);\\n        else arr[num]++;\\n        size++;\\n    };\\n    \\n    public double findMedian() {\\n        int median = size / 2, index;\\n        PriorityQueue<Integer> temp;\\n        // If total size is odd number\\n        if(size % 2 != 0) {\\n            if(median < lo.size()) {\\n                // The median is in lo\\n\\t\\t\\t\\t// Todo:\\n            }\\n            else if(median >= size - hi.size()) {\\n                // The median is in hi\\n\\t\\t\\t\\t// Todo:\\n            } \\n            else {\\n                // The median is in arr\\n\\t\\t\\t\\t// Todo:\\n            }\\n        } // If total size is even number\\n        else {\\n            int a, b;\\n            if(median < lo.size()) {\\n                temp = new PrirotyQueue<>(lo);\\n                index = 0;\\n                while(index < median) {\\n                    if(index == median - 1) {\\n                        a = temp.poll();\\n                        b = temp.poll();\\n                        return (a + b) / 2.0;\\n                    } else {\\n                        temp.poll();    \\n                        index++;\\n                    }\\n                }\\n            } else if(median == lo.size()) {\\n                int last = 0;\\n                temp = new PrirotyQueue<>(lo);\\n                while(!temp.isEmpty()) last = temp.poll();\\n                for(int i = 0; i < 101; i++)\\n                    if(arr[i] != 0) \\n                        return (i + last) / 2.0;\\n            } else if(median > size - hi.size()) {\\n                temp = new PrirotyQueue<>(hi);\\n                index = size - hi.size();\\n                while(index < median) {\\n                    if(index == median - 1) {\\n                        a = temp.poll();\\n                        b = temp.poll();\\n                        return (a + b) / 2.0;\\n                    } else {\\n                        temp.poll();\\n                        index++;\\n                    }\\n                }\\n            } else if(median == size - hi.size()) {\\n                int first = hi.peek();\\n                for(int i = 100; i >= 0; i--)\\n                    if(arr[i] != 0)\\n                        return (i + first) / 2.0;                \\n            } else {\\n                // The median is in arr\\n\\t\\t\\t\\t// Todo:\\n            }\\n        }\\n        return 0.0;\\n    }\\n}\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder obj = new MedianFinder();\\n * obj.addNum(num);\\n * double param_2 = obj.findMedian();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 697434,
                "title": "java-multiset-treemap-solution-without-storing-all-values",
                "content": "The idea is to maintain a TreeMap<Number, Count> and a mid value along with its relative index to it\\'s count.\\nEach time a number is added the relative index is incremented or decremented.\\n\\nFor example if we have numbers 10, 10, 10, 15, **15**, 15, 20, 20, 20\\nThe map contains:\\n10: 3\\n15: 3\\n20: 3\\nmid value is 15 and the relative index is 1 (pointing to the second 15)\\n\\nWhen another 20 is added it becomes\\nmap:\\n10: 3\\n15: 3\\n20: 4\\nmid value is still 15 and the relative index is 2 (pointing to the third 15)\\n\\nAnother 20:\\n10: 3\\n15: 3\\n20: 5\\nmid value is still 20 and the relative index is 0 (pointing to the first 20)\\n\\n```\\nclass MedianFinder {\\n\\n    private final TreeMap<Integer, Integer> tree = new TreeMap<>();\\n    private int totalCount;\\n\\n    private int midValue;\\n    private int midIndex;\\n\\n    /** initialize your data structure here. */\\n    public MedianFinder() {\\n    }\\n\\n    public void addNum(int num) {\\n        tree.put(num, tree.getOrDefault(num, 0) + 1);\\n        totalCount++;\\n\\n        if (totalCount == 1) {\\n            midValue = num;\\n            midIndex = 0;\\n        } else {\\n            if (num >= midValue) {\\n                midIndex++;\\n                if (midIndex / 2 >= tree.get(midValue)) {\\n                    midValue = tree.higherKey(midValue);\\n                    midIndex = 0;\\n                }\\n            } else {\\n                midIndex--;\\n                if (midIndex < 0) {\\n                    midValue = tree.lowerKey(midValue);\\n                    midIndex = tree.get(midValue) * 2 - 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    public double findMedian() {\\n        if (totalCount % 2 == 0 && (midIndex + 1) / 2 >= tree.get(midValue)) {\\n            int nextMidValue = tree.higherKey(midValue);\\n            return (midValue + nextMidValue) / 2d;\\n        } else {\\n            return midValue;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MedianFinder {\\n\\n    private final TreeMap<Integer, Integer> tree = new TreeMap<>();\\n    private int totalCount;\\n\\n    private int midValue;\\n    private int midIndex;\\n\\n    /** initialize your data structure here. */\\n    public MedianFinder() {\\n    }\\n\\n    public void addNum(int num) {\\n        tree.put(num, tree.getOrDefault(num, 0) + 1);\\n        totalCount++;\\n\\n        if (totalCount == 1) {\\n            midValue = num;\\n            midIndex = 0;\\n        } else {\\n            if (num >= midValue) {\\n                midIndex++;\\n                if (midIndex / 2 >= tree.get(midValue)) {\\n                    midValue = tree.higherKey(midValue);\\n                    midIndex = 0;\\n                }\\n            } else {\\n                midIndex--;\\n                if (midIndex < 0) {\\n                    midValue = tree.lowerKey(midValue);\\n                    midIndex = tree.get(midValue) * 2 - 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    public double findMedian() {\\n        if (totalCount % 2 == 0 && (midIndex + 1) / 2 >= tree.get(midValue)) {\\n            int nextMidValue = tree.higherKey(midValue);\\n            return (midValue + nextMidValue) / 2d;\\n        } else {\\n            return midValue;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 692987,
                "title": "c-fastest-priorityqueue",
                "content": "After searching a lot and do my bench-marking I use this implementation which is faster than any PriorityQueue I\\'ve seen. even faster than C5.IntervalHeap().\\n[my Submission](https://leetcode.com/submissions/detail/355137471/)\\n```\\n//A binary heap impelemntation\\npublic class PriorityQueue<T> {\\n    private readonly List<T> list;\\n    private readonly IComparer<T> comparer;\\n\\t\\n    public PriorityQueue(IComparer<T> comparer = null) {\\n        this.comparer = comparer ?? Comparer<T>.Default;\\n        this.list = new List<T>();\\n    }\\n\\t//O(Log N)\\n    public void Add(T x) {\\n        list.Add(x);\\n\\t\\t\\n        var child = Count - 1;\\n        while (child > 0){ // child index; start at end\\n            int parent = (child - 1) / 2;// parent index\\n            // child item is larger than (or equal) parent so we\\'re done\\n            if (comparer.Compare(list[parent], x) <= 0) break;\\n            list[child] = list[parent];\\n            child = parent;\\n        }\\n        if (Count > 0) list[child] = x;\\n    }\\n\\n    public T Peek() => list[0];\\n\\t//O(Log N)\\n    public T Poll() {\\n        var ret = Peek();\\n        var root = list[Count - 1];\\n        list.RemoveAt(Count - 1);\\n        var i = 0;//parent\\n        while (i * 2 + 1 < Count) {\\n            var left = 2 * i + 1; //left child\\n            if (left > Count) break;  // no children so we\\'re done\\n            var right = 2 * i + 2; // right child\\n            var c = right < Count && comparer.Compare(list[right], list[left]) < 0 ? right : left;\\n            if (comparer.Compare(list[c], root) >= 0) break;\\n            list[i] = list[c];\\n            i = c;\\n        }\\n        if (Count > 0) list[i] = root;\\n        return ret;\\n    }\\n\\t\\n    public int Count => list.Count;//Count is cached in List implelemtation\\n\\t\\n    public void DisplayHeap() => list.ForEach(x => Console.WriteLine(x));\\n}\\n```\\nand here\\'s a usage of it:\\n```\\npublic class MedianFinder {\\n\\n    private readonly PriorityQueue<int> small;\\n    private readonly PriorityQueue<int> large;\\n    \\n    public MedianFinder() {\\n        var maxComparer = Comparer<int>.Create((x, y) => y.CompareTo(x));\\n        small = new PriorityQueue<int>();\\n        large = new PriorityQueue<int>(maxComparer);\\n    }\\n    \\n   public void AddNum(int num) {\\n        large.Add(num);\\n        small.Add(large.Poll());\\n        if (large.Count < small.Count)\\n            large.Add(small.Poll());\\n    }\\n\\n    public double FindMedian() {\\n        return large.Count > small.Count\\n           ? large.Peek()\\n           : (large.Peek() + small.Peek()) / 2.0;\\n    }\\n}\\n```\\n\\nIt\\'s possible to implement PriorityQueue using a SortSet:\\n```\\n public class PQ {\\n     private struct HeapKey{\\n         public int Value;\\n         public int Index;\\n     }\\n     \\n    private readonly SortedSet<HeapKey> _set;\\n    private int index;\\n    public PQ(Comparer<int> comparer = null){\\n        comparer = comparer ?? Comparer<int>.Default;\\n        _set = new SortedSet<HeapKey>(\\n            Comparer<HeapKey>.Create((x, y) => \\n                        comparer.Compare(x.Value, y.Value) == 0 ?\\n                        x.Index - y.Index :\\n                        comparer.Compare(x.Value, y.Value))\\n        );\\n    }\\n    \\n    public void Add(int num){\\n        _set.Add(new HeapKey{Value= num, Index = index++});\\n    }\\n    \\n    public int Peek(){\\n        return _set.First().Value;\\n    }\\n     \\n     public int Pop(){\\n         var item = _set.First();\\n         _set.Remove(item);\\n        return item.Value;\\n    }\\n     \\n    public int Count => _set.Count;\\n     \\n }     \\n```",
                "solutionTags": [
                    "Binary Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n//A binary heap impelemntation\\npublic class PriorityQueue<T> {\\n    private readonly List<T> list;\\n    private readonly IComparer<T> comparer;\\n\\t\\n    public PriorityQueue(IComparer<T> comparer = null) {\\n        this.comparer = comparer ?? Comparer<T>.Default;\\n        this.list = new List<T>();\\n    }\\n\\t//O(Log N)\\n    public void Add(T x) {\\n        list.Add(x);\\n\\t\\t\\n        var child = Count - 1;\\n        while (child > 0){ // child index; start at end\\n            int parent = (child - 1) / 2;// parent index\\n            // child item is larger than (or equal) parent so we\\'re done\\n            if (comparer.Compare(list[parent], x) <= 0) break;\\n            list[child] = list[parent];\\n            child = parent;\\n        }\\n        if (Count > 0) list[child] = x;\\n    }\\n\\n    public T Peek() => list[0];\\n\\t//O(Log N)\\n    public T Poll() {\\n        var ret = Peek();\\n        var root = list[Count - 1];\\n        list.RemoveAt(Count - 1);\\n        var i = 0;//parent\\n        while (i * 2 + 1 < Count) {\\n            var left = 2 * i + 1; //left child\\n            if (left > Count) break;  // no children so we\\'re done\\n            var right = 2 * i + 2; // right child\\n            var c = right < Count && comparer.Compare(list[right], list[left]) < 0 ? right : left;\\n            if (comparer.Compare(list[c], root) >= 0) break;\\n            list[i] = list[c];\\n            i = c;\\n        }\\n        if (Count > 0) list[i] = root;\\n        return ret;\\n    }\\n\\t\\n    public int Count => list.Count;//Count is cached in List implelemtation\\n\\t\\n    public void DisplayHeap() => list.ForEach(x => Console.WriteLine(x));\\n}\\n```\n```\\npublic class MedianFinder {\\n\\n    private readonly PriorityQueue<int> small;\\n    private readonly PriorityQueue<int> large;\\n    \\n    public MedianFinder() {\\n        var maxComparer = Comparer<int>.Create((x, y) => y.CompareTo(x));\\n        small = new PriorityQueue<int>();\\n        large = new PriorityQueue<int>(maxComparer);\\n    }\\n    \\n   public void AddNum(int num) {\\n        large.Add(num);\\n        small.Add(large.Poll());\\n        if (large.Count < small.Count)\\n            large.Add(small.Poll());\\n    }\\n\\n    public double FindMedian() {\\n        return large.Count > small.Count\\n           ? large.Peek()\\n           : (large.Peek() + small.Peek()) / 2.0;\\n    }\\n}\\n```\n```\\n public class PQ {\\n     private struct HeapKey{\\n         public int Value;\\n         public int Index;\\n     }\\n     \\n    private readonly SortedSet<HeapKey> _set;\\n    private int index;\\n    public PQ(Comparer<int> comparer = null){\\n        comparer = comparer ?? Comparer<int>.Default;\\n        _set = new SortedSet<HeapKey>(\\n            Comparer<HeapKey>.Create((x, y) => \\n                        comparer.Compare(x.Value, y.Value) == 0 ?\\n                        x.Index - y.Index :\\n                        comparer.Compare(x.Value, y.Value))\\n        );\\n    }\\n    \\n    public void Add(int num){\\n        _set.Add(new HeapKey{Value= num, Index = index++});\\n    }\\n    \\n    public int Peek(){\\n        return _set.First().Value;\\n    }\\n     \\n     public int Pop(){\\n         var item = _set.First();\\n         _set.Remove(item);\\n        return item.Value;\\n    }\\n     \\n    public int Count => _set.Count;\\n     \\n }     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 573064,
                "title": "neat-c-solution-using-the-framework-binarysearch",
                "content": "```\\npublic class MedianFinder\\n    {\\n        private readonly List<int> store;\\n\\n        public MedianFinder()\\n        {\\n            store = new List<int, int>();\\n        }\\n\\n        public void AddNum(int num)\\n        {\\n            int index = store.BinarySearch(num);\\n            // If value is not found and value is less than one or more elements in array,\\n            // the negative number returned is the bitwise complement of the index of the first element that is larger than value.\\n            index = index >= 0 ? index : ~index;\\n            store.Insert(index, num);\\n        }\\n\\n        public double FindMedian()\\n        {\\n            int count = store.Count;\\n            return count % 2 != 0 ? \\n                store[count / 2] : \\n                ((double)(store[count / 2 - 1] + store[count / 2])) / 2;\\n        }\\n    }\\n```\\n\\t",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\npublic class MedianFinder\\n    {\\n        private readonly List<int> store;\\n\\n        public MedianFinder()\\n        {\\n            store = new List<int, int>();\\n        }\\n\\n        public void AddNum(int num)\\n        {\\n            int index = store.BinarySearch(num);\\n            // If value is not found and value is less than one or more elements in array,\\n            // the negative number returned is the bitwise complement of the index of the first element that is larger than value.\\n            index = index >= 0 ? index : ~index;\\n            store.Insert(index, num);\\n        }\\n\\n        public double FindMedian()\\n        {\\n            int count = store.Count;\\n            return count % 2 != 0 ? \\n                store[count / 2] : \\n                ((double)(store[count / 2 - 1] + store[count / 2])) / 2;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 228442,
                "title": "java-solution-with-tree-o-log-n-insertion-and-lookup-explanation",
                "content": "The intution behind the solution is pretty straightforward. We will get a random stream of numbers. We want to repeateadly find median from this stream. \\nThis tells us we need to store the numbers sorted in some DS where insert and find middle is fairly quick. This leads me to Priority Queue and Tree. \\n\\nI personally prefered implementing Tree since Queue solution felt quiet simple to me and would not make an interviewer very happy (IMHO).\\n\\nNow I am adding 2 extra fields at every node along with the usual value, left and right: leftCount, rightCount. This helps me in findMedian if i want to get to index 5 and root\\'s left has 2 nodes i can just go to right directly.\\n\\nNode object used for Tree:\\n\\n```private class Node {\\n        private int value;\\n        private Node left;\\n        private Node right;\\n        private int leftCount;\\n        private int rightCount;\\n\\n        public Node(int value) {\\n            this.value = value;\\n        }\\n    }\\n```\\n\\nAdd an element:\\nWe compare to root and then either go left or right depending on value comparison. Whichever direction we go, we increment the counter.\\n\\n```\\n    private Node root;\\n    public void addNum(int num) {\\n        if (root == null) {\\n            root = new Node(num);\\n        } else {\\n            addNode(root, num);\\n        }\\n    }\\n\\t\\n\\tprivate void addNode(Node root, int num) {\\n        if (root.value < num) {\\n            root.rightCount++;\\n            if (root.right == null) {\\n                root.right = new Node(num);\\n            } else {\\n                addNode(root.right, num);\\n            }\\n        } else {\\n            root.leftCount++;\\n            if (root.left == null) {\\n                root.left = new Node(num);\\n            } else {\\n                addNode(root.left, num);\\n            }\\n        }\\n    }\\n```\\n\\t\\nFind Median:\\nWe keep an indexSoFar variable which tells us the current node index if left==null. \\n```\\npublic double findMedian() {\\n        if (root == null) {\\n            throw new RuntimeException(\"No element present\");\\n        }\\n\\n        int size = root.leftCount + root.rightCount + 1;\\n        double value;\\n        if (size % 2 == 0) {\\n            value = (double) findNode(size / 2 - 1) / 2;\\n            value += (double) findNode(size / 2) / 2;\\n        } else {\\n            value = findNode(size / 2);\\n        }\\n\\n        return value;\\n    }\\n\\t\\n\\tprivate int findNode(int indexToReturn) {\\n        int indexSoFar = 0;\\n        Node node = root;\\n\\n        while (node != null) {\\n\\t\\t   // Reached Index, return current\\n            if (indexSoFar + node.leftCount == indexToReturn) {\\n                return node.value;\\n            } \\n\\t\\t\\t// Index is on left, go to left\\n\\t\\t\\telse if (indexSoFar + node.leftCount > indexToReturn) {\\n                node = node.left;\\n            } \\n\\t\\t\\t// Index is on right, go to right\\n\\t\\t\\telse {\\n                indexSoFar += node.leftCount + 1;\\n                node = node.right;\\n            }\\n        }\\n\\n        // This should never happen\\n        throw new RuntimeException(\"Something is wrong with FindNode. Looking for index: \" + indexToReturn);\\n    }\\n```\\n\\nA few improvisations can be done to make findMedian O(1):\\n- Tree can be rebalanced perodically - maybe asyncronously. This will bring median much closer to root.\\n- Do not necessarily need to keep right count. That can be removed if we keep size variable at global level.\\n- For even scenarios we can optimize so we dont have to perform find size/2-1 and size/2 seperately - fairly straightforward.",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```private class Node {\\n        private int value;\\n        private Node left;\\n        private Node right;\\n        private int leftCount;\\n        private int rightCount;\\n\\n        public Node(int value) {\\n            this.value = value;\\n        }\\n    }\\n```\n```\\n    private Node root;\\n    public void addNum(int num) {\\n        if (root == null) {\\n            root = new Node(num);\\n        } else {\\n            addNode(root, num);\\n        }\\n    }\\n\\t\\n\\tprivate void addNode(Node root, int num) {\\n        if (root.value < num) {\\n            root.rightCount++;\\n            if (root.right == null) {\\n                root.right = new Node(num);\\n            } else {\\n                addNode(root.right, num);\\n            }\\n        } else {\\n            root.leftCount++;\\n            if (root.left == null) {\\n                root.left = new Node(num);\\n            } else {\\n                addNode(root.left, num);\\n            }\\n        }\\n    }\\n```\n```\\npublic double findMedian() {\\n        if (root == null) {\\n            throw new RuntimeException(\"No element present\");\\n        }\\n\\n        int size = root.leftCount + root.rightCount + 1;\\n        double value;\\n        if (size % 2 == 0) {\\n            value = (double) findNode(size / 2 - 1) / 2;\\n            value += (double) findNode(size / 2) / 2;\\n        } else {\\n            value = findNode(size / 2);\\n        }\\n\\n        return value;\\n    }\\n\\t\\n\\tprivate int findNode(int indexToReturn) {\\n        int indexSoFar = 0;\\n        Node node = root;\\n\\n        while (node != null) {\\n\\t\\t   // Reached Index, return current\\n            if (indexSoFar + node.leftCount == indexToReturn) {\\n                return node.value;\\n            } \\n\\t\\t\\t// Index is on left, go to left\\n\\t\\t\\telse if (indexSoFar + node.leftCount > indexToReturn) {\\n                node = node.left;\\n            } \\n\\t\\t\\t// Index is on right, go to right\\n\\t\\t\\telse {\\n                indexSoFar += node.leftCount + 1;\\n                node = node.right;\\n            }\\n        }\\n\\n        // This should never happen\\n        throw new RuntimeException(\"Something is wrong with FindNode. Looking for index: \" + indexToReturn);\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 74098,
                "title": "java-solution-using-bst-with-explanation-beats-99-at-time-of-posting",
                "content": "The idea is to use a BST to store the stream of integers. When adding nodes to the tree, we keep a pointer to the median node (middle node if odd number of elements, smaller of the two middle nodes if even number of elements).\\n\\nTwo helper functions - getNext and getPrev, allow us to update the median node.\\n\\nWhen should the median node be updated? Only two cases, both considering we have just added a node to the BST:\\n\\n1) We have an even number of elements, and the value added was less than the median value.\\n\\n2) We have an odd number of elements, and the value added was higher or equal to the median value.\\n\\n```\\nclass Node {\\n    int val;\\n    Node right;\\n    Node left;\\n    Node parent;\\n    public Node(int val){this.val = val;}\\n}\\n\\npublic class MedianFinder {\\n    Node tree;\\n    Node medianNode;\\n    int numElements = 0;\\n    boolean addedLower = false;\\n    \\n    // Adds a number into the data structure.\\n    public void addNum(int num) {\\n        Node newNode = new Node(num);\\n        addNode(tree, newNode);\\n        numElements++;\\n        if (num < medianNode.val){\\n            addedLower = true;\\n        } else {\\n            addedLower = false;\\n        }\\n        updateMedianNode();\\n    }\\n\\n    // Returns the median of current data stream\\n    public double findMedian() {\\n        // even number of elements\\n        if (numElements % 2 == 0){\\n            double num1 = medianNode.val;\\n            double num2 = getNext(medianNode).val;\\n            return (num1+num2)/2.0;\\n        }\\n        // odd number of elements\\n        return medianNode.val;\\n    }\\n    \\n    // add node to BST\\n    private void addNode(Node curr, Node newNode){\\n        if (curr == null){\\n            tree = newNode;\\n            medianNode = tree;\\n            return;\\n        }\\n        if (curr.val > newNode.val){\\n            if (curr.left == null){\\n                curr.left = newNode;\\n                curr.left.parent = curr;\\n            } else {\\n                addNode(curr.left, newNode);\\n            }\\n        } else if (curr.val <= newNode.val){\\n            if (curr.right == null){\\n                curr.right = newNode;\\n                curr.right.parent = curr;\\n            } else {\\n                addNode(curr.right, newNode);   \\n            }\\n        }\\n    }\\n    \\n    // keep pointing to median\\n    private void updateMedianNode(){\\n        if (numElements == 1){\\n            return;\\n        }\\n        if (addedLower && numElements % 2 == 0){\\n            medianNode = getPrev(medianNode);\\n            return;\\n        }\\n        if (!addedLower && numElements % 2 == 1){\\n            medianNode = getNext(medianNode);\\n        }\\n    }\\n    \\n    // get the inorder succesor\\n    private Node getNext(Node curr){\\n        if (curr.right != null){\\n            curr = curr.right;\\n            while (curr.left != null){\\n                curr = curr.left;\\n            }\\n            return curr;\\n        } else {\\n            Node parent = curr.parent;\\n            while (parent != null && parent.left != curr){\\n                curr = parent;\\n                parent = curr.parent;\\n            }\\n            return parent;\\n        }\\n        \\n    }\\n    \\n    // get the inorder predecessor\\n    private Node getPrev(Node curr){\\n        if (curr.left != null){\\n            curr = curr.left;\\n            while (curr.right != null){\\n                curr = curr.right;\\n            }\\n            return curr;\\n        } else {\\n            Node parent = curr.parent;\\n            while (parent != null && parent.right != curr){\\n                curr = parent;\\n                parent = curr.parent;\\n            }\\n            return parent;\\n        }\\n    }\\n};\\n\\n// Your MedianFinder object will be instantiated and called as such:\\n// MedianFinder mf = new MedianFinder();\\n// mf.addNum(1);\\n// mf.findMedian();\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node {\\n    int val;\\n    Node right;\\n    Node left;\\n    Node parent;\\n    public Node(int val){this.val = val;}\\n}\\n\\npublic class MedianFinder {\\n    Node tree;\\n    Node medianNode;\\n    int numElements = 0;\\n    boolean addedLower = false;\\n    \\n    // Adds a number into the data structure.\\n    public void addNum(int num) {\\n        Node newNode = new Node(num);\\n        addNode(tree, newNode);\\n        numElements++;\\n        if (num < medianNode.val){\\n            addedLower = true;\\n        } else {\\n            addedLower = false;\\n        }\\n        updateMedianNode();\\n    }\\n\\n    // Returns the median of current data stream\\n    public double findMedian() {\\n        // even number of elements\\n        if (numElements % 2 == 0){\\n            double num1 = medianNode.val;\\n            double num2 = getNext(medianNode).val;\\n            return (num1+num2)/2.0;\\n        }\\n        // odd number of elements\\n        return medianNode.val;\\n    }\\n    \\n    // add node to BST\\n    private void addNode(Node curr, Node newNode){\\n        if (curr == null){\\n            tree = newNode;\\n            medianNode = tree;\\n            return;\\n        }\\n        if (curr.val > newNode.val){\\n            if (curr.left == null){\\n                curr.left = newNode;\\n                curr.left.parent = curr;\\n            } else {\\n                addNode(curr.left, newNode);\\n            }\\n        } else if (curr.val <= newNode.val){\\n            if (curr.right == null){\\n                curr.right = newNode;\\n                curr.right.parent = curr;\\n            } else {\\n                addNode(curr.right, newNode);   \\n            }\\n        }\\n    }\\n    \\n    // keep pointing to median\\n    private void updateMedianNode(){\\n        if (numElements == 1){\\n            return;\\n        }\\n        if (addedLower && numElements % 2 == 0){\\n            medianNode = getPrev(medianNode);\\n            return;\\n        }\\n        if (!addedLower && numElements % 2 == 1){\\n            medianNode = getNext(medianNode);\\n        }\\n    }\\n    \\n    // get the inorder succesor\\n    private Node getNext(Node curr){\\n        if (curr.right != null){\\n            curr = curr.right;\\n            while (curr.left != null){\\n                curr = curr.left;\\n            }\\n            return curr;\\n        } else {\\n            Node parent = curr.parent;\\n            while (parent != null && parent.left != curr){\\n                curr = parent;\\n                parent = curr.parent;\\n            }\\n            return parent;\\n        }\\n        \\n    }\\n    \\n    // get the inorder predecessor\\n    private Node getPrev(Node curr){\\n        if (curr.left != null){\\n            curr = curr.left;\\n            while (curr.right != null){\\n                curr = curr.right;\\n            }\\n            return curr;\\n        } else {\\n            Node parent = curr.parent;\\n            while (parent != null && parent.right != curr){\\n                curr = parent;\\n                parent = curr.parent;\\n            }\\n            return parent;\\n        }\\n    }\\n};\\n\\n// Your MedianFinder object will be instantiated and called as such:\\n// MedianFinder mf = new MedianFinder();\\n// mf.addNum(1);\\n// mf.findMedian();\\n```",
                "codeTag": "Java"
            },
            {
                "id": 74131,
                "title": "solution-using-std-multiset-and-two-iterators",
                "content": "Here is a solution using C++11 std::multiset.\\nIt keep two iterators synchronized on lower and upper median.\\nIt relies on the specification of C++11 multiset#insert that states that insertions of keys occurs at the upper bound of the range of keys with same values.\\n\\n    class MedianFinder {\\n        std::multiset<int> data;\\n        std::multiset<int>::iterator low_median, up_median;\\n    public:\\n        MedianFinder() : low_median(data.end()), up_median(data.end()) {}\\n    \\n        // Adds a number into the data structure.\\n        void addNum(int num) {\\n            // keep size BEFORE insertion\\n            const size_t n = data.size();\\n            \\n            // do the insertion; we need the element in place to make\\n            // sure our iterator shifting will point to it if necessary\\n            data.insert(num);\\n            \\n            if (!n) {\\n                // no elements before; use the new data at single median\\n                low_median = up_median = data.begin();\\n            } else if (n & 1) {\\n                // odd size, low and up median are the same point\\n                if (num < *up_median) {\\n                    // num went on left side of single median, we use the \\n                    // predecessor  of the median as the new low median\\n                    --low_median;\\n                } else { // num >= up\\n                    // num wen on the right side of single median, use the \\n                    // successor of median as new up\\n                    ++up_median;\\n                }\\n            } else {\\n                // even size, we have two different low and up median\\n                if (num > *low_median && num < *up_median) {\\n                    // we are in-between, by definition the new value \\n                    // is the new single median\\n                    ++low_median;\\n                    --up_median;\\n                } else if (num >= *up_median) {\\n                    // since C++11, insert will put the new value at\\n                    // end of range of values equal to up_median if num \\n                    // is equal to up_median; if greater it will also\\n                    // be to the right. So right side has one item more:\\n                    ++low_median;\\n                } else { // num <= low_median < up_median\\n                    // since C++11, insert will put the new value at\\n                    // end of rand; so low_median iterator may not be\\n                    // valid anymore; we use the decremented up_median\\n                    low_median = --up_median;\\n                }\\n            }\\n        }\\n    \\n        // Returns the median of current data stream\\n        double findMedian() {\\n            return 0.5 * (static_cast<double>(*low_median) + *up_median);\\n        }\\n    };\\n    \\n    // Your MedianFinder object will be instantiated and called as such:\\n    // MedianFinder mf;\\n    // mf.addNum(1);\\n    // mf.findMedian();",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "Here is a solution using C++11 std::multiset.\\nIt keep two iterators synchronized on lower and upper median.\\nIt relies on the specification of C++11 multiset#insert that states that insertions of keys occurs at the upper bound of the range of keys with same values.\\n\\n    class MedianFinder {\\n        std::multiset<int> data;\\n        std::multiset<int>::iterator low_median, up_median;\\n    public:\\n        MedianFinder() : low_median(data.end()), up_median(data.end()) {}\\n    \\n        // Adds a number into the data structure.\\n        void addNum(int num) {\\n            // keep size BEFORE insertion\\n            const size_t n = data.size();\\n            \\n            // do the insertion; we need the element in place to make\\n            // sure our iterator shifting will point to it if necessary\\n            data.insert(num);\\n            \\n            if (!n) {\\n                // no elements before; use the new data at single median\\n                low_median = up_median = data.begin();\\n            } else if (n & 1) {\\n                // odd size, low and up median are the same point\\n                if (num < *up_median) {\\n                    // num went on left side of single median, we use the \\n                    // predecessor  of the median as the new low median\\n                    --low_median;\\n                } else { // num >= up\\n                    // num wen on the right side of single median, use the \\n                    // successor of median as new up\\n                    ++up_median;\\n                }\\n            } else {\\n                // even size, we have two different low and up median\\n                if (num > *low_median && num < *up_median) {\\n                    // we are in-between, by definition the new value \\n                    // is the new single median\\n                    ++low_median;\\n                    --up_median;\\n                } else if (num >= *up_median) {\\n                    // since C++11, insert will put the new value at\\n                    // end of range of values equal to up_median if num \\n                    // is equal to up_median; if greater it will also\\n                    // be to the right. So right side has one item more:\\n                    ++low_median;\\n                } else { // num <= low_median < up_median\\n                    // since C++11, insert will put the new value at\\n                    // end of rand; so low_median iterator may not be\\n                    // valid anymore; we use the decremented up_median\\n                    low_median = --up_median;\\n                }\\n            }\\n        }\\n    \\n        // Returns the median of current data stream\\n        double findMedian() {\\n            return 0.5 * (static_cast<double>(*low_median) + *up_median);\\n        }\\n    };\\n    \\n    // Your MedianFinder object will be instantiated and called as such:\\n    // MedianFinder mf;\\n    // mf.addNum(1);\\n    // mf.findMedian();",
                "codeTag": "Java"
            },
            {
                "id": 2233100,
                "title": "c-easy-to-understand-fully-commented-explanation-too",
                "content": "Here our main objective is we want the middle element/s(we are not interested in other elements as soon as we get middle one/s) . So we can do it in array but every time we encounter new element we have to fix its position in sorted order which will take O(N) time which seems normal but for a stream of data it is a hell lot of processing. \\nNow thinking of this case we can think of priority queues because it guarantees getMin and getMax in O(1) time if some how we just make middle on top(min/max) we can solve this problem.\\nSo here we can put constratint that the min heap\\'s smallest element should be gerater than or equal to max element of max heap , we are putting this becoz later on if we want the top elements of any heap we can get the middle ones only.\\nTo maintain this we will also ensure that the heaps are balanced in terms of size(no. of elements) (i.e., their size should not differ by more than 1 unit).\\n***To sum up we can achieve this by following below steps:\\n1) Use min heap and max heap.\\n2) the max of max heap should be less than or equal to min of min heap.\\n3) keep the heaps balanced(only diff of 1 unit is allowed).***\\n```\\nclass MedianFinder {\\npublic:\\n    // we will use heaps (min and max) to get the median using . We will try to keep them balanced on basis of their size so that at    end we will have the medians at top.\\n    // we are not interested in other numbers just the middle one thats why using heap combo of min and max .\\n\\t// we are using min and max beacuse we will maintain our heaps in a way that max of max heap will always be lesser than equal to min of min Heap in this way we be able to get the medians\\n    priority_queue<int,vector<int>,greater<int>> minH;\\n    priority_queue<int> maxH;\\n    MedianFinder() {}\\n    \\n    void addNum(int num) {\\n        // we are trying to maintain a stream i.e., maxH.top() <= minH.top() in that way only we can assure the medians\\n        if(maxH.empty() || num<maxH.top()){\\n            maxH.push(num);\\n        }\\n        // incase we encounter greater number than the one present in maxH we need to add it in minH \\n        else{\\n            minH.push(num);\\n        }\\n        // we are trying to balance our heaps the max diff of size can be only 1\\n        // therefore popping the extra from that heap and pushing that in the other one\\n        if(maxH.size()>minH.size()+1){\\n            minH.push(maxH.top());\\n            maxH.pop();\\n        }\\n        else if(minH.size()>maxH.size()+1){\\n            maxH.push(minH.top());\\n            minH.pop();\\n        }\\n    }\\n    \\n    double findMedian() {\\n        // this operation is going to be O(1)\\n        // incase of even entries\\n        if(maxH.size() == minH.size()){\\n            // we will find mean of middle 2 entries and return \\n            return (maxH.top() + minH.top()) / 2.0;\\n        }\\n        // incase of odd entries:\\n        // our median will be present in that heap which has greater size\\n        else{\\n            return maxH.size() > minH.size() ? maxH.top() : minH.top();\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder* obj = new MedianFinder();\\n * obj->addNum(num);\\n * double param_2 = obj->findMedian();\\n */\\n```\\n**Please do upvote guys that helps me to post more solutions like this.**",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass MedianFinder {\\npublic:\\n    // we will use heaps (min and max) to get the median using . We will try to keep them balanced on basis of their size so that at    end we will have the medians at top.\\n    // we are not interested in other numbers just the middle one thats why using heap combo of min and max .\\n\\t// we are using min and max beacuse we will maintain our heaps in a way that max of max heap will always be lesser than equal to min of min Heap in this way we be able to get the medians\\n    priority_queue<int,vector<int>,greater<int>> minH;\\n    priority_queue<int> maxH;\\n    MedianFinder() {}\\n    \\n    void addNum(int num) {\\n        // we are trying to maintain a stream i.e., maxH.top() <= minH.top() in that way only we can assure the medians\\n        if(maxH.empty() || num<maxH.top()){\\n            maxH.push(num);\\n        }\\n        // incase we encounter greater number than the one present in maxH we need to add it in minH \\n        else{\\n            minH.push(num);\\n        }\\n        // we are trying to balance our heaps the max diff of size can be only 1\\n        // therefore popping the extra from that heap and pushing that in the other one\\n        if(maxH.size()>minH.size()+1){\\n            minH.push(maxH.top());\\n            maxH.pop();\\n        }\\n        else if(minH.size()>maxH.size()+1){\\n            maxH.push(minH.top());\\n            minH.pop();\\n        }\\n    }\\n    \\n    double findMedian() {\\n        // this operation is going to be O(1)\\n        // incase of even entries\\n        if(maxH.size() == minH.size()){\\n            // we will find mean of middle 2 entries and return \\n            return (maxH.top() + minH.top()) / 2.0;\\n        }\\n        // incase of odd entries:\\n        // our median will be present in that heap which has greater size\\n        else{\\n            return maxH.size() > minH.size() ? maxH.top() : minH.top();\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder* obj = new MedianFinder();\\n * obj->addNum(num);\\n * double param_2 = obj->findMedian();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2008525,
                "title": "median-solution-intuition-why-heaps-answer-to-follow-ups-o-logn-add-o-1-find-median",
                "content": "**Intution** : For understanding the intution of this problem lets take some sorted sample inputs.\\n\\n**Input 1 when size of array is odd** : [1,2,3,4,5]\\nWhat is the median? if we consider this as simple mathmatical problem median element will be n/2 element. So it will be 3.\\n\\nlet say we divied this array in 2 parts\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t1,2,3  ||||||   4,5\\nso in case when n is odd our median element is first element on the left of divider(i.e. ||||||).\\n\\nnow lets say we want to add element 0 in above arrangement. where this 0 element should go,\\nis it on the left of divider or on the right, in such a way sorting order is maintained?\\n\\n0 is less then 3 so it should go on the left of divider. \\n\\nso arrangement will become \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t0,1,2,3  ||||||   4,5\\n\\nwhat will be the median now?\\nsince n now become even if we consider this as simple mathematical probelm then median will become average of 2 middle element, so median is (2+3)/2 = 1.5 \\n\\nlet say we now want to add 7. where this element should be placed ? it should be on the right of divider.\\n\\n0,1,2,3  ||||||   4,5,7\\n\\nwhat will be the median? it will 3. (7/2th element).\\n\\nNow if we keep getting elements that are less then 3 then left size will keep growing. so we need to balance number of element on each side of divider( that is element should jump from left to right or right to left but we should make a contract that element can jump only from left to right or from right to left).\\n\\nLet say we made a contract the size different between left-right<=1. That mean either both sides of the divider are equal or  left can have atmost 1 element greater then right. If due to addition of some element we are breaking this balancing then we need rebalance( or move element from left to right) in order to balance the of divider.\\n\\nlets consider this arrangement.\\n\\n0,1  ||||||   4\\n\\n**what is the median ? it is 1st element from left of divider (n=3, n/2= 1) so answer is 1. and this element is the maximum element from all elements on the left hand side? So that mean we are only intreseted in the max of left. Can\\'t we max it max heap then?\\n**\\n\\nlet say we want to add -1 in above arrangement.\\n\\n-1 will go on the left as it less then 1 but if we do this left part will have 2 more element the right.\\nthen simple solution is move 1 from left to right and then add -1 so arrangement will become.\\n\\n-1.0 ||||| 1,4\\n\\nwhat is the median?  it will  be avarage of middle elements (0+1)/2 = 0.5 if you observer 0 is max element of left and 1 is min element of right. so we are only intersted in min and max elemenet.\\nlets represet left part with max heap then and right part with min heap.\\n\\nwhen n is even or sizeof(minheap) == sizeof(maxheap) in this case just peek max of left and peek min of right and divide it by 2.\\n\\n\\nNow you just need to figure out do you need to move element from left to right or where to add element. Trying tracing some sample input. Figure it out. And if you still need any help feel free to debug and go through the code.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```\\nclass MedianFinder {\\n\\n    private PriorityQueue<Integer> maxHeap, minHeap;\\n    public MedianFinder() {\\n         maxHeap = new PriorityQueue<>(Comparator.reverseOrder());\\n         minHeap = new PriorityQueue<>();\\n    }\\n    \\n    public void addNum(int num) {\\n        if(maxHeap.size()==0)\\n            maxHeap.add(num);\\n        else if(maxHeap.size()>minHeap.size()) {\\n            if(num>maxHeap.peek()) {\\n                minHeap.add(num);\\n            }else {\\n                int temp = maxHeap.remove();\\n                minHeap.add(temp);\\n                maxHeap.add(num);\\n            }\\n        }else {\\n            if(num<maxHeap.peek() || num<minHeap.peek()) {\\n                maxHeap.add(num);\\n            }\\n            else {\\n                int temp = minHeap.remove();\\n                minHeap.add(num);\\n                maxHeap.add(temp);\\n                \\n            }\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        if(maxHeap==null || maxHeap.size()==0)\\n            return -1d;\\n        if(maxHeap.size()==minHeap.size()) {\\n            return (maxHeap.peek()+minHeap.peek())*1.0/2;\\n        }else{\\n            return (double)maxHeap.peek();\\n        }\\n    }\\n}\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder obj = new MedianFinder();\\n * obj.addNum(num);\\n * double param_2 = obj.findMedian();\\n */\\n```\\nT(n) from add is O(logn) T(n) from find median is O(1)\\nCheers ~ ~ Please upvote if it helps.\\n\\nYou can comment in the post if you still need help in understanding the idea behind the problem.\\n\\n**Follow up questions**\\n1) SInce number will be of range [0,100] maintain an frequencey array of size 101. we already no if number of element are n and is odd then answer is n/2th element and if it even it will average of middle 2 element. Just do one pass and find the element. SInce arary size of 100. T(n) will O(1) for both element.\\n\\n2) 99% of the element can be stored like we did in above approach but rest 1 percent number we need to maintain two tree map/ bst to maintain the frequencey. one tree map will contain element smaller the 0 and one will contain element greater then 100. Rest of the logic will remain same as the mentioned for appraoch 1. \\n\\nIn both T(n) will be O(1) for add find median.\\n",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass MedianFinder {\\n\\n    private PriorityQueue<Integer> maxHeap, minHeap;\\n    public MedianFinder() {\\n         maxHeap = new PriorityQueue<>(Comparator.reverseOrder());\\n         minHeap = new PriorityQueue<>();\\n    }\\n    \\n    public void addNum(int num) {\\n        if(maxHeap.size()==0)\\n            maxHeap.add(num);\\n        else if(maxHeap.size()>minHeap.size()) {\\n            if(num>maxHeap.peek()) {\\n                minHeap.add(num);\\n            }else {\\n                int temp = maxHeap.remove();\\n                minHeap.add(temp);\\n                maxHeap.add(num);\\n            }\\n        }else {\\n            if(num<maxHeap.peek() || num<minHeap.peek()) {\\n                maxHeap.add(num);\\n            }\\n            else {\\n                int temp = minHeap.remove();\\n                minHeap.add(num);\\n                maxHeap.add(temp);\\n                \\n            }\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        if(maxHeap==null || maxHeap.size()==0)\\n            return -1d;\\n        if(maxHeap.size()==minHeap.size()) {\\n            return (maxHeap.peek()+minHeap.peek())*1.0/2;\\n        }else{\\n            return (double)maxHeap.peek();\\n        }\\n    }\\n}\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder obj = new MedianFinder();\\n * obj.addNum(num);\\n * double param_2 = obj.findMedian();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726087,
                "title": "easy-java-solution-with-full-explanation-using-heap-and-priorityqueues",
                "content": "Please upvote it if you find it helpful and do comment in case of any doubt. \\n\\n```\\nclass MedianFinder {\\n    \\n    /*Take two heaps\\n    \\n    1. maxHeap (Returns the largest number from the group)- stores all the\\n    numbers smaller than the median.\\n    2. minHeap (Returns the smallest number from the group) - stores all the\\n    numbers greater than the median.\\n    3. If the size of both heaps are equal then return the average of the\\n    largest number from the maxHeap and the smallest number from the minHeap.\\n    4. If size are not equal and minHeap has the size + 1 elements in it then\\n    transfer the smallest from that one to minHeap since it would become the\\n    largest and then the size would be equal so that we can take the average of\\n    both numbers.\\n    5. If the size is not greater by size + 1 then simply the minHeap element\\n    which is the largest is the median since there are total odd numbers\\n    present.\\n    \\n    */\\n    PriorityQueue<Integer> maxHeap = new PriorityQueue<>\\n        (Collections.reverseOrder());\\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n    \\n    public void addNum(int num) {\\n        if(maxHeap.isEmpty() || maxHeap.peek() >= num) {\\n            maxHeap.add(num);\\n        }\\n        else {\\n            minHeap.add(num);\\n        }\\n        \\n        if(maxHeap.size() > minHeap.size() + 1) {\\n            minHeap.add(maxHeap.poll());\\n        }\\n        else if(maxHeap.size() < minHeap.size()) {\\n            maxHeap.add(minHeap.poll());\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        if(maxHeap.size() == minHeap.size()) {\\n            return ((maxHeap.peek() + minHeap.peek())/2.0);\\n        }\\n        else {\\n            return maxHeap.peek();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass MedianFinder {\\n    \\n    /*Take two heaps\\n    \\n    1. maxHeap (Returns the largest number from the group)- stores all the\\n    numbers smaller than the median.\\n    2. minHeap (Returns the smallest number from the group) - stores all the\\n    numbers greater than the median.\\n    3. If the size of both heaps are equal then return the average of the\\n    largest number from the maxHeap and the smallest number from the minHeap.\\n    4. If size are not equal and minHeap has the size + 1 elements in it then\\n    transfer the smallest from that one to minHeap since it would become the\\n    largest and then the size would be equal so that we can take the average of\\n    both numbers.\\n    5. If the size is not greater by size + 1 then simply the minHeap element\\n    which is the largest is the median since there are total odd numbers\\n    present.\\n    \\n    */\\n    PriorityQueue<Integer> maxHeap = new PriorityQueue<>\\n        (Collections.reverseOrder());\\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n    \\n    public void addNum(int num) {\\n        if(maxHeap.isEmpty() || maxHeap.peek() >= num) {\\n            maxHeap.add(num);\\n        }\\n        else {\\n            minHeap.add(num);\\n        }\\n        \\n        if(maxHeap.size() > minHeap.size() + 1) {\\n            minHeap.add(maxHeap.poll());\\n        }\\n        else if(maxHeap.size() < minHeap.size()) {\\n            maxHeap.add(minHeap.poll());\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        if(maxHeap.size() == minHeap.size()) {\\n            return ((maxHeap.peek() + minHeap.peek())/2.0);\\n        }\\n        else {\\n            return maxHeap.peek();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1568078,
                "title": "java-heap-priorityqueue-simple-o-1-for-findmedian-and-o-logn-for-addnum",
                "content": "solution is to use 2 priorityQueues and keeping 1st half of the elements in one and 2nd half in another, [O(1) for findMedian() and O(logn) for addNum()]\\n\\n\\nin oder to keep the half the number of elements in both priorityQueues, we need the following conditions:-\\n\\n```\\nsay,\\n        small is max heap\\n        large is min heap\\n```\\n```\\n        if (size % 2 == 0) {\\n            large.offer(num);\\n            small.offer(large.poll());\\n        } else {\\n            small.offer(num);\\n            large.offer(small.poll());\\n        }        \\n```\\nif the size is even, whichever is smallest out of `large` or new `num` will be added to `small`,\\nelse whichever is largest out of `small`  or new `num` will be added to `large`.\\n\\n `small.peek()` will always have the median number when totals elements(`small.size() + large.size()`) are odd because whenever there are even elements the next element is added in `small` (which is first half of the all the elements).\\n\\nwhenever total elements are even, the median will be  `(large.peek() + small.peek())/2.0;`, \\n```\\n    PriorityQueue<Integer> small, large;\\n    public MedianFinder() {\\n        small = new PriorityQueue<>(Collections.reverseOrder()); //max heap\\n        large = new PriorityQueue<>(); //min heap\\n    }\\n\\n    public void addNum(int num) {\\n        int size = large.size() + small.size();\\n        if (size % 2 == 0) {\\n            large.offer(num);\\n            small.offer(large.poll());\\n        } else {\\n            small.offer(num);\\n            large.offer(small.poll());\\n        }        \\n    }\\n\\n    public double findMedian() {\\n        int size = large.size() + small.size();\\n        if(size % 2 == 0){\\n\\t\\t//if even\\n            return (large.peek() + small.peek())/2.0;\\n        }\\n\\t\\t//if odd\\n        return small.peek();\\n    }\\n```\\n\\n**please ask questions if you don\\'t understand any part of the solution. Thank you!",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nsay,\\n        small is max heap\\n        large is min heap\\n```\n```\\n        if (size % 2 == 0) {\\n            large.offer(num);\\n            small.offer(large.poll());\\n        } else {\\n            small.offer(num);\\n            large.offer(small.poll());\\n        }        \\n```\n```\\n    PriorityQueue<Integer> small, large;\\n    public MedianFinder() {\\n        small = new PriorityQueue<>(Collections.reverseOrder()); //max heap\\n        large = new PriorityQueue<>(); //min heap\\n    }\\n\\n    public void addNum(int num) {\\n        int size = large.size() + small.size();\\n        if (size % 2 == 0) {\\n            large.offer(num);\\n            small.offer(large.poll());\\n        } else {\\n            small.offer(num);\\n            large.offer(small.poll());\\n        }        \\n    }\\n\\n    public double findMedian() {\\n        int size = large.size() + small.size();\\n        if(size % 2 == 0){\\n\\t\\t//if even\\n            return (large.peek() + small.peek())/2.0;\\n        }\\n\\t\\t//if odd\\n        return small.peek();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1331114,
                "title": "c-double-heap-solution-explained-100-time-25-space",
                "content": "The base idea here is to keep constanly the data received into 2 halves and keep rebalancing them as we go inserting more.\\n\\nTo do so, we will create 2 heaps:\\n* `lows` is a maxheap that will collect the lower half of the values;\\n* `highs`, specularly, is a minhap that will collect the upper half.\\n\\nWe will do nothing in the constructor and move on with the `addNum` method, in which we will take the provided input `val` and:\\n* push `val` into `lows` if `lows` had no previous elements or `val < lows.top()`;\\n* push `val` into `highs` otherwise;\\n* rebalance the heaps to make sure that `lows` is never smaller and their difference in size is never `> 1`, moving the currently top element from one to the other.\\n\\nIn the `findMedian` method we can go and, if the number of provided elements so far is odd (ie: `lows.size() > highs.size()`) we will just return `lows.tops()`, otherwise we will return the average of both `.top()`s, since they are the central values :)\\n\\nThe code:\\n\\n```cpp\\nclass MedianFinder {\\n    priority_queue<int> lows;\\n    priority_queue<int, vector<int>, greater<int>> highs;\\npublic:\\n    /** initialize your data structure here. */\\n    MedianFinder() {}\\n    \\n    void addNum(int val) {\\n        // deciding in which half val goes:\\n        if (lows.empty() || val < lows.top()) lows.push(val);\\n        else highs.push(val);\\n        // rebalancing to avoid higher becoming bigger\\n        if (lows.size() < highs.size()) {\\n            lows.push(highs.top());\\n            highs.pop();\\n        }\\n        // or lows growing more than 1 element from the size of highs\\n        else if (lows.size() > highs.size() + 1) {\\n            highs.push(lows.top());\\n            lows.pop();\\n        }\\n    }\\n    \\n    double findMedian() {\\n        // computing the result depengn if we have seen odd amount of elements or not\\n        return lows.size() > highs.size() ? lows.top() : (lows.top() + highs.top()) / 2.0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```cpp\\nclass MedianFinder {\\n    priority_queue<int> lows;\\n    priority_queue<int, vector<int>, greater<int>> highs;\\npublic:\\n    /** initialize your data structure here. */\\n    MedianFinder() {}\\n    \\n    void addNum(int val) {\\n        // deciding in which half val goes:\\n        if (lows.empty() || val < lows.top()) lows.push(val);\\n        else highs.push(val);\\n        // rebalancing to avoid higher becoming bigger\\n        if (lows.size() < highs.size()) {\\n            lows.push(highs.top());\\n            highs.pop();\\n        }\\n        // or lows growing more than 1 element from the size of highs\\n        else if (lows.size() > highs.size() + 1) {\\n            highs.push(lows.top());\\n            lows.pop();\\n        }\\n    }\\n    \\n    double findMedian() {\\n        // computing the result depengn if we have seen odd amount of elements or not\\n        return lows.size() > highs.size() ? lows.top() : (lows.top() + highs.top()) / 2.0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1245501,
                "title": "simple-explained-javascript-heap-based-solution",
                "content": "**Approach**: Here we are always diving array elements in 2 parts, \\'left\\' and \\'right\\'. They both are heaps\\n\\'left\\' is max heap which will store the first half of small value of the total nums\\n\\'right\\' is min heap which will store second half of large value of the total nums\\n\\n**Inserting a new num:**\\nWhenever we are inserting a number we will check if it will go in the \\'left\\' or the \\'right\\' part. \\nIf the value is smaller than or equal to the maximum value of the \\'left\\' part then it will go in the \\'left\\' part\\nIf the value is greater than or equal to the minimum value of the \\'right\\' part then it will go in the \\'right\\' part\\nWe will take care of some more conditions in the insertion process so that the difference of elements in both parts doesn\\'t exceed by 1. See the comments in \\'addNum\\' function.\\n\\n**Finding median:**\\nIf any of the heap is having more elements, (this difference will not be greater than 1) then its top value will be the median\\nOtherwise average of top values from both the heaps will be the median\\n\\n```\\n//Creating Heap datastructer in Javscript, as we don\\'t have it prebuilt  \\nclass Heap{\\n        constructor(type){\\n            this.type = type;\\n            this.data = [];\\n            this.data[0] = undefined;\\n        }\\n        getSize(){\\n            return this.data.length-1;\\n        }\\n        insert(value){\\n            this.data.push(value);\\n            if(this.data.length==2){\\n                return ;\\n            }\\n            let lastIndex = this.data.length-1;\\n            while(this.data[Math.floor(lastIndex/2)]!==undefined && this.compare(this.data[lastIndex],this.data[Math.floor(lastIndex/2)])>0){\\n                let temp = this.data[Math.floor(lastIndex/2)];\\n                this.data[Math.floor(lastIndex/2)] = this.data[lastIndex];\\n                this.data[lastIndex] = temp;\\n                lastIndex = Math.floor(lastIndex/2);\\n            }\\n        }\\n        //This returns a positive number if a is greater than b. Here meaing of being greater depends on the type of heap. For max heap it will return positive number if a>b and for min heap it will return positive number if a<b . \\n        compare(a,b){\\n            if(this.type===\"min\"){\\n                return b-a;\\n            }else{\\n                return a-b;\\n            }\\n        }\\n        removeTop(){\\n            let max = this.data[1];\\n            if(this.getSize()>1){\\n                this.data[1] = this.data.pop();\\n                this.heapify(1);\\n            }else{//If the size is 0 then just remove the element, no shifting and hipify will be applicable\\n                this.data.pop();\\n            }\\n            return max;\\n        }\\n        getTop(){\\n            let max = null;\\n            if(this.getSize()>=1){\\n                max = this.data[1];\\n            }\\n            return max;\\n        }\\n        heapify(pos){\\n            if(pos*2>this.data.length-1){\\n                //That means element at index \\'pos\\' is not having any child\\n                return;\\n            }\\n            if(\\n                (this.data[pos*2]!==undefined && this.compare(this.data[pos*2],this.data[pos])>0)\\n              || (this.data[pos*2+1]!==undefined && this.compare(this.data[pos*2+1],this.data[pos])>0)\\n              ){\\n                if(this.data[pos*2+1]===undefined || this.compare(this.data[pos*2+1],this.data[pos*2])<=0){\\n                    let temp = this.data[pos*2];\\n                    this.data[pos*2] = this.data[pos];\\n                    this.data[pos] = temp;\\n                    this.heapify(pos*2);\\n                }else{\\n                    let temp = this.data[pos*2+1];\\n                    this.data[pos*2+1] = this.data[pos];\\n                    this.data[pos] = temp;\\n                    this.heapify(pos*2+1);\\n                }\\n            }\\n        }\\n    }\\n\\n/**\\n * initialize your data structure here.\\n */\\nvar MedianFinder = function() {\\n    this.left = new Heap(\"max\");\\n    this.right = new Heap(\"min\");\\n};\\n\\n\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nMedianFinder.prototype.addNum = function(num) {\\n    if(this.left.getSize()===0){//Lets\\'s put first element in left only\\n        this.left.insert(num);\\n        return ;\\n    }\\n    if(this.left.getSize()>this.right.getSize()){\\n        if(num<=this.left.getTop()){//As \\'left\\' was already having more values and the new value is also going to the left part, so after insertion, we will remove a value from left part and insert it to the right part, so the values in both the parts become equal\\n            this.left.insert(num);\\n            this.right.insert(this.left.removeTop());\\n        }else{\\n            this.right.insert(num);\\n        }\\n    }else if(this.right.getSize()>this.left.getSize()){//As \\'right\\' was already having more values and the new value is also going to the right part, so after insertion, we will remove a value from right part and insert it to the left part, so the values in both the parts become equal.\\n        if(num>=this.right.getTop()){\\n            this.right.insert(num);\\n            this.left.insert(this.right.removeTop());\\n        }else{\\n            this.left.insert(num);\\n        }\\n    }else {//If both the parts were having the same number of values, then we will just check and insert the new num in the relevant part. After this  insertion the part where we inserted the new num will have 1 element more than the other part, having a difference of 1 element is fine. \\n        if(num<=this.left.getTop()){\\n            this.left.insert(num);\\n        }else{\\n            this.right.insert(num);\\n        }\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nMedianFinder.prototype.findMedian = function() {\\n    if(this.left.getSize()>this.right.getSize()){\\n        return this.left.getTop();\\n    }else if(this.right.getSize()>this.left.getSize()){\\n        return this.right.getTop();\\n    }else{\\n        return (this.left.getTop()+this.right.getTop())/2;\\n    }\\n};\\n\\n/** \\n * Your MedianFinder object will be instantiated and called as such:\\n * var obj = new MedianFinder()\\n * obj.addNum(num)\\n * var param_2 = obj.findMedian()\\n */\\n */",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "**Approach**: Here we are always diving array elements in 2 parts, \\'left\\' and \\'right\\'. They both are heaps\\n\\'left\\' is max heap which will store the first half of small value of the total nums\\n\\'right\\' is min heap which will store second half of large value of the total nums\\n\\n**Inserting a new num:**\\nWhenever we are inserting a number we will check if it will go in the \\'left\\' or the \\'right\\' part. \\nIf the value is smaller than or equal to the maximum value of the \\'left\\' part then it will go in the \\'left\\' part\\nIf the value is greater than or equal to the minimum value of the \\'right\\' part then it will go in the \\'right\\' part\\nWe will take care of some more conditions in the insertion process so that the difference of elements in both parts doesn\\'t exceed by 1. See the comments in \\'addNum\\' function.\\n\\n**Finding median:**\\nIf any of the heap is having more elements, (this difference will not be greater than 1) then its top value will be the median\\nOtherwise average of top values from both the heaps will be the median\\n\\n```\\n//Creating Heap datastructer in Javscript, as we don\\'t have it prebuilt  \\nclass Heap{\\n        constructor(type){\\n            this.type = type;\\n            this.data = [];\\n            this.data[0] = undefined;\\n        }\\n        getSize(){\\n            return this.data.length-1;\\n        }\\n        insert(value){\\n            this.data.push(value);\\n            if(this.data.length==2){\\n                return ;\\n            }\\n            let lastIndex = this.data.length-1;\\n            while(this.data[Math.floor(lastIndex/2)]!==undefined && this.compare(this.data[lastIndex],this.data[Math.floor(lastIndex/2)])>0){\\n                let temp = this.data[Math.floor(lastIndex/2)];\\n                this.data[Math.floor(lastIndex/2)] = this.data[lastIndex];\\n                this.data[lastIndex] = temp;\\n                lastIndex = Math.floor(lastIndex/2);\\n            }\\n        }\\n        //This returns a positive number if a is greater than b. Here meaing of being greater depends on the type of heap. For max heap it will return positive number if a>b and for min heap it will return positive number if a<b . \\n        compare(a,b){\\n            if(this.type===\"min\"){\\n                return b-a;\\n            }else{\\n                return a-b;\\n            }\\n        }\\n        removeTop(){\\n            let max = this.data[1];\\n            if(this.getSize()>1){\\n                this.data[1] = this.data.pop();\\n                this.heapify(1);\\n            }else{//If the size is 0 then just remove the element, no shifting and hipify will be applicable\\n                this.data.pop();\\n            }\\n            return max;\\n        }\\n        getTop(){\\n            let max = null;\\n            if(this.getSize()>=1){\\n                max = this.data[1];\\n            }\\n            return max;\\n        }\\n        heapify(pos){\\n            if(pos*2>this.data.length-1){\\n                //That means element at index \\'pos\\' is not having any child\\n                return;\\n            }\\n            if(\\n                (this.data[pos*2]!==undefined && this.compare(this.data[pos*2],this.data[pos])>0)\\n              || (this.data[pos*2+1]!==undefined && this.compare(this.data[pos*2+1],this.data[pos])>0)\\n              ){\\n                if(this.data[pos*2+1]===undefined || this.compare(this.data[pos*2+1],this.data[pos*2])<=0){\\n                    let temp = this.data[pos*2];\\n                    this.data[pos*2] = this.data[pos];\\n                    this.data[pos] = temp;\\n                    this.heapify(pos*2);\\n                }else{\\n                    let temp = this.data[pos*2+1];\\n                    this.data[pos*2+1] = this.data[pos];\\n                    this.data[pos] = temp;\\n                    this.heapify(pos*2+1);\\n                }\\n            }\\n        }\\n    }\\n\\n/**\\n * initialize your data structure here.\\n */\\nvar MedianFinder = function() {\\n    this.left = new Heap(\"max\");\\n    this.right = new Heap(\"min\");\\n};\\n\\n\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nMedianFinder.prototype.addNum = function(num) {\\n    if(this.left.getSize()===0){//Lets\\'s put first element in left only\\n        this.left.insert(num);\\n        return ;\\n    }\\n    if(this.left.getSize()>this.right.getSize()){\\n        if(num<=this.left.getTop()){//As \\'left\\' was already having more values and the new value is also going to the left part, so after insertion, we will remove a value from left part and insert it to the right part, so the values in both the parts become equal\\n            this.left.insert(num);\\n            this.right.insert(this.left.removeTop());\\n        }else{\\n            this.right.insert(num);\\n        }\\n    }else if(this.right.getSize()>this.left.getSize()){//As \\'right\\' was already having more values and the new value is also going to the right part, so after insertion, we will remove a value from right part and insert it to the left part, so the values in both the parts become equal.\\n        if(num>=this.right.getTop()){\\n            this.right.insert(num);\\n            this.left.insert(this.right.removeTop());\\n        }else{\\n            this.left.insert(num);\\n        }\\n    }else {//If both the parts were having the same number of values, then we will just check and insert the new num in the relevant part. After this  insertion the part where we inserted the new num will have 1 element more than the other part, having a difference of 1 element is fine. \\n        if(num<=this.left.getTop()){\\n            this.left.insert(num);\\n        }else{\\n            this.right.insert(num);\\n        }\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nMedianFinder.prototype.findMedian = function() {\\n    if(this.left.getSize()>this.right.getSize()){\\n        return this.left.getTop();\\n    }else if(this.right.getSize()>this.left.getSize()){\\n        return this.right.getTop();\\n    }else{\\n        return (this.left.getTop()+this.right.getTop())/2;\\n    }\\n};\\n\\n/** \\n * Your MedianFinder object will be instantiated and called as such:\\n * var obj = new MedianFinder()\\n * obj.addNum(num)\\n * var param_2 = obj.findMedian()\\n */\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1165672,
                "title": "python-heapq-method",
                "content": "```\\nclass MedianFinder(object):\\n\\n    def __init__(self):\\n        self.first = [] #max heap, to get the largest item in the first half\\n        self.second = [] #min heap, to get the smallest item in the second half\\n        \\n\\n    def addNum(self, num):\\n        heapq.heappush(self.first, -num)\\n        heapq.heappush(self.second, -(heapq.heappop(self.first)))\\n        if len(self.first) < len(self.second): #always keep the first half of list is bigger/equal to the second one\\n            heapq.heappush(self.first, -(heapq.heappop(self.second)))\\n        \\n\\n    def findMedian(self):\\n        if len(self.first) > len(self.second):\\n            return -(self.first[0]) #already heapified\\n        else:\\n            return (float(-(self.first[0]))+float(self.second[0]))/2 #already heapified\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass MedianFinder(object):\\n\\n    def __init__(self):\\n        self.first = [] #max heap, to get the largest item in the first half\\n        self.second = [] #min heap, to get the smallest item in the second half\\n        \\n\\n    def addNum(self, num):\\n        heapq.heappush(self.first, -num)\\n        heapq.heappush(self.second, -(heapq.heappop(self.first)))\\n        if len(self.first) < len(self.second): #always keep the first half of list is bigger/equal to the second one\\n            heapq.heappush(self.first, -(heapq.heappop(self.second)))\\n        \\n\\n    def findMedian(self):\\n        if len(self.first) > len(self.second):\\n            return -(self.first[0]) #already heapified\\n        else:\\n            return (float(-(self.first[0]))+float(self.second[0]))/2 #already heapified\\n```",
                "codeTag": "Java"
            },
            {
                "id": 947563,
                "title": "c-priority-queue-with-explanation-with-runtime-160-ms-faster-than-95-80-of-c",
                "content": "```\\nclass MedianFinder {\\npublic:\\n    /** initialize your data structure here. */\\n    \\n    priority_queue<int> maxH; //for the first half of the elements\\n    priority_queue<int,vector<int>,greater<int>> minH; //for the second half of the elements\\n    MedianFinder() {\\n        \\n    }\\n    \\n    void addNum(int num) {\\n        //by default we consider the element on the left side i.e. maxH\\n        if(maxH.empty() || maxH.top()>num){\\n            maxH.push(num);\\n        }\\n        else{\\n            minH.push(num);\\n        }\\n        //rebalance the heaps to have same size or difference of size is 1\\n        rebalance();\\n    }\\n    \\n    double findMedian() {\\n        //if the number of elements that means we have even number of elements-> ([2,3], the median is (2 + 3) / 2 = 2.5)\\n        if(maxH.size()==minH.size()){\\n            return (maxH.top()+minH.top())/2.0;\\n        }\\n        //if left side has greater number of elements then middle is on the left side\\n        if(maxH.size()>minH.size()){\\n            return maxH.top();\\n        }\\n        //if right side has greater number of elements then middle is on the right side\\n        else{\\n            return minH.top();\\n        }\\n    }\\n    void rebalance(){\\n        //if right side is greater (minH) then put 1 element of right side to left side(maxH) \\n        if(maxH.size()+1<minH.size()){\\n            maxH.push(minH.top());\\n            minH.pop();\\n        }\\n        //if left side is greater (maxH) then put 1 element of left side to right side(minH)\\n        else if(minH.size()+1<maxH.size()){\\n            minH.push(maxH.top());\\n            maxH.pop();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass MedianFinder {\\npublic:\\n    /** initialize your data structure here. */\\n    \\n    priority_queue<int> maxH; //for the first half of the elements\\n    priority_queue<int,vector<int>,greater<int>> minH; //for the second half of the elements\\n    MedianFinder() {\\n        \\n    }\\n    \\n    void addNum(int num) {\\n        //by default we consider the element on the left side i.e. maxH\\n        if(maxH.empty() || maxH.top()>num){\\n            maxH.push(num);\\n        }\\n        else{\\n            minH.push(num);\\n        }\\n        //rebalance the heaps to have same size or difference of size is 1\\n        rebalance();\\n    }\\n    \\n    double findMedian() {\\n        //if the number of elements that means we have even number of elements-> ([2,3], the median is (2 + 3) / 2 = 2.5)\\n        if(maxH.size()==minH.size()){\\n            return (maxH.top()+minH.top())/2.0;\\n        }\\n        //if left side has greater number of elements then middle is on the left side\\n        if(maxH.size()>minH.size()){\\n            return maxH.top();\\n        }\\n        //if right side has greater number of elements then middle is on the right side\\n        else{\\n            return minH.top();\\n        }\\n    }\\n    void rebalance(){\\n        //if right side is greater (minH) then put 1 element of right side to left side(maxH) \\n        if(maxH.size()+1<minH.size()){\\n            maxH.push(minH.top());\\n            minH.pop();\\n        }\\n        //if left side is greater (maxH) then put 1 element of left side to right side(minH)\\n        else if(minH.size()+1<maxH.size()){\\n            minH.push(maxH.top());\\n            maxH.pop();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 602339,
                "title": "c-shortest-solution-using-insertion-sort",
                "content": "```\\npublic class MedianFinder {\\n    List<int> list = new List<int>();\\n\\t\\n    public void AddNum(int num) {\\n        int ind = list.BinarySearch(num);\\n        if (ind < 0) ind = ~ind;\\n        list.Insert(ind, num);\\n    }\\n\\n    public double FindMedian() {\\n        int mid = list.Count / 2;\\n        return list.Count % 2 == 1 ? list[mid] : ((double)list[mid-1] + list[mid]) / 2;\\n    }\\n}\\n```\\n\\n\\n\\nFrom [MSDN](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1.binarysearch):\\nBinary Search returns the zero-based index of item in the sorted List<T>, if item is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than item or, if there is no larger element, the bitwise complement of Count. You can apply the bitwise complement operation (~) to this negative integer to get the index of the first element that is larger than the search value. When inserting the value into the List<T>, this index should be used as the insertion point to maintain the sort order.\\n\\n`if (ind < 0) ind = ~ind;`",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class MedianFinder {\\n    List<int> list = new List<int>();\\n\\t\\n    public void AddNum(int num) {\\n        int ind = list.BinarySearch(num);\\n        if (ind < 0) ind = ~ind;\\n        list.Insert(ind, num);\\n    }\\n\\n    public double FindMedian() {\\n        int mid = list.Count / 2;\\n        return list.Count % 2 == 1 ? list[mid] : ((double)list[mid-1] + list[mid]) / 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 599685,
                "title": "javascript-o-n-addnum-o-1-findmedian-clean-w-comments",
                "content": "```\\nclass MedianFinder {\\n    constructor() {\\n        // set up array\\n        this.arr = [];\\n    }\\n\\t\\n    /**\\n     * @param {number} num\\n     * @return {void}\\n     */\\n    addNum(num) {\\n        // check if array is size 0, just push\\n        if (this.arr.length === 0) {\\n            this.arr.push(num);\\n            return;\\n        }\\n\\t\\t\\n        // left and right pointers for binary search\\n        let l = 0;\\n        let r = this.arr.length;\\n\\t\\t\\n        // keep going until pointers meet\\n        while (l < r) {\\n            // get mid point\\n            const mid = Math.floor((l + r) / 2);\\n            // check if we can insert at mid\\n            if (num > this.arr[mid]) {\\n                // search right half of array\\n                l = mid + 1;\\n            } else {\\n                // search left half of array\\n                r = mid;\\n            }\\n        }\\n\\t\\t\\n        // we can insert at left pointer\\n        this.arr.splice(l, 0, num);\\n    }\\n\\t\\n    /**\\n     * @return {number}\\n     */\\n    findMedian() {\\n        // if odd, return middle, if even, return avg of two middle\\n        const mid = Math.floor(this.arr.length / 2);\\n        return (this.arr.length & 1) === 1\\n            ? this.arr[mid]\\n            : (this.arr[mid] + this.arr[mid - 1]) / 2;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\nclass MedianFinder {\\n    constructor() {\\n        // set up array\\n        this.arr = [];\\n    }\\n\\t\\n    /**\\n     * @param {number} num\\n     * @return {void}\\n     */\\n    addNum(num) {\\n        // check if array is size 0, just push\\n        if (this.arr.length === 0) {\\n            this.arr.push(num);\\n            return;\\n        }\\n\\t\\t\\n        // left and right pointers for binary search\\n        let l = 0;\\n        let r = this.arr.length;\\n\\t\\t\\n        // keep going until pointers meet\\n        while (l < r) {\\n            // get mid point\\n            const mid = Math.floor((l + r) / 2);\\n            // check if we can insert at mid\\n            if (num > this.arr[mid]) {\\n                // search right half of array\\n                l = mid + 1;\\n            } else {\\n                // search left half of array\\n                r = mid;\\n            }\\n        }\\n\\t\\t\\n        // we can insert at left pointer\\n        this.arr.splice(l, 0, num);\\n    }\\n\\t\\n    /**\\n     * @return {number}\\n     */\\n    findMedian() {\\n        // if odd, return middle, if even, return avg of two middle\\n        const mid = Math.floor(this.arr.length / 2);\\n        return (this.arr.length & 1) === 1\\n            ? this.arr[mid]\\n            : (this.arr[mid] + this.arr[mid - 1]) / 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270084,
                "title": "simple-java-insertion-sort",
                "content": "The idea is simple, same as the approach 2 in the article, I just implemented it using Java.\\n\\nTo my suprise, it worked out quite well, runtime is *~110ms* and *~65MB* of memory usage.\\n\\n```java\\nclass MedianFinder {\\n    List<Integer> data;\\n\\n    /** initialize your data structure here. */\\n    public MedianFinder() {\\n        data = new ArrayList();\\n    }\\n    \\n    public void addNum(int num) {\\n        int idx=Collections.binarySearch(data,num);\\n        if(idx>=0) {\\n            data.add(idx,num);\\n        } else {\\n\\t\\t    // JDK document says binary search returns (-(insertion point) - 1)\\n            data.add(-idx-1,num);\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        int len=data.size();\\n        int mid=data.get(len/2);\\n        if(len%2==1) {\\n            return mid;\\n        } else {\\n            return 1.0*((data.get(len/2-1))+mid)/2;\\n        }\\n    }\\n}\\n```\\n\\nOne flaw is that you must use `ArrayList`, as LinkedList can\\'t be randomly accessed.",
                "solutionTags": [],
                "code": "```java\\nclass MedianFinder {\\n    List<Integer> data;\\n\\n    /** initialize your data structure here. */\\n    public MedianFinder() {\\n        data = new ArrayList();\\n    }\\n    \\n    public void addNum(int num) {\\n        int idx=Collections.binarySearch(data,num);\\n        if(idx>=0) {\\n            data.add(idx,num);\\n        } else {\\n\\t\\t    // JDK document says binary search returns (-(insertion point) - 1)\\n            data.add(-idx-1,num);\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        int len=data.size();\\n        int mid=data.get(len/2);\\n        if(len%2==1) {\\n            return mid;\\n        } else {\\n            return 1.0*((data.get(len/2-1))+mid)/2;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 74063,
                "title": "my-c-solution-by-sortedset",
                "content": "```\\npublic class MedianFinder {\\n    SortedSet<Tuple<int,int>> ss1;\\n    SortedSet<Tuple<int,int>> ss2;\\n    int count = 0;\\n\\n    /** initialize your data structure here. */\\n    public MedianFinder() {\\n        ss1 = new SortedSet<Tuple<int,int>>(Comparer<Tuple<int,int>>.Create((a,b) => \\n            a.Item1 == b.Item1 ? a.Item2 - b.Item2 : a.Item1 - b.Item1\\n        ));\\n        \\n        ss2 = new SortedSet<Tuple<int,int>>(Comparer<Tuple<int,int>>.Create((a,b) => \\n            a.Item1 == b.Item1 ? a.Item2 - b.Item2 : a.Item1 - b.Item1\\n        ));\\n    }\\n    \\n    public void AddNum(int num) \\n    {\\n        ss2.Add(new Tuple<int,int>(num, count++));\\n        ss1.Add(ss2.Min);\\n        ss2.Remove(ss2.Min);\\n        if(ss1.Count > ss2.Count)\\n        {\\n            ss2.Add(ss1.Max);\\n            ss1.Remove(ss1.Max);\\n        }\\n    }\\n    \\n    public double FindMedian() \\n    {\\n        if(ss1.Count == ss2.Count)\\n            return (double)(ss1.Max.Item1+ss2.Min.Item1)/2.0;\\n        else\\n            return ss2.Min.Item1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class MedianFinder {\\n    SortedSet<Tuple<int,int>> ss1;\\n    SortedSet<Tuple<int,int>> ss2;\\n    int count = 0;\\n\\n    /** initialize your data structure here. */\\n    public MedianFinder() {\\n        ss1 = new SortedSet<Tuple<int,int>>(Comparer<Tuple<int,int>>.Create((a,b) => \\n            a.Item1 == b.Item1 ? a.Item2 - b.Item2 : a.Item1 - b.Item1\\n        ));\\n        \\n        ss2 = new SortedSet<Tuple<int,int>>(Comparer<Tuple<int,int>>.Create((a,b) => \\n            a.Item1 == b.Item1 ? a.Item2 - b.Item2 : a.Item1 - b.Item1\\n        ));\\n    }\\n    \\n    public void AddNum(int num) \\n    {\\n        ss2.Add(new Tuple<int,int>(num, count++));\\n        ss1.Add(ss2.Min);\\n        ss2.Remove(ss2.Min);\\n        if(ss1.Count > ss2.Count)\\n        {\\n            ss2.Add(ss1.Max);\\n            ss1.Remove(ss1.Max);\\n        }\\n    }\\n    \\n    public double FindMedian() \\n    {\\n        if(ss1.Count == ss2.Count)\\n            return (double)(ss1.Max.Item1+ss2.Min.Item1)/2.0;\\n        else\\n            return ss2.Min.Item1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 74072,
                "title": "simple-bst-solution",
                "content": "##BST solution\\n````java\\npublic class MedianFinder {\\n    private Tree tree ;\\n    /** initialize your data structure here. */\\n    public MedianFinder() {\\n        tree = new Tree();\\n    }\\n    \\n    public void addNum(int num) {\\n        tree.add(num);\\n    }\\n    \\n    public double findMedian() {\\n        int size = tree.size();\\n        int half = size >> 1;\\n        if(size %2 == 1){\\n            return tree.getIth(1 + half);\\n        }\\n        else{\\n            return (tree.getIth(half) + tree.getIth(half +1)) / (double)2;\\n        }\\n    }\\n}\\n\\n    // BST\\nclass Tree{\\n    private static class Node {\\n        int cnt;\\n        int value;\\n        Node left; \\n        Node right;\\n        \\n        Node(int v){value = v; cnt = 1;}\\n    }\\n    \\n    private Node root ;\\n    \\n    void add(int n){\\n        if(root == null){\\n            root = new Node(n);\\n            return ;\\n        }\\n        \\n        // root not null. \\n        Node cur = root;\\n        \\n        while(true){\\n            cur.cnt ++; // important\\n            if(n < cur.value){\\n                if(cur.left == null){\\n                    cur.left = new Node(n);\\n                    break;\\n                }\\n                cur = cur.left;\\n                \\n            }\\n            else{\\n                if(cur.right == null){\\n                    cur.right = new Node(n);\\n                    break;\\n                }\\n                cur = cur.right;\\n            }\\n        }\\n    }\\n    \\n    // get ith largest element, i is 1-based.\\n    int getIth(int i){\\n        if(i <= 0 || i > size()) throw new RuntimeException(\"wrong args: \" + i);\\n        \\n        Node cur = root;\\n        while(true){\\n            int leftCnt = cur.left == null ? 0: cur.left.cnt;\\n            int rightCnt = cur.right  == null ? 0: cur.right.cnt;\\n            \\n            if(leftCnt + 1 == i) // root.\\n                return cur.value;\\n            else if(leftCnt >= i){\\n                cur = cur.left;\\n            }\\n            else{\\n                cur = cur.right;\\n                i -= (1 + leftCnt);\\n            }\\n        }\\n    }\\n    \\n    int size(){\\n        return root == null ? 0: root.cnt;\\n    }\\n}",
                "solutionTags": [],
                "code": "##BST solution\\n````java\\npublic class MedianFinder {\\n    private Tree tree ;\\n    /** initialize your data structure here. */\\n    public MedianFinder() {\\n        tree = new Tree();\\n    }\\n    \\n    public void addNum(int num) {\\n        tree.add(num);\\n    }\\n    \\n    public double findMedian() {\\n        int size = tree.size();\\n        int half = size >> 1;\\n        if(size %2 == 1){\\n            return tree.getIth(1 + half);\\n        }\\n        else{\\n            return (tree.getIth(half) + tree.getIth(half +1)) / (double)2;\\n        }\\n    }\\n}\\n\\n    // BST\\nclass Tree{\\n    private static class Node {\\n        int cnt;\\n        int value;\\n        Node left; \\n        Node right;\\n        \\n        Node(int v){value = v; cnt = 1;}\\n    }\\n    \\n    private Node root ;\\n    \\n    void add(int n){\\n        if(root == null){\\n            root = new Node(n);\\n            return ;\\n        }\\n        \\n        // root not null. \\n        Node cur = root;\\n        \\n        while(true){\\n            cur.cnt ++; // important\\n            if(n < cur.value){\\n                if(cur.left == null){\\n                    cur.left = new Node(n);\\n                    break;\\n                }\\n                cur = cur.left;\\n                \\n            }\\n            else{\\n                if(cur.right == null){\\n                    cur.right = new Node(n);\\n                    break;\\n                }\\n                cur = cur.right;\\n            }\\n        }\\n    }\\n    \\n    // get ith largest element, i is 1-based.\\n    int getIth(int i){\\n        if(i <= 0 || i > size()) throw new RuntimeException(\"wrong args: \" + i);\\n        \\n        Node cur = root;\\n        while(true){\\n            int leftCnt = cur.left == null ? 0: cur.left.cnt;\\n            int rightCnt = cur.right  == null ? 0: cur.right.cnt;\\n            \\n            if(leftCnt + 1 == i) // root.\\n                return cur.value;\\n            else if(leftCnt >= i){\\n                cur = cur.left;\\n            }\\n            else{\\n                cur = cur.right;\\n                i -= (1 + leftCnt);\\n            }\\n        }\\n    }\\n    \\n    int size(){\\n        return root == null ? 0: root.cnt;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3681001,
                "title": "interview-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n//median  can be obtained by keeping track of middle element or middle two elements \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n//we maintian two containers here , the first container stores the lower half elemnts and the second container stores the greater half elements,first half makes use of max heap and the second half makes use of min heap ,so that we can easily identify to which container our new incoming element will belong to (we always store the extra element in the first half,in this implementation )\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwe are performing two operation everytime //either simply push an element or extract min and push an element \\n//each of these operation takes o(log n )time \\ntherefore the time complexity is o(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n//corresponds to height of the heap that is o(log n) in total\\n\\n# Code\\n```\\nclass MedianFinder {\\npublic:\\n    priority_queue<int>s;//first containner to store smaller half elements\\n    priority_queue<int,vector<int>,greater<int>>g;//this is our second congtainer to store greater half elements\\n    int size;\\n    MedianFinder() {\\n        size=0;\\n    }\\n    \\n    void addNum(int num) {\\n        //we maintain extra element in our first container\\n        if(size==0)\\n        {\\n            s.push(num);\\n            size++;\\n        }\\n        else if(s.size()>g.size())\\n        {\\n                /*this time we need to make the size of both the    containers same //we check if the new element is lesser than \\n    maximum elemnt of first container ,if so we transfer the maximum\\n    elemnt from first container to second conatiner and add new\\n    incoming element to the first conatiner\\n    ( first container elements should be smaller than\\n    second container elements)*/\\n            if(num<s.top())\\n            {\\n                g.push(s.top());\\n                s.pop();\\n                s.push(num);\\n            }\\n            else\\n            {\\n                g.push(num);\\n            }\\n        }\\n        else\\n        {\\n                //both are of same size;\\n                /*if both are of same size we need to\\n        add extra element to first container , we check\\n        if new incoming element is greater than minimum\\n        element in max heap(second container) if so we \\n        transfer that minimum element to first container \\n        and add new incoming elemnet to second conatiner*/\\n           if(num>g.top())\\n           {\\n                s.push(g.top());\\n                g.pop();\\n                g.push(num);\\n           }\\n           else\\n           {\\n               s.push(num);\\n           }\\n        }\\n    }\\n    \\n    double findMedian() {\\n        if(s.size()>g.size())\\n        {\\n            return s.top();\\n        }\\n        else\\n        {\\n            return (s.top()+g.top())/2.0;\\n\\n        }\\n    }\\n};\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder* obj = new MedianFinder();\\n * obj->addNum(num);\\n * double param_2 = obj->findMedian();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MedianFinder {\\npublic:\\n    priority_queue<int>s;//first containner to store smaller half elements\\n    priority_queue<int,vector<int>,greater<int>>g;//this is our second congtainer to store greater half elements\\n    int size;\\n    MedianFinder() {\\n        size=0;\\n    }\\n    \\n    void addNum(int num) {\\n        //we maintain extra element in our first container\\n        if(size==0)\\n        {\\n            s.push(num);\\n            size++;\\n        }\\n        else if(s.size()>g.size())\\n        {\\n                /*this time we need to make the size of both the    containers same //we check if the new element is lesser than \\n    maximum elemnt of first container ,if so we transfer the maximum\\n    elemnt from first container to second conatiner and add new\\n    incoming element to the first conatiner\\n    ( first container elements should be smaller than\\n    second container elements)*/\\n            if(num<s.top())\\n            {\\n                g.push(s.top());\\n                s.pop();\\n                s.push(num);\\n            }\\n            else\\n            {\\n                g.push(num);\\n            }\\n        }\\n        else\\n        {\\n                //both are of same size;\\n                /*if both are of same size we need to\\n        add extra element to first container , we check\\n        if new incoming element is greater than minimum\\n        element in max heap(second container) if so we \\n        transfer that minimum element to first container \\n        and add new incoming elemnet to second conatiner*/\\n           if(num>g.top())\\n           {\\n                s.push(g.top());\\n                g.pop();\\n                g.push(num);\\n           }\\n           else\\n           {\\n               s.push(num);\\n           }\\n        }\\n    }\\n    \\n    double findMedian() {\\n        if(s.size()>g.size())\\n        {\\n            return s.top();\\n        }\\n        else\\n        {\\n            return (s.top()+g.top())/2.0;\\n\\n        }\\n    }\\n};\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder* obj = new MedianFinder();\\n * obj->addNum(num);\\n * double param_2 = obj->findMedian();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808491,
                "title": "c-shortest-solution-using-priorityqueue",
                "content": "# Code\\n```\\npublic class MedianFinder {\\n    PriorityQueue<int, int> max = new(Comparer<int>.Create((x, y) => y.CompareTo(x)));\\n    PriorityQueue<int, int> min = new();\\n\\n    public void AddNum(int num) {\\n        max.Enqueue(num, num);\\n        min.Enqueue(max.Peek(), max.Dequeue());\\n        if (max.Count < min.Count)\\n            max.Enqueue(min.Peek(), min.Dequeue());\\n    }\\n\\n    public double FindMedian() => min.Count != max.Count\\n        ? max.Peek() : (min.Peek() + max.Peek()) / 2.0;\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class MedianFinder {\\n    PriorityQueue<int, int> max = new(Comparer<int>.Create((x, y) => y.CompareTo(x)));\\n    PriorityQueue<int, int> min = new();\\n\\n    public void AddNum(int num) {\\n        max.Enqueue(num, num);\\n        min.Enqueue(max.Peek(), max.Dequeue());\\n        if (max.Count < min.Count)\\n            max.Enqueue(min.Peek(), min.Dequeue());\\n    }\\n\\n    public double FindMedian() => min.Count != max.Count\\n        ? max.Peek() : (min.Peek() + max.Peek()) / 2.0;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805447,
                "title": "c-short-simple-code",
                "content": "***DO UPVOTE IF IT HELPS !!!!!***\\n\\n\\tpriority_queue<int>mxh;                                  //max heap\\n    priority_queue<int,vector<int>,greater<int>> mnh;        //min heap\\n    \\n    MedianFinder() {\\n    }\\n    \\n    void addNum(int num) {\\n        \\n\\t\\t//INSERTION\\n        if(mxh.empty() || num<mxh.top()) mxh.push(num);               //if maxh is empty or num is smaller then maxh top, push in maxh      \\n        else mnh.push(num);                                           //else push in minh\\n        \\n\\t\\t//BALANCING HEAP\\n        if(mxh.size()>mnh.size() && mxh.size()-mnh.size()>1){         //if maxh size is greater than minh (diff greater than 1)\\n            mnh.push(mxh.top());                                      //then pop and push in minh\\n            mxh.pop();\\n        }\\n        else if(mnh.size()>mxh.size() && mnh.size()-mxh.size()>1){    //if minh size is greater than maxh (diff greater than 1)\\n            mxh.push(mnh.top());                                      //then pop and push in maxh\\n            mnh.pop();\\n        }\\n    }\\n    \\n    double findMedian() {\\n        \\n        if(mxh.size()==mnh.size()){                           //if maxh and minh size is equal, then return the \\n            double a=mxh.top(), b=mnh.top();                  //average of maxh.top and minh.top\\n            return (a+b)/2.0;\\n        }\\n        else{\\n            if(mxh.size()>mnh.size()){                        //else if maxh size is greater, return ,maxh top\\n                return (double) mxh.top();\\n            }\\n            else{                                             //else return minh top\\n                return (double) mnh.top();\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!!***\\n\\n\\tpriority_queue<int>mxh;                                  //max heap\\n    priority_queue<int,vector<int>,greater<int>> mnh;        //min heap\\n    \\n    MedianFinder() {\\n    }\\n    \\n    void addNum(int num) {\\n        \\n\\t\\t//INSERTION\\n        if(mxh.empty() || num<mxh.top()) mxh.push(num);               //if maxh is empty or num is smaller then maxh top, push in maxh      \\n        else mnh.push(num);                                           //else push in minh\\n        \\n\\t\\t//BALANCING HEAP\\n        if(mxh.size()>mnh.size() && mxh.size()-mnh.size()>1){         //if maxh size is greater than minh (diff greater than 1)\\n            mnh.push(mxh.top());                                      //then pop and push in minh\\n            mxh.pop();\\n        }\\n        else if(mnh.size()>mxh.size() && mnh.size()-mxh.size()>1){    //if minh size is greater than maxh (diff greater than 1)\\n            mxh.push(mnh.top());                                      //then pop and push in maxh\\n            mnh.pop();\\n        }\\n    }\\n    \\n    double findMedian() {\\n        \\n        if(mxh.size()==mnh.size()){                           //if maxh and minh size is equal, then return the \\n            double a=mxh.top(), b=mnh.top();                  //average of maxh.top and minh.top\\n            return (a+b)/2.0;\\n        }\\n        else{\\n            if(mxh.size()>mnh.size()){                        //else if maxh size is greater, return ,maxh top\\n                return (double) mxh.top();\\n            }\\n            else{                                             //else return minh top\\n                return (double) mnh.top();\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2560789,
                "title": "c-heap-solution",
                "content": "Straight forward solution, comment below if there\\'re any suggestions or doubts :)\\n\\n```\\nclass MedianFinder {\\npublic:\\n    priority_queue<int, vector<int>, greater<int>> large; \\n    priority_queue<int> small;\\n    \\n    MedianFinder() {\\n        \\n    }\\n    \\n    void addNum(int num) {\\n        if(small.empty() || small.top()>num) small.push(num);\\n        else large.push(num);\\n        \\n        if(small.size()>large.size()+1){\\n            int val=small.top();\\n            large.push(val);\\n            small.pop();\\n        }\\n        else if(large.size()>small.size()+1){\\n            int val=large.top();\\n            small.push(val);\\n            large.pop();\\n        }\\n    }\\n    \\n    double findMedian() {\\n        if(small.size()>large.size()){\\n            return small.top();\\n        }\\n        if(large.size()>small.size()){\\n            return large.top();\\n        }\\n        return (large.top()+small.top())/2.0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass MedianFinder {\\npublic:\\n    priority_queue<int, vector<int>, greater<int>> large; \\n    priority_queue<int> small;\\n    \\n    MedianFinder() {\\n        \\n    }\\n    \\n    void addNum(int num) {\\n        if(small.empty() || small.top()>num) small.push(num);\\n        else large.push(num);\\n        \\n        if(small.size()>large.size()+1){\\n            int val=small.top();\\n            large.push(val);\\n            small.pop();\\n        }\\n        else if(large.size()>small.size()+1){\\n            int val=large.top();\\n            small.push(val);\\n            large.pop();\\n        }\\n    }\\n    \\n    double findMedian() {\\n        if(small.size()>large.size()){\\n            return small.top();\\n        }\\n        if(large.size()>small.size()){\\n            return large.top();\\n        }\\n        return (large.top()+small.top())/2.0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2540241,
                "title": "c-two-heap-with-comments-based-on-480",
                "content": "///\\n\\nclass MedianFinder {\\npublic:\\n\\n    // Here we have taken two heap, Maxheap of size (n+1) and Minheap of size(n) \\n    priority_queue<int> maxheap; // it is used to store the max ele\\n    priority_queue<int,vector<int>,greater<int>> minheap; // it is used to store minimum element\\n    MedianFinder() {\\n        //ignore this as this will not affect the code\\n    }\\n    \\n    void addNum(int num) {\\n        int lefts = maxheap.size();\\n        int rights = minheap.size();\\n        \\n        // case 1 = maxheap is smaller than minheap\\n        \\n        if(lefts == 0)     // if maxheap is empty then add it first \\n            maxheap.push(num);\\n        \\n        // case 2 = if maxheap == minheap \\n        \\n        else if(lefts == rights)\\n        {\\n            if( num < minheap.top()) // if element is smaller than the top of minheap we\\'ll put it into maxheap\\n                maxheap.push(num);\\n            else\\n            {\\n                int temp = minheap.top();  // otherwise shift ele and push accordingly\\n                minheap.pop();\\n                maxheap.push(temp);\\n                minheap.push(num);\\n            }\\n        }\\n        \\n        //case 3 = if maxheap is greater than minheap\\n        \\n        else{\\n            if(num > maxheap.top()) // if num is greater than maxheap top so we\\'ll put it into min heap\\n                minheap.push(num);\\n            else{\\n                int temp = maxheap.top(); // otherwise shift ele and push accordingly\\n                maxheap.pop();\\n                minheap.push(temp);\\n                maxheap.push(num);\\n            }\\n        }\\n        \\n    }\\n    \\n    double findMedian() {\\n        int lefts = maxheap.size(); // to get the maxheap size\\n        int rights = minheap.size(); // to get the size of minheap \\n        if(lefts > rights)\\n            return maxheap.top(); // size is odd \\n        else\\n            return (double)(maxheap.top() + minheap.top())/2; // size is even\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "///\\n\\nclass MedianFinder {\\npublic:\\n\\n    // Here we have taken two heap, Maxheap of size (n+1) and Minheap of size(n) \\n    priority_queue<int> maxheap; // it is used to store the max ele\\n    priority_queue<int,vector<int>,greater<int>> minheap; // it is used to store minimum element\\n    MedianFinder() {\\n        //ignore this as this will not affect the code\\n    }\\n    \\n    void addNum(int num) {\\n        int lefts = maxheap.size();\\n        int rights = minheap.size();\\n        \\n        // case 1 = maxheap is smaller than minheap\\n        \\n        if(lefts == 0)     // if maxheap is empty then add it first \\n            maxheap.push(num);\\n        \\n        // case 2 = if maxheap == minheap \\n        \\n        else if(lefts == rights)\\n        {\\n            if( num < minheap.top()) // if element is smaller than the top of minheap we\\'ll put it into maxheap\\n                maxheap.push(num);\\n            else\\n            {\\n                int temp = minheap.top();  // otherwise shift ele and push accordingly\\n                minheap.pop();\\n                maxheap.push(temp);\\n                minheap.push(num);\\n            }\\n        }\\n        \\n        //case 3 = if maxheap is greater than minheap\\n        \\n        else{\\n            if(num > maxheap.top()) // if num is greater than maxheap top so we\\'ll put it into min heap\\n                minheap.push(num);\\n            else{\\n                int temp = maxheap.top(); // otherwise shift ele and push accordingly\\n                maxheap.pop();\\n                minheap.push(temp);\\n                maxheap.push(num);\\n            }\\n        }\\n        \\n    }\\n    \\n    double findMedian() {\\n        int lefts = maxheap.size(); // to get the maxheap size\\n        int rights = minheap.size(); // to get the size of minheap \\n        if(lefts > rights)\\n            return maxheap.top(); // size is odd \\n        else\\n            return (double)(maxheap.top() + minheap.top())/2; // size is even\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2260806,
                "title": "javascript-with-two-heaps",
                "content": "simple javascript solution by using two heaps\\n\\n```\\n\\nclass MedianFinder {\\n  constructor() {\\n   // bigger values in Min Heap\\n    this.minHeap = new MinPriorityQueue(); // already included by leetcode\\n\\t// smaller values in Max Heap\\n    this.maxHeap = new MaxPriorityQueue();  // already included by leetcode\\n  }\\n  /**\\n   * @param {number} num\\n   * @return {void}\\n   */\\n  addNum(num) {\\n    if (this.maxHeap.size() == 0 || num < this.maxHeap.front().element) {\\n      this.maxHeap.enqueue(num);\\n    } else\\n      this.minHeap.enqueue(num);\\n\\n    if (this.maxHeap.size() - this.minHeap.size() > 1)\\n      this.minHeap.enqueue(this.maxHeap.dequeue().element);\\n    else if (this.minHeap.size() - this.maxHeap.size() > 1)\\n      this.maxHeap.enqueue(this.minHeap.dequeue().element);\\n  }\\n  /**\\n   * @return {number}\\n   */\\n  findMedian() {\\n    if (this.maxHeap.size() > this.minHeap.size())\\n      return this.maxHeap.front().element;\\n    else if (this.minHeap.size() > this.maxHeap.size())\\n      return this.minHeap.front().element;\\n    else\\n      return (this.minHeap.front().element + this.maxHeap.front().element) / 2;\\n\\n  }\\n}\\n\\n ```",
                "solutionTags": [],
                "code": "```\\n\\nclass MedianFinder {\\n  constructor() {\\n   // bigger values in Min Heap\\n    this.minHeap = new MinPriorityQueue(); // already included by leetcode\\n\\t// smaller values in Max Heap\\n    this.maxHeap = new MaxPriorityQueue();  // already included by leetcode\\n  }\\n  /**\\n   * @param {number} num\\n   * @return {void}\\n   */\\n  addNum(num) {\\n    if (this.maxHeap.size() == 0 || num < this.maxHeap.front().element) {\\n      this.maxHeap.enqueue(num);\\n    } else\\n      this.minHeap.enqueue(num);\\n\\n    if (this.maxHeap.size() - this.minHeap.size() > 1)\\n      this.minHeap.enqueue(this.maxHeap.dequeue().element);\\n    else if (this.minHeap.size() - this.maxHeap.size() > 1)\\n      this.maxHeap.enqueue(this.minHeap.dequeue().element);\\n  }\\n  /**\\n   * @return {number}\\n   */\\n  findMedian() {\\n    if (this.maxHeap.size() > this.minHeap.size())\\n      return this.maxHeap.front().element;\\n    else if (this.minHeap.size() > this.maxHeap.size())\\n      return this.minHeap.front().element;\\n    else\\n      return (this.minHeap.front().element + this.maxHeap.front().element) / 2;\\n\\n  }\\n}\\n\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2202539,
                "title": "java-clean-simple-easy-to-understand",
                "content": "```\\nclass MedianFinder {\\n    PriorityQueue<Integer> left;\\n    PriorityQueue<Integer> right;\\n\\n    public MedianFinder() {\\n        right = new PriorityQueue<>();\\n        left = new PriorityQueue<>((a, b) -> b - a);\\n    }\\n\\n    public void addNum(int num) {\\n        if (left.isEmpty() || num < left.peek())\\n            left.add(num);\\n        else\\n            right.add(num);\\n\\n        if (left.size() > right.size())\\n            right.add(left.poll());\\n        if (right.size() > left.size())\\n            left.add(right.poll());\\n    }\\n\\n    public double findMedian() {\\n        return left.size() != right.size() ? left.peek()\\n                : (double) (left.peek() + right.peek()) / 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass MedianFinder {\\n    PriorityQueue<Integer> left;\\n    PriorityQueue<Integer> right;\\n\\n    public MedianFinder() {\\n        right = new PriorityQueue<>();\\n        left = new PriorityQueue<>((a, b) -> b - a);\\n    }\\n\\n    public void addNum(int num) {\\n        if (left.isEmpty() || num < left.peek())\\n            left.add(num);\\n        else\\n            right.add(num);\\n\\n        if (left.size() > right.size())\\n            right.add(left.poll());\\n        if (right.size() > left.size())\\n            left.add(right.poll());\\n    }\\n\\n    public double findMedian() {\\n        return left.size() != right.size() ? left.peek()\\n                : (double) (left.peek() + right.peek()) / 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1989867,
                "title": "easy-priority-queue-based-solution-with-explanation",
                "content": "1. First we create 2 priority_queue - one the max priority_queue ( pqmax) and other min (pqmin).\\n2.  pqmax will save the first half of the data with smaller values, and pqmin will store second half of the data with bigger values. - logic written in addNum() function.\\n3. when inserting a new value, we first compare if it is smaller than the top of pqmax.top() - (the largest value of the first half), if so, insert into pqmax, else insert it into pqmin.\\n4. after inserting a element we will balance 2 queues according to this logic - make sure either they have the same length or the length difference is only 1.\\n5. balance logic is written in - balanceHeap() function in the code.\\n6. if the size of both pqmax and pqmin is equal then we return average of their top\\n7. else\\n8. we return the top value of queue with greater size.\\n```\\nclass MedianFinder {\\npublic:\\n     priority_queue<int> pqmax;\\n     priority_queue<int , vector<int> , greater<int>> pqmin;\\n  \\n    //function to simply add num in queues.\\n    void addNum(int num) {\\n        if(pqmax.empty() or pqmax.top()>=num)\\n            pqmax.push(num);\\n        else\\n            pqmin.push(num);\\n        balanceHeap();\\n        \\n    }\\n\\t//function to balance the queues.\\n    void balanceHeap(){  \\n        if(pqmax.size()>pqmin.size() and pqmax.size()-pqmin.size()>1){\\n            pqmin.push(pqmax.top());\\n            pqmax.pop();\\n        }\\n        else if(pqmin.size()>pqmax.size() and pqmin.size()-pqmax.size()>1){\\n            pqmax.push(pqmin.top());\\n            pqmin.pop();\\n        }\\n            \\n    }\\n    \\n    double findMedian() {\\n        if(pqmax.size() ==pqmin.size())\\n            return (pqmax.top() + pqmin.top())/2.0;\\n        else if(pqmax.size()>pqmin.size())\\n            return pqmax.top();\\n        else\\n            return pqmin.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass MedianFinder {\\npublic:\\n     priority_queue<int> pqmax;\\n     priority_queue<int , vector<int> , greater<int>> pqmin;\\n  \\n    //function to simply add num in queues.\\n    void addNum(int num) {\\n        if(pqmax.empty() or pqmax.top()>=num)\\n            pqmax.push(num);\\n        else\\n            pqmin.push(num);\\n        balanceHeap();\\n        \\n    }\\n\\t//function to balance the queues.\\n    void balanceHeap(){  \\n        if(pqmax.size()>pqmin.size() and pqmax.size()-pqmin.size()>1){\\n            pqmin.push(pqmax.top());\\n            pqmax.pop();\\n        }\\n        else if(pqmin.size()>pqmax.size() and pqmin.size()-pqmax.size()>1){\\n            pqmax.push(pqmin.top());\\n            pqmin.pop();\\n        }\\n            \\n    }\\n    \\n    double findMedian() {\\n        if(pqmax.size() ==pqmin.size())\\n            return (pqmax.top() + pqmin.top())/2.0;\\n        else if(pqmax.size()>pqmin.size())\\n            return pqmax.top();\\n        else\\n            return pqmin.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1984728,
                "title": "very-easy-to-understand-java-solution-using-heap",
                "content": "```\\nclass MedianFinder {\\n    PriorityQueue<Integer> left ;\\n    PriorityQueue<Integer> right ;\\n    \\n    public MedianFinder() {\\n        left = new PriorityQueue<>(Collections.reverseOrder());\\n        right = new PriorityQueue<>();\\n    }\\n    \\n    public void addNum(int num) {\\n        left.add(num);\\n        right.add(left.remove());\\n        if(right.size()>left.size()){\\n           left.add(right.remove());\\n       }\\n    }\\n    \\n    public double findMedian() {\\n        if(left.size() == right.size()){\\n            int i = left.peek();\\n            int j = right.peek();\\n            return (double)(i+j)/2;\\n        }\\n        return (double)left.peek();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass MedianFinder {\\n    PriorityQueue<Integer> left ;\\n    PriorityQueue<Integer> right ;\\n    \\n    public MedianFinder() {\\n        left = new PriorityQueue<>(Collections.reverseOrder());\\n        right = new PriorityQueue<>();\\n    }\\n    \\n    public void addNum(int num) {\\n        left.add(num);\\n        right.add(left.remove());\\n        if(right.size()>left.size()){\\n           left.add(right.remove());\\n       }\\n    }\\n    \\n    public double findMedian() {\\n        if(left.size() == right.size()){\\n            int i = left.peek();\\n            int j = right.peek();\\n            return (double)(i+j)/2;\\n        }\\n        return (double)left.peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1455744,
                "title": "c-priority-queue",
                "content": "```\\nclass MedianFinder\\n{\\npublic:\\n    priority_queue<int> mxHeap,mnHeap;\\n    MedianFinder() {}\\n\\n    void addNum(int num)\\n    {\\n        mxHeap.push(num);\\n        mnHeap.push(-1 * mxHeap.top());\\n        mxHeap.pop();\\n        if (mxHeap.size() < mnHeap.size())\\n        {\\n            mxHeap.push(-1 * mnHeap.top());\\n            mnHeap.pop();\\n        }\\n    }\\n\\n    double findMedian()\\n    {\\n        return mxHeap.size() > mnHeap.size() ? mxHeap.top() : ((double)mxHeap.top() - mnHeap.top()) * 0.5;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass MedianFinder\\n{\\npublic:\\n    priority_queue<int> mxHeap,mnHeap;\\n    MedianFinder() {}\\n\\n    void addNum(int num)\\n    {\\n        mxHeap.push(num);\\n        mnHeap.push(-1 * mxHeap.top());\\n        mxHeap.pop();\\n        if (mxHeap.size() < mnHeap.size())\\n        {\\n            mxHeap.push(-1 * mnHeap.top());\\n            mnHeap.pop();\\n        }\\n    }\\n\\n    double findMedian()\\n    {\\n        return mxHeap.size() > mnHeap.size() ? mxHeap.top() : ((double)mxHeap.top() - mnHeap.top()) * 0.5;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331487,
                "title": "easy-c-solution-using-ordered-set",
                "content": "```\\n#include <ext/pb_ds/assoc_container.hpp> // Common file\\n#include <ext/pb_ds/tree_policy.hpp> // Including tree_order_statistics_node_update\\n#include <ext/pb_ds/detail/standard_policies.hpp>\\nusing namespace __gnu_pbds;\\n\\n\\n\\ntypedef tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\\nclass MedianFinder {\\npublic:\\n    /** initialize your data structure here. */\\n    vector<int> a;\\n    ordered_set s;\\n    MedianFinder() {\\n    }\\n    \\n    void addNum(int num) {\\n        a.push_back(num);s.insert(num);\\n    }\\n    \\n    double findMedian() {\\n        double med = 0.0;\\n        int n=a.size();\\n        if(n%2==0){\\n            med = ((double)(*(s.find_by_order(n/2))+(*(s.find_by_order(n/2-1)))))/2.0;\\n        }else{\\n            med = (*(s.find_by_order(n/2)))*1.0;\\n        }\\n        return med;\\n    }\\n};\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder* obj = new MedianFinder();\\n * obj->addNum(num);\\n * double param_2 = obj->findMedian();\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp> // Common file\\n#include <ext/pb_ds/tree_policy.hpp> // Including tree_order_statistics_node_update\\n#include <ext/pb_ds/detail/standard_policies.hpp>\\nusing namespace __gnu_pbds;\\n\\n\\n\\ntypedef tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\\nclass MedianFinder {\\npublic:\\n    /** initialize your data structure here. */\\n    vector<int> a;\\n    ordered_set s;\\n    MedianFinder() {\\n    }\\n    \\n    void addNum(int num) {\\n        a.push_back(num);s.insert(num);\\n    }\\n    \\n    double findMedian() {\\n        double med = 0.0;\\n        int n=a.size();\\n        if(n%2==0){\\n            med = ((double)(*(s.find_by_order(n/2))+(*(s.find_by_order(n/2-1)))))/2.0;\\n        }else{\\n            med = (*(s.find_by_order(n/2)))*1.0;\\n        }\\n        return med;\\n    }\\n};\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder* obj = new MedianFinder();\\n * obj->addNum(num);\\n * double param_2 = obj->findMedian();\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1331384,
                "title": "rust-translated-two-heap-solution",
                "content": "```rust\\nuse std::cmp::Reverse;\\nuse std::collections::BinaryHeap;\\n\\n#[derive(Default)]\\nstruct MedianFinder {\\n    small: BinaryHeap<i32>,\\n    large: BinaryHeap<Reverse<i32>>,\\n    odd: bool,\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl MedianFinder {\\n\\n    /** initialize your data structure here. */\\n    fn new() -> Self {\\n        Default::default()\\n    }\\n    \\n    fn add_num(&mut self, num: i32) {\\n        if self.odd {\\n            self.small.push(num);\\n            if let Some(max) = self.small.pop() {\\n                self.large.push(Reverse(max));\\n            }\\n        } else {\\n            self.large.push(Reverse(num));\\n            if let Some(Reverse(min)) = self.large.pop() {\\n                self.small.push(min);\\n            }\\n        }\\n        self.odd = !self.odd;\\n    }\\n    \\n    fn find_median(&self) -> f64 {\\n        if self.odd {\\n            *self.small.peek().unwrap() as f64\\n        } else {\\n            (self.small.peek().unwrap() + self.large.peek().unwrap().0) as f64 / 2.0\\n        }\\n    }\\n}\\n ```",
                "solutionTags": [
                    "Rust",
                    "Heap (Priority Queue)"
                ],
                "code": "```rust\\nuse std::cmp::Reverse;\\nuse std::collections::BinaryHeap;\\n\\n#[derive(Default)]\\nstruct MedianFinder {\\n    small: BinaryHeap<i32>,\\n    large: BinaryHeap<Reverse<i32>>,\\n    odd: bool,\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl MedianFinder {\\n\\n    /** initialize your data structure here. */\\n    fn new() -> Self {\\n        Default::default()\\n    }\\n    \\n    fn add_num(&mut self, num: i32) {\\n        if self.odd {\\n            self.small.push(num);\\n            if let Some(max) = self.small.pop() {\\n                self.large.push(Reverse(max));\\n            }\\n        } else {\\n            self.large.push(Reverse(num));\\n            if let Some(Reverse(min)) = self.large.pop() {\\n                self.small.push(min);\\n            }\\n        }\\n        self.odd = !self.odd;\\n    }\\n    \\n    fn find_median(&self) -> f64 {\\n        if self.odd {\\n            *self.small.peek().unwrap() as f64\\n        } else {\\n            (self.small.peek().unwrap() + self.large.peek().unwrap().0) as f64 / 2.0\\n        }\\n    }\\n}\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1331369,
                "title": "find-median-from-data-stream-easy-c-solution-using-multiset",
                "content": "Multiset data structure stores the elements in sorted order and it can store repeated elements also unlike sets.\\nThe code is pretty much understandable, feel free to comment if you  have some doubt. Thanks :)\\n```\\nclass MedianFinder {\\npublic:\\n    /** initialize your data structure here. */\\n    multiset<int> m;\\n    MedianFinder() {\\n        m.clear();\\n    }\\n    \\n    void addNum(int num) {\\n        m.insert(num);\\n    }\\n    \\n    double findMedian() {\\n        int n = m.size(),i;\\n        double ans;\\n        auto iter = m.begin();\\n        advance(iter, n / 2);\\n        if(n%2==0){\\n            auto iter2= iter--;\\n            ans = double(*iter+*iter2)/2;\\n        }else{\\n            ans = double(*iter);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass MedianFinder {\\npublic:\\n    /** initialize your data structure here. */\\n    multiset<int> m;\\n    MedianFinder() {\\n        m.clear();\\n    }\\n    \\n    void addNum(int num) {\\n        m.insert(num);\\n    }\\n    \\n    double findMedian() {\\n        int n = m.size(),i;\\n        double ans;\\n        auto iter = m.begin();\\n        advance(iter, n / 2);\\n        if(n%2==0){\\n            auto iter2= iter--;\\n            ans = double(*iter+*iter2)/2;\\n        }else{\\n            ans = double(*iter);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330805,
                "title": "heap-solution-o-logn-insertion-sort-solution-o-n",
                "content": "**Using Insertion sort**\\n```\\nclass MedianFinder {\\n\\n    ArrayList<Integer> a;\\n    public MedianFinder() {\\n        a = new ArrayList<>();\\n    }\\n    \\n    public void addNum(int num) {\\n        if(a.size()==0){\\n            a.add(num);\\n            return;\\n        }\\n        a.add(num);\\n        int j = a.size()-2;\\n        while(j >= 0 && a.get(j) > num) {\\n            a.set(j + 1,a.get(j));\\n            j--;\\n        }\\n        a.set(j + 1,num);\\n    }\\n    \\n    public double findMedian() {\\n        if(a.size()%2==0){\\n            return (a.get(a.size()/2)+a.get((a.size()-1)/2)+0.0)/2;\\n        } else{\\n            return a.get(a.size()/2)+0.0;\\n        }\\n    }\\n}\\n```\\n\\n**Using Heap**\\nApproach :\\ndivide the aray in two halfs and store left half in max heap and right half in min heap.\\nso that when we need to find median the mid element are at the top of max heap or min heap\\n\\nexample  :\\nwhen array is even\\narr = [2,4,5,6]\\n\\nmax_heap: 2 4\\nmin_heap = 6 5\\n\\nmedian is top of max_heap+minheap/2; = (4+5)/2\\n\\nwhen array is odd\\n\\narr = [2,3,4,5,6]\\n\\nmax_heap: 2 3 4 \\nmin_heap = 6 5\\n\\nmedian is top of max_heap = 4\\n\\nNow this will work when we have sorted array so, we have to insert element in heap such that the all element in max heap is less than all element in min heap .\\n\\n**0.0 in code is added to typecast from int to double**\\n```\\nclass MedianFinder {\\n\\n    PriorityQueue<Integer> max;\\n    PriorityQueue<Integer> min;\\n    public MedianFinder() {\\n\\t\\t  max =  = new PriorityQueue<>(Collections.reverseOrder());\\n\\t\\t  min = new PriorityQueue<>();\\n    }\\n    \\n    public void addNum(int num) {\\n        if(max.isEmpty() && min.isEmpty()){\\n            max.add(num);\\n            return;\\n        }\\n        if(max.size()==min.size()){\\n            if(min.peek()<num){\\n                max.add(min.poll());\\n                min.add(num);\\n            } else{\\n                max.add(num);\\n            }\\n        } else {\\n\\t\\t\\t\\n            if(num<max.peek()){\\n                min.add(max.poll());\\n                max.add(num);\\n            } else {\\n                min.add(num);\\n            }\\n        }\\n        \\n    }\\n    \\n    public double findMedian() {\\n        if(max.size()==min.size()){\\n            return (max.peek()+min.peek()+0.0)/2;\\n        }\\n        return max.peek()+0.0;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass MedianFinder {\\n\\n    ArrayList<Integer> a;\\n    public MedianFinder() {\\n        a = new ArrayList<>();\\n    }\\n    \\n    public void addNum(int num) {\\n        if(a.size()==0){\\n            a.add(num);\\n            return;\\n        }\\n        a.add(num);\\n        int j = a.size()-2;\\n        while(j >= 0 && a.get(j) > num) {\\n            a.set(j + 1,a.get(j));\\n            j--;\\n        }\\n        a.set(j + 1,num);\\n    }\\n    \\n    public double findMedian() {\\n        if(a.size()%2==0){\\n            return (a.get(a.size()/2)+a.get((a.size()-1)/2)+0.0)/2;\\n        } else{\\n            return a.get(a.size()/2)+0.0;\\n        }\\n    }\\n}\\n```\n```\\nclass MedianFinder {\\n\\n    PriorityQueue<Integer> max;\\n    PriorityQueue<Integer> min;\\n    public MedianFinder() {\\n\\t\\t  max =  = new PriorityQueue<>(Collections.reverseOrder());\\n\\t\\t  min = new PriorityQueue<>();\\n    }\\n    \\n    public void addNum(int num) {\\n        if(max.isEmpty() && min.isEmpty()){\\n            max.add(num);\\n            return;\\n        }\\n        if(max.size()==min.size()){\\n            if(min.peek()<num){\\n                max.add(min.poll());\\n                min.add(num);\\n            } else{\\n                max.add(num);\\n            }\\n        } else {\\n\\t\\t\\t\\n            if(num<max.peek()){\\n                min.add(max.poll());\\n                max.add(num);\\n            } else {\\n                min.add(num);\\n            }\\n        }\\n        \\n    }\\n    \\n    public double findMedian() {\\n        if(max.size()==min.size()){\\n            return (max.peek()+min.peek()+0.0)/2;\\n        }\\n        return max.peek()+0.0;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1035255,
                "title": "ruby-two-heaps-with-algorithms-gem",
                "content": "```ruby\\nclass MedianFinder\\n  def initialize()\\n    @small = Containers::MaxHeap.new\\n    @large = Containers::MinHeap.new\\n  end\\n  def add_num(num)\\n    if @small.length == @large.length\\n      @small.push(num)\\n      @large.push(@small.pop())\\n    else\\n      @large.push(num)\\n      @small.push(@large.pop())\\n    end\\n  end\\n  def find_median()\\n    if @small.length == @large.length\\n      return (@small.max + @large.min) / 2.0\\n    else\\n      return @large.min\\n    end\\n  end  \\nend",
                "solutionTags": [],
                "code": "```ruby\\nclass MedianFinder\\n  def initialize()\\n    @small = Containers::MaxHeap.new\\n    @large = Containers::MinHeap.new\\n  end\\n  def add_num(num)\\n    if @small.length == @large.length\\n      @small.push(num)\\n      @large.push(@small.pop())\\n    else\\n      @large.push(num)\\n      @small.push(@large.pop())\\n    end\\n  end\\n  def find_median()\\n    if @small.length == @large.length\\n      return (@small.max + @large.min) / 2.0\\n    else\\n      return @large.min\\n    end\\n  end  \\nend",
                "codeTag": "Java"
            },
            {
                "id": 867195,
                "title": "simple-and-intuitive-c-solution-using-multiset-o-logn-add-o-1-find-beats-99-90",
                "content": "Space Complexity = O(DataStream)\\nAny feedbacks are welcomed\\n```\\nclass MedianFinder {\\npublic:\\n    multiset<int> mset;\\n    multiset<int>::iterator miditer;     ///Keeps track of middle iterator of the multiset, if the list is even the iterator points to first element of the mid\\n    MedianFinder() {\\n        \\n    }\\n    \\n    void addNum(int num) {\\n        mset.insert(num);\\n        if(mset.size() == 1){\\n            miditer = mset.begin();      //Initially only one element \\n        }else if(mset.size()%2 == 0 && num < *miditer){   //Decrement the iterator only if after insertion of \"num\" the multiset size becomes even and the number is inserted before previous mid, since the list is even make iterator point to first element\\n                miditer--;    \\n        }else if(mset.size()%2 != 0 && num >= *miditer){  //Increment the iterator only if after insertion of \"num\" the multiset size becomes odd and the number is inserted after previous mid\\n                miditer++;\\n        }\\n    }\\n    \\n    double findMedian() {\\n        if(mset.size()%2 == 0){\\n            double ans = (*miditer + *(++miditer))/2.0;\\n            --miditer;\\n            return ans;\\n        }else{\\n            return *miditer;\\n        }     \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass MedianFinder {\\npublic:\\n    multiset<int> mset;\\n    multiset<int>::iterator miditer;     ///Keeps track of middle iterator of the multiset, if the list is even the iterator points to first element of the mid\\n    MedianFinder() {\\n        \\n    }\\n    \\n    void addNum(int num) {\\n        mset.insert(num);\\n        if(mset.size() == 1){\\n            miditer = mset.begin();      //Initially only one element \\n        }else if(mset.size()%2 == 0 && num < *miditer){   //Decrement the iterator only if after insertion of \"num\" the multiset size becomes even and the number is inserted before previous mid, since the list is even make iterator point to first element\\n                miditer--;    \\n        }else if(mset.size()%2 != 0 && num >= *miditer){  //Increment the iterator only if after insertion of \"num\" the multiset size becomes odd and the number is inserted after previous mid\\n                miditer++;\\n        }\\n    }\\n    \\n    double findMedian() {\\n        if(mset.size()%2 == 0){\\n            double ans = (*miditer + *(++miditer))/2.0;\\n            --miditer;\\n            return ans;\\n        }else{\\n            return *miditer;\\n        }     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 461738,
                "title": "python-2-heaps-beats-95",
                "content": "Solution explains the concept quite well. This is a Python implementation. \\nOne thing is that I used the built in heappushpop method when needing to perform a push plus a pop to maintain heap balance. According to the documentations, performing a heappushpop is faster than pushing and then popping. \\n\\n```\\nfrom heapq import heappush, heappop, heapify, heappushpop\\nclass MedianFinder(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        # min-heap containing the 1/2 largest elements\\n        self.minOfMax = []\\n        \\n        # max-heap containing the 1/2 smallest elements\\n        self.maxOfMin = []\\n\\n    def addNum(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: None\\n        \"\"\"\\n        if not self.minOfMax:\\n            heappush(self.minOfMax, num)\\n        elif not self.maxOfMin:\\n            if num > self.minOfMax[0]:\\n                minNum = heappushpop(self.minOfMax, num)\\n                heappush(self.maxOfMin, -minNum)\\n            else:\\n                heappush(self.maxOfMin, -num)\\n        else:\\n            if num > -self.maxOfMin[0]: # larger than the max of the min 1/2 elements\\n                if len(self.maxOfMin) >= len(self.minOfMax):\\n                    heappush(self.minOfMax, num)\\n                else:\\n                    num_replace = heappushpop(self.minOfMax, num)\\n                    heappush(self.maxOfMin, -num_replace)\\n            else: # smaller than the max of the min 1/2 elements or equal\\n                if len(self.maxOfMin) <= len(self.minOfMax):\\n                    heappush(self.maxOfMin, -num)\\n                else:\\n                    num_replace = -heappushpop(self.maxOfMin, -num)\\n                    heappush(self.minOfMax, num_replace)\\n\\n    def findMedian(self):\\n        \"\"\"\\n        :rtype: float\\n        \"\"\"\\n        if len(self.minOfMax) == len(self.maxOfMin):\\n            return (self.minOfMax[0] - self.maxOfMin[0])/2.0\\n        elif len(self.minOfMax) > len(self.maxOfMin):\\n            return self.minOfMax[0]\\n        else:\\n            return -self.maxOfMin[0]\\n        \\n        \\n\\n\\n# Your MedianFinder object will be instantiated and called as such:\\n# obj = MedianFinder()\\n# obj.addNum(num)\\n# param_2 = obj.findMedian()\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heappush, heappop, heapify, heappushpop\\nclass MedianFinder(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        # min-heap containing the 1/2 largest elements\\n        self.minOfMax = []\\n        \\n        # max-heap containing the 1/2 smallest elements\\n        self.maxOfMin = []\\n\\n    def addNum(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: None\\n        \"\"\"\\n        if not self.minOfMax:\\n            heappush(self.minOfMax, num)\\n        elif not self.maxOfMin:\\n            if num > self.minOfMax[0]:\\n                minNum = heappushpop(self.minOfMax, num)\\n                heappush(self.maxOfMin, -minNum)\\n            else:\\n                heappush(self.maxOfMin, -num)\\n        else:\\n            if num > -self.maxOfMin[0]: # larger than the max of the min 1/2 elements\\n                if len(self.maxOfMin) >= len(self.minOfMax):\\n                    heappush(self.minOfMax, num)\\n                else:\\n                    num_replace = heappushpop(self.minOfMax, num)\\n                    heappush(self.maxOfMin, -num_replace)\\n            else: # smaller than the max of the min 1/2 elements or equal\\n                if len(self.maxOfMin) <= len(self.minOfMax):\\n                    heappush(self.maxOfMin, -num)\\n                else:\\n                    num_replace = -heappushpop(self.maxOfMin, -num)\\n                    heappush(self.minOfMax, num_replace)\\n\\n    def findMedian(self):\\n        \"\"\"\\n        :rtype: float\\n        \"\"\"\\n        if len(self.minOfMax) == len(self.maxOfMin):\\n            return (self.minOfMax[0] - self.maxOfMin[0])/2.0\\n        elif len(self.minOfMax) > len(self.maxOfMin):\\n            return self.minOfMax[0]\\n        else:\\n            return -self.maxOfMin[0]\\n        \\n        \\n\\n\\n# Your MedianFinder object will be instantiated and called as such:\\n# obj = MedianFinder()\\n# obj.addNum(num)\\n# param_2 = obj.findMedian()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 447469,
                "title": "go-golang-two-heaps-solution",
                "content": "```go\\nimport \"container/heap\"\\n\\ntype MinHeap []int\\n\\nfunc (h MinHeap) Len() int { return len(h) }\\nfunc (h MinHeap) Less(i, j int) bool { return h[i] < h[j] }\\nfunc (h MinHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }\\nfunc (h *MinHeap) Push(x interface{}) { *h = append(*h, x.(int)) }\\nfunc (h *MinHeap) Pop() interface{} {\\n    min := (*h)[len(*h) - 1]\\n    *h = (*h)[:len(*h) - 1]\\n    return min\\n}\\n\\ntype MaxHeap []int\\n\\nfunc (h MaxHeap) Len() int { return len(h) }\\nfunc (h MaxHeap) Less(i, j int) bool { return h[i] > h[j] }\\nfunc (h MaxHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }\\nfunc (h *MaxHeap) Push(x interface{}) { *h = append(*h, x.(int)) }\\nfunc (h *MaxHeap) Pop() interface{} {\\n    min := (*h)[len(*h) - 1]\\n    *h = (*h)[:len(*h) - 1]\\n    return min\\n}\\n\\ntype MedianFinder struct {\\n    minHeap MinHeap\\n    maxHeap MaxHeap\\n}\\n\\nfunc Constructor() MedianFinder {\\n    return MedianFinder{\\n        minHeap: MinHeap{},\\n        maxHeap: MaxHeap{},\\n    }\\n}\\n\\nfunc (this *MedianFinder) AddNum(num int) {\\n    if this.maxHeap.Len() == 0 || num <= this.maxHeap[0] {\\n        heap.Push(&this.maxHeap, num)\\n    } else {\\n        heap.Push(&this.minHeap, num)\\n    }\\n    if this.maxHeap.Len() > this.minHeap.Len() + 1 {\\n        maxLeft := heap.Pop(&this.maxHeap)\\n        heap.Push(&this.minHeap, maxLeft)\\n    }\\n    if this.minHeap.Len() > this.maxHeap.Len() {\\n        minRight := heap.Pop(&this.minHeap)\\n        heap.Push(&this.maxHeap, minRight)\\n    }\\n}\\n\\nfunc (this *MedianFinder) FindMedian() float64 {\\n    if this.minHeap.Len() == this.maxHeap.Len() {\\n        return float64(this.minHeap[0] + this.maxHeap[0]) / 2\\n    }\\n    return float64(this.maxHeap[0])\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nimport \"container/heap\"\\n\\ntype MinHeap []int\\n\\nfunc (h MinHeap) Len() int { return len(h) }\\nfunc (h MinHeap) Less(i, j int) bool { return h[i] < h[j] }\\nfunc (h MinHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }\\nfunc (h *MinHeap) Push(x interface{}) { *h = append(*h, x.(int)) }\\nfunc (h *MinHeap) Pop() interface{} {\\n    min := (*h)[len(*h) - 1]\\n    *h = (*h)[:len(*h) - 1]\\n    return min\\n}\\n\\ntype MaxHeap []int\\n\\nfunc (h MaxHeap) Len() int { return len(h) }\\nfunc (h MaxHeap) Less(i, j int) bool { return h[i] > h[j] }\\nfunc (h MaxHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }\\nfunc (h *MaxHeap) Push(x interface{}) { *h = append(*h, x.(int)) }\\nfunc (h *MaxHeap) Pop() interface{} {\\n    min := (*h)[len(*h) - 1]\\n    *h = (*h)[:len(*h) - 1]\\n    return min\\n}\\n\\ntype MedianFinder struct {\\n    minHeap MinHeap\\n    maxHeap MaxHeap\\n}\\n\\nfunc Constructor() MedianFinder {\\n    return MedianFinder{\\n        minHeap: MinHeap{},\\n        maxHeap: MaxHeap{},\\n    }\\n}\\n\\nfunc (this *MedianFinder) AddNum(num int) {\\n    if this.maxHeap.Len() == 0 || num <= this.maxHeap[0] {\\n        heap.Push(&this.maxHeap, num)\\n    } else {\\n        heap.Push(&this.minHeap, num)\\n    }\\n    if this.maxHeap.Len() > this.minHeap.Len() + 1 {\\n        maxLeft := heap.Pop(&this.maxHeap)\\n        heap.Push(&this.minHeap, maxLeft)\\n    }\\n    if this.minHeap.Len() > this.maxHeap.Len() {\\n        minRight := heap.Pop(&this.minHeap)\\n        heap.Push(&this.maxHeap, minRight)\\n    }\\n}\\n\\nfunc (this *MedianFinder) FindMedian() float64 {\\n    if this.minHeap.Len() == this.maxHeap.Len() {\\n        return float64(this.minHeap[0] + this.maxHeap[0]) / 2\\n    }\\n    return float64(this.maxHeap[0])\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 439595,
                "title": "java-treeset-solution-beats-93",
                "content": "\\n```\\nimport java.io.*; \\nimport java.util.*; \\nimport java.lang.*;\\n\\nclass MyComparator implements Comparator<int[]>{\\n\\tpublic int compare(int[] a, int[] b) {\\n\\t\\tif (a[0]!=b[0]) {\\n\\t\\t\\treturn a[0] - b[0];\\n\\t\\t}\\n\\t\\treturn a[1] - b[1];\\n\\t}\\n}\\n\\n\\nclass MedianFinder {\\n\\tint time;\\n\\tMyComparator MyCom;\\n\\n    /** initialize your data structure here. */\\n\\tTreeSet<int[]> set ;\\n\\tint[] point1;\\n\\tint[] point2;\\n\\tpublic MedianFinder() {\\n        time = 0;\\n        MyCom = new MyComparator();\\n        set = new TreeSet<>(MyCom);\\n    }\\n\\t\\n    public void addNum(int num) {\\n    \\tint[] item = new int[] {num, time++};\\n        set.add(item);\\n        if (time == 1) {\\n        \\tpoint1 = set.first();\\n        \\tpoint2 = set.first();\\n        \\treturn;\\n        }\\n                \\n        if (point1 == point2) {\\n        \\tif (MyCom.compare(item, point1)<0) {\\n        \\t\\tpoint2 = point1;\\n        \\t\\tpoint1 = set.lower(point1);\\n        \\t}\\n        \\telse {\\n        \\t\\tpoint1 = point2;\\n        \\t\\tpoint2 = set.higher(point2);\\n        \\t}\\n        \\treturn;\\n        }\\n        \\n        if (point1 != point2) {\\n        \\tif (MyCom.compare(item, point1) < 0) {\\n        \\t\\tpoint2 = point1;\\n        \\t}\\n        \\telse if (MyCom.compare(item, point2) > 0) {\\n        \\t\\tpoint1 = point2;\\n        \\t}\\n        \\telse {\\n        \\t\\tpoint1 = item;\\n        \\t\\tpoint2 = item;\\n        \\t}\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        return ((double)point1[0] + (double)point2[0])/2.0;\\n    }\\n}\\n \\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nimport java.io.*; \\nimport java.util.*; \\nimport java.lang.*;\\n\\nclass MyComparator implements Comparator<int[]>{\\n\\tpublic int compare(int[] a, int[] b) {\\n\\t\\tif (a[0]!=b[0]) {\\n\\t\\t\\treturn a[0] - b[0];\\n\\t\\t}\\n\\t\\treturn a[1] - b[1];\\n\\t}\\n}\\n\\n\\nclass MedianFinder {\\n\\tint time;\\n\\tMyComparator MyCom;\\n\\n    /** initialize your data structure here. */\\n\\tTreeSet<int[]> set ;\\n\\tint[] point1;\\n\\tint[] point2;\\n\\tpublic MedianFinder() {\\n        time = 0;\\n        MyCom = new MyComparator();\\n        set = new TreeSet<>(MyCom);\\n    }\\n\\t\\n    public void addNum(int num) {\\n    \\tint[] item = new int[] {num, time++};\\n        set.add(item);\\n        if (time == 1) {\\n        \\tpoint1 = set.first();\\n        \\tpoint2 = set.first();\\n        \\treturn;\\n        }\\n                \\n        if (point1 == point2) {\\n        \\tif (MyCom.compare(item, point1)<0) {\\n        \\t\\tpoint2 = point1;\\n        \\t\\tpoint1 = set.lower(point1);\\n        \\t}\\n        \\telse {\\n        \\t\\tpoint1 = point2;\\n        \\t\\tpoint2 = set.higher(point2);\\n        \\t}\\n        \\treturn;\\n        }\\n        \\n        if (point1 != point2) {\\n        \\tif (MyCom.compare(item, point1) < 0) {\\n        \\t\\tpoint2 = point1;\\n        \\t}\\n        \\telse if (MyCom.compare(item, point2) > 0) {\\n        \\t\\tpoint1 = point2;\\n        \\t}\\n        \\telse {\\n        \\t\\tpoint1 = item;\\n        \\t\\tpoint2 = item;\\n        \\t}\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        return ((double)point1[0] + (double)point2[0])/2.0;\\n    }\\n}\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 333680,
                "title": "python-standard-implementation-commented-explained",
                "content": "```\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.low=[]\\n        self.high=[]\\n        \\n        \\n    def addNum(self, num: int) -> None:\\n        \\n        if len(self.low)>len(self.high):    #Max heap \\'low\\' has more\\n            if(num<self.findMedian()): #Item smaller than median-> make space-> push to low\\n                shifted=heapq.heappop(self.low)\\n                heapq.heappush(self.high,-shifted)\\n                heapq.heappush(self.low,-num)\\n            else: #Item bigger than median-> push to high\\n                heapq.heappush(self.high,num)\\n        elif len(self.low)==len(self.high): #Both heaps have equal size\\n            if num>self.findMedian():  #Item bigger than median->push to high\\n                heapq.heappush(self.high,num)\\n            else: #Item smaller than median->push to low\\n                heapq.heappush(self.low,-num)\\n        else:                               #Min heap \\'high\\' has more \\n            if(num>self.findMedian()): #Item bigger than median->make space->push to high\\n                shifted=heapq.heappop(self.high)\\n                heapq.heappush(self.low,-shifted)\\n                heapq.heappush(self.high,num)\\n            else: #Item smaller than median->push to low\\n                heapq.heappush(self.low,-num)\\n     \\n    def findMedian(self):\\n        low = self.low\\n        high = self.high\\n        if low and high:\\n            if len(low)==len(high):\\n                return (float(low[0])*-1+float(high[0]))/2.0\\n            if len(low)>len(high):\\n                return float(low[0]) *-1\\n            else:\\n                return float(high[0])\\n        elif not low and high:\\n            return float(high[0])\\n        elif not high and low:\\n            return float(low[0])*-1\\n        else:\\n            return 0.0\\n```\\n\\nWait. What. Howww?? \\nHere goes:\\nIf you have a stream of numbers like 1,2,3,4,5,6,7,8,9,10, you need to find the median. Do this by using two heaps. A max heap and a min heap. Why? Because you want to separate the stream of data into an upper and a lower half. The upper half is held in a min heap(with index 0 holding the least num) and the lower half is held with a max heap(with index 0 holding the max num). So out stream looks like this after we\\'re done adding to the heaps:\\nMax heap-> [5,4,3,2,1]\\nMin heap-> [6,7,8,9,10]\\n\\nNow as to how to add elements to the resepective heaps and retreive the median, remember that the challenge is to keep the heaps balanced( never different in size by more than one.) \\nBasically, for every \"num\" you\\'d like to add, add it appropriately and also keep the heaps balanced. \\n\\nLook at the following algo:\\n\\n```\\nTo add a \"num\":\\n\\tIs lower max heap bigger? If yes:\\n\\t\\tIs num bigger than current median? \\n\\t\\t\\tIf so, it has to go to the upper half:\\n\\t\\t\\t\\tJust push to high\\n\\t\\t\\telse, it has to go to the bottom half:\\n\\t\\t\\t\\tuh oh. Got to balance. Shift element from low to high. Then push to low\\n\\tIs higher min heap bigger? If yes:\\n\\t\\tIs num bigger than current median? \\n\\t\\t\\tIf so, it has to go to the upper half:\\n\\t\\t\\t\\tuh oh. Got to balance. Shift element from high to low. Then push to high\\n\\t\\t\\tElse, it goes in the lower half:\\n\\t\\t\\t\\tJust push to low.\\n\\tAre both heaps of same size? If yes:\\n\\t\\tIs num bigger than current median? \\n\\t\\t\\tIf so, it has to go to the upper half:\\n\\t\\t\\t\\tJust push to high\\n\\t\\t\\tElse, it goes in the lower half:\\n\\t\\t\\t\\tJust push to low\\n```\\n\\nLastly, to find the median:\\n```\\nIf the heaps are of equal size, then average the tops of both heaps.\\nElse return the top of the bigger heap. \\n```\\n\\nVoila ;) As usual, correct me if I\\'m wrong.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.low=[]\\n        self.high=[]\\n        \\n        \\n    def addNum(self, num: int) -> None:\\n        \\n        if len(self.low)>len(self.high):    #Max heap \\'low\\' has more\\n            if(num<self.findMedian()): #Item smaller than median-> make space-> push to low\\n                shifted=heapq.heappop(self.low)\\n                heapq.heappush(self.high,-shifted)\\n                heapq.heappush(self.low,-num)\\n            else: #Item bigger than median-> push to high\\n                heapq.heappush(self.high,num)\\n        elif len(self.low)==len(self.high): #Both heaps have equal size\\n            if num>self.findMedian():  #Item bigger than median->push to high\\n                heapq.heappush(self.high,num)\\n            else: #Item smaller than median->push to low\\n                heapq.heappush(self.low,-num)\\n        else:                               #Min heap \\'high\\' has more \\n            if(num>self.findMedian()): #Item bigger than median->make space->push to high\\n                shifted=heapq.heappop(self.high)\\n                heapq.heappush(self.low,-shifted)\\n                heapq.heappush(self.high,num)\\n            else: #Item smaller than median->push to low\\n                heapq.heappush(self.low,-num)\\n     \\n    def findMedian(self):\\n        low = self.low\\n        high = self.high\\n        if low and high:\\n            if len(low)==len(high):\\n                return (float(low[0])*-1+float(high[0]))/2.0\\n            if len(low)>len(high):\\n                return float(low[0]) *-1\\n            else:\\n                return float(high[0])\\n        elif not low and high:\\n            return float(high[0])\\n        elif not high and low:\\n            return float(low[0])*-1\\n        else:\\n            return 0.0\\n```\n```\\nTo add a \"num\":\\n\\tIs lower max heap bigger? If yes:\\n\\t\\tIs num bigger than current median? \\n\\t\\t\\tIf so, it has to go to the upper half:\\n\\t\\t\\t\\tJust push to high\\n\\t\\t\\telse, it has to go to the bottom half:\\n\\t\\t\\t\\tuh oh. Got to balance. Shift element from low to high. Then push to low\\n\\tIs higher min heap bigger? If yes:\\n\\t\\tIs num bigger than current median? \\n\\t\\t\\tIf so, it has to go to the upper half:\\n\\t\\t\\t\\tuh oh. Got to balance. Shift element from high to low. Then push to high\\n\\t\\t\\tElse, it goes in the lower half:\\n\\t\\t\\t\\tJust push to low.\\n\\tAre both heaps of same size? If yes:\\n\\t\\tIs num bigger than current median? \\n\\t\\t\\tIf so, it has to go to the upper half:\\n\\t\\t\\t\\tJust push to high\\n\\t\\t\\tElse, it goes in the lower half:\\n\\t\\t\\t\\tJust push to low\\n```\n```\\nIf the heaps are of equal size, then average the tops of both heaps.\\nElse return the top of the bigger heap. \\n```",
                "codeTag": "Java"
            },
            {
                "id": 74092,
                "title": "easy-to-understand-c-solution-beats-97",
                "content": "class MedianFinder {\\n\\n    priority_queue<int> left;\\n    priority_queue<int, vector<int>, greater<int> > right;\\npublic:\\n\\n    // Adds a number into the data structure.\\n    void addNum(int num) {\\n        if(left.empty()){\\n            left.push(num);\\n            return;\\n        }\\n        if(num <= left.top()){\\n            left.push(num);\\n            if(left.size()-right.size() > 1){\\n                right.push(left.top());\\n                left.pop();\\n            }\\n        }\\n        else{\\n            right.push(num);\\n            if(right.size()-left.size() > 1){\\n                left.push(right.top());\\n                right.pop();\\n            }\\n        }\\n    }\\n\\n    // Returns the median of current data stream\\n    double findMedian() {\\n        if(left.size() == right.size()){\\n            return (left.top()+right.top())/2.0;\\n        }\\n        else if(left.size() > right.size()) return left.top();\\n        else return right.top();\\n    }\\n};",
                "solutionTags": [],
                "code": "class MedianFinder {\\n\\n    priority_queue<int> left;\\n    priority_queue<int, vector<int>, greater<int> > right;\\npublic:\\n\\n    // Adds a number into the data structure.\\n    void addNum(int num) {\\n        if(left.empty()){\\n            left.push(num);\\n            return;\\n        }\\n        if(num <= left.top()){\\n            left.push(num);\\n            if(left.size()-right.size() > 1){\\n                right.push(left.top());\\n                left.pop();\\n            }\\n        }\\n        else{\\n            right.push(num);\\n            if(right.size()-left.size() > 1){\\n                left.push(right.top());\\n                right.pop();\\n            }\\n        }\\n    }\\n\\n    // Returns the median of current data stream\\n    double findMedian() {\\n        if(left.size() == right.size()){\\n            return (left.top()+right.top())/2.0;\\n        }\\n        else if(left.size() > right.size()) return left.top();\\n        else return right.top();\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 3769304,
                "title": "very-easy-solution-using-heap-priority-queue",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(klogn)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(k)$$\\n\\n# C++ Code\\n```\\nclass MedianFinder {\\n    priority_queue<int> maxHeap;\\n    priority_queue<int, vector<int>, greater<int>> minHeap;\\npublic:\\n    MedianFinder() {\\n    }\\n    \\n    void addNum(int num) {\\n        if(maxHeap.size() == 0 || maxHeap.top() >= num) maxHeap.push(num);\\n        else minHeap.push(num);\\n        balancingHeaps();\\n        \\n    }\\n    \\n    double findMedian() {\\n        if(maxHeap.size() > minHeap.size()) return maxHeap.top();\\n        else if(minHeap.size() > maxHeap.size()) return minHeap.top();\\n        else return (maxHeap.top() + minHeap.top()) / 2.0;\\n        \\n    }\\n    void balancingHeaps(){\\n        if (maxHeap.size() > minHeap.size() + 1) {\\n\\t\\t\\tminHeap.push(maxHeap.top());\\n\\t\\t\\tmaxHeap.pop();\\n\\t\\t} else if (minHeap.size() > maxHeap.size() + 1) {\\n\\t\\t\\tmaxHeap.push(minHeap.top());\\n\\t\\t\\tminHeap.pop();\\n\\t\\t}\\n\\n    }\\n};\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder* obj = new MedianFinder();\\n * obj->addNum(num);\\n * double param_2 = obj->findMedian();\\n */\\n```\\n# Java Code\\n```\\nclass MedianFinder {\\n    private PriorityQueue<Integer> maxHeap = null;\\n    private PriorityQueue<Integer> minHeap = null;\\n\\n    public MedianFinder() {\\n        maxHeap = new PriorityQueue<>((a, b)-> (b - a));\\n        minHeap = new PriorityQueue<>((a, b)-> (a - b));\\n    }\\n    \\n    public void addNum(int num) {\\n        if(maxHeap.size() == 0 || maxHeap.peek() >= num) maxHeap.offer(num);\\n        else minHeap.offer(num);\\n        balancingHeaps();\\n        \\n    }\\n    \\n    \\n    public double findMedian() {\\n        if(maxHeap.size() > minHeap.size()) return maxHeap.peek();\\n        else if(minHeap.size() > maxHeap.size()) return minHeap.peek();\\n        else return (maxHeap.peek() + minHeap.peek()) / 2.0;\\n        \\n    }\\n    private void balancingHeaps(){\\n        if(maxHeap.size() - minHeap.size() > 1) minHeap.offer(maxHeap.poll());\\n        else if(minHeap.size() - maxHeap.size() > 1) maxHeap.offer(minHeap.poll());\\n\\n    }\\n}\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder obj = new MedianFinder();\\n * obj.addNum(num);\\n * double param_2 = obj.findMedian();\\n */",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass MedianFinder {\\n    priority_queue<int> maxHeap;\\n    priority_queue<int, vector<int>, greater<int>> minHeap;\\npublic:\\n    MedianFinder() {\\n    }\\n    \\n    void addNum(int num) {\\n        if(maxHeap.size() == 0 || maxHeap.top() >= num) maxHeap.push(num);\\n        else minHeap.push(num);\\n        balancingHeaps();\\n        \\n    }\\n    \\n    double findMedian() {\\n        if(maxHeap.size() > minHeap.size()) return maxHeap.top();\\n        else if(minHeap.size() > maxHeap.size()) return minHeap.top();\\n        else return (maxHeap.top() + minHeap.top()) / 2.0;\\n        \\n    }\\n    void balancingHeaps(){\\n        if (maxHeap.size() > minHeap.size() + 1) {\\n\\t\\t\\tminHeap.push(maxHeap.top());\\n\\t\\t\\tmaxHeap.pop();\\n\\t\\t} else if (minHeap.size() > maxHeap.size() + 1) {\\n\\t\\t\\tmaxHeap.push(minHeap.top());\\n\\t\\t\\tminHeap.pop();\\n\\t\\t}\\n\\n    }\\n};\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder* obj = new MedianFinder();\\n * obj->addNum(num);\\n * double param_2 = obj->findMedian();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666984,
                "title": "c-easy-properly-commented-heaps-priority-queues",
                "content": "# Intuition\\nbasically we want to mantain 2 heaps.\\nmaxheap will apparently have all the elements to the left of the media. minheap will apparently have all the elements to the right of the median\\n\\nThe main property of the median is that all elements before the median are smaller than itself and all elements after the median are larger than itself, thus we assume 2 arrays (heaps actually).\\n\\n# Complexity\\n- Time complexity for addNum: $$O(logn)$$ \\n- Time complexity for findMedian: $$O(1)$$ \\n\\n- Space complexity: $$O(n)$$\\n\\n\\n# Code\\n```\\nclass MedianFinder {\\npublic:\\n  priority_queue<int, vector<int>, greater<int>> minHeap;\\n  priority_queue<int> maxHeap;\\n    MedianFinder() {\\n        \\n    }\\n    //basically we want to mantain 2 heaps.\\n    // maxheap will apparently have all the elements to the left of the median \\n    //minheap will apparently have all the elements to the right of the median\\n    void addNum(int num) {\\n\\n        //we\\'ll check if the element should go to the left side of the array (before median) \\n        //or to the right side of the array (after median)\\n        if (maxHeap.empty() || maxHeap.top()>num) maxHeap.push(num); \\n        else minHeap.push(num);\\n\\n\\n        //but after inserting there is a possibility that we disrupted the balance between the heaps.\\n        // we need both heaps to have equal size or differ at max by 1.\\n        if (maxHeap.size()>minHeap.size()+1){\\n            minHeap.push(maxHeap.top());\\n            maxHeap.pop();\\n            //removed topmost element from maxHeap and pushed it to minHeap.\\n        } \\n        else if (minHeap.size()>maxHeap.size()+1){\\n            maxHeap.push(minHeap.top());\\n            minHeap.pop();\\n            //removed topmost element from minHeap and pushed it to maxHeap.\\n        } \\n\\n             \\n    }\\n    \\n    double findMedian() {\\n\\n        if (maxHeap.size()==minHeap.size()){\\n            if (maxHeap.empty()) return 0; //the first case where we did not input any number and directly asked for a median.\\n            else return (double) (maxHeap.top()+minHeap.top())/2.0;\\n            // because median is the average of 2 middles when length is even\\n        }\\n        else{\\n            // if the size is not equal then return the top of the largest heap simply\\n            if (maxHeap.size()>minHeap.size()) return maxHeap.top();\\n            else return minHeap.top();\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder* obj = new MedianFinder();\\n * obj->addNum(num);\\n * double param_2 = obj->findMedian();\\n */\\n```\\n\\n## Do Upvote if you understood the solution!\\n\\n\\n\\n#### thank you!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MedianFinder {\\npublic:\\n  priority_queue<int, vector<int>, greater<int>> minHeap;\\n  priority_queue<int> maxHeap;\\n    MedianFinder() {\\n        \\n    }\\n    //basically we want to mantain 2 heaps.\\n    // maxheap will apparently have all the elements to the left of the median \\n    //minheap will apparently have all the elements to the right of the median\\n    void addNum(int num) {\\n\\n        //we\\'ll check if the element should go to the left side of the array (before median) \\n        //or to the right side of the array (after median)\\n        if (maxHeap.empty() || maxHeap.top()>num) maxHeap.push(num); \\n        else minHeap.push(num);\\n\\n\\n        //but after inserting there is a possibility that we disrupted the balance between the heaps.\\n        // we need both heaps to have equal size or differ at max by 1.\\n        if (maxHeap.size()>minHeap.size()+1){\\n            minHeap.push(maxHeap.top());\\n            maxHeap.pop();\\n            //removed topmost element from maxHeap and pushed it to minHeap.\\n        } \\n        else if (minHeap.size()>maxHeap.size()+1){\\n            maxHeap.push(minHeap.top());\\n            minHeap.pop();\\n            //removed topmost element from minHeap and pushed it to maxHeap.\\n        } \\n\\n             \\n    }\\n    \\n    double findMedian() {\\n\\n        if (maxHeap.size()==minHeap.size()){\\n            if (maxHeap.empty()) return 0; //the first case where we did not input any number and directly asked for a median.\\n            else return (double) (maxHeap.top()+minHeap.top())/2.0;\\n            // because median is the average of 2 middles when length is even\\n        }\\n        else{\\n            // if the size is not equal then return the top of the largest heap simply\\n            if (maxHeap.size()>minHeap.size()) return maxHeap.top();\\n            else return minHeap.top();\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder* obj = new MedianFinder();\\n * obj->addNum(num);\\n * double param_2 = obj->findMedian();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805691,
                "title": "arraylist-java-solution-without-sorting-easy-to-uderstand-with-comments",
                "content": "```\\nclass MedianFinder {\\n    int count=0;\\n    ArrayList<Integer> list;\\n    public MedianFinder() {\\n        list=new ArrayList<>();\\n    }\\n    \\n    public void addNum(int num) {\\n        int index = Collections.binarySearch(list, num); // provides the position of element in sorted list\\n        if (index < 0) index = ~index;           //if position is -ve converting it to actual postion value\\n        list.add(index,num);\\n        count++;\\n    }\\n    \\n    public double findMedian() {\\n        double median=-1.0;\\n        if(count%2==0){\\n            median=list.get(count/2-1)+list.get(count/2);\\n            median=median/2.0;\\n        }\\n        else{\\n            median=list.get(count/2);\\n        }\\n        return median;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass MedianFinder {\\n    int count=0;\\n    ArrayList<Integer> list;\\n    public MedianFinder() {\\n        list=new ArrayList<>();\\n    }\\n    \\n    public void addNum(int num) {\\n        int index = Collections.binarySearch(list, num); // provides the position of element in sorted list\\n        if (index < 0) index = ~index;           //if position is -ve converting it to actual postion value\\n        list.add(index,num);\\n        count++;\\n    }\\n    \\n    public double findMedian() {\\n        double median=-1.0;\\n        if(count%2==0){\\n            median=list.get(count/2-1)+list.get(count/2);\\n            median=median/2.0;\\n        }\\n        else{\\n            median=list.get(count/2);\\n        }\\n        return median;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805420,
                "title": "java-beats-96-memory-easiest-short-implementation-explained",
                "content": "# Intuition\\nJust implelement the 2 given functions\\n\\n# Approach\\n1. Initialize an ArrayList in the constructor.\\n\\n2. In addNum method, \\nkeep adding the incoming elements and at the time of adding itself insert them in their correct place such that they are in ascending order. (See the code)\\n\\n3. In the findMedian method,\\nReturn the middle element if the size of the list is odd,\\nElse return the average of middle two elements.\\n\\n**Why Inbuilt Sort function isn\\'t used?\\nAns: Because it\\'s giving Time Limit Exceeding(TLE) Error**\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass MedianFinder {\\n    List<Integer> list; \\n    public MedianFinder() {\\n        this.list = new ArrayList<Integer>();\\n    }\\n    \\n    public void addNum(int num) {\\n        if(list.size() == 0) list.add(0, num);  \\n        else{\\n            int i=0;\\n            while(list.get(i) <= num && i<list.size()-1) i++;\\n            //*****The reason why I didn\\'t traversed till the last index was to escape from IndexOutOfBounds Error*****\\n            if(list.get(i) <= num) list.add(i+1, num);\\n            else list.add(i, num);\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        int n = list.size();\\n        if(n == 0) return 0;\\n        if(n%2 == 1) return list.get(n/2);\\n        return (double)((list.get(n/2) + list.get(n/2 - 1)))/2;\\n    }\\n}\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder obj = new MedianFinder();\\n * obj.addNum(num);\\n * double param_2 = obj.findMedian();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MedianFinder {\\n    List<Integer> list; \\n    public MedianFinder() {\\n        this.list = new ArrayList<Integer>();\\n    }\\n    \\n    public void addNum(int num) {\\n        if(list.size() == 0) list.add(0, num);  \\n        else{\\n            int i=0;\\n            while(list.get(i) <= num && i<list.size()-1) i++;\\n            //*****The reason why I didn\\'t traversed till the last index was to escape from IndexOutOfBounds Error*****\\n            if(list.get(i) <= num) list.add(i+1, num);\\n            else list.add(i, num);\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        int n = list.size();\\n        if(n == 0) return 0;\\n        if(n%2 == 1) return list.get(n/2);\\n        return (double)((list.get(n/2) + list.get(n/2 - 1)))/2;\\n    }\\n}\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder obj = new MedianFinder();\\n * obj.addNum(num);\\n * double param_2 = obj.findMedian();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714911,
                "title": "java-solution-using-min-and-max-heaps",
                "content": "```\\nclass MedianFinder {\\n        /*\\nKey points to solve this problem :-\\n- > create max heap for smaller half of the list\\n- > create min heap for the larger half of the list\\n- > check the size of the two heaps, if they differ by more the 1 element, rebalace them by transfering 1 element from heap with greater size to smaller\\n-> if the two heaps has equal sizes, median will be average of top element of min and the max heap\\n- > else if whichever heaps has the max no. of elements, top element of that heap will be the median\\n    */\\n\\n    \\n    PriorityQueue<Integer> minHeap = new PriorityQueue<Integer>();\\n    PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(Collections.reverseOrder());\\n    public MedianFinder() {\\n        \\n    }\\n    public void addNum(int num) {\\n        if(maxHeap.size() == 0 || maxHeap.peek() >= num){\\n            maxHeap.add(num);\\n        }\\n        else{\\n            minHeap.add(num);\\n        }\\n        if(maxHeap.size() > minHeap.size() + 1){\\n            minHeap.add(maxHeap.poll());\\n        }\\n        if(minHeap.size() > maxHeap.size() + 1){\\n            maxHeap.add(minHeap.poll());\\n        }\\n    }\\n    \\n    public double findMedian() {\\n       double median = 0.0;\\n       if(minHeap.size() > maxHeap.size()){\\n           median = minHeap.peek();\\n       }else if(maxHeap.size() > minHeap.size()){\\n           median = maxHeap.peek();\\n       }else{\\n           median = (minHeap.peek() + maxHeap.peek())/2.0;\\n       }\\n      return median;\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass MedianFinder {\\n        /*\\nKey points to solve this problem :-\\n- > create max heap for smaller half of the list\\n- > create min heap for the larger half of the list\\n- > check the size of the two heaps, if they differ by more the 1 element, rebalace them by transfering 1 element from heap with greater size to smaller\\n-> if the two heaps has equal sizes, median will be average of top element of min and the max heap\\n- > else if whichever heaps has the max no. of elements, top element of that heap will be the median\\n    */\\n\\n    \\n    PriorityQueue<Integer> minHeap = new PriorityQueue<Integer>();\\n    PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(Collections.reverseOrder());\\n    public MedianFinder() {\\n        \\n    }\\n    public void addNum(int num) {\\n        if(maxHeap.size() == 0 || maxHeap.peek() >= num){\\n            maxHeap.add(num);\\n        }\\n        else{\\n            minHeap.add(num);\\n        }\\n        if(maxHeap.size() > minHeap.size() + 1){\\n            minHeap.add(maxHeap.poll());\\n        }\\n        if(minHeap.size() > maxHeap.size() + 1){\\n            maxHeap.add(minHeap.poll());\\n        }\\n    }\\n    \\n    public double findMedian() {\\n       double median = 0.0;\\n       if(minHeap.size() > maxHeap.size()){\\n           median = minHeap.peek();\\n       }else if(maxHeap.size() > minHeap.size()){\\n           median = maxHeap.peek();\\n       }else{\\n           median = (minHeap.peek() + maxHeap.peek())/2.0;\\n       }\\n      return median;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668097,
                "title": "simple-code-using-pbds",
                "content": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n  \\n#define ordered_set tree<double, null_type,less_equal<double>, rb_tree_tag,tree_order_statistics_node_update>\\nclass MedianFinder {\\npublic:\\n    ordered_set s;\\n    int size=0;\\n    MedianFinder() {\\n        \\n    }\\n    void addNum(int num) {\\n        s.insert(double(num));\\n        size++;\\n    }\\n    \\n    double findMedian() {\\n        if(size%2==1)\\n            return *(s.find_by_order(size/2));\\n        else\\n            return (*(s.find_by_order(size/2))+*(s.find_by_order(size/2-1)))/2;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n  \\n#define ordered_set tree<double, null_type,less_equal<double>, rb_tree_tag,tree_order_statistics_node_update>\\nclass MedianFinder {\\npublic:\\n    ordered_set s;\\n    int size=0;\\n    MedianFinder() {\\n        \\n    }\\n    void addNum(int num) {\\n        s.insert(double(num));\\n        size++;\\n    }\\n    \\n    double findMedian() {\\n        if(size%2==1)\\n            return *(s.find_by_order(size/2));\\n        else\\n            return (*(s.find_by_order(size/2))+*(s.find_by_order(size/2-1)))/2;\\n    }\\n};",
                "codeTag": "C++"
            },
            {
                "id": 2446327,
                "title": "3-approaches-explained-in-detail-c-code",
                "content": "**APPROACH-1:** We sort the \\'arr\\' everytime after an insertion\\n-> So, we apply the insertion_sort() here, as the array is almost sorted every time (only one element is inserted)\\n\\n**TC: O(N^2)** -> N: Number of insertions, N: insertion_sort()\\n**SC: O(1)**, as we don\\'t take any aux space\\n\\n\\n```\\nclass MedianFinder {\\n    vector<int> arr;\\n    \\npublic:\\n    MedianFinder() {\\n    }\\n    void addNum(int num) {\\n        arr.push_back(num);\\n        insertion_sort(arr);\\n    }\\n    \\n    double findMedian() {\\n        int n=arr.size();\\n        return n%2==1? arr[n/2] : (double)(arr[n/2]+arr[n/2-1])/2.0;\\n    }\\n    \\n    void insertion_sort(vector<int> &arr){\\n        for(int i=arr.size()-1; i>=0; i--){\\n            if(i-1>=0 && arr[i]<arr[i-1]) swap(arr[i],arr[i-1]);\\n            else break;\\n        }\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n**APPROACH-2: DO WE NEED TO SORT THE ENTIRE ARRAY?**\\n-> **NO!** we only need the middle elements(s) in ordered form\\n-> So, we can apply **quick_select()** algorithm here, as it does the same thing that we want\\n-> There will be two cases- \\n    - in case of odd size, we need only one element\\n    - in case pf even size, we need two elements\\n\\n**TC: O(N^2)** ->  N: Number of insertions, N: quick_select() takes O(N), as the search space gets reduced in this way - N, N/2, N/4,... (in average case BTW)\\n**SC: O(logN),** for the stack space -> can be O(N) in extremely worst cases\\n\\n```\\nclass MedianFinder {\\n    vector<int> arr;\\n    \\npublic:\\n    MedianFinder() {\\n        \\n    }\\n    \\n    void addNum(int num) {\\n        arr.push_back(num);\\n    }\\n    \\n    double findMedian() {\\n        int n=arr.size();\\n        if(n%2==1){\\n            int itf=n/2;\\n            quick_select(arr,0,n-1,itf);  // O(N) -> Search space-> N, N/2, N/4, N/8, ... and so on \\n            return arr[itf];\\n        } \\n        \\n        int itf1=n/2, itf2=n/2-1;\\n        quick_select(arr,0,n-1,itf1);\\n        quick_select(arr,0,n-1,itf2);\\n        return (arr[itf1]+arr[itf2])/2.0;\\n    }\\n    \\n    void quick_select(vector<int> &arr, int lb, int ub, int itf){\\n        int pi=partition(arr,lb,ub);\\n        if(pi==itf) return;\\n        if(pi<itf) quick_select(arr,pi+1,ub,itf);\\n        else quick_select(arr,lb,pi-1,itf); \\n    }\\n    \\n    int partition(vector<int> &arr, int lb, int ub){\\n        int pivot=ub, i=lb, j=lb;\\n        while(j<pivot){\\n            if(arr[j]<arr[pivot]) swap(arr[i],arr[j]), i++;\\n            j++;\\n        }\\n        swap(arr[i],arr[pivot]);\\n        return i;\\n    } \\n};\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n**APPROACH-3: USING HEAP (PRIORITY_QUEUE)**\\n-> We divide the entire array into two halves, and there can be two cases -\\n    - In case of ODD size, the maximum element from the left side will be the mediun (as we keep one extra element in the left side)\\n    - In case of EVEN size, the average of \\'maximum from left\\' and \\'minimum from right\\' will be the mediun\\n-> In order to maintain the max and min from both the sides respectively we can use maxHeap for the left-side (as the root will hold the max), and minHeap for the right-side (as the root will hold the min)\\n\\n**BUT, WHEN TO INSERT IN WHICH SIDE?**\\n-> There can be **3 major cases**-\\n    1. When both the sides are empty - Insertion will take place in left side for sure\\n    2. When both the sides have equal elements (but, not 0) - One element will surely be inserted in left-side as we keep one extra element in left side, BUT not \\n       necesarily the current element. There will be 2 cases-\\n        - when the current element is lesser than the minimum of right-side, the current element will surely be inserted in left-side, as there\\'s NO VIOLATION\\n        - Otherwise, shift the minHeap.top() to the maxHeap, and push the \\'num\\' in minHeap (to maintain the overall ordering)\\n    3. When left-side already have one extra element - in this case one element will surely be inserted in right-side, BUT not necessarily the current one. There \\n       will be 2 cases-\\n        - if the current element is greater than the maximum of left-side, then obviously the current element will be placed in the right-side (No Violation)\\n        - Otherwise, we need to shift the maxHeap.top() to the minHeap, and push the \\'num\\' in maxHeap\\n\\n**TC: O(NlogN)**, as it takes O(logN) for the operations in HEAP\\n**SC: O(N),** as we store the elements in HEAP\\n\\n```\\nclass MedianFinder {\\npublic:\\n    priority_queue<int> maxheap; //1st half  -> in case odd size of the total stream, the extra ele will be in the left half (max-heap)\\n    priority_queue<int,vector<int>,greater<int>> minheap; //2nd half \\n    \\n    MedianFinder() {\\n        \\n    }\\n    \\n    void addNum(int num) {\\n        int lsize = maxheap.size();\\n        int rsize = minheap.size();\\n        \\n        if(lsize==0) maxheap.push(num);  // the right-half is surely empty -> so, num is the 1st element in stream -> store it in the first half \\n        else if(lsize==rsize) {  // as the max-heap can take one extra element -> So, ONE element will go on first half (BUT, NOT NECESSARILY \\'NUM\\')\\n            if(num<minheap.top()) maxheap.push(num); // when num<miHeap.top(), num can be pushed into the maxHeap  -> No Violation\\n            else {  // Otherwise, shift the minHeap.top() to the maxHeap, and push the \\'num\\' in minHeap\\n                int temp = minheap.top(); minheap.pop();  \\n                maxheap.push(temp);\\n                minheap.push(num); \\n            }\\n        }\\n        else {  // lsize!=0, and lsize!=rsize -> that means lsize>rsize. So, one element will surely be inserted in right side (BUT, NOT NECESSARILY \\'NUM\\') \\n            if(num>maxheap.top()) minheap.push(num);  // when num>maxHeap.top(), it will obviously go on the right-side -> No Violation\\n            else{ // Otherwise, we need to shift the maxHeap.top() to the minHeap, and push the \\'num\\' in maxHeap\\n                int temp = maxheap.top(); maxheap.pop();\\n                maxheap.push(num);\\n                minheap.push(temp);\\n            }\\n        }\\n    } \\n    \\n    \\n    double findMedian() {\\n        int totSize = maxheap.size() + minheap.size();\\n        return totSize%2==1? maxheap.top() : (maxheap.top()+minheap.top())/2.0;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MedianFinder {\\n    vector<int> arr;\\n    \\npublic:\\n    MedianFinder() {\\n    }\\n    void addNum(int num) {\\n        arr.push_back(num);\\n        insertion_sort(arr);\\n    }\\n    \\n    double findMedian() {\\n        int n=arr.size();\\n        return n%2==1? arr[n/2] : (double)(arr[n/2]+arr[n/2-1])/2.0;\\n    }\\n    \\n    void insertion_sort(vector<int> &arr){\\n        for(int i=arr.size()-1; i>=0; i--){\\n            if(i-1>=0 && arr[i]<arr[i-1]) swap(arr[i],arr[i-1]);\\n            else break;\\n        }\\n    }\\n};\\n```\n```\\nclass MedianFinder {\\n    vector<int> arr;\\n    \\npublic:\\n    MedianFinder() {\\n        \\n    }\\n    \\n    void addNum(int num) {\\n        arr.push_back(num);\\n    }\\n    \\n    double findMedian() {\\n        int n=arr.size();\\n        if(n%2==1){\\n            int itf=n/2;\\n            quick_select(arr,0,n-1,itf);  // O(N) -> Search space-> N, N/2, N/4, N/8, ... and so on \\n            return arr[itf];\\n        } \\n        \\n        int itf1=n/2, itf2=n/2-1;\\n        quick_select(arr,0,n-1,itf1);\\n        quick_select(arr,0,n-1,itf2);\\n        return (arr[itf1]+arr[itf2])/2.0;\\n    }\\n    \\n    void quick_select(vector<int> &arr, int lb, int ub, int itf){\\n        int pi=partition(arr,lb,ub);\\n        if(pi==itf) return;\\n        if(pi<itf) quick_select(arr,pi+1,ub,itf);\\n        else quick_select(arr,lb,pi-1,itf); \\n    }\\n    \\n    int partition(vector<int> &arr, int lb, int ub){\\n        int pivot=ub, i=lb, j=lb;\\n        while(j<pivot){\\n            if(arr[j]<arr[pivot]) swap(arr[i],arr[j]), i++;\\n            j++;\\n        }\\n        swap(arr[i],arr[pivot]);\\n        return i;\\n    } \\n};\\n```\n```\\nclass MedianFinder {\\npublic:\\n    priority_queue<int> maxheap; //1st half  -> in case odd size of the total stream, the extra ele will be in the left half (max-heap)\\n    priority_queue<int,vector<int>,greater<int>> minheap; //2nd half \\n    \\n    MedianFinder() {\\n        \\n    }\\n    \\n    void addNum(int num) {\\n        int lsize = maxheap.size();\\n        int rsize = minheap.size();\\n        \\n        if(lsize==0) maxheap.push(num);  // the right-half is surely empty -> so, num is the 1st element in stream -> store it in the first half \\n        else if(lsize==rsize) {  // as the max-heap can take one extra element -> So, ONE element will go on first half (BUT, NOT NECESSARILY \\'NUM\\')\\n            if(num<minheap.top()) maxheap.push(num); // when num<miHeap.top(), num can be pushed into the maxHeap  -> No Violation\\n            else {  // Otherwise, shift the minHeap.top() to the maxHeap, and push the \\'num\\' in minHeap\\n                int temp = minheap.top(); minheap.pop();  \\n                maxheap.push(temp);\\n                minheap.push(num); \\n            }\\n        }\\n        else {  // lsize!=0, and lsize!=rsize -> that means lsize>rsize. So, one element will surely be inserted in right side (BUT, NOT NECESSARILY \\'NUM\\') \\n            if(num>maxheap.top()) minheap.push(num);  // when num>maxHeap.top(), it will obviously go on the right-side -> No Violation\\n            else{ // Otherwise, we need to shift the maxHeap.top() to the minHeap, and push the \\'num\\' in maxHeap\\n                int temp = maxheap.top(); maxheap.pop();\\n                maxheap.push(num);\\n                minheap.push(temp);\\n            }\\n        }\\n    } \\n    \\n    \\n    double findMedian() {\\n        int totSize = maxheap.size() + minheap.size();\\n        return totSize%2==1? maxheap.top() : (maxheap.top()+minheap.top())/2.0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2384644,
                "title": "python-o-logn-optimised-solution-two-heaps",
                "content": "\\nSolution structure:\\n* I have used two heaps: max_heap and min_heap to store left and right elements to the median resp.  \\n\\t* whenever a new number comes I can check if it should go into left block or right block\\n\\t* left block elements: numbers less than median value are stored in max_heap, I have used max_heap since I will be checking with the highest value element everytime.\\n\\t* right block elements: numbers greater than median value are stored in min_heap, I have used min_heap since I will be checking with the lowest value element everytime.\\n* when list has odd numbers: median will be stored in min_heap, `median = min_heap[0]`\\n\\t* here, `len(max_heap) + 1 = len(min_heap)`\\n* when list has even numbers: each of the median numbers will be stored in max_heap and min_heap, `median = (max_heap[0] + min_heap[0] ) / 2 `\\n\\t* here, `len(max_heap) = len(min_heap)`\\n\\nTime complexity: \\n* addNum: `O(logn)`\\n* findMedian: `O(1)`\\n\\n\\n```python\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        self.min_hp = []\\n        self.max_hp = []\\n        \\n    def addNum(self, num: int) -> None:\\n        if len(self.min_hp) == len(self.max_hp):\\n            if len(self.max_hp) and num<-self.max_hp[0]:\\n                cur = -heapq.heappop(self.max_hp)\\n                heapq.heappush(self.max_hp, -num)\\n                heapq.heappush(self.min_hp, cur)\\n            else:\\n                heapq.heappush(self.min_hp, num)\\n        else:\\n            if num>self.min_hp[0]:\\n                cur = heapq.heappop(self.min_hp)\\n                heapq.heappush(self.min_hp, num)\\n                heapq.heappush(self.max_hp, -cur)\\n            else:\\n                heapq.heappush(self.max_hp, -num)\\n        \\n    def findMedian(self) -> float:\\n        if len(self.min_hp) == len(self.max_hp):\\n            return (self.min_hp[0] + -self.max_hp[0]) /2\\n        else:\\n            return self.min_hp[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        self.min_hp = []\\n        self.max_hp = []\\n        \\n    def addNum(self, num: int) -> None:\\n        if len(self.min_hp) == len(self.max_hp):\\n            if len(self.max_hp) and num<-self.max_hp[0]:\\n                cur = -heapq.heappop(self.max_hp)\\n                heapq.heappush(self.max_hp, -num)\\n                heapq.heappush(self.min_hp, cur)\\n            else:\\n                heapq.heappush(self.min_hp, num)\\n        else:\\n            if num>self.min_hp[0]:\\n                cur = heapq.heappop(self.min_hp)\\n                heapq.heappush(self.min_hp, num)\\n                heapq.heappush(self.max_hp, -cur)\\n            else:\\n                heapq.heappush(self.max_hp, -num)\\n        \\n    def findMedian(self) -> float:\\n        if len(self.min_hp) == len(self.max_hp):\\n            return (self.min_hp[0] + -self.max_hp[0]) /2\\n        else:\\n            return self.min_hp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375029,
                "title": "c-priority-queue-min-heap-and-max-heap",
                "content": "Basic idea : \\nLet we have two boxes ( left box and right box )  then, \\n1) Max difference between number of elements of the two box should be 1\\n2) All elements of left box should be smaller than all elements of right box\\n```\\nclass MedianFinder {\\npublic:\\n    \\n    priority_queue<int> left;\\n    priority_queue<int,vector<int>, greater<int> > right;\\n    \\n    MedianFinder() {\\n    }\\n    \\n    void addNum (int num) {\\n        // initial condition\\n        if ( left.size() == 0){\\n            left.push(num);\\n        }\\n        else if ( left.size() > right.size() ){\\n            \\n            if( num > left.top() ) right.push(num);\\n            else{\\n                right.push( left.top() );\\n                left.pop();\\n                left.push(num);\\n            }\\n        }\\n        else if ( left.size() < right.size() ){\\n            \\n            if ( num < right.top() ) left.push(num);\\n            else {\\n                left.push(right.top());\\n                right.pop(); \\n                right.push(num);\\n            }\\n        }\\n        else {\\n            if( num > left.top() ) right.push(num);\\n            else left.push(num);\\n        }\\n        \\n    }\\n    \\n    double findMedian() {\\n        \\n        if ( left.size() > right.size() ) return left.top();\\n\\t\\t\\n        else if (right.size() > left.size()) return right.top();\\n\\t\\t\\n        else return (left.top()+right.top())/2.0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass MedianFinder {\\npublic:\\n    \\n    priority_queue<int> left;\\n    priority_queue<int,vector<int>, greater<int> > right;\\n    \\n    MedianFinder() {\\n    }\\n    \\n    void addNum (int num) {\\n        // initial condition\\n        if ( left.size() == 0){\\n            left.push(num);\\n        }\\n        else if ( left.size() > right.size() ){\\n            \\n            if( num > left.top() ) right.push(num);\\n            else{\\n                right.push( left.top() );\\n                left.pop();\\n                left.push(num);\\n            }\\n        }\\n        else if ( left.size() < right.size() ){\\n            \\n            if ( num < right.top() ) left.push(num);\\n            else {\\n                left.push(right.top());\\n                right.pop(); \\n                right.push(num);\\n            }\\n        }\\n        else {\\n            if( num > left.top() ) right.push(num);\\n            else left.push(num);\\n        }\\n        \\n    }\\n    \\n    double findMedian() {\\n        \\n        if ( left.size() > right.size() ) return left.top();\\n\\t\\t\\n        else if (right.size() > left.size()) return right.top();\\n\\t\\t\\n        else return (left.top()+right.top())/2.0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298911,
                "title": "last-test-case-is-failing",
                "content": "I implemented two heap soultion with JavaScript. Since JavaScript itself doesn\\'t provide any built-in heaps, I implemented my own heaps implemetation for min and max heaps. \\n\\nThis soultion is passing 21/22 testcases yet the last one which contains 49999 quries failing for some reason.\\nI belive issues lies with my heap\\'s trickle down and up code. But to actually debug this is overhelming task because of the huge test case.\\n\\nI went through my code countless times but still unable to find what is the issue.  Here is my soultion. Am I missing someting here ?\\n\\n```\\nvar MedianFinder = function () {\\n  this.smallHeap = new Heap.max();\\n  this.bigHeap = new Heap.min();\\n};\\n\\n/**\\n * @param {number} num\\n * @return {void}\\n */\\nMedianFinder.prototype.addNum = function (num) {\\n  this.smallHeap.heapPush(num);\\n\\n  if (this.smallHeap.heapPeek() > this.bigHeap.heapPeek()) {\\n    this.bigHeap.heapPush(this.smallHeap.heapPop());\\n  }\\n  const diff = Math.abs(this.smallHeap.length() - this.bigHeap.length());\\n  if (diff > 1) {\\n    const largerLength = Math.max(\\n      this.smallHeap.length(),\\n      this.bigHeap.length()\\n    );\\n    if (this.smallHeap.length() === largerLength) {\\n      this.bigHeap.heapPush(this.smallHeap.heapPop());\\n    } else {\\n      this.smallHeap.heapPush(this.bigHeap.heapPop());\\n    }\\n  }\\n};\\n\\n/**\\n * @return {number}\\n */\\nMedianFinder.prototype.findMedian = function () {\\n  const smallLength = this.smallHeap.length();\\n  const bigLength = this.bigHeap.length();\\n  if (smallLength === bigLength) {\\n    return (this.smallHeap.heapPeek() + this.bigHeap.heapPeek()) / 2;\\n  }\\n  const maxLength = Math.max(smallLength, bigLength);\\n  if (smallLength === maxLength) {\\n    return this.smallHeap.heapPeek();\\n  }\\n  return this.bigHeap.heapPeek();\\n};\\n```\\n\\nAnd the heaps code,\\n\\n```\\nconst trickleUp = function (heapType, heap) {\\n  return function (val) {\\n    // trickle up\\n    heap.push(val);\\n    if (heap.length < 2) {\\n      return heap.length;\\n    }\\n\\n    let i = heap.length - 1;\\n    while (i > 0) {\\n      const parent = Math.floor((i - 1) / 2);\\n      // change the condtion beased on heap type\\n      if (heapType === \"max\" && heap[i] <= heap[parent]) {\\n        break;\\n      }\\n      if (heapType === \"min\" && heap[i] >= heap[parent]) {\\n        break;\\n      }\\n      const temp = heap[i];\\n      heap[i] = heap[parent];\\n      heap[parent] = temp;\\n      i = parent;\\n    }\\n    return heap.length;\\n  };\\n};\\n\\nconst trickleDown = function (heapType, heap) {\\n  return function () {\\n    // trickle up\\n    if (heap.length < 2) {\\n      return heap.pop();\\n    }\\n    const top = heap[0];\\n    heap[0] = heap.pop();\\n\\tlet i=0;\\n    while(i*2+1 < heap.length) {\\n      const left = i*2 + 1;\\n      const right = i*2 + 2;\\n      const parent = i;\\n      /*\\n\\t\\tleft should definitely exsist if insed the loop\\n\\t\\twhy? i+1<heap.length\\n\\n\\t\\tbut right child might or might not exisits\\n        */\\n      const childVal = heap[right]\\n        ? Math[heapType](heap[left], heap[right])\\n        : heap[left];\\n      // check need to perform swap\\n      if (heapType === \"max\" && childVal <= heap[parent]) {\\n        break;\\n      }\\n      if (heapType === \"min\" && childVal >= heap[parent]) {\\n        break;\\n      }\\n      //which child to swap\\n      const child = heap[left] === childVal ? left : right;\\n      // swap\\n      const temp = heap[parent];\\n      heap[parent] = heap[child];\\n      heap[child] = temp;\\n\\t  i=child;\\n    }\\n\\n    return top;\\n  };\\n};\\n\\nconst Heap = (function () {\\n  const heapFunc = function (heapType) {\\n    return function () {\\n      const heap = [];\\n      const heapPush = trickleUp(heapType, heap);\\n      const heapPop = trickleDown(heapType, heap);\\n      return {\\n        length: function () {\\n          return heap.length;\\n        },\\n        heapPush,\\n        heapPop,\\n        heapPeek: () => heap[0],\\n\\t\\theap\\n      };\\n    };\\n  };\\n\\n  return {\\n    max: heapFunc(\"max\"),\\n    min: heapFunc(\"min\"),\\n  };\\n})();\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar MedianFinder = function () {\\n  this.smallHeap = new Heap.max();\\n  this.bigHeap = new Heap.min();\\n};\\n\\n/**\\n * @param {number} num\\n * @return {void}\\n */\\nMedianFinder.prototype.addNum = function (num) {\\n  this.smallHeap.heapPush(num);\\n\\n  if (this.smallHeap.heapPeek() > this.bigHeap.heapPeek()) {\\n    this.bigHeap.heapPush(this.smallHeap.heapPop());\\n  }\\n  const diff = Math.abs(this.smallHeap.length() - this.bigHeap.length());\\n  if (diff > 1) {\\n    const largerLength = Math.max(\\n      this.smallHeap.length(),\\n      this.bigHeap.length()\\n    );\\n    if (this.smallHeap.length() === largerLength) {\\n      this.bigHeap.heapPush(this.smallHeap.heapPop());\\n    } else {\\n      this.smallHeap.heapPush(this.bigHeap.heapPop());\\n    }\\n  }\\n};\\n\\n/**\\n * @return {number}\\n */\\nMedianFinder.prototype.findMedian = function () {\\n  const smallLength = this.smallHeap.length();\\n  const bigLength = this.bigHeap.length();\\n  if (smallLength === bigLength) {\\n    return (this.smallHeap.heapPeek() + this.bigHeap.heapPeek()) / 2;\\n  }\\n  const maxLength = Math.max(smallLength, bigLength);\\n  if (smallLength === maxLength) {\\n    return this.smallHeap.heapPeek();\\n  }\\n  return this.bigHeap.heapPeek();\\n};\\n```\n```\\nconst trickleUp = function (heapType, heap) {\\n  return function (val) {\\n    // trickle up\\n    heap.push(val);\\n    if (heap.length < 2) {\\n      return heap.length;\\n    }\\n\\n    let i = heap.length - 1;\\n    while (i > 0) {\\n      const parent = Math.floor((i - 1) / 2);\\n      // change the condtion beased on heap type\\n      if (heapType === \"max\" && heap[i] <= heap[parent]) {\\n        break;\\n      }\\n      if (heapType === \"min\" && heap[i] >= heap[parent]) {\\n        break;\\n      }\\n      const temp = heap[i];\\n      heap[i] = heap[parent];\\n      heap[parent] = temp;\\n      i = parent;\\n    }\\n    return heap.length;\\n  };\\n};\\n\\nconst trickleDown = function (heapType, heap) {\\n  return function () {\\n    // trickle up\\n    if (heap.length < 2) {\\n      return heap.pop();\\n    }\\n    const top = heap[0];\\n    heap[0] = heap.pop();\\n\\tlet i=0;\\n    while(i*2+1 < heap.length) {\\n      const left = i*2 + 1;\\n      const right = i*2 + 2;\\n      const parent = i;\\n      /*\\n\\t\\tleft should definitely exsist if insed the loop\\n\\t\\twhy? i+1<heap.length\\n\\n\\t\\tbut right child might or might not exisits\\n        */\\n      const childVal = heap[right]\\n        ? Math[heapType](heap[left], heap[right])\\n        : heap[left];\\n      // check need to perform swap\\n      if (heapType === \"max\" && childVal <= heap[parent]) {\\n        break;\\n      }\\n      if (heapType === \"min\" && childVal >= heap[parent]) {\\n        break;\\n      }\\n      //which child to swap\\n      const child = heap[left] === childVal ? left : right;\\n      // swap\\n      const temp = heap[parent];\\n      heap[parent] = heap[child];\\n      heap[child] = temp;\\n\\t  i=child;\\n    }\\n\\n    return top;\\n  };\\n};\\n\\nconst Heap = (function () {\\n  const heapFunc = function (heapType) {\\n    return function () {\\n      const heap = [];\\n      const heapPush = trickleUp(heapType, heap);\\n      const heapPop = trickleDown(heapType, heap);\\n      return {\\n        length: function () {\\n          return heap.length;\\n        },\\n        heapPush,\\n        heapPop,\\n        heapPeek: () => heap[0],\\n\\t\\theap\\n      };\\n    };\\n  };\\n\\n  return {\\n    max: heapFunc(\"max\"),\\n    min: heapFunc(\"min\"),\\n  };\\n})();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2298430,
                "title": "simple-with-heap",
                "content": "```\\ntype MedianFinder struct {\\n    minH minHeap\\n    maxH maxHeap\\n}\\n\\nfunc Constructor() MedianFinder {\\n    var minH minHeap\\n    var maxH maxHeap\\n    \\n    return MedianFinder {\\n        minH: minH,\\n        maxH: maxH,\\n    }\\n}\\n\\nfunc (this *MedianFinder) AddNum(num int)  {\\n    if len(this.maxH) == 0 || num <= this.maxH[0] {\\n        this.maxH.add(num)\\n    } else {\\n        this.minH.add(num)\\n    }\\n    \\n    if len(this.maxH) > len(this.minH)+1 {\\n        this.minH.add(this.maxH.pop())\\n    } else if len(this.maxH) < len(this.minH) {\\n        this.maxH.add(this.minH.pop())\\n    }\\n}\\n\\nfunc (this *MedianFinder) FindMedian() float64 {\\n    if len(this.minH) == len(this.maxH) {\\n        return (float64(this.minH[0]) + float64(this.maxH[0]))/float64(2)\\n    }\\n    \\n    return float64(this.maxH[0])\\n}\\n\\ntype minHeap []int\\n\\ntype maxHeap []int\\n\\nfunc (h *maxHeap) pop() int {\\n    poppedItem := (*h)[0]\\n    \\n    (*h)[0] = (*h)[len(*h)-1]\\n    (*h) = (*h)[:len(*h)-1]\\n    h.heapDown(0)\\n    \\n    return poppedItem\\n}\\n\\nfunc (h *minHeap) pop() int {\\n    poppedItem := (*h)[0]\\n    \\n    (*h)[0] = (*h)[len(*h)-1]\\n    (*h) = (*h)[:len(*h)-1]\\n    h.heapDown(0)\\n    \\n    return poppedItem\\n}\\n\\nfunc (h *minHeap) add(num int) {\\n    *h = append(*h, num)\\n    h.heapUp(len(*h)-1)\\n}\\n\\nfunc (h *maxHeap) add(num int) {\\n    *h = append(*h, num)\\n    h.heapUp(len(*h)-1)\\n}\\n\\nfunc (h *minHeap) heapDown(p int) {\\n    l, r := 2*p+1, 2*p+2\\n    smaller := p\\n    \\n    if l < len(*h) && (*h)[l] < (*h)[smaller] {\\n        smaller = l\\n    }\\n    \\n    if r < len(*h) && (*h)[r] < (*h)[smaller] {\\n        smaller = r\\n    }\\n    \\n    if smaller != p {\\n        (*h)[smaller], (*h)[p] = (*h)[p], (*h)[smaller]\\n        h.heapDown(smaller)\\n    }\\n}\\n\\nfunc (h *minHeap) heapUp(p int) {\\n    parent := (p-1)/2\\n    \\n    if parent >= 0 && (*h)[p] < (*h)[parent] {\\n        (*h)[p], (*h)[parent] = (*h)[parent], (*h)[p]\\n        h.heapUp(parent)\\n    }\\n}\\n\\nfunc (h *maxHeap) heapDown(p int) {\\n    l, r := 2*p+1, 2*p+2\\n    bigger := p \\n    \\n    if l < len(*h) && (*h)[l] > (*h)[bigger] {\\n        bigger = l\\n    }\\n    \\n    if r < len(*h)&& (*h)[r] > (*h)[bigger] {\\n        bigger = r\\n    }\\n    \\n    if bigger != p {\\n        (*h)[bigger], (*h)[p] = (*h)[p], (*h)[bigger]\\n        h.heapDown(bigger)\\n    }\\n}\\n\\nfunc (h *maxHeap) heapUp(p int) {\\n    parent := (p-1)/2\\n    \\n    if parent >= 0 && (*h)[p] > (*h)[parent] {\\n        (*h)[p], (*h)[parent] = (*h)[parent], (*h)[p]\\n        h.heapUp(parent)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntype MedianFinder struct {\\n    minH minHeap\\n    maxH maxHeap\\n}\\n\\nfunc Constructor() MedianFinder {\\n    var minH minHeap\\n    var maxH maxHeap\\n    \\n    return MedianFinder {\\n        minH: minH,\\n        maxH: maxH,\\n    }\\n}\\n\\nfunc (this *MedianFinder) AddNum(num int)  {\\n    if len(this.maxH) == 0 || num <= this.maxH[0] {\\n        this.maxH.add(num)\\n    } else {\\n        this.minH.add(num)\\n    }\\n    \\n    if len(this.maxH) > len(this.minH)+1 {\\n        this.minH.add(this.maxH.pop())\\n    } else if len(this.maxH) < len(this.minH) {\\n        this.maxH.add(this.minH.pop())\\n    }\\n}\\n\\nfunc (this *MedianFinder) FindMedian() float64 {\\n    if len(this.minH) == len(this.maxH) {\\n        return (float64(this.minH[0]) + float64(this.maxH[0]))/float64(2)\\n    }\\n    \\n    return float64(this.maxH[0])\\n}\\n\\ntype minHeap []int\\n\\ntype maxHeap []int\\n\\nfunc (h *maxHeap) pop() int {\\n    poppedItem := (*h)[0]\\n    \\n    (*h)[0] = (*h)[len(*h)-1]\\n    (*h) = (*h)[:len(*h)-1]\\n    h.heapDown(0)\\n    \\n    return poppedItem\\n}\\n\\nfunc (h *minHeap) pop() int {\\n    poppedItem := (*h)[0]\\n    \\n    (*h)[0] = (*h)[len(*h)-1]\\n    (*h) = (*h)[:len(*h)-1]\\n    h.heapDown(0)\\n    \\n    return poppedItem\\n}\\n\\nfunc (h *minHeap) add(num int) {\\n    *h = append(*h, num)\\n    h.heapUp(len(*h)-1)\\n}\\n\\nfunc (h *maxHeap) add(num int) {\\n    *h = append(*h, num)\\n    h.heapUp(len(*h)-1)\\n}\\n\\nfunc (h *minHeap) heapDown(p int) {\\n    l, r := 2*p+1, 2*p+2\\n    smaller := p\\n    \\n    if l < len(*h) && (*h)[l] < (*h)[smaller] {\\n        smaller = l\\n    }\\n    \\n    if r < len(*h) && (*h)[r] < (*h)[smaller] {\\n        smaller = r\\n    }\\n    \\n    if smaller != p {\\n        (*h)[smaller], (*h)[p] = (*h)[p], (*h)[smaller]\\n        h.heapDown(smaller)\\n    }\\n}\\n\\nfunc (h *minHeap) heapUp(p int) {\\n    parent := (p-1)/2\\n    \\n    if parent >= 0 && (*h)[p] < (*h)[parent] {\\n        (*h)[p], (*h)[parent] = (*h)[parent], (*h)[p]\\n        h.heapUp(parent)\\n    }\\n}\\n\\nfunc (h *maxHeap) heapDown(p int) {\\n    l, r := 2*p+1, 2*p+2\\n    bigger := p \\n    \\n    if l < len(*h) && (*h)[l] > (*h)[bigger] {\\n        bigger = l\\n    }\\n    \\n    if r < len(*h)&& (*h)[r] > (*h)[bigger] {\\n        bigger = r\\n    }\\n    \\n    if bigger != p {\\n        (*h)[bigger], (*h)[p] = (*h)[p], (*h)[bigger]\\n        h.heapDown(bigger)\\n    }\\n}\\n\\nfunc (h *maxHeap) heapUp(p int) {\\n    parent := (p-1)/2\\n    \\n    if parent >= 0 && (*h)[p] > (*h)[parent] {\\n        (*h)[p], (*h)[parent] = (*h)[parent], (*h)[p]\\n        h.heapUp(parent)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2152596,
                "title": "python-detailed-heap-solutions-for-noobs-like-moi",
                "content": "The\\xA0**median**\\xA0is the middle value in an ordered integer list. If the size of the list is even, there is no middle value and the median is the mean of the two middle values.\\n\\n- For example, for\\xA0`arr = [2,3,4]`, the median is\\xA0`3`.\\n- For example, for\\xA0`arr = [2,3]`, the median is\\xA0`(2 + 3) / 2 = 2.5`.\\n\\nImplement the MedianFinder class:\\n\\n- `MedianFinder()`\\xA0initializes the\\xA0`MedianFinder`\\xA0object.\\n- `void addNum(int num)`\\xA0adds the integer\\xA0`num`\\xA0from the data stream to the data structure.\\n- `double findMedian()`\\xA0returns the median of all elements so far. Answers within\\xA0`105`\\xA0of the actual answer will be accepted.\\n\\n**Example 1:**\\n\\n```\\nInput\\n[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"]\\n[[], [1], [2], [], [3], []]\\nOutput\\n[null, null, null, 1.5, null, 2.0]\\n\\nExplanation\\nMedianFinder medianFinder = new MedianFinder();\\nmedianFinder.addNum(1);    // arr = [1]\\nmedianFinder.addNum(2);    // arr = [1, 2]\\nmedianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\\nmedianFinder.addNum(3);    // arr[1, 2, 3]\\nmedianFinder.findMedian(); // return 2.0\\n\\n```\\n\\n**Constraints:**\\n\\n- `105\\xA0<= num <= 105`\\n- There will be at least one element in the data structure before calling\\xA0`findMedian`.\\n- At most\\xA0`5 * 104`\\xA0calls will be made to\\xA0`addNum`\\xA0and\\xA0`findMedian`.\\n\\n### Brainstorming\\n\\n1. We are given a stream of numbers coming in random order and we need to find the median of the numbers as if they were ordered. So\\n    1. numbers coming in 4,3,2,1,5 median of this will be\\n        1. First we order the numbers coming in [1,2,3,4,5]\\n        2. Median is the the value at the midpoint in a sorted array.\\n            1. So in this case it will be 3\\n                1. However there is a caveat when the array is even the median becomes the average of the two values near the middle.\\n                    1. [1,2,3,4] median = (2+3)/2 = 2.5\\n2. Now we dissected the question how can we go about solving it, A common method is that we can keep putting numbers in an array and every time we put a number in the array we sort the array. Adding an item in a sorted array will cost us a time complexity of O(n) as we will have to go over the whole array. And to add a value we will have to move all the values in the array one index ahead.\\n    1. [1,2,3,4,5 ] add 3 [1,2,3,3,4,5] will have to go over all the values until we have found the sorted position for 3 and then will have to move positions 3 will come in the place of 4 and 4 will have to be moved.See how this can get really time complex.\\n3. What do you think is a better solution for this, what if we divided the numbers coming in into two arrays one having the smaller set of numbers and the other having the larger set of numbers, after equalizing for the median. \\n    1. even [1,2,3,4] \\u2014>  can be either [1,2] [3,4] \\n        1. Median is the sum divided by 2 of the largest value in the smaller array and the smallest value of the set of larger numbers.\\n    2. odd [1,2,3,4,5] \\u2014>  it can be either [1,2,3] [4,5] or [1,2] [3,4,5]\\n        1. Median in the odd case is the largest value if the array with a smaller  set of numbers is larger(by 1 ) and the smallest value if the array with the set of larger numbers is larger in length(by 1).\\n4. Now you have seen how we can keep the order the numbers in the two separate arrays, what structure in your eyes is appropriate to get the max and the mins of separate arrays. Heaps anyone. Yes we will use heaps.\\n    1. How is heaps implemented in python\\n        \\n        Implementing a min heap requires you to use heapq.\\n        \\n        There are only min heaps in python \\n        \\n        ```python\\n        #initiated as a list\\n        minheap = []\\n        heapq.heappush(minheap,1)\\n        \\n        # to convert it into a max heap we just multiply the values by -1 so\\n        # the largest value becomes the smallest value and the min heap in python is able to get\\n        # that for you \\n        \\n        maxheap = []\\n        heapq.heappush(minheap,1 * -1)\\n        maxheap[0] # the smallest value is stored at the first index \\n        ```\\n        \\n    2. This is a little counter intuitive as we our smaller set of numbers heap is a max heap but is called small\\n        \\n        ```python\\n        #small = maxheap\\n        #large = minheap \\n        small,large = [],[]\\n        ```\\n        \\n    3. We will add the incoming number by default to the small array.\\n        \\n        ```python\\n        heapq.heappush(small,-1* incomingNumber) # -1 as this is a max heap\\n        ```\\n        \\n5. But not so fast we need to maintain the sizes of the two array as we are adding different number into them. What are a few conditions we need to maintain. As we add the numbers to the small array\\n    1. All the numbers in the smaller heap need to be less than those in the larger heap.\\n        \\n        ```python\\n        #when adding a number check [1,2] [3,4] 5 is being \\n        #added to the smaller heap [1,2,5] [3,4] \\n        #the size condition is meet but not the values in the small set being smaller\\n        #then the large set as 5 is larger value then 3 the min in the large heap.\\n        \\n        #how can we check that since we already have an imbalanced heaps\\n        \\n        if (small and large and (-1 * small[0]) > large[0]):\\n        \\t# we take the number that is too large in the small array and put it \\n        \\t# into the large array.\\n        \\t\\n        \\t#pop from small array\\n        \\tval = -1 * heapq.heappop(small) # multply by -1 again to equalize positivity :)\\n        \\t#push to large\\n        \\theapq.heappush(large, val)\\n        \\n        ```\\n        \\n        1. I know multiplying by -1 is tedious but that is the only way to implement it in python\\n    2. The difference of sizes between the two heaps can\\u2019t be more than 1.\\n        \\n        ```python\\n        if len(small) > len(large) + 1: \\n        \\t#pop from small array\\n        \\tval = -1 * heapq.heappop(small) # multply by -1 again to equalize positivity :)\\n        \\t#push to large\\n        \\theapq.heappush(large, val)\\n        \\n        \\t\\n        \\n        if len(small)+ 1 < len(large): \\n        \\t#pop from large array\\n        \\tval =  heapq.heappop(large) \\n        \\t#push to small\\n        \\theapq.heappush(small, -1* val)\\n        \\n        ```\\n        \\n6. Now the add number shenanigans are sorted ;). how do we return the median. Refer to point number 3.\\n    \\n    ```python\\n    \\n    def findMedian(self):\\n    if len(small) > len(large): # [1,2,3] [4,5]\\n    \\t# get the max from teh smalll array\\n    \\treturn -1 * small[0] \\n    elif len(small) < len(large): # [1,2] [3,4,5]\\n    \\t# get the max from teh smalll array\\n    \\t return large[0] \\n    \\n    else: \\n    \\treturn (-1* small[0] + large[0]) / 2\\n    \\n    ```\\n    \\n7. That is it lets write the code now.\\n    \\n    ```python\\n    import heapq\\n    class MedianFinder:\\n    \\n        def __init__(self):\\n            # two heaps\\n            self.small = [] # smaller set of numbers max heap \\n            self.large = [] # larger set of numbers min heap \\n            \\n            #they need to be equal\\n            \\n            \\n    \\n        def addNum(self, num: int) -> None:\\n            \\n            # push to the small heap\\n            heapq.heappush(self.small,- 1*num)\\n            \\n            # Conditions\\n            \\n            # all the numbers in the smaller heap need to be less than those in the larger heap.\\n            if (self.small and self.large and (-1 * self.small[0]) > self.large[0]): \\n                # pop from small array\\n                val = -1 * heapq.heappop(self.small) # multply by -1 again to equalize positivity :)\\n                # push to large array\\n                heapq.heappush(self.large, val)\\n                \\n                \\n            \\n            #The difference of sizes between the two heaps can\\u2019t be more than 1 \\n            # Two possibiltes \\n            \\n            \\n            if len(self.small) > len(self.large) + 1: # [1,2,4] [3]\\n                #pop from small array\\n                val = -1 * heapq.heappop(self.small) \\n                #push to large\\n                heapq.heappush(self.large, val)\\n        \\n                \\n            \\n            \\n            if (len(self.small) + 1) < len(self.large): # [1] [3,4]\\n                #pop from large array\\n                val =  heapq.heappop(self.large) \\n                #push to small\\n                heapq.heappush(self.small, -1 *val)\\n                \\n    \\n    \\t\\n    \\n                \\n    \\n        def findMedian(self) -> float:\\n            # print(self.small)\\n            # print(self.large)\\n            \\n            if len(self.small) > len(self.large): # [1,2,3] [4,5]\\n                # get the max from teh smalll array\\n                return -1 * self.small[0] \\n            elif len(self.small) < len(self.large): # [1,2] [3,4,5]\\n                # get the max from teh smalll array\\n                 return self.large[0] \\n            else: # [1,2] [3,4]\\n                return (-1 * self.small[0] + self.large[0]) / 2\\n    ```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nInput\\n[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"]\\n[[], [1], [2], [], [3], []]\\nOutput\\n[null, null, null, 1.5, null, 2.0]\\n\\nExplanation\\nMedianFinder medianFinder = new MedianFinder();\\nmedianFinder.addNum(1);    // arr = [1]\\nmedianFinder.addNum(2);    // arr = [1, 2]\\nmedianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\\nmedianFinder.addNum(3);    // arr[1, 2, 3]\\nmedianFinder.findMedian(); // return 2.0\\n\\n```\n```python\\n        #initiated as a list\\n        minheap = []\\n        heapq.heappush(minheap,1)\\n        \\n        # to convert it into a max heap we just multiply the values by -1 so\\n        # the largest value becomes the smallest value and the min heap in python is able to get\\n        # that for you \\n        \\n        maxheap = []\\n        heapq.heappush(minheap,1 * -1)\\n        maxheap[0] # the smallest value is stored at the first index \\n        ```\n```python\\n        #small = maxheap\\n        #large = minheap \\n        small,large = [],[]\\n        ```\n```python\\n        heapq.heappush(small,-1* incomingNumber) # -1 as this is a max heap\\n        ```\n```python\\n        #when adding a number check [1,2] [3,4] 5 is being \\n        #added to the smaller heap [1,2,5] [3,4] \\n        #the size condition is meet but not the values in the small set being smaller\\n        #then the large set as 5 is larger value then 3 the min in the large heap.\\n        \\n        #how can we check that since we already have an imbalanced heaps\\n        \\n        if (small and large and (-1 * small[0]) > large[0]):\\n        \\t# we take the number that is too large in the small array and put it \\n        \\t# into the large array.\\n        \\t\\n        \\t#pop from small array\\n        \\tval = -1 * heapq.heappop(small) # multply by -1 again to equalize positivity :)\\n        \\t#push to large\\n        \\theapq.heappush(large, val)\\n        \\n        ```\n```python\\n        if len(small) > len(large) + 1: \\n        \\t#pop from small array\\n        \\tval = -1 * heapq.heappop(small) # multply by -1 again to equalize positivity :)\\n        \\t#push to large\\n        \\theapq.heappush(large, val)\\n        \\n        \\t\\n        \\n        if len(small)+ 1 < len(large): \\n        \\t#pop from large array\\n        \\tval =  heapq.heappop(large) \\n        \\t#push to small\\n        \\theapq.heappush(small, -1* val)\\n        \\n        ```\n```python\\n    \\n    def findMedian(self):\\n    if len(small) > len(large): # [1,2,3] [4,5]\\n    \\t# get the max from teh smalll array\\n    \\treturn -1 * small[0] \\n    elif len(small) < len(large): # [1,2] [3,4,5]\\n    \\t# get the max from teh smalll array\\n    \\t return large[0] \\n    \\n    else: \\n    \\treturn (-1* small[0] + large[0]) / 2\\n    \\n    ```\n```python\\n    import heapq\\n    class MedianFinder:\\n    \\n        def __init__(self):\\n            # two heaps\\n            self.small = [] # smaller set of numbers max heap \\n            self.large = [] # larger set of numbers min heap \\n            \\n            #they need to be equal\\n            \\n            \\n    \\n        def addNum(self, num: int) -> None:\\n            \\n            # push to the small heap\\n            heapq.heappush(self.small,- 1*num)\\n            \\n            # Conditions\\n            \\n            # all the numbers in the smaller heap need to be less than those in the larger heap.\\n            if (self.small and self.large and (-1 * self.small[0]) > self.large[0]): \\n                # pop from small array\\n                val = -1 * heapq.heappop(self.small) # multply by -1 again to equalize positivity :)\\n                # push to large array\\n                heapq.heappush(self.large, val)\\n                \\n                \\n            \\n            #The difference of sizes between the two heaps can\\u2019t be more than 1 \\n            # Two possibiltes \\n            \\n            \\n            if len(self.small) > len(self.large) + 1: # [1,2,4] [3]\\n                #pop from small array\\n                val = -1 * heapq.heappop(self.small) \\n                #push to large\\n                heapq.heappush(self.large, val)\\n        \\n                \\n            \\n            \\n            if (len(self.small) + 1) < len(self.large): # [1] [3,4]\\n                #pop from large array\\n                val =  heapq.heappop(self.large) \\n                #push to small\\n                heapq.heappush(self.small, -1 *val)\\n                \\n    \\n    \\t\\n    \\n                \\n    \\n        def findMedian(self) -> float:\\n            # print(self.small)\\n            # print(self.large)\\n            \\n            if len(self.small) > len(self.large): # [1,2,3] [4,5]\\n                # get the max from teh smalll array\\n                return -1 * self.small[0] \\n            elif len(self.small) < len(self.large): # [1,2] [3,4,5]\\n                # get the max from teh smalll array\\n                 return self.large[0] \\n            else: # [1,2] [3,4]\\n                return (-1 * self.small[0] + self.large[0]) / 2\\n    ```",
                "codeTag": "Java"
            },
            {
                "id": 2035008,
                "title": "clean-and-clear-heap-solution-in-python-very-easy-to-understand",
                "content": "Very classical question that could be efficiently solved using **heap**!\\n\\nUse **two heaps**:\\nheap1, a max heap\\nheap2, a min heap\\nWhen **adding**, always make sure all numbers in heap1 is smaller than all numbers in heap2.\\nWhen **finding median**, there are two cases: odd numbers in total, even numbers in total.\\n\\n**Time:**\\naddNum: O(lgn)\\nfindMedian: O(1)\\n**Space:**\\nO(n)\\n\\n```\\nfrom heapq import heappush, heappop\\n\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        self.heap1 = []\\n        self.heap2 = []    \\n\\n    def addNum(self, num: int) -> None:\\n        \\n        if len(self.heap1) == 0:\\n            heappush(self.heap1, -num)\\n            return\\n        \\n        if len(self.heap1) > len(self.heap2):\\n            heappush(self.heap1, -num)\\n            num_poped = -heappop(self.heap1)\\n            heappush(self.heap2, num_poped)\\n            return\\n        \\n        if len(self.heap1) == len(self.heap2):\\n            heappush(self.heap2, num)\\n            num_poped = heappop(self.heap2)\\n            heappush(self.heap1, -num_poped)\\n            return\\n\\n    def findMedian(self) -> float:\\n\\n        if len(self.heap1) == len(self.heap2):\\n            left = -1 * self.heap1[0]\\n            right = self.heap2[0]\\n            return (left + right) / 2.0\\n        if len(self.heap1) > len(self.heap2):\\n            return self.heap1[0] * -1\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heappush, heappop\\n\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        self.heap1 = []\\n        self.heap2 = []    \\n\\n    def addNum(self, num: int) -> None:\\n        \\n        if len(self.heap1) == 0:\\n            heappush(self.heap1, -num)\\n            return\\n        \\n        if len(self.heap1) > len(self.heap2):\\n            heappush(self.heap1, -num)\\n            num_poped = -heappop(self.heap1)\\n            heappush(self.heap2, num_poped)\\n            return\\n        \\n        if len(self.heap1) == len(self.heap2):\\n            heappush(self.heap2, num)\\n            num_poped = heappop(self.heap2)\\n            heappush(self.heap1, -num_poped)\\n            return\\n\\n    def findMedian(self) -> float:\\n\\n        if len(self.heap1) == len(self.heap2):\\n            left = -1 * self.heap1[0]\\n            right = self.heap2[0]\\n            return (left + right) / 2.0\\n        if len(self.heap1) > len(self.heap2):\\n            return self.heap1[0] * -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868086,
                "title": "javascript-priority-queue-inbuilt-lc-priority-queue-time-add-o-logn-find-o-1",
                "content": "```\\nvar MedianFinder = function () {\\n    // Use below links if you want to understand more about the PriorityQueue\\n\\t// https://github.com/datastructures-js/priority-queue\\n    // https://support.leetcode.com/hc/en-us/articles/360011833974-What-are-the-environments-for-the-programming-languages-\\n    this.minHeap = new MinPriorityQueue(); // holds right part \\n    this.maxHeap = new MaxPriorityQueue(); // holds left part(elements in right > elements in left)\\n};\\n\\n\\nMedianFinder.prototype.addNum = function (num) {\\n    // inserting in min heap bubbles up the smallest element in this heap to top\\n    this.minHeap.enqueue(num); \\n    this.maxHeap.enqueue(this.minHeap.dequeue().element);\\n    // To balance the size\\n    // This will always keep min heap size >= max heap size\\n    if (this.minHeap.size() < this.maxHeap.size()) {\\n        this.minHeap.enqueue(this.maxHeap.dequeue().element); \\n    }\\n};\\n\\n\\nMedianFinder.prototype.findMedian = function () {\\n    // Odd size input array\\n    if (this.minHeap.size() > this.maxHeap.size()) return this.minHeap.front().element;\\n    else return (this.minHeap.front().element + this.maxHeap.front().element) / 2; // Even size input array\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nvar MedianFinder = function () {\\n    // Use below links if you want to understand more about the PriorityQueue\\n\\t// https://github.com/datastructures-js/priority-queue\\n    // https://support.leetcode.com/hc/en-us/articles/360011833974-What-are-the-environments-for-the-programming-languages-\\n    this.minHeap = new MinPriorityQueue(); // holds right part \\n    this.maxHeap = new MaxPriorityQueue(); // holds left part(elements in right > elements in left)\\n};\\n\\n\\nMedianFinder.prototype.addNum = function (num) {\\n    // inserting in min heap bubbles up the smallest element in this heap to top\\n    this.minHeap.enqueue(num); \\n    this.maxHeap.enqueue(this.minHeap.dequeue().element);\\n    // To balance the size\\n    // This will always keep min heap size >= max heap size\\n    if (this.minHeap.size() < this.maxHeap.size()) {\\n        this.minHeap.enqueue(this.maxHeap.dequeue().element); \\n    }\\n};\\n\\n\\nMedianFinder.prototype.findMedian = function () {\\n    // Odd size input array\\n    if (this.minHeap.size() > this.maxHeap.size()) return this.minHeap.front().element;\\n    else return (this.minHeap.front().element + this.maxHeap.front().element) / 2; // Even size input array\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1763216,
                "title": "java-two-priority-queues-easy-to-understand-solution",
                "content": "### Concept\\n* Lets take two priority queues, imagining that they are the left half and right half of the array of integers. \\n* The median is the one that is calculated from the center elements.\\n* Therefore we want the maximum integer from the left side and minimum integer from the right side. This concludes that the left pq will be a max heap and the right pq will be a min min heap.\\n\\n### Addition of Elements\\n* We allways add a new element in the left pq, and later check if the count of elements have become even then we will remove the maximum element from the left pq and add it to the right pq, to equally distribute the elements. Also pq automantically adjusts the maximum and minimum elements so we do not have to worry.\\n* Whenever we adda new element to the left side, firstly we check for the size (in prev point), else we will check if the max of left is greater than the min of right, then we will swap them, or else if will later create conflicts. Since we always want to have lower elements in the left and higher ones in the right.\\n\\n### Find Median\\n* Check if size of left pq is greater than the size of right pq, then return the peek of left. Since this will be the median. [case of odd numbers].\\n* Else we take peeks of both pqs and return the median. [case of even numbers]\\n\\n```\\nclass MedianFinder {\\n\\n    /** initialize your data structure here. */\\n    \\n    PriorityQueue<Integer> left;\\n    PriorityQueue<Integer> right;\\n    \\n    int l, r;\\n    \\n    public MedianFinder() {\\n        left=new PriorityQueue<>(Collections.reverseOrder());\\n        right=new PriorityQueue<>();\\n        \\n        l=0;\\n        r=0;\\n    }\\n    \\n    public void addNum(int num) {\\n        left.add(num);\\n        l++;\\n        \\n        if (l-r>1) {\\n            right.add(left.poll());\\n            l--;\\n            r++;\\n        } else if (right.size()>0 && left.peek()>right.peek()) {\\n            int temp1=left.poll();\\n            int temp2=right.poll();\\n\\n            left.add(temp2);\\n            right.add(temp1);\\n            \\n        }\\n        \\n    }\\n    \\n    public double findMedian() {\\n        \\n        if (l>r) {\\n            return left.peek();\\n        } else {\\n            return (left.peek()+right.peek())/2.0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass MedianFinder {\\n\\n    /** initialize your data structure here. */\\n    \\n    PriorityQueue<Integer> left;\\n    PriorityQueue<Integer> right;\\n    \\n    int l, r;\\n    \\n    public MedianFinder() {\\n        left=new PriorityQueue<>(Collections.reverseOrder());\\n        right=new PriorityQueue<>();\\n        \\n        l=0;\\n        r=0;\\n    }\\n    \\n    public void addNum(int num) {\\n        left.add(num);\\n        l++;\\n        \\n        if (l-r>1) {\\n            right.add(left.poll());\\n            l--;\\n            r++;\\n        } else if (right.size()>0 && left.peek()>right.peek()) {\\n            int temp1=left.poll();\\n            int temp2=right.poll();\\n\\n            left.add(temp2);\\n            right.add(temp1);\\n            \\n        }\\n        \\n    }\\n    \\n    public double findMedian() {\\n        \\n        if (l>r) {\\n            return left.peek();\\n        } else {\\n            return (left.peek()+right.peek())/2.0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381191,
                "title": "priority-queue-based-very-easy-c-solution",
                "content": "EXPLANATION : -\\nIdea -  Median divides array into 2 equal parts.\\nWe will make 2 heaps one max heap and one min heap. We will store first half of current elements in max heap (as top() function will return maximum value of first half) and min heap will store second half (as top() function will give minimum value of second half ) While inserting the new element if it is less than left.top() (max heap ) then we will insert it into left part else into right part. As to maintain size of both of the parts equal if the difference between both the parts is greater than 1 then we will exchange one element from larger part to smaller part.\\nFor finding median : - if size of both parts is same then median = (left.top()+right.top())/2; else the top element of bigger part.\\n\\nNote - ap function is just doing functionality of abs function.\\n\\nIt would be great if you upvote.\\n\\n\\n```\\n int ap(int n)\\n    {\\n        if(n<0)\\n        {\\n            return -1*n;\\n        }\\n        return n;\\n    }\\nclass MedianFinder {\\npublic:\\n    priority_queue<long> left;                        // max heap (left part)\\n    priority_queue<long,vector<long>,greater<long>> right;   // min heap(right part)\\n    MedianFinder() {\\n       \\n    }\\n   \\n    void addNum(int num) {\\n\\n        if(left.empty())\\n        {\\n            left.push(num);\\n                \\n        }\\n        else if(num<left.top())\\n        {\\n            left.push(num);\\n        }\\n        else\\n        {\\n            right.push(num);\\n        }\\n        \\n        if(ap(left.size()-right.size())>1)\\n        {\\n            if(left.size()>right.size())\\n            {\\n                right.push(left.top());\\n                left.pop();\\n            }\\n            else\\n            {\\n                left.push(right.top());\\n                right.pop();\\n            }\\n        }\\n       \\n        \\n    }\\n    \\n    double findMedian() {\\n        if(left.size()==right.size())\\n        {\\n            double a=(left.top()+right.top())/2.0;\\n            return a;\\n        }\\n        if(left.size()>right.size())\\n        {\\n            return double(left.top());\\n        }\\n        return double(right.top());\\n    }\\n};\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder* obj = new MedianFinder();\\n * obj->addNum(num);\\n * double param_2 = obj->findMedian();\\n */\\n \\n ```\\n  \\nIt would be great if you upvote.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n int ap(int n)\\n    {\\n        if(n<0)\\n        {\\n            return -1*n;\\n        }\\n        return n;\\n    }\\nclass MedianFinder {\\npublic:\\n    priority_queue<long> left;                        // max heap (left part)\\n    priority_queue<long,vector<long>,greater<long>> right;   // min heap(right part)\\n    MedianFinder() {\\n       \\n    }\\n   \\n    void addNum(int num) {\\n\\n        if(left.empty())\\n        {\\n            left.push(num);\\n                \\n        }\\n        else if(num<left.top())\\n        {\\n            left.push(num);\\n        }\\n        else\\n        {\\n            right.push(num);\\n        }\\n        \\n        if(ap(left.size()-right.size())>1)\\n        {\\n            if(left.size()>right.size())\\n            {\\n                right.push(left.top());\\n                left.pop();\\n            }\\n            else\\n            {\\n                left.push(right.top());\\n                right.pop();\\n            }\\n        }\\n       \\n        \\n    }\\n    \\n    double findMedian() {\\n        if(left.size()==right.size())\\n        {\\n            double a=(left.top()+right.top())/2.0;\\n            return a;\\n        }\\n        if(left.size()>right.size())\\n        {\\n            return double(left.top());\\n        }\\n        return double(right.top());\\n    }\\n};\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder* obj = new MedianFinder();\\n * obj->addNum(num);\\n * double param_2 = obj->findMedian();\\n */\\n \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1331041,
                "title": "c-simplest-solution",
                "content": "Using simple vectors for storage. Using binary search O(log n) for inserting each time maintaning sorted order.\\n```\\nclass MedianFinder {\\n\\npublic:\\n\\n\\tvector<int> arr;\\n\\n\\tvoid addNum(int num) {\\n\\t\\tarr.insert(lower_bound(arr.begin(), arr.end(), num), num);\\n\\t}\\n\\n\\tdouble findMedian() {\\n\\t\\tif( arr.size() % 2 == 1) {\\n\\t\\t\\treturn arr[arr.size()/2];\\n\\t\\t} else {\\n\\t\\t\\treturn ( (arr[arr.size()/2]) + (arr[arr.size()/2 - 1]) ) / 2.0;\\n\\t\\t}\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass MedianFinder {\\n\\npublic:\\n\\n\\tvector<int> arr;\\n\\n\\tvoid addNum(int num) {\\n\\t\\tarr.insert(lower_bound(arr.begin(), arr.end(), num), num);\\n\\t}\\n\\n\\tdouble findMedian() {\\n\\t\\tif( arr.size() % 2 == 1) {\\n\\t\\t\\treturn arr[arr.size()/2];\\n\\t\\t} else {\\n\\t\\t\\treturn ( (arr[arr.size()/2]) + (arr[arr.size()/2 - 1]) ) / 2.0;\\n\\t\\t}\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330976,
                "title": "c-2-approaches-using-insertion-sort-techinique-tle-priority-queue-accepted-youtube-video",
                "content": "```\\n//Approach-1 (O(n^2) - Insertion Sort) - TLE\\nclass MedianFinder {\\npublic:\\n    vector<int> vec;\\n    int i = 0;\\n    MedianFinder() {\\n        vec.resize(5*10000+1);\\n    }\\n    \\n    void addNum(int num) {\\n        if(i == 0) {\\n            vec[i++] = num;\\n            return;\\n        }\\n        int j = i-1;\\n        while(j >= 0 && vec[j] > num) {\\n            vec[j+1] = vec[j];\\n            j--;\\n        }\\n        vec[j+1] = num;\\n        i++;\\n    }\\n    \\n    double findMedian() {\\n        int n = i;\\n        if(n%2 == 0) {\\n            int l = n/2-1;\\n            int r = n/2;\\n            return (float)(vec[l]+vec[r])/2;\\n        }\\n        \\n        return vec[n/2];\\n    }\\n};\\n```\\n\\n```\\n//YouTube Video : https://www.youtube.com/watch?v=jnj87BSi9Is\\n//Approach-2 (O(logn)  using priority_queue) (Accepted)\\nclass MedianFinder {\\npublic:\\n    priority_queue<int> left_max; //max_heap\\n    priority_queue<int, vector<int>, greater<int>> right_min; //min_heap\\n    MedianFinder() {\\n        \\n    }\\n    \\n    void addNum(int num) {\\n        if(left_max.empty() || num < left_max.top())\\n            left_max.push(num);\\n        else\\n            right_min.push(num);\\n        \\n        //Now, adjust the size\\n        //left_max can only be greater than right_min by 1 in size;\\n        if(left_max.size() > right_min.size()+1) {\\n            right_min.push(left_max.top());\\n            left_max.pop();\\n        } else if(left_max.size() < right_min.size()) {\\n            left_max.push(right_min.top());\\n            right_min.pop();\\n        }\\n    }\\n    \\n    double findMedian() {\\n        if(left_max.size() == right_min.size())\\n            return (double)(left_max.top()+right_min.top())/2;\\n        \\n        return left_max.top();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (O(n^2) - Insertion Sort) - TLE\\nclass MedianFinder {\\npublic:\\n    vector<int> vec;\\n    int i = 0;\\n    MedianFinder() {\\n        vec.resize(5*10000+1);\\n    }\\n    \\n    void addNum(int num) {\\n        if(i == 0) {\\n            vec[i++] = num;\\n            return;\\n        }\\n        int j = i-1;\\n        while(j >= 0 && vec[j] > num) {\\n            vec[j+1] = vec[j];\\n            j--;\\n        }\\n        vec[j+1] = num;\\n        i++;\\n    }\\n    \\n    double findMedian() {\\n        int n = i;\\n        if(n%2 == 0) {\\n            int l = n/2-1;\\n            int r = n/2;\\n            return (float)(vec[l]+vec[r])/2;\\n        }\\n        \\n        return vec[n/2];\\n    }\\n};\\n```\n```\\n//YouTube Video : https://www.youtube.com/watch?v=jnj87BSi9Is\\n//Approach-2 (O(logn)  using priority_queue) (Accepted)\\nclass MedianFinder {\\npublic:\\n    priority_queue<int> left_max; //max_heap\\n    priority_queue<int, vector<int>, greater<int>> right_min; //min_heap\\n    MedianFinder() {\\n        \\n    }\\n    \\n    void addNum(int num) {\\n        if(left_max.empty() || num < left_max.top())\\n            left_max.push(num);\\n        else\\n            right_min.push(num);\\n        \\n        //Now, adjust the size\\n        //left_max can only be greater than right_min by 1 in size;\\n        if(left_max.size() > right_min.size()+1) {\\n            right_min.push(left_max.top());\\n            left_max.pop();\\n        } else if(left_max.size() < right_min.size()) {\\n            left_max.push(right_min.top());\\n            right_min.pop();\\n        }\\n    }\\n    \\n    double findMedian() {\\n        if(left_max.size() == right_min.size())\\n            return (double)(left_max.top()+right_min.top())/2;\\n        \\n        return left_max.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1116125,
                "title": "javascript-java-brute-force",
                "content": "javascript\\n```\\nclass MedianFinder {\\n    constructor() {\\n        this.a = [];\\n    }\\n\\n    addNum(num) {\\n        this.a.push(num);\\n    }\\n\\n    findMedian() {\\n        this.a.sort((x, y) => x - y);\\n        let n = this.a.length;\\n        let m = n >> 1;\\n        return n & 1 ? this.a[m] : (this.a[m - 1] + this.a[m]) / 2;\\n    }\\n}\\n```\\njava\\n```\\nclass MedianFinder {\\n\\n\\tList<Integer> l;\\n\\n\\tpublic MedianFinder() {\\n\\t\\tl = new ArrayList<>();\\n\\t}\\n\\n\\tpublic void addNum(int num) {\\n\\t\\tl.add(num);\\n\\t}\\n\\n\\tpublic double findMedian() {\\n\\t\\tCollections.sort(l);\\n        int n = l.size();\\n        int m = n >> 1;\\n        return (n & 1) == 1 ? l.get(m) : (double) (l.get(m -1) + l.get(m)) / 2;\\n\\t}\\n}\\n```\\njavascript solution 2: use multiset (improved 1659ms)\\nhttps://leetcode.com/problems/find-median-from-data-stream/solutions/3047663/javascript-multiset-1658ms/",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\nclass MedianFinder {\\n    constructor() {\\n        this.a = [];\\n    }\\n\\n    addNum(num) {\\n        this.a.push(num);\\n    }\\n\\n    findMedian() {\\n        this.a.sort((x, y) => x - y);\\n        let n = this.a.length;\\n        let m = n >> 1;\\n        return n & 1 ? this.a[m] : (this.a[m - 1] + this.a[m]) / 2;\\n    }\\n}\\n```\n```\\nclass MedianFinder {\\n\\n\\tList<Integer> l;\\n\\n\\tpublic MedianFinder() {\\n\\t\\tl = new ArrayList<>();\\n\\t}\\n\\n\\tpublic void addNum(int num) {\\n\\t\\tl.add(num);\\n\\t}\\n\\n\\tpublic double findMedian() {\\n\\t\\tCollections.sort(l);\\n        int n = l.size();\\n        int m = n >> 1;\\n        return (n & 1) == 1 ? l.get(m) : (double) (l.get(m -1) + l.get(m)) / 2;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 810725,
                "title": "javascript-insertion-sort-using-binary-search-o-n-o-logn-o-n",
                "content": "```\\n/**\\n * initialize your data structure here.\\n */\\nvar MedianFinder = function() {\\n    this.nums = [];\\n};\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nMedianFinder.prototype.size = function(num) {\\n    return this.nums.length;\\n}\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nMedianFinder.prototype.addNum = function(num) {\\n    if (this.size() === 0) {\\n        this.nums.push(num);\\n    } else {\\n        let idx = search(this.nums, num);\\n        this.nums.splice(idx, 0, num)\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nMedianFinder.prototype.findMedian = function() {\\n    if (this.size() === 0) return 0;\\n    let isSizeEven = this.size() % 2 === 0;\\n    let mid = isSizeEven ? (this.size() / 2) : ((this.size() - 1) / 2);\\n    return isSizeEven ? (this.nums[mid] + this.nums[mid - 1]) / 2 : this.nums[mid];\\n};\\n\\n/** \\n * Your MedianFinder object will be instantiated and called as such:\\n * var obj = new MedianFinder()\\n * obj.addNum(num)\\n * var param_2 = obj.findMedian()\\n */\\n\\nfunction search(arr, num) {\\n    let start = 0;\\n    let end = arr.length - 1;\\n    \\n    if (num < arr[0]) return 0;\\n    \\n    if (num > arr[end]) return end + 1;\\n\\n    let ans = -1; \\n    \\n    while (start <= end) {\\n        const mid = start + ((end - start) >> 1);\\n        if (arr[mid] <= num) {\\n            start = mid + 1;\\n            ans = mid;\\n        } else {\\n            end = mid - 1;\\n        }\\n    }\\n    \\n    return ans + 1;\\n}",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * initialize your data structure here.\\n */\\nvar MedianFinder = function() {\\n    this.nums = [];\\n};\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nMedianFinder.prototype.size = function(num) {\\n    return this.nums.length;\\n}\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nMedianFinder.prototype.addNum = function(num) {\\n    if (this.size() === 0) {\\n        this.nums.push(num);\\n    } else {\\n        let idx = search(this.nums, num);\\n        this.nums.splice(idx, 0, num)\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nMedianFinder.prototype.findMedian = function() {\\n    if (this.size() === 0) return 0;\\n    let isSizeEven = this.size() % 2 === 0;\\n    let mid = isSizeEven ? (this.size() / 2) : ((this.size() - 1) / 2);\\n    return isSizeEven ? (this.nums[mid] + this.nums[mid - 1]) / 2 : this.nums[mid];\\n};\\n\\n/** \\n * Your MedianFinder object will be instantiated and called as such:\\n * var obj = new MedianFinder()\\n * obj.addNum(num)\\n * var param_2 = obj.findMedian()\\n */\\n\\nfunction search(arr, num) {\\n    let start = 0;\\n    let end = arr.length - 1;\\n    \\n    if (num < arr[0]) return 0;\\n    \\n    if (num > arr[end]) return end + 1;\\n\\n    let ans = -1; \\n    \\n    while (start <= end) {\\n        const mid = start + ((end - start) >> 1);\\n        if (arr[mid] <= num) {\\n            start = mid + 1;\\n            ans = mid;\\n        } else {\\n            end = mid - 1;\\n        }\\n    }\\n    \\n    return ans + 1;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 597182,
                "title": "javascript-solution-simple-binary-search-99-100",
                "content": "The idea behind this solution is to use binary search to find the index of insertion.\\n\\nRuntime: 216 ms, faster than 99.54% of JavaScript online submissions for Find Median from Data Stream.\\nMemory Usage: 64.1 MB, less than 100.00% of JavaScript online submissions for Find Median from Data Stream.\\n\\n```\\nfunction binarySearch(arr, target, l, r) {\\n  if (l === r) {\\n    return arr[l] > target ? l : l + 1;\\n  }\\n  let mid = Math.floor((l + r) / 2);\\n  if (arr[mid] < target) return binarySearch(arr, target, mid + 1, r);\\n  if (arr[mid] > target) return binarySearch(arr, target, l, mid);\\n  return mid;\\n}\\n\\nvar MedianFinder = function() {\\n  this.arr = [];\\n};\\n\\nMedianFinder.prototype.addNum = function(num) {\\n  if (this.arr.length === 0) {\\n    this.arr.push(num);\\n    return;\\n  }\\n  let index = binarySearch(this.arr, num, 0, this.arr.length - 1);\\n  this.arr.splice(index, 0, num);\\n};\\n\\nMedianFinder.prototype.findMedian = function() {\\n  if (this.arr.length === 0) {\\n    return null;\\n  }\\n  let mid = this.arr.length / 2;\\n  if (this.arr.length % 2 === 0) {\\n    return ((this.arr[mid] + this.arr[mid - 1]) / 2);\\n  }\\n  return this.arr[Math.floor(mid)];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction binarySearch(arr, target, l, r) {\\n  if (l === r) {\\n    return arr[l] > target ? l : l + 1;\\n  }\\n  let mid = Math.floor((l + r) / 2);\\n  if (arr[mid] < target) return binarySearch(arr, target, mid + 1, r);\\n  if (arr[mid] > target) return binarySearch(arr, target, l, mid);\\n  return mid;\\n}\\n\\nvar MedianFinder = function() {\\n  this.arr = [];\\n};\\n\\nMedianFinder.prototype.addNum = function(num) {\\n  if (this.arr.length === 0) {\\n    this.arr.push(num);\\n    return;\\n  }\\n  let index = binarySearch(this.arr, num, 0, this.arr.length - 1);\\n  this.arr.splice(index, 0, num);\\n};\\n\\nMedianFinder.prototype.findMedian = function() {\\n  if (this.arr.length === 0) {\\n    return null;\\n  }\\n  let mid = this.arr.length / 2;\\n  if (this.arr.length % 2 === 0) {\\n    return ((this.arr[mid] + this.arr[mid - 1]) / 2);\\n  }\\n  return this.arr[Math.floor(mid)];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 571849,
                "title": "solution-to-follow-ups-add-o-100-find-o-lg100",
                "content": "# Follow up\\n1. Maintain an array of size `101` such that for each number `i` in `[0,100]` we know the count of numbers smaller than or equal to `i`. And, we binary search for median; median has half the numbers smaller than or equal to it. So, we can binary search in that array for finding median - since it\\'ll be in non-decreasing order.\\n\\n```\\nclass MedianFinder {\\n    private int[] se = new int[101];\\n\\n    public MedianFinder() {\\n    }\\n    \\n    public void addNum(int num) {\\n        for (int i = num; i < se.length; i++) {\\n              se[i]++;\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        int n = se[100];\\n        int middle = (n + 1) / 2;\\n        double ans = smallestEqualOrGreater(middle);\\n        if (n % 2 == 0) {\\n            ans += smallestEqualOrGreater(middle + 1);\\n            ans /= 2;\\n        }\\n        return ans;\\n    }\\n        \\n    private int smallestEqualOrGreater(int key) {\\n        int lo = 0, hi = se.length - 1;\\n        int index = -1;\\n        while (lo <= hi) {\\n            int mid = (lo + hi) / 2;\\n            if (se[mid] >= key) {\\n                index = mid;\\n                hi = mid - 1;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```\\n\\n2. What changes for the second follow up? Keeping counters for elements smaller than `0` and greater than `100` should suffice. And, we use `se` array only for the purpose; indexes `0` and `102`. Why only counters are enough for numbers outside the range `[0,100]`? Only `1%` of the numbers are outside of that range, so the median will never be outside of the range; so, we need not remember those numbers.\\n\\n```\\nclass MedianFinder {\\n    private int[] se = new int[103];\\n\\n    public MedianFinder() {\\n    }\\n    \\n    public void addNum(int num) {\\n\\t    int start = num + 1;\\n\\t    if (num < 0) {\\n\\t\\t    start = 0;\\n\\t\\t}\\n\\t\\tif (num > 100) {\\n\\t\\t    start = 102;\\n\\t\\t}\\n        for (int i = start; i < se.length; i++) {\\n              se[i]++;\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        int n = se[102];\\n        int middle = (n + 1) / 2;\\n\\t\\t// remember, index=0 corresponds to negative numbers\\n        double ans = smallestEqualOrGreater(middle) - 1;\\n        if (n % 2 == 0) {\\n            ans += smallestEqualOrGreater(middle + 1) - 1;\\n            ans /= 2;\\n        }\\n        return ans;\\n    }\\n        \\n    private int smallestEqualOrGreater(int key) {\\n        int lo = 0, hi = se.length - 1;\\n        int index = -1;\\n        while (lo <= hi) {\\n            int mid = (lo + hi) / 2;\\n            if (se[mid] >= key) {\\n                index = mid;\\n                hi = mid - 1;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MedianFinder {\\n    private int[] se = new int[101];\\n\\n    public MedianFinder() {\\n    }\\n    \\n    public void addNum(int num) {\\n        for (int i = num; i < se.length; i++) {\\n              se[i]++;\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        int n = se[100];\\n        int middle = (n + 1) / 2;\\n        double ans = smallestEqualOrGreater(middle);\\n        if (n % 2 == 0) {\\n            ans += smallestEqualOrGreater(middle + 1);\\n            ans /= 2;\\n        }\\n        return ans;\\n    }\\n        \\n    private int smallestEqualOrGreater(int key) {\\n        int lo = 0, hi = se.length - 1;\\n        int index = -1;\\n        while (lo <= hi) {\\n            int mid = (lo + hi) / 2;\\n            if (se[mid] >= key) {\\n                index = mid;\\n                hi = mid - 1;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```\n```\\nclass MedianFinder {\\n    private int[] se = new int[103];\\n\\n    public MedianFinder() {\\n    }\\n    \\n    public void addNum(int num) {\\n\\t    int start = num + 1;\\n\\t    if (num < 0) {\\n\\t\\t    start = 0;\\n\\t\\t}\\n\\t\\tif (num > 100) {\\n\\t\\t    start = 102;\\n\\t\\t}\\n        for (int i = start; i < se.length; i++) {\\n              se[i]++;\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        int n = se[102];\\n        int middle = (n + 1) / 2;\\n\\t\\t// remember, index=0 corresponds to negative numbers\\n        double ans = smallestEqualOrGreater(middle) - 1;\\n        if (n % 2 == 0) {\\n            ans += smallestEqualOrGreater(middle + 1) - 1;\\n            ans /= 2;\\n        }\\n        return ans;\\n    }\\n        \\n    private int smallestEqualOrGreater(int key) {\\n        int lo = 0, hi = se.length - 1;\\n        int index = -1;\\n        while (lo <= hi) {\\n            int mid = (lo + hi) / 2;\\n            if (se[mid] >= key) {\\n                index = mid;\\n                hi = mid - 1;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 499195,
                "title": "java-avl-tree-based-solution-for-understanding-the-use-of-avl-tree-with-comments",
                "content": "```\\n\\n//>>>>>>>>>>>>>>>>>>>>>>>>>>    NODE\\nclass Node {\\n\\tint key;\\n\\tint freq; //duplicates are allowed in stream\\n\\tint lcount; // number of items in left subtree\\n\\tint rcount; // number of items in right subtree\\n\\tint height; // height for avl operations\\n\\tNode left;\\n\\tNode right;\\n\\n\\tNode(int key) {\\n\\t\\tthis.key = key;\\n\\t\\theight = 1;\\n\\t\\tleft = right = null;\\n\\t\\tlcount = rcount = 0;\\n\\t\\tfreq = 1;\\n\\t}\\n}\\n\\n//>>>>>>>>>>>>>>>>>>>>>>>>>>    AVL\\nclass AVL {\\n\\tNode root;\\n\\tint size;\\n\\n\\tAVL() {\\n\\t\\tsize = 0;\\n\\t\\troot = null;\\n\\t}\\n\\n\\tvoid insert(int key) {\\n\\t\\troot = insertHelper(root, key);\\n\\t}\\n\\n\\tNode leftR(Node x) {\\n\\t\\tNode y = x.right;\\n\\t\\tNode T2 = y.left;\\n\\n\\t\\t// Perform rotation\\n\\t\\ty.left = x;\\n\\t\\tx.right = T2;\\n\\n\\t\\t// Update heights\\n\\t\\tx.height = Math.max(height(x.left), height(x.right)) + 1;\\n\\t\\ty.height = Math.max(height(y.left), height(y.right)) + 1;\\n\\n\\t\\t// update count\\n\\t\\tx.rcount = (T2 != null) ? T2.lcount + T2.rcount + T2.freq : 0;\\n\\t\\ty.lcount = x.lcount + x.rcount + x.freq;\\n\\n\\t\\t// Return new root\\n\\t\\treturn y;\\n\\t}\\n\\n\\tNode rightR(Node y) {\\n\\t\\tNode x = y.left;\\n\\t\\tNode T2 = x.right;\\n\\n\\t\\t// Perform rotation\\n\\t\\tx.right = y;\\n\\t\\ty.left = T2;\\n\\n\\t\\t// Update heights\\n\\t\\ty.height = Math.max(height(y.left), height(y.right)) + 1;\\n\\t\\tx.height = Math.max(height(x.left), height(x.right)) + 1;\\n\\n\\t\\t// update count\\n\\t\\ty.lcount = (T2 != null) ? T2.lcount + T2.rcount +T2.freq : 0;\\n\\t\\tx.rcount = y.lcount + y.rcount + y.freq;\\n\\n\\t\\t// Return new root\\n\\t\\treturn x;\\n\\t}\\n\\n\\tint getBalance(Node root) {\\n\\t\\tif (root == null)\\n\\t\\t\\treturn 0;\\n\\t\\treturn height(root.left) - height(root.right);\\n\\t}\\n\\n\\tint height(Node root) {\\n\\t\\tif (root == null)\\n\\t\\t\\treturn 0;\\n\\t\\treturn root.height;\\n\\t}\\n\\n\\tNode insertHelper(Node root, int key) {\\n\\t\\t// insert in tree\\n\\t\\t// increment size\\n\\t\\tif (root == null) {\\n\\t\\t\\tsize++;\\n\\t\\t\\treturn new Node(key);\\n\\t\\t}\\n\\n\\t\\tif (key < root.key) {\\n\\t\\t\\troot.left = insertHelper(root.left, key);\\n\\t\\t\\troot.lcount++;\\n\\t\\t}\\n\\n\\t\\telse if (key > root.key) {\\n\\t\\t\\troot.right = insertHelper(root.right, key);\\n\\t\\t\\troot.rcount++;\\n\\t\\t}\\n\\n\\t\\telse {\\n\\t\\t\\troot.freq++;\\n\\t\\t\\tsize++;\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\n\\t\\t// insertion is done, update height and check for balancing factor\\n\\t\\troot.height = 1 + Math.max(height(root.left), height(root.right));\\n\\n\\t\\tint balance = getBalance(root);\\n\\n\\t\\t// If this node becomes unbalanced, then there\\n\\t\\t// are 4 cases Left Left Case\\n\\t\\tif (balance > 1 && key < root.left.key)\\n\\t\\t\\treturn rightR(root);\\n\\n\\t\\t// Right Right Case\\n\\t\\tif (balance < -1 && key > root.right.key)\\n\\t\\t\\treturn leftR(root);\\n\\n\\t\\t// Left Right Case\\n\\t\\tif (balance > 1 && key > root.left.key) {\\n\\t\\t\\troot.left = leftR(root.left);\\n\\t\\t\\treturn rightR(root);\\n\\t\\t}\\n\\n\\t\\t// Right Left Case\\n\\t\\tif (balance < -1 && key < root.right.key) {\\n\\t\\t\\troot.right = rightR(root.right);\\n\\t\\t\\treturn leftR(root);\\n\\t\\t}\\n\\n\\t\\t/* return the (unchanged) node pointer */\\n\\t\\treturn root;\\n\\n\\t}\\n\\n\\tdouble findMedian() {\\n\\t\\t// as per size find out element(s) to find\\n\\t\\t// return median\\n\\t\\tint idx = size / 2 + 1;\\n\\t\\tint k1 = 0, k2 = 0;\\n\\t\\tdouble median = 0;\\n\\n\\t\\tk1 = find(root, idx);\\n\\t\\tmedian = k1 / 1.0;\\n\\t\\tif (size % 2 == 0) {\\n\\t\\t\\tk2 = find(root, idx - 1);\\n\\t\\t\\tmedian = (k1 + k2) / 2.0;\\n\\t\\t}\\n\\t\\treturn median;\\n\\t}\\n\\n\\tint find(Node root, int idx) {\\n\\t\\t\\n\\t\\tif (idx>= root.lcount + 1  && idx< root.lcount+1+root.freq)\\n\\t\\t\\treturn root.key;\\n\\n\\t\\telse if (idx <= root.lcount)\\n\\t\\t\\treturn find(root.left, idx);\\n\\n\\t\\telse\\n\\t\\t\\treturn find(root.right, idx - root.lcount - root.freq);\\n\\t}\\n}\\n\\n//>>>>>>>>>>>>>>>>>>>>>>>>>>    MedianFinder\\nclass MedianFinder {\\n\\n\\tAVL avl;\\n\\n\\tpublic MedianFinder() {\\n\\t\\tavl = new AVL();\\n\\t}\\n\\n\\tpublic void addNum(int num) {\\n\\t\\tavl.insert(num);\\n\\t}\\n\\n\\tpublic double findMedian() {\\n\\t\\treturn avl.findMedian();\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n//>>>>>>>>>>>>>>>>>>>>>>>>>>    NODE\\nclass Node {\\n\\tint key;\\n\\tint freq; //duplicates are allowed in stream\\n\\tint lcount; // number of items in left subtree\\n\\tint rcount; // number of items in right subtree\\n\\tint height; // height for avl operations\\n\\tNode left;\\n\\tNode right;\\n\\n\\tNode(int key) {\\n\\t\\tthis.key = key;\\n\\t\\theight = 1;\\n\\t\\tleft = right = null;\\n\\t\\tlcount = rcount = 0;\\n\\t\\tfreq = 1;\\n\\t}\\n}\\n\\n//>>>>>>>>>>>>>>>>>>>>>>>>>>    AVL\\nclass AVL {\\n\\tNode root;\\n\\tint size;\\n\\n\\tAVL() {\\n\\t\\tsize = 0;\\n\\t\\troot = null;\\n\\t}\\n\\n\\tvoid insert(int key) {\\n\\t\\troot = insertHelper(root, key);\\n\\t}\\n\\n\\tNode leftR(Node x) {\\n\\t\\tNode y = x.right;\\n\\t\\tNode T2 = y.left;\\n\\n\\t\\t// Perform rotation\\n\\t\\ty.left = x;\\n\\t\\tx.right = T2;\\n\\n\\t\\t// Update heights\\n\\t\\tx.height = Math.max(height(x.left), height(x.right)) + 1;\\n\\t\\ty.height = Math.max(height(y.left), height(y.right)) + 1;\\n\\n\\t\\t// update count\\n\\t\\tx.rcount = (T2 != null) ? T2.lcount + T2.rcount + T2.freq : 0;\\n\\t\\ty.lcount = x.lcount + x.rcount + x.freq;\\n\\n\\t\\t// Return new root\\n\\t\\treturn y;\\n\\t}\\n\\n\\tNode rightR(Node y) {\\n\\t\\tNode x = y.left;\\n\\t\\tNode T2 = x.right;\\n\\n\\t\\t// Perform rotation\\n\\t\\tx.right = y;\\n\\t\\ty.left = T2;\\n\\n\\t\\t// Update heights\\n\\t\\ty.height = Math.max(height(y.left), height(y.right)) + 1;\\n\\t\\tx.height = Math.max(height(x.left), height(x.right)) + 1;\\n\\n\\t\\t// update count\\n\\t\\ty.lcount = (T2 != null) ? T2.lcount + T2.rcount +T2.freq : 0;\\n\\t\\tx.rcount = y.lcount + y.rcount + y.freq;\\n\\n\\t\\t// Return new root\\n\\t\\treturn x;\\n\\t}\\n\\n\\tint getBalance(Node root) {\\n\\t\\tif (root == null)\\n\\t\\t\\treturn 0;\\n\\t\\treturn height(root.left) - height(root.right);\\n\\t}\\n\\n\\tint height(Node root) {\\n\\t\\tif (root == null)\\n\\t\\t\\treturn 0;\\n\\t\\treturn root.height;\\n\\t}\\n\\n\\tNode insertHelper(Node root, int key) {\\n\\t\\t// insert in tree\\n\\t\\t// increment size\\n\\t\\tif (root == null) {\\n\\t\\t\\tsize++;\\n\\t\\t\\treturn new Node(key);\\n\\t\\t}\\n\\n\\t\\tif (key < root.key) {\\n\\t\\t\\troot.left = insertHelper(root.left, key);\\n\\t\\t\\troot.lcount++;\\n\\t\\t}\\n\\n\\t\\telse if (key > root.key) {\\n\\t\\t\\troot.right = insertHelper(root.right, key);\\n\\t\\t\\troot.rcount++;\\n\\t\\t}\\n\\n\\t\\telse {\\n\\t\\t\\troot.freq++;\\n\\t\\t\\tsize++;\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\n\\t\\t// insertion is done, update height and check for balancing factor\\n\\t\\troot.height = 1 + Math.max(height(root.left), height(root.right));\\n\\n\\t\\tint balance = getBalance(root);\\n\\n\\t\\t// If this node becomes unbalanced, then there\\n\\t\\t// are 4 cases Left Left Case\\n\\t\\tif (balance > 1 && key < root.left.key)\\n\\t\\t\\treturn rightR(root);\\n\\n\\t\\t// Right Right Case\\n\\t\\tif (balance < -1 && key > root.right.key)\\n\\t\\t\\treturn leftR(root);\\n\\n\\t\\t// Left Right Case\\n\\t\\tif (balance > 1 && key > root.left.key) {\\n\\t\\t\\troot.left = leftR(root.left);\\n\\t\\t\\treturn rightR(root);\\n\\t\\t}\\n\\n\\t\\t// Right Left Case\\n\\t\\tif (balance < -1 && key < root.right.key) {\\n\\t\\t\\troot.right = rightR(root.right);\\n\\t\\t\\treturn leftR(root);\\n\\t\\t}\\n\\n\\t\\t/* return the (unchanged) node pointer */\\n\\t\\treturn root;\\n\\n\\t}\\n\\n\\tdouble findMedian() {\\n\\t\\t// as per size find out element(s) to find\\n\\t\\t// return median\\n\\t\\tint idx = size / 2 + 1;\\n\\t\\tint k1 = 0, k2 = 0;\\n\\t\\tdouble median = 0;\\n\\n\\t\\tk1 = find(root, idx);\\n\\t\\tmedian = k1 / 1.0;\\n\\t\\tif (size % 2 == 0) {\\n\\t\\t\\tk2 = find(root, idx - 1);\\n\\t\\t\\tmedian = (k1 + k2) / 2.0;\\n\\t\\t}\\n\\t\\treturn median;\\n\\t}\\n\\n\\tint find(Node root, int idx) {\\n\\t\\t\\n\\t\\tif (idx>= root.lcount + 1  && idx< root.lcount+1+root.freq)\\n\\t\\t\\treturn root.key;\\n\\n\\t\\telse if (idx <= root.lcount)\\n\\t\\t\\treturn find(root.left, idx);\\n\\n\\t\\telse\\n\\t\\t\\treturn find(root.right, idx - root.lcount - root.freq);\\n\\t}\\n}\\n\\n//>>>>>>>>>>>>>>>>>>>>>>>>>>    MedianFinder\\nclass MedianFinder {\\n\\n\\tAVL avl;\\n\\n\\tpublic MedianFinder() {\\n\\t\\tavl = new AVL();\\n\\t}\\n\\n\\tpublic void addNum(int num) {\\n\\t\\tavl.insert(num);\\n\\t}\\n\\n\\tpublic double findMedian() {\\n\\t\\treturn avl.findMedian();\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420630,
                "title": "python3-solution-using-two-heaps",
                "content": "This is the python version of the method given in solutions tab.\\n```\\nfrom heapq import heappush, heappop\\n\\n\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        # for left half of the data stream we maintain a max heap\\n        self.left_max_heap = []\\n        # vice-versa\\n        self.right_min_heap = []\\n\\n    def max_heap_push(self, x):\\n        heappush(self.left_max_heap, -x)\\n\\n    def min_heap_push(self, x):\\n        heappush(self.right_min_heap, x)\\n\\n    def max_heap_pop(self):\\n        return -heappop(self.left_max_heap)\\n\\n    def min_heap_pop(self):\\n        return heappop(self.right_min_heap)\\n\\n    @property\\n    def left_max_heap_size(self):\\n        return len(self.left_max_heap)\\n\\n    @property\\n    def right_min_heap_size(self):\\n        return len(self.right_min_heap)\\n\\n    def addNum(self, num: int) -> None:\\n        self.max_heap_push(num)\\n        self.min_heap_push(self.max_heap_pop())\\n        while self.left_max_heap_size < self.right_min_heap_size:\\n            self.max_heap_push(self.min_heap_pop())\\n\\n    def findMedian(self) -> float:\\n        if self.left_max_heap_size > self.right_min_heap_size:\\n            return -self.left_max_heap[0]\\n        return (-self.left_max_heap[0] + self.right_min_heap[0]) / 2\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heappush, heappop\\n\\n\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        # for left half of the data stream we maintain a max heap\\n        self.left_max_heap = []\\n        # vice-versa\\n        self.right_min_heap = []\\n\\n    def max_heap_push(self, x):\\n        heappush(self.left_max_heap, -x)\\n\\n    def min_heap_push(self, x):\\n        heappush(self.right_min_heap, x)\\n\\n    def max_heap_pop(self):\\n        return -heappop(self.left_max_heap)\\n\\n    def min_heap_pop(self):\\n        return heappop(self.right_min_heap)\\n\\n    @property\\n    def left_max_heap_size(self):\\n        return len(self.left_max_heap)\\n\\n    @property\\n    def right_min_heap_size(self):\\n        return len(self.right_min_heap)\\n\\n    def addNum(self, num: int) -> None:\\n        self.max_heap_push(num)\\n        self.min_heap_push(self.max_heap_pop())\\n        while self.left_max_heap_size < self.right_min_heap_size:\\n            self.max_heap_push(self.min_heap_pop())\\n\\n    def findMedian(self) -> float:\\n        if self.left_max_heap_size > self.right_min_heap_size:\\n            return -self.left_max_heap[0]\\n        return (-self.left_max_heap[0] + self.right_min_heap[0]) / 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 380288,
                "title": "python-solution-with-binary-search-tree",
                "content": "I tried to code the BST solution in Python and it didn\\'t result in a faster time(because the tree is not balanced) but atleast have something for the interview. :)\\n\\n```\\nclass TreeNode:\\n    def __init__(self, val):\\n        self.val = val\\n        self.right = self.left = None\\n        self.leftSize = 0\\n\\n\\nclass BinarySearchTree:\\n\\n    def __init__(self):\\n        self.root = None\\n        self.count = 0\\n        \\n    def _add(self, root, num):\\n        if not root:\\n            root = TreeNode(num)\\n            return root\\n\\n        if num <= root.val: \\n            root.left = self._add(root.left, num)\\n            root.leftSize += 1\\n        else:\\n            root.right = self._add(root.right, num)\\n        return root\\n\\n    def add(self, num):\\n        self.root = self._add(self.root, num)\\n        self.count += 1\\n    \\n    def rank(self, k):\\n        return self._Rank(self.root, k)\\n    \\n    def _Rank(self, root,  k):\\n\\n        if not root:\\n            return -1\\n\\n        if root.leftSize == k:\\n            return root.val\\n\\n        if root.leftSize > k:\\n            return self._Rank(root.left, k)\\n\\n        else:\\n            return self._Rank(root.right, k - root.leftSize - 1)\\n\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.bst = BinarySearchTree()\\n\\n    def addNum(self, num: int) -> None:\\n        \\n        self.bst.add(num)\\n        \\n    def findMedian(self) -> float:\\n        \\n        #check the size of elements:\\n        size = self.bst.count\\n        if size % 2 == 0: #even number of nodes, return median of two middle            \\n            rank1 = self.bst.rank(size // 2)\\n            rank2 = self.bst.rank(size // 2 - 1)\\n            return (rank1 + rank2) / 2\\n        else:\\n            return self.bst.rank(size//2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass TreeNode:\\n    def __init__(self, val):\\n        self.val = val\\n        self.right = self.left = None\\n        self.leftSize = 0\\n\\n\\nclass BinarySearchTree:\\n\\n    def __init__(self):\\n        self.root = None\\n        self.count = 0\\n        \\n    def _add(self, root, num):\\n        if not root:\\n            root = TreeNode(num)\\n            return root\\n\\n        if num <= root.val: \\n            root.left = self._add(root.left, num)\\n            root.leftSize += 1\\n        else:\\n            root.right = self._add(root.right, num)\\n        return root\\n\\n    def add(self, num):\\n        self.root = self._add(self.root, num)\\n        self.count += 1\\n    \\n    def rank(self, k):\\n        return self._Rank(self.root, k)\\n    \\n    def _Rank(self, root,  k):\\n\\n        if not root:\\n            return -1\\n\\n        if root.leftSize == k:\\n            return root.val\\n\\n        if root.leftSize > k:\\n            return self._Rank(root.left, k)\\n\\n        else:\\n            return self._Rank(root.right, k - root.leftSize - 1)\\n\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.bst = BinarySearchTree()\\n\\n    def addNum(self, num: int) -> None:\\n        \\n        self.bst.add(num)\\n        \\n    def findMedian(self) -> float:\\n        \\n        #check the size of elements:\\n        size = self.bst.count\\n        if size % 2 == 0: #even number of nodes, return median of two middle            \\n            rank1 = self.bst.rank(size // 2)\\n            rank2 = self.bst.rank(size // 2 - 1)\\n            return (rank1 + rank2) / 2\\n        else:\\n            return self.bst.rank(size//2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 318054,
                "title": "simple-solution-with-min-and-max-heap-java",
                "content": "```\\nclass MedianFinder {\\n\\n    PriorityQueue<Integer> maxHeap;\\n    PriorityQueue<Integer> minHeap;\\n    /** initialize your data structure here. */\\n    public MedianFinder() {\\n        maxHeap = new PriorityQueue<>((a,b) -> b-a);\\n        minHeap = new PriorityQueue<>((a,b) -> a-b);\\n    }\\n    \\n    public void addNum(int num) {\\n        if(maxHeap.isEmpty() || maxHeap.peek() >= num) {\\n            maxHeap.add(num);\\n        } else {\\n            minHeap.add(num);\\n        }\\n        \\n        if(maxHeap.size() > minHeap.size() + 1) {\\n            minHeap.add(maxHeap.poll());\\n        } else if(maxHeap.size() < minHeap.size()) {\\n            maxHeap.add(minHeap.poll());\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        if(maxHeap.size() == minHeap.size()) {\\n            return maxHeap.peek() / 2.0 + minHeap.peek() / 2.0;\\n        }\\n        \\n        return maxHeap.peek();\\n    }\\n}\\n```\\n\\nAlgorithm\\n\\n* We can store the first half of numbers (i.e., smallNumList) in a Max Heap. We should use a Max Heap as we are interested in knowing the largest number in the first half.\\n* We can store the second half of numbers (i.e., largeNumList) in a Min Heap, as we are interested in knowing the smallest number in the second half.\\n* Inserting a number in a heap will take O(logN)O(logN), which is better than the brute force approach.\\n* At any time, the median of the current list of numbers can be calculated from the top element of the two heaps.",
                "solutionTags": [],
                "code": "```\\nclass MedianFinder {\\n\\n    PriorityQueue<Integer> maxHeap;\\n    PriorityQueue<Integer> minHeap;\\n    /** initialize your data structure here. */\\n    public MedianFinder() {\\n        maxHeap = new PriorityQueue<>((a,b) -> b-a);\\n        minHeap = new PriorityQueue<>((a,b) -> a-b);\\n    }\\n    \\n    public void addNum(int num) {\\n        if(maxHeap.isEmpty() || maxHeap.peek() >= num) {\\n            maxHeap.add(num);\\n        } else {\\n            minHeap.add(num);\\n        }\\n        \\n        if(maxHeap.size() > minHeap.size() + 1) {\\n            minHeap.add(maxHeap.poll());\\n        } else if(maxHeap.size() < minHeap.size()) {\\n            maxHeap.add(minHeap.poll());\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        if(maxHeap.size() == minHeap.size()) {\\n            return maxHeap.peek() / 2.0 + minHeap.peek() / 2.0;\\n        }\\n        \\n        return maxHeap.peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 301613,
                "title": "couting-sort-in-java-for-follow-up-1",
                "content": "Follow up: \\n1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n\\n```\\n// Time Complexity:\\n// addNum: O(1)\\n// findMedian: O(m),  m is the length of buckets, in this case, it\\'s 101 \\nclass MedianFinder {\\n    \\n    int[] buckets;\\n    int len;\\n\\n    /** initialize your data structure here. */\\n    public MedianFinder() {\\n        buckets = new int[101];\\n        len = 0;\\n    }\\n    \\n    public void addNum(int num) {\\n        len ++;\\n        buckets[num] ++;\\n    }\\n    \\n    public double findMedian() {\\n        double half = (double) len / 2;\\n        int sum = 0;\\n        int preSum = 0;\\n        if(len % 2 == 0){\\n            for(int i = 0; i < buckets.length; i ++){\\n                sum += buckets[i];\\n                if(sum > half && preSum < half){\\n                    return (double) i;\\n                }\\n                if(sum == half && preSum < half){\\n                    for(int j = i + 1; j < buckets.length; j ++){\\n                        if(buckets[j] > 0){\\n                            return (double) (i + j) / 2;\\n                        }\\n                    }\\n                }\\n                preSum = sum;\\n            }\\n        }else{\\n            for(int i = 0; i < buckets.length; i ++){\\n                sum += buckets[i];\\n                if(sum >= half && preSum < half){\\n                    return (double) i;\\n                }\\n                preSum = sum;\\n            }\\n        }\\n        \\n        return 0.0;\\n    }\\n}\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder obj = new MedianFinder();\\n * obj.addNum(num);\\n * double param_2 = obj.findMedian();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n// Time Complexity:\\n// addNum: O(1)\\n// findMedian: O(m),  m is the length of buckets, in this case, it\\'s 101 \\nclass MedianFinder {\\n    \\n    int[] buckets;\\n    int len;\\n\\n    /** initialize your data structure here. */\\n    public MedianFinder() {\\n        buckets = new int[101];\\n        len = 0;\\n    }\\n    \\n    public void addNum(int num) {\\n        len ++;\\n        buckets[num] ++;\\n    }\\n    \\n    public double findMedian() {\\n        double half = (double) len / 2;\\n        int sum = 0;\\n        int preSum = 0;\\n        if(len % 2 == 0){\\n            for(int i = 0; i < buckets.length; i ++){\\n                sum += buckets[i];\\n                if(sum > half && preSum < half){\\n                    return (double) i;\\n                }\\n                if(sum == half && preSum < half){\\n                    for(int j = i + 1; j < buckets.length; j ++){\\n                        if(buckets[j] > 0){\\n                            return (double) (i + j) / 2;\\n                        }\\n                    }\\n                }\\n                preSum = sum;\\n            }\\n        }else{\\n            for(int i = 0; i < buckets.length; i ++){\\n                sum += buckets[i];\\n                if(sum >= half && preSum < half){\\n                    return (double) i;\\n                }\\n                preSum = sum;\\n            }\\n        }\\n        \\n        return 0.0;\\n    }\\n}\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder obj = new MedianFinder();\\n * obj.addNum(num);\\n * double param_2 = obj.findMedian();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 291599,
                "title": "clean-multiset-solution",
                "content": "We continuosly refresh an iterator pointing to the middle of a multiset depending on two things: 1) whether the new elements are inserted to the right or left of the middle iterator, 2) whether the number of current elements is even or odd.\\n\\n```\\ntypedef multiset<int> MS;\\nclass MedianFinder {\\n    int size;\\n    MS ordered_multiset;\\n    MS::iterator it;\\n    bool even;\\n    \\npublic:\\n    /** initialize your data structure here. */\\n    MedianFinder() {\\n        size=0;\\n        it = ordered_multiset.begin();\\n        even = true;\\n    }\\n    \\n    void addNum(int num) {\\n        size++;\\n        even=!even;\\n        ordered_multiset.insert(num);        \\n        if(it==ordered_multiset.end() || (even && num>=(*it))) it++; \\n        if(!even && num<*it) it--;\\n    }\\n    \\n    double findMedian() {\\n        return (!even)? *it:(*it + *prev(it))/2.0;            \\n    }\\n};\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder* obj = new MedianFinder();\\n * obj->addNum(num);\\n * double param_2 = obj->findMedian();\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\ntypedef multiset<int> MS;\\nclass MedianFinder {\\n    int size;\\n    MS ordered_multiset;\\n    MS::iterator it;\\n    bool even;\\n    \\npublic:\\n    /** initialize your data structure here. */\\n    MedianFinder() {\\n        size=0;\\n        it = ordered_multiset.begin();\\n        even = true;\\n    }\\n    \\n    void addNum(int num) {\\n        size++;\\n        even=!even;\\n        ordered_multiset.insert(num);        \\n        if(it==ordered_multiset.end() || (even && num>=(*it))) it++; \\n        if(!even && num<*it) it--;\\n    }\\n    \\n    double findMedian() {\\n        return (!even)? *it:(*it + *prev(it))/2.0;            \\n    }\\n};\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder* obj = new MedianFinder();\\n * obj->addNum(num);\\n * double param_2 = obj->findMedian();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 265977,
                "title": "double-heap-solution-in-swift",
                "content": "```swift\\nclass MedianFinder {\\n\\n    let maxHeap = Heap(topToBottom: >) // left half\\n    let minHeap = Heap(topToBottom: <) // right half\\n\\n    // make sure `maxHeap.count == minHeap.count || maxHeap.count == minHeap.count + 1`\\n    func addNum(_ num: Int) {\\n        if maxHeap.count == 0 || maxHeap.peek()! >= num {\\n            maxHeap.add(num)\\n            if maxHeap.count > minHeap.count + 1 {\\n                minHeap.add(maxHeap.extract()!)\\n            }\\n        } else {\\n            minHeap.add(num)\\n            if minHeap.count > maxHeap.count {\\n                maxHeap.add(minHeap.extract()!)\\n            }\\n        }\\n    }\\n    \\n    func findMedian() -> Double {\\n        if maxHeap.count != minHeap.count {\\n            return Double(maxHeap.peek()!)\\n        } else {\\n            return Double(maxHeap.peek()! + minHeap.peek()!) / 2\\n        }\\n    }\\n}\\n\\n// heap definition\\nclass Heap {    \\n    private var heap = [Int]()\\n    \\n    private let comparator: (_ top: Int, _ bottom: Int) -> Bool\\n    init(topToBottom comparator: @escaping (Int, Int) -> Bool) {\\n        self.comparator = comparator\\n    }\\n    \\n    var count: Int {\\n        return heap.count\\n    }\\n    \\n    func add(_ num: Int) {\\n        heap.append(num)\\n        var curr = heap.count - 1\\n        while curr > 0 {\\n            let parent = (curr - 1) / 2\\n            if !comparator(heap[parent], heap[curr]) {\\n                heap.swapAt(curr, parent)\\n                curr = parent\\n            } else {\\n                break\\n            }\\n        }\\n    }\\n    \\n    func extract() -> Int? {\\n        guard heap.count > 0 else { return nil }\\n        let result = heap[0]\\n        let last = heap.removeLast()\\n        if heap.count > 0 {\\n            heap[0] = last\\n            var curr = 0\\n            while curr < heap.count {\\n                let next: Int\\n                let left = curr * 2 + 1, right = curr * 2 + 2\\n                if right < heap.count {\\n                    next = comparator(heap[left], heap[right]) ? left : right\\n                } else if left < heap.count {\\n                    next = left\\n                } else {\\n                    break\\n                }\\n                \\n                if !comparator(heap[curr], heap[next]) {\\n                    heap.swapAt(curr, next)\\n                    curr = next\\n                } else {\\n                    break\\n                }\\n            }\\n        }\\n        return result\\n    }\\n    \\n    func peek() -> Int? {\\n        return heap.first\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass MedianFinder {\\n\\n    let maxHeap = Heap(topToBottom: >) // left half\\n    let minHeap = Heap(topToBottom: <) // right half\\n\\n    // make sure `maxHeap.count == minHeap.count || maxHeap.count == minHeap.count + 1`\\n    func addNum(_ num: Int) {\\n        if maxHeap.count == 0 || maxHeap.peek()! >= num {\\n            maxHeap.add(num)\\n            if maxHeap.count > minHeap.count + 1 {\\n                minHeap.add(maxHeap.extract()!)\\n            }\\n        } else {\\n            minHeap.add(num)\\n            if minHeap.count > maxHeap.count {\\n                maxHeap.add(minHeap.extract()!)\\n            }\\n        }\\n    }\\n    \\n    func findMedian() -> Double {\\n        if maxHeap.count != minHeap.count {\\n            return Double(maxHeap.peek()!)\\n        } else {\\n            return Double(maxHeap.peek()! + minHeap.peek()!) / 2\\n        }\\n    }\\n}\\n\\n// heap definition\\nclass Heap {    \\n    private var heap = [Int]()\\n    \\n    private let comparator: (_ top: Int, _ bottom: Int) -> Bool\\n    init(topToBottom comparator: @escaping (Int, Int) -> Bool) {\\n        self.comparator = comparator\\n    }\\n    \\n    var count: Int {\\n        return heap.count\\n    }\\n    \\n    func add(_ num: Int) {\\n        heap.append(num)\\n        var curr = heap.count - 1\\n        while curr > 0 {\\n            let parent = (curr - 1) / 2\\n            if !comparator(heap[parent], heap[curr]) {\\n                heap.swapAt(curr, parent)\\n                curr = parent\\n            } else {\\n                break\\n            }\\n        }\\n    }\\n    \\n    func extract() -> Int? {\\n        guard heap.count > 0 else { return nil }\\n        let result = heap[0]\\n        let last = heap.removeLast()\\n        if heap.count > 0 {\\n            heap[0] = last\\n            var curr = 0\\n            while curr < heap.count {\\n                let next: Int\\n                let left = curr * 2 + 1, right = curr * 2 + 2\\n                if right < heap.count {\\n                    next = comparator(heap[left], heap[right]) ? left : right\\n                } else if left < heap.count {\\n                    next = left\\n                } else {\\n                    break\\n                }\\n                \\n                if !comparator(heap[curr], heap[next]) {\\n                    heap.swapAt(curr, next)\\n                    curr = next\\n                } else {\\n                    break\\n                }\\n            }\\n        }\\n        return result\\n    }\\n    \\n    func peek() -> Int? {\\n        return heap.first\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 228234,
                "title": "java-treemap-implementation-and-follow-up-o-logn-remove-function",
                "content": "My basic idea is use two treemaps (one is minHeap called as upperMap, one is maxHeap called as lowerMap) and each time we can add and remove elements in O(log N). And once we want to find median, we need to adjust the number of two Heaps. So the remove operation will be only O(logn).\\n```\\nclass MedianFinder {\\n\\n    /** initialize your data structure here. */\\n    TreeMap<Integer, Integer> upperMap, lowerMap;\\n    int countU, countL;\\n    //39\\n    public MedianFinder() {\\n        countU = 0;\\n        countL = 0;\\n        upperMap = new TreeMap<>();\\n        lowerMap = new TreeMap<>(Collections.reverseOrder());\\n    }\\n    \\n    public void addNum(int num){\\n        addNumHelper(num);\\n        // remove(num);\\n        // addNumHelper(num);\\n    }\\n    public void addNumHelper(int num) {\\n        if (upperMap.isEmpty() || num >= upperMap.firstKey()){//here, we should be careful about the if we can get upperMap.firstKey\\n            upperMap.put(num, upperMap.getOrDefault(num, 0) + 1);\\n            countU++;\\n        }else{\\n            lowerMap.put(num, lowerMap.getOrDefault(num, 0) + 1);\\n            countL++;\\n        }\\n        adjust();\\n    }\\n    public boolean remove(int num){\\n        if (num >= upperMap.firstKey()){\\n            if (!upperMap.containsKey(num)){\\n                return false;\\n            }\\n            int val = upperMap.get(num) -1;\\n            if(val == 0){upperMap.remove(num);}\\n            else{upperMap.put(num, val);}\\n            countU--;\\n        }else{\\n            if (!lowerMap.containsKey(num)){\\n                return false;\\n            }\\n            int val = lowerMap.get(num) - 1;\\n            if (val == 0){lowerMap.remove(num);}\\n            else{lowerMap.put(num, val);}\\n            countL--;\\n            \\n        }\\n        adjust();\\n        return true;\\n    }\\n    private void adjust(){\\n        if (countU > countL + 1){\\n            // Map.Entry<Integer,Integer> firstEntry = upperMap.firstEntry();\\n            int firstKey = upperMap.firstKey();\\n            int firstVal = upperMap.get(firstKey);\\n            if (countU - firstVal >= countL + firstVal){\\n                lowerMap.put(firstKey, firstVal);\\n                countU -= firstVal;\\n                countL += firstVal;\\n                upperMap.remove(firstKey);//remove need to be at last\\n            }\\n            \\n        }\\n        if (countL > countU + 1 ){\\n            // Map.Entry<Integer, Integer> firstEntry = lowerMap.firstEntry();\\n            int firstKey = lowerMap.firstKey();\\n            int firstVal = lowerMap.get(firstKey);\\n            if (countL - firstVal >= countU + firstVal){\\n                upperMap.put(firstKey, firstVal);\\n                countL -= firstVal;\\n                countU += firstVal;\\n                lowerMap.remove(firstKey);\\n            }\\n            \\n        }\\n    }\\n    public double findMedian() {\\n        // adjust();\\n        \\n        if (countU == countL){\\n            return (double)(upperMap.firstKey() + lowerMap.firstKey()) / 2;\\n        }else if (countU < countL){\\n            return lowerMap.firstKey();\\n        }else{\\n            return upperMap.firstKey();\\n        }\\n    }\\n}\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder obj = new MedianFinder();\\n * obj.addNum(num);\\n * double param_2 = obj.findMedian();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass MedianFinder {\\n\\n    /** initialize your data structure here. */\\n    TreeMap<Integer, Integer> upperMap, lowerMap;\\n    int countU, countL;\\n    //39\\n    public MedianFinder() {\\n        countU = 0;\\n        countL = 0;\\n        upperMap = new TreeMap<>();\\n        lowerMap = new TreeMap<>(Collections.reverseOrder());\\n    }\\n    \\n    public void addNum(int num){\\n        addNumHelper(num);\\n        // remove(num);\\n        // addNumHelper(num);\\n    }\\n    public void addNumHelper(int num) {\\n        if (upperMap.isEmpty() || num >= upperMap.firstKey()){//here, we should be careful about the if we can get upperMap.firstKey\\n            upperMap.put(num, upperMap.getOrDefault(num, 0) + 1);\\n            countU++;\\n        }else{\\n            lowerMap.put(num, lowerMap.getOrDefault(num, 0) + 1);\\n            countL++;\\n        }\\n        adjust();\\n    }\\n    public boolean remove(int num){\\n        if (num >= upperMap.firstKey()){\\n            if (!upperMap.containsKey(num)){\\n                return false;\\n            }\\n            int val = upperMap.get(num) -1;\\n            if(val == 0){upperMap.remove(num);}\\n            else{upperMap.put(num, val);}\\n            countU--;\\n        }else{\\n            if (!lowerMap.containsKey(num)){\\n                return false;\\n            }\\n            int val = lowerMap.get(num) - 1;\\n            if (val == 0){lowerMap.remove(num);}\\n            else{lowerMap.put(num, val);}\\n            countL--;\\n            \\n        }\\n        adjust();\\n        return true;\\n    }\\n    private void adjust(){\\n        if (countU > countL + 1){\\n            // Map.Entry<Integer,Integer> firstEntry = upperMap.firstEntry();\\n            int firstKey = upperMap.firstKey();\\n            int firstVal = upperMap.get(firstKey);\\n            if (countU - firstVal >= countL + firstVal){\\n                lowerMap.put(firstKey, firstVal);\\n                countU -= firstVal;\\n                countL += firstVal;\\n                upperMap.remove(firstKey);//remove need to be at last\\n            }\\n            \\n        }\\n        if (countL > countU + 1 ){\\n            // Map.Entry<Integer, Integer> firstEntry = lowerMap.firstEntry();\\n            int firstKey = lowerMap.firstKey();\\n            int firstVal = lowerMap.get(firstKey);\\n            if (countL - firstVal >= countU + firstVal){\\n                upperMap.put(firstKey, firstVal);\\n                countL -= firstVal;\\n                countU += firstVal;\\n                lowerMap.remove(firstKey);\\n            }\\n            \\n        }\\n    }\\n    public double findMedian() {\\n        // adjust();\\n        \\n        if (countU == countL){\\n            return (double)(upperMap.firstKey() + lowerMap.firstKey()) / 2;\\n        }else if (countU < countL){\\n            return lowerMap.firstKey();\\n        }else{\\n            return upperMap.firstKey();\\n        }\\n    }\\n}\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder obj = new MedianFinder();\\n * obj.addNum(num);\\n * double param_2 = obj.findMedian();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 74039,
                "title": "c-two-heaps",
                "content": "Sorted Array: Left (Max Heap) - Mid - Right (Min Heap)\\n\\n```\\nclass MedianFinder {\\npublic:\\n    /** initialize your data structure here. */\\n    MedianFinder() {}\\n    \\n    void addNum(int num) {\\n        (left.empty() || num <= left.top()) ? left.push(num) : right.push(num);\\n        if(left.size() > right.size() + 1){\\n            right.push(left.top());\\n            left.pop();\\n        }\\n        if(right.size() > left.size()){\\n            left.push(right.top());\\n            right.pop();\\n        }\\n    }\\n    \\n    double findMedian() {\\n        return left.size() > right.size()? left.top() : (left.top() + right.top()) / 2.0;\\n    }\\n\\nprivate:\\n    priority_queue<int>left;\\n    priority_queue<int, vector<int>, greater<int>>right;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass MedianFinder {\\npublic:\\n    /** initialize your data structure here. */\\n    MedianFinder() {}\\n    \\n    void addNum(int num) {\\n        (left.empty() || num <= left.top()) ? left.push(num) : right.push(num);\\n        if(left.size() > right.size() + 1){\\n            right.push(left.top());\\n            left.pop();\\n        }\\n        if(right.size() > left.size()){\\n            left.push(right.top());\\n            right.pop();\\n        }\\n    }\\n    \\n    double findMedian() {\\n        return left.size() > right.size()? left.top() : (left.top() + right.top()) / 2.0;\\n    }\\n\\nprivate:\\n    priority_queue<int>left;\\n    priority_queue<int, vector<int>, greater<int>>right;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 74048,
                "title": "c-heap-solution",
                "content": "Have a C# solution using a heap. No heap exists in C# for some reason so I had to write one.\\nSince I wrote it, it is capable of both Min and Max via a switch enum. Solution is much like the others, where we use 2 heaps, one min, and one max. We pop and push judging on the respective size of each queue. The 'upper' value numbers are held in a Min heap, the 'lower' value numbers are held in a max heap. If a number is truly on the Maximum end of the spectrum, it will be in the 'bottom' of MIN Heap with no possibility of being ejected. If a number is truly on the Minimum end of the spectrum, it will be in the 'bottom' of the MAX Heap with no possibility of being ejected.\\n\\nAs an insertion example, we'll use 4 numbers: 10, 5, 7, 4. \\n\\nInsert(10)\\n\\nWe push to the MIN Heap.\\nThe contents of MIN Heap are (10).\\nThe contents of MAX Heap are ().\\n\\nThen we push to the MAX Heap, the Pop() of the MIN Heap.\\nThe contents of MIN Heap are ().\\nThe contents of MAX Heap are (10).\\n\\nIf MIN Heap's size is less than MAX Heap (**TRUE**), we push to the MIN Heap, the Pop() of the MAX Heap. \\nThe contents of MIN Heap are (10).\\nThe contents of MAX Heap are ().\\n\\nInsert(5)\\n\\nWe push to the MIN Heap.\\nThe contents of MIN Heap are (10, 5).\\nThe contents of MAX Heap are ().\\n\\nThen we push to the MAX Heap, the Pop() of the MIN Heap.\\nThe contents of MIN Heap are (10).\\nThe contents of MAX Heap are (5).\\n\\nIf MIN Heap's size is less than MAX Heap (**FALSE**), we push to the MIN Heap, the Pop() of the MAX Heap. \\nThe contents of MIN Heap are (10).\\nThe contents of MAX Heap are (5).\\n\\nInsert(7)\\n\\nFirst we push to the MIN Heap.\\nThe contents of MIN Heap are (10, 7).\\nThe contents of MAX Heap are (5).\\n\\nThen we push to the MAX Heap, the Pop() of the MIN Heap.\\nThe contents of MIN Heap are (10).\\nThe contents of MAX Heap are (5, 7).\\n\\nIf MIN Heap's size is less than MAX Heap (**TRUE**), we push to the MIN Heap, the Pop() of the MAX Heap. \\nThe contents of MIN Heap are (10, 7).\\nThe contents of MAX Heap are (5).\\n\\nInsert(4)\\n\\nFirst we push to the MIN Heap.\\nThe contents of MIN Heap are (10, 7, 4).\\nThe contents of MAX Heap are (5).\\n\\nThen we push to the MAX Heap, the Pop() of the MIN Heap.\\nThe contents of MIN Heap are (10, 7).\\nThe contents of MAX Heap are (5, 4).\\n\\nIf MIN Heap's size is less than MAX Heap (**FALSE**), we push to the MIN Heap, the Pop() of the MAX Heap. \\nThe contents of MIN Heap are (10, 7).\\nThe contents of MAX Heap are (5, 4).\\n\\nFinding The Median:\\n\\nIf the MIN Heap is larger, we have an odd number of contents, so we Pop() the MIN Heap for our median.\\n\\nIf the MIN Heap and the MAX Heap are the same size, we have an even number of contents, so we\\nPop() both and average the value, so in this case.\\nThe contents of MIN Heap are (10, 7).\\nWe pop 7.\\n\\nThe contents of MAX Heap are (5, 4).\\nWe pop 5.\\n\\n7 + 5 / 2 = 6\\n\\n\\n```\\npublic class MedianFinder\\n{\\n    private IntegerHeap m_MinHeap;\\n    private IntegerHeap m_MaxHeap;\\n    /** initialize your data structure here. */\\n    public MedianFinder()\\n    {\\n        m_MinHeap = new IntegerHeap(IntegerHeap.SortType.MIN);\\n        m_MaxHeap = new IntegerHeap(IntegerHeap.SortType.MAX);\\n    }\\n\\n    public void AddNum(int num)\\n    {\\n        m_MinHeap.Insert(num);\\n        m_MaxHeap.Insert(m_MinHeap.Pop());\\n        if (m_MinHeap.m_Size < m_MaxHeap.m_Size) m_MinHeap.Insert(m_MaxHeap.Pop());\\n    }\\n\\n\\n    public double FindMedian()\\n    {\\n        if (m_MinHeap.m_Size > m_MaxHeap.m_Size)\\n        {\\n            return m_MinHeap.Peek();\\n        }\\n        else\\n        {\\n            return (m_MinHeap.Peek() + m_MaxHeap.Peek()) / 2.0;\\n        }\\n    }\\n\\n\\n    /// <summary>\\n    /// Integer Heap by Steve Stermer. \\n    /// Integer heap is held as an array. Left child is indexed as 2i + 1, right child is indexed as 2i + 2.\\n    /// </summary>\\n    private class IntegerHeap\\n    {\\n        public enum SortType\\n        {\\n            MIN,\\n            MAX\\n        }\\n\\n        private SortType m_ActiveSort;\\n        private int[] m_Heap = new int[100];\\n        public int m_Size;\\n\\n        public IntegerHeap(SortType activeSort)\\n        {\\n            m_ActiveSort = activeSort;\\n        }\\n\\n        private void ResizeHeap()\\n        {\\n            if (m_Size * 2 + 2 >= m_Heap.Length)\\n            {\\n                int[] newHeap = new int[m_Heap.Length * 2];\\n                Array.Copy(m_Heap, newHeap, m_Size);\\n                m_Heap = newHeap;\\n            }\\n        }\\n\\n        public void Insert(int number)\\n        {\\n            ResizeHeap();\\n            m_Heap[m_Size] = number;\\n            BubbleUp(m_Size);\\n            m_Size++;\\n        }\\n\\n        private void SwapAToB(int indexA, int indexB)\\n        {\\n            int tempVal = m_Heap[indexA];\\n            m_Heap[indexA] = m_Heap[indexB];\\n            m_Heap[indexB] = tempVal;\\n        }\\n\\n        //When inserting a new number, we 'bubble up' to find its right place.\\n        private void BubbleUp(int index)\\n        {\\n            if (index == 0) return;\\n\\n            int parentOffset = index % 2 == 0 ? parentOffset = 2 : 1; //Was a 'right' node it was even, else, it was a left.\\n            bool swapIndices = false;\\n\\n            switch (m_ActiveSort)\\n            {\\n                case SortType.MAX:\\n                    if (m_Heap[index] > m_Heap[(index - parentOffset) / 2]) swapIndices = true; //If greater than its parent, setup swap.\\n                    break;\\n                case SortType.MIN:\\n                    if (m_Heap[index] < m_Heap[(index - parentOffset) / 2]) swapIndices = true; //If less than its parent, setup swap.\\n                    break;\\n            }\\n\\n            if (swapIndices)\\n            {\\n                SwapAToB((index - parentOffset) / 2, index);\\n                BubbleUp((index - parentOffset) / 2);\\n            }\\n        }\\n\\n        //If we pop the root, we place the last added number in the root, and 'bubble down' to find its right place\\n        private void BubbleDown(int index)\\n        {\\n            if (index >= m_Size - 1) return; //No where to bubble.\\n\\n            bool swapLeft = false;\\n            bool swapRight = false;\\n\\n            switch (m_ActiveSort)\\n            {\\n                case SortType.MAX:\\n                    if (2 * index + 1 < m_Size && m_Heap[index] < m_Heap[2 * index + 1]) //if less than left child, swap. Check if child is out of bounds.\\n                    {\\n                        SwapAToB(index, 2 * index + 1);\\n                        swapLeft = true;\\n                    }\\n                    if (2 * index + 2 < m_Size && m_Heap[index] < m_Heap[2 * index + 2]) //if less than right child, swap. Chick if child is out of bounds.\\n                    {\\n                        SwapAToB(index, 2 * index + 2);\\n                        swapRight = true;\\n                    }\\n                    break;\\n                case SortType.MIN:\\n                    if (2 * index + 1 < m_Size && m_Heap[index] > m_Heap[2 * index + 1]) //if greater than left child, swap. Check if child is out of bounds.\\n                    {\\n                        SwapAToB(index, 2 * index + 1);\\n                        swapLeft = true;\\n                    }\\n                    if (2 * index + 2 < m_Size && m_Heap[index] > m_Heap[2 * index + 2]) //if greater than right child, swap. Check if child is out of bounds.\\n                    {\\n                        SwapAToB(index, 2 * index + 2);\\n                        swapRight = true;\\n                    }\\n                    break;\\n            }\\n\\n            if (swapRight) BubbleDown(2 * index + 2); //If a swap was performed, continue the bubbling down.\\n            if (swapLeft) BubbleDown(2 * index + 1); //Since we could have swapped both sides above, we most now perform on both sides.\\n        }\\n\\n        public int Peek()\\n        {\\n            if (m_Size != 0) return m_Heap[0];\\n            return int.MinValue;\\n        }\\n\\n        public int Pop()\\n        {\\n            if (m_Size != 0)\\n            {\\n                int rootValue = m_Heap[0];\\n                m_Heap[0] = m_Heap[m_Size - 1];\\n                m_Size--;\\n\\n                BubbleDown(0);\\n                return rootValue;\\n\\n            }\\n\\n            return int.MinValue;\\n        }\\n    } //end Integer Heap\\n\\n}//end Median Finder\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class MedianFinder\\n{\\n    private IntegerHeap m_MinHeap;\\n    private IntegerHeap m_MaxHeap;\\n    /** initialize your data structure here. */\\n    public MedianFinder()\\n    {\\n        m_MinHeap = new IntegerHeap(IntegerHeap.SortType.MIN);\\n        m_MaxHeap = new IntegerHeap(IntegerHeap.SortType.MAX);\\n    }\\n\\n    public void AddNum(int num)\\n    {\\n        m_MinHeap.Insert(num);\\n        m_MaxHeap.Insert(m_MinHeap.Pop());\\n        if (m_MinHeap.m_Size < m_MaxHeap.m_Size) m_MinHeap.Insert(m_MaxHeap.Pop());\\n    }\\n\\n\\n    public double FindMedian()\\n    {\\n        if (m_MinHeap.m_Size > m_MaxHeap.m_Size)\\n        {\\n            return m_MinHeap.Peek();\\n        }\\n        else\\n        {\\n            return (m_MinHeap.Peek() + m_MaxHeap.Peek()) / 2.0;\\n        }\\n    }\\n\\n\\n    /// <summary>\\n    /// Integer Heap by Steve Stermer. \\n    /// Integer heap is held as an array. Left child is indexed as 2i + 1, right child is indexed as 2i + 2.\\n    /// </summary>\\n    private class IntegerHeap\\n    {\\n        public enum SortType\\n        {\\n            MIN,\\n            MAX\\n        }\\n\\n        private SortType m_ActiveSort;\\n        private int[] m_Heap = new int[100];\\n        public int m_Size;\\n\\n        public IntegerHeap(SortType activeSort)\\n        {\\n            m_ActiveSort = activeSort;\\n        }\\n\\n        private void ResizeHeap()\\n        {\\n            if (m_Size * 2 + 2 >= m_Heap.Length)\\n            {\\n                int[] newHeap = new int[m_Heap.Length * 2];\\n                Array.Copy(m_Heap, newHeap, m_Size);\\n                m_Heap = newHeap;\\n            }\\n        }\\n\\n        public void Insert(int number)\\n        {\\n            ResizeHeap();\\n            m_Heap[m_Size] = number;\\n            BubbleUp(m_Size);\\n            m_Size++;\\n        }\\n\\n        private void SwapAToB(int indexA, int indexB)\\n        {\\n            int tempVal = m_Heap[indexA];\\n            m_Heap[indexA] = m_Heap[indexB];\\n            m_Heap[indexB] = tempVal;\\n        }\\n\\n        //When inserting a new number, we 'bubble up' to find its right place.\\n        private void BubbleUp(int index)\\n        {\\n            if (index == 0) return;\\n\\n            int parentOffset = index % 2 == 0 ? parentOffset = 2 : 1; //Was a 'right' node it was even, else, it was a left.\\n            bool swapIndices = false;\\n\\n            switch (m_ActiveSort)\\n            {\\n                case SortType.MAX:\\n                    if (m_Heap[index] > m_Heap[(index - parentOffset) / 2]) swapIndices = true; //If greater than its parent, setup swap.\\n                    break;\\n                case SortType.MIN:\\n                    if (m_Heap[index] < m_Heap[(index - parentOffset) / 2]) swapIndices = true; //If less than its parent, setup swap.\\n                    break;\\n            }\\n\\n            if (swapIndices)\\n            {\\n                SwapAToB((index - parentOffset) / 2, index);\\n                BubbleUp((index - parentOffset) / 2);\\n            }\\n        }\\n\\n        //If we pop the root, we place the last added number in the root, and 'bubble down' to find its right place\\n        private void BubbleDown(int index)\\n        {\\n            if (index >= m_Size - 1) return; //No where to bubble.\\n\\n            bool swapLeft = false;\\n            bool swapRight = false;\\n\\n            switch (m_ActiveSort)\\n            {\\n                case SortType.MAX:\\n                    if (2 * index + 1 < m_Size && m_Heap[index] < m_Heap[2 * index + 1]) //if less than left child, swap. Check if child is out of bounds.\\n                    {\\n                        SwapAToB(index, 2 * index + 1);\\n                        swapLeft = true;\\n                    }\\n                    if (2 * index + 2 < m_Size && m_Heap[index] < m_Heap[2 * index + 2]) //if less than right child, swap. Chick if child is out of bounds.\\n                    {\\n                        SwapAToB(index, 2 * index + 2);\\n                        swapRight = true;\\n                    }\\n                    break;\\n                case SortType.MIN:\\n                    if (2 * index + 1 < m_Size && m_Heap[index] > m_Heap[2 * index + 1]) //if greater than left child, swap. Check if child is out of bounds.\\n                    {\\n                        SwapAToB(index, 2 * index + 1);\\n                        swapLeft = true;\\n                    }\\n                    if (2 * index + 2 < m_Size && m_Heap[index] > m_Heap[2 * index + 2]) //if greater than right child, swap. Check if child is out of bounds.\\n                    {\\n                        SwapAToB(index, 2 * index + 2);\\n                        swapRight = true;\\n                    }\\n                    break;\\n            }\\n\\n            if (swapRight) BubbleDown(2 * index + 2); //If a swap was performed, continue the bubbling down.\\n            if (swapLeft) BubbleDown(2 * index + 1); //Since we could have swapped both sides above, we most now perform on both sides.\\n        }\\n\\n        public int Peek()\\n        {\\n            if (m_Size != 0) return m_Heap[0];\\n            return int.MinValue;\\n        }\\n\\n        public int Pop()\\n        {\\n            if (m_Size != 0)\\n            {\\n                int rootValue = m_Heap[0];\\n                m_Heap[0] = m_Heap[m_Size - 1];\\n                m_Size--;\\n\\n                BubbleDown(0);\\n                return rootValue;\\n\\n            }\\n\\n            return int.MinValue;\\n        }\\n    } //end Integer Heap\\n\\n}//end Median Finder\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564564,
                "content": [
                    {
                        "username": "nupt_wang",
                        "content": "***1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nWe can maintain an integer array of length 100 to store the count of each number along with a total count.  Then, we can iterate over the array to find the middle value to get our median.\\n\\nTime and space complexity would be O(100) = O(1).\\n\\n***2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nIn this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100]."
                    },
                    {
                        "username": "kevintancs",
                        "content": "[@psing9968](/psing9968) iterating over an array with fixed size of 100 is O(100) = O(1)"
                    },
                    {
                        "username": "A5HU705H",
                        "content": "[@murlinwang](/murlinwang) but it guarantees a 99% hits on 0, 100"
                    },
                    {
                        "username": "psing9968",
                        "content": "If we are iterating over the array, how can it be O(1) ?"
                    },
                    {
                        "username": "hombreingwar",
                        "content": "2. why not just ignore values outside [0, 100]. They won\\'t impact the median since they are anomalies median calculation is designed for to ignore.  "
                    },
                    {
                        "username": "murlinwang",
                        "content": "[@Max7cd](/Max7cd) I think there could be cases where integers in the data stream are all out of the range of 0-100. In that case, if we want the median, the count of those integers would not help. I am also learning so correct me if I am wrong."
                    },
                    {
                        "username": "c0s",
                        "content": "[@Max7cd](/Max7cd) it would not let to call findMedian() until this requirement is met on already streamed values"
                    },
                    {
                        "username": "Max7cd",
                        "content": "> 2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n> \\n> In this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100].\\n\\nI am not 100% sure, but couldn\\'t we just keep a count of how many numbers are above 100 and how many numbers are below 0, since these numbers could never get to be the median and are therefore not important to keep?\\nThis would keep the solution in O(1) time and memory."
                    },
                    {
                        "username": "mahapatro",
                        "content": "Really great"
                    },
                    {
                        "username": "Future6",
                        "content": "[\"MedianFinder\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"]\\n[[],[6],[],[10],[],[2],[],[6],[],[5],[],[0],[],[6],[],[3],[],[1],[],[0],[],[0],[]]\\n\\nso the list is {6, 10, 2, 6, 5, 0, 6, 3, 1, 0, 0}\\nand the MedianFinder result should be: 6, 8, 10, 6, 2, 4, 6, 5.5, 5, 2.5, 0\\n\\nBut it offers answer as follows:\\n[null,null,6.00000,null,8.00000,null,**6.00000**,null,6.00000,null,**6.00000**,null,5.50000,null,6.00000,null,5.50000,null,5.00000,null,4.00000,null,3.00000]\\n\\nOr I misunderstand this quesiton"
                    },
                    {
                        "username": "rajputasif",
                        "content": "[@CrossBon3](/CrossBon3) Thanks for the reply... my data is already sorted in multiset strange!\\n\\n6 out:6\\n6 10 out:8\\n2 6 10 out:6\\n2 6 6 10 out:6\\n2 5 6 6 10 out:6\\n0 2 5 6 6 10 out:5 //5.5 expected\\n0 2 5 6 6 6 10 out:5 //6 expected\\n0 2 3 5 6 6 6 10 out:5 //5.5 expected\\n0 1 2 3 5 6 6 6 10 out:5\\n0 0 1 2 3 5 6 6 6 10 out:5\\n0 0 0 1 2 3 5 6 6 6 10 out:5"
                    },
                    {
                        "username": "adanaza89",
                        "content": "[@CrossBon3](/CrossBon3) Oh wow!! I missed this very important aspect of the question. I came here because I was sure I was right. Thanks for your answer"
                    },
                    {
                        "username": "CrossBon3",
                        "content": "median is performed on sorted array.\\nfor first 2 numbers you get correct cause they are already in sorted fashion so you got median as 6 and 8.\\nwhen 2 is added to the array, array need to be sorted(it looks [2,6,10]). thus median will be 6. "
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "**Important posts from discussions:**\\n- I was asked this question in an interview today. I told about the minHeap and maxHeap approach. The interviewer asked what if the data is very very large. How would you handle it? Any thoughts?! \\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/228442/Java-Solution-with-Tree-O(Log-N)-Insertion-and-Lookup-+-Explanation : Java Solution with Tree - O(Log N) Insertion and Lookup + Explanation\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/111698/Be-asked-for-a-multi-thread-and-thread-safe-solution-in-a-real-interview. : Be asked for a multi-thread and thread-safe solution in a real interview\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/652498/Good-for-interviews:-Python-general-sort-greater-insertion-sort-greater-two-heaps-greater-follow-ups : Good for interviews: Python general sort -> insertion sort -> two heaps -> follow-ups\\n\\n**Observations:**\\n- The change in Median: when a new element comes, the new median will be either 1 unit left or 1 unit right to the prvious median. We use 2 pointers to implement this along with taking care of average of middle numbers for even size.\\n- Median means sorted data and middle element(s). Sorted data means \\'array/collection + manual sort\\' or self balanced bst or miltuple heaps or monotonic stack or deque (which isn\\'t useful for this problem since monotonic stack/deque will involve removal exisiting elements).  \\n- Heap utilities:\\n\\t- using a heap for a data set helps to get the smallest/largest element fastly\\n\\t- using 2 heaps: if we divide the random data (non sorted data) into 2 heaps (1 min and other max) such that the first half of sorted data (data if it had been sorted) is in max heap and second half of sorted data (data if it had been sorted) is in min heap, we could easily get the middle element of the sorted data (data if it had been sorted). VISUALIZE!!!"
                    },
                    {
                        "username": "prYsm",
                        "content": "If there is a condition that the calls to findMedian() are less, we can lazily compute the median.\n\n1. Have two lists: Unsorted list, sorted list.\n2. If query == Addelement():\n    2.1 Add element to unsorted list.\n3. If query == FindMedian():\n    3.1 sort(unsorted list) call it X.\n    3.2 Merge(x, sortedlist) and assign it back to sortedlist.\n    3.3 Use indexes to find middle elements from sorted list.\n\nYes, 3 in the worst case would take O(nlogn). But, we are not computing it every time we get a query. This way we only spend cycles, which is especially important if we have large amount of data, when we want to compute median."
                    },
                    {
                        "username": "avminus",
                        "content": "Hey your second link is not opening, can you please share something regarding this thread safety discussion can\\'t seem to find it anywhere.\\n"
                    },
                    {
                        "username": "chao4",
                        "content": "In real world streaming application. The data amount will be huge so it is impossible to hold all the data in the stream into memory.\\n\\nI think it is a good open-end question to ask. What if the memory is not allowed to hold all the data from the beginning. Some data needs to go to hard drive. How will we optmize that."
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "what would be the solution in that case? i\\'m guessing some amount of memoization would be needed?"
                    },
                    {
                        "username": "prakashsellathurai",
                        "content": "`1. If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\nSince the input range is bounded we can use counter array to calculate median, where count[i] represents the number of times integer data occur in the stream in O(1) space and time\\n**refer this problem**: [statistics-from-a-large-sample](https://leetcode.com/problems/statistics-from-a-large-sample/description/)\\n\\n`2. If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\n\\nIF 99% of all integers from the stream are in the range [0,100] then considering empirical rule \\n\\n\"99.7% of data observed following a normal distribution lies within 3 standard deviations of the mean\"\\n\\nwe can assume that the input stream is normally distributed in this case.\\nIf we maintain a   reservoir  of  100 items sampled with equal probability stored in a array then we can estimate the median of the the input data with highest confidence  for large input data distribution of unknown size .\\n\\n**Alternate Interesting Solution**: By using median filter [stackoverflow](https://stackoverflow.com/a/15150968/8336491)\\n\\n  \\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Wanted to complete it quickly by using Sorting instead of two heaps and got TLE haha"
                    },
                    {
                        "username": "54564269",
                        "content": "Got it done pretty soon using 2 heaps in a real interview. However, in the follow-up, I'm asked how to improve it and make sure the method is thread-safe if the two heaps are shared."
                    },
                    {
                        "username": "adit2005",
                        "content": "can u pls share the answer for follow-up question asked ??"
                    },
                    {
                        "username": "animish01",
                        "content": "do you know it now? can you share?"
                    },
                    {
                        "username": "bayernkang",
                        "content": "Should I implement the Heap data structure myself ? (that\\'s a lot of code to memorize and write).\\n\\nDo anyone encounter a quesiton in a real interview that have to use heap but you are using Javascript?"
                    },
                    {
                        "username": "suziray",
                        "content": "I saw there is some solution for using BST in C++, and I heard some hint for using Counting Sort or maintaining the median and the numbers next to it. Is there a way to do these in Java?\\n\\nAdditionally,  another version is to return the median of recent k numbers added, how could this be achieved..."
                    },
                    {
                        "username": "jsnoob",
                        "content": "Follow up:\\n\\n1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?"
                    }
                ]
            },
            {
                "id": 1567243,
                "content": [
                    {
                        "username": "nupt_wang",
                        "content": "***1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nWe can maintain an integer array of length 100 to store the count of each number along with a total count.  Then, we can iterate over the array to find the middle value to get our median.\\n\\nTime and space complexity would be O(100) = O(1).\\n\\n***2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nIn this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100]."
                    },
                    {
                        "username": "kevintancs",
                        "content": "[@psing9968](/psing9968) iterating over an array with fixed size of 100 is O(100) = O(1)"
                    },
                    {
                        "username": "A5HU705H",
                        "content": "[@murlinwang](/murlinwang) but it guarantees a 99% hits on 0, 100"
                    },
                    {
                        "username": "psing9968",
                        "content": "If we are iterating over the array, how can it be O(1) ?"
                    },
                    {
                        "username": "hombreingwar",
                        "content": "2. why not just ignore values outside [0, 100]. They won\\'t impact the median since they are anomalies median calculation is designed for to ignore.  "
                    },
                    {
                        "username": "murlinwang",
                        "content": "[@Max7cd](/Max7cd) I think there could be cases where integers in the data stream are all out of the range of 0-100. In that case, if we want the median, the count of those integers would not help. I am also learning so correct me if I am wrong."
                    },
                    {
                        "username": "c0s",
                        "content": "[@Max7cd](/Max7cd) it would not let to call findMedian() until this requirement is met on already streamed values"
                    },
                    {
                        "username": "Max7cd",
                        "content": "> 2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n> \\n> In this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100].\\n\\nI am not 100% sure, but couldn\\'t we just keep a count of how many numbers are above 100 and how many numbers are below 0, since these numbers could never get to be the median and are therefore not important to keep?\\nThis would keep the solution in O(1) time and memory."
                    },
                    {
                        "username": "mahapatro",
                        "content": "Really great"
                    },
                    {
                        "username": "Future6",
                        "content": "[\"MedianFinder\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"]\\n[[],[6],[],[10],[],[2],[],[6],[],[5],[],[0],[],[6],[],[3],[],[1],[],[0],[],[0],[]]\\n\\nso the list is {6, 10, 2, 6, 5, 0, 6, 3, 1, 0, 0}\\nand the MedianFinder result should be: 6, 8, 10, 6, 2, 4, 6, 5.5, 5, 2.5, 0\\n\\nBut it offers answer as follows:\\n[null,null,6.00000,null,8.00000,null,**6.00000**,null,6.00000,null,**6.00000**,null,5.50000,null,6.00000,null,5.50000,null,5.00000,null,4.00000,null,3.00000]\\n\\nOr I misunderstand this quesiton"
                    },
                    {
                        "username": "rajputasif",
                        "content": "[@CrossBon3](/CrossBon3) Thanks for the reply... my data is already sorted in multiset strange!\\n\\n6 out:6\\n6 10 out:8\\n2 6 10 out:6\\n2 6 6 10 out:6\\n2 5 6 6 10 out:6\\n0 2 5 6 6 10 out:5 //5.5 expected\\n0 2 5 6 6 6 10 out:5 //6 expected\\n0 2 3 5 6 6 6 10 out:5 //5.5 expected\\n0 1 2 3 5 6 6 6 10 out:5\\n0 0 1 2 3 5 6 6 6 10 out:5\\n0 0 0 1 2 3 5 6 6 6 10 out:5"
                    },
                    {
                        "username": "adanaza89",
                        "content": "[@CrossBon3](/CrossBon3) Oh wow!! I missed this very important aspect of the question. I came here because I was sure I was right. Thanks for your answer"
                    },
                    {
                        "username": "CrossBon3",
                        "content": "median is performed on sorted array.\\nfor first 2 numbers you get correct cause they are already in sorted fashion so you got median as 6 and 8.\\nwhen 2 is added to the array, array need to be sorted(it looks [2,6,10]). thus median will be 6. "
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "**Important posts from discussions:**\\n- I was asked this question in an interview today. I told about the minHeap and maxHeap approach. The interviewer asked what if the data is very very large. How would you handle it? Any thoughts?! \\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/228442/Java-Solution-with-Tree-O(Log-N)-Insertion-and-Lookup-+-Explanation : Java Solution with Tree - O(Log N) Insertion and Lookup + Explanation\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/111698/Be-asked-for-a-multi-thread-and-thread-safe-solution-in-a-real-interview. : Be asked for a multi-thread and thread-safe solution in a real interview\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/652498/Good-for-interviews:-Python-general-sort-greater-insertion-sort-greater-two-heaps-greater-follow-ups : Good for interviews: Python general sort -> insertion sort -> two heaps -> follow-ups\\n\\n**Observations:**\\n- The change in Median: when a new element comes, the new median will be either 1 unit left or 1 unit right to the prvious median. We use 2 pointers to implement this along with taking care of average of middle numbers for even size.\\n- Median means sorted data and middle element(s). Sorted data means \\'array/collection + manual sort\\' or self balanced bst or miltuple heaps or monotonic stack or deque (which isn\\'t useful for this problem since monotonic stack/deque will involve removal exisiting elements).  \\n- Heap utilities:\\n\\t- using a heap for a data set helps to get the smallest/largest element fastly\\n\\t- using 2 heaps: if we divide the random data (non sorted data) into 2 heaps (1 min and other max) such that the first half of sorted data (data if it had been sorted) is in max heap and second half of sorted data (data if it had been sorted) is in min heap, we could easily get the middle element of the sorted data (data if it had been sorted). VISUALIZE!!!"
                    },
                    {
                        "username": "prYsm",
                        "content": "If there is a condition that the calls to findMedian() are less, we can lazily compute the median.\n\n1. Have two lists: Unsorted list, sorted list.\n2. If query == Addelement():\n    2.1 Add element to unsorted list.\n3. If query == FindMedian():\n    3.1 sort(unsorted list) call it X.\n    3.2 Merge(x, sortedlist) and assign it back to sortedlist.\n    3.3 Use indexes to find middle elements from sorted list.\n\nYes, 3 in the worst case would take O(nlogn). But, we are not computing it every time we get a query. This way we only spend cycles, which is especially important if we have large amount of data, when we want to compute median."
                    },
                    {
                        "username": "avminus",
                        "content": "Hey your second link is not opening, can you please share something regarding this thread safety discussion can\\'t seem to find it anywhere.\\n"
                    },
                    {
                        "username": "chao4",
                        "content": "In real world streaming application. The data amount will be huge so it is impossible to hold all the data in the stream into memory.\\n\\nI think it is a good open-end question to ask. What if the memory is not allowed to hold all the data from the beginning. Some data needs to go to hard drive. How will we optmize that."
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "what would be the solution in that case? i\\'m guessing some amount of memoization would be needed?"
                    },
                    {
                        "username": "prakashsellathurai",
                        "content": "`1. If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\nSince the input range is bounded we can use counter array to calculate median, where count[i] represents the number of times integer data occur in the stream in O(1) space and time\\n**refer this problem**: [statistics-from-a-large-sample](https://leetcode.com/problems/statistics-from-a-large-sample/description/)\\n\\n`2. If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\n\\nIF 99% of all integers from the stream are in the range [0,100] then considering empirical rule \\n\\n\"99.7% of data observed following a normal distribution lies within 3 standard deviations of the mean\"\\n\\nwe can assume that the input stream is normally distributed in this case.\\nIf we maintain a   reservoir  of  100 items sampled with equal probability stored in a array then we can estimate the median of the the input data with highest confidence  for large input data distribution of unknown size .\\n\\n**Alternate Interesting Solution**: By using median filter [stackoverflow](https://stackoverflow.com/a/15150968/8336491)\\n\\n  \\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Wanted to complete it quickly by using Sorting instead of two heaps and got TLE haha"
                    },
                    {
                        "username": "54564269",
                        "content": "Got it done pretty soon using 2 heaps in a real interview. However, in the follow-up, I'm asked how to improve it and make sure the method is thread-safe if the two heaps are shared."
                    },
                    {
                        "username": "adit2005",
                        "content": "can u pls share the answer for follow-up question asked ??"
                    },
                    {
                        "username": "animish01",
                        "content": "do you know it now? can you share?"
                    },
                    {
                        "username": "bayernkang",
                        "content": "Should I implement the Heap data structure myself ? (that\\'s a lot of code to memorize and write).\\n\\nDo anyone encounter a quesiton in a real interview that have to use heap but you are using Javascript?"
                    },
                    {
                        "username": "suziray",
                        "content": "I saw there is some solution for using BST in C++, and I heard some hint for using Counting Sort or maintaining the median and the numbers next to it. Is there a way to do these in Java?\\n\\nAdditionally,  another version is to return the median of recent k numbers added, how could this be achieved..."
                    },
                    {
                        "username": "jsnoob",
                        "content": "Follow up:\\n\\n1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?"
                    }
                ]
            },
            {
                "id": 1567590,
                "content": [
                    {
                        "username": "nupt_wang",
                        "content": "***1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nWe can maintain an integer array of length 100 to store the count of each number along with a total count.  Then, we can iterate over the array to find the middle value to get our median.\\n\\nTime and space complexity would be O(100) = O(1).\\n\\n***2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nIn this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100]."
                    },
                    {
                        "username": "kevintancs",
                        "content": "[@psing9968](/psing9968) iterating over an array with fixed size of 100 is O(100) = O(1)"
                    },
                    {
                        "username": "A5HU705H",
                        "content": "[@murlinwang](/murlinwang) but it guarantees a 99% hits on 0, 100"
                    },
                    {
                        "username": "psing9968",
                        "content": "If we are iterating over the array, how can it be O(1) ?"
                    },
                    {
                        "username": "hombreingwar",
                        "content": "2. why not just ignore values outside [0, 100]. They won\\'t impact the median since they are anomalies median calculation is designed for to ignore.  "
                    },
                    {
                        "username": "murlinwang",
                        "content": "[@Max7cd](/Max7cd) I think there could be cases where integers in the data stream are all out of the range of 0-100. In that case, if we want the median, the count of those integers would not help. I am also learning so correct me if I am wrong."
                    },
                    {
                        "username": "c0s",
                        "content": "[@Max7cd](/Max7cd) it would not let to call findMedian() until this requirement is met on already streamed values"
                    },
                    {
                        "username": "Max7cd",
                        "content": "> 2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n> \\n> In this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100].\\n\\nI am not 100% sure, but couldn\\'t we just keep a count of how many numbers are above 100 and how many numbers are below 0, since these numbers could never get to be the median and are therefore not important to keep?\\nThis would keep the solution in O(1) time and memory."
                    },
                    {
                        "username": "mahapatro",
                        "content": "Really great"
                    },
                    {
                        "username": "Future6",
                        "content": "[\"MedianFinder\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"]\\n[[],[6],[],[10],[],[2],[],[6],[],[5],[],[0],[],[6],[],[3],[],[1],[],[0],[],[0],[]]\\n\\nso the list is {6, 10, 2, 6, 5, 0, 6, 3, 1, 0, 0}\\nand the MedianFinder result should be: 6, 8, 10, 6, 2, 4, 6, 5.5, 5, 2.5, 0\\n\\nBut it offers answer as follows:\\n[null,null,6.00000,null,8.00000,null,**6.00000**,null,6.00000,null,**6.00000**,null,5.50000,null,6.00000,null,5.50000,null,5.00000,null,4.00000,null,3.00000]\\n\\nOr I misunderstand this quesiton"
                    },
                    {
                        "username": "rajputasif",
                        "content": "[@CrossBon3](/CrossBon3) Thanks for the reply... my data is already sorted in multiset strange!\\n\\n6 out:6\\n6 10 out:8\\n2 6 10 out:6\\n2 6 6 10 out:6\\n2 5 6 6 10 out:6\\n0 2 5 6 6 10 out:5 //5.5 expected\\n0 2 5 6 6 6 10 out:5 //6 expected\\n0 2 3 5 6 6 6 10 out:5 //5.5 expected\\n0 1 2 3 5 6 6 6 10 out:5\\n0 0 1 2 3 5 6 6 6 10 out:5\\n0 0 0 1 2 3 5 6 6 6 10 out:5"
                    },
                    {
                        "username": "adanaza89",
                        "content": "[@CrossBon3](/CrossBon3) Oh wow!! I missed this very important aspect of the question. I came here because I was sure I was right. Thanks for your answer"
                    },
                    {
                        "username": "CrossBon3",
                        "content": "median is performed on sorted array.\\nfor first 2 numbers you get correct cause they are already in sorted fashion so you got median as 6 and 8.\\nwhen 2 is added to the array, array need to be sorted(it looks [2,6,10]). thus median will be 6. "
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "**Important posts from discussions:**\\n- I was asked this question in an interview today. I told about the minHeap and maxHeap approach. The interviewer asked what if the data is very very large. How would you handle it? Any thoughts?! \\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/228442/Java-Solution-with-Tree-O(Log-N)-Insertion-and-Lookup-+-Explanation : Java Solution with Tree - O(Log N) Insertion and Lookup + Explanation\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/111698/Be-asked-for-a-multi-thread-and-thread-safe-solution-in-a-real-interview. : Be asked for a multi-thread and thread-safe solution in a real interview\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/652498/Good-for-interviews:-Python-general-sort-greater-insertion-sort-greater-two-heaps-greater-follow-ups : Good for interviews: Python general sort -> insertion sort -> two heaps -> follow-ups\\n\\n**Observations:**\\n- The change in Median: when a new element comes, the new median will be either 1 unit left or 1 unit right to the prvious median. We use 2 pointers to implement this along with taking care of average of middle numbers for even size.\\n- Median means sorted data and middle element(s). Sorted data means \\'array/collection + manual sort\\' or self balanced bst or miltuple heaps or monotonic stack or deque (which isn\\'t useful for this problem since monotonic stack/deque will involve removal exisiting elements).  \\n- Heap utilities:\\n\\t- using a heap for a data set helps to get the smallest/largest element fastly\\n\\t- using 2 heaps: if we divide the random data (non sorted data) into 2 heaps (1 min and other max) such that the first half of sorted data (data if it had been sorted) is in max heap and second half of sorted data (data if it had been sorted) is in min heap, we could easily get the middle element of the sorted data (data if it had been sorted). VISUALIZE!!!"
                    },
                    {
                        "username": "prYsm",
                        "content": "If there is a condition that the calls to findMedian() are less, we can lazily compute the median.\n\n1. Have two lists: Unsorted list, sorted list.\n2. If query == Addelement():\n    2.1 Add element to unsorted list.\n3. If query == FindMedian():\n    3.1 sort(unsorted list) call it X.\n    3.2 Merge(x, sortedlist) and assign it back to sortedlist.\n    3.3 Use indexes to find middle elements from sorted list.\n\nYes, 3 in the worst case would take O(nlogn). But, we are not computing it every time we get a query. This way we only spend cycles, which is especially important if we have large amount of data, when we want to compute median."
                    },
                    {
                        "username": "avminus",
                        "content": "Hey your second link is not opening, can you please share something regarding this thread safety discussion can\\'t seem to find it anywhere.\\n"
                    },
                    {
                        "username": "chao4",
                        "content": "In real world streaming application. The data amount will be huge so it is impossible to hold all the data in the stream into memory.\\n\\nI think it is a good open-end question to ask. What if the memory is not allowed to hold all the data from the beginning. Some data needs to go to hard drive. How will we optmize that."
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "what would be the solution in that case? i\\'m guessing some amount of memoization would be needed?"
                    },
                    {
                        "username": "prakashsellathurai",
                        "content": "`1. If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\nSince the input range is bounded we can use counter array to calculate median, where count[i] represents the number of times integer data occur in the stream in O(1) space and time\\n**refer this problem**: [statistics-from-a-large-sample](https://leetcode.com/problems/statistics-from-a-large-sample/description/)\\n\\n`2. If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\n\\nIF 99% of all integers from the stream are in the range [0,100] then considering empirical rule \\n\\n\"99.7% of data observed following a normal distribution lies within 3 standard deviations of the mean\"\\n\\nwe can assume that the input stream is normally distributed in this case.\\nIf we maintain a   reservoir  of  100 items sampled with equal probability stored in a array then we can estimate the median of the the input data with highest confidence  for large input data distribution of unknown size .\\n\\n**Alternate Interesting Solution**: By using median filter [stackoverflow](https://stackoverflow.com/a/15150968/8336491)\\n\\n  \\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Wanted to complete it quickly by using Sorting instead of two heaps and got TLE haha"
                    },
                    {
                        "username": "54564269",
                        "content": "Got it done pretty soon using 2 heaps in a real interview. However, in the follow-up, I'm asked how to improve it and make sure the method is thread-safe if the two heaps are shared."
                    },
                    {
                        "username": "adit2005",
                        "content": "can u pls share the answer for follow-up question asked ??"
                    },
                    {
                        "username": "animish01",
                        "content": "do you know it now? can you share?"
                    },
                    {
                        "username": "bayernkang",
                        "content": "Should I implement the Heap data structure myself ? (that\\'s a lot of code to memorize and write).\\n\\nDo anyone encounter a quesiton in a real interview that have to use heap but you are using Javascript?"
                    },
                    {
                        "username": "suziray",
                        "content": "I saw there is some solution for using BST in C++, and I heard some hint for using Counting Sort or maintaining the median and the numbers next to it. Is there a way to do these in Java?\\n\\nAdditionally,  another version is to return the median of recent k numbers added, how could this be achieved..."
                    },
                    {
                        "username": "jsnoob",
                        "content": "Follow up:\\n\\n1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?"
                    }
                ]
            },
            {
                "id": 1566833,
                "content": [
                    {
                        "username": "nupt_wang",
                        "content": "***1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nWe can maintain an integer array of length 100 to store the count of each number along with a total count.  Then, we can iterate over the array to find the middle value to get our median.\\n\\nTime and space complexity would be O(100) = O(1).\\n\\n***2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nIn this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100]."
                    },
                    {
                        "username": "kevintancs",
                        "content": "[@psing9968](/psing9968) iterating over an array with fixed size of 100 is O(100) = O(1)"
                    },
                    {
                        "username": "A5HU705H",
                        "content": "[@murlinwang](/murlinwang) but it guarantees a 99% hits on 0, 100"
                    },
                    {
                        "username": "psing9968",
                        "content": "If we are iterating over the array, how can it be O(1) ?"
                    },
                    {
                        "username": "hombreingwar",
                        "content": "2. why not just ignore values outside [0, 100]. They won\\'t impact the median since they are anomalies median calculation is designed for to ignore.  "
                    },
                    {
                        "username": "murlinwang",
                        "content": "[@Max7cd](/Max7cd) I think there could be cases where integers in the data stream are all out of the range of 0-100. In that case, if we want the median, the count of those integers would not help. I am also learning so correct me if I am wrong."
                    },
                    {
                        "username": "c0s",
                        "content": "[@Max7cd](/Max7cd) it would not let to call findMedian() until this requirement is met on already streamed values"
                    },
                    {
                        "username": "Max7cd",
                        "content": "> 2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n> \\n> In this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100].\\n\\nI am not 100% sure, but couldn\\'t we just keep a count of how many numbers are above 100 and how many numbers are below 0, since these numbers could never get to be the median and are therefore not important to keep?\\nThis would keep the solution in O(1) time and memory."
                    },
                    {
                        "username": "mahapatro",
                        "content": "Really great"
                    },
                    {
                        "username": "Future6",
                        "content": "[\"MedianFinder\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"]\\n[[],[6],[],[10],[],[2],[],[6],[],[5],[],[0],[],[6],[],[3],[],[1],[],[0],[],[0],[]]\\n\\nso the list is {6, 10, 2, 6, 5, 0, 6, 3, 1, 0, 0}\\nand the MedianFinder result should be: 6, 8, 10, 6, 2, 4, 6, 5.5, 5, 2.5, 0\\n\\nBut it offers answer as follows:\\n[null,null,6.00000,null,8.00000,null,**6.00000**,null,6.00000,null,**6.00000**,null,5.50000,null,6.00000,null,5.50000,null,5.00000,null,4.00000,null,3.00000]\\n\\nOr I misunderstand this quesiton"
                    },
                    {
                        "username": "rajputasif",
                        "content": "[@CrossBon3](/CrossBon3) Thanks for the reply... my data is already sorted in multiset strange!\\n\\n6 out:6\\n6 10 out:8\\n2 6 10 out:6\\n2 6 6 10 out:6\\n2 5 6 6 10 out:6\\n0 2 5 6 6 10 out:5 //5.5 expected\\n0 2 5 6 6 6 10 out:5 //6 expected\\n0 2 3 5 6 6 6 10 out:5 //5.5 expected\\n0 1 2 3 5 6 6 6 10 out:5\\n0 0 1 2 3 5 6 6 6 10 out:5\\n0 0 0 1 2 3 5 6 6 6 10 out:5"
                    },
                    {
                        "username": "adanaza89",
                        "content": "[@CrossBon3](/CrossBon3) Oh wow!! I missed this very important aspect of the question. I came here because I was sure I was right. Thanks for your answer"
                    },
                    {
                        "username": "CrossBon3",
                        "content": "median is performed on sorted array.\\nfor first 2 numbers you get correct cause they are already in sorted fashion so you got median as 6 and 8.\\nwhen 2 is added to the array, array need to be sorted(it looks [2,6,10]). thus median will be 6. "
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "**Important posts from discussions:**\\n- I was asked this question in an interview today. I told about the minHeap and maxHeap approach. The interviewer asked what if the data is very very large. How would you handle it? Any thoughts?! \\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/228442/Java-Solution-with-Tree-O(Log-N)-Insertion-and-Lookup-+-Explanation : Java Solution with Tree - O(Log N) Insertion and Lookup + Explanation\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/111698/Be-asked-for-a-multi-thread-and-thread-safe-solution-in-a-real-interview. : Be asked for a multi-thread and thread-safe solution in a real interview\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/652498/Good-for-interviews:-Python-general-sort-greater-insertion-sort-greater-two-heaps-greater-follow-ups : Good for interviews: Python general sort -> insertion sort -> two heaps -> follow-ups\\n\\n**Observations:**\\n- The change in Median: when a new element comes, the new median will be either 1 unit left or 1 unit right to the prvious median. We use 2 pointers to implement this along with taking care of average of middle numbers for even size.\\n- Median means sorted data and middle element(s). Sorted data means \\'array/collection + manual sort\\' or self balanced bst or miltuple heaps or monotonic stack or deque (which isn\\'t useful for this problem since monotonic stack/deque will involve removal exisiting elements).  \\n- Heap utilities:\\n\\t- using a heap for a data set helps to get the smallest/largest element fastly\\n\\t- using 2 heaps: if we divide the random data (non sorted data) into 2 heaps (1 min and other max) such that the first half of sorted data (data if it had been sorted) is in max heap and second half of sorted data (data if it had been sorted) is in min heap, we could easily get the middle element of the sorted data (data if it had been sorted). VISUALIZE!!!"
                    },
                    {
                        "username": "prYsm",
                        "content": "If there is a condition that the calls to findMedian() are less, we can lazily compute the median.\n\n1. Have two lists: Unsorted list, sorted list.\n2. If query == Addelement():\n    2.1 Add element to unsorted list.\n3. If query == FindMedian():\n    3.1 sort(unsorted list) call it X.\n    3.2 Merge(x, sortedlist) and assign it back to sortedlist.\n    3.3 Use indexes to find middle elements from sorted list.\n\nYes, 3 in the worst case would take O(nlogn). But, we are not computing it every time we get a query. This way we only spend cycles, which is especially important if we have large amount of data, when we want to compute median."
                    },
                    {
                        "username": "avminus",
                        "content": "Hey your second link is not opening, can you please share something regarding this thread safety discussion can\\'t seem to find it anywhere.\\n"
                    },
                    {
                        "username": "chao4",
                        "content": "In real world streaming application. The data amount will be huge so it is impossible to hold all the data in the stream into memory.\\n\\nI think it is a good open-end question to ask. What if the memory is not allowed to hold all the data from the beginning. Some data needs to go to hard drive. How will we optmize that."
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "what would be the solution in that case? i\\'m guessing some amount of memoization would be needed?"
                    },
                    {
                        "username": "prakashsellathurai",
                        "content": "`1. If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\nSince the input range is bounded we can use counter array to calculate median, where count[i] represents the number of times integer data occur in the stream in O(1) space and time\\n**refer this problem**: [statistics-from-a-large-sample](https://leetcode.com/problems/statistics-from-a-large-sample/description/)\\n\\n`2. If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\n\\nIF 99% of all integers from the stream are in the range [0,100] then considering empirical rule \\n\\n\"99.7% of data observed following a normal distribution lies within 3 standard deviations of the mean\"\\n\\nwe can assume that the input stream is normally distributed in this case.\\nIf we maintain a   reservoir  of  100 items sampled with equal probability stored in a array then we can estimate the median of the the input data with highest confidence  for large input data distribution of unknown size .\\n\\n**Alternate Interesting Solution**: By using median filter [stackoverflow](https://stackoverflow.com/a/15150968/8336491)\\n\\n  \\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Wanted to complete it quickly by using Sorting instead of two heaps and got TLE haha"
                    },
                    {
                        "username": "54564269",
                        "content": "Got it done pretty soon using 2 heaps in a real interview. However, in the follow-up, I'm asked how to improve it and make sure the method is thread-safe if the two heaps are shared."
                    },
                    {
                        "username": "adit2005",
                        "content": "can u pls share the answer for follow-up question asked ??"
                    },
                    {
                        "username": "animish01",
                        "content": "do you know it now? can you share?"
                    },
                    {
                        "username": "bayernkang",
                        "content": "Should I implement the Heap data structure myself ? (that\\'s a lot of code to memorize and write).\\n\\nDo anyone encounter a quesiton in a real interview that have to use heap but you are using Javascript?"
                    },
                    {
                        "username": "suziray",
                        "content": "I saw there is some solution for using BST in C++, and I heard some hint for using Counting Sort or maintaining the median and the numbers next to it. Is there a way to do these in Java?\\n\\nAdditionally,  another version is to return the median of recent k numbers added, how could this be achieved..."
                    },
                    {
                        "username": "jsnoob",
                        "content": "Follow up:\\n\\n1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?"
                    }
                ]
            },
            {
                "id": 1567744,
                "content": [
                    {
                        "username": "nupt_wang",
                        "content": "***1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nWe can maintain an integer array of length 100 to store the count of each number along with a total count.  Then, we can iterate over the array to find the middle value to get our median.\\n\\nTime and space complexity would be O(100) = O(1).\\n\\n***2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nIn this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100]."
                    },
                    {
                        "username": "kevintancs",
                        "content": "[@psing9968](/psing9968) iterating over an array with fixed size of 100 is O(100) = O(1)"
                    },
                    {
                        "username": "A5HU705H",
                        "content": "[@murlinwang](/murlinwang) but it guarantees a 99% hits on 0, 100"
                    },
                    {
                        "username": "psing9968",
                        "content": "If we are iterating over the array, how can it be O(1) ?"
                    },
                    {
                        "username": "hombreingwar",
                        "content": "2. why not just ignore values outside [0, 100]. They won\\'t impact the median since they are anomalies median calculation is designed for to ignore.  "
                    },
                    {
                        "username": "murlinwang",
                        "content": "[@Max7cd](/Max7cd) I think there could be cases where integers in the data stream are all out of the range of 0-100. In that case, if we want the median, the count of those integers would not help. I am also learning so correct me if I am wrong."
                    },
                    {
                        "username": "c0s",
                        "content": "[@Max7cd](/Max7cd) it would not let to call findMedian() until this requirement is met on already streamed values"
                    },
                    {
                        "username": "Max7cd",
                        "content": "> 2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n> \\n> In this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100].\\n\\nI am not 100% sure, but couldn\\'t we just keep a count of how many numbers are above 100 and how many numbers are below 0, since these numbers could never get to be the median and are therefore not important to keep?\\nThis would keep the solution in O(1) time and memory."
                    },
                    {
                        "username": "mahapatro",
                        "content": "Really great"
                    },
                    {
                        "username": "Future6",
                        "content": "[\"MedianFinder\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"]\\n[[],[6],[],[10],[],[2],[],[6],[],[5],[],[0],[],[6],[],[3],[],[1],[],[0],[],[0],[]]\\n\\nso the list is {6, 10, 2, 6, 5, 0, 6, 3, 1, 0, 0}\\nand the MedianFinder result should be: 6, 8, 10, 6, 2, 4, 6, 5.5, 5, 2.5, 0\\n\\nBut it offers answer as follows:\\n[null,null,6.00000,null,8.00000,null,**6.00000**,null,6.00000,null,**6.00000**,null,5.50000,null,6.00000,null,5.50000,null,5.00000,null,4.00000,null,3.00000]\\n\\nOr I misunderstand this quesiton"
                    },
                    {
                        "username": "rajputasif",
                        "content": "[@CrossBon3](/CrossBon3) Thanks for the reply... my data is already sorted in multiset strange!\\n\\n6 out:6\\n6 10 out:8\\n2 6 10 out:6\\n2 6 6 10 out:6\\n2 5 6 6 10 out:6\\n0 2 5 6 6 10 out:5 //5.5 expected\\n0 2 5 6 6 6 10 out:5 //6 expected\\n0 2 3 5 6 6 6 10 out:5 //5.5 expected\\n0 1 2 3 5 6 6 6 10 out:5\\n0 0 1 2 3 5 6 6 6 10 out:5\\n0 0 0 1 2 3 5 6 6 6 10 out:5"
                    },
                    {
                        "username": "adanaza89",
                        "content": "[@CrossBon3](/CrossBon3) Oh wow!! I missed this very important aspect of the question. I came here because I was sure I was right. Thanks for your answer"
                    },
                    {
                        "username": "CrossBon3",
                        "content": "median is performed on sorted array.\\nfor first 2 numbers you get correct cause they are already in sorted fashion so you got median as 6 and 8.\\nwhen 2 is added to the array, array need to be sorted(it looks [2,6,10]). thus median will be 6. "
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "**Important posts from discussions:**\\n- I was asked this question in an interview today. I told about the minHeap and maxHeap approach. The interviewer asked what if the data is very very large. How would you handle it? Any thoughts?! \\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/228442/Java-Solution-with-Tree-O(Log-N)-Insertion-and-Lookup-+-Explanation : Java Solution with Tree - O(Log N) Insertion and Lookup + Explanation\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/111698/Be-asked-for-a-multi-thread-and-thread-safe-solution-in-a-real-interview. : Be asked for a multi-thread and thread-safe solution in a real interview\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/652498/Good-for-interviews:-Python-general-sort-greater-insertion-sort-greater-two-heaps-greater-follow-ups : Good for interviews: Python general sort -> insertion sort -> two heaps -> follow-ups\\n\\n**Observations:**\\n- The change in Median: when a new element comes, the new median will be either 1 unit left or 1 unit right to the prvious median. We use 2 pointers to implement this along with taking care of average of middle numbers for even size.\\n- Median means sorted data and middle element(s). Sorted data means \\'array/collection + manual sort\\' or self balanced bst or miltuple heaps or monotonic stack or deque (which isn\\'t useful for this problem since monotonic stack/deque will involve removal exisiting elements).  \\n- Heap utilities:\\n\\t- using a heap for a data set helps to get the smallest/largest element fastly\\n\\t- using 2 heaps: if we divide the random data (non sorted data) into 2 heaps (1 min and other max) such that the first half of sorted data (data if it had been sorted) is in max heap and second half of sorted data (data if it had been sorted) is in min heap, we could easily get the middle element of the sorted data (data if it had been sorted). VISUALIZE!!!"
                    },
                    {
                        "username": "prYsm",
                        "content": "If there is a condition that the calls to findMedian() are less, we can lazily compute the median.\n\n1. Have two lists: Unsorted list, sorted list.\n2. If query == Addelement():\n    2.1 Add element to unsorted list.\n3. If query == FindMedian():\n    3.1 sort(unsorted list) call it X.\n    3.2 Merge(x, sortedlist) and assign it back to sortedlist.\n    3.3 Use indexes to find middle elements from sorted list.\n\nYes, 3 in the worst case would take O(nlogn). But, we are not computing it every time we get a query. This way we only spend cycles, which is especially important if we have large amount of data, when we want to compute median."
                    },
                    {
                        "username": "avminus",
                        "content": "Hey your second link is not opening, can you please share something regarding this thread safety discussion can\\'t seem to find it anywhere.\\n"
                    },
                    {
                        "username": "chao4",
                        "content": "In real world streaming application. The data amount will be huge so it is impossible to hold all the data in the stream into memory.\\n\\nI think it is a good open-end question to ask. What if the memory is not allowed to hold all the data from the beginning. Some data needs to go to hard drive. How will we optmize that."
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "what would be the solution in that case? i\\'m guessing some amount of memoization would be needed?"
                    },
                    {
                        "username": "prakashsellathurai",
                        "content": "`1. If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\nSince the input range is bounded we can use counter array to calculate median, where count[i] represents the number of times integer data occur in the stream in O(1) space and time\\n**refer this problem**: [statistics-from-a-large-sample](https://leetcode.com/problems/statistics-from-a-large-sample/description/)\\n\\n`2. If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\n\\nIF 99% of all integers from the stream are in the range [0,100] then considering empirical rule \\n\\n\"99.7% of data observed following a normal distribution lies within 3 standard deviations of the mean\"\\n\\nwe can assume that the input stream is normally distributed in this case.\\nIf we maintain a   reservoir  of  100 items sampled with equal probability stored in a array then we can estimate the median of the the input data with highest confidence  for large input data distribution of unknown size .\\n\\n**Alternate Interesting Solution**: By using median filter [stackoverflow](https://stackoverflow.com/a/15150968/8336491)\\n\\n  \\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Wanted to complete it quickly by using Sorting instead of two heaps and got TLE haha"
                    },
                    {
                        "username": "54564269",
                        "content": "Got it done pretty soon using 2 heaps in a real interview. However, in the follow-up, I'm asked how to improve it and make sure the method is thread-safe if the two heaps are shared."
                    },
                    {
                        "username": "adit2005",
                        "content": "can u pls share the answer for follow-up question asked ??"
                    },
                    {
                        "username": "animish01",
                        "content": "do you know it now? can you share?"
                    },
                    {
                        "username": "bayernkang",
                        "content": "Should I implement the Heap data structure myself ? (that\\'s a lot of code to memorize and write).\\n\\nDo anyone encounter a quesiton in a real interview that have to use heap but you are using Javascript?"
                    },
                    {
                        "username": "suziray",
                        "content": "I saw there is some solution for using BST in C++, and I heard some hint for using Counting Sort or maintaining the median and the numbers next to it. Is there a way to do these in Java?\\n\\nAdditionally,  another version is to return the median of recent k numbers added, how could this be achieved..."
                    },
                    {
                        "username": "jsnoob",
                        "content": "Follow up:\\n\\n1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?"
                    }
                ]
            },
            {
                "id": 1851791,
                "content": [
                    {
                        "username": "nupt_wang",
                        "content": "***1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nWe can maintain an integer array of length 100 to store the count of each number along with a total count.  Then, we can iterate over the array to find the middle value to get our median.\\n\\nTime and space complexity would be O(100) = O(1).\\n\\n***2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nIn this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100]."
                    },
                    {
                        "username": "kevintancs",
                        "content": "[@psing9968](/psing9968) iterating over an array with fixed size of 100 is O(100) = O(1)"
                    },
                    {
                        "username": "A5HU705H",
                        "content": "[@murlinwang](/murlinwang) but it guarantees a 99% hits on 0, 100"
                    },
                    {
                        "username": "psing9968",
                        "content": "If we are iterating over the array, how can it be O(1) ?"
                    },
                    {
                        "username": "hombreingwar",
                        "content": "2. why not just ignore values outside [0, 100]. They won\\'t impact the median since they are anomalies median calculation is designed for to ignore.  "
                    },
                    {
                        "username": "murlinwang",
                        "content": "[@Max7cd](/Max7cd) I think there could be cases where integers in the data stream are all out of the range of 0-100. In that case, if we want the median, the count of those integers would not help. I am also learning so correct me if I am wrong."
                    },
                    {
                        "username": "c0s",
                        "content": "[@Max7cd](/Max7cd) it would not let to call findMedian() until this requirement is met on already streamed values"
                    },
                    {
                        "username": "Max7cd",
                        "content": "> 2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n> \\n> In this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100].\\n\\nI am not 100% sure, but couldn\\'t we just keep a count of how many numbers are above 100 and how many numbers are below 0, since these numbers could never get to be the median and are therefore not important to keep?\\nThis would keep the solution in O(1) time and memory."
                    },
                    {
                        "username": "mahapatro",
                        "content": "Really great"
                    },
                    {
                        "username": "Future6",
                        "content": "[\"MedianFinder\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"]\\n[[],[6],[],[10],[],[2],[],[6],[],[5],[],[0],[],[6],[],[3],[],[1],[],[0],[],[0],[]]\\n\\nso the list is {6, 10, 2, 6, 5, 0, 6, 3, 1, 0, 0}\\nand the MedianFinder result should be: 6, 8, 10, 6, 2, 4, 6, 5.5, 5, 2.5, 0\\n\\nBut it offers answer as follows:\\n[null,null,6.00000,null,8.00000,null,**6.00000**,null,6.00000,null,**6.00000**,null,5.50000,null,6.00000,null,5.50000,null,5.00000,null,4.00000,null,3.00000]\\n\\nOr I misunderstand this quesiton"
                    },
                    {
                        "username": "rajputasif",
                        "content": "[@CrossBon3](/CrossBon3) Thanks for the reply... my data is already sorted in multiset strange!\\n\\n6 out:6\\n6 10 out:8\\n2 6 10 out:6\\n2 6 6 10 out:6\\n2 5 6 6 10 out:6\\n0 2 5 6 6 10 out:5 //5.5 expected\\n0 2 5 6 6 6 10 out:5 //6 expected\\n0 2 3 5 6 6 6 10 out:5 //5.5 expected\\n0 1 2 3 5 6 6 6 10 out:5\\n0 0 1 2 3 5 6 6 6 10 out:5\\n0 0 0 1 2 3 5 6 6 6 10 out:5"
                    },
                    {
                        "username": "adanaza89",
                        "content": "[@CrossBon3](/CrossBon3) Oh wow!! I missed this very important aspect of the question. I came here because I was sure I was right. Thanks for your answer"
                    },
                    {
                        "username": "CrossBon3",
                        "content": "median is performed on sorted array.\\nfor first 2 numbers you get correct cause they are already in sorted fashion so you got median as 6 and 8.\\nwhen 2 is added to the array, array need to be sorted(it looks [2,6,10]). thus median will be 6. "
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "**Important posts from discussions:**\\n- I was asked this question in an interview today. I told about the minHeap and maxHeap approach. The interviewer asked what if the data is very very large. How would you handle it? Any thoughts?! \\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/228442/Java-Solution-with-Tree-O(Log-N)-Insertion-and-Lookup-+-Explanation : Java Solution with Tree - O(Log N) Insertion and Lookup + Explanation\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/111698/Be-asked-for-a-multi-thread-and-thread-safe-solution-in-a-real-interview. : Be asked for a multi-thread and thread-safe solution in a real interview\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/652498/Good-for-interviews:-Python-general-sort-greater-insertion-sort-greater-two-heaps-greater-follow-ups : Good for interviews: Python general sort -> insertion sort -> two heaps -> follow-ups\\n\\n**Observations:**\\n- The change in Median: when a new element comes, the new median will be either 1 unit left or 1 unit right to the prvious median. We use 2 pointers to implement this along with taking care of average of middle numbers for even size.\\n- Median means sorted data and middle element(s). Sorted data means \\'array/collection + manual sort\\' or self balanced bst or miltuple heaps or monotonic stack or deque (which isn\\'t useful for this problem since monotonic stack/deque will involve removal exisiting elements).  \\n- Heap utilities:\\n\\t- using a heap for a data set helps to get the smallest/largest element fastly\\n\\t- using 2 heaps: if we divide the random data (non sorted data) into 2 heaps (1 min and other max) such that the first half of sorted data (data if it had been sorted) is in max heap and second half of sorted data (data if it had been sorted) is in min heap, we could easily get the middle element of the sorted data (data if it had been sorted). VISUALIZE!!!"
                    },
                    {
                        "username": "prYsm",
                        "content": "If there is a condition that the calls to findMedian() are less, we can lazily compute the median.\n\n1. Have two lists: Unsorted list, sorted list.\n2. If query == Addelement():\n    2.1 Add element to unsorted list.\n3. If query == FindMedian():\n    3.1 sort(unsorted list) call it X.\n    3.2 Merge(x, sortedlist) and assign it back to sortedlist.\n    3.3 Use indexes to find middle elements from sorted list.\n\nYes, 3 in the worst case would take O(nlogn). But, we are not computing it every time we get a query. This way we only spend cycles, which is especially important if we have large amount of data, when we want to compute median."
                    },
                    {
                        "username": "avminus",
                        "content": "Hey your second link is not opening, can you please share something regarding this thread safety discussion can\\'t seem to find it anywhere.\\n"
                    },
                    {
                        "username": "chao4",
                        "content": "In real world streaming application. The data amount will be huge so it is impossible to hold all the data in the stream into memory.\\n\\nI think it is a good open-end question to ask. What if the memory is not allowed to hold all the data from the beginning. Some data needs to go to hard drive. How will we optmize that."
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "what would be the solution in that case? i\\'m guessing some amount of memoization would be needed?"
                    },
                    {
                        "username": "prakashsellathurai",
                        "content": "`1. If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\nSince the input range is bounded we can use counter array to calculate median, where count[i] represents the number of times integer data occur in the stream in O(1) space and time\\n**refer this problem**: [statistics-from-a-large-sample](https://leetcode.com/problems/statistics-from-a-large-sample/description/)\\n\\n`2. If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\n\\nIF 99% of all integers from the stream are in the range [0,100] then considering empirical rule \\n\\n\"99.7% of data observed following a normal distribution lies within 3 standard deviations of the mean\"\\n\\nwe can assume that the input stream is normally distributed in this case.\\nIf we maintain a   reservoir  of  100 items sampled with equal probability stored in a array then we can estimate the median of the the input data with highest confidence  for large input data distribution of unknown size .\\n\\n**Alternate Interesting Solution**: By using median filter [stackoverflow](https://stackoverflow.com/a/15150968/8336491)\\n\\n  \\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Wanted to complete it quickly by using Sorting instead of two heaps and got TLE haha"
                    },
                    {
                        "username": "54564269",
                        "content": "Got it done pretty soon using 2 heaps in a real interview. However, in the follow-up, I'm asked how to improve it and make sure the method is thread-safe if the two heaps are shared."
                    },
                    {
                        "username": "adit2005",
                        "content": "can u pls share the answer for follow-up question asked ??"
                    },
                    {
                        "username": "animish01",
                        "content": "do you know it now? can you share?"
                    },
                    {
                        "username": "bayernkang",
                        "content": "Should I implement the Heap data structure myself ? (that\\'s a lot of code to memorize and write).\\n\\nDo anyone encounter a quesiton in a real interview that have to use heap but you are using Javascript?"
                    },
                    {
                        "username": "suziray",
                        "content": "I saw there is some solution for using BST in C++, and I heard some hint for using Counting Sort or maintaining the median and the numbers next to it. Is there a way to do these in Java?\\n\\nAdditionally,  another version is to return the median of recent k numbers added, how could this be achieved..."
                    },
                    {
                        "username": "jsnoob",
                        "content": "Follow up:\\n\\n1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?"
                    }
                ]
            },
            {
                "id": 1569168,
                "content": [
                    {
                        "username": "nupt_wang",
                        "content": "***1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nWe can maintain an integer array of length 100 to store the count of each number along with a total count.  Then, we can iterate over the array to find the middle value to get our median.\\n\\nTime and space complexity would be O(100) = O(1).\\n\\n***2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nIn this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100]."
                    },
                    {
                        "username": "kevintancs",
                        "content": "[@psing9968](/psing9968) iterating over an array with fixed size of 100 is O(100) = O(1)"
                    },
                    {
                        "username": "A5HU705H",
                        "content": "[@murlinwang](/murlinwang) but it guarantees a 99% hits on 0, 100"
                    },
                    {
                        "username": "psing9968",
                        "content": "If we are iterating over the array, how can it be O(1) ?"
                    },
                    {
                        "username": "hombreingwar",
                        "content": "2. why not just ignore values outside [0, 100]. They won\\'t impact the median since they are anomalies median calculation is designed for to ignore.  "
                    },
                    {
                        "username": "murlinwang",
                        "content": "[@Max7cd](/Max7cd) I think there could be cases where integers in the data stream are all out of the range of 0-100. In that case, if we want the median, the count of those integers would not help. I am also learning so correct me if I am wrong."
                    },
                    {
                        "username": "c0s",
                        "content": "[@Max7cd](/Max7cd) it would not let to call findMedian() until this requirement is met on already streamed values"
                    },
                    {
                        "username": "Max7cd",
                        "content": "> 2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n> \\n> In this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100].\\n\\nI am not 100% sure, but couldn\\'t we just keep a count of how many numbers are above 100 and how many numbers are below 0, since these numbers could never get to be the median and are therefore not important to keep?\\nThis would keep the solution in O(1) time and memory."
                    },
                    {
                        "username": "mahapatro",
                        "content": "Really great"
                    },
                    {
                        "username": "Future6",
                        "content": "[\"MedianFinder\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"]\\n[[],[6],[],[10],[],[2],[],[6],[],[5],[],[0],[],[6],[],[3],[],[1],[],[0],[],[0],[]]\\n\\nso the list is {6, 10, 2, 6, 5, 0, 6, 3, 1, 0, 0}\\nand the MedianFinder result should be: 6, 8, 10, 6, 2, 4, 6, 5.5, 5, 2.5, 0\\n\\nBut it offers answer as follows:\\n[null,null,6.00000,null,8.00000,null,**6.00000**,null,6.00000,null,**6.00000**,null,5.50000,null,6.00000,null,5.50000,null,5.00000,null,4.00000,null,3.00000]\\n\\nOr I misunderstand this quesiton"
                    },
                    {
                        "username": "rajputasif",
                        "content": "[@CrossBon3](/CrossBon3) Thanks for the reply... my data is already sorted in multiset strange!\\n\\n6 out:6\\n6 10 out:8\\n2 6 10 out:6\\n2 6 6 10 out:6\\n2 5 6 6 10 out:6\\n0 2 5 6 6 10 out:5 //5.5 expected\\n0 2 5 6 6 6 10 out:5 //6 expected\\n0 2 3 5 6 6 6 10 out:5 //5.5 expected\\n0 1 2 3 5 6 6 6 10 out:5\\n0 0 1 2 3 5 6 6 6 10 out:5\\n0 0 0 1 2 3 5 6 6 6 10 out:5"
                    },
                    {
                        "username": "adanaza89",
                        "content": "[@CrossBon3](/CrossBon3) Oh wow!! I missed this very important aspect of the question. I came here because I was sure I was right. Thanks for your answer"
                    },
                    {
                        "username": "CrossBon3",
                        "content": "median is performed on sorted array.\\nfor first 2 numbers you get correct cause they are already in sorted fashion so you got median as 6 and 8.\\nwhen 2 is added to the array, array need to be sorted(it looks [2,6,10]). thus median will be 6. "
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "**Important posts from discussions:**\\n- I was asked this question in an interview today. I told about the minHeap and maxHeap approach. The interviewer asked what if the data is very very large. How would you handle it? Any thoughts?! \\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/228442/Java-Solution-with-Tree-O(Log-N)-Insertion-and-Lookup-+-Explanation : Java Solution with Tree - O(Log N) Insertion and Lookup + Explanation\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/111698/Be-asked-for-a-multi-thread-and-thread-safe-solution-in-a-real-interview. : Be asked for a multi-thread and thread-safe solution in a real interview\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/652498/Good-for-interviews:-Python-general-sort-greater-insertion-sort-greater-two-heaps-greater-follow-ups : Good for interviews: Python general sort -> insertion sort -> two heaps -> follow-ups\\n\\n**Observations:**\\n- The change in Median: when a new element comes, the new median will be either 1 unit left or 1 unit right to the prvious median. We use 2 pointers to implement this along with taking care of average of middle numbers for even size.\\n- Median means sorted data and middle element(s). Sorted data means \\'array/collection + manual sort\\' or self balanced bst or miltuple heaps or monotonic stack or deque (which isn\\'t useful for this problem since monotonic stack/deque will involve removal exisiting elements).  \\n- Heap utilities:\\n\\t- using a heap for a data set helps to get the smallest/largest element fastly\\n\\t- using 2 heaps: if we divide the random data (non sorted data) into 2 heaps (1 min and other max) such that the first half of sorted data (data if it had been sorted) is in max heap and second half of sorted data (data if it had been sorted) is in min heap, we could easily get the middle element of the sorted data (data if it had been sorted). VISUALIZE!!!"
                    },
                    {
                        "username": "prYsm",
                        "content": "If there is a condition that the calls to findMedian() are less, we can lazily compute the median.\n\n1. Have two lists: Unsorted list, sorted list.\n2. If query == Addelement():\n    2.1 Add element to unsorted list.\n3. If query == FindMedian():\n    3.1 sort(unsorted list) call it X.\n    3.2 Merge(x, sortedlist) and assign it back to sortedlist.\n    3.3 Use indexes to find middle elements from sorted list.\n\nYes, 3 in the worst case would take O(nlogn). But, we are not computing it every time we get a query. This way we only spend cycles, which is especially important if we have large amount of data, when we want to compute median."
                    },
                    {
                        "username": "avminus",
                        "content": "Hey your second link is not opening, can you please share something regarding this thread safety discussion can\\'t seem to find it anywhere.\\n"
                    },
                    {
                        "username": "chao4",
                        "content": "In real world streaming application. The data amount will be huge so it is impossible to hold all the data in the stream into memory.\\n\\nI think it is a good open-end question to ask. What if the memory is not allowed to hold all the data from the beginning. Some data needs to go to hard drive. How will we optmize that."
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "what would be the solution in that case? i\\'m guessing some amount of memoization would be needed?"
                    },
                    {
                        "username": "prakashsellathurai",
                        "content": "`1. If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\nSince the input range is bounded we can use counter array to calculate median, where count[i] represents the number of times integer data occur in the stream in O(1) space and time\\n**refer this problem**: [statistics-from-a-large-sample](https://leetcode.com/problems/statistics-from-a-large-sample/description/)\\n\\n`2. If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\n\\nIF 99% of all integers from the stream are in the range [0,100] then considering empirical rule \\n\\n\"99.7% of data observed following a normal distribution lies within 3 standard deviations of the mean\"\\n\\nwe can assume that the input stream is normally distributed in this case.\\nIf we maintain a   reservoir  of  100 items sampled with equal probability stored in a array then we can estimate the median of the the input data with highest confidence  for large input data distribution of unknown size .\\n\\n**Alternate Interesting Solution**: By using median filter [stackoverflow](https://stackoverflow.com/a/15150968/8336491)\\n\\n  \\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Wanted to complete it quickly by using Sorting instead of two heaps and got TLE haha"
                    },
                    {
                        "username": "54564269",
                        "content": "Got it done pretty soon using 2 heaps in a real interview. However, in the follow-up, I'm asked how to improve it and make sure the method is thread-safe if the two heaps are shared."
                    },
                    {
                        "username": "adit2005",
                        "content": "can u pls share the answer for follow-up question asked ??"
                    },
                    {
                        "username": "animish01",
                        "content": "do you know it now? can you share?"
                    },
                    {
                        "username": "bayernkang",
                        "content": "Should I implement the Heap data structure myself ? (that\\'s a lot of code to memorize and write).\\n\\nDo anyone encounter a quesiton in a real interview that have to use heap but you are using Javascript?"
                    },
                    {
                        "username": "suziray",
                        "content": "I saw there is some solution for using BST in C++, and I heard some hint for using Counting Sort or maintaining the median and the numbers next to it. Is there a way to do these in Java?\\n\\nAdditionally,  another version is to return the median of recent k numbers added, how could this be achieved..."
                    },
                    {
                        "username": "jsnoob",
                        "content": "Follow up:\\n\\n1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?"
                    }
                ]
            },
            {
                "id": 1568410,
                "content": [
                    {
                        "username": "nupt_wang",
                        "content": "***1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nWe can maintain an integer array of length 100 to store the count of each number along with a total count.  Then, we can iterate over the array to find the middle value to get our median.\\n\\nTime and space complexity would be O(100) = O(1).\\n\\n***2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nIn this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100]."
                    },
                    {
                        "username": "kevintancs",
                        "content": "[@psing9968](/psing9968) iterating over an array with fixed size of 100 is O(100) = O(1)"
                    },
                    {
                        "username": "A5HU705H",
                        "content": "[@murlinwang](/murlinwang) but it guarantees a 99% hits on 0, 100"
                    },
                    {
                        "username": "psing9968",
                        "content": "If we are iterating over the array, how can it be O(1) ?"
                    },
                    {
                        "username": "hombreingwar",
                        "content": "2. why not just ignore values outside [0, 100]. They won\\'t impact the median since they are anomalies median calculation is designed for to ignore.  "
                    },
                    {
                        "username": "murlinwang",
                        "content": "[@Max7cd](/Max7cd) I think there could be cases where integers in the data stream are all out of the range of 0-100. In that case, if we want the median, the count of those integers would not help. I am also learning so correct me if I am wrong."
                    },
                    {
                        "username": "c0s",
                        "content": "[@Max7cd](/Max7cd) it would not let to call findMedian() until this requirement is met on already streamed values"
                    },
                    {
                        "username": "Max7cd",
                        "content": "> 2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n> \\n> In this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100].\\n\\nI am not 100% sure, but couldn\\'t we just keep a count of how many numbers are above 100 and how many numbers are below 0, since these numbers could never get to be the median and are therefore not important to keep?\\nThis would keep the solution in O(1) time and memory."
                    },
                    {
                        "username": "mahapatro",
                        "content": "Really great"
                    },
                    {
                        "username": "Future6",
                        "content": "[\"MedianFinder\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"]\\n[[],[6],[],[10],[],[2],[],[6],[],[5],[],[0],[],[6],[],[3],[],[1],[],[0],[],[0],[]]\\n\\nso the list is {6, 10, 2, 6, 5, 0, 6, 3, 1, 0, 0}\\nand the MedianFinder result should be: 6, 8, 10, 6, 2, 4, 6, 5.5, 5, 2.5, 0\\n\\nBut it offers answer as follows:\\n[null,null,6.00000,null,8.00000,null,**6.00000**,null,6.00000,null,**6.00000**,null,5.50000,null,6.00000,null,5.50000,null,5.00000,null,4.00000,null,3.00000]\\n\\nOr I misunderstand this quesiton"
                    },
                    {
                        "username": "rajputasif",
                        "content": "[@CrossBon3](/CrossBon3) Thanks for the reply... my data is already sorted in multiset strange!\\n\\n6 out:6\\n6 10 out:8\\n2 6 10 out:6\\n2 6 6 10 out:6\\n2 5 6 6 10 out:6\\n0 2 5 6 6 10 out:5 //5.5 expected\\n0 2 5 6 6 6 10 out:5 //6 expected\\n0 2 3 5 6 6 6 10 out:5 //5.5 expected\\n0 1 2 3 5 6 6 6 10 out:5\\n0 0 1 2 3 5 6 6 6 10 out:5\\n0 0 0 1 2 3 5 6 6 6 10 out:5"
                    },
                    {
                        "username": "adanaza89",
                        "content": "[@CrossBon3](/CrossBon3) Oh wow!! I missed this very important aspect of the question. I came here because I was sure I was right. Thanks for your answer"
                    },
                    {
                        "username": "CrossBon3",
                        "content": "median is performed on sorted array.\\nfor first 2 numbers you get correct cause they are already in sorted fashion so you got median as 6 and 8.\\nwhen 2 is added to the array, array need to be sorted(it looks [2,6,10]). thus median will be 6. "
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "**Important posts from discussions:**\\n- I was asked this question in an interview today. I told about the minHeap and maxHeap approach. The interviewer asked what if the data is very very large. How would you handle it? Any thoughts?! \\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/228442/Java-Solution-with-Tree-O(Log-N)-Insertion-and-Lookup-+-Explanation : Java Solution with Tree - O(Log N) Insertion and Lookup + Explanation\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/111698/Be-asked-for-a-multi-thread-and-thread-safe-solution-in-a-real-interview. : Be asked for a multi-thread and thread-safe solution in a real interview\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/652498/Good-for-interviews:-Python-general-sort-greater-insertion-sort-greater-two-heaps-greater-follow-ups : Good for interviews: Python general sort -> insertion sort -> two heaps -> follow-ups\\n\\n**Observations:**\\n- The change in Median: when a new element comes, the new median will be either 1 unit left or 1 unit right to the prvious median. We use 2 pointers to implement this along with taking care of average of middle numbers for even size.\\n- Median means sorted data and middle element(s). Sorted data means \\'array/collection + manual sort\\' or self balanced bst or miltuple heaps or monotonic stack or deque (which isn\\'t useful for this problem since monotonic stack/deque will involve removal exisiting elements).  \\n- Heap utilities:\\n\\t- using a heap for a data set helps to get the smallest/largest element fastly\\n\\t- using 2 heaps: if we divide the random data (non sorted data) into 2 heaps (1 min and other max) such that the first half of sorted data (data if it had been sorted) is in max heap and second half of sorted data (data if it had been sorted) is in min heap, we could easily get the middle element of the sorted data (data if it had been sorted). VISUALIZE!!!"
                    },
                    {
                        "username": "prYsm",
                        "content": "If there is a condition that the calls to findMedian() are less, we can lazily compute the median.\n\n1. Have two lists: Unsorted list, sorted list.\n2. If query == Addelement():\n    2.1 Add element to unsorted list.\n3. If query == FindMedian():\n    3.1 sort(unsorted list) call it X.\n    3.2 Merge(x, sortedlist) and assign it back to sortedlist.\n    3.3 Use indexes to find middle elements from sorted list.\n\nYes, 3 in the worst case would take O(nlogn). But, we are not computing it every time we get a query. This way we only spend cycles, which is especially important if we have large amount of data, when we want to compute median."
                    },
                    {
                        "username": "avminus",
                        "content": "Hey your second link is not opening, can you please share something regarding this thread safety discussion can\\'t seem to find it anywhere.\\n"
                    },
                    {
                        "username": "chao4",
                        "content": "In real world streaming application. The data amount will be huge so it is impossible to hold all the data in the stream into memory.\\n\\nI think it is a good open-end question to ask. What if the memory is not allowed to hold all the data from the beginning. Some data needs to go to hard drive. How will we optmize that."
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "what would be the solution in that case? i\\'m guessing some amount of memoization would be needed?"
                    },
                    {
                        "username": "prakashsellathurai",
                        "content": "`1. If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\nSince the input range is bounded we can use counter array to calculate median, where count[i] represents the number of times integer data occur in the stream in O(1) space and time\\n**refer this problem**: [statistics-from-a-large-sample](https://leetcode.com/problems/statistics-from-a-large-sample/description/)\\n\\n`2. If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\n\\nIF 99% of all integers from the stream are in the range [0,100] then considering empirical rule \\n\\n\"99.7% of data observed following a normal distribution lies within 3 standard deviations of the mean\"\\n\\nwe can assume that the input stream is normally distributed in this case.\\nIf we maintain a   reservoir  of  100 items sampled with equal probability stored in a array then we can estimate the median of the the input data with highest confidence  for large input data distribution of unknown size .\\n\\n**Alternate Interesting Solution**: By using median filter [stackoverflow](https://stackoverflow.com/a/15150968/8336491)\\n\\n  \\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Wanted to complete it quickly by using Sorting instead of two heaps and got TLE haha"
                    },
                    {
                        "username": "54564269",
                        "content": "Got it done pretty soon using 2 heaps in a real interview. However, in the follow-up, I'm asked how to improve it and make sure the method is thread-safe if the two heaps are shared."
                    },
                    {
                        "username": "adit2005",
                        "content": "can u pls share the answer for follow-up question asked ??"
                    },
                    {
                        "username": "animish01",
                        "content": "do you know it now? can you share?"
                    },
                    {
                        "username": "bayernkang",
                        "content": "Should I implement the Heap data structure myself ? (that\\'s a lot of code to memorize and write).\\n\\nDo anyone encounter a quesiton in a real interview that have to use heap but you are using Javascript?"
                    },
                    {
                        "username": "suziray",
                        "content": "I saw there is some solution for using BST in C++, and I heard some hint for using Counting Sort or maintaining the median and the numbers next to it. Is there a way to do these in Java?\\n\\nAdditionally,  another version is to return the median of recent k numbers added, how could this be achieved..."
                    },
                    {
                        "username": "jsnoob",
                        "content": "Follow up:\\n\\n1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?"
                    }
                ]
            },
            {
                "id": 1566495,
                "content": [
                    {
                        "username": "nupt_wang",
                        "content": "***1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nWe can maintain an integer array of length 100 to store the count of each number along with a total count.  Then, we can iterate over the array to find the middle value to get our median.\\n\\nTime and space complexity would be O(100) = O(1).\\n\\n***2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nIn this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100]."
                    },
                    {
                        "username": "kevintancs",
                        "content": "[@psing9968](/psing9968) iterating over an array with fixed size of 100 is O(100) = O(1)"
                    },
                    {
                        "username": "A5HU705H",
                        "content": "[@murlinwang](/murlinwang) but it guarantees a 99% hits on 0, 100"
                    },
                    {
                        "username": "psing9968",
                        "content": "If we are iterating over the array, how can it be O(1) ?"
                    },
                    {
                        "username": "hombreingwar",
                        "content": "2. why not just ignore values outside [0, 100]. They won\\'t impact the median since they are anomalies median calculation is designed for to ignore.  "
                    },
                    {
                        "username": "murlinwang",
                        "content": "[@Max7cd](/Max7cd) I think there could be cases where integers in the data stream are all out of the range of 0-100. In that case, if we want the median, the count of those integers would not help. I am also learning so correct me if I am wrong."
                    },
                    {
                        "username": "c0s",
                        "content": "[@Max7cd](/Max7cd) it would not let to call findMedian() until this requirement is met on already streamed values"
                    },
                    {
                        "username": "Max7cd",
                        "content": "> 2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n> \\n> In this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100].\\n\\nI am not 100% sure, but couldn\\'t we just keep a count of how many numbers are above 100 and how many numbers are below 0, since these numbers could never get to be the median and are therefore not important to keep?\\nThis would keep the solution in O(1) time and memory."
                    },
                    {
                        "username": "mahapatro",
                        "content": "Really great"
                    },
                    {
                        "username": "Future6",
                        "content": "[\"MedianFinder\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"]\\n[[],[6],[],[10],[],[2],[],[6],[],[5],[],[0],[],[6],[],[3],[],[1],[],[0],[],[0],[]]\\n\\nso the list is {6, 10, 2, 6, 5, 0, 6, 3, 1, 0, 0}\\nand the MedianFinder result should be: 6, 8, 10, 6, 2, 4, 6, 5.5, 5, 2.5, 0\\n\\nBut it offers answer as follows:\\n[null,null,6.00000,null,8.00000,null,**6.00000**,null,6.00000,null,**6.00000**,null,5.50000,null,6.00000,null,5.50000,null,5.00000,null,4.00000,null,3.00000]\\n\\nOr I misunderstand this quesiton"
                    },
                    {
                        "username": "rajputasif",
                        "content": "[@CrossBon3](/CrossBon3) Thanks for the reply... my data is already sorted in multiset strange!\\n\\n6 out:6\\n6 10 out:8\\n2 6 10 out:6\\n2 6 6 10 out:6\\n2 5 6 6 10 out:6\\n0 2 5 6 6 10 out:5 //5.5 expected\\n0 2 5 6 6 6 10 out:5 //6 expected\\n0 2 3 5 6 6 6 10 out:5 //5.5 expected\\n0 1 2 3 5 6 6 6 10 out:5\\n0 0 1 2 3 5 6 6 6 10 out:5\\n0 0 0 1 2 3 5 6 6 6 10 out:5"
                    },
                    {
                        "username": "adanaza89",
                        "content": "[@CrossBon3](/CrossBon3) Oh wow!! I missed this very important aspect of the question. I came here because I was sure I was right. Thanks for your answer"
                    },
                    {
                        "username": "CrossBon3",
                        "content": "median is performed on sorted array.\\nfor first 2 numbers you get correct cause they are already in sorted fashion so you got median as 6 and 8.\\nwhen 2 is added to the array, array need to be sorted(it looks [2,6,10]). thus median will be 6. "
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "**Important posts from discussions:**\\n- I was asked this question in an interview today. I told about the minHeap and maxHeap approach. The interviewer asked what if the data is very very large. How would you handle it? Any thoughts?! \\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/228442/Java-Solution-with-Tree-O(Log-N)-Insertion-and-Lookup-+-Explanation : Java Solution with Tree - O(Log N) Insertion and Lookup + Explanation\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/111698/Be-asked-for-a-multi-thread-and-thread-safe-solution-in-a-real-interview. : Be asked for a multi-thread and thread-safe solution in a real interview\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/652498/Good-for-interviews:-Python-general-sort-greater-insertion-sort-greater-two-heaps-greater-follow-ups : Good for interviews: Python general sort -> insertion sort -> two heaps -> follow-ups\\n\\n**Observations:**\\n- The change in Median: when a new element comes, the new median will be either 1 unit left or 1 unit right to the prvious median. We use 2 pointers to implement this along with taking care of average of middle numbers for even size.\\n- Median means sorted data and middle element(s). Sorted data means \\'array/collection + manual sort\\' or self balanced bst or miltuple heaps or monotonic stack or deque (which isn\\'t useful for this problem since monotonic stack/deque will involve removal exisiting elements).  \\n- Heap utilities:\\n\\t- using a heap for a data set helps to get the smallest/largest element fastly\\n\\t- using 2 heaps: if we divide the random data (non sorted data) into 2 heaps (1 min and other max) such that the first half of sorted data (data if it had been sorted) is in max heap and second half of sorted data (data if it had been sorted) is in min heap, we could easily get the middle element of the sorted data (data if it had been sorted). VISUALIZE!!!"
                    },
                    {
                        "username": "prYsm",
                        "content": "If there is a condition that the calls to findMedian() are less, we can lazily compute the median.\n\n1. Have two lists: Unsorted list, sorted list.\n2. If query == Addelement():\n    2.1 Add element to unsorted list.\n3. If query == FindMedian():\n    3.1 sort(unsorted list) call it X.\n    3.2 Merge(x, sortedlist) and assign it back to sortedlist.\n    3.3 Use indexes to find middle elements from sorted list.\n\nYes, 3 in the worst case would take O(nlogn). But, we are not computing it every time we get a query. This way we only spend cycles, which is especially important if we have large amount of data, when we want to compute median."
                    },
                    {
                        "username": "avminus",
                        "content": "Hey your second link is not opening, can you please share something regarding this thread safety discussion can\\'t seem to find it anywhere.\\n"
                    },
                    {
                        "username": "chao4",
                        "content": "In real world streaming application. The data amount will be huge so it is impossible to hold all the data in the stream into memory.\\n\\nI think it is a good open-end question to ask. What if the memory is not allowed to hold all the data from the beginning. Some data needs to go to hard drive. How will we optmize that."
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "what would be the solution in that case? i\\'m guessing some amount of memoization would be needed?"
                    },
                    {
                        "username": "prakashsellathurai",
                        "content": "`1. If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\nSince the input range is bounded we can use counter array to calculate median, where count[i] represents the number of times integer data occur in the stream in O(1) space and time\\n**refer this problem**: [statistics-from-a-large-sample](https://leetcode.com/problems/statistics-from-a-large-sample/description/)\\n\\n`2. If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\n\\nIF 99% of all integers from the stream are in the range [0,100] then considering empirical rule \\n\\n\"99.7% of data observed following a normal distribution lies within 3 standard deviations of the mean\"\\n\\nwe can assume that the input stream is normally distributed in this case.\\nIf we maintain a   reservoir  of  100 items sampled with equal probability stored in a array then we can estimate the median of the the input data with highest confidence  for large input data distribution of unknown size .\\n\\n**Alternate Interesting Solution**: By using median filter [stackoverflow](https://stackoverflow.com/a/15150968/8336491)\\n\\n  \\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Wanted to complete it quickly by using Sorting instead of two heaps and got TLE haha"
                    },
                    {
                        "username": "54564269",
                        "content": "Got it done pretty soon using 2 heaps in a real interview. However, in the follow-up, I'm asked how to improve it and make sure the method is thread-safe if the two heaps are shared."
                    },
                    {
                        "username": "adit2005",
                        "content": "can u pls share the answer for follow-up question asked ??"
                    },
                    {
                        "username": "animish01",
                        "content": "do you know it now? can you share?"
                    },
                    {
                        "username": "bayernkang",
                        "content": "Should I implement the Heap data structure myself ? (that\\'s a lot of code to memorize and write).\\n\\nDo anyone encounter a quesiton in a real interview that have to use heap but you are using Javascript?"
                    },
                    {
                        "username": "suziray",
                        "content": "I saw there is some solution for using BST in C++, and I heard some hint for using Counting Sort or maintaining the median and the numbers next to it. Is there a way to do these in Java?\\n\\nAdditionally,  another version is to return the median of recent k numbers added, how could this be achieved..."
                    },
                    {
                        "username": "jsnoob",
                        "content": "Follow up:\\n\\n1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?"
                    }
                ]
            },
            {
                "id": 1567412,
                "content": [
                    {
                        "username": "nupt_wang",
                        "content": "***1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nWe can maintain an integer array of length 100 to store the count of each number along with a total count.  Then, we can iterate over the array to find the middle value to get our median.\\n\\nTime and space complexity would be O(100) = O(1).\\n\\n***2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nIn this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100]."
                    },
                    {
                        "username": "kevintancs",
                        "content": "[@psing9968](/psing9968) iterating over an array with fixed size of 100 is O(100) = O(1)"
                    },
                    {
                        "username": "A5HU705H",
                        "content": "[@murlinwang](/murlinwang) but it guarantees a 99% hits on 0, 100"
                    },
                    {
                        "username": "psing9968",
                        "content": "If we are iterating over the array, how can it be O(1) ?"
                    },
                    {
                        "username": "hombreingwar",
                        "content": "2. why not just ignore values outside [0, 100]. They won\\'t impact the median since they are anomalies median calculation is designed for to ignore.  "
                    },
                    {
                        "username": "murlinwang",
                        "content": "[@Max7cd](/Max7cd) I think there could be cases where integers in the data stream are all out of the range of 0-100. In that case, if we want the median, the count of those integers would not help. I am also learning so correct me if I am wrong."
                    },
                    {
                        "username": "c0s",
                        "content": "[@Max7cd](/Max7cd) it would not let to call findMedian() until this requirement is met on already streamed values"
                    },
                    {
                        "username": "Max7cd",
                        "content": "> 2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n> \\n> In this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100].\\n\\nI am not 100% sure, but couldn\\'t we just keep a count of how many numbers are above 100 and how many numbers are below 0, since these numbers could never get to be the median and are therefore not important to keep?\\nThis would keep the solution in O(1) time and memory."
                    },
                    {
                        "username": "mahapatro",
                        "content": "Really great"
                    },
                    {
                        "username": "Future6",
                        "content": "[\"MedianFinder\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"]\\n[[],[6],[],[10],[],[2],[],[6],[],[5],[],[0],[],[6],[],[3],[],[1],[],[0],[],[0],[]]\\n\\nso the list is {6, 10, 2, 6, 5, 0, 6, 3, 1, 0, 0}\\nand the MedianFinder result should be: 6, 8, 10, 6, 2, 4, 6, 5.5, 5, 2.5, 0\\n\\nBut it offers answer as follows:\\n[null,null,6.00000,null,8.00000,null,**6.00000**,null,6.00000,null,**6.00000**,null,5.50000,null,6.00000,null,5.50000,null,5.00000,null,4.00000,null,3.00000]\\n\\nOr I misunderstand this quesiton"
                    },
                    {
                        "username": "rajputasif",
                        "content": "[@CrossBon3](/CrossBon3) Thanks for the reply... my data is already sorted in multiset strange!\\n\\n6 out:6\\n6 10 out:8\\n2 6 10 out:6\\n2 6 6 10 out:6\\n2 5 6 6 10 out:6\\n0 2 5 6 6 10 out:5 //5.5 expected\\n0 2 5 6 6 6 10 out:5 //6 expected\\n0 2 3 5 6 6 6 10 out:5 //5.5 expected\\n0 1 2 3 5 6 6 6 10 out:5\\n0 0 1 2 3 5 6 6 6 10 out:5\\n0 0 0 1 2 3 5 6 6 6 10 out:5"
                    },
                    {
                        "username": "adanaza89",
                        "content": "[@CrossBon3](/CrossBon3) Oh wow!! I missed this very important aspect of the question. I came here because I was sure I was right. Thanks for your answer"
                    },
                    {
                        "username": "CrossBon3",
                        "content": "median is performed on sorted array.\\nfor first 2 numbers you get correct cause they are already in sorted fashion so you got median as 6 and 8.\\nwhen 2 is added to the array, array need to be sorted(it looks [2,6,10]). thus median will be 6. "
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "**Important posts from discussions:**\\n- I was asked this question in an interview today. I told about the minHeap and maxHeap approach. The interviewer asked what if the data is very very large. How would you handle it? Any thoughts?! \\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/228442/Java-Solution-with-Tree-O(Log-N)-Insertion-and-Lookup-+-Explanation : Java Solution with Tree - O(Log N) Insertion and Lookup + Explanation\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/111698/Be-asked-for-a-multi-thread-and-thread-safe-solution-in-a-real-interview. : Be asked for a multi-thread and thread-safe solution in a real interview\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/652498/Good-for-interviews:-Python-general-sort-greater-insertion-sort-greater-two-heaps-greater-follow-ups : Good for interviews: Python general sort -> insertion sort -> two heaps -> follow-ups\\n\\n**Observations:**\\n- The change in Median: when a new element comes, the new median will be either 1 unit left or 1 unit right to the prvious median. We use 2 pointers to implement this along with taking care of average of middle numbers for even size.\\n- Median means sorted data and middle element(s). Sorted data means \\'array/collection + manual sort\\' or self balanced bst or miltuple heaps or monotonic stack or deque (which isn\\'t useful for this problem since monotonic stack/deque will involve removal exisiting elements).  \\n- Heap utilities:\\n\\t- using a heap for a data set helps to get the smallest/largest element fastly\\n\\t- using 2 heaps: if we divide the random data (non sorted data) into 2 heaps (1 min and other max) such that the first half of sorted data (data if it had been sorted) is in max heap and second half of sorted data (data if it had been sorted) is in min heap, we could easily get the middle element of the sorted data (data if it had been sorted). VISUALIZE!!!"
                    },
                    {
                        "username": "prYsm",
                        "content": "If there is a condition that the calls to findMedian() are less, we can lazily compute the median.\n\n1. Have two lists: Unsorted list, sorted list.\n2. If query == Addelement():\n    2.1 Add element to unsorted list.\n3. If query == FindMedian():\n    3.1 sort(unsorted list) call it X.\n    3.2 Merge(x, sortedlist) and assign it back to sortedlist.\n    3.3 Use indexes to find middle elements from sorted list.\n\nYes, 3 in the worst case would take O(nlogn). But, we are not computing it every time we get a query. This way we only spend cycles, which is especially important if we have large amount of data, when we want to compute median."
                    },
                    {
                        "username": "avminus",
                        "content": "Hey your second link is not opening, can you please share something regarding this thread safety discussion can\\'t seem to find it anywhere.\\n"
                    },
                    {
                        "username": "chao4",
                        "content": "In real world streaming application. The data amount will be huge so it is impossible to hold all the data in the stream into memory.\\n\\nI think it is a good open-end question to ask. What if the memory is not allowed to hold all the data from the beginning. Some data needs to go to hard drive. How will we optmize that."
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "what would be the solution in that case? i\\'m guessing some amount of memoization would be needed?"
                    },
                    {
                        "username": "prakashsellathurai",
                        "content": "`1. If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\nSince the input range is bounded we can use counter array to calculate median, where count[i] represents the number of times integer data occur in the stream in O(1) space and time\\n**refer this problem**: [statistics-from-a-large-sample](https://leetcode.com/problems/statistics-from-a-large-sample/description/)\\n\\n`2. If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\n\\nIF 99% of all integers from the stream are in the range [0,100] then considering empirical rule \\n\\n\"99.7% of data observed following a normal distribution lies within 3 standard deviations of the mean\"\\n\\nwe can assume that the input stream is normally distributed in this case.\\nIf we maintain a   reservoir  of  100 items sampled with equal probability stored in a array then we can estimate the median of the the input data with highest confidence  for large input data distribution of unknown size .\\n\\n**Alternate Interesting Solution**: By using median filter [stackoverflow](https://stackoverflow.com/a/15150968/8336491)\\n\\n  \\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Wanted to complete it quickly by using Sorting instead of two heaps and got TLE haha"
                    },
                    {
                        "username": "54564269",
                        "content": "Got it done pretty soon using 2 heaps in a real interview. However, in the follow-up, I'm asked how to improve it and make sure the method is thread-safe if the two heaps are shared."
                    },
                    {
                        "username": "adit2005",
                        "content": "can u pls share the answer for follow-up question asked ??"
                    },
                    {
                        "username": "animish01",
                        "content": "do you know it now? can you share?"
                    },
                    {
                        "username": "bayernkang",
                        "content": "Should I implement the Heap data structure myself ? (that\\'s a lot of code to memorize and write).\\n\\nDo anyone encounter a quesiton in a real interview that have to use heap but you are using Javascript?"
                    },
                    {
                        "username": "suziray",
                        "content": "I saw there is some solution for using BST in C++, and I heard some hint for using Counting Sort or maintaining the median and the numbers next to it. Is there a way to do these in Java?\\n\\nAdditionally,  another version is to return the median of recent k numbers added, how could this be achieved..."
                    },
                    {
                        "username": "jsnoob",
                        "content": "Follow up:\\n\\n1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?"
                    }
                ]
            },
            {
                "id": 1564564,
                "content": [
                    {
                        "username": "nupt_wang",
                        "content": "***1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nWe can maintain an integer array of length 100 to store the count of each number along with a total count.  Then, we can iterate over the array to find the middle value to get our median.\\n\\nTime and space complexity would be O(100) = O(1).\\n\\n***2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nIn this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100]."
                    },
                    {
                        "username": "kevintancs",
                        "content": "[@psing9968](/psing9968) iterating over an array with fixed size of 100 is O(100) = O(1)"
                    },
                    {
                        "username": "A5HU705H",
                        "content": "[@murlinwang](/murlinwang) but it guarantees a 99% hits on 0, 100"
                    },
                    {
                        "username": "psing9968",
                        "content": "If we are iterating over the array, how can it be O(1) ?"
                    },
                    {
                        "username": "hombreingwar",
                        "content": "2. why not just ignore values outside [0, 100]. They won\\'t impact the median since they are anomalies median calculation is designed for to ignore.  "
                    },
                    {
                        "username": "murlinwang",
                        "content": "[@Max7cd](/Max7cd) I think there could be cases where integers in the data stream are all out of the range of 0-100. In that case, if we want the median, the count of those integers would not help. I am also learning so correct me if I am wrong."
                    },
                    {
                        "username": "c0s",
                        "content": "[@Max7cd](/Max7cd) it would not let to call findMedian() until this requirement is met on already streamed values"
                    },
                    {
                        "username": "Max7cd",
                        "content": "> 2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n> \\n> In this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100].\\n\\nI am not 100% sure, but couldn\\'t we just keep a count of how many numbers are above 100 and how many numbers are below 0, since these numbers could never get to be the median and are therefore not important to keep?\\nThis would keep the solution in O(1) time and memory."
                    },
                    {
                        "username": "mahapatro",
                        "content": "Really great"
                    },
                    {
                        "username": "Future6",
                        "content": "[\"MedianFinder\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"]\\n[[],[6],[],[10],[],[2],[],[6],[],[5],[],[0],[],[6],[],[3],[],[1],[],[0],[],[0],[]]\\n\\nso the list is {6, 10, 2, 6, 5, 0, 6, 3, 1, 0, 0}\\nand the MedianFinder result should be: 6, 8, 10, 6, 2, 4, 6, 5.5, 5, 2.5, 0\\n\\nBut it offers answer as follows:\\n[null,null,6.00000,null,8.00000,null,**6.00000**,null,6.00000,null,**6.00000**,null,5.50000,null,6.00000,null,5.50000,null,5.00000,null,4.00000,null,3.00000]\\n\\nOr I misunderstand this quesiton"
                    },
                    {
                        "username": "rajputasif",
                        "content": "[@CrossBon3](/CrossBon3) Thanks for the reply... my data is already sorted in multiset strange!\\n\\n6 out:6\\n6 10 out:8\\n2 6 10 out:6\\n2 6 6 10 out:6\\n2 5 6 6 10 out:6\\n0 2 5 6 6 10 out:5 //5.5 expected\\n0 2 5 6 6 6 10 out:5 //6 expected\\n0 2 3 5 6 6 6 10 out:5 //5.5 expected\\n0 1 2 3 5 6 6 6 10 out:5\\n0 0 1 2 3 5 6 6 6 10 out:5\\n0 0 0 1 2 3 5 6 6 6 10 out:5"
                    },
                    {
                        "username": "adanaza89",
                        "content": "[@CrossBon3](/CrossBon3) Oh wow!! I missed this very important aspect of the question. I came here because I was sure I was right. Thanks for your answer"
                    },
                    {
                        "username": "CrossBon3",
                        "content": "median is performed on sorted array.\\nfor first 2 numbers you get correct cause they are already in sorted fashion so you got median as 6 and 8.\\nwhen 2 is added to the array, array need to be sorted(it looks [2,6,10]). thus median will be 6. "
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "**Important posts from discussions:**\\n- I was asked this question in an interview today. I told about the minHeap and maxHeap approach. The interviewer asked what if the data is very very large. How would you handle it? Any thoughts?! \\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/228442/Java-Solution-with-Tree-O(Log-N)-Insertion-and-Lookup-+-Explanation : Java Solution with Tree - O(Log N) Insertion and Lookup + Explanation\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/111698/Be-asked-for-a-multi-thread-and-thread-safe-solution-in-a-real-interview. : Be asked for a multi-thread and thread-safe solution in a real interview\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/652498/Good-for-interviews:-Python-general-sort-greater-insertion-sort-greater-two-heaps-greater-follow-ups : Good for interviews: Python general sort -> insertion sort -> two heaps -> follow-ups\\n\\n**Observations:**\\n- The change in Median: when a new element comes, the new median will be either 1 unit left or 1 unit right to the prvious median. We use 2 pointers to implement this along with taking care of average of middle numbers for even size.\\n- Median means sorted data and middle element(s). Sorted data means \\'array/collection + manual sort\\' or self balanced bst or miltuple heaps or monotonic stack or deque (which isn\\'t useful for this problem since monotonic stack/deque will involve removal exisiting elements).  \\n- Heap utilities:\\n\\t- using a heap for a data set helps to get the smallest/largest element fastly\\n\\t- using 2 heaps: if we divide the random data (non sorted data) into 2 heaps (1 min and other max) such that the first half of sorted data (data if it had been sorted) is in max heap and second half of sorted data (data if it had been sorted) is in min heap, we could easily get the middle element of the sorted data (data if it had been sorted). VISUALIZE!!!"
                    },
                    {
                        "username": "prYsm",
                        "content": "If there is a condition that the calls to findMedian() are less, we can lazily compute the median.\n\n1. Have two lists: Unsorted list, sorted list.\n2. If query == Addelement():\n    2.1 Add element to unsorted list.\n3. If query == FindMedian():\n    3.1 sort(unsorted list) call it X.\n    3.2 Merge(x, sortedlist) and assign it back to sortedlist.\n    3.3 Use indexes to find middle elements from sorted list.\n\nYes, 3 in the worst case would take O(nlogn). But, we are not computing it every time we get a query. This way we only spend cycles, which is especially important if we have large amount of data, when we want to compute median."
                    },
                    {
                        "username": "avminus",
                        "content": "Hey your second link is not opening, can you please share something regarding this thread safety discussion can\\'t seem to find it anywhere.\\n"
                    },
                    {
                        "username": "chao4",
                        "content": "In real world streaming application. The data amount will be huge so it is impossible to hold all the data in the stream into memory.\\n\\nI think it is a good open-end question to ask. What if the memory is not allowed to hold all the data from the beginning. Some data needs to go to hard drive. How will we optmize that."
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "what would be the solution in that case? i\\'m guessing some amount of memoization would be needed?"
                    },
                    {
                        "username": "prakashsellathurai",
                        "content": "`1. If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\nSince the input range is bounded we can use counter array to calculate median, where count[i] represents the number of times integer data occur in the stream in O(1) space and time\\n**refer this problem**: [statistics-from-a-large-sample](https://leetcode.com/problems/statistics-from-a-large-sample/description/)\\n\\n`2. If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\n\\nIF 99% of all integers from the stream are in the range [0,100] then considering empirical rule \\n\\n\"99.7% of data observed following a normal distribution lies within 3 standard deviations of the mean\"\\n\\nwe can assume that the input stream is normally distributed in this case.\\nIf we maintain a   reservoir  of  100 items sampled with equal probability stored in a array then we can estimate the median of the the input data with highest confidence  for large input data distribution of unknown size .\\n\\n**Alternate Interesting Solution**: By using median filter [stackoverflow](https://stackoverflow.com/a/15150968/8336491)\\n\\n  \\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Wanted to complete it quickly by using Sorting instead of two heaps and got TLE haha"
                    },
                    {
                        "username": "54564269",
                        "content": "Got it done pretty soon using 2 heaps in a real interview. However, in the follow-up, I'm asked how to improve it and make sure the method is thread-safe if the two heaps are shared."
                    },
                    {
                        "username": "adit2005",
                        "content": "can u pls share the answer for follow-up question asked ??"
                    },
                    {
                        "username": "animish01",
                        "content": "do you know it now? can you share?"
                    },
                    {
                        "username": "bayernkang",
                        "content": "Should I implement the Heap data structure myself ? (that\\'s a lot of code to memorize and write).\\n\\nDo anyone encounter a quesiton in a real interview that have to use heap but you are using Javascript?"
                    },
                    {
                        "username": "suziray",
                        "content": "I saw there is some solution for using BST in C++, and I heard some hint for using Counting Sort or maintaining the median and the numbers next to it. Is there a way to do these in Java?\\n\\nAdditionally,  another version is to return the median of recent k numbers added, how could this be achieved..."
                    },
                    {
                        "username": "jsnoob",
                        "content": "Follow up:\\n\\n1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?"
                    }
                ]
            },
            {
                "id": 1567243,
                "content": [
                    {
                        "username": "nupt_wang",
                        "content": "***1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nWe can maintain an integer array of length 100 to store the count of each number along with a total count.  Then, we can iterate over the array to find the middle value to get our median.\\n\\nTime and space complexity would be O(100) = O(1).\\n\\n***2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nIn this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100]."
                    },
                    {
                        "username": "kevintancs",
                        "content": "[@psing9968](/psing9968) iterating over an array with fixed size of 100 is O(100) = O(1)"
                    },
                    {
                        "username": "A5HU705H",
                        "content": "[@murlinwang](/murlinwang) but it guarantees a 99% hits on 0, 100"
                    },
                    {
                        "username": "psing9968",
                        "content": "If we are iterating over the array, how can it be O(1) ?"
                    },
                    {
                        "username": "hombreingwar",
                        "content": "2. why not just ignore values outside [0, 100]. They won\\'t impact the median since they are anomalies median calculation is designed for to ignore.  "
                    },
                    {
                        "username": "murlinwang",
                        "content": "[@Max7cd](/Max7cd) I think there could be cases where integers in the data stream are all out of the range of 0-100. In that case, if we want the median, the count of those integers would not help. I am also learning so correct me if I am wrong."
                    },
                    {
                        "username": "c0s",
                        "content": "[@Max7cd](/Max7cd) it would not let to call findMedian() until this requirement is met on already streamed values"
                    },
                    {
                        "username": "Max7cd",
                        "content": "> 2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n> \\n> In this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100].\\n\\nI am not 100% sure, but couldn\\'t we just keep a count of how many numbers are above 100 and how many numbers are below 0, since these numbers could never get to be the median and are therefore not important to keep?\\nThis would keep the solution in O(1) time and memory."
                    },
                    {
                        "username": "mahapatro",
                        "content": "Really great"
                    },
                    {
                        "username": "Future6",
                        "content": "[\"MedianFinder\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"]\\n[[],[6],[],[10],[],[2],[],[6],[],[5],[],[0],[],[6],[],[3],[],[1],[],[0],[],[0],[]]\\n\\nso the list is {6, 10, 2, 6, 5, 0, 6, 3, 1, 0, 0}\\nand the MedianFinder result should be: 6, 8, 10, 6, 2, 4, 6, 5.5, 5, 2.5, 0\\n\\nBut it offers answer as follows:\\n[null,null,6.00000,null,8.00000,null,**6.00000**,null,6.00000,null,**6.00000**,null,5.50000,null,6.00000,null,5.50000,null,5.00000,null,4.00000,null,3.00000]\\n\\nOr I misunderstand this quesiton"
                    },
                    {
                        "username": "rajputasif",
                        "content": "[@CrossBon3](/CrossBon3) Thanks for the reply... my data is already sorted in multiset strange!\\n\\n6 out:6\\n6 10 out:8\\n2 6 10 out:6\\n2 6 6 10 out:6\\n2 5 6 6 10 out:6\\n0 2 5 6 6 10 out:5 //5.5 expected\\n0 2 5 6 6 6 10 out:5 //6 expected\\n0 2 3 5 6 6 6 10 out:5 //5.5 expected\\n0 1 2 3 5 6 6 6 10 out:5\\n0 0 1 2 3 5 6 6 6 10 out:5\\n0 0 0 1 2 3 5 6 6 6 10 out:5"
                    },
                    {
                        "username": "adanaza89",
                        "content": "[@CrossBon3](/CrossBon3) Oh wow!! I missed this very important aspect of the question. I came here because I was sure I was right. Thanks for your answer"
                    },
                    {
                        "username": "CrossBon3",
                        "content": "median is performed on sorted array.\\nfor first 2 numbers you get correct cause they are already in sorted fashion so you got median as 6 and 8.\\nwhen 2 is added to the array, array need to be sorted(it looks [2,6,10]). thus median will be 6. "
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "**Important posts from discussions:**\\n- I was asked this question in an interview today. I told about the minHeap and maxHeap approach. The interviewer asked what if the data is very very large. How would you handle it? Any thoughts?! \\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/228442/Java-Solution-with-Tree-O(Log-N)-Insertion-and-Lookup-+-Explanation : Java Solution with Tree - O(Log N) Insertion and Lookup + Explanation\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/111698/Be-asked-for-a-multi-thread-and-thread-safe-solution-in-a-real-interview. : Be asked for a multi-thread and thread-safe solution in a real interview\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/652498/Good-for-interviews:-Python-general-sort-greater-insertion-sort-greater-two-heaps-greater-follow-ups : Good for interviews: Python general sort -> insertion sort -> two heaps -> follow-ups\\n\\n**Observations:**\\n- The change in Median: when a new element comes, the new median will be either 1 unit left or 1 unit right to the prvious median. We use 2 pointers to implement this along with taking care of average of middle numbers for even size.\\n- Median means sorted data and middle element(s). Sorted data means \\'array/collection + manual sort\\' or self balanced bst or miltuple heaps or monotonic stack or deque (which isn\\'t useful for this problem since monotonic stack/deque will involve removal exisiting elements).  \\n- Heap utilities:\\n\\t- using a heap for a data set helps to get the smallest/largest element fastly\\n\\t- using 2 heaps: if we divide the random data (non sorted data) into 2 heaps (1 min and other max) such that the first half of sorted data (data if it had been sorted) is in max heap and second half of sorted data (data if it had been sorted) is in min heap, we could easily get the middle element of the sorted data (data if it had been sorted). VISUALIZE!!!"
                    },
                    {
                        "username": "prYsm",
                        "content": "If there is a condition that the calls to findMedian() are less, we can lazily compute the median.\n\n1. Have two lists: Unsorted list, sorted list.\n2. If query == Addelement():\n    2.1 Add element to unsorted list.\n3. If query == FindMedian():\n    3.1 sort(unsorted list) call it X.\n    3.2 Merge(x, sortedlist) and assign it back to sortedlist.\n    3.3 Use indexes to find middle elements from sorted list.\n\nYes, 3 in the worst case would take O(nlogn). But, we are not computing it every time we get a query. This way we only spend cycles, which is especially important if we have large amount of data, when we want to compute median."
                    },
                    {
                        "username": "avminus",
                        "content": "Hey your second link is not opening, can you please share something regarding this thread safety discussion can\\'t seem to find it anywhere.\\n"
                    },
                    {
                        "username": "chao4",
                        "content": "In real world streaming application. The data amount will be huge so it is impossible to hold all the data in the stream into memory.\\n\\nI think it is a good open-end question to ask. What if the memory is not allowed to hold all the data from the beginning. Some data needs to go to hard drive. How will we optmize that."
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "what would be the solution in that case? i\\'m guessing some amount of memoization would be needed?"
                    },
                    {
                        "username": "prakashsellathurai",
                        "content": "`1. If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\nSince the input range is bounded we can use counter array to calculate median, where count[i] represents the number of times integer data occur in the stream in O(1) space and time\\n**refer this problem**: [statistics-from-a-large-sample](https://leetcode.com/problems/statistics-from-a-large-sample/description/)\\n\\n`2. If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\n\\nIF 99% of all integers from the stream are in the range [0,100] then considering empirical rule \\n\\n\"99.7% of data observed following a normal distribution lies within 3 standard deviations of the mean\"\\n\\nwe can assume that the input stream is normally distributed in this case.\\nIf we maintain a   reservoir  of  100 items sampled with equal probability stored in a array then we can estimate the median of the the input data with highest confidence  for large input data distribution of unknown size .\\n\\n**Alternate Interesting Solution**: By using median filter [stackoverflow](https://stackoverflow.com/a/15150968/8336491)\\n\\n  \\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Wanted to complete it quickly by using Sorting instead of two heaps and got TLE haha"
                    },
                    {
                        "username": "54564269",
                        "content": "Got it done pretty soon using 2 heaps in a real interview. However, in the follow-up, I'm asked how to improve it and make sure the method is thread-safe if the two heaps are shared."
                    },
                    {
                        "username": "adit2005",
                        "content": "can u pls share the answer for follow-up question asked ??"
                    },
                    {
                        "username": "animish01",
                        "content": "do you know it now? can you share?"
                    },
                    {
                        "username": "bayernkang",
                        "content": "Should I implement the Heap data structure myself ? (that\\'s a lot of code to memorize and write).\\n\\nDo anyone encounter a quesiton in a real interview that have to use heap but you are using Javascript?"
                    },
                    {
                        "username": "suziray",
                        "content": "I saw there is some solution for using BST in C++, and I heard some hint for using Counting Sort or maintaining the median and the numbers next to it. Is there a way to do these in Java?\\n\\nAdditionally,  another version is to return the median of recent k numbers added, how could this be achieved..."
                    },
                    {
                        "username": "jsnoob",
                        "content": "Follow up:\\n\\n1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?"
                    }
                ]
            },
            {
                "id": 1567590,
                "content": [
                    {
                        "username": "nupt_wang",
                        "content": "***1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nWe can maintain an integer array of length 100 to store the count of each number along with a total count.  Then, we can iterate over the array to find the middle value to get our median.\\n\\nTime and space complexity would be O(100) = O(1).\\n\\n***2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nIn this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100]."
                    },
                    {
                        "username": "kevintancs",
                        "content": "[@psing9968](/psing9968) iterating over an array with fixed size of 100 is O(100) = O(1)"
                    },
                    {
                        "username": "A5HU705H",
                        "content": "[@murlinwang](/murlinwang) but it guarantees a 99% hits on 0, 100"
                    },
                    {
                        "username": "psing9968",
                        "content": "If we are iterating over the array, how can it be O(1) ?"
                    },
                    {
                        "username": "hombreingwar",
                        "content": "2. why not just ignore values outside [0, 100]. They won\\'t impact the median since they are anomalies median calculation is designed for to ignore.  "
                    },
                    {
                        "username": "murlinwang",
                        "content": "[@Max7cd](/Max7cd) I think there could be cases where integers in the data stream are all out of the range of 0-100. In that case, if we want the median, the count of those integers would not help. I am also learning so correct me if I am wrong."
                    },
                    {
                        "username": "c0s",
                        "content": "[@Max7cd](/Max7cd) it would not let to call findMedian() until this requirement is met on already streamed values"
                    },
                    {
                        "username": "Max7cd",
                        "content": "> 2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n> \\n> In this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100].\\n\\nI am not 100% sure, but couldn\\'t we just keep a count of how many numbers are above 100 and how many numbers are below 0, since these numbers could never get to be the median and are therefore not important to keep?\\nThis would keep the solution in O(1) time and memory."
                    },
                    {
                        "username": "mahapatro",
                        "content": "Really great"
                    },
                    {
                        "username": "Future6",
                        "content": "[\"MedianFinder\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"]\\n[[],[6],[],[10],[],[2],[],[6],[],[5],[],[0],[],[6],[],[3],[],[1],[],[0],[],[0],[]]\\n\\nso the list is {6, 10, 2, 6, 5, 0, 6, 3, 1, 0, 0}\\nand the MedianFinder result should be: 6, 8, 10, 6, 2, 4, 6, 5.5, 5, 2.5, 0\\n\\nBut it offers answer as follows:\\n[null,null,6.00000,null,8.00000,null,**6.00000**,null,6.00000,null,**6.00000**,null,5.50000,null,6.00000,null,5.50000,null,5.00000,null,4.00000,null,3.00000]\\n\\nOr I misunderstand this quesiton"
                    },
                    {
                        "username": "rajputasif",
                        "content": "[@CrossBon3](/CrossBon3) Thanks for the reply... my data is already sorted in multiset strange!\\n\\n6 out:6\\n6 10 out:8\\n2 6 10 out:6\\n2 6 6 10 out:6\\n2 5 6 6 10 out:6\\n0 2 5 6 6 10 out:5 //5.5 expected\\n0 2 5 6 6 6 10 out:5 //6 expected\\n0 2 3 5 6 6 6 10 out:5 //5.5 expected\\n0 1 2 3 5 6 6 6 10 out:5\\n0 0 1 2 3 5 6 6 6 10 out:5\\n0 0 0 1 2 3 5 6 6 6 10 out:5"
                    },
                    {
                        "username": "adanaza89",
                        "content": "[@CrossBon3](/CrossBon3) Oh wow!! I missed this very important aspect of the question. I came here because I was sure I was right. Thanks for your answer"
                    },
                    {
                        "username": "CrossBon3",
                        "content": "median is performed on sorted array.\\nfor first 2 numbers you get correct cause they are already in sorted fashion so you got median as 6 and 8.\\nwhen 2 is added to the array, array need to be sorted(it looks [2,6,10]). thus median will be 6. "
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "**Important posts from discussions:**\\n- I was asked this question in an interview today. I told about the minHeap and maxHeap approach. The interviewer asked what if the data is very very large. How would you handle it? Any thoughts?! \\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/228442/Java-Solution-with-Tree-O(Log-N)-Insertion-and-Lookup-+-Explanation : Java Solution with Tree - O(Log N) Insertion and Lookup + Explanation\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/111698/Be-asked-for-a-multi-thread-and-thread-safe-solution-in-a-real-interview. : Be asked for a multi-thread and thread-safe solution in a real interview\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/652498/Good-for-interviews:-Python-general-sort-greater-insertion-sort-greater-two-heaps-greater-follow-ups : Good for interviews: Python general sort -> insertion sort -> two heaps -> follow-ups\\n\\n**Observations:**\\n- The change in Median: when a new element comes, the new median will be either 1 unit left or 1 unit right to the prvious median. We use 2 pointers to implement this along with taking care of average of middle numbers for even size.\\n- Median means sorted data and middle element(s). Sorted data means \\'array/collection + manual sort\\' or self balanced bst or miltuple heaps or monotonic stack or deque (which isn\\'t useful for this problem since monotonic stack/deque will involve removal exisiting elements).  \\n- Heap utilities:\\n\\t- using a heap for a data set helps to get the smallest/largest element fastly\\n\\t- using 2 heaps: if we divide the random data (non sorted data) into 2 heaps (1 min and other max) such that the first half of sorted data (data if it had been sorted) is in max heap and second half of sorted data (data if it had been sorted) is in min heap, we could easily get the middle element of the sorted data (data if it had been sorted). VISUALIZE!!!"
                    },
                    {
                        "username": "prYsm",
                        "content": "If there is a condition that the calls to findMedian() are less, we can lazily compute the median.\n\n1. Have two lists: Unsorted list, sorted list.\n2. If query == Addelement():\n    2.1 Add element to unsorted list.\n3. If query == FindMedian():\n    3.1 sort(unsorted list) call it X.\n    3.2 Merge(x, sortedlist) and assign it back to sortedlist.\n    3.3 Use indexes to find middle elements from sorted list.\n\nYes, 3 in the worst case would take O(nlogn). But, we are not computing it every time we get a query. This way we only spend cycles, which is especially important if we have large amount of data, when we want to compute median."
                    },
                    {
                        "username": "avminus",
                        "content": "Hey your second link is not opening, can you please share something regarding this thread safety discussion can\\'t seem to find it anywhere.\\n"
                    },
                    {
                        "username": "chao4",
                        "content": "In real world streaming application. The data amount will be huge so it is impossible to hold all the data in the stream into memory.\\n\\nI think it is a good open-end question to ask. What if the memory is not allowed to hold all the data from the beginning. Some data needs to go to hard drive. How will we optmize that."
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "what would be the solution in that case? i\\'m guessing some amount of memoization would be needed?"
                    },
                    {
                        "username": "prakashsellathurai",
                        "content": "`1. If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\nSince the input range is bounded we can use counter array to calculate median, where count[i] represents the number of times integer data occur in the stream in O(1) space and time\\n**refer this problem**: [statistics-from-a-large-sample](https://leetcode.com/problems/statistics-from-a-large-sample/description/)\\n\\n`2. If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\n\\nIF 99% of all integers from the stream are in the range [0,100] then considering empirical rule \\n\\n\"99.7% of data observed following a normal distribution lies within 3 standard deviations of the mean\"\\n\\nwe can assume that the input stream is normally distributed in this case.\\nIf we maintain a   reservoir  of  100 items sampled with equal probability stored in a array then we can estimate the median of the the input data with highest confidence  for large input data distribution of unknown size .\\n\\n**Alternate Interesting Solution**: By using median filter [stackoverflow](https://stackoverflow.com/a/15150968/8336491)\\n\\n  \\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Wanted to complete it quickly by using Sorting instead of two heaps and got TLE haha"
                    },
                    {
                        "username": "54564269",
                        "content": "Got it done pretty soon using 2 heaps in a real interview. However, in the follow-up, I'm asked how to improve it and make sure the method is thread-safe if the two heaps are shared."
                    },
                    {
                        "username": "adit2005",
                        "content": "can u pls share the answer for follow-up question asked ??"
                    },
                    {
                        "username": "animish01",
                        "content": "do you know it now? can you share?"
                    },
                    {
                        "username": "bayernkang",
                        "content": "Should I implement the Heap data structure myself ? (that\\'s a lot of code to memorize and write).\\n\\nDo anyone encounter a quesiton in a real interview that have to use heap but you are using Javascript?"
                    },
                    {
                        "username": "suziray",
                        "content": "I saw there is some solution for using BST in C++, and I heard some hint for using Counting Sort or maintaining the median and the numbers next to it. Is there a way to do these in Java?\\n\\nAdditionally,  another version is to return the median of recent k numbers added, how could this be achieved..."
                    },
                    {
                        "username": "jsnoob",
                        "content": "Follow up:\\n\\n1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?"
                    }
                ]
            },
            {
                "id": 1566833,
                "content": [
                    {
                        "username": "nupt_wang",
                        "content": "***1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nWe can maintain an integer array of length 100 to store the count of each number along with a total count.  Then, we can iterate over the array to find the middle value to get our median.\\n\\nTime and space complexity would be O(100) = O(1).\\n\\n***2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nIn this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100]."
                    },
                    {
                        "username": "kevintancs",
                        "content": "[@psing9968](/psing9968) iterating over an array with fixed size of 100 is O(100) = O(1)"
                    },
                    {
                        "username": "A5HU705H",
                        "content": "[@murlinwang](/murlinwang) but it guarantees a 99% hits on 0, 100"
                    },
                    {
                        "username": "psing9968",
                        "content": "If we are iterating over the array, how can it be O(1) ?"
                    },
                    {
                        "username": "hombreingwar",
                        "content": "2. why not just ignore values outside [0, 100]. They won\\'t impact the median since they are anomalies median calculation is designed for to ignore.  "
                    },
                    {
                        "username": "murlinwang",
                        "content": "[@Max7cd](/Max7cd) I think there could be cases where integers in the data stream are all out of the range of 0-100. In that case, if we want the median, the count of those integers would not help. I am also learning so correct me if I am wrong."
                    },
                    {
                        "username": "c0s",
                        "content": "[@Max7cd](/Max7cd) it would not let to call findMedian() until this requirement is met on already streamed values"
                    },
                    {
                        "username": "Max7cd",
                        "content": "> 2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n> \\n> In this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100].\\n\\nI am not 100% sure, but couldn\\'t we just keep a count of how many numbers are above 100 and how many numbers are below 0, since these numbers could never get to be the median and are therefore not important to keep?\\nThis would keep the solution in O(1) time and memory."
                    },
                    {
                        "username": "mahapatro",
                        "content": "Really great"
                    },
                    {
                        "username": "Future6",
                        "content": "[\"MedianFinder\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"]\\n[[],[6],[],[10],[],[2],[],[6],[],[5],[],[0],[],[6],[],[3],[],[1],[],[0],[],[0],[]]\\n\\nso the list is {6, 10, 2, 6, 5, 0, 6, 3, 1, 0, 0}\\nand the MedianFinder result should be: 6, 8, 10, 6, 2, 4, 6, 5.5, 5, 2.5, 0\\n\\nBut it offers answer as follows:\\n[null,null,6.00000,null,8.00000,null,**6.00000**,null,6.00000,null,**6.00000**,null,5.50000,null,6.00000,null,5.50000,null,5.00000,null,4.00000,null,3.00000]\\n\\nOr I misunderstand this quesiton"
                    },
                    {
                        "username": "rajputasif",
                        "content": "[@CrossBon3](/CrossBon3) Thanks for the reply... my data is already sorted in multiset strange!\\n\\n6 out:6\\n6 10 out:8\\n2 6 10 out:6\\n2 6 6 10 out:6\\n2 5 6 6 10 out:6\\n0 2 5 6 6 10 out:5 //5.5 expected\\n0 2 5 6 6 6 10 out:5 //6 expected\\n0 2 3 5 6 6 6 10 out:5 //5.5 expected\\n0 1 2 3 5 6 6 6 10 out:5\\n0 0 1 2 3 5 6 6 6 10 out:5\\n0 0 0 1 2 3 5 6 6 6 10 out:5"
                    },
                    {
                        "username": "adanaza89",
                        "content": "[@CrossBon3](/CrossBon3) Oh wow!! I missed this very important aspect of the question. I came here because I was sure I was right. Thanks for your answer"
                    },
                    {
                        "username": "CrossBon3",
                        "content": "median is performed on sorted array.\\nfor first 2 numbers you get correct cause they are already in sorted fashion so you got median as 6 and 8.\\nwhen 2 is added to the array, array need to be sorted(it looks [2,6,10]). thus median will be 6. "
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "**Important posts from discussions:**\\n- I was asked this question in an interview today. I told about the minHeap and maxHeap approach. The interviewer asked what if the data is very very large. How would you handle it? Any thoughts?! \\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/228442/Java-Solution-with-Tree-O(Log-N)-Insertion-and-Lookup-+-Explanation : Java Solution with Tree - O(Log N) Insertion and Lookup + Explanation\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/111698/Be-asked-for-a-multi-thread-and-thread-safe-solution-in-a-real-interview. : Be asked for a multi-thread and thread-safe solution in a real interview\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/652498/Good-for-interviews:-Python-general-sort-greater-insertion-sort-greater-two-heaps-greater-follow-ups : Good for interviews: Python general sort -> insertion sort -> two heaps -> follow-ups\\n\\n**Observations:**\\n- The change in Median: when a new element comes, the new median will be either 1 unit left or 1 unit right to the prvious median. We use 2 pointers to implement this along with taking care of average of middle numbers for even size.\\n- Median means sorted data and middle element(s). Sorted data means \\'array/collection + manual sort\\' or self balanced bst or miltuple heaps or monotonic stack or deque (which isn\\'t useful for this problem since monotonic stack/deque will involve removal exisiting elements).  \\n- Heap utilities:\\n\\t- using a heap for a data set helps to get the smallest/largest element fastly\\n\\t- using 2 heaps: if we divide the random data (non sorted data) into 2 heaps (1 min and other max) such that the first half of sorted data (data if it had been sorted) is in max heap and second half of sorted data (data if it had been sorted) is in min heap, we could easily get the middle element of the sorted data (data if it had been sorted). VISUALIZE!!!"
                    },
                    {
                        "username": "prYsm",
                        "content": "If there is a condition that the calls to findMedian() are less, we can lazily compute the median.\n\n1. Have two lists: Unsorted list, sorted list.\n2. If query == Addelement():\n    2.1 Add element to unsorted list.\n3. If query == FindMedian():\n    3.1 sort(unsorted list) call it X.\n    3.2 Merge(x, sortedlist) and assign it back to sortedlist.\n    3.3 Use indexes to find middle elements from sorted list.\n\nYes, 3 in the worst case would take O(nlogn). But, we are not computing it every time we get a query. This way we only spend cycles, which is especially important if we have large amount of data, when we want to compute median."
                    },
                    {
                        "username": "avminus",
                        "content": "Hey your second link is not opening, can you please share something regarding this thread safety discussion can\\'t seem to find it anywhere.\\n"
                    },
                    {
                        "username": "chao4",
                        "content": "In real world streaming application. The data amount will be huge so it is impossible to hold all the data in the stream into memory.\\n\\nI think it is a good open-end question to ask. What if the memory is not allowed to hold all the data from the beginning. Some data needs to go to hard drive. How will we optmize that."
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "what would be the solution in that case? i\\'m guessing some amount of memoization would be needed?"
                    },
                    {
                        "username": "prakashsellathurai",
                        "content": "`1. If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\nSince the input range is bounded we can use counter array to calculate median, where count[i] represents the number of times integer data occur in the stream in O(1) space and time\\n**refer this problem**: [statistics-from-a-large-sample](https://leetcode.com/problems/statistics-from-a-large-sample/description/)\\n\\n`2. If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\n\\nIF 99% of all integers from the stream are in the range [0,100] then considering empirical rule \\n\\n\"99.7% of data observed following a normal distribution lies within 3 standard deviations of the mean\"\\n\\nwe can assume that the input stream is normally distributed in this case.\\nIf we maintain a   reservoir  of  100 items sampled with equal probability stored in a array then we can estimate the median of the the input data with highest confidence  for large input data distribution of unknown size .\\n\\n**Alternate Interesting Solution**: By using median filter [stackoverflow](https://stackoverflow.com/a/15150968/8336491)\\n\\n  \\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Wanted to complete it quickly by using Sorting instead of two heaps and got TLE haha"
                    },
                    {
                        "username": "54564269",
                        "content": "Got it done pretty soon using 2 heaps in a real interview. However, in the follow-up, I'm asked how to improve it and make sure the method is thread-safe if the two heaps are shared."
                    },
                    {
                        "username": "adit2005",
                        "content": "can u pls share the answer for follow-up question asked ??"
                    },
                    {
                        "username": "animish01",
                        "content": "do you know it now? can you share?"
                    },
                    {
                        "username": "bayernkang",
                        "content": "Should I implement the Heap data structure myself ? (that\\'s a lot of code to memorize and write).\\n\\nDo anyone encounter a quesiton in a real interview that have to use heap but you are using Javascript?"
                    },
                    {
                        "username": "suziray",
                        "content": "I saw there is some solution for using BST in C++, and I heard some hint for using Counting Sort or maintaining the median and the numbers next to it. Is there a way to do these in Java?\\n\\nAdditionally,  another version is to return the median of recent k numbers added, how could this be achieved..."
                    },
                    {
                        "username": "jsnoob",
                        "content": "Follow up:\\n\\n1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?"
                    }
                ]
            },
            {
                "id": 1567744,
                "content": [
                    {
                        "username": "nupt_wang",
                        "content": "***1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nWe can maintain an integer array of length 100 to store the count of each number along with a total count.  Then, we can iterate over the array to find the middle value to get our median.\\n\\nTime and space complexity would be O(100) = O(1).\\n\\n***2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nIn this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100]."
                    },
                    {
                        "username": "kevintancs",
                        "content": "[@psing9968](/psing9968) iterating over an array with fixed size of 100 is O(100) = O(1)"
                    },
                    {
                        "username": "A5HU705H",
                        "content": "[@murlinwang](/murlinwang) but it guarantees a 99% hits on 0, 100"
                    },
                    {
                        "username": "psing9968",
                        "content": "If we are iterating over the array, how can it be O(1) ?"
                    },
                    {
                        "username": "hombreingwar",
                        "content": "2. why not just ignore values outside [0, 100]. They won\\'t impact the median since they are anomalies median calculation is designed for to ignore.  "
                    },
                    {
                        "username": "murlinwang",
                        "content": "[@Max7cd](/Max7cd) I think there could be cases where integers in the data stream are all out of the range of 0-100. In that case, if we want the median, the count of those integers would not help. I am also learning so correct me if I am wrong."
                    },
                    {
                        "username": "c0s",
                        "content": "[@Max7cd](/Max7cd) it would not let to call findMedian() until this requirement is met on already streamed values"
                    },
                    {
                        "username": "Max7cd",
                        "content": "> 2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n> \\n> In this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100].\\n\\nI am not 100% sure, but couldn\\'t we just keep a count of how many numbers are above 100 and how many numbers are below 0, since these numbers could never get to be the median and are therefore not important to keep?\\nThis would keep the solution in O(1) time and memory."
                    },
                    {
                        "username": "mahapatro",
                        "content": "Really great"
                    },
                    {
                        "username": "Future6",
                        "content": "[\"MedianFinder\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"]\\n[[],[6],[],[10],[],[2],[],[6],[],[5],[],[0],[],[6],[],[3],[],[1],[],[0],[],[0],[]]\\n\\nso the list is {6, 10, 2, 6, 5, 0, 6, 3, 1, 0, 0}\\nand the MedianFinder result should be: 6, 8, 10, 6, 2, 4, 6, 5.5, 5, 2.5, 0\\n\\nBut it offers answer as follows:\\n[null,null,6.00000,null,8.00000,null,**6.00000**,null,6.00000,null,**6.00000**,null,5.50000,null,6.00000,null,5.50000,null,5.00000,null,4.00000,null,3.00000]\\n\\nOr I misunderstand this quesiton"
                    },
                    {
                        "username": "rajputasif",
                        "content": "[@CrossBon3](/CrossBon3) Thanks for the reply... my data is already sorted in multiset strange!\\n\\n6 out:6\\n6 10 out:8\\n2 6 10 out:6\\n2 6 6 10 out:6\\n2 5 6 6 10 out:6\\n0 2 5 6 6 10 out:5 //5.5 expected\\n0 2 5 6 6 6 10 out:5 //6 expected\\n0 2 3 5 6 6 6 10 out:5 //5.5 expected\\n0 1 2 3 5 6 6 6 10 out:5\\n0 0 1 2 3 5 6 6 6 10 out:5\\n0 0 0 1 2 3 5 6 6 6 10 out:5"
                    },
                    {
                        "username": "adanaza89",
                        "content": "[@CrossBon3](/CrossBon3) Oh wow!! I missed this very important aspect of the question. I came here because I was sure I was right. Thanks for your answer"
                    },
                    {
                        "username": "CrossBon3",
                        "content": "median is performed on sorted array.\\nfor first 2 numbers you get correct cause they are already in sorted fashion so you got median as 6 and 8.\\nwhen 2 is added to the array, array need to be sorted(it looks [2,6,10]). thus median will be 6. "
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "**Important posts from discussions:**\\n- I was asked this question in an interview today. I told about the minHeap and maxHeap approach. The interviewer asked what if the data is very very large. How would you handle it? Any thoughts?! \\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/228442/Java-Solution-with-Tree-O(Log-N)-Insertion-and-Lookup-+-Explanation : Java Solution with Tree - O(Log N) Insertion and Lookup + Explanation\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/111698/Be-asked-for-a-multi-thread-and-thread-safe-solution-in-a-real-interview. : Be asked for a multi-thread and thread-safe solution in a real interview\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/652498/Good-for-interviews:-Python-general-sort-greater-insertion-sort-greater-two-heaps-greater-follow-ups : Good for interviews: Python general sort -> insertion sort -> two heaps -> follow-ups\\n\\n**Observations:**\\n- The change in Median: when a new element comes, the new median will be either 1 unit left or 1 unit right to the prvious median. We use 2 pointers to implement this along with taking care of average of middle numbers for even size.\\n- Median means sorted data and middle element(s). Sorted data means \\'array/collection + manual sort\\' or self balanced bst or miltuple heaps or monotonic stack or deque (which isn\\'t useful for this problem since monotonic stack/deque will involve removal exisiting elements).  \\n- Heap utilities:\\n\\t- using a heap for a data set helps to get the smallest/largest element fastly\\n\\t- using 2 heaps: if we divide the random data (non sorted data) into 2 heaps (1 min and other max) such that the first half of sorted data (data if it had been sorted) is in max heap and second half of sorted data (data if it had been sorted) is in min heap, we could easily get the middle element of the sorted data (data if it had been sorted). VISUALIZE!!!"
                    },
                    {
                        "username": "prYsm",
                        "content": "If there is a condition that the calls to findMedian() are less, we can lazily compute the median.\n\n1. Have two lists: Unsorted list, sorted list.\n2. If query == Addelement():\n    2.1 Add element to unsorted list.\n3. If query == FindMedian():\n    3.1 sort(unsorted list) call it X.\n    3.2 Merge(x, sortedlist) and assign it back to sortedlist.\n    3.3 Use indexes to find middle elements from sorted list.\n\nYes, 3 in the worst case would take O(nlogn). But, we are not computing it every time we get a query. This way we only spend cycles, which is especially important if we have large amount of data, when we want to compute median."
                    },
                    {
                        "username": "avminus",
                        "content": "Hey your second link is not opening, can you please share something regarding this thread safety discussion can\\'t seem to find it anywhere.\\n"
                    },
                    {
                        "username": "chao4",
                        "content": "In real world streaming application. The data amount will be huge so it is impossible to hold all the data in the stream into memory.\\n\\nI think it is a good open-end question to ask. What if the memory is not allowed to hold all the data from the beginning. Some data needs to go to hard drive. How will we optmize that."
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "what would be the solution in that case? i\\'m guessing some amount of memoization would be needed?"
                    },
                    {
                        "username": "prakashsellathurai",
                        "content": "`1. If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\nSince the input range is bounded we can use counter array to calculate median, where count[i] represents the number of times integer data occur in the stream in O(1) space and time\\n**refer this problem**: [statistics-from-a-large-sample](https://leetcode.com/problems/statistics-from-a-large-sample/description/)\\n\\n`2. If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\n\\nIF 99% of all integers from the stream are in the range [0,100] then considering empirical rule \\n\\n\"99.7% of data observed following a normal distribution lies within 3 standard deviations of the mean\"\\n\\nwe can assume that the input stream is normally distributed in this case.\\nIf we maintain a   reservoir  of  100 items sampled with equal probability stored in a array then we can estimate the median of the the input data with highest confidence  for large input data distribution of unknown size .\\n\\n**Alternate Interesting Solution**: By using median filter [stackoverflow](https://stackoverflow.com/a/15150968/8336491)\\n\\n  \\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Wanted to complete it quickly by using Sorting instead of two heaps and got TLE haha"
                    },
                    {
                        "username": "54564269",
                        "content": "Got it done pretty soon using 2 heaps in a real interview. However, in the follow-up, I'm asked how to improve it and make sure the method is thread-safe if the two heaps are shared."
                    },
                    {
                        "username": "adit2005",
                        "content": "can u pls share the answer for follow-up question asked ??"
                    },
                    {
                        "username": "animish01",
                        "content": "do you know it now? can you share?"
                    },
                    {
                        "username": "bayernkang",
                        "content": "Should I implement the Heap data structure myself ? (that\\'s a lot of code to memorize and write).\\n\\nDo anyone encounter a quesiton in a real interview that have to use heap but you are using Javascript?"
                    },
                    {
                        "username": "suziray",
                        "content": "I saw there is some solution for using BST in C++, and I heard some hint for using Counting Sort or maintaining the median and the numbers next to it. Is there a way to do these in Java?\\n\\nAdditionally,  another version is to return the median of recent k numbers added, how could this be achieved..."
                    },
                    {
                        "username": "jsnoob",
                        "content": "Follow up:\\n\\n1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?"
                    }
                ]
            },
            {
                "id": 1851791,
                "content": [
                    {
                        "username": "nupt_wang",
                        "content": "***1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nWe can maintain an integer array of length 100 to store the count of each number along with a total count.  Then, we can iterate over the array to find the middle value to get our median.\\n\\nTime and space complexity would be O(100) = O(1).\\n\\n***2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nIn this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100]."
                    },
                    {
                        "username": "kevintancs",
                        "content": "[@psing9968](/psing9968) iterating over an array with fixed size of 100 is O(100) = O(1)"
                    },
                    {
                        "username": "A5HU705H",
                        "content": "[@murlinwang](/murlinwang) but it guarantees a 99% hits on 0, 100"
                    },
                    {
                        "username": "psing9968",
                        "content": "If we are iterating over the array, how can it be O(1) ?"
                    },
                    {
                        "username": "hombreingwar",
                        "content": "2. why not just ignore values outside [0, 100]. They won\\'t impact the median since they are anomalies median calculation is designed for to ignore.  "
                    },
                    {
                        "username": "murlinwang",
                        "content": "[@Max7cd](/Max7cd) I think there could be cases where integers in the data stream are all out of the range of 0-100. In that case, if we want the median, the count of those integers would not help. I am also learning so correct me if I am wrong."
                    },
                    {
                        "username": "c0s",
                        "content": "[@Max7cd](/Max7cd) it would not let to call findMedian() until this requirement is met on already streamed values"
                    },
                    {
                        "username": "Max7cd",
                        "content": "> 2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n> \\n> In this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100].\\n\\nI am not 100% sure, but couldn\\'t we just keep a count of how many numbers are above 100 and how many numbers are below 0, since these numbers could never get to be the median and are therefore not important to keep?\\nThis would keep the solution in O(1) time and memory."
                    },
                    {
                        "username": "mahapatro",
                        "content": "Really great"
                    },
                    {
                        "username": "Future6",
                        "content": "[\"MedianFinder\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"]\\n[[],[6],[],[10],[],[2],[],[6],[],[5],[],[0],[],[6],[],[3],[],[1],[],[0],[],[0],[]]\\n\\nso the list is {6, 10, 2, 6, 5, 0, 6, 3, 1, 0, 0}\\nand the MedianFinder result should be: 6, 8, 10, 6, 2, 4, 6, 5.5, 5, 2.5, 0\\n\\nBut it offers answer as follows:\\n[null,null,6.00000,null,8.00000,null,**6.00000**,null,6.00000,null,**6.00000**,null,5.50000,null,6.00000,null,5.50000,null,5.00000,null,4.00000,null,3.00000]\\n\\nOr I misunderstand this quesiton"
                    },
                    {
                        "username": "rajputasif",
                        "content": "[@CrossBon3](/CrossBon3) Thanks for the reply... my data is already sorted in multiset strange!\\n\\n6 out:6\\n6 10 out:8\\n2 6 10 out:6\\n2 6 6 10 out:6\\n2 5 6 6 10 out:6\\n0 2 5 6 6 10 out:5 //5.5 expected\\n0 2 5 6 6 6 10 out:5 //6 expected\\n0 2 3 5 6 6 6 10 out:5 //5.5 expected\\n0 1 2 3 5 6 6 6 10 out:5\\n0 0 1 2 3 5 6 6 6 10 out:5\\n0 0 0 1 2 3 5 6 6 6 10 out:5"
                    },
                    {
                        "username": "adanaza89",
                        "content": "[@CrossBon3](/CrossBon3) Oh wow!! I missed this very important aspect of the question. I came here because I was sure I was right. Thanks for your answer"
                    },
                    {
                        "username": "CrossBon3",
                        "content": "median is performed on sorted array.\\nfor first 2 numbers you get correct cause they are already in sorted fashion so you got median as 6 and 8.\\nwhen 2 is added to the array, array need to be sorted(it looks [2,6,10]). thus median will be 6. "
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "**Important posts from discussions:**\\n- I was asked this question in an interview today. I told about the minHeap and maxHeap approach. The interviewer asked what if the data is very very large. How would you handle it? Any thoughts?! \\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/228442/Java-Solution-with-Tree-O(Log-N)-Insertion-and-Lookup-+-Explanation : Java Solution with Tree - O(Log N) Insertion and Lookup + Explanation\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/111698/Be-asked-for-a-multi-thread-and-thread-safe-solution-in-a-real-interview. : Be asked for a multi-thread and thread-safe solution in a real interview\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/652498/Good-for-interviews:-Python-general-sort-greater-insertion-sort-greater-two-heaps-greater-follow-ups : Good for interviews: Python general sort -> insertion sort -> two heaps -> follow-ups\\n\\n**Observations:**\\n- The change in Median: when a new element comes, the new median will be either 1 unit left or 1 unit right to the prvious median. We use 2 pointers to implement this along with taking care of average of middle numbers for even size.\\n- Median means sorted data and middle element(s). Sorted data means \\'array/collection + manual sort\\' or self balanced bst or miltuple heaps or monotonic stack or deque (which isn\\'t useful for this problem since monotonic stack/deque will involve removal exisiting elements).  \\n- Heap utilities:\\n\\t- using a heap for a data set helps to get the smallest/largest element fastly\\n\\t- using 2 heaps: if we divide the random data (non sorted data) into 2 heaps (1 min and other max) such that the first half of sorted data (data if it had been sorted) is in max heap and second half of sorted data (data if it had been sorted) is in min heap, we could easily get the middle element of the sorted data (data if it had been sorted). VISUALIZE!!!"
                    },
                    {
                        "username": "prYsm",
                        "content": "If there is a condition that the calls to findMedian() are less, we can lazily compute the median.\n\n1. Have two lists: Unsorted list, sorted list.\n2. If query == Addelement():\n    2.1 Add element to unsorted list.\n3. If query == FindMedian():\n    3.1 sort(unsorted list) call it X.\n    3.2 Merge(x, sortedlist) and assign it back to sortedlist.\n    3.3 Use indexes to find middle elements from sorted list.\n\nYes, 3 in the worst case would take O(nlogn). But, we are not computing it every time we get a query. This way we only spend cycles, which is especially important if we have large amount of data, when we want to compute median."
                    },
                    {
                        "username": "avminus",
                        "content": "Hey your second link is not opening, can you please share something regarding this thread safety discussion can\\'t seem to find it anywhere.\\n"
                    },
                    {
                        "username": "chao4",
                        "content": "In real world streaming application. The data amount will be huge so it is impossible to hold all the data in the stream into memory.\\n\\nI think it is a good open-end question to ask. What if the memory is not allowed to hold all the data from the beginning. Some data needs to go to hard drive. How will we optmize that."
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "what would be the solution in that case? i\\'m guessing some amount of memoization would be needed?"
                    },
                    {
                        "username": "prakashsellathurai",
                        "content": "`1. If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\nSince the input range is bounded we can use counter array to calculate median, where count[i] represents the number of times integer data occur in the stream in O(1) space and time\\n**refer this problem**: [statistics-from-a-large-sample](https://leetcode.com/problems/statistics-from-a-large-sample/description/)\\n\\n`2. If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\n\\nIF 99% of all integers from the stream are in the range [0,100] then considering empirical rule \\n\\n\"99.7% of data observed following a normal distribution lies within 3 standard deviations of the mean\"\\n\\nwe can assume that the input stream is normally distributed in this case.\\nIf we maintain a   reservoir  of  100 items sampled with equal probability stored in a array then we can estimate the median of the the input data with highest confidence  for large input data distribution of unknown size .\\n\\n**Alternate Interesting Solution**: By using median filter [stackoverflow](https://stackoverflow.com/a/15150968/8336491)\\n\\n  \\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Wanted to complete it quickly by using Sorting instead of two heaps and got TLE haha"
                    },
                    {
                        "username": "54564269",
                        "content": "Got it done pretty soon using 2 heaps in a real interview. However, in the follow-up, I'm asked how to improve it and make sure the method is thread-safe if the two heaps are shared."
                    },
                    {
                        "username": "adit2005",
                        "content": "can u pls share the answer for follow-up question asked ??"
                    },
                    {
                        "username": "animish01",
                        "content": "do you know it now? can you share?"
                    },
                    {
                        "username": "bayernkang",
                        "content": "Should I implement the Heap data structure myself ? (that\\'s a lot of code to memorize and write).\\n\\nDo anyone encounter a quesiton in a real interview that have to use heap but you are using Javascript?"
                    },
                    {
                        "username": "suziray",
                        "content": "I saw there is some solution for using BST in C++, and I heard some hint for using Counting Sort or maintaining the median and the numbers next to it. Is there a way to do these in Java?\\n\\nAdditionally,  another version is to return the median of recent k numbers added, how could this be achieved..."
                    },
                    {
                        "username": "jsnoob",
                        "content": "Follow up:\\n\\n1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?"
                    }
                ]
            },
            {
                "id": 1569168,
                "content": [
                    {
                        "username": "nupt_wang",
                        "content": "***1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nWe can maintain an integer array of length 100 to store the count of each number along with a total count.  Then, we can iterate over the array to find the middle value to get our median.\\n\\nTime and space complexity would be O(100) = O(1).\\n\\n***2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nIn this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100]."
                    },
                    {
                        "username": "kevintancs",
                        "content": "[@psing9968](/psing9968) iterating over an array with fixed size of 100 is O(100) = O(1)"
                    },
                    {
                        "username": "A5HU705H",
                        "content": "[@murlinwang](/murlinwang) but it guarantees a 99% hits on 0, 100"
                    },
                    {
                        "username": "psing9968",
                        "content": "If we are iterating over the array, how can it be O(1) ?"
                    },
                    {
                        "username": "hombreingwar",
                        "content": "2. why not just ignore values outside [0, 100]. They won\\'t impact the median since they are anomalies median calculation is designed for to ignore.  "
                    },
                    {
                        "username": "murlinwang",
                        "content": "[@Max7cd](/Max7cd) I think there could be cases where integers in the data stream are all out of the range of 0-100. In that case, if we want the median, the count of those integers would not help. I am also learning so correct me if I am wrong."
                    },
                    {
                        "username": "c0s",
                        "content": "[@Max7cd](/Max7cd) it would not let to call findMedian() until this requirement is met on already streamed values"
                    },
                    {
                        "username": "Max7cd",
                        "content": "> 2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n> \\n> In this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100].\\n\\nI am not 100% sure, but couldn\\'t we just keep a count of how many numbers are above 100 and how many numbers are below 0, since these numbers could never get to be the median and are therefore not important to keep?\\nThis would keep the solution in O(1) time and memory."
                    },
                    {
                        "username": "mahapatro",
                        "content": "Really great"
                    },
                    {
                        "username": "Future6",
                        "content": "[\"MedianFinder\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"]\\n[[],[6],[],[10],[],[2],[],[6],[],[5],[],[0],[],[6],[],[3],[],[1],[],[0],[],[0],[]]\\n\\nso the list is {6, 10, 2, 6, 5, 0, 6, 3, 1, 0, 0}\\nand the MedianFinder result should be: 6, 8, 10, 6, 2, 4, 6, 5.5, 5, 2.5, 0\\n\\nBut it offers answer as follows:\\n[null,null,6.00000,null,8.00000,null,**6.00000**,null,6.00000,null,**6.00000**,null,5.50000,null,6.00000,null,5.50000,null,5.00000,null,4.00000,null,3.00000]\\n\\nOr I misunderstand this quesiton"
                    },
                    {
                        "username": "rajputasif",
                        "content": "[@CrossBon3](/CrossBon3) Thanks for the reply... my data is already sorted in multiset strange!\\n\\n6 out:6\\n6 10 out:8\\n2 6 10 out:6\\n2 6 6 10 out:6\\n2 5 6 6 10 out:6\\n0 2 5 6 6 10 out:5 //5.5 expected\\n0 2 5 6 6 6 10 out:5 //6 expected\\n0 2 3 5 6 6 6 10 out:5 //5.5 expected\\n0 1 2 3 5 6 6 6 10 out:5\\n0 0 1 2 3 5 6 6 6 10 out:5\\n0 0 0 1 2 3 5 6 6 6 10 out:5"
                    },
                    {
                        "username": "adanaza89",
                        "content": "[@CrossBon3](/CrossBon3) Oh wow!! I missed this very important aspect of the question. I came here because I was sure I was right. Thanks for your answer"
                    },
                    {
                        "username": "CrossBon3",
                        "content": "median is performed on sorted array.\\nfor first 2 numbers you get correct cause they are already in sorted fashion so you got median as 6 and 8.\\nwhen 2 is added to the array, array need to be sorted(it looks [2,6,10]). thus median will be 6. "
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "**Important posts from discussions:**\\n- I was asked this question in an interview today. I told about the minHeap and maxHeap approach. The interviewer asked what if the data is very very large. How would you handle it? Any thoughts?! \\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/228442/Java-Solution-with-Tree-O(Log-N)-Insertion-and-Lookup-+-Explanation : Java Solution with Tree - O(Log N) Insertion and Lookup + Explanation\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/111698/Be-asked-for-a-multi-thread-and-thread-safe-solution-in-a-real-interview. : Be asked for a multi-thread and thread-safe solution in a real interview\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/652498/Good-for-interviews:-Python-general-sort-greater-insertion-sort-greater-two-heaps-greater-follow-ups : Good for interviews: Python general sort -> insertion sort -> two heaps -> follow-ups\\n\\n**Observations:**\\n- The change in Median: when a new element comes, the new median will be either 1 unit left or 1 unit right to the prvious median. We use 2 pointers to implement this along with taking care of average of middle numbers for even size.\\n- Median means sorted data and middle element(s). Sorted data means \\'array/collection + manual sort\\' or self balanced bst or miltuple heaps or monotonic stack or deque (which isn\\'t useful for this problem since monotonic stack/deque will involve removal exisiting elements).  \\n- Heap utilities:\\n\\t- using a heap for a data set helps to get the smallest/largest element fastly\\n\\t- using 2 heaps: if we divide the random data (non sorted data) into 2 heaps (1 min and other max) such that the first half of sorted data (data if it had been sorted) is in max heap and second half of sorted data (data if it had been sorted) is in min heap, we could easily get the middle element of the sorted data (data if it had been sorted). VISUALIZE!!!"
                    },
                    {
                        "username": "prYsm",
                        "content": "If there is a condition that the calls to findMedian() are less, we can lazily compute the median.\n\n1. Have two lists: Unsorted list, sorted list.\n2. If query == Addelement():\n    2.1 Add element to unsorted list.\n3. If query == FindMedian():\n    3.1 sort(unsorted list) call it X.\n    3.2 Merge(x, sortedlist) and assign it back to sortedlist.\n    3.3 Use indexes to find middle elements from sorted list.\n\nYes, 3 in the worst case would take O(nlogn). But, we are not computing it every time we get a query. This way we only spend cycles, which is especially important if we have large amount of data, when we want to compute median."
                    },
                    {
                        "username": "avminus",
                        "content": "Hey your second link is not opening, can you please share something regarding this thread safety discussion can\\'t seem to find it anywhere.\\n"
                    },
                    {
                        "username": "chao4",
                        "content": "In real world streaming application. The data amount will be huge so it is impossible to hold all the data in the stream into memory.\\n\\nI think it is a good open-end question to ask. What if the memory is not allowed to hold all the data from the beginning. Some data needs to go to hard drive. How will we optmize that."
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "what would be the solution in that case? i\\'m guessing some amount of memoization would be needed?"
                    },
                    {
                        "username": "prakashsellathurai",
                        "content": "`1. If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\nSince the input range is bounded we can use counter array to calculate median, where count[i] represents the number of times integer data occur in the stream in O(1) space and time\\n**refer this problem**: [statistics-from-a-large-sample](https://leetcode.com/problems/statistics-from-a-large-sample/description/)\\n\\n`2. If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\n\\nIF 99% of all integers from the stream are in the range [0,100] then considering empirical rule \\n\\n\"99.7% of data observed following a normal distribution lies within 3 standard deviations of the mean\"\\n\\nwe can assume that the input stream is normally distributed in this case.\\nIf we maintain a   reservoir  of  100 items sampled with equal probability stored in a array then we can estimate the median of the the input data with highest confidence  for large input data distribution of unknown size .\\n\\n**Alternate Interesting Solution**: By using median filter [stackoverflow](https://stackoverflow.com/a/15150968/8336491)\\n\\n  \\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Wanted to complete it quickly by using Sorting instead of two heaps and got TLE haha"
                    },
                    {
                        "username": "54564269",
                        "content": "Got it done pretty soon using 2 heaps in a real interview. However, in the follow-up, I'm asked how to improve it and make sure the method is thread-safe if the two heaps are shared."
                    },
                    {
                        "username": "adit2005",
                        "content": "can u pls share the answer for follow-up question asked ??"
                    },
                    {
                        "username": "animish01",
                        "content": "do you know it now? can you share?"
                    },
                    {
                        "username": "bayernkang",
                        "content": "Should I implement the Heap data structure myself ? (that\\'s a lot of code to memorize and write).\\n\\nDo anyone encounter a quesiton in a real interview that have to use heap but you are using Javascript?"
                    },
                    {
                        "username": "suziray",
                        "content": "I saw there is some solution for using BST in C++, and I heard some hint for using Counting Sort or maintaining the median and the numbers next to it. Is there a way to do these in Java?\\n\\nAdditionally,  another version is to return the median of recent k numbers added, how could this be achieved..."
                    },
                    {
                        "username": "jsnoob",
                        "content": "Follow up:\\n\\n1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?"
                    }
                ]
            },
            {
                "id": 1568410,
                "content": [
                    {
                        "username": "nupt_wang",
                        "content": "***1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nWe can maintain an integer array of length 100 to store the count of each number along with a total count.  Then, we can iterate over the array to find the middle value to get our median.\\n\\nTime and space complexity would be O(100) = O(1).\\n\\n***2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nIn this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100]."
                    },
                    {
                        "username": "kevintancs",
                        "content": "[@psing9968](/psing9968) iterating over an array with fixed size of 100 is O(100) = O(1)"
                    },
                    {
                        "username": "A5HU705H",
                        "content": "[@murlinwang](/murlinwang) but it guarantees a 99% hits on 0, 100"
                    },
                    {
                        "username": "psing9968",
                        "content": "If we are iterating over the array, how can it be O(1) ?"
                    },
                    {
                        "username": "hombreingwar",
                        "content": "2. why not just ignore values outside [0, 100]. They won\\'t impact the median since they are anomalies median calculation is designed for to ignore.  "
                    },
                    {
                        "username": "murlinwang",
                        "content": "[@Max7cd](/Max7cd) I think there could be cases where integers in the data stream are all out of the range of 0-100. In that case, if we want the median, the count of those integers would not help. I am also learning so correct me if I am wrong."
                    },
                    {
                        "username": "c0s",
                        "content": "[@Max7cd](/Max7cd) it would not let to call findMedian() until this requirement is met on already streamed values"
                    },
                    {
                        "username": "Max7cd",
                        "content": "> 2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n> \\n> In this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100].\\n\\nI am not 100% sure, but couldn\\'t we just keep a count of how many numbers are above 100 and how many numbers are below 0, since these numbers could never get to be the median and are therefore not important to keep?\\nThis would keep the solution in O(1) time and memory."
                    },
                    {
                        "username": "mahapatro",
                        "content": "Really great"
                    },
                    {
                        "username": "Future6",
                        "content": "[\"MedianFinder\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"]\\n[[],[6],[],[10],[],[2],[],[6],[],[5],[],[0],[],[6],[],[3],[],[1],[],[0],[],[0],[]]\\n\\nso the list is {6, 10, 2, 6, 5, 0, 6, 3, 1, 0, 0}\\nand the MedianFinder result should be: 6, 8, 10, 6, 2, 4, 6, 5.5, 5, 2.5, 0\\n\\nBut it offers answer as follows:\\n[null,null,6.00000,null,8.00000,null,**6.00000**,null,6.00000,null,**6.00000**,null,5.50000,null,6.00000,null,5.50000,null,5.00000,null,4.00000,null,3.00000]\\n\\nOr I misunderstand this quesiton"
                    },
                    {
                        "username": "rajputasif",
                        "content": "[@CrossBon3](/CrossBon3) Thanks for the reply... my data is already sorted in multiset strange!\\n\\n6 out:6\\n6 10 out:8\\n2 6 10 out:6\\n2 6 6 10 out:6\\n2 5 6 6 10 out:6\\n0 2 5 6 6 10 out:5 //5.5 expected\\n0 2 5 6 6 6 10 out:5 //6 expected\\n0 2 3 5 6 6 6 10 out:5 //5.5 expected\\n0 1 2 3 5 6 6 6 10 out:5\\n0 0 1 2 3 5 6 6 6 10 out:5\\n0 0 0 1 2 3 5 6 6 6 10 out:5"
                    },
                    {
                        "username": "adanaza89",
                        "content": "[@CrossBon3](/CrossBon3) Oh wow!! I missed this very important aspect of the question. I came here because I was sure I was right. Thanks for your answer"
                    },
                    {
                        "username": "CrossBon3",
                        "content": "median is performed on sorted array.\\nfor first 2 numbers you get correct cause they are already in sorted fashion so you got median as 6 and 8.\\nwhen 2 is added to the array, array need to be sorted(it looks [2,6,10]). thus median will be 6. "
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "**Important posts from discussions:**\\n- I was asked this question in an interview today. I told about the minHeap and maxHeap approach. The interviewer asked what if the data is very very large. How would you handle it? Any thoughts?! \\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/228442/Java-Solution-with-Tree-O(Log-N)-Insertion-and-Lookup-+-Explanation : Java Solution with Tree - O(Log N) Insertion and Lookup + Explanation\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/111698/Be-asked-for-a-multi-thread-and-thread-safe-solution-in-a-real-interview. : Be asked for a multi-thread and thread-safe solution in a real interview\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/652498/Good-for-interviews:-Python-general-sort-greater-insertion-sort-greater-two-heaps-greater-follow-ups : Good for interviews: Python general sort -> insertion sort -> two heaps -> follow-ups\\n\\n**Observations:**\\n- The change in Median: when a new element comes, the new median will be either 1 unit left or 1 unit right to the prvious median. We use 2 pointers to implement this along with taking care of average of middle numbers for even size.\\n- Median means sorted data and middle element(s). Sorted data means \\'array/collection + manual sort\\' or self balanced bst or miltuple heaps or monotonic stack or deque (which isn\\'t useful for this problem since monotonic stack/deque will involve removal exisiting elements).  \\n- Heap utilities:\\n\\t- using a heap for a data set helps to get the smallest/largest element fastly\\n\\t- using 2 heaps: if we divide the random data (non sorted data) into 2 heaps (1 min and other max) such that the first half of sorted data (data if it had been sorted) is in max heap and second half of sorted data (data if it had been sorted) is in min heap, we could easily get the middle element of the sorted data (data if it had been sorted). VISUALIZE!!!"
                    },
                    {
                        "username": "prYsm",
                        "content": "If there is a condition that the calls to findMedian() are less, we can lazily compute the median.\n\n1. Have two lists: Unsorted list, sorted list.\n2. If query == Addelement():\n    2.1 Add element to unsorted list.\n3. If query == FindMedian():\n    3.1 sort(unsorted list) call it X.\n    3.2 Merge(x, sortedlist) and assign it back to sortedlist.\n    3.3 Use indexes to find middle elements from sorted list.\n\nYes, 3 in the worst case would take O(nlogn). But, we are not computing it every time we get a query. This way we only spend cycles, which is especially important if we have large amount of data, when we want to compute median."
                    },
                    {
                        "username": "avminus",
                        "content": "Hey your second link is not opening, can you please share something regarding this thread safety discussion can\\'t seem to find it anywhere.\\n"
                    },
                    {
                        "username": "chao4",
                        "content": "In real world streaming application. The data amount will be huge so it is impossible to hold all the data in the stream into memory.\\n\\nI think it is a good open-end question to ask. What if the memory is not allowed to hold all the data from the beginning. Some data needs to go to hard drive. How will we optmize that."
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "what would be the solution in that case? i\\'m guessing some amount of memoization would be needed?"
                    },
                    {
                        "username": "prakashsellathurai",
                        "content": "`1. If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\nSince the input range is bounded we can use counter array to calculate median, where count[i] represents the number of times integer data occur in the stream in O(1) space and time\\n**refer this problem**: [statistics-from-a-large-sample](https://leetcode.com/problems/statistics-from-a-large-sample/description/)\\n\\n`2. If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\n\\nIF 99% of all integers from the stream are in the range [0,100] then considering empirical rule \\n\\n\"99.7% of data observed following a normal distribution lies within 3 standard deviations of the mean\"\\n\\nwe can assume that the input stream is normally distributed in this case.\\nIf we maintain a   reservoir  of  100 items sampled with equal probability stored in a array then we can estimate the median of the the input data with highest confidence  for large input data distribution of unknown size .\\n\\n**Alternate Interesting Solution**: By using median filter [stackoverflow](https://stackoverflow.com/a/15150968/8336491)\\n\\n  \\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Wanted to complete it quickly by using Sorting instead of two heaps and got TLE haha"
                    },
                    {
                        "username": "54564269",
                        "content": "Got it done pretty soon using 2 heaps in a real interview. However, in the follow-up, I'm asked how to improve it and make sure the method is thread-safe if the two heaps are shared."
                    },
                    {
                        "username": "adit2005",
                        "content": "can u pls share the answer for follow-up question asked ??"
                    },
                    {
                        "username": "animish01",
                        "content": "do you know it now? can you share?"
                    },
                    {
                        "username": "bayernkang",
                        "content": "Should I implement the Heap data structure myself ? (that\\'s a lot of code to memorize and write).\\n\\nDo anyone encounter a quesiton in a real interview that have to use heap but you are using Javascript?"
                    },
                    {
                        "username": "suziray",
                        "content": "I saw there is some solution for using BST in C++, and I heard some hint for using Counting Sort or maintaining the median and the numbers next to it. Is there a way to do these in Java?\\n\\nAdditionally,  another version is to return the median of recent k numbers added, how could this be achieved..."
                    },
                    {
                        "username": "jsnoob",
                        "content": "Follow up:\\n\\n1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?"
                    }
                ]
            },
            {
                "id": 1566495,
                "content": [
                    {
                        "username": "nupt_wang",
                        "content": "***1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nWe can maintain an integer array of length 100 to store the count of each number along with a total count.  Then, we can iterate over the array to find the middle value to get our median.\\n\\nTime and space complexity would be O(100) = O(1).\\n\\n***2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nIn this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100]."
                    },
                    {
                        "username": "kevintancs",
                        "content": "[@psing9968](/psing9968) iterating over an array with fixed size of 100 is O(100) = O(1)"
                    },
                    {
                        "username": "A5HU705H",
                        "content": "[@murlinwang](/murlinwang) but it guarantees a 99% hits on 0, 100"
                    },
                    {
                        "username": "psing9968",
                        "content": "If we are iterating over the array, how can it be O(1) ?"
                    },
                    {
                        "username": "hombreingwar",
                        "content": "2. why not just ignore values outside [0, 100]. They won\\'t impact the median since they are anomalies median calculation is designed for to ignore.  "
                    },
                    {
                        "username": "murlinwang",
                        "content": "[@Max7cd](/Max7cd) I think there could be cases where integers in the data stream are all out of the range of 0-100. In that case, if we want the median, the count of those integers would not help. I am also learning so correct me if I am wrong."
                    },
                    {
                        "username": "c0s",
                        "content": "[@Max7cd](/Max7cd) it would not let to call findMedian() until this requirement is met on already streamed values"
                    },
                    {
                        "username": "Max7cd",
                        "content": "> 2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n> \\n> In this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100].\\n\\nI am not 100% sure, but couldn\\'t we just keep a count of how many numbers are above 100 and how many numbers are below 0, since these numbers could never get to be the median and are therefore not important to keep?\\nThis would keep the solution in O(1) time and memory."
                    },
                    {
                        "username": "mahapatro",
                        "content": "Really great"
                    },
                    {
                        "username": "Future6",
                        "content": "[\"MedianFinder\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"]\\n[[],[6],[],[10],[],[2],[],[6],[],[5],[],[0],[],[6],[],[3],[],[1],[],[0],[],[0],[]]\\n\\nso the list is {6, 10, 2, 6, 5, 0, 6, 3, 1, 0, 0}\\nand the MedianFinder result should be: 6, 8, 10, 6, 2, 4, 6, 5.5, 5, 2.5, 0\\n\\nBut it offers answer as follows:\\n[null,null,6.00000,null,8.00000,null,**6.00000**,null,6.00000,null,**6.00000**,null,5.50000,null,6.00000,null,5.50000,null,5.00000,null,4.00000,null,3.00000]\\n\\nOr I misunderstand this quesiton"
                    },
                    {
                        "username": "rajputasif",
                        "content": "[@CrossBon3](/CrossBon3) Thanks for the reply... my data is already sorted in multiset strange!\\n\\n6 out:6\\n6 10 out:8\\n2 6 10 out:6\\n2 6 6 10 out:6\\n2 5 6 6 10 out:6\\n0 2 5 6 6 10 out:5 //5.5 expected\\n0 2 5 6 6 6 10 out:5 //6 expected\\n0 2 3 5 6 6 6 10 out:5 //5.5 expected\\n0 1 2 3 5 6 6 6 10 out:5\\n0 0 1 2 3 5 6 6 6 10 out:5\\n0 0 0 1 2 3 5 6 6 6 10 out:5"
                    },
                    {
                        "username": "adanaza89",
                        "content": "[@CrossBon3](/CrossBon3) Oh wow!! I missed this very important aspect of the question. I came here because I was sure I was right. Thanks for your answer"
                    },
                    {
                        "username": "CrossBon3",
                        "content": "median is performed on sorted array.\\nfor first 2 numbers you get correct cause they are already in sorted fashion so you got median as 6 and 8.\\nwhen 2 is added to the array, array need to be sorted(it looks [2,6,10]). thus median will be 6. "
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "**Important posts from discussions:**\\n- I was asked this question in an interview today. I told about the minHeap and maxHeap approach. The interviewer asked what if the data is very very large. How would you handle it? Any thoughts?! \\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/228442/Java-Solution-with-Tree-O(Log-N)-Insertion-and-Lookup-+-Explanation : Java Solution with Tree - O(Log N) Insertion and Lookup + Explanation\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/111698/Be-asked-for-a-multi-thread-and-thread-safe-solution-in-a-real-interview. : Be asked for a multi-thread and thread-safe solution in a real interview\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/652498/Good-for-interviews:-Python-general-sort-greater-insertion-sort-greater-two-heaps-greater-follow-ups : Good for interviews: Python general sort -> insertion sort -> two heaps -> follow-ups\\n\\n**Observations:**\\n- The change in Median: when a new element comes, the new median will be either 1 unit left or 1 unit right to the prvious median. We use 2 pointers to implement this along with taking care of average of middle numbers for even size.\\n- Median means sorted data and middle element(s). Sorted data means \\'array/collection + manual sort\\' or self balanced bst or miltuple heaps or monotonic stack or deque (which isn\\'t useful for this problem since monotonic stack/deque will involve removal exisiting elements).  \\n- Heap utilities:\\n\\t- using a heap for a data set helps to get the smallest/largest element fastly\\n\\t- using 2 heaps: if we divide the random data (non sorted data) into 2 heaps (1 min and other max) such that the first half of sorted data (data if it had been sorted) is in max heap and second half of sorted data (data if it had been sorted) is in min heap, we could easily get the middle element of the sorted data (data if it had been sorted). VISUALIZE!!!"
                    },
                    {
                        "username": "prYsm",
                        "content": "If there is a condition that the calls to findMedian() are less, we can lazily compute the median.\n\n1. Have two lists: Unsorted list, sorted list.\n2. If query == Addelement():\n    2.1 Add element to unsorted list.\n3. If query == FindMedian():\n    3.1 sort(unsorted list) call it X.\n    3.2 Merge(x, sortedlist) and assign it back to sortedlist.\n    3.3 Use indexes to find middle elements from sorted list.\n\nYes, 3 in the worst case would take O(nlogn). But, we are not computing it every time we get a query. This way we only spend cycles, which is especially important if we have large amount of data, when we want to compute median."
                    },
                    {
                        "username": "avminus",
                        "content": "Hey your second link is not opening, can you please share something regarding this thread safety discussion can\\'t seem to find it anywhere.\\n"
                    },
                    {
                        "username": "chao4",
                        "content": "In real world streaming application. The data amount will be huge so it is impossible to hold all the data in the stream into memory.\\n\\nI think it is a good open-end question to ask. What if the memory is not allowed to hold all the data from the beginning. Some data needs to go to hard drive. How will we optmize that."
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "what would be the solution in that case? i\\'m guessing some amount of memoization would be needed?"
                    },
                    {
                        "username": "prakashsellathurai",
                        "content": "`1. If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\nSince the input range is bounded we can use counter array to calculate median, where count[i] represents the number of times integer data occur in the stream in O(1) space and time\\n**refer this problem**: [statistics-from-a-large-sample](https://leetcode.com/problems/statistics-from-a-large-sample/description/)\\n\\n`2. If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\n\\nIF 99% of all integers from the stream are in the range [0,100] then considering empirical rule \\n\\n\"99.7% of data observed following a normal distribution lies within 3 standard deviations of the mean\"\\n\\nwe can assume that the input stream is normally distributed in this case.\\nIf we maintain a   reservoir  of  100 items sampled with equal probability stored in a array then we can estimate the median of the the input data with highest confidence  for large input data distribution of unknown size .\\n\\n**Alternate Interesting Solution**: By using median filter [stackoverflow](https://stackoverflow.com/a/15150968/8336491)\\n\\n  \\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Wanted to complete it quickly by using Sorting instead of two heaps and got TLE haha"
                    },
                    {
                        "username": "54564269",
                        "content": "Got it done pretty soon using 2 heaps in a real interview. However, in the follow-up, I'm asked how to improve it and make sure the method is thread-safe if the two heaps are shared."
                    },
                    {
                        "username": "adit2005",
                        "content": "can u pls share the answer for follow-up question asked ??"
                    },
                    {
                        "username": "animish01",
                        "content": "do you know it now? can you share?"
                    },
                    {
                        "username": "bayernkang",
                        "content": "Should I implement the Heap data structure myself ? (that\\'s a lot of code to memorize and write).\\n\\nDo anyone encounter a quesiton in a real interview that have to use heap but you are using Javascript?"
                    },
                    {
                        "username": "suziray",
                        "content": "I saw there is some solution for using BST in C++, and I heard some hint for using Counting Sort or maintaining the median and the numbers next to it. Is there a way to do these in Java?\\n\\nAdditionally,  another version is to return the median of recent k numbers added, how could this be achieved..."
                    },
                    {
                        "username": "jsnoob",
                        "content": "Follow up:\\n\\n1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?"
                    }
                ]
            },
            {
                "id": 1567412,
                "content": [
                    {
                        "username": "nupt_wang",
                        "content": "***1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nWe can maintain an integer array of length 100 to store the count of each number along with a total count.  Then, we can iterate over the array to find the middle value to get our median.\\n\\nTime and space complexity would be O(100) = O(1).\\n\\n***2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?***\\n\\nIn this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100]."
                    },
                    {
                        "username": "kevintancs",
                        "content": "[@psing9968](/psing9968) iterating over an array with fixed size of 100 is O(100) = O(1)"
                    },
                    {
                        "username": "A5HU705H",
                        "content": "[@murlinwang](/murlinwang) but it guarantees a 99% hits on 0, 100"
                    },
                    {
                        "username": "psing9968",
                        "content": "If we are iterating over the array, how can it be O(1) ?"
                    },
                    {
                        "username": "hombreingwar",
                        "content": "2. why not just ignore values outside [0, 100]. They won\\'t impact the median since they are anomalies median calculation is designed for to ignore.  "
                    },
                    {
                        "username": "murlinwang",
                        "content": "[@Max7cd](/Max7cd) I think there could be cases where integers in the data stream are all out of the range of 0-100. In that case, if we want the median, the count of those integers would not help. I am also learning so correct me if I am wrong."
                    },
                    {
                        "username": "c0s",
                        "content": "[@Max7cd](/Max7cd) it would not let to call findMedian() until this requirement is met on already streamed values"
                    },
                    {
                        "username": "Max7cd",
                        "content": "> 2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n> \\n> In this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100].\\n\\nI am not 100% sure, but couldn\\'t we just keep a count of how many numbers are above 100 and how many numbers are below 0, since these numbers could never get to be the median and are therefore not important to keep?\\nThis would keep the solution in O(1) time and memory."
                    },
                    {
                        "username": "mahapatro",
                        "content": "Really great"
                    },
                    {
                        "username": "Future6",
                        "content": "[\"MedianFinder\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"]\\n[[],[6],[],[10],[],[2],[],[6],[],[5],[],[0],[],[6],[],[3],[],[1],[],[0],[],[0],[]]\\n\\nso the list is {6, 10, 2, 6, 5, 0, 6, 3, 1, 0, 0}\\nand the MedianFinder result should be: 6, 8, 10, 6, 2, 4, 6, 5.5, 5, 2.5, 0\\n\\nBut it offers answer as follows:\\n[null,null,6.00000,null,8.00000,null,**6.00000**,null,6.00000,null,**6.00000**,null,5.50000,null,6.00000,null,5.50000,null,5.00000,null,4.00000,null,3.00000]\\n\\nOr I misunderstand this quesiton"
                    },
                    {
                        "username": "rajputasif",
                        "content": "[@CrossBon3](/CrossBon3) Thanks for the reply... my data is already sorted in multiset strange!\\n\\n6 out:6\\n6 10 out:8\\n2 6 10 out:6\\n2 6 6 10 out:6\\n2 5 6 6 10 out:6\\n0 2 5 6 6 10 out:5 //5.5 expected\\n0 2 5 6 6 6 10 out:5 //6 expected\\n0 2 3 5 6 6 6 10 out:5 //5.5 expected\\n0 1 2 3 5 6 6 6 10 out:5\\n0 0 1 2 3 5 6 6 6 10 out:5\\n0 0 0 1 2 3 5 6 6 6 10 out:5"
                    },
                    {
                        "username": "adanaza89",
                        "content": "[@CrossBon3](/CrossBon3) Oh wow!! I missed this very important aspect of the question. I came here because I was sure I was right. Thanks for your answer"
                    },
                    {
                        "username": "CrossBon3",
                        "content": "median is performed on sorted array.\\nfor first 2 numbers you get correct cause they are already in sorted fashion so you got median as 6 and 8.\\nwhen 2 is added to the array, array need to be sorted(it looks [2,6,10]). thus median will be 6. "
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "**Important posts from discussions:**\\n- I was asked this question in an interview today. I told about the minHeap and maxHeap approach. The interviewer asked what if the data is very very large. How would you handle it? Any thoughts?! \\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/228442/Java-Solution-with-Tree-O(Log-N)-Insertion-and-Lookup-+-Explanation : Java Solution with Tree - O(Log N) Insertion and Lookup + Explanation\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/111698/Be-asked-for-a-multi-thread-and-thread-safe-solution-in-a-real-interview. : Be asked for a multi-thread and thread-safe solution in a real interview\\n- https://leetcode.com/problems/find-median-from-data-stream/discuss/652498/Good-for-interviews:-Python-general-sort-greater-insertion-sort-greater-two-heaps-greater-follow-ups : Good for interviews: Python general sort -> insertion sort -> two heaps -> follow-ups\\n\\n**Observations:**\\n- The change in Median: when a new element comes, the new median will be either 1 unit left or 1 unit right to the prvious median. We use 2 pointers to implement this along with taking care of average of middle numbers for even size.\\n- Median means sorted data and middle element(s). Sorted data means \\'array/collection + manual sort\\' or self balanced bst or miltuple heaps or monotonic stack or deque (which isn\\'t useful for this problem since monotonic stack/deque will involve removal exisiting elements).  \\n- Heap utilities:\\n\\t- using a heap for a data set helps to get the smallest/largest element fastly\\n\\t- using 2 heaps: if we divide the random data (non sorted data) into 2 heaps (1 min and other max) such that the first half of sorted data (data if it had been sorted) is in max heap and second half of sorted data (data if it had been sorted) is in min heap, we could easily get the middle element of the sorted data (data if it had been sorted). VISUALIZE!!!"
                    },
                    {
                        "username": "prYsm",
                        "content": "If there is a condition that the calls to findMedian() are less, we can lazily compute the median.\n\n1. Have two lists: Unsorted list, sorted list.\n2. If query == Addelement():\n    2.1 Add element to unsorted list.\n3. If query == FindMedian():\n    3.1 sort(unsorted list) call it X.\n    3.2 Merge(x, sortedlist) and assign it back to sortedlist.\n    3.3 Use indexes to find middle elements from sorted list.\n\nYes, 3 in the worst case would take O(nlogn). But, we are not computing it every time we get a query. This way we only spend cycles, which is especially important if we have large amount of data, when we want to compute median."
                    },
                    {
                        "username": "avminus",
                        "content": "Hey your second link is not opening, can you please share something regarding this thread safety discussion can\\'t seem to find it anywhere.\\n"
                    },
                    {
                        "username": "chao4",
                        "content": "In real world streaming application. The data amount will be huge so it is impossible to hold all the data in the stream into memory.\\n\\nI think it is a good open-end question to ask. What if the memory is not allowed to hold all the data from the beginning. Some data needs to go to hard drive. How will we optmize that."
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "what would be the solution in that case? i\\'m guessing some amount of memoization would be needed?"
                    },
                    {
                        "username": "prakashsellathurai",
                        "content": "`1. If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\nSince the input range is bounded we can use counter array to calculate median, where count[i] represents the number of times integer data occur in the stream in O(1) space and time\\n**refer this problem**: [statistics-from-a-large-sample](https://leetcode.com/problems/statistics-from-a-large-sample/description/)\\n\\n`2. If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?`\\n\\nIF 99% of all integers from the stream are in the range [0,100] then considering empirical rule \\n\\n\"99.7% of data observed following a normal distribution lies within 3 standard deviations of the mean\"\\n\\nwe can assume that the input stream is normally distributed in this case.\\nIf we maintain a   reservoir  of  100 items sampled with equal probability stored in a array then we can estimate the median of the the input data with highest confidence  for large input data distribution of unknown size .\\n\\n**Alternate Interesting Solution**: By using median filter [stackoverflow](https://stackoverflow.com/a/15150968/8336491)\\n\\n  \\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Wanted to complete it quickly by using Sorting instead of two heaps and got TLE haha"
                    },
                    {
                        "username": "54564269",
                        "content": "Got it done pretty soon using 2 heaps in a real interview. However, in the follow-up, I'm asked how to improve it and make sure the method is thread-safe if the two heaps are shared."
                    },
                    {
                        "username": "adit2005",
                        "content": "can u pls share the answer for follow-up question asked ??"
                    },
                    {
                        "username": "animish01",
                        "content": "do you know it now? can you share?"
                    },
                    {
                        "username": "bayernkang",
                        "content": "Should I implement the Heap data structure myself ? (that\\'s a lot of code to memorize and write).\\n\\nDo anyone encounter a quesiton in a real interview that have to use heap but you are using Javascript?"
                    },
                    {
                        "username": "suziray",
                        "content": "I saw there is some solution for using BST in C++, and I heard some hint for using Counting Sort or maintaining the median and the numbers next to it. Is there a way to do these in Java?\\n\\nAdditionally,  another version is to return the median of recent k numbers added, how could this be achieved..."
                    },
                    {
                        "username": "jsnoob",
                        "content": "Follow up:\\n\\n1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?\\n2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?"
                    }
                ]
            },
            {
                "id": 1573694,
                "content": [
                    {
                        "username": "mukunda-",
                        "content": "Don\\'t build your algorithm around a counting sort due to the \"hints\": *If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?*\\n\\nSome of the tests do not follow this at all.\\n"
                    },
                    {
                        "username": "neelambuj2",
                        "content": "Please reply in comments"
                    },
                    {
                        "username": "Narayanadev",
                        "content": "Any idea on how to solve the follow-up questions?"
                    },
                    {
                        "username": "sergant_123",
                        "content": "Hello anyone please could tell me why it is passing only 20 testcases out of 21 is there any bug in last testcase\\n\\n\\n `class MedianFinder {\\npublic:\\n\\n   priority_queue<int> maxheap;\\n   priority_queue<int,vector<int>,greater<int>> minheap;\\n   double median;\\n\\n   int sgnum(int a,int b){\\n       if(a==b)\\n       return 0;\\n       else if(a>b)\\n       return 1;\\n       else\\n       return -1;\\n   }\\n\\n    MedianFinder() {\\n        this->median  = 0;\\n    }\\n    \\n    void addNum(int num) {\\n        switch(sgnum(maxheap.size(),minheap.size())){\\n            case 0:\\n            if(num>this->median){\\n                minheap.push(num);\\n            }\\n            else{\\n                maxheap.push(num);\\n            }\\n            break;\\n            case 1:\\n            if(num>this->median){\\n                minheap.push(num);\\n            }\\n            else{\\n                minheap.push(maxheap.top());\\n                maxheap.pop();\\n                maxheap.push(num);\\n            }\\n            break;\\n            case -1:\\n            if(num>this->median){\\n                maxheap.push(minheap.top());\\n                minheap.pop();\\n\\n                minheap.push(num);\\n            }\\n            else{\\n                maxheap.push(num);\\n            }\\n            break;\\n        }\\n\\n    }\\n    \\n    double findMedian() {\\n        if(maxheap.size()>minheap.size()){\\n            this->median  = maxheap.top();\\n        }\\n        else if(maxheap.size()<minheap.size()){\\n            this->median  = minheap.top();\\n        }\\n        else{\\n            this->median  = (maxheap.top()+minheap.top())/2.0;\\n        }\\n        return this->median;\\n    }\\n};`"
                    },
                    {
                        "username": "Vithesh",
                        "content": "typecaste it properly. maybe thats the issue...and do check the last testcase..."
                    },
                    {
                        "username": "GrandChieftain",
                        "content": "Same issue here. Compared the actual and expected outputs, both when submitting and running the testcase in isolation, and it keeps failing even though they\\'re the exact same."
                    },
                    {
                        "username": "csjobhelp2",
                        "content": "Aren\\'t they the same time complexity NlogN?  Why do the more complicated two heap?"
                    },
                    {
                        "username": "drsagitn",
                        "content": "My code succeeded on when try \"Run Code\" but failed on \"Submission\". Exact same testcase used. I dont know why??? Is this because of soem environment difference?\\n\\n![image](https://assets.leetcode.com/users/drsagitn/image_1580253193.png)\\n"
                    },
                    {
                        "username": "LizLemon777",
                        "content": "I'm just thinking of this idea, and it seems the majority of people here use two heaps. Has anyone tried two pointers (pointing to two middle values) and a doubly linked list? When adding a new value, compare it to the middle values, and place the value at the right place using binary search, and update middle value pointers. Does this idea work?"
                    },
                    {
                        "username": "vansharora03",
                        "content": "unfortunately you cannot perform a logn sorted insertion of a doubly linked list. I tried using a hashmap of indexes to nodes, but realized I would have to update the indexes anyways after insertion. "
                    },
                    {
                        "username": "meetug",
                        "content": "I find this solution by HelloWorld123456 to be very intuitive. \\n\\nhttps://leetcode.com/discuss/80600/java-easy-version-to-understand\\n\\nC# does not have native support for priority queue/heap. How can I write equivalent code that will be accepted by LeetCode? What is an acceptable alternative with O(lgn) insert and remove?"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This is a fun question but I feel as though it should be Medium Difficulty because it just involves a sorted array search and that computation is of medium difficulty."
                    },
                    {
                        "username": "nathan_code",
                        "content": "Hi, Everyone. I saw a interview follow up for this question \"what if data can\\'t fit into memory\"\\nso how can we handle this?  something about Divide and Conquer?\\nMany Thanks"
                    }
                ]
            },
            {
                "id": 1569631,
                "content": [
                    {
                        "username": "mukunda-",
                        "content": "Don\\'t build your algorithm around a counting sort due to the \"hints\": *If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?*\\n\\nSome of the tests do not follow this at all.\\n"
                    },
                    {
                        "username": "neelambuj2",
                        "content": "Please reply in comments"
                    },
                    {
                        "username": "Narayanadev",
                        "content": "Any idea on how to solve the follow-up questions?"
                    },
                    {
                        "username": "sergant_123",
                        "content": "Hello anyone please could tell me why it is passing only 20 testcases out of 21 is there any bug in last testcase\\n\\n\\n `class MedianFinder {\\npublic:\\n\\n   priority_queue<int> maxheap;\\n   priority_queue<int,vector<int>,greater<int>> minheap;\\n   double median;\\n\\n   int sgnum(int a,int b){\\n       if(a==b)\\n       return 0;\\n       else if(a>b)\\n       return 1;\\n       else\\n       return -1;\\n   }\\n\\n    MedianFinder() {\\n        this->median  = 0;\\n    }\\n    \\n    void addNum(int num) {\\n        switch(sgnum(maxheap.size(),minheap.size())){\\n            case 0:\\n            if(num>this->median){\\n                minheap.push(num);\\n            }\\n            else{\\n                maxheap.push(num);\\n            }\\n            break;\\n            case 1:\\n            if(num>this->median){\\n                minheap.push(num);\\n            }\\n            else{\\n                minheap.push(maxheap.top());\\n                maxheap.pop();\\n                maxheap.push(num);\\n            }\\n            break;\\n            case -1:\\n            if(num>this->median){\\n                maxheap.push(minheap.top());\\n                minheap.pop();\\n\\n                minheap.push(num);\\n            }\\n            else{\\n                maxheap.push(num);\\n            }\\n            break;\\n        }\\n\\n    }\\n    \\n    double findMedian() {\\n        if(maxheap.size()>minheap.size()){\\n            this->median  = maxheap.top();\\n        }\\n        else if(maxheap.size()<minheap.size()){\\n            this->median  = minheap.top();\\n        }\\n        else{\\n            this->median  = (maxheap.top()+minheap.top())/2.0;\\n        }\\n        return this->median;\\n    }\\n};`"
                    },
                    {
                        "username": "Vithesh",
                        "content": "typecaste it properly. maybe thats the issue...and do check the last testcase..."
                    },
                    {
                        "username": "GrandChieftain",
                        "content": "Same issue here. Compared the actual and expected outputs, both when submitting and running the testcase in isolation, and it keeps failing even though they\\'re the exact same."
                    },
                    {
                        "username": "csjobhelp2",
                        "content": "Aren\\'t they the same time complexity NlogN?  Why do the more complicated two heap?"
                    },
                    {
                        "username": "drsagitn",
                        "content": "My code succeeded on when try \"Run Code\" but failed on \"Submission\". Exact same testcase used. I dont know why??? Is this because of soem environment difference?\\n\\n![image](https://assets.leetcode.com/users/drsagitn/image_1580253193.png)\\n"
                    },
                    {
                        "username": "LizLemon777",
                        "content": "I'm just thinking of this idea, and it seems the majority of people here use two heaps. Has anyone tried two pointers (pointing to two middle values) and a doubly linked list? When adding a new value, compare it to the middle values, and place the value at the right place using binary search, and update middle value pointers. Does this idea work?"
                    },
                    {
                        "username": "vansharora03",
                        "content": "unfortunately you cannot perform a logn sorted insertion of a doubly linked list. I tried using a hashmap of indexes to nodes, but realized I would have to update the indexes anyways after insertion. "
                    },
                    {
                        "username": "meetug",
                        "content": "I find this solution by HelloWorld123456 to be very intuitive. \\n\\nhttps://leetcode.com/discuss/80600/java-easy-version-to-understand\\n\\nC# does not have native support for priority queue/heap. How can I write equivalent code that will be accepted by LeetCode? What is an acceptable alternative with O(lgn) insert and remove?"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This is a fun question but I feel as though it should be Medium Difficulty because it just involves a sorted array search and that computation is of medium difficulty."
                    },
                    {
                        "username": "nathan_code",
                        "content": "Hi, Everyone. I saw a interview follow up for this question \"what if data can\\'t fit into memory\"\\nso how can we handle this?  something about Divide and Conquer?\\nMany Thanks"
                    }
                ]
            },
            {
                "id": 1569452,
                "content": [
                    {
                        "username": "mukunda-",
                        "content": "Don\\'t build your algorithm around a counting sort due to the \"hints\": *If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?*\\n\\nSome of the tests do not follow this at all.\\n"
                    },
                    {
                        "username": "neelambuj2",
                        "content": "Please reply in comments"
                    },
                    {
                        "username": "Narayanadev",
                        "content": "Any idea on how to solve the follow-up questions?"
                    },
                    {
                        "username": "sergant_123",
                        "content": "Hello anyone please could tell me why it is passing only 20 testcases out of 21 is there any bug in last testcase\\n\\n\\n `class MedianFinder {\\npublic:\\n\\n   priority_queue<int> maxheap;\\n   priority_queue<int,vector<int>,greater<int>> minheap;\\n   double median;\\n\\n   int sgnum(int a,int b){\\n       if(a==b)\\n       return 0;\\n       else if(a>b)\\n       return 1;\\n       else\\n       return -1;\\n   }\\n\\n    MedianFinder() {\\n        this->median  = 0;\\n    }\\n    \\n    void addNum(int num) {\\n        switch(sgnum(maxheap.size(),minheap.size())){\\n            case 0:\\n            if(num>this->median){\\n                minheap.push(num);\\n            }\\n            else{\\n                maxheap.push(num);\\n            }\\n            break;\\n            case 1:\\n            if(num>this->median){\\n                minheap.push(num);\\n            }\\n            else{\\n                minheap.push(maxheap.top());\\n                maxheap.pop();\\n                maxheap.push(num);\\n            }\\n            break;\\n            case -1:\\n            if(num>this->median){\\n                maxheap.push(minheap.top());\\n                minheap.pop();\\n\\n                minheap.push(num);\\n            }\\n            else{\\n                maxheap.push(num);\\n            }\\n            break;\\n        }\\n\\n    }\\n    \\n    double findMedian() {\\n        if(maxheap.size()>minheap.size()){\\n            this->median  = maxheap.top();\\n        }\\n        else if(maxheap.size()<minheap.size()){\\n            this->median  = minheap.top();\\n        }\\n        else{\\n            this->median  = (maxheap.top()+minheap.top())/2.0;\\n        }\\n        return this->median;\\n    }\\n};`"
                    },
                    {
                        "username": "Vithesh",
                        "content": "typecaste it properly. maybe thats the issue...and do check the last testcase..."
                    },
                    {
                        "username": "GrandChieftain",
                        "content": "Same issue here. Compared the actual and expected outputs, both when submitting and running the testcase in isolation, and it keeps failing even though they\\'re the exact same."
                    },
                    {
                        "username": "csjobhelp2",
                        "content": "Aren\\'t they the same time complexity NlogN?  Why do the more complicated two heap?"
                    },
                    {
                        "username": "drsagitn",
                        "content": "My code succeeded on when try \"Run Code\" but failed on \"Submission\". Exact same testcase used. I dont know why??? Is this because of soem environment difference?\\n\\n![image](https://assets.leetcode.com/users/drsagitn/image_1580253193.png)\\n"
                    },
                    {
                        "username": "LizLemon777",
                        "content": "I'm just thinking of this idea, and it seems the majority of people here use two heaps. Has anyone tried two pointers (pointing to two middle values) and a doubly linked list? When adding a new value, compare it to the middle values, and place the value at the right place using binary search, and update middle value pointers. Does this idea work?"
                    },
                    {
                        "username": "vansharora03",
                        "content": "unfortunately you cannot perform a logn sorted insertion of a doubly linked list. I tried using a hashmap of indexes to nodes, but realized I would have to update the indexes anyways after insertion. "
                    },
                    {
                        "username": "meetug",
                        "content": "I find this solution by HelloWorld123456 to be very intuitive. \\n\\nhttps://leetcode.com/discuss/80600/java-easy-version-to-understand\\n\\nC# does not have native support for priority queue/heap. How can I write equivalent code that will be accepted by LeetCode? What is an acceptable alternative with O(lgn) insert and remove?"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This is a fun question but I feel as though it should be Medium Difficulty because it just involves a sorted array search and that computation is of medium difficulty."
                    },
                    {
                        "username": "nathan_code",
                        "content": "Hi, Everyone. I saw a interview follow up for this question \"what if data can\\'t fit into memory\"\\nso how can we handle this?  something about Divide and Conquer?\\nMany Thanks"
                    }
                ]
            },
            {
                "id": 2034237,
                "content": [
                    {
                        "username": "mukunda-",
                        "content": "Don\\'t build your algorithm around a counting sort due to the \"hints\": *If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?*\\n\\nSome of the tests do not follow this at all.\\n"
                    },
                    {
                        "username": "neelambuj2",
                        "content": "Please reply in comments"
                    },
                    {
                        "username": "Narayanadev",
                        "content": "Any idea on how to solve the follow-up questions?"
                    },
                    {
                        "username": "sergant_123",
                        "content": "Hello anyone please could tell me why it is passing only 20 testcases out of 21 is there any bug in last testcase\\n\\n\\n `class MedianFinder {\\npublic:\\n\\n   priority_queue<int> maxheap;\\n   priority_queue<int,vector<int>,greater<int>> minheap;\\n   double median;\\n\\n   int sgnum(int a,int b){\\n       if(a==b)\\n       return 0;\\n       else if(a>b)\\n       return 1;\\n       else\\n       return -1;\\n   }\\n\\n    MedianFinder() {\\n        this->median  = 0;\\n    }\\n    \\n    void addNum(int num) {\\n        switch(sgnum(maxheap.size(),minheap.size())){\\n            case 0:\\n            if(num>this->median){\\n                minheap.push(num);\\n            }\\n            else{\\n                maxheap.push(num);\\n            }\\n            break;\\n            case 1:\\n            if(num>this->median){\\n                minheap.push(num);\\n            }\\n            else{\\n                minheap.push(maxheap.top());\\n                maxheap.pop();\\n                maxheap.push(num);\\n            }\\n            break;\\n            case -1:\\n            if(num>this->median){\\n                maxheap.push(minheap.top());\\n                minheap.pop();\\n\\n                minheap.push(num);\\n            }\\n            else{\\n                maxheap.push(num);\\n            }\\n            break;\\n        }\\n\\n    }\\n    \\n    double findMedian() {\\n        if(maxheap.size()>minheap.size()){\\n            this->median  = maxheap.top();\\n        }\\n        else if(maxheap.size()<minheap.size()){\\n            this->median  = minheap.top();\\n        }\\n        else{\\n            this->median  = (maxheap.top()+minheap.top())/2.0;\\n        }\\n        return this->median;\\n    }\\n};`"
                    },
                    {
                        "username": "Vithesh",
                        "content": "typecaste it properly. maybe thats the issue...and do check the last testcase..."
                    },
                    {
                        "username": "GrandChieftain",
                        "content": "Same issue here. Compared the actual and expected outputs, both when submitting and running the testcase in isolation, and it keeps failing even though they\\'re the exact same."
                    },
                    {
                        "username": "csjobhelp2",
                        "content": "Aren\\'t they the same time complexity NlogN?  Why do the more complicated two heap?"
                    },
                    {
                        "username": "drsagitn",
                        "content": "My code succeeded on when try \"Run Code\" but failed on \"Submission\". Exact same testcase used. I dont know why??? Is this because of soem environment difference?\\n\\n![image](https://assets.leetcode.com/users/drsagitn/image_1580253193.png)\\n"
                    },
                    {
                        "username": "LizLemon777",
                        "content": "I'm just thinking of this idea, and it seems the majority of people here use two heaps. Has anyone tried two pointers (pointing to two middle values) and a doubly linked list? When adding a new value, compare it to the middle values, and place the value at the right place using binary search, and update middle value pointers. Does this idea work?"
                    },
                    {
                        "username": "vansharora03",
                        "content": "unfortunately you cannot perform a logn sorted insertion of a doubly linked list. I tried using a hashmap of indexes to nodes, but realized I would have to update the indexes anyways after insertion. "
                    },
                    {
                        "username": "meetug",
                        "content": "I find this solution by HelloWorld123456 to be very intuitive. \\n\\nhttps://leetcode.com/discuss/80600/java-easy-version-to-understand\\n\\nC# does not have native support for priority queue/heap. How can I write equivalent code that will be accepted by LeetCode? What is an acceptable alternative with O(lgn) insert and remove?"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This is a fun question but I feel as though it should be Medium Difficulty because it just involves a sorted array search and that computation is of medium difficulty."
                    },
                    {
                        "username": "nathan_code",
                        "content": "Hi, Everyone. I saw a interview follow up for this question \"what if data can\\'t fit into memory\"\\nso how can we handle this?  something about Divide and Conquer?\\nMany Thanks"
                    }
                ]
            },
            {
                "id": 1575093,
                "content": [
                    {
                        "username": "mukunda-",
                        "content": "Don\\'t build your algorithm around a counting sort due to the \"hints\": *If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?*\\n\\nSome of the tests do not follow this at all.\\n"
                    },
                    {
                        "username": "neelambuj2",
                        "content": "Please reply in comments"
                    },
                    {
                        "username": "Narayanadev",
                        "content": "Any idea on how to solve the follow-up questions?"
                    },
                    {
                        "username": "sergant_123",
                        "content": "Hello anyone please could tell me why it is passing only 20 testcases out of 21 is there any bug in last testcase\\n\\n\\n `class MedianFinder {\\npublic:\\n\\n   priority_queue<int> maxheap;\\n   priority_queue<int,vector<int>,greater<int>> minheap;\\n   double median;\\n\\n   int sgnum(int a,int b){\\n       if(a==b)\\n       return 0;\\n       else if(a>b)\\n       return 1;\\n       else\\n       return -1;\\n   }\\n\\n    MedianFinder() {\\n        this->median  = 0;\\n    }\\n    \\n    void addNum(int num) {\\n        switch(sgnum(maxheap.size(),minheap.size())){\\n            case 0:\\n            if(num>this->median){\\n                minheap.push(num);\\n            }\\n            else{\\n                maxheap.push(num);\\n            }\\n            break;\\n            case 1:\\n            if(num>this->median){\\n                minheap.push(num);\\n            }\\n            else{\\n                minheap.push(maxheap.top());\\n                maxheap.pop();\\n                maxheap.push(num);\\n            }\\n            break;\\n            case -1:\\n            if(num>this->median){\\n                maxheap.push(minheap.top());\\n                minheap.pop();\\n\\n                minheap.push(num);\\n            }\\n            else{\\n                maxheap.push(num);\\n            }\\n            break;\\n        }\\n\\n    }\\n    \\n    double findMedian() {\\n        if(maxheap.size()>minheap.size()){\\n            this->median  = maxheap.top();\\n        }\\n        else if(maxheap.size()<minheap.size()){\\n            this->median  = minheap.top();\\n        }\\n        else{\\n            this->median  = (maxheap.top()+minheap.top())/2.0;\\n        }\\n        return this->median;\\n    }\\n};`"
                    },
                    {
                        "username": "Vithesh",
                        "content": "typecaste it properly. maybe thats the issue...and do check the last testcase..."
                    },
                    {
                        "username": "GrandChieftain",
                        "content": "Same issue here. Compared the actual and expected outputs, both when submitting and running the testcase in isolation, and it keeps failing even though they\\'re the exact same."
                    },
                    {
                        "username": "csjobhelp2",
                        "content": "Aren\\'t they the same time complexity NlogN?  Why do the more complicated two heap?"
                    },
                    {
                        "username": "drsagitn",
                        "content": "My code succeeded on when try \"Run Code\" but failed on \"Submission\". Exact same testcase used. I dont know why??? Is this because of soem environment difference?\\n\\n![image](https://assets.leetcode.com/users/drsagitn/image_1580253193.png)\\n"
                    },
                    {
                        "username": "LizLemon777",
                        "content": "I'm just thinking of this idea, and it seems the majority of people here use two heaps. Has anyone tried two pointers (pointing to two middle values) and a doubly linked list? When adding a new value, compare it to the middle values, and place the value at the right place using binary search, and update middle value pointers. Does this idea work?"
                    },
                    {
                        "username": "vansharora03",
                        "content": "unfortunately you cannot perform a logn sorted insertion of a doubly linked list. I tried using a hashmap of indexes to nodes, but realized I would have to update the indexes anyways after insertion. "
                    },
                    {
                        "username": "meetug",
                        "content": "I find this solution by HelloWorld123456 to be very intuitive. \\n\\nhttps://leetcode.com/discuss/80600/java-easy-version-to-understand\\n\\nC# does not have native support for priority queue/heap. How can I write equivalent code that will be accepted by LeetCode? What is an acceptable alternative with O(lgn) insert and remove?"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This is a fun question but I feel as though it should be Medium Difficulty because it just involves a sorted array search and that computation is of medium difficulty."
                    },
                    {
                        "username": "nathan_code",
                        "content": "Hi, Everyone. I saw a interview follow up for this question \"what if data can\\'t fit into memory\"\\nso how can we handle this?  something about Divide and Conquer?\\nMany Thanks"
                    }
                ]
            },
            {
                "id": 1573390,
                "content": [
                    {
                        "username": "mukunda-",
                        "content": "Don\\'t build your algorithm around a counting sort due to the \"hints\": *If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?*\\n\\nSome of the tests do not follow this at all.\\n"
                    },
                    {
                        "username": "neelambuj2",
                        "content": "Please reply in comments"
                    },
                    {
                        "username": "Narayanadev",
                        "content": "Any idea on how to solve the follow-up questions?"
                    },
                    {
                        "username": "sergant_123",
                        "content": "Hello anyone please could tell me why it is passing only 20 testcases out of 21 is there any bug in last testcase\\n\\n\\n `class MedianFinder {\\npublic:\\n\\n   priority_queue<int> maxheap;\\n   priority_queue<int,vector<int>,greater<int>> minheap;\\n   double median;\\n\\n   int sgnum(int a,int b){\\n       if(a==b)\\n       return 0;\\n       else if(a>b)\\n       return 1;\\n       else\\n       return -1;\\n   }\\n\\n    MedianFinder() {\\n        this->median  = 0;\\n    }\\n    \\n    void addNum(int num) {\\n        switch(sgnum(maxheap.size(),minheap.size())){\\n            case 0:\\n            if(num>this->median){\\n                minheap.push(num);\\n            }\\n            else{\\n                maxheap.push(num);\\n            }\\n            break;\\n            case 1:\\n            if(num>this->median){\\n                minheap.push(num);\\n            }\\n            else{\\n                minheap.push(maxheap.top());\\n                maxheap.pop();\\n                maxheap.push(num);\\n            }\\n            break;\\n            case -1:\\n            if(num>this->median){\\n                maxheap.push(minheap.top());\\n                minheap.pop();\\n\\n                minheap.push(num);\\n            }\\n            else{\\n                maxheap.push(num);\\n            }\\n            break;\\n        }\\n\\n    }\\n    \\n    double findMedian() {\\n        if(maxheap.size()>minheap.size()){\\n            this->median  = maxheap.top();\\n        }\\n        else if(maxheap.size()<minheap.size()){\\n            this->median  = minheap.top();\\n        }\\n        else{\\n            this->median  = (maxheap.top()+minheap.top())/2.0;\\n        }\\n        return this->median;\\n    }\\n};`"
                    },
                    {
                        "username": "Vithesh",
                        "content": "typecaste it properly. maybe thats the issue...and do check the last testcase..."
                    },
                    {
                        "username": "GrandChieftain",
                        "content": "Same issue here. Compared the actual and expected outputs, both when submitting and running the testcase in isolation, and it keeps failing even though they\\'re the exact same."
                    },
                    {
                        "username": "csjobhelp2",
                        "content": "Aren\\'t they the same time complexity NlogN?  Why do the more complicated two heap?"
                    },
                    {
                        "username": "drsagitn",
                        "content": "My code succeeded on when try \"Run Code\" but failed on \"Submission\". Exact same testcase used. I dont know why??? Is this because of soem environment difference?\\n\\n![image](https://assets.leetcode.com/users/drsagitn/image_1580253193.png)\\n"
                    },
                    {
                        "username": "LizLemon777",
                        "content": "I'm just thinking of this idea, and it seems the majority of people here use two heaps. Has anyone tried two pointers (pointing to two middle values) and a doubly linked list? When adding a new value, compare it to the middle values, and place the value at the right place using binary search, and update middle value pointers. Does this idea work?"
                    },
                    {
                        "username": "vansharora03",
                        "content": "unfortunately you cannot perform a logn sorted insertion of a doubly linked list. I tried using a hashmap of indexes to nodes, but realized I would have to update the indexes anyways after insertion. "
                    },
                    {
                        "username": "meetug",
                        "content": "I find this solution by HelloWorld123456 to be very intuitive. \\n\\nhttps://leetcode.com/discuss/80600/java-easy-version-to-understand\\n\\nC# does not have native support for priority queue/heap. How can I write equivalent code that will be accepted by LeetCode? What is an acceptable alternative with O(lgn) insert and remove?"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This is a fun question but I feel as though it should be Medium Difficulty because it just involves a sorted array search and that computation is of medium difficulty."
                    },
                    {
                        "username": "nathan_code",
                        "content": "Hi, Everyone. I saw a interview follow up for this question \"what if data can\\'t fit into memory\"\\nso how can we handle this?  something about Divide and Conquer?\\nMany Thanks"
                    }
                ]
            },
            {
                "id": 1571547,
                "content": [
                    {
                        "username": "mukunda-",
                        "content": "Don\\'t build your algorithm around a counting sort due to the \"hints\": *If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?*\\n\\nSome of the tests do not follow this at all.\\n"
                    },
                    {
                        "username": "neelambuj2",
                        "content": "Please reply in comments"
                    },
                    {
                        "username": "Narayanadev",
                        "content": "Any idea on how to solve the follow-up questions?"
                    },
                    {
                        "username": "sergant_123",
                        "content": "Hello anyone please could tell me why it is passing only 20 testcases out of 21 is there any bug in last testcase\\n\\n\\n `class MedianFinder {\\npublic:\\n\\n   priority_queue<int> maxheap;\\n   priority_queue<int,vector<int>,greater<int>> minheap;\\n   double median;\\n\\n   int sgnum(int a,int b){\\n       if(a==b)\\n       return 0;\\n       else if(a>b)\\n       return 1;\\n       else\\n       return -1;\\n   }\\n\\n    MedianFinder() {\\n        this->median  = 0;\\n    }\\n    \\n    void addNum(int num) {\\n        switch(sgnum(maxheap.size(),minheap.size())){\\n            case 0:\\n            if(num>this->median){\\n                minheap.push(num);\\n            }\\n            else{\\n                maxheap.push(num);\\n            }\\n            break;\\n            case 1:\\n            if(num>this->median){\\n                minheap.push(num);\\n            }\\n            else{\\n                minheap.push(maxheap.top());\\n                maxheap.pop();\\n                maxheap.push(num);\\n            }\\n            break;\\n            case -1:\\n            if(num>this->median){\\n                maxheap.push(minheap.top());\\n                minheap.pop();\\n\\n                minheap.push(num);\\n            }\\n            else{\\n                maxheap.push(num);\\n            }\\n            break;\\n        }\\n\\n    }\\n    \\n    double findMedian() {\\n        if(maxheap.size()>minheap.size()){\\n            this->median  = maxheap.top();\\n        }\\n        else if(maxheap.size()<minheap.size()){\\n            this->median  = minheap.top();\\n        }\\n        else{\\n            this->median  = (maxheap.top()+minheap.top())/2.0;\\n        }\\n        return this->median;\\n    }\\n};`"
                    },
                    {
                        "username": "Vithesh",
                        "content": "typecaste it properly. maybe thats the issue...and do check the last testcase..."
                    },
                    {
                        "username": "GrandChieftain",
                        "content": "Same issue here. Compared the actual and expected outputs, both when submitting and running the testcase in isolation, and it keeps failing even though they\\'re the exact same."
                    },
                    {
                        "username": "csjobhelp2",
                        "content": "Aren\\'t they the same time complexity NlogN?  Why do the more complicated two heap?"
                    },
                    {
                        "username": "drsagitn",
                        "content": "My code succeeded on when try \"Run Code\" but failed on \"Submission\". Exact same testcase used. I dont know why??? Is this because of soem environment difference?\\n\\n![image](https://assets.leetcode.com/users/drsagitn/image_1580253193.png)\\n"
                    },
                    {
                        "username": "LizLemon777",
                        "content": "I'm just thinking of this idea, and it seems the majority of people here use two heaps. Has anyone tried two pointers (pointing to two middle values) and a doubly linked list? When adding a new value, compare it to the middle values, and place the value at the right place using binary search, and update middle value pointers. Does this idea work?"
                    },
                    {
                        "username": "vansharora03",
                        "content": "unfortunately you cannot perform a logn sorted insertion of a doubly linked list. I tried using a hashmap of indexes to nodes, but realized I would have to update the indexes anyways after insertion. "
                    },
                    {
                        "username": "meetug",
                        "content": "I find this solution by HelloWorld123456 to be very intuitive. \\n\\nhttps://leetcode.com/discuss/80600/java-easy-version-to-understand\\n\\nC# does not have native support for priority queue/heap. How can I write equivalent code that will be accepted by LeetCode? What is an acceptable alternative with O(lgn) insert and remove?"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This is a fun question but I feel as though it should be Medium Difficulty because it just involves a sorted array search and that computation is of medium difficulty."
                    },
                    {
                        "username": "nathan_code",
                        "content": "Hi, Everyone. I saw a interview follow up for this question \"what if data can\\'t fit into memory\"\\nso how can we handle this?  something about Divide and Conquer?\\nMany Thanks"
                    }
                ]
            },
            {
                "id": 1571546,
                "content": [
                    {
                        "username": "mukunda-",
                        "content": "Don\\'t build your algorithm around a counting sort due to the \"hints\": *If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?*\\n\\nSome of the tests do not follow this at all.\\n"
                    },
                    {
                        "username": "neelambuj2",
                        "content": "Please reply in comments"
                    },
                    {
                        "username": "Narayanadev",
                        "content": "Any idea on how to solve the follow-up questions?"
                    },
                    {
                        "username": "sergant_123",
                        "content": "Hello anyone please could tell me why it is passing only 20 testcases out of 21 is there any bug in last testcase\\n\\n\\n `class MedianFinder {\\npublic:\\n\\n   priority_queue<int> maxheap;\\n   priority_queue<int,vector<int>,greater<int>> minheap;\\n   double median;\\n\\n   int sgnum(int a,int b){\\n       if(a==b)\\n       return 0;\\n       else if(a>b)\\n       return 1;\\n       else\\n       return -1;\\n   }\\n\\n    MedianFinder() {\\n        this->median  = 0;\\n    }\\n    \\n    void addNum(int num) {\\n        switch(sgnum(maxheap.size(),minheap.size())){\\n            case 0:\\n            if(num>this->median){\\n                minheap.push(num);\\n            }\\n            else{\\n                maxheap.push(num);\\n            }\\n            break;\\n            case 1:\\n            if(num>this->median){\\n                minheap.push(num);\\n            }\\n            else{\\n                minheap.push(maxheap.top());\\n                maxheap.pop();\\n                maxheap.push(num);\\n            }\\n            break;\\n            case -1:\\n            if(num>this->median){\\n                maxheap.push(minheap.top());\\n                minheap.pop();\\n\\n                minheap.push(num);\\n            }\\n            else{\\n                maxheap.push(num);\\n            }\\n            break;\\n        }\\n\\n    }\\n    \\n    double findMedian() {\\n        if(maxheap.size()>minheap.size()){\\n            this->median  = maxheap.top();\\n        }\\n        else if(maxheap.size()<minheap.size()){\\n            this->median  = minheap.top();\\n        }\\n        else{\\n            this->median  = (maxheap.top()+minheap.top())/2.0;\\n        }\\n        return this->median;\\n    }\\n};`"
                    },
                    {
                        "username": "Vithesh",
                        "content": "typecaste it properly. maybe thats the issue...and do check the last testcase..."
                    },
                    {
                        "username": "GrandChieftain",
                        "content": "Same issue here. Compared the actual and expected outputs, both when submitting and running the testcase in isolation, and it keeps failing even though they\\'re the exact same."
                    },
                    {
                        "username": "csjobhelp2",
                        "content": "Aren\\'t they the same time complexity NlogN?  Why do the more complicated two heap?"
                    },
                    {
                        "username": "drsagitn",
                        "content": "My code succeeded on when try \"Run Code\" but failed on \"Submission\". Exact same testcase used. I dont know why??? Is this because of soem environment difference?\\n\\n![image](https://assets.leetcode.com/users/drsagitn/image_1580253193.png)\\n"
                    },
                    {
                        "username": "LizLemon777",
                        "content": "I'm just thinking of this idea, and it seems the majority of people here use two heaps. Has anyone tried two pointers (pointing to two middle values) and a doubly linked list? When adding a new value, compare it to the middle values, and place the value at the right place using binary search, and update middle value pointers. Does this idea work?"
                    },
                    {
                        "username": "vansharora03",
                        "content": "unfortunately you cannot perform a logn sorted insertion of a doubly linked list. I tried using a hashmap of indexes to nodes, but realized I would have to update the indexes anyways after insertion. "
                    },
                    {
                        "username": "meetug",
                        "content": "I find this solution by HelloWorld123456 to be very intuitive. \\n\\nhttps://leetcode.com/discuss/80600/java-easy-version-to-understand\\n\\nC# does not have native support for priority queue/heap. How can I write equivalent code that will be accepted by LeetCode? What is an acceptable alternative with O(lgn) insert and remove?"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This is a fun question but I feel as though it should be Medium Difficulty because it just involves a sorted array search and that computation is of medium difficulty."
                    },
                    {
                        "username": "nathan_code",
                        "content": "Hi, Everyone. I saw a interview follow up for this question \"what if data can\\'t fit into memory\"\\nso how can we handle this?  something about Divide and Conquer?\\nMany Thanks"
                    }
                ]
            },
            {
                "id": 1681260,
                "content": [
                    {
                        "username": "mukunda-",
                        "content": "Don\\'t build your algorithm around a counting sort due to the \"hints\": *If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?*\\n\\nSome of the tests do not follow this at all.\\n"
                    },
                    {
                        "username": "neelambuj2",
                        "content": "Please reply in comments"
                    },
                    {
                        "username": "Narayanadev",
                        "content": "Any idea on how to solve the follow-up questions?"
                    },
                    {
                        "username": "sergant_123",
                        "content": "Hello anyone please could tell me why it is passing only 20 testcases out of 21 is there any bug in last testcase\\n\\n\\n `class MedianFinder {\\npublic:\\n\\n   priority_queue<int> maxheap;\\n   priority_queue<int,vector<int>,greater<int>> minheap;\\n   double median;\\n\\n   int sgnum(int a,int b){\\n       if(a==b)\\n       return 0;\\n       else if(a>b)\\n       return 1;\\n       else\\n       return -1;\\n   }\\n\\n    MedianFinder() {\\n        this->median  = 0;\\n    }\\n    \\n    void addNum(int num) {\\n        switch(sgnum(maxheap.size(),minheap.size())){\\n            case 0:\\n            if(num>this->median){\\n                minheap.push(num);\\n            }\\n            else{\\n                maxheap.push(num);\\n            }\\n            break;\\n            case 1:\\n            if(num>this->median){\\n                minheap.push(num);\\n            }\\n            else{\\n                minheap.push(maxheap.top());\\n                maxheap.pop();\\n                maxheap.push(num);\\n            }\\n            break;\\n            case -1:\\n            if(num>this->median){\\n                maxheap.push(minheap.top());\\n                minheap.pop();\\n\\n                minheap.push(num);\\n            }\\n            else{\\n                maxheap.push(num);\\n            }\\n            break;\\n        }\\n\\n    }\\n    \\n    double findMedian() {\\n        if(maxheap.size()>minheap.size()){\\n            this->median  = maxheap.top();\\n        }\\n        else if(maxheap.size()<minheap.size()){\\n            this->median  = minheap.top();\\n        }\\n        else{\\n            this->median  = (maxheap.top()+minheap.top())/2.0;\\n        }\\n        return this->median;\\n    }\\n};`"
                    },
                    {
                        "username": "Vithesh",
                        "content": "typecaste it properly. maybe thats the issue...and do check the last testcase..."
                    },
                    {
                        "username": "GrandChieftain",
                        "content": "Same issue here. Compared the actual and expected outputs, both when submitting and running the testcase in isolation, and it keeps failing even though they\\'re the exact same."
                    },
                    {
                        "username": "csjobhelp2",
                        "content": "Aren\\'t they the same time complexity NlogN?  Why do the more complicated two heap?"
                    },
                    {
                        "username": "drsagitn",
                        "content": "My code succeeded on when try \"Run Code\" but failed on \"Submission\". Exact same testcase used. I dont know why??? Is this because of soem environment difference?\\n\\n![image](https://assets.leetcode.com/users/drsagitn/image_1580253193.png)\\n"
                    },
                    {
                        "username": "LizLemon777",
                        "content": "I'm just thinking of this idea, and it seems the majority of people here use two heaps. Has anyone tried two pointers (pointing to two middle values) and a doubly linked list? When adding a new value, compare it to the middle values, and place the value at the right place using binary search, and update middle value pointers. Does this idea work?"
                    },
                    {
                        "username": "vansharora03",
                        "content": "unfortunately you cannot perform a logn sorted insertion of a doubly linked list. I tried using a hashmap of indexes to nodes, but realized I would have to update the indexes anyways after insertion. "
                    },
                    {
                        "username": "meetug",
                        "content": "I find this solution by HelloWorld123456 to be very intuitive. \\n\\nhttps://leetcode.com/discuss/80600/java-easy-version-to-understand\\n\\nC# does not have native support for priority queue/heap. How can I write equivalent code that will be accepted by LeetCode? What is an acceptable alternative with O(lgn) insert and remove?"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This is a fun question but I feel as though it should be Medium Difficulty because it just involves a sorted array search and that computation is of medium difficulty."
                    },
                    {
                        "username": "nathan_code",
                        "content": "Hi, Everyone. I saw a interview follow up for this question \"what if data can\\'t fit into memory\"\\nso how can we handle this?  something about Divide and Conquer?\\nMany Thanks"
                    }
                ]
            },
            {
                "id": 1575156,
                "content": [
                    {
                        "username": "mukunda-",
                        "content": "Don\\'t build your algorithm around a counting sort due to the \"hints\": *If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?*\\n\\nSome of the tests do not follow this at all.\\n"
                    },
                    {
                        "username": "neelambuj2",
                        "content": "Please reply in comments"
                    },
                    {
                        "username": "Narayanadev",
                        "content": "Any idea on how to solve the follow-up questions?"
                    },
                    {
                        "username": "sergant_123",
                        "content": "Hello anyone please could tell me why it is passing only 20 testcases out of 21 is there any bug in last testcase\\n\\n\\n `class MedianFinder {\\npublic:\\n\\n   priority_queue<int> maxheap;\\n   priority_queue<int,vector<int>,greater<int>> minheap;\\n   double median;\\n\\n   int sgnum(int a,int b){\\n       if(a==b)\\n       return 0;\\n       else if(a>b)\\n       return 1;\\n       else\\n       return -1;\\n   }\\n\\n    MedianFinder() {\\n        this->median  = 0;\\n    }\\n    \\n    void addNum(int num) {\\n        switch(sgnum(maxheap.size(),minheap.size())){\\n            case 0:\\n            if(num>this->median){\\n                minheap.push(num);\\n            }\\n            else{\\n                maxheap.push(num);\\n            }\\n            break;\\n            case 1:\\n            if(num>this->median){\\n                minheap.push(num);\\n            }\\n            else{\\n                minheap.push(maxheap.top());\\n                maxheap.pop();\\n                maxheap.push(num);\\n            }\\n            break;\\n            case -1:\\n            if(num>this->median){\\n                maxheap.push(minheap.top());\\n                minheap.pop();\\n\\n                minheap.push(num);\\n            }\\n            else{\\n                maxheap.push(num);\\n            }\\n            break;\\n        }\\n\\n    }\\n    \\n    double findMedian() {\\n        if(maxheap.size()>minheap.size()){\\n            this->median  = maxheap.top();\\n        }\\n        else if(maxheap.size()<minheap.size()){\\n            this->median  = minheap.top();\\n        }\\n        else{\\n            this->median  = (maxheap.top()+minheap.top())/2.0;\\n        }\\n        return this->median;\\n    }\\n};`"
                    },
                    {
                        "username": "Vithesh",
                        "content": "typecaste it properly. maybe thats the issue...and do check the last testcase..."
                    },
                    {
                        "username": "GrandChieftain",
                        "content": "Same issue here. Compared the actual and expected outputs, both when submitting and running the testcase in isolation, and it keeps failing even though they\\'re the exact same."
                    },
                    {
                        "username": "csjobhelp2",
                        "content": "Aren\\'t they the same time complexity NlogN?  Why do the more complicated two heap?"
                    },
                    {
                        "username": "drsagitn",
                        "content": "My code succeeded on when try \"Run Code\" but failed on \"Submission\". Exact same testcase used. I dont know why??? Is this because of soem environment difference?\\n\\n![image](https://assets.leetcode.com/users/drsagitn/image_1580253193.png)\\n"
                    },
                    {
                        "username": "LizLemon777",
                        "content": "I'm just thinking of this idea, and it seems the majority of people here use two heaps. Has anyone tried two pointers (pointing to two middle values) and a doubly linked list? When adding a new value, compare it to the middle values, and place the value at the right place using binary search, and update middle value pointers. Does this idea work?"
                    },
                    {
                        "username": "vansharora03",
                        "content": "unfortunately you cannot perform a logn sorted insertion of a doubly linked list. I tried using a hashmap of indexes to nodes, but realized I would have to update the indexes anyways after insertion. "
                    },
                    {
                        "username": "meetug",
                        "content": "I find this solution by HelloWorld123456 to be very intuitive. \\n\\nhttps://leetcode.com/discuss/80600/java-easy-version-to-understand\\n\\nC# does not have native support for priority queue/heap. How can I write equivalent code that will be accepted by LeetCode? What is an acceptable alternative with O(lgn) insert and remove?"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This is a fun question but I feel as though it should be Medium Difficulty because it just involves a sorted array search and that computation is of medium difficulty."
                    },
                    {
                        "username": "nathan_code",
                        "content": "Hi, Everyone. I saw a interview follow up for this question \"what if data can\\'t fit into memory\"\\nso how can we handle this?  something about Divide and Conquer?\\nMany Thanks"
                    }
                ]
            },
            {
                "id": 2062053,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "this question is somewhere in between a medium and a hard problem. Beacuse the approach becomes so obvious once we think about max and min heaps.."
                    },
                    {
                        "username": "harshit_rathr3",
                        "content": " \\n`Why my code is not working giving TLE. The exact similar solution worked on other platform and also submitted by someone else in leetcode as well\\n`\\n\\ndef __init__(self):\\n        self.max_heap = []\\n        self.min_heap = []\\n        \\n    def addNum(self, num: int) -> None:\\n        if self.max_heap and self.max_heap[0]>num:\\n            self.max_heap.append(num)\\n            heapq._heapify_max(self.max_heap)\\n        else:\\n            heapq.heappush(self.min_heap, num)\\n        diff = len(self.max_heap) - len(self.min_heap)\\n\\n        if diff>1:\\n            heapq.heappush(self.min_heap, heapq._heappop_max(self.max_heap))\\n        if diff<-1:\\n            self.max_heap.append(heapq.heappop(self.min_heap))\\n            heapq._heapify_max(self.max_heap)\\n        \\n\\n    def findMedian(self) -> float:\\n        diff = len(self.max_heap) - len(self.min_heap)\\n\\n        if diff==0:\\n            return (self.max_heap[0] + self.min_heap[0])/2\\n        elif diff>0:\\n            return self.max_heap[0]\\n        else:\\n            return self.min_heap[0]`\\n \\n"
                    },
                    {
                        "username": "thicktruyenche9",
                        "content": "i wonder if input number list get sorted ?"
                    },
                    {
                        "username": "khushmeetchugh",
                        "content": "Trying to do this question using quick select but still time limit exceeding in large data set (testcase 16)"
                    },
                    {
                        "username": "sid9812",
                        "content": "How do we approach the follow ups? "
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "works using ordered map"
                    },
                    {
                        "username": "elizfitz",
                        "content": "I think there\\'s a bug on the testcases. It says I have passed them all, but also that I have a TLE. However, the last executed input is empty. "
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Using multiset doesn\\'t give TLE \\uD83D\\uDC4D"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Should be medium tbh"
                    },
                    {
                        "username": "NakulJaju",
                        "content": "What\\'s wrong with this approach?\\nI\\'m always balancing the 2 heaps, and maxHeap will have 1 extra number if at all sizes are different.\\n\\nMy code below is giving runtime error:\\nruntime error: reference binding to null pointer of type \\'const int\\' (stl_iterator.h)\\n\\n\\nclass MedianFinder {\\nprivate:\\n    priority_queue<int> maxHeap;\\n    priority_queue<int, vector<int>, greater<int>> minHeap;\\n\\npublic:\\n    MedianFinder() {\\n        \\n    }\\n    \\n    void addNum(int num) {\\n        if(maxHeap.size()==0) maxHeap.push(num);\\n        else if(maxHeap.size()==minHeap.size()){\\n            if(num<maxHeap.top()){\\n                maxHeap.push(num);\\n            }else if(num>minHeap.top()){\\n                int temp = minHeap.top();\\n                minHeap.pop();\\n                maxHeap.push(temp);\\n                minHeap.push(num);\\n            }else{\\n                maxHeap.push(num);\\n            }\\n        }else{\\n            if(num<maxHeap.top()){\\n                int temp = maxHeap.top();\\n                maxHeap.pop();\\n                minHeap.push(temp);\\n                maxHeap.push(num);\\n                // maxHeap.push(num);\\n            }else if(num>minHeap.top()){\\n                minHeap.push(num);\\n            }else{\\n                int temp = maxHeap.top();\\n                maxHeap.pop();\\n                minHeap.push(temp);\\n                maxHeap.push(num);\\n            }\\n        }\\n\\n    }\\n    \\n    double findMedian() {\\n        double ans;\\n        if(maxHeap.size()==minHeap.size()){\\n            ans = (maxHeap.top()+minHeap.top())/2;\\n        }else ans = maxHeap.top();\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder* obj = new MedianFinder();\\n * obj->addNum(num);\\n * double param_2 = obj->findMedian();\\n */\\n"
                    },
                    {
                        "username": "NakulJaju",
                        "content": "[@codepiyush1](/codepiyush1) Hi I\\'ve written a code such that when the heap sizes are equal and an element comes I\\'ll balance the heaps such that the new element goes to the maxHeap always \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Bro U r not checking the heap size.\\nOnly once u checked both heap equal or not.\\nelse if(maxHeap.size()==minHeap.size())\\n\\\\\\nNote: In Else condition.\\nthere may be the difference between both heap is more than one because u haven\\'t  check the heap size of both heap.\\n\\nCheck Out this solution\\nhttps://leetcode.com/problems/find-median-from-data-stream/solutions/3629630/c-undestand-the-concept/\\n\\nIf Understand Please Upvote."
                    }
                ]
            },
            {
                "id": 2062000,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "this question is somewhere in between a medium and a hard problem. Beacuse the approach becomes so obvious once we think about max and min heaps.."
                    },
                    {
                        "username": "harshit_rathr3",
                        "content": " \\n`Why my code is not working giving TLE. The exact similar solution worked on other platform and also submitted by someone else in leetcode as well\\n`\\n\\ndef __init__(self):\\n        self.max_heap = []\\n        self.min_heap = []\\n        \\n    def addNum(self, num: int) -> None:\\n        if self.max_heap and self.max_heap[0]>num:\\n            self.max_heap.append(num)\\n            heapq._heapify_max(self.max_heap)\\n        else:\\n            heapq.heappush(self.min_heap, num)\\n        diff = len(self.max_heap) - len(self.min_heap)\\n\\n        if diff>1:\\n            heapq.heappush(self.min_heap, heapq._heappop_max(self.max_heap))\\n        if diff<-1:\\n            self.max_heap.append(heapq.heappop(self.min_heap))\\n            heapq._heapify_max(self.max_heap)\\n        \\n\\n    def findMedian(self) -> float:\\n        diff = len(self.max_heap) - len(self.min_heap)\\n\\n        if diff==0:\\n            return (self.max_heap[0] + self.min_heap[0])/2\\n        elif diff>0:\\n            return self.max_heap[0]\\n        else:\\n            return self.min_heap[0]`\\n \\n"
                    },
                    {
                        "username": "thicktruyenche9",
                        "content": "i wonder if input number list get sorted ?"
                    },
                    {
                        "username": "khushmeetchugh",
                        "content": "Trying to do this question using quick select but still time limit exceeding in large data set (testcase 16)"
                    },
                    {
                        "username": "sid9812",
                        "content": "How do we approach the follow ups? "
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "works using ordered map"
                    },
                    {
                        "username": "elizfitz",
                        "content": "I think there\\'s a bug on the testcases. It says I have passed them all, but also that I have a TLE. However, the last executed input is empty. "
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Using multiset doesn\\'t give TLE \\uD83D\\uDC4D"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Should be medium tbh"
                    },
                    {
                        "username": "NakulJaju",
                        "content": "What\\'s wrong with this approach?\\nI\\'m always balancing the 2 heaps, and maxHeap will have 1 extra number if at all sizes are different.\\n\\nMy code below is giving runtime error:\\nruntime error: reference binding to null pointer of type \\'const int\\' (stl_iterator.h)\\n\\n\\nclass MedianFinder {\\nprivate:\\n    priority_queue<int> maxHeap;\\n    priority_queue<int, vector<int>, greater<int>> minHeap;\\n\\npublic:\\n    MedianFinder() {\\n        \\n    }\\n    \\n    void addNum(int num) {\\n        if(maxHeap.size()==0) maxHeap.push(num);\\n        else if(maxHeap.size()==minHeap.size()){\\n            if(num<maxHeap.top()){\\n                maxHeap.push(num);\\n            }else if(num>minHeap.top()){\\n                int temp = minHeap.top();\\n                minHeap.pop();\\n                maxHeap.push(temp);\\n                minHeap.push(num);\\n            }else{\\n                maxHeap.push(num);\\n            }\\n        }else{\\n            if(num<maxHeap.top()){\\n                int temp = maxHeap.top();\\n                maxHeap.pop();\\n                minHeap.push(temp);\\n                maxHeap.push(num);\\n                // maxHeap.push(num);\\n            }else if(num>minHeap.top()){\\n                minHeap.push(num);\\n            }else{\\n                int temp = maxHeap.top();\\n                maxHeap.pop();\\n                minHeap.push(temp);\\n                maxHeap.push(num);\\n            }\\n        }\\n\\n    }\\n    \\n    double findMedian() {\\n        double ans;\\n        if(maxHeap.size()==minHeap.size()){\\n            ans = (maxHeap.top()+minHeap.top())/2;\\n        }else ans = maxHeap.top();\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder* obj = new MedianFinder();\\n * obj->addNum(num);\\n * double param_2 = obj->findMedian();\\n */\\n"
                    },
                    {
                        "username": "NakulJaju",
                        "content": "[@codepiyush1](/codepiyush1) Hi I\\'ve written a code such that when the heap sizes are equal and an element comes I\\'ll balance the heaps such that the new element goes to the maxHeap always \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Bro U r not checking the heap size.\\nOnly once u checked both heap equal or not.\\nelse if(maxHeap.size()==minHeap.size())\\n\\\\\\nNote: In Else condition.\\nthere may be the difference between both heap is more than one because u haven\\'t  check the heap size of both heap.\\n\\nCheck Out this solution\\nhttps://leetcode.com/problems/find-median-from-data-stream/solutions/3629630/c-undestand-the-concept/\\n\\nIf Understand Please Upvote."
                    }
                ]
            },
            {
                "id": 2054094,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "this question is somewhere in between a medium and a hard problem. Beacuse the approach becomes so obvious once we think about max and min heaps.."
                    },
                    {
                        "username": "harshit_rathr3",
                        "content": " \\n`Why my code is not working giving TLE. The exact similar solution worked on other platform and also submitted by someone else in leetcode as well\\n`\\n\\ndef __init__(self):\\n        self.max_heap = []\\n        self.min_heap = []\\n        \\n    def addNum(self, num: int) -> None:\\n        if self.max_heap and self.max_heap[0]>num:\\n            self.max_heap.append(num)\\n            heapq._heapify_max(self.max_heap)\\n        else:\\n            heapq.heappush(self.min_heap, num)\\n        diff = len(self.max_heap) - len(self.min_heap)\\n\\n        if diff>1:\\n            heapq.heappush(self.min_heap, heapq._heappop_max(self.max_heap))\\n        if diff<-1:\\n            self.max_heap.append(heapq.heappop(self.min_heap))\\n            heapq._heapify_max(self.max_heap)\\n        \\n\\n    def findMedian(self) -> float:\\n        diff = len(self.max_heap) - len(self.min_heap)\\n\\n        if diff==0:\\n            return (self.max_heap[0] + self.min_heap[0])/2\\n        elif diff>0:\\n            return self.max_heap[0]\\n        else:\\n            return self.min_heap[0]`\\n \\n"
                    },
                    {
                        "username": "thicktruyenche9",
                        "content": "i wonder if input number list get sorted ?"
                    },
                    {
                        "username": "khushmeetchugh",
                        "content": "Trying to do this question using quick select but still time limit exceeding in large data set (testcase 16)"
                    },
                    {
                        "username": "sid9812",
                        "content": "How do we approach the follow ups? "
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "works using ordered map"
                    },
                    {
                        "username": "elizfitz",
                        "content": "I think there\\'s a bug on the testcases. It says I have passed them all, but also that I have a TLE. However, the last executed input is empty. "
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Using multiset doesn\\'t give TLE \\uD83D\\uDC4D"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Should be medium tbh"
                    },
                    {
                        "username": "NakulJaju",
                        "content": "What\\'s wrong with this approach?\\nI\\'m always balancing the 2 heaps, and maxHeap will have 1 extra number if at all sizes are different.\\n\\nMy code below is giving runtime error:\\nruntime error: reference binding to null pointer of type \\'const int\\' (stl_iterator.h)\\n\\n\\nclass MedianFinder {\\nprivate:\\n    priority_queue<int> maxHeap;\\n    priority_queue<int, vector<int>, greater<int>> minHeap;\\n\\npublic:\\n    MedianFinder() {\\n        \\n    }\\n    \\n    void addNum(int num) {\\n        if(maxHeap.size()==0) maxHeap.push(num);\\n        else if(maxHeap.size()==minHeap.size()){\\n            if(num<maxHeap.top()){\\n                maxHeap.push(num);\\n            }else if(num>minHeap.top()){\\n                int temp = minHeap.top();\\n                minHeap.pop();\\n                maxHeap.push(temp);\\n                minHeap.push(num);\\n            }else{\\n                maxHeap.push(num);\\n            }\\n        }else{\\n            if(num<maxHeap.top()){\\n                int temp = maxHeap.top();\\n                maxHeap.pop();\\n                minHeap.push(temp);\\n                maxHeap.push(num);\\n                // maxHeap.push(num);\\n            }else if(num>minHeap.top()){\\n                minHeap.push(num);\\n            }else{\\n                int temp = maxHeap.top();\\n                maxHeap.pop();\\n                minHeap.push(temp);\\n                maxHeap.push(num);\\n            }\\n        }\\n\\n    }\\n    \\n    double findMedian() {\\n        double ans;\\n        if(maxHeap.size()==minHeap.size()){\\n            ans = (maxHeap.top()+minHeap.top())/2;\\n        }else ans = maxHeap.top();\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder* obj = new MedianFinder();\\n * obj->addNum(num);\\n * double param_2 = obj->findMedian();\\n */\\n"
                    },
                    {
                        "username": "NakulJaju",
                        "content": "[@codepiyush1](/codepiyush1) Hi I\\'ve written a code such that when the heap sizes are equal and an element comes I\\'ll balance the heaps such that the new element goes to the maxHeap always \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Bro U r not checking the heap size.\\nOnly once u checked both heap equal or not.\\nelse if(maxHeap.size()==minHeap.size())\\n\\\\\\nNote: In Else condition.\\nthere may be the difference between both heap is more than one because u haven\\'t  check the heap size of both heap.\\n\\nCheck Out this solution\\nhttps://leetcode.com/problems/find-median-from-data-stream/solutions/3629630/c-undestand-the-concept/\\n\\nIf Understand Please Upvote."
                    }
                ]
            },
            {
                "id": 2016944,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "this question is somewhere in between a medium and a hard problem. Beacuse the approach becomes so obvious once we think about max and min heaps.."
                    },
                    {
                        "username": "harshit_rathr3",
                        "content": " \\n`Why my code is not working giving TLE. The exact similar solution worked on other platform and also submitted by someone else in leetcode as well\\n`\\n\\ndef __init__(self):\\n        self.max_heap = []\\n        self.min_heap = []\\n        \\n    def addNum(self, num: int) -> None:\\n        if self.max_heap and self.max_heap[0]>num:\\n            self.max_heap.append(num)\\n            heapq._heapify_max(self.max_heap)\\n        else:\\n            heapq.heappush(self.min_heap, num)\\n        diff = len(self.max_heap) - len(self.min_heap)\\n\\n        if diff>1:\\n            heapq.heappush(self.min_heap, heapq._heappop_max(self.max_heap))\\n        if diff<-1:\\n            self.max_heap.append(heapq.heappop(self.min_heap))\\n            heapq._heapify_max(self.max_heap)\\n        \\n\\n    def findMedian(self) -> float:\\n        diff = len(self.max_heap) - len(self.min_heap)\\n\\n        if diff==0:\\n            return (self.max_heap[0] + self.min_heap[0])/2\\n        elif diff>0:\\n            return self.max_heap[0]\\n        else:\\n            return self.min_heap[0]`\\n \\n"
                    },
                    {
                        "username": "thicktruyenche9",
                        "content": "i wonder if input number list get sorted ?"
                    },
                    {
                        "username": "khushmeetchugh",
                        "content": "Trying to do this question using quick select but still time limit exceeding in large data set (testcase 16)"
                    },
                    {
                        "username": "sid9812",
                        "content": "How do we approach the follow ups? "
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "works using ordered map"
                    },
                    {
                        "username": "elizfitz",
                        "content": "I think there\\'s a bug on the testcases. It says I have passed them all, but also that I have a TLE. However, the last executed input is empty. "
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Using multiset doesn\\'t give TLE \\uD83D\\uDC4D"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Should be medium tbh"
                    },
                    {
                        "username": "NakulJaju",
                        "content": "What\\'s wrong with this approach?\\nI\\'m always balancing the 2 heaps, and maxHeap will have 1 extra number if at all sizes are different.\\n\\nMy code below is giving runtime error:\\nruntime error: reference binding to null pointer of type \\'const int\\' (stl_iterator.h)\\n\\n\\nclass MedianFinder {\\nprivate:\\n    priority_queue<int> maxHeap;\\n    priority_queue<int, vector<int>, greater<int>> minHeap;\\n\\npublic:\\n    MedianFinder() {\\n        \\n    }\\n    \\n    void addNum(int num) {\\n        if(maxHeap.size()==0) maxHeap.push(num);\\n        else if(maxHeap.size()==minHeap.size()){\\n            if(num<maxHeap.top()){\\n                maxHeap.push(num);\\n            }else if(num>minHeap.top()){\\n                int temp = minHeap.top();\\n                minHeap.pop();\\n                maxHeap.push(temp);\\n                minHeap.push(num);\\n            }else{\\n                maxHeap.push(num);\\n            }\\n        }else{\\n            if(num<maxHeap.top()){\\n                int temp = maxHeap.top();\\n                maxHeap.pop();\\n                minHeap.push(temp);\\n                maxHeap.push(num);\\n                // maxHeap.push(num);\\n            }else if(num>minHeap.top()){\\n                minHeap.push(num);\\n            }else{\\n                int temp = maxHeap.top();\\n                maxHeap.pop();\\n                minHeap.push(temp);\\n                maxHeap.push(num);\\n            }\\n        }\\n\\n    }\\n    \\n    double findMedian() {\\n        double ans;\\n        if(maxHeap.size()==minHeap.size()){\\n            ans = (maxHeap.top()+minHeap.top())/2;\\n        }else ans = maxHeap.top();\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder* obj = new MedianFinder();\\n * obj->addNum(num);\\n * double param_2 = obj->findMedian();\\n */\\n"
                    },
                    {
                        "username": "NakulJaju",
                        "content": "[@codepiyush1](/codepiyush1) Hi I\\'ve written a code such that when the heap sizes are equal and an element comes I\\'ll balance the heaps such that the new element goes to the maxHeap always \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Bro U r not checking the heap size.\\nOnly once u checked both heap equal or not.\\nelse if(maxHeap.size()==minHeap.size())\\n\\\\\\nNote: In Else condition.\\nthere may be the difference between both heap is more than one because u haven\\'t  check the heap size of both heap.\\n\\nCheck Out this solution\\nhttps://leetcode.com/problems/find-median-from-data-stream/solutions/3629630/c-undestand-the-concept/\\n\\nIf Understand Please Upvote."
                    }
                ]
            },
            {
                "id": 2001435,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "this question is somewhere in between a medium and a hard problem. Beacuse the approach becomes so obvious once we think about max and min heaps.."
                    },
                    {
                        "username": "harshit_rathr3",
                        "content": " \\n`Why my code is not working giving TLE. The exact similar solution worked on other platform and also submitted by someone else in leetcode as well\\n`\\n\\ndef __init__(self):\\n        self.max_heap = []\\n        self.min_heap = []\\n        \\n    def addNum(self, num: int) -> None:\\n        if self.max_heap and self.max_heap[0]>num:\\n            self.max_heap.append(num)\\n            heapq._heapify_max(self.max_heap)\\n        else:\\n            heapq.heappush(self.min_heap, num)\\n        diff = len(self.max_heap) - len(self.min_heap)\\n\\n        if diff>1:\\n            heapq.heappush(self.min_heap, heapq._heappop_max(self.max_heap))\\n        if diff<-1:\\n            self.max_heap.append(heapq.heappop(self.min_heap))\\n            heapq._heapify_max(self.max_heap)\\n        \\n\\n    def findMedian(self) -> float:\\n        diff = len(self.max_heap) - len(self.min_heap)\\n\\n        if diff==0:\\n            return (self.max_heap[0] + self.min_heap[0])/2\\n        elif diff>0:\\n            return self.max_heap[0]\\n        else:\\n            return self.min_heap[0]`\\n \\n"
                    },
                    {
                        "username": "thicktruyenche9",
                        "content": "i wonder if input number list get sorted ?"
                    },
                    {
                        "username": "khushmeetchugh",
                        "content": "Trying to do this question using quick select but still time limit exceeding in large data set (testcase 16)"
                    },
                    {
                        "username": "sid9812",
                        "content": "How do we approach the follow ups? "
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "works using ordered map"
                    },
                    {
                        "username": "elizfitz",
                        "content": "I think there\\'s a bug on the testcases. It says I have passed them all, but also that I have a TLE. However, the last executed input is empty. "
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Using multiset doesn\\'t give TLE \\uD83D\\uDC4D"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Should be medium tbh"
                    },
                    {
                        "username": "NakulJaju",
                        "content": "What\\'s wrong with this approach?\\nI\\'m always balancing the 2 heaps, and maxHeap will have 1 extra number if at all sizes are different.\\n\\nMy code below is giving runtime error:\\nruntime error: reference binding to null pointer of type \\'const int\\' (stl_iterator.h)\\n\\n\\nclass MedianFinder {\\nprivate:\\n    priority_queue<int> maxHeap;\\n    priority_queue<int, vector<int>, greater<int>> minHeap;\\n\\npublic:\\n    MedianFinder() {\\n        \\n    }\\n    \\n    void addNum(int num) {\\n        if(maxHeap.size()==0) maxHeap.push(num);\\n        else if(maxHeap.size()==minHeap.size()){\\n            if(num<maxHeap.top()){\\n                maxHeap.push(num);\\n            }else if(num>minHeap.top()){\\n                int temp = minHeap.top();\\n                minHeap.pop();\\n                maxHeap.push(temp);\\n                minHeap.push(num);\\n            }else{\\n                maxHeap.push(num);\\n            }\\n        }else{\\n            if(num<maxHeap.top()){\\n                int temp = maxHeap.top();\\n                maxHeap.pop();\\n                minHeap.push(temp);\\n                maxHeap.push(num);\\n                // maxHeap.push(num);\\n            }else if(num>minHeap.top()){\\n                minHeap.push(num);\\n            }else{\\n                int temp = maxHeap.top();\\n                maxHeap.pop();\\n                minHeap.push(temp);\\n                maxHeap.push(num);\\n            }\\n        }\\n\\n    }\\n    \\n    double findMedian() {\\n        double ans;\\n        if(maxHeap.size()==minHeap.size()){\\n            ans = (maxHeap.top()+minHeap.top())/2;\\n        }else ans = maxHeap.top();\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder* obj = new MedianFinder();\\n * obj->addNum(num);\\n * double param_2 = obj->findMedian();\\n */\\n"
                    },
                    {
                        "username": "NakulJaju",
                        "content": "[@codepiyush1](/codepiyush1) Hi I\\'ve written a code such that when the heap sizes are equal and an element comes I\\'ll balance the heaps such that the new element goes to the maxHeap always \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Bro U r not checking the heap size.\\nOnly once u checked both heap equal or not.\\nelse if(maxHeap.size()==minHeap.size())\\n\\\\\\nNote: In Else condition.\\nthere may be the difference between both heap is more than one because u haven\\'t  check the heap size of both heap.\\n\\nCheck Out this solution\\nhttps://leetcode.com/problems/find-median-from-data-stream/solutions/3629630/c-undestand-the-concept/\\n\\nIf Understand Please Upvote."
                    }
                ]
            },
            {
                "id": 1997090,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "this question is somewhere in between a medium and a hard problem. Beacuse the approach becomes so obvious once we think about max and min heaps.."
                    },
                    {
                        "username": "harshit_rathr3",
                        "content": " \\n`Why my code is not working giving TLE. The exact similar solution worked on other platform and also submitted by someone else in leetcode as well\\n`\\n\\ndef __init__(self):\\n        self.max_heap = []\\n        self.min_heap = []\\n        \\n    def addNum(self, num: int) -> None:\\n        if self.max_heap and self.max_heap[0]>num:\\n            self.max_heap.append(num)\\n            heapq._heapify_max(self.max_heap)\\n        else:\\n            heapq.heappush(self.min_heap, num)\\n        diff = len(self.max_heap) - len(self.min_heap)\\n\\n        if diff>1:\\n            heapq.heappush(self.min_heap, heapq._heappop_max(self.max_heap))\\n        if diff<-1:\\n            self.max_heap.append(heapq.heappop(self.min_heap))\\n            heapq._heapify_max(self.max_heap)\\n        \\n\\n    def findMedian(self) -> float:\\n        diff = len(self.max_heap) - len(self.min_heap)\\n\\n        if diff==0:\\n            return (self.max_heap[0] + self.min_heap[0])/2\\n        elif diff>0:\\n            return self.max_heap[0]\\n        else:\\n            return self.min_heap[0]`\\n \\n"
                    },
                    {
                        "username": "thicktruyenche9",
                        "content": "i wonder if input number list get sorted ?"
                    },
                    {
                        "username": "khushmeetchugh",
                        "content": "Trying to do this question using quick select but still time limit exceeding in large data set (testcase 16)"
                    },
                    {
                        "username": "sid9812",
                        "content": "How do we approach the follow ups? "
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "works using ordered map"
                    },
                    {
                        "username": "elizfitz",
                        "content": "I think there\\'s a bug on the testcases. It says I have passed them all, but also that I have a TLE. However, the last executed input is empty. "
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Using multiset doesn\\'t give TLE \\uD83D\\uDC4D"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Should be medium tbh"
                    },
                    {
                        "username": "NakulJaju",
                        "content": "What\\'s wrong with this approach?\\nI\\'m always balancing the 2 heaps, and maxHeap will have 1 extra number if at all sizes are different.\\n\\nMy code below is giving runtime error:\\nruntime error: reference binding to null pointer of type \\'const int\\' (stl_iterator.h)\\n\\n\\nclass MedianFinder {\\nprivate:\\n    priority_queue<int> maxHeap;\\n    priority_queue<int, vector<int>, greater<int>> minHeap;\\n\\npublic:\\n    MedianFinder() {\\n        \\n    }\\n    \\n    void addNum(int num) {\\n        if(maxHeap.size()==0) maxHeap.push(num);\\n        else if(maxHeap.size()==minHeap.size()){\\n            if(num<maxHeap.top()){\\n                maxHeap.push(num);\\n            }else if(num>minHeap.top()){\\n                int temp = minHeap.top();\\n                minHeap.pop();\\n                maxHeap.push(temp);\\n                minHeap.push(num);\\n            }else{\\n                maxHeap.push(num);\\n            }\\n        }else{\\n            if(num<maxHeap.top()){\\n                int temp = maxHeap.top();\\n                maxHeap.pop();\\n                minHeap.push(temp);\\n                maxHeap.push(num);\\n                // maxHeap.push(num);\\n            }else if(num>minHeap.top()){\\n                minHeap.push(num);\\n            }else{\\n                int temp = maxHeap.top();\\n                maxHeap.pop();\\n                minHeap.push(temp);\\n                maxHeap.push(num);\\n            }\\n        }\\n\\n    }\\n    \\n    double findMedian() {\\n        double ans;\\n        if(maxHeap.size()==minHeap.size()){\\n            ans = (maxHeap.top()+minHeap.top())/2;\\n        }else ans = maxHeap.top();\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder* obj = new MedianFinder();\\n * obj->addNum(num);\\n * double param_2 = obj->findMedian();\\n */\\n"
                    },
                    {
                        "username": "NakulJaju",
                        "content": "[@codepiyush1](/codepiyush1) Hi I\\'ve written a code such that when the heap sizes are equal and an element comes I\\'ll balance the heaps such that the new element goes to the maxHeap always \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Bro U r not checking the heap size.\\nOnly once u checked both heap equal or not.\\nelse if(maxHeap.size()==minHeap.size())\\n\\\\\\nNote: In Else condition.\\nthere may be the difference between both heap is more than one because u haven\\'t  check the heap size of both heap.\\n\\nCheck Out this solution\\nhttps://leetcode.com/problems/find-median-from-data-stream/solutions/3629630/c-undestand-the-concept/\\n\\nIf Understand Please Upvote."
                    }
                ]
            },
            {
                "id": 1990946,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "this question is somewhere in between a medium and a hard problem. Beacuse the approach becomes so obvious once we think about max and min heaps.."
                    },
                    {
                        "username": "harshit_rathr3",
                        "content": " \\n`Why my code is not working giving TLE. The exact similar solution worked on other platform and also submitted by someone else in leetcode as well\\n`\\n\\ndef __init__(self):\\n        self.max_heap = []\\n        self.min_heap = []\\n        \\n    def addNum(self, num: int) -> None:\\n        if self.max_heap and self.max_heap[0]>num:\\n            self.max_heap.append(num)\\n            heapq._heapify_max(self.max_heap)\\n        else:\\n            heapq.heappush(self.min_heap, num)\\n        diff = len(self.max_heap) - len(self.min_heap)\\n\\n        if diff>1:\\n            heapq.heappush(self.min_heap, heapq._heappop_max(self.max_heap))\\n        if diff<-1:\\n            self.max_heap.append(heapq.heappop(self.min_heap))\\n            heapq._heapify_max(self.max_heap)\\n        \\n\\n    def findMedian(self) -> float:\\n        diff = len(self.max_heap) - len(self.min_heap)\\n\\n        if diff==0:\\n            return (self.max_heap[0] + self.min_heap[0])/2\\n        elif diff>0:\\n            return self.max_heap[0]\\n        else:\\n            return self.min_heap[0]`\\n \\n"
                    },
                    {
                        "username": "thicktruyenche9",
                        "content": "i wonder if input number list get sorted ?"
                    },
                    {
                        "username": "khushmeetchugh",
                        "content": "Trying to do this question using quick select but still time limit exceeding in large data set (testcase 16)"
                    },
                    {
                        "username": "sid9812",
                        "content": "How do we approach the follow ups? "
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "works using ordered map"
                    },
                    {
                        "username": "elizfitz",
                        "content": "I think there\\'s a bug on the testcases. It says I have passed them all, but also that I have a TLE. However, the last executed input is empty. "
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Using multiset doesn\\'t give TLE \\uD83D\\uDC4D"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Should be medium tbh"
                    },
                    {
                        "username": "NakulJaju",
                        "content": "What\\'s wrong with this approach?\\nI\\'m always balancing the 2 heaps, and maxHeap will have 1 extra number if at all sizes are different.\\n\\nMy code below is giving runtime error:\\nruntime error: reference binding to null pointer of type \\'const int\\' (stl_iterator.h)\\n\\n\\nclass MedianFinder {\\nprivate:\\n    priority_queue<int> maxHeap;\\n    priority_queue<int, vector<int>, greater<int>> minHeap;\\n\\npublic:\\n    MedianFinder() {\\n        \\n    }\\n    \\n    void addNum(int num) {\\n        if(maxHeap.size()==0) maxHeap.push(num);\\n        else if(maxHeap.size()==minHeap.size()){\\n            if(num<maxHeap.top()){\\n                maxHeap.push(num);\\n            }else if(num>minHeap.top()){\\n                int temp = minHeap.top();\\n                minHeap.pop();\\n                maxHeap.push(temp);\\n                minHeap.push(num);\\n            }else{\\n                maxHeap.push(num);\\n            }\\n        }else{\\n            if(num<maxHeap.top()){\\n                int temp = maxHeap.top();\\n                maxHeap.pop();\\n                minHeap.push(temp);\\n                maxHeap.push(num);\\n                // maxHeap.push(num);\\n            }else if(num>minHeap.top()){\\n                minHeap.push(num);\\n            }else{\\n                int temp = maxHeap.top();\\n                maxHeap.pop();\\n                minHeap.push(temp);\\n                maxHeap.push(num);\\n            }\\n        }\\n\\n    }\\n    \\n    double findMedian() {\\n        double ans;\\n        if(maxHeap.size()==minHeap.size()){\\n            ans = (maxHeap.top()+minHeap.top())/2;\\n        }else ans = maxHeap.top();\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder* obj = new MedianFinder();\\n * obj->addNum(num);\\n * double param_2 = obj->findMedian();\\n */\\n"
                    },
                    {
                        "username": "NakulJaju",
                        "content": "[@codepiyush1](/codepiyush1) Hi I\\'ve written a code such that when the heap sizes are equal and an element comes I\\'ll balance the heaps such that the new element goes to the maxHeap always \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Bro U r not checking the heap size.\\nOnly once u checked both heap equal or not.\\nelse if(maxHeap.size()==minHeap.size())\\n\\\\\\nNote: In Else condition.\\nthere may be the difference between both heap is more than one because u haven\\'t  check the heap size of both heap.\\n\\nCheck Out this solution\\nhttps://leetcode.com/problems/find-median-from-data-stream/solutions/3629630/c-undestand-the-concept/\\n\\nIf Understand Please Upvote."
                    }
                ]
            },
            {
                "id": 1971601,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "this question is somewhere in between a medium and a hard problem. Beacuse the approach becomes so obvious once we think about max and min heaps.."
                    },
                    {
                        "username": "harshit_rathr3",
                        "content": " \\n`Why my code is not working giving TLE. The exact similar solution worked on other platform and also submitted by someone else in leetcode as well\\n`\\n\\ndef __init__(self):\\n        self.max_heap = []\\n        self.min_heap = []\\n        \\n    def addNum(self, num: int) -> None:\\n        if self.max_heap and self.max_heap[0]>num:\\n            self.max_heap.append(num)\\n            heapq._heapify_max(self.max_heap)\\n        else:\\n            heapq.heappush(self.min_heap, num)\\n        diff = len(self.max_heap) - len(self.min_heap)\\n\\n        if diff>1:\\n            heapq.heappush(self.min_heap, heapq._heappop_max(self.max_heap))\\n        if diff<-1:\\n            self.max_heap.append(heapq.heappop(self.min_heap))\\n            heapq._heapify_max(self.max_heap)\\n        \\n\\n    def findMedian(self) -> float:\\n        diff = len(self.max_heap) - len(self.min_heap)\\n\\n        if diff==0:\\n            return (self.max_heap[0] + self.min_heap[0])/2\\n        elif diff>0:\\n            return self.max_heap[0]\\n        else:\\n            return self.min_heap[0]`\\n \\n"
                    },
                    {
                        "username": "thicktruyenche9",
                        "content": "i wonder if input number list get sorted ?"
                    },
                    {
                        "username": "khushmeetchugh",
                        "content": "Trying to do this question using quick select but still time limit exceeding in large data set (testcase 16)"
                    },
                    {
                        "username": "sid9812",
                        "content": "How do we approach the follow ups? "
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "works using ordered map"
                    },
                    {
                        "username": "elizfitz",
                        "content": "I think there\\'s a bug on the testcases. It says I have passed them all, but also that I have a TLE. However, the last executed input is empty. "
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Using multiset doesn\\'t give TLE \\uD83D\\uDC4D"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Should be medium tbh"
                    },
                    {
                        "username": "NakulJaju",
                        "content": "What\\'s wrong with this approach?\\nI\\'m always balancing the 2 heaps, and maxHeap will have 1 extra number if at all sizes are different.\\n\\nMy code below is giving runtime error:\\nruntime error: reference binding to null pointer of type \\'const int\\' (stl_iterator.h)\\n\\n\\nclass MedianFinder {\\nprivate:\\n    priority_queue<int> maxHeap;\\n    priority_queue<int, vector<int>, greater<int>> minHeap;\\n\\npublic:\\n    MedianFinder() {\\n        \\n    }\\n    \\n    void addNum(int num) {\\n        if(maxHeap.size()==0) maxHeap.push(num);\\n        else if(maxHeap.size()==minHeap.size()){\\n            if(num<maxHeap.top()){\\n                maxHeap.push(num);\\n            }else if(num>minHeap.top()){\\n                int temp = minHeap.top();\\n                minHeap.pop();\\n                maxHeap.push(temp);\\n                minHeap.push(num);\\n            }else{\\n                maxHeap.push(num);\\n            }\\n        }else{\\n            if(num<maxHeap.top()){\\n                int temp = maxHeap.top();\\n                maxHeap.pop();\\n                minHeap.push(temp);\\n                maxHeap.push(num);\\n                // maxHeap.push(num);\\n            }else if(num>minHeap.top()){\\n                minHeap.push(num);\\n            }else{\\n                int temp = maxHeap.top();\\n                maxHeap.pop();\\n                minHeap.push(temp);\\n                maxHeap.push(num);\\n            }\\n        }\\n\\n    }\\n    \\n    double findMedian() {\\n        double ans;\\n        if(maxHeap.size()==minHeap.size()){\\n            ans = (maxHeap.top()+minHeap.top())/2;\\n        }else ans = maxHeap.top();\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder* obj = new MedianFinder();\\n * obj->addNum(num);\\n * double param_2 = obj->findMedian();\\n */\\n"
                    },
                    {
                        "username": "NakulJaju",
                        "content": "[@codepiyush1](/codepiyush1) Hi I\\'ve written a code such that when the heap sizes are equal and an element comes I\\'ll balance the heaps such that the new element goes to the maxHeap always \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Bro U r not checking the heap size.\\nOnly once u checked both heap equal or not.\\nelse if(maxHeap.size()==minHeap.size())\\n\\\\\\nNote: In Else condition.\\nthere may be the difference between both heap is more than one because u haven\\'t  check the heap size of both heap.\\n\\nCheck Out this solution\\nhttps://leetcode.com/problems/find-median-from-data-stream/solutions/3629630/c-undestand-the-concept/\\n\\nIf Understand Please Upvote."
                    }
                ]
            },
            {
                "id": 1937216,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "this question is somewhere in between a medium and a hard problem. Beacuse the approach becomes so obvious once we think about max and min heaps.."
                    },
                    {
                        "username": "harshit_rathr3",
                        "content": " \\n`Why my code is not working giving TLE. The exact similar solution worked on other platform and also submitted by someone else in leetcode as well\\n`\\n\\ndef __init__(self):\\n        self.max_heap = []\\n        self.min_heap = []\\n        \\n    def addNum(self, num: int) -> None:\\n        if self.max_heap and self.max_heap[0]>num:\\n            self.max_heap.append(num)\\n            heapq._heapify_max(self.max_heap)\\n        else:\\n            heapq.heappush(self.min_heap, num)\\n        diff = len(self.max_heap) - len(self.min_heap)\\n\\n        if diff>1:\\n            heapq.heappush(self.min_heap, heapq._heappop_max(self.max_heap))\\n        if diff<-1:\\n            self.max_heap.append(heapq.heappop(self.min_heap))\\n            heapq._heapify_max(self.max_heap)\\n        \\n\\n    def findMedian(self) -> float:\\n        diff = len(self.max_heap) - len(self.min_heap)\\n\\n        if diff==0:\\n            return (self.max_heap[0] + self.min_heap[0])/2\\n        elif diff>0:\\n            return self.max_heap[0]\\n        else:\\n            return self.min_heap[0]`\\n \\n"
                    },
                    {
                        "username": "thicktruyenche9",
                        "content": "i wonder if input number list get sorted ?"
                    },
                    {
                        "username": "khushmeetchugh",
                        "content": "Trying to do this question using quick select but still time limit exceeding in large data set (testcase 16)"
                    },
                    {
                        "username": "sid9812",
                        "content": "How do we approach the follow ups? "
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "works using ordered map"
                    },
                    {
                        "username": "elizfitz",
                        "content": "I think there\\'s a bug on the testcases. It says I have passed them all, but also that I have a TLE. However, the last executed input is empty. "
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Using multiset doesn\\'t give TLE \\uD83D\\uDC4D"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Should be medium tbh"
                    },
                    {
                        "username": "NakulJaju",
                        "content": "What\\'s wrong with this approach?\\nI\\'m always balancing the 2 heaps, and maxHeap will have 1 extra number if at all sizes are different.\\n\\nMy code below is giving runtime error:\\nruntime error: reference binding to null pointer of type \\'const int\\' (stl_iterator.h)\\n\\n\\nclass MedianFinder {\\nprivate:\\n    priority_queue<int> maxHeap;\\n    priority_queue<int, vector<int>, greater<int>> minHeap;\\n\\npublic:\\n    MedianFinder() {\\n        \\n    }\\n    \\n    void addNum(int num) {\\n        if(maxHeap.size()==0) maxHeap.push(num);\\n        else if(maxHeap.size()==minHeap.size()){\\n            if(num<maxHeap.top()){\\n                maxHeap.push(num);\\n            }else if(num>minHeap.top()){\\n                int temp = minHeap.top();\\n                minHeap.pop();\\n                maxHeap.push(temp);\\n                minHeap.push(num);\\n            }else{\\n                maxHeap.push(num);\\n            }\\n        }else{\\n            if(num<maxHeap.top()){\\n                int temp = maxHeap.top();\\n                maxHeap.pop();\\n                minHeap.push(temp);\\n                maxHeap.push(num);\\n                // maxHeap.push(num);\\n            }else if(num>minHeap.top()){\\n                minHeap.push(num);\\n            }else{\\n                int temp = maxHeap.top();\\n                maxHeap.pop();\\n                minHeap.push(temp);\\n                maxHeap.push(num);\\n            }\\n        }\\n\\n    }\\n    \\n    double findMedian() {\\n        double ans;\\n        if(maxHeap.size()==minHeap.size()){\\n            ans = (maxHeap.top()+minHeap.top())/2;\\n        }else ans = maxHeap.top();\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder* obj = new MedianFinder();\\n * obj->addNum(num);\\n * double param_2 = obj->findMedian();\\n */\\n"
                    },
                    {
                        "username": "NakulJaju",
                        "content": "[@codepiyush1](/codepiyush1) Hi I\\'ve written a code such that when the heap sizes are equal and an element comes I\\'ll balance the heaps such that the new element goes to the maxHeap always \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Bro U r not checking the heap size.\\nOnly once u checked both heap equal or not.\\nelse if(maxHeap.size()==minHeap.size())\\n\\\\\\nNote: In Else condition.\\nthere may be the difference between both heap is more than one because u haven\\'t  check the heap size of both heap.\\n\\nCheck Out this solution\\nhttps://leetcode.com/problems/find-median-from-data-stream/solutions/3629630/c-undestand-the-concept/\\n\\nIf Understand Please Upvote."
                    }
                ]
            },
            {
                "id": 1927984,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "this question is somewhere in between a medium and a hard problem. Beacuse the approach becomes so obvious once we think about max and min heaps.."
                    },
                    {
                        "username": "harshit_rathr3",
                        "content": " \\n`Why my code is not working giving TLE. The exact similar solution worked on other platform and also submitted by someone else in leetcode as well\\n`\\n\\ndef __init__(self):\\n        self.max_heap = []\\n        self.min_heap = []\\n        \\n    def addNum(self, num: int) -> None:\\n        if self.max_heap and self.max_heap[0]>num:\\n            self.max_heap.append(num)\\n            heapq._heapify_max(self.max_heap)\\n        else:\\n            heapq.heappush(self.min_heap, num)\\n        diff = len(self.max_heap) - len(self.min_heap)\\n\\n        if diff>1:\\n            heapq.heappush(self.min_heap, heapq._heappop_max(self.max_heap))\\n        if diff<-1:\\n            self.max_heap.append(heapq.heappop(self.min_heap))\\n            heapq._heapify_max(self.max_heap)\\n        \\n\\n    def findMedian(self) -> float:\\n        diff = len(self.max_heap) - len(self.min_heap)\\n\\n        if diff==0:\\n            return (self.max_heap[0] + self.min_heap[0])/2\\n        elif diff>0:\\n            return self.max_heap[0]\\n        else:\\n            return self.min_heap[0]`\\n \\n"
                    },
                    {
                        "username": "thicktruyenche9",
                        "content": "i wonder if input number list get sorted ?"
                    },
                    {
                        "username": "khushmeetchugh",
                        "content": "Trying to do this question using quick select but still time limit exceeding in large data set (testcase 16)"
                    },
                    {
                        "username": "sid9812",
                        "content": "How do we approach the follow ups? "
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "works using ordered map"
                    },
                    {
                        "username": "elizfitz",
                        "content": "I think there\\'s a bug on the testcases. It says I have passed them all, but also that I have a TLE. However, the last executed input is empty. "
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Using multiset doesn\\'t give TLE \\uD83D\\uDC4D"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Should be medium tbh"
                    },
                    {
                        "username": "NakulJaju",
                        "content": "What\\'s wrong with this approach?\\nI\\'m always balancing the 2 heaps, and maxHeap will have 1 extra number if at all sizes are different.\\n\\nMy code below is giving runtime error:\\nruntime error: reference binding to null pointer of type \\'const int\\' (stl_iterator.h)\\n\\n\\nclass MedianFinder {\\nprivate:\\n    priority_queue<int> maxHeap;\\n    priority_queue<int, vector<int>, greater<int>> minHeap;\\n\\npublic:\\n    MedianFinder() {\\n        \\n    }\\n    \\n    void addNum(int num) {\\n        if(maxHeap.size()==0) maxHeap.push(num);\\n        else if(maxHeap.size()==minHeap.size()){\\n            if(num<maxHeap.top()){\\n                maxHeap.push(num);\\n            }else if(num>minHeap.top()){\\n                int temp = minHeap.top();\\n                minHeap.pop();\\n                maxHeap.push(temp);\\n                minHeap.push(num);\\n            }else{\\n                maxHeap.push(num);\\n            }\\n        }else{\\n            if(num<maxHeap.top()){\\n                int temp = maxHeap.top();\\n                maxHeap.pop();\\n                minHeap.push(temp);\\n                maxHeap.push(num);\\n                // maxHeap.push(num);\\n            }else if(num>minHeap.top()){\\n                minHeap.push(num);\\n            }else{\\n                int temp = maxHeap.top();\\n                maxHeap.pop();\\n                minHeap.push(temp);\\n                maxHeap.push(num);\\n            }\\n        }\\n\\n    }\\n    \\n    double findMedian() {\\n        double ans;\\n        if(maxHeap.size()==minHeap.size()){\\n            ans = (maxHeap.top()+minHeap.top())/2;\\n        }else ans = maxHeap.top();\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder* obj = new MedianFinder();\\n * obj->addNum(num);\\n * double param_2 = obj->findMedian();\\n */\\n"
                    },
                    {
                        "username": "NakulJaju",
                        "content": "[@codepiyush1](/codepiyush1) Hi I\\'ve written a code such that when the heap sizes are equal and an element comes I\\'ll balance the heaps such that the new element goes to the maxHeap always \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Bro U r not checking the heap size.\\nOnly once u checked both heap equal or not.\\nelse if(maxHeap.size()==minHeap.size())\\n\\\\\\nNote: In Else condition.\\nthere may be the difference between both heap is more than one because u haven\\'t  check the heap size of both heap.\\n\\nCheck Out this solution\\nhttps://leetcode.com/problems/find-median-from-data-stream/solutions/3629630/c-undestand-the-concept/\\n\\nIf Understand Please Upvote."
                    }
                ]
            },
            {
                "id": 1926813,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "We can use the concept of MaxHeap & MinHeap concept.\\nThe MaxHeap size is alwys greater than or equal to MinHeap size.\\nSo If the number of element is even then the MaxHeap store the first n/2 element and MinHeap store next n/2 element.\\n->For median Do the sum of top of (MaxHeap + MinHeap )/2.\\nIf the number of element is odd. then first (n/2 + 1) element is stored in the MaxHeap. the remaining is in the MinHeap.\\nFor Median return the MaxHeap top. because in case of number of odd elements. MaxHeap size is graeter then MinHeap size.\\nTime Complexity:\\nO(nLogn) In worst case Each time in heap insertion deletion take place.\\nSpace Complexity:\\nO(n) n/2 +n/2 heap used so total n size heap.\\n\\nPlease Upvote .If you understand the concept....\\nSolution link:\\nhttps://leetcode.com/problems/find-median-from-data-stream/solutions/3629630/c-undestand-the-concept/"
                    },
                    {
                        "username": "sspenst",
                        "content": "Not sure I understand why two heaps are supposed to be used here. My solution was to create an array and use binary search to find where to insert - addNum is always O(log(n)) and findMedian is always O(1). Most solutions I\\'ve seen use multiple heap pushes/pops within addNum, which means multiple O(log(n)) operations instead of just one."
                    },
                    {
                        "username": "kotian97",
                        "content": "When you insert new element (say \\'num\\') into your array after binary search, won\\'t you have to move all elements > num to one position right? This moving will have O(n) complexity"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "itna wahiyaad question hai, mtlb itna hi jyada bisi 30 min pehle laga linkedlist ki approach se solution likhne me aur litteraly 4 hourse se jyada ho gya hai , still debugging for null pointer access, patani bisi kaha kaha se null aaye ja rha hai hr baar, hr ek test case me ek naya aaye ja rha hai, "
                    },
                    {
                        "username": "devashish2008",
                        "content": "/*\\n    Time: add : O(nlogn) find: O(1)\\n    Space: O(n)\\n    */\\n    \\nclass MedianFinder {\\n\\n    private PriorityQueue<Integer> smallHeap = new PriorityQueue<>((a,b) -> b.compareTo(a));\\n    private PriorityQueue<Integer> largeHeap = new PriorityQueue<>((a,b) -> a.compareTo(b));\\n\\n    public MedianFinder() {\\n\\n    }\\n    \\n    public void addNum(int num) {\\n        smallHeap.add(num);\\n        satisfy();\\n    }\\n\\n    private void satisfy(){\\n\\n        while(true){\\n            boolean touch = false;\\n\\n            if(smallHeap.size() > largeHeap.size() && smallHeap.size() - largeHeap.size() > 1) {\\n                largeHeap.add(smallHeap.poll());\\n                touch = true;\\n            }\\n\\n            if(largeHeap.size() > smallHeap.size() && largeHeap.size() - smallHeap.size() > 1) {\\n                smallHeap.add(largeHeap.poll());\\n                touch = true;\\n            }\\n\\n            if(smallHeap.size() > 0 && largeHeap.size() > 0 && smallHeap.peek() > largeHeap.peek()){\\n                largeHeap.add(smallHeap.poll());\\n                touch = true;\\n            }\\n\\n            if(smallHeap.size() > 0 && largeHeap.size() > 0 &&  largeHeap.peek() < smallHeap.peek()){\\n                smallHeap.add(largeHeap.poll());\\n                touch = true;\\n            }    \\n            \\n            if (!touch){\\n                break;\\n            }\\n        }\\n        \\n    }\\n\\n    public double findMedian() {\\n        if(smallHeap.size() > largeHeap.size()){\\n            return smallHeap.peek();\\n        }\\n\\n        if(largeHeap.size() > smallHeap.size()){\\n            return largeHeap.peek();\\n        }\\n\\n        Double res = (Double.valueOf(smallHeap.peek()) + Double.valueOf(largeHeap.peek())) /2;\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder obj = new MedianFinder();\\n * obj.addNum(num);\\n * double param_2 = obj.findMedian();\\n */"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user3245tw",
                        "content": "# Dart 'package.collection' not available ? \n\nimport 'package:collection/collection.dart'; Throws an error"
                    },
                    {
                        "username": "user5248P",
                        "content": "The question doesn\\'t mention that the values inserted should be considered sorted"
                    },
                    {
                        "username": "nayandubey08",
                        "content": "The very first line of question stated this,have a look\\n\\n\"The median is the middle value in an ordered integer list.\"\\n"
                    },
                    {
                        "username": "karans92837",
                        "content": "How on earth is one supposed to come up with a min heap/max heap solution during an interview for this question? God have some mercy on the people who get asked this question during an interview!"
                    },
                    {
                        "username": "kzduy2507",
                        "content": "# Will this take up O(inf) space?\n\nWill this take up Infinite space for Data Stream because **the data in the data stream is infinite and non-stationary**? Can we remove the unused value in Large and Small heaps to save space?"
                    },
                    {
                        "username": "yongjunchai",
                        "content": "a little change to the solution of the second follow up question. \n\n# 1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?\n\nWe can maintain an integer array of length 100 to store the count of each number along with a total count. Then, we can iterate over the array to find the middle value to get our median.\n\nTime and space complexity would be O(100) = O(1).\n\n# 2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?\n\nIn this case, we need an integer array of length 100 and two sored lists, one stores numbers less than 0, the other store numbers bigger than 100."
                    },
                    {
                        "username": "Shivamshrivaastava",
                        "content": "class MedianFinder {\\n    \\n    ArrayList<Integer> list;\\n\\n    public MedianFinder() {\\n        list = new ArrayList<>();\\n    }\\n    \\n    public void addNum(int num) {\\n        int i;\\n        if(list.size() > 0){\\n            for (i = 0; (i < list.size()  && list.get(i) < num); i++);\\n            if(i == -1){\\n                i = 0;\\n            }\\n            list.add(i , num);\\n        }else{\\n            list.add(num);\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        // System.out.println(list);\\n        int index = list.size()/2;\\n        if(list.size() % 2 == 0){\\n            return (double) (list.get(index) + list.get(index - 1))/2;\\n        }else{\\n            return list.get(index);\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1903481,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "We can use the concept of MaxHeap & MinHeap concept.\\nThe MaxHeap size is alwys greater than or equal to MinHeap size.\\nSo If the number of element is even then the MaxHeap store the first n/2 element and MinHeap store next n/2 element.\\n->For median Do the sum of top of (MaxHeap + MinHeap )/2.\\nIf the number of element is odd. then first (n/2 + 1) element is stored in the MaxHeap. the remaining is in the MinHeap.\\nFor Median return the MaxHeap top. because in case of number of odd elements. MaxHeap size is graeter then MinHeap size.\\nTime Complexity:\\nO(nLogn) In worst case Each time in heap insertion deletion take place.\\nSpace Complexity:\\nO(n) n/2 +n/2 heap used so total n size heap.\\n\\nPlease Upvote .If you understand the concept....\\nSolution link:\\nhttps://leetcode.com/problems/find-median-from-data-stream/solutions/3629630/c-undestand-the-concept/"
                    },
                    {
                        "username": "sspenst",
                        "content": "Not sure I understand why two heaps are supposed to be used here. My solution was to create an array and use binary search to find where to insert - addNum is always O(log(n)) and findMedian is always O(1). Most solutions I\\'ve seen use multiple heap pushes/pops within addNum, which means multiple O(log(n)) operations instead of just one."
                    },
                    {
                        "username": "kotian97",
                        "content": "When you insert new element (say \\'num\\') into your array after binary search, won\\'t you have to move all elements > num to one position right? This moving will have O(n) complexity"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "itna wahiyaad question hai, mtlb itna hi jyada bisi 30 min pehle laga linkedlist ki approach se solution likhne me aur litteraly 4 hourse se jyada ho gya hai , still debugging for null pointer access, patani bisi kaha kaha se null aaye ja rha hai hr baar, hr ek test case me ek naya aaye ja rha hai, "
                    },
                    {
                        "username": "devashish2008",
                        "content": "/*\\n    Time: add : O(nlogn) find: O(1)\\n    Space: O(n)\\n    */\\n    \\nclass MedianFinder {\\n\\n    private PriorityQueue<Integer> smallHeap = new PriorityQueue<>((a,b) -> b.compareTo(a));\\n    private PriorityQueue<Integer> largeHeap = new PriorityQueue<>((a,b) -> a.compareTo(b));\\n\\n    public MedianFinder() {\\n\\n    }\\n    \\n    public void addNum(int num) {\\n        smallHeap.add(num);\\n        satisfy();\\n    }\\n\\n    private void satisfy(){\\n\\n        while(true){\\n            boolean touch = false;\\n\\n            if(smallHeap.size() > largeHeap.size() && smallHeap.size() - largeHeap.size() > 1) {\\n                largeHeap.add(smallHeap.poll());\\n                touch = true;\\n            }\\n\\n            if(largeHeap.size() > smallHeap.size() && largeHeap.size() - smallHeap.size() > 1) {\\n                smallHeap.add(largeHeap.poll());\\n                touch = true;\\n            }\\n\\n            if(smallHeap.size() > 0 && largeHeap.size() > 0 && smallHeap.peek() > largeHeap.peek()){\\n                largeHeap.add(smallHeap.poll());\\n                touch = true;\\n            }\\n\\n            if(smallHeap.size() > 0 && largeHeap.size() > 0 &&  largeHeap.peek() < smallHeap.peek()){\\n                smallHeap.add(largeHeap.poll());\\n                touch = true;\\n            }    \\n            \\n            if (!touch){\\n                break;\\n            }\\n        }\\n        \\n    }\\n\\n    public double findMedian() {\\n        if(smallHeap.size() > largeHeap.size()){\\n            return smallHeap.peek();\\n        }\\n\\n        if(largeHeap.size() > smallHeap.size()){\\n            return largeHeap.peek();\\n        }\\n\\n        Double res = (Double.valueOf(smallHeap.peek()) + Double.valueOf(largeHeap.peek())) /2;\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder obj = new MedianFinder();\\n * obj.addNum(num);\\n * double param_2 = obj.findMedian();\\n */"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user3245tw",
                        "content": "# Dart 'package.collection' not available ? \n\nimport 'package:collection/collection.dart'; Throws an error"
                    },
                    {
                        "username": "user5248P",
                        "content": "The question doesn\\'t mention that the values inserted should be considered sorted"
                    },
                    {
                        "username": "nayandubey08",
                        "content": "The very first line of question stated this,have a look\\n\\n\"The median is the middle value in an ordered integer list.\"\\n"
                    },
                    {
                        "username": "karans92837",
                        "content": "How on earth is one supposed to come up with a min heap/max heap solution during an interview for this question? God have some mercy on the people who get asked this question during an interview!"
                    },
                    {
                        "username": "kzduy2507",
                        "content": "# Will this take up O(inf) space?\n\nWill this take up Infinite space for Data Stream because **the data in the data stream is infinite and non-stationary**? Can we remove the unused value in Large and Small heaps to save space?"
                    },
                    {
                        "username": "yongjunchai",
                        "content": "a little change to the solution of the second follow up question. \n\n# 1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?\n\nWe can maintain an integer array of length 100 to store the count of each number along with a total count. Then, we can iterate over the array to find the middle value to get our median.\n\nTime and space complexity would be O(100) = O(1).\n\n# 2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?\n\nIn this case, we need an integer array of length 100 and two sored lists, one stores numbers less than 0, the other store numbers bigger than 100."
                    },
                    {
                        "username": "Shivamshrivaastava",
                        "content": "class MedianFinder {\\n    \\n    ArrayList<Integer> list;\\n\\n    public MedianFinder() {\\n        list = new ArrayList<>();\\n    }\\n    \\n    public void addNum(int num) {\\n        int i;\\n        if(list.size() > 0){\\n            for (i = 0; (i < list.size()  && list.get(i) < num); i++);\\n            if(i == -1){\\n                i = 0;\\n            }\\n            list.add(i , num);\\n        }else{\\n            list.add(num);\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        // System.out.println(list);\\n        int index = list.size()/2;\\n        if(list.size() % 2 == 0){\\n            return (double) (list.get(index) + list.get(index - 1))/2;\\n        }else{\\n            return list.get(index);\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1834451,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "We can use the concept of MaxHeap & MinHeap concept.\\nThe MaxHeap size is alwys greater than or equal to MinHeap size.\\nSo If the number of element is even then the MaxHeap store the first n/2 element and MinHeap store next n/2 element.\\n->For median Do the sum of top of (MaxHeap + MinHeap )/2.\\nIf the number of element is odd. then first (n/2 + 1) element is stored in the MaxHeap. the remaining is in the MinHeap.\\nFor Median return the MaxHeap top. because in case of number of odd elements. MaxHeap size is graeter then MinHeap size.\\nTime Complexity:\\nO(nLogn) In worst case Each time in heap insertion deletion take place.\\nSpace Complexity:\\nO(n) n/2 +n/2 heap used so total n size heap.\\n\\nPlease Upvote .If you understand the concept....\\nSolution link:\\nhttps://leetcode.com/problems/find-median-from-data-stream/solutions/3629630/c-undestand-the-concept/"
                    },
                    {
                        "username": "sspenst",
                        "content": "Not sure I understand why two heaps are supposed to be used here. My solution was to create an array and use binary search to find where to insert - addNum is always O(log(n)) and findMedian is always O(1). Most solutions I\\'ve seen use multiple heap pushes/pops within addNum, which means multiple O(log(n)) operations instead of just one."
                    },
                    {
                        "username": "kotian97",
                        "content": "When you insert new element (say \\'num\\') into your array after binary search, won\\'t you have to move all elements > num to one position right? This moving will have O(n) complexity"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "itna wahiyaad question hai, mtlb itna hi jyada bisi 30 min pehle laga linkedlist ki approach se solution likhne me aur litteraly 4 hourse se jyada ho gya hai , still debugging for null pointer access, patani bisi kaha kaha se null aaye ja rha hai hr baar, hr ek test case me ek naya aaye ja rha hai, "
                    },
                    {
                        "username": "devashish2008",
                        "content": "/*\\n    Time: add : O(nlogn) find: O(1)\\n    Space: O(n)\\n    */\\n    \\nclass MedianFinder {\\n\\n    private PriorityQueue<Integer> smallHeap = new PriorityQueue<>((a,b) -> b.compareTo(a));\\n    private PriorityQueue<Integer> largeHeap = new PriorityQueue<>((a,b) -> a.compareTo(b));\\n\\n    public MedianFinder() {\\n\\n    }\\n    \\n    public void addNum(int num) {\\n        smallHeap.add(num);\\n        satisfy();\\n    }\\n\\n    private void satisfy(){\\n\\n        while(true){\\n            boolean touch = false;\\n\\n            if(smallHeap.size() > largeHeap.size() && smallHeap.size() - largeHeap.size() > 1) {\\n                largeHeap.add(smallHeap.poll());\\n                touch = true;\\n            }\\n\\n            if(largeHeap.size() > smallHeap.size() && largeHeap.size() - smallHeap.size() > 1) {\\n                smallHeap.add(largeHeap.poll());\\n                touch = true;\\n            }\\n\\n            if(smallHeap.size() > 0 && largeHeap.size() > 0 && smallHeap.peek() > largeHeap.peek()){\\n                largeHeap.add(smallHeap.poll());\\n                touch = true;\\n            }\\n\\n            if(smallHeap.size() > 0 && largeHeap.size() > 0 &&  largeHeap.peek() < smallHeap.peek()){\\n                smallHeap.add(largeHeap.poll());\\n                touch = true;\\n            }    \\n            \\n            if (!touch){\\n                break;\\n            }\\n        }\\n        \\n    }\\n\\n    public double findMedian() {\\n        if(smallHeap.size() > largeHeap.size()){\\n            return smallHeap.peek();\\n        }\\n\\n        if(largeHeap.size() > smallHeap.size()){\\n            return largeHeap.peek();\\n        }\\n\\n        Double res = (Double.valueOf(smallHeap.peek()) + Double.valueOf(largeHeap.peek())) /2;\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder obj = new MedianFinder();\\n * obj.addNum(num);\\n * double param_2 = obj.findMedian();\\n */"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user3245tw",
                        "content": "# Dart 'package.collection' not available ? \n\nimport 'package:collection/collection.dart'; Throws an error"
                    },
                    {
                        "username": "user5248P",
                        "content": "The question doesn\\'t mention that the values inserted should be considered sorted"
                    },
                    {
                        "username": "nayandubey08",
                        "content": "The very first line of question stated this,have a look\\n\\n\"The median is the middle value in an ordered integer list.\"\\n"
                    },
                    {
                        "username": "karans92837",
                        "content": "How on earth is one supposed to come up with a min heap/max heap solution during an interview for this question? God have some mercy on the people who get asked this question during an interview!"
                    },
                    {
                        "username": "kzduy2507",
                        "content": "# Will this take up O(inf) space?\n\nWill this take up Infinite space for Data Stream because **the data in the data stream is infinite and non-stationary**? Can we remove the unused value in Large and Small heaps to save space?"
                    },
                    {
                        "username": "yongjunchai",
                        "content": "a little change to the solution of the second follow up question. \n\n# 1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?\n\nWe can maintain an integer array of length 100 to store the count of each number along with a total count. Then, we can iterate over the array to find the middle value to get our median.\n\nTime and space complexity would be O(100) = O(1).\n\n# 2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?\n\nIn this case, we need an integer array of length 100 and two sored lists, one stores numbers less than 0, the other store numbers bigger than 100."
                    },
                    {
                        "username": "Shivamshrivaastava",
                        "content": "class MedianFinder {\\n    \\n    ArrayList<Integer> list;\\n\\n    public MedianFinder() {\\n        list = new ArrayList<>();\\n    }\\n    \\n    public void addNum(int num) {\\n        int i;\\n        if(list.size() > 0){\\n            for (i = 0; (i < list.size()  && list.get(i) < num); i++);\\n            if(i == -1){\\n                i = 0;\\n            }\\n            list.add(i , num);\\n        }else{\\n            list.add(num);\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        // System.out.println(list);\\n        int index = list.size()/2;\\n        if(list.size() % 2 == 0){\\n            return (double) (list.get(index) + list.get(index - 1))/2;\\n        }else{\\n            return list.get(index);\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1798020,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "We can use the concept of MaxHeap & MinHeap concept.\\nThe MaxHeap size is alwys greater than or equal to MinHeap size.\\nSo If the number of element is even then the MaxHeap store the first n/2 element and MinHeap store next n/2 element.\\n->For median Do the sum of top of (MaxHeap + MinHeap )/2.\\nIf the number of element is odd. then first (n/2 + 1) element is stored in the MaxHeap. the remaining is in the MinHeap.\\nFor Median return the MaxHeap top. because in case of number of odd elements. MaxHeap size is graeter then MinHeap size.\\nTime Complexity:\\nO(nLogn) In worst case Each time in heap insertion deletion take place.\\nSpace Complexity:\\nO(n) n/2 +n/2 heap used so total n size heap.\\n\\nPlease Upvote .If you understand the concept....\\nSolution link:\\nhttps://leetcode.com/problems/find-median-from-data-stream/solutions/3629630/c-undestand-the-concept/"
                    },
                    {
                        "username": "sspenst",
                        "content": "Not sure I understand why two heaps are supposed to be used here. My solution was to create an array and use binary search to find where to insert - addNum is always O(log(n)) and findMedian is always O(1). Most solutions I\\'ve seen use multiple heap pushes/pops within addNum, which means multiple O(log(n)) operations instead of just one."
                    },
                    {
                        "username": "kotian97",
                        "content": "When you insert new element (say \\'num\\') into your array after binary search, won\\'t you have to move all elements > num to one position right? This moving will have O(n) complexity"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "itna wahiyaad question hai, mtlb itna hi jyada bisi 30 min pehle laga linkedlist ki approach se solution likhne me aur litteraly 4 hourse se jyada ho gya hai , still debugging for null pointer access, patani bisi kaha kaha se null aaye ja rha hai hr baar, hr ek test case me ek naya aaye ja rha hai, "
                    },
                    {
                        "username": "devashish2008",
                        "content": "/*\\n    Time: add : O(nlogn) find: O(1)\\n    Space: O(n)\\n    */\\n    \\nclass MedianFinder {\\n\\n    private PriorityQueue<Integer> smallHeap = new PriorityQueue<>((a,b) -> b.compareTo(a));\\n    private PriorityQueue<Integer> largeHeap = new PriorityQueue<>((a,b) -> a.compareTo(b));\\n\\n    public MedianFinder() {\\n\\n    }\\n    \\n    public void addNum(int num) {\\n        smallHeap.add(num);\\n        satisfy();\\n    }\\n\\n    private void satisfy(){\\n\\n        while(true){\\n            boolean touch = false;\\n\\n            if(smallHeap.size() > largeHeap.size() && smallHeap.size() - largeHeap.size() > 1) {\\n                largeHeap.add(smallHeap.poll());\\n                touch = true;\\n            }\\n\\n            if(largeHeap.size() > smallHeap.size() && largeHeap.size() - smallHeap.size() > 1) {\\n                smallHeap.add(largeHeap.poll());\\n                touch = true;\\n            }\\n\\n            if(smallHeap.size() > 0 && largeHeap.size() > 0 && smallHeap.peek() > largeHeap.peek()){\\n                largeHeap.add(smallHeap.poll());\\n                touch = true;\\n            }\\n\\n            if(smallHeap.size() > 0 && largeHeap.size() > 0 &&  largeHeap.peek() < smallHeap.peek()){\\n                smallHeap.add(largeHeap.poll());\\n                touch = true;\\n            }    \\n            \\n            if (!touch){\\n                break;\\n            }\\n        }\\n        \\n    }\\n\\n    public double findMedian() {\\n        if(smallHeap.size() > largeHeap.size()){\\n            return smallHeap.peek();\\n        }\\n\\n        if(largeHeap.size() > smallHeap.size()){\\n            return largeHeap.peek();\\n        }\\n\\n        Double res = (Double.valueOf(smallHeap.peek()) + Double.valueOf(largeHeap.peek())) /2;\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder obj = new MedianFinder();\\n * obj.addNum(num);\\n * double param_2 = obj.findMedian();\\n */"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user3245tw",
                        "content": "# Dart 'package.collection' not available ? \n\nimport 'package:collection/collection.dart'; Throws an error"
                    },
                    {
                        "username": "user5248P",
                        "content": "The question doesn\\'t mention that the values inserted should be considered sorted"
                    },
                    {
                        "username": "nayandubey08",
                        "content": "The very first line of question stated this,have a look\\n\\n\"The median is the middle value in an ordered integer list.\"\\n"
                    },
                    {
                        "username": "karans92837",
                        "content": "How on earth is one supposed to come up with a min heap/max heap solution during an interview for this question? God have some mercy on the people who get asked this question during an interview!"
                    },
                    {
                        "username": "kzduy2507",
                        "content": "# Will this take up O(inf) space?\n\nWill this take up Infinite space for Data Stream because **the data in the data stream is infinite and non-stationary**? Can we remove the unused value in Large and Small heaps to save space?"
                    },
                    {
                        "username": "yongjunchai",
                        "content": "a little change to the solution of the second follow up question. \n\n# 1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?\n\nWe can maintain an integer array of length 100 to store the count of each number along with a total count. Then, we can iterate over the array to find the middle value to get our median.\n\nTime and space complexity would be O(100) = O(1).\n\n# 2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?\n\nIn this case, we need an integer array of length 100 and two sored lists, one stores numbers less than 0, the other store numbers bigger than 100."
                    },
                    {
                        "username": "Shivamshrivaastava",
                        "content": "class MedianFinder {\\n    \\n    ArrayList<Integer> list;\\n\\n    public MedianFinder() {\\n        list = new ArrayList<>();\\n    }\\n    \\n    public void addNum(int num) {\\n        int i;\\n        if(list.size() > 0){\\n            for (i = 0; (i < list.size()  && list.get(i) < num); i++);\\n            if(i == -1){\\n                i = 0;\\n            }\\n            list.add(i , num);\\n        }else{\\n            list.add(num);\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        // System.out.println(list);\\n        int index = list.size()/2;\\n        if(list.size() % 2 == 0){\\n            return (double) (list.get(index) + list.get(index - 1))/2;\\n        }else{\\n            return list.get(index);\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1783328,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "We can use the concept of MaxHeap & MinHeap concept.\\nThe MaxHeap size is alwys greater than or equal to MinHeap size.\\nSo If the number of element is even then the MaxHeap store the first n/2 element and MinHeap store next n/2 element.\\n->For median Do the sum of top of (MaxHeap + MinHeap )/2.\\nIf the number of element is odd. then first (n/2 + 1) element is stored in the MaxHeap. the remaining is in the MinHeap.\\nFor Median return the MaxHeap top. because in case of number of odd elements. MaxHeap size is graeter then MinHeap size.\\nTime Complexity:\\nO(nLogn) In worst case Each time in heap insertion deletion take place.\\nSpace Complexity:\\nO(n) n/2 +n/2 heap used so total n size heap.\\n\\nPlease Upvote .If you understand the concept....\\nSolution link:\\nhttps://leetcode.com/problems/find-median-from-data-stream/solutions/3629630/c-undestand-the-concept/"
                    },
                    {
                        "username": "sspenst",
                        "content": "Not sure I understand why two heaps are supposed to be used here. My solution was to create an array and use binary search to find where to insert - addNum is always O(log(n)) and findMedian is always O(1). Most solutions I\\'ve seen use multiple heap pushes/pops within addNum, which means multiple O(log(n)) operations instead of just one."
                    },
                    {
                        "username": "kotian97",
                        "content": "When you insert new element (say \\'num\\') into your array after binary search, won\\'t you have to move all elements > num to one position right? This moving will have O(n) complexity"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "itna wahiyaad question hai, mtlb itna hi jyada bisi 30 min pehle laga linkedlist ki approach se solution likhne me aur litteraly 4 hourse se jyada ho gya hai , still debugging for null pointer access, patani bisi kaha kaha se null aaye ja rha hai hr baar, hr ek test case me ek naya aaye ja rha hai, "
                    },
                    {
                        "username": "devashish2008",
                        "content": "/*\\n    Time: add : O(nlogn) find: O(1)\\n    Space: O(n)\\n    */\\n    \\nclass MedianFinder {\\n\\n    private PriorityQueue<Integer> smallHeap = new PriorityQueue<>((a,b) -> b.compareTo(a));\\n    private PriorityQueue<Integer> largeHeap = new PriorityQueue<>((a,b) -> a.compareTo(b));\\n\\n    public MedianFinder() {\\n\\n    }\\n    \\n    public void addNum(int num) {\\n        smallHeap.add(num);\\n        satisfy();\\n    }\\n\\n    private void satisfy(){\\n\\n        while(true){\\n            boolean touch = false;\\n\\n            if(smallHeap.size() > largeHeap.size() && smallHeap.size() - largeHeap.size() > 1) {\\n                largeHeap.add(smallHeap.poll());\\n                touch = true;\\n            }\\n\\n            if(largeHeap.size() > smallHeap.size() && largeHeap.size() - smallHeap.size() > 1) {\\n                smallHeap.add(largeHeap.poll());\\n                touch = true;\\n            }\\n\\n            if(smallHeap.size() > 0 && largeHeap.size() > 0 && smallHeap.peek() > largeHeap.peek()){\\n                largeHeap.add(smallHeap.poll());\\n                touch = true;\\n            }\\n\\n            if(smallHeap.size() > 0 && largeHeap.size() > 0 &&  largeHeap.peek() < smallHeap.peek()){\\n                smallHeap.add(largeHeap.poll());\\n                touch = true;\\n            }    \\n            \\n            if (!touch){\\n                break;\\n            }\\n        }\\n        \\n    }\\n\\n    public double findMedian() {\\n        if(smallHeap.size() > largeHeap.size()){\\n            return smallHeap.peek();\\n        }\\n\\n        if(largeHeap.size() > smallHeap.size()){\\n            return largeHeap.peek();\\n        }\\n\\n        Double res = (Double.valueOf(smallHeap.peek()) + Double.valueOf(largeHeap.peek())) /2;\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder obj = new MedianFinder();\\n * obj.addNum(num);\\n * double param_2 = obj.findMedian();\\n */"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user3245tw",
                        "content": "# Dart 'package.collection' not available ? \n\nimport 'package:collection/collection.dart'; Throws an error"
                    },
                    {
                        "username": "user5248P",
                        "content": "The question doesn\\'t mention that the values inserted should be considered sorted"
                    },
                    {
                        "username": "nayandubey08",
                        "content": "The very first line of question stated this,have a look\\n\\n\"The median is the middle value in an ordered integer list.\"\\n"
                    },
                    {
                        "username": "karans92837",
                        "content": "How on earth is one supposed to come up with a min heap/max heap solution during an interview for this question? God have some mercy on the people who get asked this question during an interview!"
                    },
                    {
                        "username": "kzduy2507",
                        "content": "# Will this take up O(inf) space?\n\nWill this take up Infinite space for Data Stream because **the data in the data stream is infinite and non-stationary**? Can we remove the unused value in Large and Small heaps to save space?"
                    },
                    {
                        "username": "yongjunchai",
                        "content": "a little change to the solution of the second follow up question. \n\n# 1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?\n\nWe can maintain an integer array of length 100 to store the count of each number along with a total count. Then, we can iterate over the array to find the middle value to get our median.\n\nTime and space complexity would be O(100) = O(1).\n\n# 2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?\n\nIn this case, we need an integer array of length 100 and two sored lists, one stores numbers less than 0, the other store numbers bigger than 100."
                    },
                    {
                        "username": "Shivamshrivaastava",
                        "content": "class MedianFinder {\\n    \\n    ArrayList<Integer> list;\\n\\n    public MedianFinder() {\\n        list = new ArrayList<>();\\n    }\\n    \\n    public void addNum(int num) {\\n        int i;\\n        if(list.size() > 0){\\n            for (i = 0; (i < list.size()  && list.get(i) < num); i++);\\n            if(i == -1){\\n                i = 0;\\n            }\\n            list.add(i , num);\\n        }else{\\n            list.add(num);\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        // System.out.println(list);\\n        int index = list.size()/2;\\n        if(list.size() % 2 == 0){\\n            return (double) (list.get(index) + list.get(index - 1))/2;\\n        }else{\\n            return list.get(index);\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1772254,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "We can use the concept of MaxHeap & MinHeap concept.\\nThe MaxHeap size is alwys greater than or equal to MinHeap size.\\nSo If the number of element is even then the MaxHeap store the first n/2 element and MinHeap store next n/2 element.\\n->For median Do the sum of top of (MaxHeap + MinHeap )/2.\\nIf the number of element is odd. then first (n/2 + 1) element is stored in the MaxHeap. the remaining is in the MinHeap.\\nFor Median return the MaxHeap top. because in case of number of odd elements. MaxHeap size is graeter then MinHeap size.\\nTime Complexity:\\nO(nLogn) In worst case Each time in heap insertion deletion take place.\\nSpace Complexity:\\nO(n) n/2 +n/2 heap used so total n size heap.\\n\\nPlease Upvote .If you understand the concept....\\nSolution link:\\nhttps://leetcode.com/problems/find-median-from-data-stream/solutions/3629630/c-undestand-the-concept/"
                    },
                    {
                        "username": "sspenst",
                        "content": "Not sure I understand why two heaps are supposed to be used here. My solution was to create an array and use binary search to find where to insert - addNum is always O(log(n)) and findMedian is always O(1). Most solutions I\\'ve seen use multiple heap pushes/pops within addNum, which means multiple O(log(n)) operations instead of just one."
                    },
                    {
                        "username": "kotian97",
                        "content": "When you insert new element (say \\'num\\') into your array after binary search, won\\'t you have to move all elements > num to one position right? This moving will have O(n) complexity"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "itna wahiyaad question hai, mtlb itna hi jyada bisi 30 min pehle laga linkedlist ki approach se solution likhne me aur litteraly 4 hourse se jyada ho gya hai , still debugging for null pointer access, patani bisi kaha kaha se null aaye ja rha hai hr baar, hr ek test case me ek naya aaye ja rha hai, "
                    },
                    {
                        "username": "devashish2008",
                        "content": "/*\\n    Time: add : O(nlogn) find: O(1)\\n    Space: O(n)\\n    */\\n    \\nclass MedianFinder {\\n\\n    private PriorityQueue<Integer> smallHeap = new PriorityQueue<>((a,b) -> b.compareTo(a));\\n    private PriorityQueue<Integer> largeHeap = new PriorityQueue<>((a,b) -> a.compareTo(b));\\n\\n    public MedianFinder() {\\n\\n    }\\n    \\n    public void addNum(int num) {\\n        smallHeap.add(num);\\n        satisfy();\\n    }\\n\\n    private void satisfy(){\\n\\n        while(true){\\n            boolean touch = false;\\n\\n            if(smallHeap.size() > largeHeap.size() && smallHeap.size() - largeHeap.size() > 1) {\\n                largeHeap.add(smallHeap.poll());\\n                touch = true;\\n            }\\n\\n            if(largeHeap.size() > smallHeap.size() && largeHeap.size() - smallHeap.size() > 1) {\\n                smallHeap.add(largeHeap.poll());\\n                touch = true;\\n            }\\n\\n            if(smallHeap.size() > 0 && largeHeap.size() > 0 && smallHeap.peek() > largeHeap.peek()){\\n                largeHeap.add(smallHeap.poll());\\n                touch = true;\\n            }\\n\\n            if(smallHeap.size() > 0 && largeHeap.size() > 0 &&  largeHeap.peek() < smallHeap.peek()){\\n                smallHeap.add(largeHeap.poll());\\n                touch = true;\\n            }    \\n            \\n            if (!touch){\\n                break;\\n            }\\n        }\\n        \\n    }\\n\\n    public double findMedian() {\\n        if(smallHeap.size() > largeHeap.size()){\\n            return smallHeap.peek();\\n        }\\n\\n        if(largeHeap.size() > smallHeap.size()){\\n            return largeHeap.peek();\\n        }\\n\\n        Double res = (Double.valueOf(smallHeap.peek()) + Double.valueOf(largeHeap.peek())) /2;\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder obj = new MedianFinder();\\n * obj.addNum(num);\\n * double param_2 = obj.findMedian();\\n */"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user3245tw",
                        "content": "# Dart 'package.collection' not available ? \n\nimport 'package:collection/collection.dart'; Throws an error"
                    },
                    {
                        "username": "user5248P",
                        "content": "The question doesn\\'t mention that the values inserted should be considered sorted"
                    },
                    {
                        "username": "nayandubey08",
                        "content": "The very first line of question stated this,have a look\\n\\n\"The median is the middle value in an ordered integer list.\"\\n"
                    },
                    {
                        "username": "karans92837",
                        "content": "How on earth is one supposed to come up with a min heap/max heap solution during an interview for this question? God have some mercy on the people who get asked this question during an interview!"
                    },
                    {
                        "username": "kzduy2507",
                        "content": "# Will this take up O(inf) space?\n\nWill this take up Infinite space for Data Stream because **the data in the data stream is infinite and non-stationary**? Can we remove the unused value in Large and Small heaps to save space?"
                    },
                    {
                        "username": "yongjunchai",
                        "content": "a little change to the solution of the second follow up question. \n\n# 1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?\n\nWe can maintain an integer array of length 100 to store the count of each number along with a total count. Then, we can iterate over the array to find the middle value to get our median.\n\nTime and space complexity would be O(100) = O(1).\n\n# 2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?\n\nIn this case, we need an integer array of length 100 and two sored lists, one stores numbers less than 0, the other store numbers bigger than 100."
                    },
                    {
                        "username": "Shivamshrivaastava",
                        "content": "class MedianFinder {\\n    \\n    ArrayList<Integer> list;\\n\\n    public MedianFinder() {\\n        list = new ArrayList<>();\\n    }\\n    \\n    public void addNum(int num) {\\n        int i;\\n        if(list.size() > 0){\\n            for (i = 0; (i < list.size()  && list.get(i) < num); i++);\\n            if(i == -1){\\n                i = 0;\\n            }\\n            list.add(i , num);\\n        }else{\\n            list.add(num);\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        // System.out.println(list);\\n        int index = list.size()/2;\\n        if(list.size() % 2 == 0){\\n            return (double) (list.get(index) + list.get(index - 1))/2;\\n        }else{\\n            return list.get(index);\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1762656,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "We can use the concept of MaxHeap & MinHeap concept.\\nThe MaxHeap size is alwys greater than or equal to MinHeap size.\\nSo If the number of element is even then the MaxHeap store the first n/2 element and MinHeap store next n/2 element.\\n->For median Do the sum of top of (MaxHeap + MinHeap )/2.\\nIf the number of element is odd. then first (n/2 + 1) element is stored in the MaxHeap. the remaining is in the MinHeap.\\nFor Median return the MaxHeap top. because in case of number of odd elements. MaxHeap size is graeter then MinHeap size.\\nTime Complexity:\\nO(nLogn) In worst case Each time in heap insertion deletion take place.\\nSpace Complexity:\\nO(n) n/2 +n/2 heap used so total n size heap.\\n\\nPlease Upvote .If you understand the concept....\\nSolution link:\\nhttps://leetcode.com/problems/find-median-from-data-stream/solutions/3629630/c-undestand-the-concept/"
                    },
                    {
                        "username": "sspenst",
                        "content": "Not sure I understand why two heaps are supposed to be used here. My solution was to create an array and use binary search to find where to insert - addNum is always O(log(n)) and findMedian is always O(1). Most solutions I\\'ve seen use multiple heap pushes/pops within addNum, which means multiple O(log(n)) operations instead of just one."
                    },
                    {
                        "username": "kotian97",
                        "content": "When you insert new element (say \\'num\\') into your array after binary search, won\\'t you have to move all elements > num to one position right? This moving will have O(n) complexity"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "itna wahiyaad question hai, mtlb itna hi jyada bisi 30 min pehle laga linkedlist ki approach se solution likhne me aur litteraly 4 hourse se jyada ho gya hai , still debugging for null pointer access, patani bisi kaha kaha se null aaye ja rha hai hr baar, hr ek test case me ek naya aaye ja rha hai, "
                    },
                    {
                        "username": "devashish2008",
                        "content": "/*\\n    Time: add : O(nlogn) find: O(1)\\n    Space: O(n)\\n    */\\n    \\nclass MedianFinder {\\n\\n    private PriorityQueue<Integer> smallHeap = new PriorityQueue<>((a,b) -> b.compareTo(a));\\n    private PriorityQueue<Integer> largeHeap = new PriorityQueue<>((a,b) -> a.compareTo(b));\\n\\n    public MedianFinder() {\\n\\n    }\\n    \\n    public void addNum(int num) {\\n        smallHeap.add(num);\\n        satisfy();\\n    }\\n\\n    private void satisfy(){\\n\\n        while(true){\\n            boolean touch = false;\\n\\n            if(smallHeap.size() > largeHeap.size() && smallHeap.size() - largeHeap.size() > 1) {\\n                largeHeap.add(smallHeap.poll());\\n                touch = true;\\n            }\\n\\n            if(largeHeap.size() > smallHeap.size() && largeHeap.size() - smallHeap.size() > 1) {\\n                smallHeap.add(largeHeap.poll());\\n                touch = true;\\n            }\\n\\n            if(smallHeap.size() > 0 && largeHeap.size() > 0 && smallHeap.peek() > largeHeap.peek()){\\n                largeHeap.add(smallHeap.poll());\\n                touch = true;\\n            }\\n\\n            if(smallHeap.size() > 0 && largeHeap.size() > 0 &&  largeHeap.peek() < smallHeap.peek()){\\n                smallHeap.add(largeHeap.poll());\\n                touch = true;\\n            }    \\n            \\n            if (!touch){\\n                break;\\n            }\\n        }\\n        \\n    }\\n\\n    public double findMedian() {\\n        if(smallHeap.size() > largeHeap.size()){\\n            return smallHeap.peek();\\n        }\\n\\n        if(largeHeap.size() > smallHeap.size()){\\n            return largeHeap.peek();\\n        }\\n\\n        Double res = (Double.valueOf(smallHeap.peek()) + Double.valueOf(largeHeap.peek())) /2;\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder obj = new MedianFinder();\\n * obj.addNum(num);\\n * double param_2 = obj.findMedian();\\n */"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user3245tw",
                        "content": "# Dart 'package.collection' not available ? \n\nimport 'package:collection/collection.dart'; Throws an error"
                    },
                    {
                        "username": "user5248P",
                        "content": "The question doesn\\'t mention that the values inserted should be considered sorted"
                    },
                    {
                        "username": "nayandubey08",
                        "content": "The very first line of question stated this,have a look\\n\\n\"The median is the middle value in an ordered integer list.\"\\n"
                    },
                    {
                        "username": "karans92837",
                        "content": "How on earth is one supposed to come up with a min heap/max heap solution during an interview for this question? God have some mercy on the people who get asked this question during an interview!"
                    },
                    {
                        "username": "kzduy2507",
                        "content": "# Will this take up O(inf) space?\n\nWill this take up Infinite space for Data Stream because **the data in the data stream is infinite and non-stationary**? Can we remove the unused value in Large and Small heaps to save space?"
                    },
                    {
                        "username": "yongjunchai",
                        "content": "a little change to the solution of the second follow up question. \n\n# 1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?\n\nWe can maintain an integer array of length 100 to store the count of each number along with a total count. Then, we can iterate over the array to find the middle value to get our median.\n\nTime and space complexity would be O(100) = O(1).\n\n# 2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?\n\nIn this case, we need an integer array of length 100 and two sored lists, one stores numbers less than 0, the other store numbers bigger than 100."
                    },
                    {
                        "username": "Shivamshrivaastava",
                        "content": "class MedianFinder {\\n    \\n    ArrayList<Integer> list;\\n\\n    public MedianFinder() {\\n        list = new ArrayList<>();\\n    }\\n    \\n    public void addNum(int num) {\\n        int i;\\n        if(list.size() > 0){\\n            for (i = 0; (i < list.size()  && list.get(i) < num); i++);\\n            if(i == -1){\\n                i = 0;\\n            }\\n            list.add(i , num);\\n        }else{\\n            list.add(num);\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        // System.out.println(list);\\n        int index = list.size()/2;\\n        if(list.size() % 2 == 0){\\n            return (double) (list.get(index) + list.get(index - 1))/2;\\n        }else{\\n            return list.get(index);\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1743495,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "We can use the concept of MaxHeap & MinHeap concept.\\nThe MaxHeap size is alwys greater than or equal to MinHeap size.\\nSo If the number of element is even then the MaxHeap store the first n/2 element and MinHeap store next n/2 element.\\n->For median Do the sum of top of (MaxHeap + MinHeap )/2.\\nIf the number of element is odd. then first (n/2 + 1) element is stored in the MaxHeap. the remaining is in the MinHeap.\\nFor Median return the MaxHeap top. because in case of number of odd elements. MaxHeap size is graeter then MinHeap size.\\nTime Complexity:\\nO(nLogn) In worst case Each time in heap insertion deletion take place.\\nSpace Complexity:\\nO(n) n/2 +n/2 heap used so total n size heap.\\n\\nPlease Upvote .If you understand the concept....\\nSolution link:\\nhttps://leetcode.com/problems/find-median-from-data-stream/solutions/3629630/c-undestand-the-concept/"
                    },
                    {
                        "username": "sspenst",
                        "content": "Not sure I understand why two heaps are supposed to be used here. My solution was to create an array and use binary search to find where to insert - addNum is always O(log(n)) and findMedian is always O(1). Most solutions I\\'ve seen use multiple heap pushes/pops within addNum, which means multiple O(log(n)) operations instead of just one."
                    },
                    {
                        "username": "kotian97",
                        "content": "When you insert new element (say \\'num\\') into your array after binary search, won\\'t you have to move all elements > num to one position right? This moving will have O(n) complexity"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "itna wahiyaad question hai, mtlb itna hi jyada bisi 30 min pehle laga linkedlist ki approach se solution likhne me aur litteraly 4 hourse se jyada ho gya hai , still debugging for null pointer access, patani bisi kaha kaha se null aaye ja rha hai hr baar, hr ek test case me ek naya aaye ja rha hai, "
                    },
                    {
                        "username": "devashish2008",
                        "content": "/*\\n    Time: add : O(nlogn) find: O(1)\\n    Space: O(n)\\n    */\\n    \\nclass MedianFinder {\\n\\n    private PriorityQueue<Integer> smallHeap = new PriorityQueue<>((a,b) -> b.compareTo(a));\\n    private PriorityQueue<Integer> largeHeap = new PriorityQueue<>((a,b) -> a.compareTo(b));\\n\\n    public MedianFinder() {\\n\\n    }\\n    \\n    public void addNum(int num) {\\n        smallHeap.add(num);\\n        satisfy();\\n    }\\n\\n    private void satisfy(){\\n\\n        while(true){\\n            boolean touch = false;\\n\\n            if(smallHeap.size() > largeHeap.size() && smallHeap.size() - largeHeap.size() > 1) {\\n                largeHeap.add(smallHeap.poll());\\n                touch = true;\\n            }\\n\\n            if(largeHeap.size() > smallHeap.size() && largeHeap.size() - smallHeap.size() > 1) {\\n                smallHeap.add(largeHeap.poll());\\n                touch = true;\\n            }\\n\\n            if(smallHeap.size() > 0 && largeHeap.size() > 0 && smallHeap.peek() > largeHeap.peek()){\\n                largeHeap.add(smallHeap.poll());\\n                touch = true;\\n            }\\n\\n            if(smallHeap.size() > 0 && largeHeap.size() > 0 &&  largeHeap.peek() < smallHeap.peek()){\\n                smallHeap.add(largeHeap.poll());\\n                touch = true;\\n            }    \\n            \\n            if (!touch){\\n                break;\\n            }\\n        }\\n        \\n    }\\n\\n    public double findMedian() {\\n        if(smallHeap.size() > largeHeap.size()){\\n            return smallHeap.peek();\\n        }\\n\\n        if(largeHeap.size() > smallHeap.size()){\\n            return largeHeap.peek();\\n        }\\n\\n        Double res = (Double.valueOf(smallHeap.peek()) + Double.valueOf(largeHeap.peek())) /2;\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder obj = new MedianFinder();\\n * obj.addNum(num);\\n * double param_2 = obj.findMedian();\\n */"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user3245tw",
                        "content": "# Dart 'package.collection' not available ? \n\nimport 'package:collection/collection.dart'; Throws an error"
                    },
                    {
                        "username": "user5248P",
                        "content": "The question doesn\\'t mention that the values inserted should be considered sorted"
                    },
                    {
                        "username": "nayandubey08",
                        "content": "The very first line of question stated this,have a look\\n\\n\"The median is the middle value in an ordered integer list.\"\\n"
                    },
                    {
                        "username": "karans92837",
                        "content": "How on earth is one supposed to come up with a min heap/max heap solution during an interview for this question? God have some mercy on the people who get asked this question during an interview!"
                    },
                    {
                        "username": "kzduy2507",
                        "content": "# Will this take up O(inf) space?\n\nWill this take up Infinite space for Data Stream because **the data in the data stream is infinite and non-stationary**? Can we remove the unused value in Large and Small heaps to save space?"
                    },
                    {
                        "username": "yongjunchai",
                        "content": "a little change to the solution of the second follow up question. \n\n# 1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?\n\nWe can maintain an integer array of length 100 to store the count of each number along with a total count. Then, we can iterate over the array to find the middle value to get our median.\n\nTime and space complexity would be O(100) = O(1).\n\n# 2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?\n\nIn this case, we need an integer array of length 100 and two sored lists, one stores numbers less than 0, the other store numbers bigger than 100."
                    },
                    {
                        "username": "Shivamshrivaastava",
                        "content": "class MedianFinder {\\n    \\n    ArrayList<Integer> list;\\n\\n    public MedianFinder() {\\n        list = new ArrayList<>();\\n    }\\n    \\n    public void addNum(int num) {\\n        int i;\\n        if(list.size() > 0){\\n            for (i = 0; (i < list.size()  && list.get(i) < num); i++);\\n            if(i == -1){\\n                i = 0;\\n            }\\n            list.add(i , num);\\n        }else{\\n            list.add(num);\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        // System.out.println(list);\\n        int index = list.size()/2;\\n        if(list.size() % 2 == 0){\\n            return (double) (list.get(index) + list.get(index - 1))/2;\\n        }else{\\n            return list.get(index);\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1712386,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "We can use the concept of MaxHeap & MinHeap concept.\\nThe MaxHeap size is alwys greater than or equal to MinHeap size.\\nSo If the number of element is even then the MaxHeap store the first n/2 element and MinHeap store next n/2 element.\\n->For median Do the sum of top of (MaxHeap + MinHeap )/2.\\nIf the number of element is odd. then first (n/2 + 1) element is stored in the MaxHeap. the remaining is in the MinHeap.\\nFor Median return the MaxHeap top. because in case of number of odd elements. MaxHeap size is graeter then MinHeap size.\\nTime Complexity:\\nO(nLogn) In worst case Each time in heap insertion deletion take place.\\nSpace Complexity:\\nO(n) n/2 +n/2 heap used so total n size heap.\\n\\nPlease Upvote .If you understand the concept....\\nSolution link:\\nhttps://leetcode.com/problems/find-median-from-data-stream/solutions/3629630/c-undestand-the-concept/"
                    },
                    {
                        "username": "sspenst",
                        "content": "Not sure I understand why two heaps are supposed to be used here. My solution was to create an array and use binary search to find where to insert - addNum is always O(log(n)) and findMedian is always O(1). Most solutions I\\'ve seen use multiple heap pushes/pops within addNum, which means multiple O(log(n)) operations instead of just one."
                    },
                    {
                        "username": "kotian97",
                        "content": "When you insert new element (say \\'num\\') into your array after binary search, won\\'t you have to move all elements > num to one position right? This moving will have O(n) complexity"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "itna wahiyaad question hai, mtlb itna hi jyada bisi 30 min pehle laga linkedlist ki approach se solution likhne me aur litteraly 4 hourse se jyada ho gya hai , still debugging for null pointer access, patani bisi kaha kaha se null aaye ja rha hai hr baar, hr ek test case me ek naya aaye ja rha hai, "
                    },
                    {
                        "username": "devashish2008",
                        "content": "/*\\n    Time: add : O(nlogn) find: O(1)\\n    Space: O(n)\\n    */\\n    \\nclass MedianFinder {\\n\\n    private PriorityQueue<Integer> smallHeap = new PriorityQueue<>((a,b) -> b.compareTo(a));\\n    private PriorityQueue<Integer> largeHeap = new PriorityQueue<>((a,b) -> a.compareTo(b));\\n\\n    public MedianFinder() {\\n\\n    }\\n    \\n    public void addNum(int num) {\\n        smallHeap.add(num);\\n        satisfy();\\n    }\\n\\n    private void satisfy(){\\n\\n        while(true){\\n            boolean touch = false;\\n\\n            if(smallHeap.size() > largeHeap.size() && smallHeap.size() - largeHeap.size() > 1) {\\n                largeHeap.add(smallHeap.poll());\\n                touch = true;\\n            }\\n\\n            if(largeHeap.size() > smallHeap.size() && largeHeap.size() - smallHeap.size() > 1) {\\n                smallHeap.add(largeHeap.poll());\\n                touch = true;\\n            }\\n\\n            if(smallHeap.size() > 0 && largeHeap.size() > 0 && smallHeap.peek() > largeHeap.peek()){\\n                largeHeap.add(smallHeap.poll());\\n                touch = true;\\n            }\\n\\n            if(smallHeap.size() > 0 && largeHeap.size() > 0 &&  largeHeap.peek() < smallHeap.peek()){\\n                smallHeap.add(largeHeap.poll());\\n                touch = true;\\n            }    \\n            \\n            if (!touch){\\n                break;\\n            }\\n        }\\n        \\n    }\\n\\n    public double findMedian() {\\n        if(smallHeap.size() > largeHeap.size()){\\n            return smallHeap.peek();\\n        }\\n\\n        if(largeHeap.size() > smallHeap.size()){\\n            return largeHeap.peek();\\n        }\\n\\n        Double res = (Double.valueOf(smallHeap.peek()) + Double.valueOf(largeHeap.peek())) /2;\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder obj = new MedianFinder();\\n * obj.addNum(num);\\n * double param_2 = obj.findMedian();\\n */"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user3245tw",
                        "content": "# Dart 'package.collection' not available ? \n\nimport 'package:collection/collection.dart'; Throws an error"
                    },
                    {
                        "username": "user5248P",
                        "content": "The question doesn\\'t mention that the values inserted should be considered sorted"
                    },
                    {
                        "username": "nayandubey08",
                        "content": "The very first line of question stated this,have a look\\n\\n\"The median is the middle value in an ordered integer list.\"\\n"
                    },
                    {
                        "username": "karans92837",
                        "content": "How on earth is one supposed to come up with a min heap/max heap solution during an interview for this question? God have some mercy on the people who get asked this question during an interview!"
                    },
                    {
                        "username": "kzduy2507",
                        "content": "# Will this take up O(inf) space?\n\nWill this take up Infinite space for Data Stream because **the data in the data stream is infinite and non-stationary**? Can we remove the unused value in Large and Small heaps to save space?"
                    },
                    {
                        "username": "yongjunchai",
                        "content": "a little change to the solution of the second follow up question. \n\n# 1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?\n\nWe can maintain an integer array of length 100 to store the count of each number along with a total count. Then, we can iterate over the array to find the middle value to get our median.\n\nTime and space complexity would be O(100) = O(1).\n\n# 2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?\n\nIn this case, we need an integer array of length 100 and two sored lists, one stores numbers less than 0, the other store numbers bigger than 100."
                    },
                    {
                        "username": "Shivamshrivaastava",
                        "content": "class MedianFinder {\\n    \\n    ArrayList<Integer> list;\\n\\n    public MedianFinder() {\\n        list = new ArrayList<>();\\n    }\\n    \\n    public void addNum(int num) {\\n        int i;\\n        if(list.size() > 0){\\n            for (i = 0; (i < list.size()  && list.get(i) < num); i++);\\n            if(i == -1){\\n                i = 0;\\n            }\\n            list.add(i , num);\\n        }else{\\n            list.add(num);\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        // System.out.println(list);\\n        int index = list.size()/2;\\n        if(list.size() % 2 == 0){\\n            return (double) (list.get(index) + list.get(index - 1))/2;\\n        }else{\\n            return list.get(index);\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1682822,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "We can use the concept of MaxHeap & MinHeap concept.\\nThe MaxHeap size is alwys greater than or equal to MinHeap size.\\nSo If the number of element is even then the MaxHeap store the first n/2 element and MinHeap store next n/2 element.\\n->For median Do the sum of top of (MaxHeap + MinHeap )/2.\\nIf the number of element is odd. then first (n/2 + 1) element is stored in the MaxHeap. the remaining is in the MinHeap.\\nFor Median return the MaxHeap top. because in case of number of odd elements. MaxHeap size is graeter then MinHeap size.\\nTime Complexity:\\nO(nLogn) In worst case Each time in heap insertion deletion take place.\\nSpace Complexity:\\nO(n) n/2 +n/2 heap used so total n size heap.\\n\\nPlease Upvote .If you understand the concept....\\nSolution link:\\nhttps://leetcode.com/problems/find-median-from-data-stream/solutions/3629630/c-undestand-the-concept/"
                    },
                    {
                        "username": "sspenst",
                        "content": "Not sure I understand why two heaps are supposed to be used here. My solution was to create an array and use binary search to find where to insert - addNum is always O(log(n)) and findMedian is always O(1). Most solutions I\\'ve seen use multiple heap pushes/pops within addNum, which means multiple O(log(n)) operations instead of just one."
                    },
                    {
                        "username": "kotian97",
                        "content": "When you insert new element (say \\'num\\') into your array after binary search, won\\'t you have to move all elements > num to one position right? This moving will have O(n) complexity"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "itna wahiyaad question hai, mtlb itna hi jyada bisi 30 min pehle laga linkedlist ki approach se solution likhne me aur litteraly 4 hourse se jyada ho gya hai , still debugging for null pointer access, patani bisi kaha kaha se null aaye ja rha hai hr baar, hr ek test case me ek naya aaye ja rha hai, "
                    },
                    {
                        "username": "devashish2008",
                        "content": "/*\\n    Time: add : O(nlogn) find: O(1)\\n    Space: O(n)\\n    */\\n    \\nclass MedianFinder {\\n\\n    private PriorityQueue<Integer> smallHeap = new PriorityQueue<>((a,b) -> b.compareTo(a));\\n    private PriorityQueue<Integer> largeHeap = new PriorityQueue<>((a,b) -> a.compareTo(b));\\n\\n    public MedianFinder() {\\n\\n    }\\n    \\n    public void addNum(int num) {\\n        smallHeap.add(num);\\n        satisfy();\\n    }\\n\\n    private void satisfy(){\\n\\n        while(true){\\n            boolean touch = false;\\n\\n            if(smallHeap.size() > largeHeap.size() && smallHeap.size() - largeHeap.size() > 1) {\\n                largeHeap.add(smallHeap.poll());\\n                touch = true;\\n            }\\n\\n            if(largeHeap.size() > smallHeap.size() && largeHeap.size() - smallHeap.size() > 1) {\\n                smallHeap.add(largeHeap.poll());\\n                touch = true;\\n            }\\n\\n            if(smallHeap.size() > 0 && largeHeap.size() > 0 && smallHeap.peek() > largeHeap.peek()){\\n                largeHeap.add(smallHeap.poll());\\n                touch = true;\\n            }\\n\\n            if(smallHeap.size() > 0 && largeHeap.size() > 0 &&  largeHeap.peek() < smallHeap.peek()){\\n                smallHeap.add(largeHeap.poll());\\n                touch = true;\\n            }    \\n            \\n            if (!touch){\\n                break;\\n            }\\n        }\\n        \\n    }\\n\\n    public double findMedian() {\\n        if(smallHeap.size() > largeHeap.size()){\\n            return smallHeap.peek();\\n        }\\n\\n        if(largeHeap.size() > smallHeap.size()){\\n            return largeHeap.peek();\\n        }\\n\\n        Double res = (Double.valueOf(smallHeap.peek()) + Double.valueOf(largeHeap.peek())) /2;\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * MedianFinder obj = new MedianFinder();\\n * obj.addNum(num);\\n * double param_2 = obj.findMedian();\\n */"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user3245tw",
                        "content": "# Dart 'package.collection' not available ? \n\nimport 'package:collection/collection.dart'; Throws an error"
                    },
                    {
                        "username": "user5248P",
                        "content": "The question doesn\\'t mention that the values inserted should be considered sorted"
                    },
                    {
                        "username": "nayandubey08",
                        "content": "The very first line of question stated this,have a look\\n\\n\"The median is the middle value in an ordered integer list.\"\\n"
                    },
                    {
                        "username": "karans92837",
                        "content": "How on earth is one supposed to come up with a min heap/max heap solution during an interview for this question? God have some mercy on the people who get asked this question during an interview!"
                    },
                    {
                        "username": "kzduy2507",
                        "content": "# Will this take up O(inf) space?\n\nWill this take up Infinite space for Data Stream because **the data in the data stream is infinite and non-stationary**? Can we remove the unused value in Large and Small heaps to save space?"
                    },
                    {
                        "username": "yongjunchai",
                        "content": "a little change to the solution of the second follow up question. \n\n# 1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?\n\nWe can maintain an integer array of length 100 to store the count of each number along with a total count. Then, we can iterate over the array to find the middle value to get our median.\n\nTime and space complexity would be O(100) = O(1).\n\n# 2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?\n\nIn this case, we need an integer array of length 100 and two sored lists, one stores numbers less than 0, the other store numbers bigger than 100."
                    },
                    {
                        "username": "Shivamshrivaastava",
                        "content": "class MedianFinder {\\n    \\n    ArrayList<Integer> list;\\n\\n    public MedianFinder() {\\n        list = new ArrayList<>();\\n    }\\n    \\n    public void addNum(int num) {\\n        int i;\\n        if(list.size() > 0){\\n            for (i = 0; (i < list.size()  && list.get(i) < num); i++);\\n            if(i == -1){\\n                i = 0;\\n            }\\n            list.add(i , num);\\n        }else{\\n            list.add(num);\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        // System.out.println(list);\\n        int index = list.size()/2;\\n        if(list.size() % 2 == 0){\\n            return (double) (list.get(index) + list.get(index - 1))/2;\\n        }else{\\n            return list.get(index);\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            }
        ]
    }
]