[
    {
        "title": "Task Scheduler II",
        "question_content": "You are given a 0-indexed array of positive integers tasks, representing tasks that need to be completed in order, where tasks[i] represents the type of the ith task.\nYou are also given a positive integer space, which represents the minimum number of days that must pass after the completion of a task before another task of the same type can be performed.\nEach day, until all tasks have been completed, you must either:\n\n\tComplete the next task from tasks, or\n\tTake a break.\n\nReturn the minimum number of days needed to complete all tasks.\n&nbsp;\nExample 1:\n\nInput: tasks = [1,2,1,2,3,1], space = 3\nOutput: 9\nExplanation:\nOne way to complete all tasks in 9 days is as follows:\nDay 1: Complete the 0th task.\nDay 2: Complete the 1st task.\nDay 3: Take a break.\nDay 4: Take a break.\nDay 5: Complete the 2nd task.\nDay 6: Complete the 3rd task.\nDay 7: Take a break.\nDay 8: Complete the 4th task.\nDay 9: Complete the 5th task.\nIt can be shown that the tasks cannot be completed in less than 9 days.\n\nExample 2:\n\nInput: tasks = [5,8,8,5], space = 2\nOutput: 6\nExplanation:\nOne way to complete all tasks in 6 days is as follows:\nDay 1: Complete the 0th task.\nDay 2: Complete the 1st task.\nDay 3: Take a break.\nDay 4: Take a break.\nDay 5: Complete the 2nd task.\nDay 6: Complete the 3rd task.\nIt can be shown that the tasks cannot be completed in less than 6 days.\n\n&nbsp;\nConstraints:\n\n\t1 <= tasks.length <= 105\n\t1 <= tasks[i] <= 109\n\t1 <= space <= tasks.length",
        "solutions": [
            {
                "id": 2388301,
                "title": "java-c-python-hashmap",
                "content": "# **Solution 1**\\nThe last task of type `a` is completed on day `last[a]`.\\nCurrently it takes us `res` day.\\n\\nFor the task `a`,\\nwe can do it on `res + 1` day,\\nand it need to be bigger than `last[a] + space`.\\nSo this task is completed on `max(res, last[a] + space) + 1`.\\n\\nWe keep doing this for all tasks, and finally return result `res`\\n\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        Map<Integer, Long> last = new HashMap<>();;\\n        long res = 0;\\n        for (int a : tasks)\\n            if (last.containsKey(a))\\n                last.put(a, res = Math.max(res, last.get(a) + space) + 1);\\n            else\\n                last.put(a, ++res);\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<int, long long> last;\\n        long long res = 0;\\n        for (int a: tasks)\\n            if (last.count(a))\\n                last[a] = res = max(res, last[a] + space) + 1;\\n            else\\n                last[a] = ++res;\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def taskSchedulerII(self, A, space):\\n        last = defaultdict(lambda: - len(A) - 10)\\n        res = 0\\n        for a in A:\\n            last[a] = res = max(res, last[a] + space) + 1\\n        return res\\n```\\n<br>\\n\\n# Solution 2\\n`m[a]` is the next avaible day for task type of `a`\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        Map<Integer, Long> next = new HashMap<>();;\\n        long res = 0;\\n        for (int a : tasks) {\\n            res = Math.max(next.getOrDefault(a, 0L), res + 1);\\n            next.put(a, res + space + 1);\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<int, long long> next;\\n        long long res = 0;\\n        for (int a : tasks)\\n            next[a] = (res = max(next[a], res + 1)) + space + 1;\\n        return res;\\n    }\\n```\\n<br>\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        Map<Integer, Long> last = new HashMap<>();;\\n        long res = 0;\\n        for (int a : tasks)\\n            if (last.containsKey(a))\\n                last.put(a, res = Math.max(res, last.get(a) + space) + 1);\\n            else\\n                last.put(a, ++res);\\n        return res;\\n    }\\n```\n```cpp\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<int, long long> last;\\n        long long res = 0;\\n        for (int a: tasks)\\n            if (last.count(a))\\n                last[a] = res = max(res, last[a] + space) + 1;\\n            else\\n                last[a] = ++res;\\n        return res;\\n    }\\n```\n```py\\n    def taskSchedulerII(self, A, space):\\n        last = defaultdict(lambda: - len(A) - 10)\\n        res = 0\\n        for a in A:\\n            last[a] = res = max(res, last[a] + space) + 1\\n        return res\\n```\n```java\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        Map<Integer, Long> next = new HashMap<>();;\\n        long res = 0;\\n        for (int a : tasks) {\\n            res = Math.max(next.getOrDefault(a, 0L), res + 1);\\n            next.put(a, res + space + 1);\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<int, long long> next;\\n        long long res = 0;\\n        for (int a : tasks)\\n            next[a] = (res = max(next[a], res + 1)) + space + 1;\\n        return res;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2388880,
                "title": "c-solution-hindi-explanation-map",
                "content": "**This question is similar to that of task scheduler  bas ismain humain task jis order main diye hain usmain krna h **\\n\\n\\nToh hum kya karenge ek map banayenge[ task no->NEXT TIME wo kab chal sakta h ]\\nsabse phle ek ek krke task pe Iterate karenge or ek variable lenge currenttime ke liye jo ki zero se start hoga \\nphir apan dekhenge kya yeh task mere map main present h ki nai agar nai h toh wo task mtlb usko hum abhi execute kr sakte hain toh uss case main usse map main dalke uska next time update krdenge currenttime +space+1 or agar h  toh 2 possibility h ki uski value jo h current time se yaa toh choti yaa barabar hogi yaa badi hogi \\nagar choti h toh usko execute krke uska next time update krdenge currenttime +space+1 se \\nagar badi h toh humain break lena padega toh hum currenttime ko uski value+1 se update krke task ki value ko next time se update krdenge \\nbas end main jo currenttime hoga wo humara ans h\\n\\n\\n**please do upvote**\\n```\\n  long long taskSchedulerII(vector<int>& tasks, int space) \\n    {\\n        unordered_map<long long ,long long> m;\\n        int ans=0;\\n        long long int  curr=0;\\n        for(int i=0;i<tasks.size();i++)\\n        {\\n            \\n            if(m.find(tasks[i])==m.end())\\n            {\\n                m[tasks[i]]=1+space+curr;\\n                curr++;\\n            }\\n            else\\n            {\\n                if(m[tasks[i]]>curr)\\n                {\\n                    curr=m[tasks[i]];\\n                }\\n                m[tasks[i]]=space+curr+1;  \\n                curr++;\\n            }     \\n        }\\n        return curr;\\n        \\n        \\n    }\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  long long taskSchedulerII(vector<int>& tasks, int space) \\n    {\\n        unordered_map<long long ,long long> m;\\n        int ans=0;\\n        long long int  curr=0;\\n        for(int i=0;i<tasks.size();i++)\\n        {\\n            \\n            if(m.find(tasks[i])==m.end())\\n            {\\n                m[tasks[i]]=1+space+curr;\\n                curr++;\\n            }\\n            else\\n            {\\n                if(m[tasks[i]]>curr)\\n                {\\n                    curr=m[tasks[i]];\\n                }\\n                m[tasks[i]]=space+curr+1;  \\n                curr++;\\n            }     \\n        }\\n        return curr;\\n        \\n        \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2388105,
                "title": "c-python3-hashmap-to-store-previous-occurence-o-n",
                "content": "\\n\\nUse hashmap to store previous day on which task occured. If the `curr_day - day it occured earlier <= space` we need to take breaks. \\n\\n**C++**\\n```\\nlong long taskSchedulerII(vector<int>& tasks, int space) {\\n    unordered_map<int, long long> m;\\n    long long curr_day = 0;\\n    for (int& x: tasks) {\\n        curr_day += 1;\\n        if (m.count(x) && curr_day - m[x] <= space)\\n            curr_day += space - (curr_day - m[x]) + 1;\\n        m[x] = curr_day;\\n    }\\n    return curr_day;\\n}\\n```\\n**Python3**\\n```\\ndef taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n    m, curr_day = {}, 0\\n    for x in tasks:\\n        curr_day += 1\\n        if x in m and curr_day - m[x] <= space:\\n            curr_day += space - (curr_day - m[x]) + 1\\n        m[x] = curr_day\\n    return curr_day\\n```",
                "solutionTags": [],
                "code": "```\\nlong long taskSchedulerII(vector<int>& tasks, int space) {\\n    unordered_map<int, long long> m;\\n    long long curr_day = 0;\\n    for (int& x: tasks) {\\n        curr_day += 1;\\n        if (m.count(x) && curr_day - m[x] <= space)\\n            curr_day += space - (curr_day - m[x]) + 1;\\n        m[x] = curr_day;\\n    }\\n    return curr_day;\\n}\\n```\n```\\ndef taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n    m, curr_day = {}, 0\\n    for x in tasks:\\n        curr_day += 1\\n        if x in m and curr_day - m[x] <= space:\\n            curr_day += space - (curr_day - m[x]) + 1\\n        m[x] = curr_day\\n    return curr_day\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2388526,
                "title": "python-easily-understood-faster-than-98-simple-o-n",
                "content": "```\\nimport math\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        count_dict = {}\\n        total_days = 0\\n        for task in tasks:\\n            if task not in count_dict:\\n                count_dict[task] = -math.inf\\n            total_days = max(total_days + 1, count_dict[task] + space + 1)\\n            count_dict[task] = total_days\\n        return total_days\\n```\\n**Time complexity**: O(n)\\n**Space complexity**: O(n)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        count_dict = {}\\n        total_days = 0\\n        for task in tasks:\\n            if task not in count_dict:\\n                count_dict[task] = -math.inf\\n            total_days = max(total_days + 1, count_dict[task] + space + 1)\\n            count_dict[task] = total_days\\n        return total_days\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388212,
                "title": "simple-simulation-hashmap-o-n",
                "content": "hashmap stores the next possible day to perform a task.\\nas the tasks needs to be performed in the order they are given, if the curday is lesser than the next possible day to perform a day, we need to have gap days\\n\\n```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<int,long long int> hash;     long long int curday=0;    \\n        for(int i=0;i<tasks.size();i++){\\n            if(hash.count(tasks[i])) curday=max(curday,hash[tasks[i]]);\\n            hash[tasks[i]]=curday+space+1;\\n            curday+=1;\\n        }\\n        return curday;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<int,long long int> hash;     long long int curday=0;    \\n        for(int i=0;i<tasks.size();i++){\\n            if(hash.count(tasks[i])) curday=max(curday,hash[tasks[i]]);\\n            hash[tasks[i]]=curday+space+1;\\n            curday+=1;\\n        }\\n        return curday;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388164,
                "title": "java-python-3-use-hashmap-to-store-task-and-next-available-day-w-brief-explanation-and-analysis",
                "content": "Traverse `tasks`, for each task `t`, compute the days needed and update the next available day for `t`.\\n\\n```java\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        Map<Integer, Long> nextAvailableDay = new HashMap<>();\\n        long days = 0;\\n        for (int t : tasks) {\\n            days = Math.max(nextAvailableDay.getOrDefault(t, 0L), days + 1);\\n            nextAvailableDay.put(t, days + space + 1);\\n        }\\n        return days;\\n    }\\n```\\n\\n```python\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        next_available_day, days  = {}, 0\\n        for t in tasks:\\n            days = max(next_available_day.get(t, 0), days + 1)\\n            next_available_day[t] = days + 1 + space\\n        return days\\n```\\n\\n**Analysis:**\\n\\nTime & space: `O(n)`, where `n = tasks.length`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        Map<Integer, Long> nextAvailableDay = new HashMap<>();\\n        long days = 0;\\n        for (int t : tasks) {\\n            days = Math.max(nextAvailableDay.getOrDefault(t, 0L), days + 1);\\n            nextAvailableDay.put(t, days + space + 1);\\n        }\\n        return days;\\n    }\\n```\n```python\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        next_available_day, days  = {}, 0\\n        for t in tasks:\\n            days = max(next_available_day.get(t, 0), days + 1)\\n            next_available_day[t] = days + 1 + space\\n        return days\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2388624,
                "title": "hash-map",
                "content": "We track the day we can work on task `i` using a hash map.\\n\\nInitially, we can work on any task from day zero. After we complete a task, we set the new day we can work on that tast type (`days + space`).\\n\\n**C++**\\n```cpp\\nlong long taskSchedulerII(vector<int>& t, int space) {\\n    unordered_map<int, long long> m;\\n    long long days = 0;\\n    for (int i = 0; i < t.size(); ++i) {\\n        days += 1 + max(0LL, m[t[i]] - days);\\n        m[t[i]] = days + space;\\n    }\\n    return days;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nlong long taskSchedulerII(vector<int>& t, int space) {\\n    unordered_map<int, long long> m;\\n    long long days = 0;\\n    for (int i = 0; i < t.size(); ++i) {\\n        days += 1 + max(0LL, m[t[i]] - days);\\n        m[t[i]] = days + space;\\n    }\\n    return days;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2389035,
                "title": "java-hashmap-for-nextday-explained-with-diagrams",
                "content": "### Ideas\\n\\n**Intuitive Idea(TLE)**\\nUse `hashmap` to store `lastDay` of each task. Pass day one by one. For today `days`, check current task, `days` and `lastDay` has enough break or not.\\n\\n<u>This will cause TLE since we are pass day one by one.\\n\\n**Efficient Idea**\\n\\nuse `hashmap` to record `nextDay` (next day **okay to do same task**)  of various type of task. In this case, we can efficiently fast forward today to that day.\\n\\n\\n### Explanations\\n\\nDifferent situations for today `days`, current task `task`, stored map `nextMap`\\n\\n<img width=\"800\" src=\"https://assets.leetcode.com/users/images/ef51a916-15cc-41a8-9f40-c4ef1502e125_1659808504.2153118.png\">\\n\\n\\n---\\n**Steps**\\n+ Init `days` = 1L, and empty `nextMap`\\n+ Iterate all tasks:\\n\\t+ if could work, update map with days + space + 1  \\n\\t+ if not work, fast forward days to map.get(task)\\n+ return days - 1.\\n\\n\\n**examples**\\n<img width=\"600\" src=\"https://assets.leetcode.com/users/images/629815ed-e27d-4c15-88e3-d8c07dd69a00_1659808128.1880271.png\">\\n<img width=\"800\" src=\"https://assets.leetcode.com/users/images/e91aacc3-e18a-4274-9396-9a2e5592862c_1659808906.394155.png\">\\n<img width=\"800\" src=\"https://assets.leetcode.com/users/images/5d748b02-9f87-4171-91d5-a193d1e24f45_1659808986.027925.png\">\\n<img width=\"800\" src=\"https://assets.leetcode.com/users/images/5ea5928d-df61-4d6e-9b5a-c8316498ba04_1659809014.09696.png\">\\n\\n<img width=\"400\" src=\"https://assets.leetcode.com/users/images/e17ce73f-440a-44f1-98a5-e475005f3164_1659808394.372792.png\">\\n\\n\\n### Code\\nKinda lazy to change map name : `next` => `nextMap` in code\\n```java\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        if(tasks.length == 1) return 1;\\n    \\n        Map<Integer, Long> next = new HashMap<>();\\n        long days = 1L;\\n        int n = tasks.length;\\n        int i = 0;\\n\\n        while(i < n){\\n            int task = tasks[i];\\n            // can do\\n            if(!next.containsKey(task) || days >= next.get(task)){\\n                next.put(task, days + space + 1);\\n                i++;\\n                days++;\\n            }else{\\n                // take break, fastward \\n                days = next.get(task);\\n                next.put(task, days + space + 1);\\n                days++;\\n                i++;\\n            }\\n        }\\n        return days - 1;\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        if(tasks.length == 1) return 1;\\n    \\n        Map<Integer, Long> next = new HashMap<>();\\n        long days = 1L;\\n        int n = tasks.length;\\n        int i = 0;\\n\\n        while(i < n){\\n            int task = tasks[i];\\n            // can do\\n            if(!next.containsKey(task) || days >= next.get(task)){\\n                next.put(task, days + space + 1);\\n                i++;\\n                days++;\\n            }else{\\n                // take break, fastward \\n                days = next.get(task);\\n                next.put(task, days + space + 1);\\n                days++;\\n                i++;\\n            }\\n        }\\n        return days - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388331,
                "title": "java-clean-simple-hashmap",
                "content": "```\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        HashMap<Integer, Long> map = new HashMap<>();\\n        long day = 0;\\n\\n        for (int item : tasks) {\\n            if (map.containsKey(item) && map.get(item) > day)\\n                day = map.get(item);\\n\\n            day++;\\n            map.put(item, day + space);\\n        }\\n\\n        return day;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        HashMap<Integer, Long> map = new HashMap<>();\\n        long day = 0;\\n\\n        for (int item : tasks) {\\n            if (map.containsKey(item) && map.get(item) > day)\\n                day = map.get(item);\\n\\n            day++;\\n            map.put(item, day + space);\\n        }\\n\\n        return day;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388258,
                "title": "easy-c-map-o-n-solution",
                "content": "Use a map that keeps track of the last day you performed task *i*. \\n\\n```\\nlong long taskSchedulerII(vector<int>& tasks, int space) {\\n       unordered_map<long long,long long>m;\\n        long long day=0;\\n        int i=0,n=tasks.size();\\n        while(i<n)\\n        {\\n            if(m.count(tasks[i]) && day-m[tasks[i]]<=space)\\n                day=m[tasks[i]]+space+1;    //next available day\\n            m[tasks[i]]=day;\\n            day++;\\n            i++;\\n        }\\n        return day;\\n    }\\n\\t\\n```\\n\\nT.C. = O(n)\\nS.C. = O(n)\\n\\nUPVOTE if you like.\\nComment below if any doubt.",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nlong long taskSchedulerII(vector<int>& tasks, int space) {\\n       unordered_map<long long,long long>m;\\n        long long day=0;\\n        int i=0,n=tasks.size();\\n        while(i<n)\\n        {\\n            if(m.count(tasks[i]) && day-m[tasks[i]]<=space)\\n                day=m[tasks[i]]+space+1;    //next available day\\n            m[tasks[i]]=day;\\n            day++;\\n            i++;\\n        }\\n        return day;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2388096,
                "title": "c-simple-commented-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) \\n    {\\n        long long days = 0;\\n        \\n        // create the map for storing the task and their execution day\\n        map<int,long long> mp;\\n        \\n        int n=tasks.size(); \\n        \\n        // iterate over the array\\n        for(int i=0;i<n;i++)\\n        {\\n            // if it is not present in our map\\n            // then increase a day for current task execution and store it into out map\\n            if(mp.find(tasks[i])==mp.end())\\n                mp[tasks[i]] = ++days;\\n            \\n            // if it is present in our map \\n            else\\n            {\\n                // check given condition space is satisfied or not\\n                if(days < space+mp[tasks[i]])\\n                    days=space+mp[tasks[i]];\\n                \\n                // increase a day for current task execution and store it into out map\\n                mp[tasks[i]] = ++days;\\n            }\\n        }\\n        return days;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) \\n    {\\n        long long days = 0;\\n        \\n        // create the map for storing the task and their execution day\\n        map<int,long long> mp;\\n        \\n        int n=tasks.size(); \\n        \\n        // iterate over the array\\n        for(int i=0;i<n;i++)\\n        {\\n            // if it is not present in our map\\n            // then increase a day for current task execution and store it into out map\\n            if(mp.find(tasks[i])==mp.end())\\n                mp[tasks[i]] = ++days;\\n            \\n            // if it is present in our map \\n            else\\n            {\\n                // check given condition space is satisfied or not\\n                if(days < space+mp[tasks[i]])\\n                    days=space+mp[tasks[i]];\\n                \\n                // increase a day for current task execution and store it into out map\\n                mp[tasks[i]] = ++days;\\n            }\\n        }\\n        return days;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719201,
                "title": "python-3-7-lines-dict-t-m-90-86",
                "content": "```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        d, day = defaultdict(int),  0                   # d keeps track of task\\'s prev day\\n   \\n        for task in tasks:\\n            day += 1\\n            \\n            if d[task]:\\n                day += max(space+d[task]+1 - day, 0)    # space+d[task]+1 is the next eligible day for task\\n                    \\n            d[task] = day                               # update previous task date\\n        \\n        return day\\n```\\n\\n[https://leetcode.com/submissions/detail/825334913/](http://)",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        d, day = defaultdict(int),  0                   # d keeps track of task\\'s prev day\\n   \\n        for task in tasks:\\n            day += 1\\n            \\n            if d[task]:\\n                day += max(space+d[task]+1 - day, 0)    # space+d[task]+1 is the next eligible day for task\\n                    \\n            d[task] = day                               # update previous task date\\n        \\n        return day\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392309,
                "title": "c-with-explanation-map-2365-task-scheduler-ii",
                "content": "\\t// tasks.size()>=1 so we can start day from 1\\n\\t// map<int,int> will store the {tasks[i], day on which this task is done last time}\\n\\t// if the task[i] is not done before then we can do it on the day mentioned \\n\\t// if the task is done before means we need to check on which day it can be done again \\n\\t// let say we have task 1 which was already done on day 1 \\n\\t// then it can be done on day 5 (as per example 1)\\n\\t// because we have to wait for 3 days (i.e. on day2,day3,day4) \\n\\t// 5 can be calculated as m[task[i]]+space+1 \\n\\t// if currday is less than the required day(m[task[i]]+space+1) (3<5)\\n\\t// then day will be updated (i.e. wait for 3 days and day will become 5)\\n\\t// if we have performed the last task (i.e. i==tasks.size()-1) then we will not update the day \\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong long taskSchedulerII(vector<int>& tasks, int space) {\\n\\t\\t\\tlong long day=1;\\n\\t\\t\\tmap<long long,long long>m;\\n\\t\\t\\tfor(int i=0;i<tasks.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(m.find(tasks[i])==m.end())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tm[tasks[i]]=day;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(day<m[tasks[i]]+space+1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tday=m[tasks[i]]+space+1;\\n\\t\\t\\t\\t\\t\\tm[tasks[i]]=day;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse \\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tm[tasks[i]]=day;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(i==tasks.size()-1) break;\\n\\t\\t\\t\\tday++;\\n\\t\\t\\t}\\n\\t\\t\\treturn day;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tlong long taskSchedulerII(vector<int>& tasks, int space) {\\n\\t\\t\\tlong long day=1;\\n\\t\\t\\tmap<long long,long long>m;\\n\\t\\t\\tfor(int i=0;i<tasks.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(m.find(tasks[i])==m.end())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tm[tasks[i]]=day;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2388403,
                "title": "simple-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        long d=1;\\n        Map<Integer,Long> map=new HashMap<>();\\n        for(int i=0;i<tasks.length;i++){\\n            if(map.containsKey(tasks[i])){\\n                long db=(d-1)-map.get(tasks[i]);\\n                if(db<space){\\n                    d+=space-db;\\n                }\\n            }\\n            map.put(tasks[i],d);\\n            d++;\\n        }\\n        return d-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        long d=1;\\n        Map<Integer,Long> map=new HashMap<>();\\n        for(int i=0;i<tasks.length;i++){\\n            if(map.containsKey(tasks[i])){\\n                long db=(d-1)-map.get(tasks[i]);\\n                if(db<space){\\n                    d+=space-db;\\n                }\\n            }\\n            map.put(tasks[i],d);\\n            d++;\\n        }\\n        return d-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388253,
                "title": "c-hashmap-counting-breaks-explained",
                "content": "Count the breaks for each task required by calculating the gap in number of days between current and previous task with same work type.\\nand store index+breaks instead of index.\\n\\n```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<int,int> mp;\\n        int diff;\\n        long long breaks=0;\\n       \\n        for(int i=0;i<tasks.size();i++)\\n        {\\n            // if the same task was completed previously\\n            if(mp.find(tasks[i])!=mp.end())\\n            {\\n                // calculate the days difference between the two.\\n                diff=breaks+i-mp[tasks[i]];\\n                // if diff is less than or equal to space then increase breaks.\\n                if(diff<=space)\\n                 breaks+=(space+1-diff);         \\n            }   \\n            mp[tasks[i]]=(i+breaks);\\n        }\\n        // return number of breaks+ number of tasks\\n        return (long long)breaks+tasks.size();\\n    }\\n};\\n```\\n\\nTime Complexity: O(N)\\nspace Compleixty: O(N)\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<int,int> mp;\\n        int diff;\\n        long long breaks=0;\\n       \\n        for(int i=0;i<tasks.size();i++)\\n        {\\n            // if the same task was completed previously\\n            if(mp.find(tasks[i])!=mp.end())\\n            {\\n                // calculate the days difference between the two.\\n                diff=breaks+i-mp[tasks[i]];\\n                // if diff is less than or equal to space then increase breaks.\\n                if(diff<=space)\\n                 breaks+=(space+1-diff);         \\n            }   \\n            mp[tasks[i]]=(i+breaks);\\n        }\\n        // return number of breaks+ number of tasks\\n        return (long long)breaks+tasks.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388189,
                "title": "c-easy-map",
                "content": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& a, int space) {\\n        \\n        long long timer  = 0;\\n        map<long long , long long>lastTime;\\n        for(auto task : a)\\n        {\\n            timer++;\\n            if(lastTime.find(task)==lastTime.end())\\n            {\\n                lastTime[task] = timer;\\n            }\\n            else\\n            {\\n\\t\\t    // if we already passed \"space\" days then no worries\\n                if( (timer - lastTime[task]) > space)\\n                {\\n                    lastTime[task] = timer;\\n                }\\n                else\\n                {\\n\\t\\t\\t // find required days to wait\\n                    long long reqDays = space - (timer-lastTime[task]) +1;\\n                    \\n                    timer += reqDays;\\n                    \\n                    lastTime[task] = timer;\\n                }\\n            }\\n        }\\n        return timer;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& a, int space) {\\n        \\n        long long timer  = 0;\\n        map<long long , long long>lastTime;\\n        for(auto task : a)\\n        {\\n            timer++;\\n            if(lastTime.find(task)==lastTime.end())\\n            {\\n                lastTime[task] = timer;\\n            }\\n            else\\n            {\\n\\t\\t    // if we already passed \"space\" days then no worries\\n                if( (timer - lastTime[task]) > space)\\n                {\\n                    lastTime[task] = timer;\\n                }\\n                else\\n                {\\n\\t\\t\\t // find required days to wait\\n                    long long reqDays = space - (timer-lastTime[task]) +1;\\n                    \\n                    timer += reqDays;\\n                    \\n                    lastTime[task] = timer;\\n                }\\n            }\\n        }\\n        return timer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388153,
                "title": "java-simple-solution-map",
                "content": "```\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        long currDay=0L,gap=space;\\n        int len=tasks.length;\\n        Map<Integer,Long> map=new HashMap<>();\\n        for(int i=0;i<len;i++) {\\n            int task=tasks[i];\\n            if(!map.containsKey(task))\\n                map.put(tasks[i],currDay);\\n            else {\\n                long lastDay=map.get(task);\\n                long taskGap=currDay-lastDay;\\n                if(taskGap<=gap)\\n                    currDay+=gap-taskGap+1;\\n                map.put(task,currDay);\\n            }\\n            ++currDay;\\n        }\\n        return currDay;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        long currDay=0L,gap=space;\\n        int len=tasks.length;\\n        Map<Integer,Long> map=new HashMap<>();\\n        for(int i=0;i<len;i++) {\\n            int task=tasks[i];\\n            if(!map.containsKey(task))\\n                map.put(tasks[i],currDay);\\n            else {\\n                long lastDay=map.get(task);\\n                long taskGap=currDay-lastDay;\\n                if(taskGap<=gap)\\n                    currDay+=gap-taskGap+1;\\n                map.put(task,currDay);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3156266,
                "title": "c-using-hash-map-faster-than-90-of-solution",
                "content": "# Code\\n# **PLEASE DO UPVOTE !**\\n**CONNECT WITH ME ON LINKEDIN : https://www.linkedin.com/in/kunal-shaw-/**\\n```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& t, int n) {\\n        long long int cnt=0;\\n        unordered_map<long long int,long long int> mp;\\n        for(int i=0;i<t.size();i++){\\n            if(mp.find(t[i])==mp.end()){\\n                cnt++;\\n                mp[t[i]]=cnt;\\n            }\\n            else{\\n                if(cnt-mp[t[i]]>n){\\n                    cnt++;\\n                    mp[t[i]]=cnt;\\n                    continue;\\n                }\\n                else{\\n                    cnt=(n+mp[t[i]])+1LL;\\n                    mp[t[i]]=cnt;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n![memer-cat.jpg](https://assets.leetcode.com/users/images/dfc2018d-01d8-43da-9889-af2896179f15_1675779280.3429081.jpeg)",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& t, int n) {\\n        long long int cnt=0;\\n        unordered_map<long long int,long long int> mp;\\n        for(int i=0;i<t.size();i++){\\n            if(mp.find(t[i])==mp.end()){\\n                cnt++;\\n                mp[t[i]]=cnt;\\n            }\\n            else{\\n                if(cnt-mp[t[i]]>n){\\n                    cnt++;\\n                    mp[t[i]]=cnt;\\n                    continue;\\n                }\\n                else{\\n                    cnt=(n+mp[t[i]])+1LL;\\n                    mp[t[i]]=cnt;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799705,
                "title": "simple-cpp-solution-of-using-unordered-map-96-faster-17-memeory",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        long long taskSchedulerII(vector<int> &tasks, int space)\\n        {\\n            long long cnt = 0;\\n            unordered_map<int, long> m;\\n            long index = 0;\\n            for (int i = 0; i < tasks.size(); i++)\\n            {\\n                if (m.find(tasks[i]) != m.end())\\n                {\\n                    int dist = index - m[tasks[i]] - 1;\\n                    if (dist < space)\\n                    {\\n                        cnt += (space - dist);\\n                        index += space - dist;\\n                    }\\n                }\\n                m[tasks[i]] = index++;\\n                cnt += 1;\\n            }\\n            return cnt;\\n        }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        long long taskSchedulerII(vector<int> &tasks, int space)\\n        {\\n            long long cnt = 0;\\n            unordered_map<int, long> m;\\n            long index = 0;\\n            for (int i = 0; i < tasks.size(); i++)\\n            {\\n                if (m.find(tasks[i]) != m.end())\\n                {\\n                    int dist = index - m[tasks[i]] - 1;\\n                    if (dist < space)\\n                    {\\n                        cnt += (space - dist);\\n                        index += space - dist;\\n                    }\\n                }\\n                m[tasks[i]] = index++;\\n                cnt += 1;\\n            }\\n            return cnt;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391284,
                "title": "c-o-n-time-solution-using-hashmap-easy-simulation",
                "content": "**Intuition :**\\n\\nFor every task,\\n* If the task has never been done before, do it.\\n* If the task was done atleast space days ago or earlier, do it.\\n* Else take a break.\\n\\n**Implementation :**\\n\\n* We want to simulate the entire process.\\n* Keep track of the day when the task was last performed in a hashmap.\\n* If the task appears for the first time or appeared atleast space days ago, perform the task.\\n* Else update the day to the earliest day such that a gap of space days is maintained.\\n\\n**C++ Solution :**\\n\\n```\\n\\tlong long taskSchedulerII(vector<int>& tasks, int space) {\\n\\t\\tlong long day = 1;\\n\\t\\t\\n\\t\\t// To store the last day when task t was performed\\n        unordered_map <int,long long> prev; \\n\\t\\t\\n        for(int t : tasks) {\\n\\t\\t\\t// If the task appears for the first time, add the day it is being performed on\\n            if(!prev[t]) { \\n                prev[t] = day;\\n                day++;\\n                continue;\\n            }\\n\\t\\t\\t// If the gap is less than space, update day to the earliest possible day and store it in map\\n            if(day <= prev[t] + space) {\\n                day = prev[t] + space + 1;\\n            }\\n            prev[t] = day;\\n\\t\\t\\t// Increment day once the task is performed\\n            day++;\\n        }\\n\\t\\t\\n\\t\\t// After the last task is performed, an extra day is added while incrementing the day\\n        return day-1;\\n    }\\n```\\n\\n**Time Complexity :** O(N)\\n**Space Complexity :** O(N)\\n",
                "solutionTags": [
                    "Hash Table",
                    "Simulation"
                ],
                "code": "```\\n\\tlong long taskSchedulerII(vector<int>& tasks, int space) {\\n\\t\\tlong long day = 1;\\n\\t\\t\\n\\t\\t// To store the last day when task t was performed\\n        unordered_map <int,long long> prev; \\n\\t\\t\\n        for(int t : tasks) {\\n\\t\\t\\t// If the task appears for the first time, add the day it is being performed on\\n            if(!prev[t]) { \\n                prev[t] = day;\\n                day++;\\n                continue;\\n            }\\n\\t\\t\\t// If the gap is less than space, update day to the earliest possible day and store it in map\\n            if(day <= prev[t] + space) {\\n                day = prev[t] + space + 1;\\n            }\\n            prev[t] = day;\\n\\t\\t\\t// Increment day once the task is performed\\n            day++;\\n        }\\n\\t\\t\\n\\t\\t// After the last task is performed, an extra day is added while incrementing the day\\n        return day-1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2388502,
                "title": "c-o-n-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<int,long long>mp;\\n        long long int added=0;\\n        long long count=0;\\n        for(int i=0;i<tasks.size();i++)\\n        {\\n            if(mp.find(tasks[i])!=mp.end())\\n            {\\n                int x=i+added-mp[tasks[i]]-1;\\n                if(x<space)\\n                {\\n                    added+=space-x;                    \\n                }\\n            }\\n            mp[tasks[i]]=i+added;\\n            // cout<<tasks[i]<<\" \"<<added<<\" \"<<mp[tasks[i]]<<endl;\\n        }\\n        return tasks.size()+(long long)added;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<int,long long>mp;\\n        long long int added=0;\\n        long long count=0;\\n        for(int i=0;i<tasks.size();i++)\\n        {\\n            if(mp.find(tasks[i])!=mp.end())\\n            {\\n                int x=i+added-mp[tasks[i]]-1;\\n                if(x<space)\\n                {\\n                    added+=space-x;                    \\n                }\\n            }\\n            mp[tasks[i]]=i+added;\\n            // cout<<tasks[i]<<\" \"<<added<<\" \"<<mp[tasks[i]]<<endl;\\n        }\\n        return tasks.size()+(long long)added;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2388101,
                "title": "hash-table-in-single-pass-with-explanation",
                "content": "#### Rationale\\n* Complete the task if the wait time is lower than the current day. Put the next day for it. Otherwise, skip the `days` to the time where it can be completed\\n* We could use a Hash table to see when we\\'re allowed to do the task\\n\\n##### Complexities\\n* Time: `O(n)`\\n* Space: `O(n)`\\n\\n```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        next_day = defaultdict(int)\\n        days = 1\\n        \\n        for task in tasks:\\n            if next_day[task] <= days:\\n                next_day[task] = days + space + 1\\n                days += 1\\n            else:    \\n                days += next_day[task] - days + 1\\n                next_day[task] = days + space\\n        \\n        return days - 1\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        next_day = defaultdict(int)\\n        days = 1\\n        \\n        for task in tasks:\\n            if next_day[task] <= days:\\n                next_day[task] = days + space + 1\\n                days += 1\\n            else:    \\n                days += next_day[task] - days + 1\\n                next_day[task] = days + space\\n        \\n        return days - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910450,
                "title": "c-easy-explaination-with-quotes",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        // Use a map to keep track of the last occurrence day for each task\\n        unordered_map<int, long long> lastOccurrence;\\n        \\n        // Initialize the current day to 0\\n        long long currentDay = 0;\\n\\n        // Loop through each task in the list\\n        for(int task : tasks) {\\n            // If the task has been executed before\\n            if(lastOccurrence.find(task) != lastOccurrence.end()) {\\n                // Check if the space constraint is satisfied\\n                if(currentDay - lastOccurrence[task] <= space) {\\n                    // If not, move the currentDay ahead\\n                    currentDay = lastOccurrence[task] + space + 1;\\n                } else {\\n                    // If yes, just increment the current day\\n                    currentDay++;\\n                }\\n            } else {\\n                // If the task hasn\\'t been executed before, simply increment the current day\\n                currentDay++;\\n            }\\n\\n            // Update the last occurrence of the task\\n            lastOccurrence[task] = currentDay;\\n        }\\n\\n        return currentDay;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Brainteaser",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        // Use a map to keep track of the last occurrence day for each task\\n        unordered_map<int, long long> lastOccurrence;\\n        \\n        // Initialize the current day to 0\\n        long long currentDay = 0;\\n\\n        // Loop through each task in the list\\n        for(int task : tasks) {\\n            // If the task has been executed before\\n            if(lastOccurrence.find(task) != lastOccurrence.end()) {\\n                // Check if the space constraint is satisfied\\n                if(currentDay - lastOccurrence[task] <= space) {\\n                    // If not, move the currentDay ahead\\n                    currentDay = lastOccurrence[task] + space + 1;\\n                } else {\\n                    // If yes, just increment the current day\\n                    currentDay++;\\n                }\\n            } else {\\n                // If the task hasn\\'t been executed before, simply increment the current day\\n                currentDay++;\\n            }\\n\\n            // Update the last occurrence of the task\\n            lastOccurrence[task] = currentDay;\\n        }\\n\\n        return currentDay;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809625,
                "title": "easy-implementation-using-map-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        int n = tasks.size();\\n        long long days = 0;\\n\\n        map<long long,long long>mp;\\n\\n        for(int i=0; i<n; i++){\\n            days++;\\n            if(mp.find(tasks[i]) != mp.end()){\\n                long long temp = mp[tasks[i]]+space+1;\\n                if(days >= temp) {\\n                    mp[tasks[i]] = days;\\n                }\\n                else {\\n                    days = temp;\\n                    mp[tasks[i]] = days;\\n                }\\n            }\\n            else{\\n                mp[tasks[i]] = days;\\n            }\\n        }\\n\\n        return days;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        int n = tasks.size();\\n        long long days = 0;\\n\\n        map<long long,long long>mp;\\n\\n        for(int i=0; i<n; i++){\\n            days++;\\n            if(mp.find(tasks[i]) != mp.end()){\\n                long long temp = mp[tasks[i]]+space+1;\\n                if(days >= temp) {\\n                    mp[tasks[i]] = days;\\n                }\\n                else {\\n                    days = temp;\\n                    mp[tasks[i]] = days;\\n                }\\n            }\\n            else{\\n                mp[tasks[i]] = days;\\n            }\\n        }\\n\\n        return days;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395345,
                "title": "c",
                "content": "```\\nlong long taskSchedulerII(vector<int>& tasks, int space) {\\n        int n=tasks.size();\\n        unordered_map<long long,long long> mp;\\n        long long ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!mp.count(tasks[i]))\\n            {      \\n                mp[tasks[i]]=ans;\\n                ans++;\\n            }\\n            else \\n            {\\n                if(ans-mp[tasks[i]]>space)\\n                {   \\n                    mp[tasks[i]]=ans;\\n                    ans++;\\n                }\\n                else\\n                {\\n                    ans=(space+mp[tasks[i]])+1;\\n                    mp[tasks[i]]=ans;\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nlong long taskSchedulerII(vector<int>& tasks, int space) {\\n        int n=tasks.size();\\n        unordered_map<long long,long long> mp;\\n        long long ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!mp.count(tasks[i]))\\n            {      \\n                mp[tasks[i]]=ans;\\n                ans++;\\n            }\\n            else \\n            {\\n                if(ans-mp[tasks[i]]>space)\\n                {   \\n                    mp[tasks[i]]=ans;\\n                    ans++;\\n                }\\n                else\\n                {\\n                    ans=(space+mp[tasks[i]])+1;\\n                    mp[tasks[i]]=ans;\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2388800,
                "title": "c-unordered-map-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        long long day = 1;\\n\\t\\t\\n\\t\\t // to store last day \\n\\t\\t //on which we completed a particular task\\n        unordered_map<int ,long long> recent;     \\n        recent[tasks[0]] = day;\\n        for (int i = 1; i < tasks.size(); i++) {\\n            \\n            // if we are doing task for the first time\\n            //just store it\\'s day of completion\\n            \\n            if (recent.find(tasks[i]) == recent.end()) {\\n                day++;\\n                recent[tasks[i]] = day;\\n                \\n                // else we are not doing this task for the first time\\n            } else {\\n\\t\\t\\t\\n\\t\\t\\t     //it means the required days are \\n               //passed after we completed the same task earlier\\n                if (day-recent[tasks[i]] >= space) {      \\n                    day++;\\n                    recent[tasks[i]] = day;\\n                } else {\\n\\t\\t\\t\\t //it means enousgh days have not passed since we completed the same task earlier\\n\\t\\t\\t    // so lets rest for the required days\\n\\t\\t\\t   //and complete the task\\n                    day += space-(day-recent[tasks[i]]); \\n                    day++;                              \\n                    recent[tasks[i]] = day;\\n                }\\n            }\\n        }\\n        return day;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        long long day = 1;\\n\\t\\t\\n\\t\\t // to store last day \\n\\t\\t //on which we completed a particular task\\n        unordered_map<int ,long long> recent;     \\n        recent[tasks[0]] = day;\\n        for (int i = 1; i < tasks.size(); i++) {\\n            \\n            // if we are doing task for the first time\\n            //just store it\\'s day of completion\\n            \\n            if (recent.find(tasks[i]) == recent.end()) {\\n                day++;\\n                recent[tasks[i]] = day;\\n                \\n                // else we are not doing this task for the first time\\n            } else {\\n\\t\\t\\t\\n\\t\\t\\t     //it means the required days are \\n               //passed after we completed the same task earlier\\n                if (day-recent[tasks[i]] >= space) {      \\n                    day++;\\n                    recent[tasks[i]] = day;\\n                } else {\\n\\t\\t\\t\\t //it means enousgh days have not passed since we completed the same task earlier\\n\\t\\t\\t    // so lets rest for the required days\\n\\t\\t\\t   //and complete the task\\n                    day += space-(day-recent[tasks[i]]); \\n                    day++;                              \\n                    recent[tasks[i]] = day;\\n                }\\n            }\\n        }\\n        return day;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388751,
                "title": "map-o-n-c-solution",
                "content": "```\\nTime Complexity :- O(N)\\nSpace Complexity :- O(N)\\n\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        map<long long, long long> m;\\n        for(int i=0; i<tasks.size(); i++)\\n            m[tasks[i]] = INT_MIN;\\n        \\n        long long days = 0;\\n        for(int i=0; i<tasks.size(); i++)\\n        {\\n            if(m[tasks[i]] == INT_MIN)\\n                m[tasks[i]] = days;\\n            \\n            else\\n            {\\n                if((days - m[tasks[i]]) <= space)\\n                    days += space - (days - m[tasks[i]]);\\n            }\\n            \\n            days++;\\n            m[tasks[i]] = days;\\n        }\\n        \\n        return days;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nTime Complexity :- O(N)\\nSpace Complexity :- O(N)\\n\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        map<long long, long long> m;\\n        for(int i=0; i<tasks.size(); i++)\\n            m[tasks[i]] = INT_MIN;\\n        \\n        long long days = 0;\\n        for(int i=0; i<tasks.size(); i++)\\n        {\\n            if(m[tasks[i]] == INT_MIN)\\n                m[tasks[i]] = days;\\n            \\n            else\\n            {\\n                if((days - m[tasks[i]]) <= space)\\n                    days += space - (days - m[tasks[i]]);\\n            }\\n            \\n            days++;\\n            m[tasks[i]] = days;\\n        }\\n        \\n        return days;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388551,
                "title": "task-scheduler-ii-java-hashmap-lc-biweekly-84-approach-commented-easy",
                "content": "```\\n/*\\nApproach:\\n1.  We simply iterate in the array and check if a[i] type of task is present in the map or not.\\n2.  If not present, days increment by one, and we move to next index.\\n3.  But if map contains a[i], we process as follows :\\n\\ta. We find current space = what is the gap of last occurence of a[i] till now\\n\\tb. if this current gap is less than space, calculate breaks and add it to days.\\n\\tb. else if current gap is already more than \"space\", simply day++\\n4. return days\\n*/\\n\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        HashMap<Integer,Integer> mp=new HashMap<>(); //to store a[i] -> index it occured recently at\\n        long days = 0;        \\n        for(int i=0; i<tasks.length ; i++){\\n            if(mp.containsKey(tasks[i])){\\n                //check how long break\\n                long curspace = i - mp.get(tasks[i]) - 1;\\n                if(curspace < space){\\n                    long breaks = space  - curspace;\\n                    days += breaks;\\n\\t\\t\\t\\t\\t //travel map and incr no. of breaks for all keys\\n                    for(Map.Entry<Integer, Integer> it : mp.entrySet()) {\\n                        mp.put( it.getKey() , it.getValue() - (int)breaks);\\n                    }                    \\n                }\\n                mp.put(tasks[i] , i);\\n                days++;                                \\n            }\\n            else{\\n                mp.put(tasks[i] , i);\\n                days++;\\n            }\\n        }\\n        return days;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\nApproach:\\n1.  We simply iterate in the array and check if a[i] type of task is present in the map or not.\\n2.  If not present, days increment by one, and we move to next index.\\n3.  But if map contains a[i], we process as follows :\\n\\ta. We find current space = what is the gap of last occurence of a[i] till now\\n\\tb. if this current gap is less than space, calculate breaks and add it to days.\\n\\tb. else if current gap is already more than \"space\", simply day++\\n4. return days\\n*/\\n\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        HashMap<Integer,Integer> mp=new HashMap<>(); //to store a[i] -> index it occured recently at\\n        long days = 0;        \\n        for(int i=0; i<tasks.length ; i++){\\n            if(mp.containsKey(tasks[i])){\\n                //check how long break\\n                long curspace = i - mp.get(tasks[i]) - 1;\\n                if(curspace < space){\\n                    long breaks = space  - curspace;\\n                    days += breaks;\\n\\t\\t\\t\\t\\t //travel map and incr no. of breaks for all keys\\n                    for(Map.Entry<Integer, Integer> it : mp.entrySet()) {\\n                        mp.put( it.getKey() , it.getValue() - (int)breaks);\\n                    }                    \\n                }\\n                mp.put(tasks[i] , i);\\n                days++;                                \\n            }\\n            else{\\n                mp.put(tasks[i] , i);\\n                days++;\\n            }\\n        }\\n        return days;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388549,
                "title": "java-ez-2-understand",
                "content": "```\\n// approach if the task has been done previously than we have to do it on last+space +1 day\\nclass Solution {\\n    public long taskSchedulerII(int[] nums, int space) {\\n        long days=0;\\n         Map<Integer,Long> map=new HashMap<>();\\n         for(int i=0;i<nums.length;i++){\\n            long last=map.getOrDefault(nums[i],-1-space+0l);\\n             if(last+space<days){\\n                  map.put(nums[i],days);\\n                  days++;\\n             }else{\\n                 days=last+space+1;\\n                 map.put(nums[i],days);\\n                 days++;\\n             }\\n         }\\n        return days;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public long taskSchedulerII(int[] nums, int space) {\\n        long days=0;\\n         Map<Integer,Long> map=new HashMap<>();\\n         for(int i=0;i<nums.length;i++){\\n            long last=map.getOrDefault(nums[i],-1-space+0l);\\n             if(last+space<days){\\n                  map.put(nums[i],days);\\n                  days++;\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 2388542,
                "title": "c-hashmap",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& v, int k) {\\n        ll n=v.size();\\n        ll c=1;\\n        map<ll,ll> m;\\n        for(ll i=0;i<n;i++){\\n            if(m.find(v[i])==m.end()){\\n                m[v[i]]=c;\\n                v[i]=c;\\n                c++;\\n            }else{\\n                v[i]=m[v[i]];\\n            }\\n        }\\n        ll day=1;\\n        vector<ll> f(c,0);\\n        for(ll i=0;i<n;){\\n            if(f[v[i]]<=day){\\n                if(i==(n-1)) return day;\\n                f[v[i]]=(day+k+1);\\n                i++;day++;\\n                continue;\\n            }else{\\n                day=f[v[i]];\\n            } \\n        }return day;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& v, int k) {\\n        ll n=v.size();\\n        ll c=1;\\n        map<ll,ll> m;\\n        for(ll i=0;i<n;i++){\\n            if(m.find(v[i])==m.end()){\\n                m[v[i]]=c;\\n                v[i]=c;\\n                c++;\\n            }else{\\n                v[i]=m[v[i]];\\n            }\\n        }\\n        ll day=1;\\n        vector<ll> f(c,0);\\n        for(ll i=0;i<n;){\\n            if(f[v[i]]<=day){\\n                if(i==(n-1)) return day;\\n                f[v[i]]=(day+k+1);\\n                i++;day++;\\n                continue;\\n            }else{\\n                day=f[v[i]];\\n            } \\n        }return day;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388355,
                "title": "python-easy-approach",
                "content": "```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        \\n        ans = 0\\n        hashset = {}\\n        n = len(tasks)\\n        \\n        for x in set(tasks):\\n            hashset[x] = 0\\n            \\n        i = 0\\n        while i <= n - 1:\\n            flag = ans - hashset[tasks[i]]\\n            if flag >= 0:\\n                ans += 1\\n                hashset[tasks[i]] = ans + space\\n                i += 1\\n            else:\\n                ans += -flag\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        \\n        ans = 0\\n        hashset = {}\\n        n = len(tasks)\\n        \\n        for x in set(tasks):\\n            hashset[x] = 0\\n            \\n        i = 0\\n        while i <= n - 1:\\n            flag = ans - hashset[tasks[i]]\\n            if flag >= 0:\\n                ans += 1\\n                hashset[tasks[i]] = ans + space\\n                i += 1\\n            else:\\n                ans += -flag\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388165,
                "title": "python-simple-o-n-greedy-approach-with-hash-map",
                "content": "When we get to the task with index `i`, we can\\'t move ahead to do any other task, so we have to finish that one. We can keep track of the minimal time to complete the task at index `i` and carry it over to `i + 1`.\\n\\nIf we can immediately complete a task when we see it, that\\'s great. If not, we have to wait until we\\'re able to, because we have no other options. We\\'ll use a hash map to keep track of the next available time that we can complete another task of each type; if we encounter another one of that type before we reach that time, then we have to wait.\\n\\nO(N) time and space complexity.\\n```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        ret = 0\\n        wait = {t: -1 for t in tasks}\\n        for i,t in enumerate(tasks):\\n            w = wait[t]\\n            if w > ret:\\n                ret = w\\n                \\n            wait[t] = ret + space + 1\\n            ret += 1\\n\\n        return ret\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        ret = 0\\n        wait = {t: -1 for t in tasks}\\n        for i,t in enumerate(tasks):\\n            w = wait[t]\\n            if w > ret:\\n                ret = w\\n                \\n            wait[t] = ret + space + 1\\n            ret += 1\\n\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2862992,
                "title": "o-n-c-solution-using-hashmap-and-better-understanding",
                "content": "# Complexity\\n- Time complexity:\\nO(n);\\n- Space complexity:\\nO(n);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n    //In this question we have to check the space between same type of number\\n    //When same number meet we check the distance between them by index - m[tasks[i]]-1\\n    //if this is smaller than space then we take break and update days to space -distance\\n    //We have to update index to space - distance also \\n\\n    //Example: 1 2 1 2 3 1 when we meet 2nd one ,if the distance b/w 1st and 2nd 1\\n   // is smaller than space then we have to take break after that when we found 2nd 2 then we dont have to take break because \\n//the  break for 1 also covers break of 2 \\n//thats why we will update index to space  - distance.\\n\\n//Dry run this code ,then you will get perfect understanding\\n        long long days=0;\\n\\n        unordered_map<int,long long>m;\\n        long long index = 0;\\n\\n\\n        for(int i=0;i<tasks.size();i++){\\n            if(m.find(tasks[i]) != m.end()){\\n                int distance = (index - m[tasks[i]] - 1);\\n                if(distance < space){\\n                    days += space - distance;\\n                    index += space - distance;\\n                }\\n            }\\n            m[tasks[i]] = index++;\\n            days += 1;\\n        }\\n        return days ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n    //In this question we have to check the space between same type of number\\n    //When same number meet we check the distance between them by index - m[tasks[i]]-1\\n    //if this is smaller than space then we take break and update days to space -distance\\n    //We have to update index to space - distance also \\n\\n    //Example: 1 2 1 2 3 1 when we meet 2nd one ,if the distance b/w 1st and 2nd 1\\n   // is smaller than space then we have to take break after that when we found 2nd 2 then we dont have to take break because \\n//the  break for 1 also covers break of 2 \\n//thats why we will update index to space  - distance.\\n\\n//Dry run this code ,then you will get perfect understanding\\n        long long days=0;\\n\\n        unordered_map<int,long long>m;\\n        long long index = 0;\\n\\n\\n        for(int i=0;i<tasks.size();i++){\\n            if(m.find(tasks[i]) != m.end()){\\n                int distance = (index - m[tasks[i]] - 1);\\n                if(distance < space){\\n                    days += space - distance;\\n                    index += space - distance;\\n                }\\n            }\\n            m[tasks[i]] = index++;\\n            days += 1;\\n        }\\n        return days ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437055,
                "title": "java-clean-and-easy-to-understand-solution-hashmap",
                "content": "\\n\\n```\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        int n = tasks.length;\\n        Map<Integer,Long> lastOccur = new HashMap<>();\\n        long currDay = 0;\\n        for(int task: tasks) {\\n            currDay++;\\n            if(lastOccur.containsKey(task)) {\\n                long nextPossible = lastOccur.get(task) + (long)space + 1l;\\n                currDay =  Math.max(currDay,nextPossible);\\n            }\\n            lastOccur.put(task,currDay);\\n        }\\n        return currDay;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        int n = tasks.length;\\n        Map<Integer,Long> lastOccur = new HashMap<>();\\n        long currDay = 0;\\n        for(int task: tasks) {\\n            currDay++;\\n            if(lastOccur.containsKey(task)) {\\n                long nextPossible = lastOccur.get(task) + (long)space + 1l;\\n                currDay =  Math.max(currDay,nextPossible);\\n            }\\n            lastOccur.put(task,currDay);\\n        }\\n        return currDay;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430221,
                "title": "python-dictionary-very-simple-iterative-solution",
                "content": "```\\nRuntime: 1085 ms, faster than 57.14% of Python3 online submissions for Task Scheduler II.\\nMemory Usage: 29.8 MB, less than 100.00% of Python3 online submissions for Task Scheduler II.\\n```\\n\\nHere is the simple python iterative code for Task Scheduler II.\\n\\n```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        task={}\\n        i=0\\n        res=0\\n        while i<len(tasks):\\n            if tasks[i] not in task:\\n                task[tasks[i]]=res\\n            else:\\n                if res-task[tasks[i]]>space:\\n                    \\n                    task[tasks[i]]=res\\n                else:\\n                    res+=space-(res-task[tasks[i]])+1\\n                    task[tasks[i]]=res\\n            i+=1\\n            res+=1\\n    \\n        return res\\n```\\n\\nPlease do upvote if you like the solution.\\nThankyou for reading.\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nRuntime: 1085 ms, faster than 57.14% of Python3 online submissions for Task Scheduler II.\\nMemory Usage: 29.8 MB, less than 100.00% of Python3 online submissions for Task Scheduler II.\\n```\n```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        task={}\\n        i=0\\n        res=0\\n        while i<len(tasks):\\n            if tasks[i] not in task:\\n                task[tasks[i]]=res\\n            else:\\n                if res-task[tasks[i]]>space:\\n                    \\n                    task[tasks[i]]=res\\n                else:\\n                    res+=space-(res-task[tasks[i]])+1\\n                    task[tasks[i]]=res\\n            i+=1\\n            res+=1\\n    \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2416404,
                "title": "c-well-explained-using-unordered-map-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& t, int s) {\\n        \\n        // Basically it stores the days at which an ID last occurred\\n        unordered_map<int,long long> mp; \\n        long long days = 0; // It is basically the current days\\n        \\n        for(int i=0 ; i<t.size() ; i++){\\n            \\n            if(mp.find(t[i]) != mp.end()){\\n                // If (current day) is less than (space + last occurrence of same id)\\n                if(days - mp[t[i]] < s)\\n                    days += s - days + mp[t[i]];\\n            }\\n            // For every case we add 1 as days\\n            days++;\\n            mp[t[i]] = days;\\n        }\\n        return days;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& t, int s) {\\n        \\n        // Basically it stores the days at which an ID last occurred\\n        unordered_map<int,long long> mp; \\n        long long days = 0; // It is basically the current days\\n        \\n        for(int i=0 ; i<t.size() ; i++){\\n            \\n            if(mp.find(t[i]) != mp.end()){\\n                // If (current day) is less than (space + last occurrence of same id)\\n                if(days - mp[t[i]] < s)\\n                    days += s - days + mp[t[i]];\\n            }\\n            // For every case we add 1 as days\\n            days++;\\n            mp[t[i]] = days;\\n        }\\n        return days;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2416247,
                "title": "c-easy-fastest-beats-100-map",
                "content": "```\\n    long long taskSchedulerII(vector<int>& tasks, int space)\\n\\t{\\n       int  n = tasks.size();\\n        //basically stores the time at which an ID last occurred\\n        unordered_map<int,long long> mpp;\\n        long long ans = 0;  //it is basically the current time\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(mpp.find(tasks[i]) != mpp.end())\\n            {\\n                //if (current time) is less than (space + last occurrence of same id)\\n                if(space + mpp[tasks[i]] > ans)\\n                    ans = space + mpp[tasks[i]];    // it is basically ans += (space + mpp[tasks[i]] - ans);\\n            }\\n            \\n            //for every case we add 1 as time\\n            ans++;\\n            \\n            mpp[tasks[i]] = ans;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    long long taskSchedulerII(vector<int>& tasks, int space)\\n\\t{\\n       int  n = tasks.size();\\n        //basically stores the time at which an ID last occurred\\n        unordered_map<int,long long> mpp;\\n        long long ans = 0;  //it is basically the current time\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(mpp.find(tasks[i]) != mpp.end())\\n            {\\n                //if (current time) is less than (space + last occurrence of same id)\\n                if(space + mpp[tasks[i]] > ans)\\n                    ans = space + mpp[tasks[i]];    // it is basically ans += (space + mpp[tasks[i]] - ans);\\n            }\\n            \\n            //for every case we add 1 as time\\n            ans++;\\n            \\n            mpp[tasks[i]] = ans;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2406706,
                "title": "c-hashmap-beats-100-time-and-memory",
                "content": "long long taskSchedulerII(vector<int>& t , int s ) \\n    {\\n        int n = t.size() ;\\n        long long ans = 0 ;\\n        unordered_map< int , long long > m ;\\n        for( auto ele : t )\\n        {\\n            if( m.find(ele) != m.end() )\\n            {\\n                if( m[ele] > ans )\\n                {\\n                    ans = m[ele] ;\\n                }\\n             }\\n              m[ele] = ans + s + 1;\\n           \\n            ans++;\\n        }\\n        return ans ;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "long long taskSchedulerII(vector<int>& t , int s ) \\n    {\\n        int n = t.size() ;\\n        long long ans = 0 ;\\n        unordered_map< int , long long > m ;\\n        for( auto ele : t )\\n        {\\n            if( m.find(ele) != m.end() )\\n            {\\n                if( m[ele] > ans )\\n                {\\n                    ans = m[ele] ;\\n                }\\n             }\\n              m[ele] = ans + s + 1;\\n           \\n            ans++;\\n        }\\n        return ans ;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2397258,
                "title": "c-solution-using-unordered-map",
                "content": "class Solution {\\n# public:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<long long int,long long int>m;\\n        long long int days=0;\\n        for(int i=0;i<tasks.size();i++){\\n            if(m.find(tasks[i])==m.end()){\\n                days++;\\n                m.insert({tasks[i],days});   \\n            }else{\\n               long long int x=m[tasks[i]];\\n                long long int y=days;\\n                x=y-x;\\n                if(x<space){\\n                    days=y+space+1-x;\\n                }else{\\n                    y++;\\n                    days=y;\\n                }\\n                m[tasks[i]]=days;\\n            }\\n        }\\n        return days;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n# public:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<long long int,long long int>m;\\n        long long int days=0;\\n        for(int i=0;i<tasks.size();i++){\\n            if(m.find(tasks[i])==m.end()){\\n                days++;\\n                m.insert({tasks[i],days}",
                "codeTag": "Java"
            },
            {
                "id": 2394940,
                "title": "c-solution",
                "content": "```class Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        long long curr_day = 0;\\n        int n = tasks.size();\\n        map< long long, long long> mp;\\n        for(int i = 0; i < n; i++){\\n            if(mp.count(tasks[i]) == 1){\\n                if(curr_day < mp[tasks[i]] + space){\\n                    curr_day += mp[tasks[i]] + space - curr_day;    \\n                }\\n            }\\n            curr_day++;\\n            mp[tasks[i]] = curr_day;\\n        }\\n        return curr_day;\\n    }\\n};```",
                "solutionTags": [
                    "C"
                ],
                "code": "```class Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        long long curr_day = 0;\\n        int n = tasks.size();\\n        map< long long, long long> mp;\\n        for(int i = 0; i < n; i++){\\n            if(mp.count(tasks[i]) == 1){\\n                if(curr_day < mp[tasks[i]] + space){\\n                    curr_day += mp[tasks[i]] + space - curr_day;    \\n                }\\n            }\\n            curr_day++;\\n            mp[tasks[i]] = curr_day;\\n        }\\n        return curr_day;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2393563,
                "title": "beats-100-cpp-users",
                "content": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& task, int space) {\\n        unordered_map<long long ,long long>m;\\n       long long ans=0;\\n        \\n        for(auto ele:task){\\n            ans++;\\n            if(!m[ele]){\\n                m[ele]=ans;\\n            }\\n            \\n            else{\\n                if(m[ele]<ans-space){\\n                    m[ele]=ans;\\n                }\\n                \\n                else{\\n                   ans=m[ele]+space+1;\\n                    m[ele]=ans;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& task, int space) {\\n        unordered_map<long long ,long long>m;\\n       long long ans=0;\\n        \\n        for(auto ele:task){\\n            ans++;\\n            if(!m[ele]){\\n                m[ele]=ans;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2393062,
                "title": "c-100-faster-and-100-space-optimized-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tlong long taskSchedulerII(vector<int>& tasks, int space) {\\n\\t\\t\\t\\tlong long int n=tasks.size();\\n\\t\\t\\t\\tunordered_map<long long int,long long int>mp;\\n\\t\\t\\t\\tlong long int cday=1;   // day on which you do a particular task\\n\\t\\t\\t\\tfor(long long int i=0; i<n; i++){ \\n\\t\\t\\t\\t\\tif(mp.find(tasks[i])!=mp.end()) {\\n\\t\\t\\t\\t\\t\\tcday=max(mp[tasks[i]]+space+1,cday);\\n\\t\\t\\t\\t\\t\\tmp[tasks[i]]=cday;\\n\\t\\t\\t\\t\\t\\tcday+=1;\\n\\t\\t\\t\\t\\t}else {\\n\\t\\t\\t\\t\\t\\tmp[tasks[i]]=cday;\\n\\t\\t\\t\\t\\t\\tcday+=1;\\n\\t\\t\\t\\t\\t}      \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn cday-1;\\n\\t\\t\\t}\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tlong long taskSchedulerII(vector<int>& tasks, int space) {\\n\\t\\t\\t\\tlong long int n=tasks.size();\\n\\t\\t\\t\\tunordered_map<long long int,long long int>mp;\\n\\t\\t\\t\\tlong long int cday=1;   // day on which you do a particular task\\n\\t\\t\\t\\tfor(long long int i=0; i<n; i++){ \\n\\t\\t\\t\\t\\tif(mp.find(tasks[i])!=mp.end()) {\\n\\t\\t\\t\\t\\t\\tcday=max(mp[tasks[i]]+space+1,cday);\\n\\t\\t\\t\\t\\t\\tmp[tasks[i]]=cday;\\n\\t\\t\\t\\t\\t\\tcday+=1;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2391765,
                "title": "map-c-easy-solution-beginner-friendly",
                "content": "```\\nclass Solution { \\npublic: \\n    long long taskSchedulerII(vector<int>& tasks, int space) { \\n       long long day = 0;\\n        \\n        int n = tasks.size();\\n        map<long,long> lastday;\\n        \\n        for(int i = 0;i<n;i++){\\n            if(lastday.find(tasks[i]) == lastday.end())\\n            {\\n                day++;\\n                lastday[tasks[i]] = day;\\n                continue;\\n            }\\n            long long last_done_day = lastday[tasks[i]];\\n            day = max(day+1,last_done_day + space + 1);\\n            lastday[tasks[i]] = day;\\n        }\\n        return day;\\n    } \\n};\\n```\\n\\n**Do not forget to upvote if you like the solution**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution { \\npublic: \\n    long long taskSchedulerII(vector<int>& tasks, int space) { \\n       long long day = 0;\\n        \\n        int n = tasks.size();\\n        map<long,long> lastday;\\n        \\n        for(int i = 0;i<n;i++){\\n            if(lastday.find(tasks[i]) == lastday.end())\\n            {\\n                day++;\\n                lastday[tasks[i]] = day;\\n                continue;\\n            }\\n            long long last_done_day = lastday[tasks[i]];\\n            day = max(day+1,last_done_day + space + 1);\\n            lastday[tasks[i]] = day;\\n        }\\n        return day;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391053,
                "title": "c-solution-time-o-n-memory-o-n-easy-to-understand",
                "content": "```C#\\npublic class Solution {\\n    public long TaskSchedulerII(int[] tasks, int space) {\\n        Dictionary<int, long> d = new();\\n\\n        long ans = 0;\\n        for (int i = 0; i < tasks.Length; i++)\\n        {\\n            long waitTime = 0;\\n            if (d.ContainsKey(tasks[i]))\\n            {\\n                long timeSpan = ans - d[tasks[i]];\\n                if (timeSpan < space) waitTime = space - timeSpan;\\n            }\\n\\n            ans += waitTime + 1;\\n            d[tasks[i]] = ans;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```C#\\npublic class Solution {\\n    public long TaskSchedulerII(int[] tasks, int space) {\\n        Dictionary<int, long> d = new();\\n\\n        long ans = 0;\\n        for (int i = 0; i < tasks.Length; i++)\\n        {\\n            long waitTime = 0;\\n            if (d.ContainsKey(tasks[i]))\\n            {\\n                long timeSpan = ans - d[tasks[i]];\\n                if (timeSpan < space) waitTime = space - timeSpan;\\n            }\\n\\n            ans += waitTime + 1;\\n            d[tasks[i]] = ans;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389596,
                "title": "c-solution-hashmap-beats-100",
                "content": "```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<ll, ll> mp;\\n        ll ans = 0;\\n        for(int i=0; i<tasks.size(); ++i) {\\n            if(mp.count(tasks[i]) && ans-mp[tasks[i]]<=space) {\\n                ans = (ll)space + mp[tasks[i]] + 1;\\n            }\\n            else ans++;\\n            mp[tasks[i]] = ans;\\n        }\\n     return ans;\\n    }\\n};\\n/**\\nif(find helpful) {\\ndo upvote(); \\n}\\n*/\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<ll, ll> mp;\\n        ll ans = 0;\\n        for(int i=0; i<tasks.size(); ++i) {\\n            if(mp.count(tasks[i]) && ans-mp[tasks[i]]<=space) {\\n                ans = (ll)space + mp[tasks[i]] + 1;\\n            }\\n            else ans++;\\n            mp[tasks[i]] = ans;\\n        }\\n     return ans;\\n    }\\n};\\n/**\\nif(find helpful) {\\ndo upvote(); \\n}\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389573,
                "title": "c-hashmap-o-n",
                "content": "```\\nclass Solution {\\npublic:\\nlong long taskSchedulerII(vector<int>& tasks, int space) {\\n\\tlong long count = 0;\\n\\tunordered_map<long long int, long long int>mp;\\n\\tfor (int i = 0; i < tasks.size(); i++) {\\n\\t\\tif (mp.find(tasks[i]) == mp.end()) {\\n            count++;\\n\\t\\t\\tmp[tasks[i]] = count;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tauto it = mp[tasks[i]];\\n\\t\\t\\tif (count >= it + space + 1) {\\n                count++;\\n\\t\\t\\t\\tmp[tasks[i]] = count;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tcount +=space-(count-mp[tasks[i]])+1;\\n\\t\\t\\t\\tmp[tasks[i]] = count;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nlong long taskSchedulerII(vector<int>& tasks, int space) {\\n\\tlong long count = 0;\\n\\tunordered_map<long long int, long long int>mp;\\n\\tfor (int i = 0; i < tasks.size(); i++) {\\n\\t\\tif (mp.find(tasks[i]) == mp.end()) {\\n            count++;\\n\\t\\t\\tmp[tasks[i]] = count;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tauto it = mp[tasks[i]];\\n\\t\\t\\tif (count >= it + space + 1) {\\n                count++;\\n\\t\\t\\t\\tmp[tasks[i]] = count;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tcount +=space-(count-mp[tasks[i]])+1;\\n\\t\\t\\t\\tmp[tasks[i]] = count;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389499,
                "title": "c-hashing-easy-to-understand-soln-100-fast-soln",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<long long,long long>mp;\\n        int n=tasks.size();\\n        long long day=1;\\n        \\n        for (int i=0; i<n; i++)\\n        {\\n            if (mp.find(tasks[i])==mp.end())\\n            {\\n                mp[tasks[i]]=day;\\n                day++;\\n            }\\n            else{\\n                if (day> mp[tasks[i]]+space)\\n                {\\n                    mp[tasks[i]]=day;\\n                    day++;\\n                }\\n                else {\\n                    day= mp[tasks[i]]+ space+1;\\n                    mp[tasks[i]]=day;\\n                    day++;\\n                }\\n            }\\n        \\n        }\\n        return day-1;\\n        \\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/3908d90b-6ce4-4a5b-9f45-c18b3a64c2e6_1659815969.809943.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<long long,long long>mp;\\n        int n=tasks.size();\\n        long long day=1;\\n        \\n        for (int i=0; i<n; i++)\\n        {\\n            if (mp.find(tasks[i])==mp.end())\\n            {\\n                mp[tasks[i]]=day;\\n                day++;\\n            }\\n            else{\\n                if (day> mp[tasks[i]]+space)\\n                {\\n                    mp[tasks[i]]=day;\\n                    day++;\\n                }\\n                else {\\n                    day= mp[tasks[i]]+ space+1;\\n                    mp[tasks[i]]=day;\\n                    day++;\\n                }\\n            }\\n        \\n        }\\n        return day-1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389226,
                "title": "c-easy-to-understand-hashmap-approach",
                "content": "```\\n\\tclass Solution {\\npublic:\\n\\t// we will be using hashmap to check if task has been done previously or not\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n\\t//current variable to store current time\\n        long long  int curr = 0;\\n        long long int i;\\n        long long n = tasks.size();\\n        unordered_map<long long, long long> mp;\\n        for(i=0;i<n;i++){\\n            if(mp.find(tasks[i]) == mp.end()){          \\n                mp[tasks[i]] = curr + space + 1;        \\n                curr++;\\n            }\\n            else{\\n                if(mp[tasks[i]] > curr){              \\n                    curr = mp[tasks[i]];\\n                }\\n                mp[tasks[i]] = 1 + curr + space;   \\n                curr++;\\n            }\\n        }\\n        return curr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\tclass Solution {\\npublic:\\n\\t// we will be using hashmap to check if task has been done previously or not\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n\\t//current variable to store current time\\n        long long  int curr = 0;\\n        long long int i;\\n        long long n = tasks.size();\\n        unordered_map<long long, long long> mp;\\n        for(i=0;i<n;i++){\\n            if(mp.find(tasks[i]) == mp.end()){          \\n                mp[tasks[i]] = curr + space + 1;        \\n                curr++;\\n            }\\n            else{\\n                if(mp[tasks[i]] > curr){              \\n                    curr = mp[tasks[i]];\\n                }\\n                mp[tasks[i]] = 1 + curr + space;   \\n                curr++;\\n            }\\n        }\\n        return curr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389197,
                "title": "c-hashmap-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<long long,long long> m;\\n        long long d=1;\\n        long long t=space;\\n        for(int i=0;i<tasks.size();i++)\\n        {\\n            long long p=tasks[i];\\n            if(m.find(p)==m.end() || d>(m[p]+t))\\n            {\\n                m[p]=d;\\n                d++;\\n            }\\n            else\\n            {\\n                d=m[p]+t+1;\\n                m[p]=d;\\n                d++;\\n            }\\n        }\\n        return d-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<long long,long long> m;\\n        long long d=1;\\n        long long t=space;\\n        for(int i=0;i<tasks.size();i++)\\n        {\\n            long long p=tasks[i];\\n            if(m.find(p)==m.end() || d>(m[p]+t))\\n            {\\n                m[p]=d;\\n                d++;\\n            }\\n            else\\n            {\\n                d=m[p]+t+1;\\n                m[p]=d;\\n                d++;\\n            }\\n        }\\n        return d-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389036,
                "title": "using-single-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        long long cnt=0;\\n        map<int,int> mp;\\n        for(int i=0;i<tasks.size();i++){\\n            if(mp.find(tasks[i])==mp.end()){\\n                cnt++;\\n                mp[tasks[i]]= cnt-1;\\n            }\\n            else{\\n                int x=cnt-mp[tasks[i]]-1 ;\\n                if(x>=space){\\n                    cnt++;\\n                    mp[tasks[i]]=cnt-1;\\n                }\\n                else{\\n                    cnt+=space-x+1;\\n                    mp[tasks[i]]=cnt-1;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        long long cnt=0;\\n        map<int,int> mp;\\n        for(int i=0;i<tasks.size();i++){\\n            if(mp.find(tasks[i])==mp.end()){\\n                cnt++;\\n                mp[tasks[i]]= cnt-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2388907,
                "title": "c-simple-solution-using-map-and-dynamic-programming-in-o-n-time",
                "content": "class Solution {\\npublic:\\n\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<long long,long long>ans;\\n        ans[tasks[0]]=1;\\n        for(long long i=1;i<tasks.size();i++){\\n            if(ans[tasks[i]]==0){\\n                ans[tasks[i]]=ans[tasks[i-1]]+1;\\n            }else{\\n                ans[tasks[i]]=max(ans[tasks[i-1]]+1,ans[tasks[i]]+space+1);\\n            }\\n        }\\n        return ans[tasks[tasks.size()-1]];\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<long long,long long>ans;\\n        ans[tasks[0]]=1;\\n        for(long long i=1;i<tasks.size();i++){\\n            if(ans[tasks[i]]==0){\\n                ans[tasks[i]]=ans[tasks[i-1]]+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2388845,
                "title": "c-hashmap-o-n-easy-with-comments",
                "content": "```\\n\\n//         The approach is to count days using(i+j) but accessing the array by \\'i\\' ( j counts the number of vacations made).\\n        \\n//        1.  We store the day at which particular type of activity is performed in a map. We check if particular activity is not performed                 earlier then we push it in the map along with the day number.\\n        \\n//        2. If the activity is already performed in past then we check the differnce of days between (the last occurence of this activity)                and (current day).  l=i+j-mp[task[i]]\\n        \\n//        3. if the diff is more than space then we perform it again without increasing j and assign the new day\\'s value to current activity.\\n        \\n//        4.  else we count the jumps (or breaks ) we need to take from work and add it to j.\\nlong long taskSchedulerII(vector<int>& tasks, int space) \\n    {\\n            long long j=0,i=0;\\n            unordered_map<int,long long> mp;\\n            for(i=0;i<tasks.size();i++)\\n            {\\n                    if(mp.find(tasks[i])==mp.end())\\n                    {\\n                            mp[tasks[i]]=i+j;\\n                    }\\n                    else\\n                    {\\n                            int l=i+j-mp[tasks[i]];\\n                            if(l<=space)\\n                            {\\n                            long long jump=(space+mp[tasks[i]]-i-j)+1;  \\n                            j=j+jump;\\n                            }\\n                            mp[tasks[i]]=i+j;     \\n                            \\n                    }\\n            }\\n            return tasks.size()+j;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n//         The approach is to count days using(i+j) but accessing the array by \\'i\\' ( j counts the number of vacations made).\\n        \\n//        1.  We store the day at which particular type of activity is performed in a map. We check if particular activity is not performed                 earlier then we push it in the map along with the day number.\\n        \\n//        2. If the activity is already performed in past then we check the differnce of days between (the last occurence of this activity)                and (current day).  l=i+j-mp[task[i]]\\n        \\n//        3. if the diff is more than space then we perform it again without increasing j and assign the new day\\'s value to current activity.\\n        \\n//        4.  else we count the jumps (or breaks ) we need to take from work and add it to j.\\nlong long taskSchedulerII(vector<int>& tasks, int space) \\n    {\\n            long long j=0,i=0;\\n            unordered_map<int,long long> mp;\\n            for(i=0;i<tasks.size();i++)\\n            {\\n                    if(mp.find(tasks[i])==mp.end())\\n                    {\\n                            mp[tasks[i]]=i+j;\\n                    }\\n                    else\\n                    {\\n                            int l=i+j-mp[tasks[i]];\\n                            if(l<=space)\\n                            {\\n                            long long jump=(space+mp[tasks[i]]-i-j)+1;  \\n                            j=j+jump;\\n                            }\\n                            mp[tasks[i]]=i+j;     \\n                            \\n                    }\\n            }\\n            return tasks.size()+j;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2388642,
                "title": "c-easy-hashmap-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        map<long,long> m;\\n        long long day = 0;\\n        for(int i=0;i<tasks.size();i++){\\n            if(m.find(tasks[i]) == m.end()){\\n                day++;\\n                m[tasks[i]] = day;\\n            }else{\\n                day++;\\n                long long req = space-day+m[tasks[i]]+1;\\n                if(req>0)\\n                    day += req;\\n                m[tasks[i]] = day;\\n            }\\n        }\\n        return day;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        map<long,long> m;\\n        long long day = 0;\\n        for(int i=0;i<tasks.size();i++){\\n            if(m.find(tasks[i]) == m.end()){\\n                day++;\\n                m[tasks[i]] = day;\\n            }else{\\n                day++;\\n                long long req = space-day+m[tasks[i]]+1;\\n                if(req>0)\\n                    day += req;\\n                m[tasks[i]] = day;\\n            }\\n        }\\n        return day;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388487,
                "title": "easy-to-understand-hashmap-solution",
                "content": "class Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& t, int s) {\\n        unordered_map<long long int,long long int>m;\\n        long long int ans=0;\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(m[t[i]]!=0)\\n            {\\n                if(m[t[i]]+s<ans+1)\\n                {\\n                    ans++;\\n                    m[t[i]]=ans;\\n                }\\n                else\\n                {\\n                    ans+=m[t[i]]+s+1-ans;\\n                    m[t[i]]=ans;\\n                }\\n            }\\n            else\\n            {\\n                m[t[i]]=ans+1;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& t, int s) {\\n        unordered_map<long long int,long long int>m;\\n        long long int ans=0;\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(m[t[i]]!=0)\\n            {\\n                if(m[t[i]]+s<ans+1)\\n                {\\n                    ans++;\\n                    m[t[i]]=ans;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2388481,
                "title": "java-only-using-hashmap-o-n",
                "content": "class Solution {\\n\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        long time = 0;\\n        int n = tasks.length;\\n        Map<Integer,Long> map=new HashMap<>();\\n        \\n        for(int i=0; i<n; i++) {\\n            int task=tasks[i];\\n            \\n            if(!map.containsKey(task))\\n                map.put(tasks[i], time);      //If you didn\\'t performed it earlier perform it\\n            else {\\n                long last = map.get(task);\\n                long gap = time - last;\\n                if(gap <= space)\\n                    time += space - gap + 1;      // add gap time in which  you can\\'t perform the task\\n                map.put(task, time);                // then add the current task with next spaces\\n            }\\n            time++;\\n        }\\n        return time;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        long time = 0;\\n        int n = tasks.length;\\n        Map<Integer,Long> map=new HashMap<>();\\n        \\n        for(int i=0; i<n; i++) {\\n            int task=tasks[i];\\n            \\n            if(!map.containsKey(task))\\n                map.put(tasks[i], time);      //If you didn\\'t performed it earlier perform it\\n            else {\\n                long last = map.get(task);\\n                long gap = time - last;\\n                if(gap <= space)\\n                    time += space - gap + 1;      // add gap time in which  you can\\'t perform the task\\n                map.put(task, time);                // then add the current task with next spaces\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2388474,
                "title": "c-map",
                "content": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<long long, long long> maps;\\n        long long days = 0;\\n        for (auto t : tasks) {\\n            if (maps.find(t) == maps.end()) {\\n                maps[t] = ++days;\\n            } else {\\n                if (days - maps[t] > space) {\\n                    maps[t] = ++days;    \\n                } else {\\n                    days += (space - days + maps[t] + 1);\\n                    maps[t] = days;\\n                }\\n            }\\n        }\\n        return days;\\n    }\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<long long, long long> maps;\\n        long long days = 0;\\n        for (auto t : tasks) {\\n            if (maps.find(t) == maps.end()) {\\n                maps[t] = ++days;\\n            } else {\\n                if (days - maps[t] > space) {\\n                    maps[t] = ++days;    \\n                } else {\\n                    days += (space - days + maps[t] + 1);\\n                    maps[t] = days;\\n                }\\n            }\\n        }\\n        return days;\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388287,
                "title": "o-n-single-pass-using-hashmap",
                "content": "**TC: O(n)\\nSC: O(n)**\\n```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        long long ans=0;\\n        unordered_map<int,int> m;\\n        for(int i=0;i<tasks.size();++i){\\n            ans++;\\n            if(m.find(tasks[i])!=m.end()){\\n                int prev=m[tasks[i]];\\n                int diff=ans-prev-1;\\n                if(diff<space) ans+=(space-diff);\\n            }\\n            m[tasks[i]]=ans;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        long long ans=0;\\n        unordered_map<int,int> m;\\n        for(int i=0;i<tasks.size();++i){\\n            ans++;\\n            if(m.find(tasks[i])!=m.end()){\\n                int prev=m[tasks[i]];\\n                int diff=ans-prev-1;\\n                if(diff<space) ans+=(space-diff);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2388279,
                "title": "java-hashmap",
                "content": "After scheduling the current task, remember the earliest possible time the task of this type can be processed next in a hash map.\\n```\\npublic long taskSchedulerII(int[] tasks, int space) {\\n\\tMap<Integer,Long> notEarlierThan= new HashMap<>();\\n\\tlong time= 0;\\n\\tint n= tasks.length;\\n\\t// process tasks in the original order in the tasks array, keeping track of the current time\\n\\tfor(int i=0; i<n; i++){\\n\\t\\tint type= tasks[i];\\n\\t\\t// check if we have a restriction on the time the task of the current type can start, based on previous occurrences of the same type\\n\\t\\tlong earliest= notEarlierThan.getOrDefault(type, 0L);\\n\\t\\t// if we do have a restriction, \"wait\" until that *earliest* time this type of task can start (which we calculated and put in the hashmap before)\\n\\t\\tif(earliest>time) time= earliest;\\n\\t\\t// do the current task - move time by 1\\n\\t\\ttime++;\\n\\t\\t// calculate the earliest time the next task of the same type can start, and remember it in the hashmap\\n\\t\\tnotEarlierThan.put(type, time+space);\\n\\t}\\n\\t// return the time it took to process all tasks\\n\\treturn time;\\n}",
                "solutionTags": [],
                "code": "After scheduling the current task, remember the earliest possible time the task of this type can be processed next in a hash map.\\n```\\npublic long taskSchedulerII(int[] tasks, int space) {\\n\\tMap<Integer,Long> notEarlierThan= new HashMap<>();\\n\\tlong time= 0;\\n\\tint n= tasks.length;\\n\\t// process tasks in the original order in the tasks array, keeping track of the current time\\n\\tfor(int i=0; i<n; i++){\\n\\t\\tint type= tasks[i];\\n\\t\\t// check if we have a restriction on the time the task of the current type can start, based on previous occurrences of the same type\\n\\t\\tlong earliest= notEarlierThan.getOrDefault(type, 0L);\\n\\t\\t// if we do have a restriction, \"wait\" until that *earliest* time this type of task can start (which we calculated and put in the hashmap before)\\n\\t\\tif(earliest>time) time= earliest;\\n\\t\\t// do the current task - move time by 1\\n\\t\\ttime++;\\n\\t\\t// calculate the earliest time the next task of the same type can start, and remember it in the hashmap\\n\\t\\tnotEarlierThan.put(type, time+space);\\n\\t}\\n\\t// return the time it took to process all tasks\\n\\treturn time;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2388216,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        Dict = {}\\n        ans,l = 0,len(tasks)\\n        \\n        for i,n in enumerate(tasks):\\n            if n in Dict:\\n                ans += max(1,space-(ans-Dict[n])+1)\\n            else:\\n                ans+=1\\n            Dict[n] = ans\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        Dict = {}",
                "codeTag": "Java"
            },
            {
                "id": 2388206,
                "title": "kotlin-solution-few-lines-of-code",
                "content": "```\\nclass Solution {\\n    fun taskSchedulerII(tasks: IntArray, space: Int): Long {\\n        var ans = 0L\\n        val map = HashMap<Int, Long>()\\n        val diff = 1L + space\\n        for (i in tasks.indices) {\\n            val lst = map.getOrDefault(tasks[i], -diff)\\n            if (ans - lst < diff) {\\n                ans = lst + diff\\n            } else {\\n                ans++\\n            }\\n            map[tasks[i]] = ans\\n\\n        }\\n        return ans\\n    }\\n}\\n",
                "solutionTags": [
                    "Kotlin",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    fun taskSchedulerII(tasks: IntArray, space: Int): Long {\\n        var ans = 0L\\n        val map = HashMap<Int, Long>()\\n        val diff = 1L + space\\n        for (i in tasks.indices) {\\n            val lst = map.getOrDefault(tasks[i], -diff)\\n            if (ans - lst < diff) {\\n                ans = lst + diff\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2388197,
                "title": "short-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<long long, long long> m;\\n        \\n        long long d = 1, i = 0;\\n        while(i < tasks.size()) {\\n            if(m.find(tasks[i]) == m.end()) m[tasks[i]] = d++, i++;\\n            else {\\n                if(d - m[tasks[i]] - 1 < space) d += space - (d - m[tasks[i]] - 1);\\n                else m[tasks[i]] = d++, i++;\\n                \\n            }\\n        }\\n        return d - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<long long, long long> m;\\n        \\n        long long d = 1, i = 0;\\n        while(i < tasks.size()) {\\n            if(m.find(tasks[i]) == m.end()) m[tasks[i]] = d++, i++;\\n            else {\\n                if(d - m[tasks[i]] - 1 < space) d += space - (d - m[tasks[i]] - 1);\\n                else m[tasks[i]] = d++, i++;\\n                \\n            }\\n        }\\n        return d - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388185,
                "title": "simple-hashmap-c",
                "content": "```\\nlong long taskSchedulerII(vector<int>& tasks, int space) {\\n        long long days=0;\\n        \\n        unordered_map<int,long long>m;\\n        for(auto it : tasks){\\n            days++;\\n            if(m.count(it)==0) m[it]=days;\\n            else{\\n                long long d=m[it];\\n                if(days-d<=space){\\n                    days+=space-(days-d)+1;\\n                    m[it]=days;\\n                }\\n                m[it]=days;\\n            }\\n        }\\n        \\n        return days;\\n    }",
                "solutionTags": [],
                "code": "```\\nlong long taskSchedulerII(vector<int>& tasks, int space) {\\n        long long days=0;\\n        \\n        unordered_map<int,long long>m;\\n        for(auto it : tasks){\\n            days++;\\n            if(m.count(it)==0) m[it]=days;\\n            else{\\n                long long d=m[it];\\n                if(days-d<=space){\\n                    days+=space-(days-d)+1;\\n                    m[it]=days;\\n                }\\n                m[it]=days;\\n            }\\n        }\\n        \\n        return days;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2388141,
                "title": "c-easy-solution-using-hashmap",
                "content": "Approch:- It is  quite different from Task Scheduler.\\n          Please have a look on this problem https://leetcode.com/problems/task-scheduler/\\n  \\nQ:-what is diff?\\nIn Task Scheduler the given tasks can be arranged in any order.But in this question ordere should be maintained\\n\\nQ:-How to solve this question then?\\nAns: we just have to consider if we are currently on a task that is repeated previously.Then the gap between them should be space(given in question).\\nBut it it is the new task or if repeated but the gap(space) is enough then no problem\\n\\n\\nAlgo:-\\n    create a map.we use map considering the task is present at this number(anything).Basically helps in checking gap(space) is enogh or not\\n    \\n```\\n#define ll long long \\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        ll n=tasks.size();\\n        if(n==1)return 1;\\n        \\n        unordered_map<ll,ll> mp;\\n        ll cnt=0;\\n        for(ll i=0;i<n;i++){\\n            if(mp.count(tasks[i])){\\n                ll len=cnt-space;\\n                if(mp[tasks[i]]>=len){\\n                    cnt=mp[tasks[i]]+space+1;//if repeated and space is not enough then add space+1 in previously visited task\\n                }\\n                else cnt++;//if repeated but gap(space) is enough no problem\\n            }\\n            else cnt++;//if new task then increase count with one\\n            \\n            mp[tasks[i]]=cnt;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\nPlease upvote if you like this post",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        ll n=tasks.size();\\n        if(n==1)return 1;\\n        \\n        unordered_map<ll,ll> mp;\\n        ll cnt=0;\\n        for(ll i=0;i<n;i++){\\n            if(mp.count(tasks[i])){\\n                ll len=cnt-space;\\n                if(mp[tasks[i]]>=len){\\n                    cnt=mp[tasks[i]]+space+1;//if repeated and space is not enough then add space+1 in previously visited task\\n                }\\n                else cnt++;//if repeated but gap(space) is enough no problem\\n            }\\n            else cnt++;//if new task then increase count with one\\n            \\n            mp[tasks[i]]=cnt;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388134,
                "title": "very-simple-and-easy-to-understand-c-solution-using-map-with-explaination",
                "content": "<b>Up Vote if you like the solution\\n```\\n    //keep track of next possible day no. when the task can be executed, \\n\\t//and when the i is less then the next possible day count then update ans to possible day \\n\\t//that is stored in the map.\\n   long long taskSchedulerII(vector<int>& tasks, int space) {\\n        map<int, long long> mp;\\n        long long ans = 0;\\n        for(int i = 0; i < tasks.size(); ++i){\\n            if(ans < mp[tasks[i]]) ans = mp[tasks[i]];\\n            else ans++;\\n            mp[tasks[i]] = ans + space + 1;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    //keep track of next possible day no. when the task can be executed, \\n\\t//and when the i is less then the next possible day count then update ans to possible day \\n\\t//that is stored in the map.\\n   long long taskSchedulerII(vector<int>& tasks, int space) {\\n        map<int, long long> mp;\\n        long long ans = 0;\\n        for(int i = 0; i < tasks.size(); ++i){\\n            if(ans < mp[tasks[i]]) ans = mp[tasks[i]];\\n            else ans++;\\n            mp[tasks[i]] = ans + space + 1;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2388112,
                "title": "simple-and-concise-greedy-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        long long day = 0;\\n        // last day when this task was done\\n        unordered_map<int, long long> lastDay;\\n        \\n        for(int task: tasks) {\\n            if(lastDay.find(task) != lastDay.end()) {\\n                // minimum space days needed to do the task again\\n                // note : all tasks must be in same order, hence greedy works\\n                if(day - lastDay[task] <= space) day = lastDay[task] + space + 1;\\n            }\\n            lastDay[task] = day; // perform task\\n            day++; // move to next day\\n        }\\n        \\n        return day;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        long long day = 0;\\n        // last day when this task was done\\n        unordered_map<int, long long> lastDay;\\n        \\n        for(int task: tasks) {\\n            if(lastDay.find(task) != lastDay.end()) {\\n                // minimum space days needed to do the task again\\n                // note : all tasks must be in same order, hence greedy works\\n                if(day - lastDay[task] <= space) day = lastDay[task] + space + 1;\\n            }\\n            lastDay[task] = day; // perform task\\n            day++; // move to next day\\n        }\\n        \\n        return day;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388107,
                "title": "c-hashmap",
                "content": "maintain a hashmap where key is task and value is the last day that type of task was visited.\\n```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& nums, int space) {\\n        unordered_map<long long,long long>m;\\n        long long n = nums.size(),days = 0,i = 0;\\n        while(i<n){\\n            if(m.find(nums[i]) == m.end()){\\n                days++;\\n                m[nums[i]] = days;\\n            }\\n            else{\\n                long long prev = m[nums[i]];\\n                long long cur = days;\\n                if(cur-prev +1 <= space){\\n                    days += space - (cur-prev) +1;\\n                 }\\n                else{\\n                    days++;\\n                }\\n                m[nums[i]] = days;\\n            }\\n            i++;\\n        }\\n        return days;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& nums, int space) {\\n        unordered_map<long long,long long>m;\\n        long long n = nums.size(),days = 0,i = 0;\\n        while(i<n){\\n            if(m.find(nums[i]) == m.end()){\\n                days++;\\n                m[nums[i]] = days;\\n            }\\n            else{\\n                long long prev = m[nums[i]];\\n                long long cur = days;\\n                if(cur-prev +1 <= space){\\n                    days += space - (cur-prev) +1;\\n                 }\\n                else{\\n                    days++;\\n                }\\n                m[nums[i]] = days;\\n            }\\n            i++;\\n        }\\n        return days;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388097,
                "title": "keep-track-of-previous-execution",
                "content": "```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        t = 0\\n        prev = {}\\n        for task in tasks:\\n            if task in prev:\\n                t += max(space - t + prev[task] + 1, 0)\\n            prev[task] = t\\n            t += 1\\n        return t\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        t = 0\\n        prev = {}\\n        for task in tasks:\\n            if task in prev:\\n                t += max(space - t + prev[task] + 1, 0)\\n            prev[task] = t\\n            t += 1\\n        return t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077499,
                "title": "typescript-hashmap-time-o-n-space-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Typescript\\nfunction taskSchedulerII(tasks: number[], space: number): number {\\n    const N = tasks.length;\\n\\n    // Base cases\\n    if (N < 2 || space < 1) {\\n        return N;\\n    }\\n\\n    // Initialize\\n    let day = 0;\\n    const prevs = new Map<number, number>();\\n\\n    // For each task:\\n    for (let i = 0; i < N; prevs.set(tasks[i++], ++day)) {\\n        // Check # of days since last time task type was completed\\n        const elapsed = day - (prevs.get(tasks[i]) ?? -Infinity);\\n        // Add any remaining days to fulfill spacing condition\\n        day += (elapsed < space) ? space - elapsed: 0;\\n        // Update the task\\'s completion day and increment day\\n    }\\n\\n    // Return # of days required\\n    return day;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```Typescript\\nfunction taskSchedulerII(tasks: number[], space: number): number {\\n    const N = tasks.length;\\n\\n    // Base cases\\n    if (N < 2 || space < 1) {\\n        return N;\\n    }\\n\\n    // Initialize\\n    let day = 0;\\n    const prevs = new Map<number, number>();\\n\\n    // For each task:\\n    for (let i = 0; i < N; prevs.set(tasks[i++], ++day)) {\\n        // Check # of days since last time task type was completed\\n        const elapsed = day - (prevs.get(tasks[i]) ?? -Infinity);\\n        // Add any remaining days to fulfill spacing condition\\n        day += (elapsed < space) ? space - elapsed: 0;\\n        // Update the task\\'s completion day and increment day\\n    }\\n\\n    // Return # of days required\\n    return day;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4049682,
                "title": "java-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        // 1 2 - - 1 2 - 3 1\\n        Map<Integer, Long> map = new HashMap<>(); // val, last seen pos\\n        long curPos = 0; // position after adding break\\n        for (int i = 0; i < tasks.length; i++) {\\n            int t = tasks[i];\\n            curPos++;\\n            if (map.containsKey(t)) {\\n                long diff = curPos - map.get(t);\\n                if (diff <= space) {\\n                    curPos += (long) (space - diff + 1);\\n                }\\n            } \\n            map.put(t, curPos);\\n            // System.out.println(i + \" \" + curPos);\\n        }\\n        return (long) curPos;\\n    }\\n}\\n\\n// The return type is LONG !!!\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        // 1 2 - - 1 2 - 3 1\\n        Map<Integer, Long> map = new HashMap<>(); // val, last seen pos\\n        long curPos = 0; // position after adding break\\n        for (int i = 0; i < tasks.length; i++) {\\n            int t = tasks[i];\\n            curPos++;\\n            if (map.containsKey(t)) {\\n                long diff = curPos - map.get(t);\\n                if (diff <= space) {\\n                    curPos += (long) (space - diff + 1);\\n                }\\n            } \\n            map.put(t, curPos);\\n            // System.out.println(i + \" \" + curPos);\\n        }\\n        return (long) curPos;\\n    }\\n}\\n\\n// The return type is LONG !!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033163,
                "title": "using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nlinear solution using hashmap\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        std::unordered_map<long, long> hashmap;\\n        long days{0};\\n        for (auto& task: tasks) {\\n            ++days;\\n            if (hashmap.count(task) == 0) {\\n            } else if (hashmap[task] > days) {\\n              days = hashmap[task];\\n            }\\n            hashmap[task] = days + space + 1;\\n        }\\n        \\n        return days;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        std::unordered_map<long, long> hashmap;\\n        long days{0};\\n        for (auto& task: tasks) {\\n            ++days;\\n            if (hashmap.count(task) == 0) {\\n            } else if (hashmap[task] > days) {\\n              days = hashmap[task];\\n            }\\n            hashmap[task] = days + space + 1;\\n        }\\n        \\n        return days;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005949,
                "title": "python-just-another-solution",
                "content": "```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        \\n\\n        last_time = {}\\n        time = 0\\n        \\n        for task in tasks:\\n            if task not in last_time or last_time[task]+space < time: \\n                time += 1\\n            else:\\n                postpone = space - (time - last_time[task]) + 1\\n                time += postpone\\n            last_time[task] = time\\n\\n        return time\\n                \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        \\n\\n        last_time = {}\\n        time = 0\\n        \\n        for task in tasks:\\n            if task not in last_time or last_time[task]+space < time: \\n                time += 1\\n            else:\\n                postpone = space - (time - last_time[task]) + 1\\n                time += postpone\\n            last_time[task] = time\\n\\n        return time\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930085,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  long long taskSchedulerII(vector<int>& tasks, int space) {\\n    unordered_map<int, long long> taskToNextAvailable;\\n    long long ans = 0;\\n\\n    for (const int task : tasks) {\\n      ans = max(ans + 1, taskToNextAvailable[task]);\\n      taskToNextAvailable[task] = ans + space + 1;\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  long long taskSchedulerII(vector<int>& tasks, int space) {\\n    unordered_map<int, long long> taskToNextAvailable;\\n    long long ans = 0;\\n\\n    for (const int task : tasks) {\\n      ans = max(ans + 1, taskToNextAvailable[task]);\\n      taskToNextAvailable[task] = ans + space + 1;\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925750,
                "title": "c-easy-to-understand-o-n-time-ans-space",
                "content": "# Intuition\\n\\nWe need to insert extra days for break in order to satisfy \"space\" condition.\\nso the final answer is tasks.size() + extra days added.\\n\\n# Approach\\n\\nUse a hash map to record last seen index for a value.\\nThe diff should be greater than \"space\".\\n\\n# Complexity\\n- Time complexity:\\nO(N) just scan it once.\\n\\n- Space complexity:\\nO(N) in map\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        long long ans = 1;\\n        \\n        unordered_map<int, int> mp;  // value to index\\n        long long extra = 0;\\n        for(int i=0; i<tasks.size(); i++) {\\n            if (!mp.count(tasks[i])) {\\n                mp[tasks[i]] = i + extra;\\n                continue;\\n            }\\n\\n            int diff = i + extra - mp[tasks[i]];\\n            if (diff > space) {\\n                mp[tasks[i]] = i + extra;\\n                continue;\\n            }\\n\\n            extra += (space - diff + 1);\\n            mp[tasks[i]] = i + extra;\\n        }\\n        return tasks.size() + extra;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        long long ans = 1;\\n        \\n        unordered_map<int, int> mp;  // value to index\\n        long long extra = 0;\\n        for(int i=0; i<tasks.size(); i++) {\\n            if (!mp.count(tasks[i])) {\\n                mp[tasks[i]] = i + extra;\\n                continue;\\n            }\\n\\n            int diff = i + extra - mp[tasks[i]];\\n            if (diff > space) {\\n                mp[tasks[i]] = i + extra;\\n                continue;\\n            }\\n\\n            extra += (space - diff + 1);\\n            mp[tasks[i]] = i + extra;\\n        }\\n        return tasks.size() + extra;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903503,
                "title": "magic-of-hashmaps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse hashmap to know the previous position of the same task.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<int,long long> mp;\\n        long long ind=0;\\n        for(int i=0;i<tasks.size();i++) {\\n            if(!mp.count(tasks[i])) mp[tasks[i]]=ind++;\\n            else {\\n                //space is not enough\\n                if(ind-mp[tasks[i]]-1<space) {\\n                    ind+=space-(ind-mp[tasks[i]]-1);\\n                    mp[tasks[i]]=ind++;\\n                }\\n                //space is enough\\n                else {\\n                    mp[tasks[i]]=ind++;\\n                }\\n            }\\n        }\\n        return ind;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "class Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<int,long long> mp;\\n        long long ind=0;\\n        for(int i=0;i<tasks.size();i++) {\\n            if(!mp.count(tasks[i])) mp[tasks[i]]=ind++;\\n            else {\\n                //space is not enough\\n                if(ind-mp[tasks[i]]-1<space) {\\n                    ind+=space-(ind-mp[tasks[i]]-1);\\n                    mp[tasks[i]]=ind++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3841297,
                "title": "simple-js-solution-top-100-by-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you like this solution, please +1 \\uD83E\\uDD79\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} tasks\\n * @param {number} space\\n * @return {number}\\n */\\nvar taskSchedulerII = function(tasks, space) {\\n    let cal = {};\\n\\n    let time = 0;\\n    for(let i = 0; i < tasks.length; i++) {\\n        let task = tasks[i];\\n        \\n        if(cal[task] && cal[task] > time) {\\n            var timeBreak = cal[task] - time;\\n            time += timeBreak;\\n            // console.log(\"timeBreak\", timeBreak);\\n        }\\n\\n        cal[task] = time + space + 1;\\n\\n        time++;\\n        // console.log(\"cal\", cal, \"time\", time);\\n        // console.log(\"i\", i, \"task\", task);\\n    }\\n\\n    return time;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tasks\\n * @param {number} space\\n * @return {number}\\n */\\nvar taskSchedulerII = function(tasks, space) {\\n    let cal = {};\\n\\n    let time = 0;\\n    for(let i = 0; i < tasks.length; i++) {\\n        let task = tasks[i];\\n        \\n        if(cal[task] && cal[task] > time) {\\n            var timeBreak = cal[task] - time;\\n            time += timeBreak;\\n            // console.log(\"timeBreak\", timeBreak);\\n        }\\n\\n        cal[task] = time + space + 1;\\n\\n        time++;\\n        // console.log(\"cal\", cal, \"time\", time);\\n        // console.log(\"i\", i, \"task\", task);\\n    }\\n\\n    return time;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3819837,
                "title": "java-hashmap-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        HashMap<Integer, Long> taskCompletion = new HashMap<>(); \\n        long days = 0; \\n\\n        for(int i = 0; i < tasks.length; i++) {\\n            if(!taskCompletion.containsKey(tasks[i])) {\\n                days ++;\\n                taskCompletion.put(tasks[i], days); \\n            }\\n            else {\\n                long dateCompleted = taskCompletion.get(tasks[i]); \\n                if( dateCompleted + space > days) {\\n                    days = dateCompleted + space; \\n                }\\n                days++;\\n                taskCompletion.put(tasks[i], days);\\n            }    \\n        }\\n        \\n        return days;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        HashMap<Integer, Long> taskCompletion = new HashMap<>(); \\n        long days = 0; \\n\\n        for(int i = 0; i < tasks.length; i++) {\\n            if(!taskCompletion.containsKey(tasks[i])) {\\n                days ++;\\n                taskCompletion.put(tasks[i], days); \\n            }\\n            else {\\n                long dateCompleted = taskCompletion.get(tasks[i]); \\n                if( dateCompleted + space > days) {\\n                    days = dateCompleted + space; \\n                }\\n                days++;\\n                taskCompletion.put(tasks[i], days);\\n            }    \\n        }\\n        \\n        return days;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811267,
                "title": "unordered-map-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int k) {\\n        unordered_map<long long, long long> m;\\n        long long days = 0;\\n        \\n        for (int i = 0; i < tasks.size(); ++i) {\\n            if (m.count(tasks[i]) && days - m[tasks[i]] <= k) {\\n                days = m[tasks[i]] + k + 1;\\n            }\\n            m[tasks[i]] = days;\\n            days++;\\n        }\\n        \\n        return days;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int k) {\\n        unordered_map<long long, long long> m;\\n        long long days = 0;\\n        \\n        for (int i = 0; i < tasks.size(); ++i) {\\n            if (m.count(tasks[i]) && days - m[tasks[i]] <= k) {\\n                days = m[tasks[i]] + k + 1;\\n            }\\n            m[tasks[i]] = days;\\n            days++;\\n        }\\n        \\n        return days;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805578,
                "title": "bahut-hi-simple-solution-java-me-maza-hi-aa-jaega",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n\\n\\n    int n = tasks.length;\\n    if(n==0){\\n      return 0;\\n    }\\n    long[] arr = new long[n];\\n    HashMap<Integer , Integer> hm = new HashMap<>();\\n    hm.put(tasks[0],0);\\n    arr[0]=1;\\n    for(int i =1;i<n;i++) {\\n      if (hm.containsKey(tasks[i])) {\\n        int prevIndex = hm.get(tasks[i]);\\n        if ((arr[i - 1] - arr[prevIndex ]) >= space) {\\n          arr[i] = arr[i-1] + 1;\\n          hm.put(tasks[i], i);\\n        } else {\\n          arr[i] = arr[i-1] + 1 + space - (arr[i - 1] - arr[prevIndex ]);\\n          hm.put(tasks[i], i);\\n        }\\n      } else {\\n        arr[i] = arr[i-1] + 1;\\n        hm.put(tasks[i], i);\\n      }\\n    }\\n    return arr[n-1];\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n\\n\\n    int n = tasks.length;\\n    if(n==0){\\n      return 0;\\n    }\\n    long[] arr = new long[n];\\n    HashMap<Integer , Integer> hm = new HashMap<>();\\n    hm.put(tasks[0],0);\\n    arr[0]=1;\\n    for(int i =1;i<n;i++) {\\n      if (hm.containsKey(tasks[i])) {\\n        int prevIndex = hm.get(tasks[i]);\\n        if ((arr[i - 1] - arr[prevIndex ]) >= space) {\\n          arr[i] = arr[i-1] + 1;\\n          hm.put(tasks[i], i);\\n        } else {\\n          arr[i] = arr[i-1] + 1 + space - (arr[i - 1] - arr[prevIndex ]);\\n          hm.put(tasks[i], i);\\n        }\\n      } else {\\n        arr[i] = arr[i-1] + 1;\\n        hm.put(tasks[i], i);\\n      }\\n    }\\n    return arr[n-1];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650408,
                "title": "python-solution-using-hash-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        day = 0\\n        d = {}  # {task : the last day it was performed}\\n\\n        for _, task in enumerate(tasks):\\n            day += 1\\n\\n            # For the 1st task to be performed\\n            if task not in d:\\n                d[task] = day   # update hash map\\n\\n            # If the task was performed before, we have to check idle time.\\n            else:\\n                # If the task is not ready to be performed,\\n                # update day to the day passed as much as space\\n                if d[task] + space >= day:\\n                    day = d[task] + space + 1\\n\\n                d[task] = day   # update hash map\\n\\n        return day\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        day = 0\\n        d = {}  # {task : the last day it was performed}\\n\\n        for _, task in enumerate(tasks):\\n            day += 1\\n\\n            # For the 1st task to be performed\\n            if task not in d:\\n                d[task] = day   # update hash map\\n\\n            # If the task was performed before, we have to check idle time.\\n            else:\\n                # If the task is not ready to be performed,\\n                # update day to the day passed as much as space\\n                if d[task] + space >= day:\\n                    day = d[task] + space + 1\\n\\n                d[task] = day   # update hash map\\n\\n        return day\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596036,
                "title": "a-c-method",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<int, int> mymap;\\n\\n        int n = tasks.size();\\n\\n        vector<long long> ans(n, 1);\\n\\n        for (int i = 0; i < n; i++) {\\n            int task = tasks[i];\\n\\n            if (mymap.count(task)) {\\n                long long max1 = ans[i-1] + 1;\\n                long long max2 = ans[mymap[task]] + space + 1;\\n                // current task take times is the max of two condition:\\n                // condition 1: last task plus one\\n                // condition 2: last same task plus space plus one\\n                // use map to trace the last same task\\'s position\\n                ans[i] = max1 > max2 ? max1 : max2;\\n            } else {\\n                if (i > 0) \\n                    ans[i] = ans[i-1] + 1;\\n            }\\n\\n            mymap[task] = i;\\n        }\\n\\n        return ans[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<int, int> mymap;\\n\\n        int n = tasks.size();\\n\\n        vector<long long> ans(n, 1);\\n\\n        for (int i = 0; i < n; i++) {\\n            int task = tasks[i];\\n\\n            if (mymap.count(task)) {\\n                long long max1 = ans[i-1] + 1;\\n                long long max2 = ans[mymap[task]] + space + 1;\\n                // current task take times is the max of two condition:\\n                // condition 1: last task plus one\\n                // condition 2: last same task plus space plus one\\n                // use map to trace the last same task\\'s position\\n                ans[i] = max1 > max2 ? max1 : max2;\\n            } else {\\n                if (i > 0) \\n                    ans[i] = ans[i-1] + 1;\\n            }\\n\\n            mymap[task] = i;\\n        }\\n\\n        return ans[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584893,
                "title": "solution-using-python-and-dictionary",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        dic = {} # This above dictionary will keep the track of the index where the next similar task is to be placed\\n        curr = 0 # This variable will store the min days needed to complete all tasks\\n\\n        for i in tasks:\\n            if i in dic: # This means this task was done before\\n                expectedTimeForNextTaskOfSimilarType = dic[i] # This will give the min time for the next task of same type to complete\\n                if curr >= expectedTimeForNextTaskOfSimilarType: # The current time is able to accomodate the next task\\n                    dic[i] = curr + space + 1 # We will update the dictionary with the next expected time\\n                    curr += 1 # Increment the current to signify that this element has been added\\n                else: # The current time is not able to accomodate the next task\\n                    curr = dic[i] # The current value has been updated as the are adding thr task with required spaces\\n                    dic[i] += space + 1 # We will update the dictionary with the next expected time\\n                    curr += 1 # Increment the current to signify that this element has been added\\n            else:\\n                dic[i] = curr + space + 1 # Since this is a new entry the next time this task will be available is current length + space + 1\\n                curr += 1 # Increment the current to signify that this element has been added\\n        return curr\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        dic = {} # This above dictionary will keep the track of the index where the next similar task is to be placed\\n        curr = 0 # This variable will store the min days needed to complete all tasks\\n\\n        for i in tasks:\\n            if i in dic: # This means this task was done before\\n                expectedTimeForNextTaskOfSimilarType = dic[i] # This will give the min time for the next task of same type to complete\\n                if curr >= expectedTimeForNextTaskOfSimilarType: # The current time is able to accomodate the next task\\n                    dic[i] = curr + space + 1 # We will update the dictionary with the next expected time\\n                    curr += 1 # Increment the current to signify that this element has been added\\n                else: # The current time is not able to accomodate the next task\\n                    curr = dic[i] # The current value has been updated as the are adding thr task with required spaces\\n                    dic[i] += space + 1 # We will update the dictionary with the next expected time\\n                    curr += 1 # Increment the current to signify that this element has been added\\n            else:\\n                dic[i] = curr + space + 1 # Since this is a new entry the next time this task will be available is current length + space + 1\\n                curr += 1 # Increment the current to signify that this element has been added\\n        return curr\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573940,
                "title": "easy-solution-8-lines-o-n-time-o-n-space",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        day, repeat = 0, {}\\n        for task in tasks:\\n            if task in repeat:\\n                diff = day-repeat[task]\\n                day += 0 if diff >= space else space-diff\\n            day += 1\\n            repeat[task] = day\\n        return day\\n```\\n\\nPlease let me know if any improvements can be made.\\n\\nThanks",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        day, repeat = 0, {}\\n        for task in tasks:\\n            if task in repeat:\\n                diff = day-repeat[task]\\n                day += 0 if diff >= space else space-diff\\n            day += 1\\n            repeat[task] = day\\n        return day\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561247,
                "title": "simple-hashmap-based-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nScan through the inputs tasks array and keep updating the lastExecuted timestamp for each task. If current task i.e., task[i] can be executed on curr day, then just consider it done by increasing the day by 1 else consider adding break time to day (to move day counter by break time).\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) to maintain the map of each tasks last execution time\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<int, long long> lastExecuted;\\n        long long day=0;\\n        for(auto& task: tasks) {\\n            if(lastExecuted.find(task) != lastExecuted.end()) {\\n                if(lastExecuted[task] + space>=day) {\\n                    day += lastExecuted[task] + space - day + 1; \\n                }\\n            } \\n            lastExecuted[task] = day;\\n            day++;\\n        }\\n        return day;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<int, long long> lastExecuted;\\n        long long day=0;\\n        for(auto& task: tasks) {\\n            if(lastExecuted.find(task) != lastExecuted.end()) {\\n                if(lastExecuted[task] + space>=day) {\\n                    day += lastExecuted[task] + space - day + 1; \\n                }\\n            } \\n            lastExecuted[task] = day;\\n            day++;\\n        }\\n        return day;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543596,
                "title": "hindi-solution-easy-to-understand-6-lines-code",
                "content": "# Explanation :\\nDye diye gae code mein, humein ek vector tasks diya gaya hai jo ek task ki list hai, aur ek space integer hai jo tasks ke beech mein kitne samay ka gap hona chahiye. Humko yeh calculate karna hai ki kitne samay tak saare tasks complete ho jayenge.\\n\\n\\n1. Is code mein hum ek unordered_map mp ka upyog kar rahe hain, jismein hum task numbers ko unke corresponding completion days ke saath map kar rahe hain. Yeh map humein task numbers ke corresponding completion days ko track karne mein madad karega.\\n\\n2. Code ke andar, hum loop chalate hain tasks vector par. Har ek task ke liye, hum dekhte hain ki kya yeh task pehle se map mein hai ya nahi (mp.count(tasks[i])). Agar task pehle se map mein hai, toh hum currdays variable ko update karte hain. currdays variable track karega ki ab tak kitne din ho chuke hain, yani kitne tasks complete ho chuke hain.\\n\\n3. Fir hum mp[tasks[i]] ko update karte hain. Ismein hum currdays ko space aur 1 add kar dete hain. Yeh naya completion day hai, jismein hum task number tasks[i] ko assign kar rahe hain.\\n\\n4. Uske baad, hum currdays ko 1 se badha dete hain, kyunki ek aur din beet gaya hai.\\n\\n5. Is tarah, hum saare tasks ke liye loop chalate hain aur unke completion days ko update karte hain. Loop khatam hone ke baad, hum currdays ko return karte hain, jo total completion days hai.\\n\\n6. Yeh approach is prakar kaam karta hai ki agar kisi task ka completion day pehle se map mein hai, toh hum us task ka completion day update karte hain, space ke saath. Yeh space humein gap provide karta hai tasks ke beech mein. Is tarah, hum saare tasks ko ek ek karke process karte hain aur unke completion days ko track karte hain.\\n\\n**Ummid hai ki yeh samajhne mein madad karega! Agar aur kuch samjhna ho, toh poochh sakte hain**.\\nMap\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        \\n        unordered_map<long long,long long> mp ;\\n        long long currdays = 0 ;\\n        for(long long i=0 ;i<tasks.size() ;i++){\\n           if(mp.count(tasks[i])){\\n               currdays = max(currdays, mp[tasks[i]]) ;\\n           }\\n           mp[tasks[i]] = currdays+space+1 ;\\n           currdays += 1 ;\\n        }\\n        return currdays ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Ordered Map",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        \\n        unordered_map<long long,long long> mp ;\\n        long long currdays = 0 ;\\n        for(long long i=0 ;i<tasks.size() ;i++){\\n           if(mp.count(tasks[i])){\\n               currdays = max(currdays, mp[tasks[i]]) ;\\n           }\\n           mp[tasks[i]] = currdays+space+1 ;\\n           currdays += 1 ;\\n        }\\n        return currdays ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3536964,
                "title": "python-skip-days-in-bulk",
                "content": "1. We start at `day 0` and first of all we `day += 1`, why not last?\\nBecause then you\\'ll have to do `return timer - 1`\\n\\n2. Then you check the test case:\\n```\\nspace = 3\\n1 2 3 4 5 6 1 2\\n```\\n3. And realize that you need to have the `max(current timer, next_allowed_time[task_type])` in order to avoid `TLE` for cases when the gap between tasks execution is huge (e.g. `10^5`) .\\n4. After you\\'ve executed a task, update it\\'s `next_allowed_time` to `timer + space + 1`\\n5. Return `timer`\\n\\n```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        timer = 0\\n        next_allowed_time = defaultdict(int)\\n        for task_type in tasks:\\n            timer = max(timer + 1, next_allowed_time[task_type])\\n            next_allowed_time[task_type] = timer + space + 1\\n        return timer\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nspace = 3\\n1 2 3 4 5 6 1 2\\n```\n```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        timer = 0\\n        next_allowed_time = defaultdict(int)\\n        for task_type in tasks:\\n            timer = max(timer + 1, next_allowed_time[task_type])\\n            next_allowed_time[task_type] = timer + space + 1\\n        return timer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514487,
                "title": "java-hashmap-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSeems like the longest step you could get.\\nsteps:[1,2,3,4...]\\n```\\nfor(int i = 0; i < Math.min(max, steps.length); ++i){\\n    max = Math.max(max, steps[i] + i);\\n}\\n\\n```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        Map<Integer, Long> map = new HashMap<>();\\n        map.put(tasks[0], 0l);\\n        for(int i = 1; i < tasks.length; ++i){\\n            long d = map.get(tasks[i - 1]);\\n            if(map.get(tasks[i]) != null)\\n                d = Math.max(map.get(tasks[i]) + space, d);\\n            map.put(tasks[i], d + 1);\\n        }\\n        return map.get(tasks[tasks.length - 1]) + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nfor(int i = 0; i < Math.min(max, steps.length); ++i){\\n    max = Math.max(max, steps[i] + i);\\n}\\n\\n```\n```\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        Map<Integer, Long> map = new HashMap<>();\\n        map.put(tasks[0], 0l);\\n        for(int i = 1; i < tasks.length; ++i){\\n            long d = map.get(tasks[i - 1]);\\n            if(map.get(tasks[i]) != null)\\n                d = Math.max(map.get(tasks[i]) + space, d);\\n            map.put(tasks[i], d + 1);\\n        }\\n        return map.get(tasks[tasks.length - 1]) + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497577,
                "title": "runtime-893-ms-beats-92-55-memory-34-mb-beats-6-38",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        dic,count={},0\\n        for i in range(len(tasks)):\\n            if tasks[i] in dic:\\n                diffIndexs=count-dic[tasks[i]]-1\\n                diff=space-diffIndexs\\n                if diff>0:\\n                    count+=diff\\n                dic[tasks[i]]=count\\n                count+=1\\n            else:\\n                dic[tasks[i]]=count\\n                count+=1\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        dic,count={},0\\n        for i in range(len(tasks)):\\n            if tasks[i] in dic:\\n                diffIndexs=count-dic[tasks[i]]-1\\n                diff=space-diffIndexs\\n                if diff>0:\\n                    count+=diff\\n                dic[tasks[i]]=count\\n                count+=1\\n            else:\\n                dic[tasks[i]]=count\\n                count+=1\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475628,
                "title": "c-avoid-edge-case-by-starting-at-day-space",
                "content": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<int, long long> task2date;\\n        long long day = space;\\n        for(int i = 0; i < tasks.size(); ++i)\\n            task2date[tasks[i]] = (day += 1 + max(0LL, space - day + task2date[tasks[i]]));\\n        return day - space;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<int, long long> task2date;\\n        long long day = space;\\n        for(int i = 0; i < tasks.size(); ++i)\\n            task2date[tasks[i]] = (day += 1 + max(0LL, space - day + task2date[tasks[i]]));\\n        return day - space;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470561,
                "title": "hashing-super-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) \\n    {\\n        int n=tasks.size();\\n        map<int,long long> m;\\n        long long currTime=1;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(m[tasks[x]]!=0 && m[tasks[x]]+space+1>currTime)\\n            {\\n                int diff=m[tasks[x]]+space+1-currTime;\\n                currTime+=diff;\\n            }\\n            m[tasks[x]]=currTime;\\n            currTime++;\\n        }\\n        return currTime-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) \\n    {\\n        int n=tasks.size();\\n        map<int,long long> m;\\n        long long currTime=1;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(m[tasks[x]]!=0 && m[tasks[x]]+space+1>currTime)\\n            {\\n                int diff=m[tasks[x]]+space+1-currTime;\\n                currTime+=diff;\\n            }\\n            m[tasks[x]]=currTime;\\n            currTime++;\\n        }\\n        return currTime-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469848,
                "title": "python-solution-easy-understandable-solution",
                "content": "# Complexity\\n- Time complexity: O9(1)\\n\\n- Space complexity: O(n)\\n# Code\\n\\n```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        done = {}\\n        day = 1\\n        for task in tasks:\\n            if task not in done:\\n                done[task] = day\\n            else:\\n                if abs(done[task] - day) <= space:\\n                    day = done[task] + space + 1\\n                    done[task] = day\\n                else:\\n                    done[task] = day\\n            day += 1\\n        return day - 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        done = {}\\n        day = 1\\n        for task in tasks:\\n            if task not in done:\\n                done[task] = day\\n            else:\\n                if abs(done[task] - day) <= space:\\n                    day = done[task] + space + 1\\n                    done[task] = day\\n                else:\\n                    done[task] = day\\n            day += 1\\n        return day - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443833,
                "title": "java-easy-to-understand-map",
                "content": "```\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        long day = 0;\\n        Map<Integer, Long> map = new HashMap<>();\\n        for(int i = 0; i < tasks.length; i++){\\n            if(map.containsKey(tasks[i])){\\n                long lastDay = map.get(tasks[i]);\\n                day = Math.max(day + 1, lastDay + space + 1);\\n                map.put(tasks[i], day);\\n            }else{\\n                day ++;\\n                map.put(tasks[i], day);\\n            }\\n        }\\n        return day;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        long day = 0;\\n        Map<Integer, Long> map = new HashMap<>();\\n        for(int i = 0; i < tasks.length; i++){\\n            if(map.containsKey(tasks[i])){\\n                long lastDay = map.get(tasks[i]);\\n                day = Math.max(day + 1, lastDay + space + 1);\\n                map.put(tasks[i], day);\\n            }else{\\n                day ++;\\n                map.put(tasks[i], day);\\n            }\\n        }\\n        return day;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431904,
                "title": "easiest-hashmap-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n\\n    long day=1;\\n\\n    HashMap<Integer,Long>mp=new HashMap<>();\\n\\n    for(int i=0;i<tasks.length;i++){\\n        if(!mp.containsKey(tasks[i])){\\n            mp.put(tasks[i],day);\\n        }\\n        else{\\n            if((day-mp.get(tasks[i])-1)<space){\\n                long sum=(day-mp.get(tasks[i]))-1;\\n                day=day+(space-sum);\\n            }\\n            mp.put(tasks[i],day);\\n        }\\n        if(i<tasks.length-1)\\n        day+=1;\\n    }\\n\\n    return day;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n\\n    long day=1;\\n\\n    HashMap<Integer,Long>mp=new HashMap<>();\\n\\n    for(int i=0;i<tasks.length;i++){\\n        if(!mp.containsKey(tasks[i])){\\n            mp.put(tasks[i],day);\\n        }\\n        else{\\n            if((day-mp.get(tasks[i])-1)<space){\\n                long sum=(day-mp.get(tasks[i]))-1;\\n                day=day+(space-sum);\\n            }\\n            mp.put(tasks[i],day);\\n        }\\n        if(i<tasks.length-1)\\n        day+=1;\\n    }\\n\\n    return day;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302812,
                "title": "c-clean-code-hashmap-clean-c-solution-o-n-time-space",
                "content": "# Intuition\\nMy first thought on seeing this problem was to simulate it. The main information that you need for each new task is when the last task was scheduled, since you can only schedule a new task if it was previously scheduled at least `space` time ago. You can easily track the previous time a task occured with a hash map.\\n\\nOne obvious but important thing to note is that a task id `A` that occured before a task id `B` in the `|tasks|` array can never be executed before `A`, even if we havee to wait for `A` to be executed.\\n\\nFrom here, we can basically just simulate the process.\\n\\n# Approach\\n## First attempt - Direct simulation [TLE]\\nFollowing my intuition, my initial code looked something like this:\\n```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        // Mapping between task id --> last time it was executed.\\n        std::unordered_map<int, long long> last_task_time;\\n        long long cur_time = 0;\\n        for (const auto& task_id : tasks) {\\n            // Increment the current time until we can schedule the task.\\n            while (last_task_time.count(task_id) && last_task_time[task_id] + space + 1 > cur_time) {\\n                cur_time++;\\n            }\\n            // Set the time when this task was last executed.\\n            last_task_time[task_id] = cur_time;\\n            // Incrementing the current time after completing this task.\\n            cur_time++;\\n        }\\n        return cur_time;\\n    }\\n};\\n```\\nThis code is just a naive simulation of the problem. While the code looks fairly intuitive, this will TLE due to the `while` statement, since we could potentially be waiting and incrementing our count for a while.\\n\\n## Second attempt - Direct simulation with some optimization [AC]\\nBuilding on the previous approach, I realized you can just directly set the next execution time to the first day after the last task execution time + `space`. This will avoid the expensive `while` statement and the code looks like:\\n\\n```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        // Mapping between task id --> last time it was executed.\\n        std::unordered_map<int, long long> last_task_time;\\n        long long cur_time = 0;\\n        for (const auto& task_id : tasks) {\\n            // If the current time is within |space| time of when |task_id| was last executed,\\n            // fast forward the time to the first time where the task can be unblocked.\\n            if (last_task_time.count(task_id) && last_task_time[task_id] + space + 1 > cur_time) {\\n                cur_time = last_task_time[task_id] + space + 1;\\n            }\\n            // Set the time when this task was last executed.\\n            last_task_time[task_id] = cur_time;\\n            // Incrementing the current time after completing this task.\\n            cur_time += 1;\\n        }\\n        return cur_time;\\n    }\\n};\\n```\\nThis code improved the code from an `O(time)` complexity to an `O(tasks)` complexity.\\n\\n## Third Attempt - Direct simulation but cleaning up the code [AC]\\nThis approach is the same as the above 2 approaches but makes the code more streamlined, at the expense of some readibility.\\n\\n```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        std::unordered_map<int, long long> last_task_time;\\n        long long cur_time = 0;\\n        for (const auto& task_id : tasks) {\\n            if (last_task_time.count(task_id)) {\\n                cur_time = std::max(cur_time, last_task_time[task_id] + space + 1);\\n            }\\n            last_task_time[task_id] = cur_time++;\\n        }\\n        return cur_time;\\n    }\\n};\\n```\\n\\n# Complexity\\nAll of the solutions have:\\n- Time complexity:\\n`O(n)`\\n\\n- Space complexity:\\n`O(n)`\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        // Mapping between task id --> last time it was executed.\\n        std::unordered_map<int, long long> last_task_time;\\n        long long cur_time = 0;\\n        for (const auto& task_id : tasks) {\\n            // Increment the current time until we can schedule the task.\\n            while (last_task_time.count(task_id) && last_task_time[task_id] + space + 1 > cur_time) {\\n                cur_time++;\\n            }\\n            // Set the time when this task was last executed.\\n            last_task_time[task_id] = cur_time;\\n            // Incrementing the current time after completing this task.\\n            cur_time++;\\n        }\\n        return cur_time;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        // Mapping between task id --> last time it was executed.\\n        std::unordered_map<int, long long> last_task_time;\\n        long long cur_time = 0;\\n        for (const auto& task_id : tasks) {\\n            // If the current time is within |space| time of when |task_id| was last executed,\\n            // fast forward the time to the first time where the task can be unblocked.\\n            if (last_task_time.count(task_id) && last_task_time[task_id] + space + 1 > cur_time) {\\n                cur_time = last_task_time[task_id] + space + 1;\\n            }\\n            // Set the time when this task was last executed.\\n            last_task_time[task_id] = cur_time;\\n            // Incrementing the current time after completing this task.\\n            cur_time += 1;\\n        }\\n        return cur_time;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        std::unordered_map<int, long long> last_task_time;\\n        long long cur_time = 0;\\n        for (const auto& task_id : tasks) {\\n            if (last_task_time.count(task_id)) {\\n                cur_time = std::max(cur_time, last_task_time[task_id] + space + 1);\\n            }\\n            last_task_time[task_id] = cur_time++;\\n        }\\n        return cur_time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284614,
                "title": "c-golang-hash-table",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        long long pos = 0;\\n        space++;\\n        unordered_map<int, long long> Map;\\n        for(int task: tasks) {\\n            pos++;\\n            if(Map.find(task) != Map.end()) Map[task] = max(Map[task] + space, pos);\\n            else Map[task] = pos;\\n            pos = max(pos, Map[task]);\\n        }\\n        return pos;\\n    }\\n};\\n\\n---------------------------------------------------\\n\\n// Golang\\nfunc max(a, b int64) int64 {\\n    if a > b {return a}\\n    return b\\n}\\n\\nfunc taskSchedulerII(tasks []int, space int) int64 {\\n    var pos int64 = 0\\n    space++\\n    Map := make(map[int]int64)\\n    for _, task := range tasks {\\n        pos++\\n        if val, ok := Map[task]; ok {\\n            Map[task] = max(val + int64(space), pos)\\n        } else {\\n            Map[task] = pos\\n        }\\n        pos = max(pos, Map[task])\\n    }\\n    return pos\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Hash Table"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        long long pos = 0;\\n        space++;\\n        unordered_map<int, long long> Map;\\n        for(int task: tasks) {\\n            pos++;\\n            if(Map.find(task) != Map.end()) Map[task] = max(Map[task] + space, pos);\\n            else Map[task] = pos;\\n            pos = max(pos, Map[task]);\\n        }\\n        return pos;\\n    }\\n};\\n\\n---------------------------------------------------\\n\\n// Golang\\nfunc max(a, b int64) int64 {\\n    if a > b {return a}\\n    return b\\n}\\n\\nfunc taskSchedulerII(tasks []int, space int) int64 {\\n    var pos int64 = 0\\n    space++\\n    Map := make(map[int]int64)\\n    for _, task := range tasks {\\n        pos++\\n        if val, ok := Map[task]; ok {\\n            Map[task] = max(val + int64(space), pos)\\n        } else {\\n            Map[task] = pos\\n        }\\n        pos = max(pos, Map[task])\\n    }\\n    return pos\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281813,
                "title": "easy-understand-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        dic = {}\\n        res = 0\\n        for t in tasks:\\n            if t in dic and res < dic[t]:\\n                res = dic[t]\\n            dic[t] = res + space + 1\\n            res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        dic = {}\\n        res = 0\\n        for t in tasks:\\n            if t in dic and res < dic[t]:\\n                res = dic[t]\\n            dic[t] = res + space + 1\\n            res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274177,
                "title": "c-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& t, int s) {\\n        long long curDay = 0;\\n        unordered_map<long long, long long> m;\\n        for (int i = 0; i < t.size(); ++i){\\n            int n = t[i];\\n            if (m.find(n) == m.end() || m[n] + s < curDay + 1)\\n                m[n] = ++curDay;\\n            else m[n] = curDay = m[n] + s + 1;\\n        }\\n        return curDay;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& t, int s) {\\n        long long curDay = 0;\\n        unordered_map<long long, long long> m;\\n        for (int i = 0; i < t.size(); ++i){\\n            int n = t[i];\\n            if (m.find(n) == m.end() || m[n] + s < curDay + 1)\\n                m[n] = ++curDay;\\n            else m[n] = curDay = m[n] + s + 1;\\n        }\\n        return curDay;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241512,
                "title": "dpm07-haspmap",
                "content": "\\n```\\nclass Solution:\\n    \"\"\"\\n    Tasks of the same type must be executed in the order they are given,\\n    so we can\\'t use heap\\n\\n    \"\"\"\\n    def taskSchedulerII(self, task_ids, space):\\n        # to keep track of the last day when a task was processed\\n        process = defaultdict(int)\\n        \\n        day = 1\\n        for task_id in task_ids:\\n            if task_id in process:\\n                time = day - process[task_id] - 1\\n                \\n                if time <= space:\\n                    day += space - time\\n            \\n            process[task_id] = day\\n            day += 1\\n        \\n        return day - 1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    Tasks of the same type must be executed in the order they are given,\\n    so we can\\'t use heap\\n\\n    \"\"\"\\n    def taskSchedulerII(self, task_ids, space):\\n        # to keep track of the last day when a task was processed\\n        process = defaultdict(int)\\n        \\n        day = 1\\n        for task_id in task_ids:\\n            if task_id in process:\\n                time = day - process[task_id] - 1\\n                \\n                if time <= space:\\n                    day += space - time\\n            \\n            process[task_id] = day\\n            day += 1\\n        \\n        return day - 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234306,
                "title": "python-hashmap",
                "content": "```\\nclass Solution:\\n    def taskSchedulerII(self, tasks, space):\\n        process = defaultdict(int)\\n        day = 1\\n        for num in tasks:\\n            if num in process:\\n                time = day - process[num] - 1\\n                if time <= space:\\n                    day += space - time\\n                    process[num] = day\\n                    day += 1\\n                else:\\n                    process[num] = day\\n                    day += 1\\n            else:\\n                process[num] = day\\n                day += 1\\n        return day - 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def taskSchedulerII(self, tasks, space):\\n        process = defaultdict(int)\\n        day = 1\\n        for num in tasks:\\n            if num in process:\\n                time = day - process[num] - 1\\n                if time <= space:\\n                    day += space - time\\n                    process[num] = day\\n                    day += 1\\n                else:\\n                    process[num] = day\\n                    day += 1\\n            else:\\n                process[num] = day\\n                day += 1\\n        return day - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225126,
                "title": "crisp-n-clear-o-n-javascript-memory-94-72-meaningful-vars",
                "content": "Time Complexity: O(N)\\nSpace Complexity: O(N)\\n```\\nvar taskSchedulerII = function(tasks, n) {\\n\\tconst config = {};\\n\\tlet totalIteration = 0;\\n\\tlet currentTime = 0;\\n\\tfor (const iterator of tasks) {\\n\\t\\tcurrentTime++;\\n\\t\\tif (!config[iterator]) {\\n\\t\\t\\tconfig[iterator] = 0;\\n\\t\\t} else {\\n\\t\\t\\tif (config[iterator] > currentTime) {\\n\\t\\t\\t\\tlet difference = config[iterator] - currentTime;\\n\\t\\t\\t\\ttotalIteration += difference;\\n\\t\\t\\t\\tcurrentTime += difference;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tconfig[iterator] = currentTime + n + 1;\\n\\t\\ttotalIteration++;\\n\\t}\\n\\n\\treturn totalIteration;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar taskSchedulerII = function(tasks, n) {\\n\\tconst config = {};\\n\\tlet totalIteration = 0;\\n\\tlet currentTime = 0;\\n\\tfor (const iterator of tasks) {\\n\\t\\tcurrentTime++;\\n\\t\\tif (!config[iterator]) {\\n\\t\\t\\tconfig[iterator] = 0;\\n\\t\\t} else {\\n\\t\\t\\tif (config[iterator] > currentTime) {\\n\\t\\t\\t\\tlet difference = config[iterator] - currentTime;\\n\\t\\t\\t\\ttotalIteration += difference;\\n\\t\\t\\t\\tcurrentTime += difference;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tconfig[iterator] = currentTime + n + 1;\\n\\t\\ttotalIteration++;\\n\\t}\\n\\n\\treturn totalIteration;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3209982,
                "title": "very-easy-short-swift",
                "content": "\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func taskSchedulerII(_ tasks: [Int], _ space: Int) -> Int {\\n        var day = 0 \\n        var map = [Int: Int]()\\n        for (i, task) in tasks.enumerated() {\\n            if let d = map[task], day - d - 1 < space {\\n                day += space - day + d + 1\\n            }\\n            map[task] = day\\n            day += 1\\n        }\\n        return day\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    func taskSchedulerII(_ tasks: [Int], _ space: Int) -> Int {\\n        var day = 0 \\n        var map = [Int: Int]()\\n        for (i, task) in tasks.enumerated() {\\n            if let d = map[task], day - d - 1 < space {\\n                day += space - day + d + 1\\n            }\\n            map[task] = day\\n            day += 1\\n        }\\n        return day\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3156501,
                "title": "java-simple-understandable-solution-using-hashmap",
                "content": "\\nThe basic idea is that when we execute a task we add the **task(tasks[i])** and the day after which it can be **executed again(current day + space)** in the hashMap. \\n\\n# Code\\n```\\nclass Solution \\n{\\n    public long taskSchedulerII(int[] tasks, int space) \\n    {\\n        HashMap<Integer,Long> map = new HashMap<>();\\n        long day = 0;\\n\\n        for(int i=0; i<tasks.length; ++i)\\n        {\\n            ++day;\\n\\n            if(!map.containsKey(tasks[i]) || map.get(tasks[i]) < day)\\n            map.put(tasks[i], day+space);\\n            \\n            else if(map.get(tasks[i]) >= day)\\n            {\\n                day = map.get(tasks[i]) + 1;\\n                map.put(tasks[i], day+space);\\n            }\\n        }\\n        return day;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public long taskSchedulerII(int[] tasks, int space) \\n    {\\n        HashMap<Integer,Long> map = new HashMap<>();\\n        long day = 0;\\n\\n        for(int i=0; i<tasks.length; ++i)\\n        {\\n            ++day;\\n\\n            if(!map.containsKey(tasks[i]) || map.get(tasks[i]) < day)\\n            map.put(tasks[i], day+space);\\n            \\n            else if(map.get(tasks[i]) >= day)\\n            {\\n                day = map.get(tasks[i]) + 1;\\n                map.put(tasks[i], day+space);\\n            }\\n        }\\n        return day;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3156437,
                "title": "c-hashmap-simple-simulation-code-for-beginners",
                "content": "```\\nclass Solution {\\npublic:\\n    // taskSchedulerI had condition- any order, that is why we could have done tasks in any order, but here you need to do in order\\n    \\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        long long runningday=1;\\n        unordered_map<int,long long> taskDay; // the day we do the task\\n        for(int i=0;i<tasks.size();i++){\\n            if(taskDay.find(tasks[i])!=taskDay.end()){\\n                int prevDay=taskDay[tasks[i]];\\n                int timePassed=runningday-prevDay-1;\\n                if(timePassed<=space){\\n                    runningday+=(space-timePassed);\\n                }\\n            }\\n            taskDay[tasks[i]]=runningday;\\n            runningday++;\\n        }\\n \\xA0 \\xA0 \\xA0 \\xA0return runningday-1;\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // taskSchedulerI had condition- any order, that is why we could have done tasks in any order, but here you need to do in order\\n    \\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        long long runningday=1;\\n        unordered_map<int,long long> taskDay; // the day we do the task\\n        for(int i=0;i<tasks.size();i++){\\n            if(taskDay.find(tasks[i])!=taskDay.end()){\\n                int prevDay=taskDay[tasks[i]];\\n                int timePassed=runningday-prevDay-1;\\n                if(timePassed<=space){\\n                    runningday+=(space-timePassed);\\n                }\\n            }\\n            taskDay[tasks[i]]=runningday;\\n            runningday++;\\n        }\\n \\xA0 \\xA0 \\xA0 \\xA0return runningday-1;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152207,
                "title": "java-code-faster",
                "content": "**UpVote \\uD83D\\uDD25\\uD83D\\uDE0E\\uD83D\\uDC4D**\\n\\n```\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        \\n        HashMap <Integer, Long> map = new HashMap <Integer, Long>();\\n        \\n        \\n        long dayCount = 0;\\n        \\n        \\n        for(int i = 0; i < tasks.length; i++)\\n        {\\n            if(!map.containsKey(tasks[i])) // if map doesn\\'t contains the task then we can directly put task in map\\n            {\\n                dayCount = dayCount + 1; // switching to next day\\n                map.put(tasks[i], dayCount);\\n            }\\n            \\n            else\\n            {\\n                long dayFreq = map.get(tasks[i]); // taking previous day number of same task\\n                \\n                if(dayCount - dayFreq >= space) // checking differnce of previous day and current day is >= space\\n                {\\n                    dayCount = dayCount + 1; // if condition became true switching to next day updating the map.\\n                    map.put(tasks[i], dayCount);\\n                }\\n                else\\n                {\\n                    long x = dayCount - dayFreq; // checking how many days have been passed\\n                    \\n                    // adding break days in dayCounts to complete min number of days to do same task.\\n                    \\n                    dayCount += space - x; \\n                    \\n                    dayCount = dayCount + 1; // switching to next day\\n                    map.put(tasks[i], dayCount); // updating the map\\n                }\\n            }  \\n        }\\n        \\n        return dayCount;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        \\n        HashMap <Integer, Long> map = new HashMap <Integer, Long>();\\n        \\n        \\n        long dayCount = 0;\\n        \\n        \\n        for(int i = 0; i < tasks.length; i++)\\n        {\\n            if(!map.containsKey(tasks[i])) // if map doesn\\'t contains the task then we can directly put task in map\\n            {\\n                dayCount = dayCount + 1; // switching to next day\\n                map.put(tasks[i], dayCount);\\n            }\\n            \\n            else\\n            {\\n                long dayFreq = map.get(tasks[i]); // taking previous day number of same task\\n                \\n                if(dayCount - dayFreq >= space) // checking differnce of previous day and current day is >= space\\n                {\\n                    dayCount = dayCount + 1; // if condition became true switching to next day updating the map.\\n                    map.put(tasks[i], dayCount);\\n                }\\n                else\\n                {\\n                    long x = dayCount - dayFreq; // checking how many days have been passed\\n                    \\n                    // adding break days in dayCounts to complete min number of days to do same task.\\n                    \\n                    dayCount += space - x; \\n                    \\n                    dayCount = dayCount + 1; // switching to next day\\n                    map.put(tasks[i], dayCount); // updating the map\\n                }\\n            }  \\n        }\\n        \\n        return dayCount;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120448,
                "title": "par-bhai-tu-hai-kon",
                "content": "\\n    long long taskSchedulerII(vector<int>& tasks, int space) \\n    {\\n        long long days=0;\\n        \\n        unordered_map<int,int> mpp;\\n        int n=tasks.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int ele=tasks[i];\\n            \\n            days++;\\n            \\n            if(mpp.count(ele)!=0)\\n            {\\n                int gap=days-mpp[ele]-1;\\n                if(gap<space)\\n                {\\n                    days+=space-gap;\\n                }\\n            }\\n            \\n            mpp[ele]=days;\\n        }\\n            \\n        return days;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n    long long taskSchedulerII(vector<int>& tasks, int space) \\n    {\\n        long long days=0;\\n        \\n        unordered_map<int,int> mpp;\\n        int n=tasks.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int ele=tasks[i];\\n            \\n            days++;\\n            \\n            if(mpp.count(ele)!=0)\\n            {\\n                int gap=days-mpp[ele]-1;\\n                if(gap<space)\\n                {\\n                    days+=space-gap;\\n                }\\n            }\\n            \\n            mpp[ele]=days;\\n        }\\n            \\n        return days;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3033762,
                "title": "simple-linear-java-solution",
                "content": "# Approach\\nUse map to store next available time\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    // O(n) time | O(n) time\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        Map<Integer, Long> nextTimeAvailable = new HashMap<>();\\n        long days = 0;\\n\\n        for (int task : tasks) {\\n            if (nextTimeAvailable.containsKey(task)) {\\n                days = Math.max(days, nextTimeAvailable.get(task));\\n            }\\n            days++; \\n            nextTimeAvailable.put(task, days + space);  \\n        }\\n        return days;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // O(n) time | O(n) time\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        Map<Integer, Long> nextTimeAvailable = new HashMap<>();\\n        long days = 0;\\n\\n        for (int task : tasks) {\\n            if (nextTimeAvailable.containsKey(task)) {\\n                days = Math.max(days, nextTimeAvailable.get(task));\\n            }\\n            days++; \\n            nextTimeAvailable.put(task, days + space);  \\n        }\\n        return days;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3031888,
                "title": "hash-map-c-7-lines-98-60-faster-53-15-lesser-space-simple",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int n ) {\\n        // map to store when a task can be done next\\n        unordered_map <int, long long> m;\\n\\n        // variable to store day count till latest task finished\\n        // ie no tasks done yet, so at day 0\\n        long long curr = 0;\\n\\n        for( auto task: tasks ){\\n            // u can do task after m[task] day\\n            // waiting wherever needed\\n            curr = max( m[task], curr );\\n\\n            // perform task\\n            curr++;\\n\\n            // update when we can do task next\\n            m[task]=curr+n;\\n        }\\n\\n        // return day count after finishing last task\\n        return curr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int n ) {\\n        // map to store when a task can be done next\\n        unordered_map <int, long long> m;\\n\\n        // variable to store day count till latest task finished\\n        // ie no tasks done yet, so at day 0\\n        long long curr = 0;\\n\\n        for( auto task: tasks ){\\n            // u can do task after m[task] day\\n            // waiting wherever needed\\n            curr = max( m[task], curr );\\n\\n            // perform task\\n            curr++;\\n\\n            // update when we can do task next\\n            m[task]=curr+n;\\n        }\\n\\n        // return day count after finishing last task\\n        return curr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3031887,
                "title": "hash-map-c-7-lines-98-60-faster-53-15-lesser-space-simple",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int n ) {\\n        // map to store when a task can be done next\\n        unordered_map <int, long long> m;\\n\\n        // variable to store day count till latest task finished\\n        // ie no tasks done yet, so at day 0\\n        long long curr = 0;\\n\\n        for( auto task: tasks ){\\n            // u can do task after m[task] day\\n            // waiting wherever needed\\n            curr = max( m[task], curr );\\n\\n            // perform task\\n            curr++;\\n\\n            // update when we can do task next\\n            m[task]=curr+n;\\n        }\\n\\n        // return day count after finishing last task\\n        return curr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int n ) {\\n        // map to store when a task can be done next\\n        unordered_map <int, long long> m;\\n\\n        // variable to store day count till latest task finished\\n        // ie no tasks done yet, so at day 0\\n        long long curr = 0;\\n\\n        for( auto task: tasks ){\\n            // u can do task after m[task] day\\n            // waiting wherever needed\\n            curr = max( m[task], curr );\\n\\n            // perform task\\n            curr++;\\n\\n            // update when we can do task next\\n            m[task]=curr+n;\\n        }\\n\\n        // return day count after finishing last task\\n        return curr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019272,
                "title": "c-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEvery time we consider new task, problem divides in two halves.\\n1 - task is availible to complete.\\n2 - task is on cooldown\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate through tasks in order. Every time we consider a task it is a new day.\\nIf the task is availible -> calculate a day, when it can be comleted next.\\nIf the taks is not availible -> skip time till it can be completed and do the calculation again.\\n\\nI think it is possible to improve perfomance using only map insertion function, but i am too lazy to figure it out.\\n\\n# Complexity\\n- Time complexity: O(N log N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        int64_t daysSpent{ 0 };\\n        map<int, int64_t> taskToDay; // <task, day on whick task can be done again>\\n        for (auto &task : tasks)\\n        {\\n            daysSpent++;\\n            auto it = taskToDay.find(task);\\n            if (it != taskToDay.end() && it->second > daysSpent)\\n                daysSpent = it->second;\\n            taskToDay[task] = daysSpent + space + 1;\\n        }\\n        return daysSpent;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        int64_t daysSpent{ 0 };\\n        map<int, int64_t> taskToDay; // <task, day on whick task can be done again>\\n        for (auto &task : tasks)\\n        {\\n            daysSpent++;\\n            auto it = taskToDay.find(task);\\n            if (it != taskToDay.end() && it->second > daysSpent)\\n                daysSpent = it->second;\\n            taskToDay[task] = daysSpent + space + 1;\\n        }\\n        return daysSpent;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000039,
                "title": "simple-java-solution-using-hashmap",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        Map<Integer, Long> map = new HashMap<>();\\n        long res = 0;\\n        for (int task : tasks) {\\n            if (!map.containsKey(task) || res - map.get(task) >= space) {\\n                res++;\\n            } else {\\n                res = map.get(task) + space + 1;\\n            }\\n            map.put(task, res);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        Map<Integer, Long> map = new HashMap<>();\\n        long res = 0;\\n        for (int task : tasks) {\\n            if (!map.containsKey(task) || res - map.get(task) >= space) {\\n                res++;\\n            } else {\\n                res = map.get(task) + space + 1;\\n            }\\n            map.put(task, res);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993552,
                "title": "rust-concise",
                "content": "```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn task_scheduler_ii(tasks: Vec<i32>, space: i32) -> i64 {\\n        let mut h = HashMap::new();\\n        let mut days: i64 = 0;\\n        for t in tasks {\\n            if h.contains_key(&t) {\\n                let past = days - h.get(&t).unwrap() - 1;\\n                if past < space as i64 {\\n                    days += space as i64 - past;\\n                }\\n            }\\n            h.insert(t, days);\\n            days += 1;\\n        } \\n        days\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn task_scheduler_ii(tasks: Vec<i32>, space: i32) -> i64 {\\n        let mut h = HashMap::new();\\n        let mut days: i64 = 0;\\n        for t in tasks {\\n            if h.contains_key(&t) {\\n                let past = days - h.get(&t).unwrap() - 1;\\n                if past < space as i64 {\\n                    days += space as i64 - past;\\n                }\\n            }\\n            h.insert(t, days);\\n            days += 1;\\n        } \\n        days\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2981080,
                "title": "using-a-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        using ll  = long long;\\n        ll ans = 0;\\n        unordered_map<int, ll> mp;\\n        for (int task: tasks){\\n            ans++;\\n            if (mp.count(task)){\\n                if (ans < mp[task]){\\n                    ans = mp[task];\\n                    mp[task] = ans + space + 1;\\n                }else{\\n                    mp[task] = ans + space + 1;\\n                }\\n            }else{\\n                mp[task] = ans + space + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        using ll  = long long;\\n        ll ans = 0;\\n        unordered_map<int, ll> mp;\\n        for (int task: tasks){\\n            ans++;\\n            if (mp.count(task)){\\n                if (ans < mp[task]){\\n                    ans = mp[task];\\n                    mp[task] = ans + space + 1;\\n                }else{\\n                    mp[task] = ans + space + 1;\\n                }\\n            }else{\\n                mp[task] = ans + space + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961433,
                "title": "java-hashmap-solution",
                "content": "i use a hashMap to keep the task\\'s type and last day it was done\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        HashMap<Integer,Long> hashMap = new HashMap<>(); // task\\'s type + last day it was done\\n        long today = 0;\\n        for (int task : tasks) {\\n            today++;\\n            if (hashMap.containsKey(task) && hashMap.get(task) + space >= today) {\\n                today = hashMap.get(task) + space + 1;\\n            }\\n            hashMap.put(task, today);\\n        }\\n        return today;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        HashMap<Integer,Long> hashMap = new HashMap<>(); // task\\'s type + last day it was done\\n        long today = 0;\\n        for (int task : tasks) {\\n            today++;\\n            if (hashMap.containsKey(task) && hashMap.get(task) + space >= today) {\\n                today = hashMap.get(task) + space + 1;\\n            }\\n            hashMap.put(task, today);\\n        }\\n        return today;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948903,
                "title": "c",
                "content": "```\\nlong long taskSchedulerII(int* tasks, int tasksSize, int space){\\n    long long ans = 0;\\n    int n = tasksSize;\\n    int N = 10 * tasksSize;\\n    long long** hash = calloc(N, sizeof(long long*));\\n\\n    for(int i = 0; i < n; i++){\\n        int val = tasks[i];\\n        int d = val;\\n        while(1){\\n            if(hash[d%N] == NULL){\\n                ans += 1;\\n                hash[d%N] = malloc(2 * sizeof(long long));\\n                hash[d%N][0] = tasks[i];\\n                hash[d%N][1] = ans;\\n                break;\\n            }\\n            else if(hash[d%N][0] == tasks[i] ){\\n                ans += 1;\\n                if(ans >= (hash[d%N][1] + space + 1)){\\n                    hash[d%N][1] = ans;\\n                }\\n                else{\\n                    hash[d%N][1] += (space + 1);\\n                    ans = hash[d%N][1] ;\\n                }\\n                break;\\n            }\\n            else\\n                d++;\\n        } \\n    }\\n    for(int i = 0; i < N; i++){\\n        if(hash[i] != NULL)\\n            free(hash[i]);\\n    }\\n    free(hash);\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nlong long taskSchedulerII(int* tasks, int tasksSize, int space){\\n    long long ans = 0;\\n    int n = tasksSize;\\n    int N = 10 * tasksSize;\\n    long long** hash = calloc(N, sizeof(long long*));\\n\\n    for(int i = 0; i < n; i++){\\n        int val = tasks[i];\\n        int d = val;\\n        while(1){\\n            if(hash[d%N] == NULL){\\n                ans += 1;\\n                hash[d%N] = malloc(2 * sizeof(long long));\\n                hash[d%N][0] = tasks[i];\\n                hash[d%N][1] = ans;\\n                break;\\n            }\\n            else if(hash[d%N][0] == tasks[i] ){\\n                ans += 1;\\n                if(ans >= (hash[d%N][1] + space + 1)){\\n                    hash[d%N][1] = ans;\\n                }\\n                else{\\n                    hash[d%N][1] += (space + 1);\\n                    ans = hash[d%N][1] ;\\n                }\\n                break;\\n            }\\n            else\\n                d++;\\n        } \\n    }\\n    for(int i = 0; i < N; i++){\\n        if(hash[i] != NULL)\\n            free(hash[i]);\\n    }\\n    free(hash);\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2901627,
                "title": "java-no-if-conditions",
                "content": "# Intuition\\nUses Math.max to replace explicit if conditions.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        long time=0;\\n        HashMap<Integer,Long> taskTimes=new HashMap<>();\\n\\n        for(int i=0; i<tasks.length; i++) {\\n            int task=tasks[i];\\n            long taskTime=taskTimes.getOrDefault(task, 0l);\\n\\n            long breakTime=Math.max(taskTime-time, 0l) + 1l;\\n            \\n            time+=breakTime;\\n\\n            taskTimes.put(task, time+space);\\n        }\\n        return time;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        long time=0;\\n        HashMap<Integer,Long> taskTimes=new HashMap<>();\\n\\n        for(int i=0; i<tasks.length; i++) {\\n            int task=tasks[i];\\n            long taskTime=taskTimes.getOrDefault(task, 0l);\\n\\n            long breakTime=Math.max(taskTime-time, 0l) + 1l;\\n            \\n            time+=breakTime;\\n\\n            taskTimes.put(task, time+space);\\n        }\\n        return time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878394,
                "title": "python-o-n-space-and-time",
                "content": "```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        blockedTasks = {}\\n        day = 0\\n        \\n        for task in tasks:\\n            if task in blockedTasks:\\n                # if the waiting period has not past, add the required days, else remove from the blocked list\\n                if day <= blockedTasks[task] + space:\\n                    day += (blockedTasks[task] + space) - day + 1\\n                blockedTasks.pop(task)\\n                \\n            blockedTasks[task] = day   \\n            day += 1\\n            \\n        return day",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        blockedTasks = {}",
                "codeTag": "Java"
            },
            {
                "id": 2849432,
                "title": "python-3-o-n-solution-dictionary-and-a-for-loop",
                "content": "```\\ndef taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        day, tAva = 0, {} # tAva store next available day for each task\\n        for t in tasks: # we need to check tasks one by one\\n            try:\\n                if tAva[t]>day:\\n                    # if type cannot be done on a certain day, which means all tasks remained must be delayed\\n                    day = tAva[t] # set day to the available day\\n                tAva[t] = day+space+1 # update next available day for the task\\n            except KeyError:\\n                tAva[t] = day+space+1 # initialize next available day for the task\\n            day+=1 # we assign a task to certian day, thus add one day\\n        return day\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        day, tAva = 0, {} # tAva store next available day for each task\\n        for t in tasks: # we need to check tasks one by one\\n            try:\\n                if tAva[t]>day:\\n                    # if type cannot be done on a certain day, which means all tasks remained must be delayed\\n                    day = tAva[t] # set day to the available day\\n                tAva[t] = day+space+1 # update next available day for the task\\n            except KeyError:\\n                tAva[t] = day+space+1 # initialize next available day for the task\\n            day+=1 # we assign a task to certian day, thus add one day\\n        return day\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2842466,
                "title": "java-using-hashmap-time-complexity-o-n",
                "content": "# class Solution{\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        HashMap<Integer, Long> map = new HashMap<Integer, Long>();\\n        long days = 0;\\n        for(int i=0; i<tasks.length; i++){\\n            if(map.containsKey(tasks[i]) == false){\\n                map.put(tasks[i], days);\\n                days++;\\n            }\\n            else if(days-map.get(tasks[i]) >(long)space){\\n                map.put(tasks[i], days);\\n                days++;\\n            }\\n            else if(map.containsKey(tasks[i])){\\n                long numWaitDays = (long)space - days + map.get(tasks[i])+(long)1;\\n                days += numWaitDays;\\n                map.put(tasks[i], days);\\n                days++;\\n            }\\n        }\\n        return days;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution{\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        HashMap<Integer, Long> map = new HashMap<Integer, Long>();\\n        long days = 0;\\n        for(int i=0; i<tasks.length; i++){\\n            if(map.containsKey(tasks[i]) == false){\\n                map.put(tasks[i], days);\\n                days++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2837774,
                "title": "python-dict-7-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n O(# distinct tasks)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def taskSchedulerII(self, tasks, space):\\n        \"\"\"\\n        :type tasks: List[int]\\n        :type space: int\\n        :rtype: int\\n        \"\"\"\\n        memo = collections.defaultdict(int)\\n        day = 0\\n        for task in tasks:\\n            breaks = memo[task] - day if memo[task] > day else 0\\n            day += breaks + 1\\n            memo[task] = day + space\\n        return day\\n            \\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def taskSchedulerII(self, tasks, space):\\n        \"\"\"\\n        :type tasks: List[int]\\n        :type space: int\\n        :rtype: int\\n        \"\"\"\\n        memo = collections.defaultdict(int)\\n        day = 0\\n        for task in tasks:\\n            breaks = memo[task] - day if memo[task] > day else 0\\n            day += breaks + 1\\n            memo[task] = day + space\\n        return day\\n            \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832762,
                "title": "java-hashmap-single-iteration",
                "content": "# Intuition\\nNeed to track is same type completed within space or before space.\\n\\n# Approach\\nKeep track of every task type in dictionary\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n    \\n        Map<Integer,Long> last = new HashMap<>();\\n        long res =0;\\n        for(int task : tasks){\\n            if(last.containsKey(task))\\n                last.put(task,res = Math.max(res,last.get(task)+space)+1);\\n            else\\n                    last.put(task,++res);    \\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n    \\n        Map<Integer,Long> last = new HashMap<>();\\n        long res =0;\\n        for(int task : tasks){\\n            if(last.containsKey(task))\\n                last.put(task,res = Math.max(res,last.get(task)+space)+1);\\n            else\\n                    last.put(task,++res);    \\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812283,
                "title": "clear-python-solution-with-comments-83-speed-84-space",
                "content": "```\\ndef taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n\\t# keep track of the last time we completed a task of a certain type \\n\\tmostRecent = {} # stores information in the form (task: index)\\n\\tans = 0 # answer\\n\\tfor task in tasks: # go through the tasks\\n\\t\\tif task in mostRecent: # if we have done it before\\n\\t\\t\\tans += max(0, space - (ans - mostRecent[task])) # take as many rest days as we need\\n\\t\\tans += 1 # complete the task\\n\\t\\tmostRecent[task] = ans # update the last time we completed this task\\n\\treturn ans # return the answer\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n\\t# keep track of the last time we completed a task of a certain type \\n\\tmostRecent = {} # stores information in the form (task: index)\\n\\tans = 0 # answer\\n\\tfor task in tasks: # go through the tasks\\n\\t\\tif task in mostRecent: # if we have done it before\\n\\t\\t\\tans += max(0, space - (ans - mostRecent[task])) # take as many rest days as we need\\n\\t\\tans += 1 # complete the task\\n\\t\\tmostRecent[task] = ans # update the last time we completed this task\\n\\treturn ans # return the answer\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2771458,
                "title": "python-dictionary-simulation-time-o-n",
                "content": "class Solution(object):\\n    def taskSchedulerII(self, tasks, space):\\n\\n        dictPreTDay, days = {}, 0 # dictionary record the day which previous task t at; days is the current day \\n        \\n        for t in tasks:\\n            if(t in dictPreTDay):\\n                tmp = max(space - (days - dictPreTDay[t]) + 1, 0) #Check the last time work on task t\\n                days += tmp\\n            dictPreTDay[t] = days   \\n            days += 1\\n        \\n        return days",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def taskSchedulerII(self, tasks, space):\\n\\n        dictPreTDay, days = {}",
                "codeTag": "Java"
            },
            {
                "id": 2745955,
                "title": "simple-hashmap-solution-python",
                "content": "```\\ndef taskSchedulerII(self, tasks: List[int], gap: int) -> int:\\n    time = 0\\n    prev_time = defaultdict(lambda: -inf)\\n    \\n    for task in tasks:\\n        time += 1\\n        if time - prev_time[task] - 1 >= gap:\\n            prev_time[task] = time\\n        else:\\n            time += gap + 1 + prev_time[task] - time\\n            prev_time[task] = time\\n    \\n    return time\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\ndef taskSchedulerII(self, tasks: List[int], gap: int) -> int:\\n    time = 0\\n    prev_time = defaultdict(lambda: -inf)\\n    \\n    for task in tasks:\\n        time += 1\\n        if time - prev_time[task] - 1 >= gap:\\n            prev_time[task] = time\\n        else:\\n            time += gap + 1 + prev_time[task] - time\\n            prev_time[task] = time\\n    \\n    return time\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2739415,
                "title": "golang-map-solution",
                "content": "```go\\nfunc taskSchedulerII(tasks []int, space int) int64 {\\n\\tprevDate := make(map[int]int)\\n\\tday := 0\\n\\tfor _, task := range tasks {\\n\\t\\tday++\\n\\t\\tprev, exists := prevDate[task]\\n\\t\\tif exists == false {\\n\\t\\t\\tprevDate[task] = day\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif prev+space+1 > day {\\n\\t\\t\\tday = prev + space + 1\\n\\t\\t}\\n\\t\\tprevDate[task] = day\\n\\t}\\n\\treturn int64(day)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc taskSchedulerII(tasks []int, space int) int64 {\\n\\tprevDate := make(map[int]int)\\n\\tday := 0\\n\\tfor _, task := range tasks {\\n\\t\\tday++\\n\\t\\tprev, exists := prevDate[task]\\n\\t\\tif exists == false {\\n\\t\\t\\tprevDate[task] = day\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif prev+space+1 > day {\\n\\t\\t\\tday = prev + space + 1\\n\\t\\t}\\n\\t\\tprevDate[task] = day\\n\\t}\\n\\treturn int64(day)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2728161,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        \\n        unordered_map<ll,ll> map;\\n        \\n        ll day = 0;\\n        \\n        for(int i = 0; i < tasks.size(); i++) {    \\n            \\n            if(map.count(tasks[i])) {\\n                if(day <= map[tasks[i]]) day = map[tasks[i]] + 1;\\n            }\\n            \\n            map[tasks[i]] = day + space;\\n            day++;\\n        }\\n        \\n        return day;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        \\n        unordered_map<ll,ll> map;\\n        \\n        ll day = 0;\\n        \\n        for(int i = 0; i < tasks.size(); i++) {    \\n            \\n            if(map.count(tasks[i])) {\\n                if(day <= map[tasks[i]]) day = map[tasks[i]] + 1;\\n            }\\n            \\n            map[tasks[i]] = day + space;\\n            day++;\\n        }\\n        \\n        return day;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707368,
                "title": "java-hashmap-o-n-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        \\n        Map<Integer,Long> seen = new HashMap<>();\\n        long day = 0;\\n        for(int task : tasks) {\\n            day++;\\n            if(!seen.containsKey(task)) {\\n                seen.put(task,day);\\n            } else {\\n                long prevDay = seen.get(task);\\n                // If the diff of currDay and prevDay (for same task) is less than space provided then move the \\n                // current day ahead by space+1.\\n                if(day - prevDay <= space) {\\n                    day = prevDay+space+1;\\n                } \\n                // While loop approach gives TLE.\\n                // while(day - prevDay <= space) {\\n                //     day++;\\n                // }\\n                seen.put(task,day);\\n            }\\n        }\\n        return day;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        \\n        Map<Integer,Long> seen = new HashMap<>();\\n        long day = 0;\\n        for(int task : tasks) {\\n            day++;\\n            if(!seen.containsKey(task)) {\\n                seen.put(task,day);\\n            } else {\\n                long prevDay = seen.get(task);\\n                // If the diff of currDay and prevDay (for same task) is less than space provided then move the \\n                // current day ahead by space+1.\\n                if(day - prevDay <= space) {\\n                    day = prevDay+space+1;\\n                } \\n                // While loop approach gives TLE.\\n                // while(day - prevDay <= space) {\\n                //     day++;\\n                // }\\n                seen.put(task,day);\\n            }\\n        }\\n        return day;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700598,
                "title": "c-simulation",
                "content": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    ll taskSchedulerII(vector<int>& tasks, int space) {\\n        auto max0 = [&](ll val) { return val < 0 ? 0 : val; };\\n        ll day = 0;\\n        unordered_map<int, ll> m; // [type, day]\\n        \\n        for(int type: tasks) {\\n            day++;\\n            if(m.find(type) != m.end()) day += max0(space - day + m[type] + 1);\\n            m[type] = day;\\n        }\\n        \\n        return day;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    ll taskSchedulerII(vector<int>& tasks, int space) {\\n        auto max0 = [&](ll val) { return val < 0 ? 0 : val; };\\n        ll day = 0;\\n        unordered_map<int, ll> m; // [type, day]\\n        \\n        for(int type: tasks) {\\n            day++;\\n            if(m.find(type) != m.end()) day += max0(space - day + m[type] + 1);\\n            m[type] = day;\\n        }\\n        \\n        return day;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684751,
                "title": "java-solution-o-n-time-complexity",
                "content": "```\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        long days = 0;\\n        HashMap<Integer, Long> map = new HashMap<>();\\n        for(int i = 0; i < tasks.length; i++){\\n            int task = tasks[i];\\n            if(map.containsKey(task)){\\n                long day = map.get(task);\\n                long gap = days - day;\\n                if(gap < space){\\n                    days += space - gap;\\n                }\\n                days++;\\n                map.put(task, days);\\n                \\n            }\\n            else{\\n                days++;\\n                map.put(task, days);\\n            }\\n        }\\n        \\n        return days;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        long days = 0;\\n        HashMap<Integer, Long> map = new HashMap<>();\\n        for(int i = 0; i < tasks.length; i++){\\n            int task = tasks[i];\\n            if(map.containsKey(task)){\\n                long day = map.get(task);\\n                long gap = days - day;\\n                if(gap < space){\\n                    days += space - gap;\\n                }\\n                days++;\\n                map.put(task, days);\\n                \\n            }\\n            else{\\n                days++;\\n                map.put(task, days);\\n            }\\n        }\\n        \\n        return days;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661190,
                "title": "simple-java-map",
                "content": "Use a map to track the last same type of task\\'s completion date.\\nIf you like it please upvote, thanks\\n\\n```\\npublic long taskSchedulerII(int[] tasks, int space) {\\n        long r = 0;\\n        Map<Integer, Long> lastCompletionDay = new HashMap<>();\\n        for (int t : tasks) {\\n            r++;\\n            Long day = lastCompletionDay.get(t);\\n            if (day != null) {\\n                r = Math.max(day + space + 1, r);\\n            }\\n            lastCompletionDay.put(t, r);\\n        }\\n        return r;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic long taskSchedulerII(int[] tasks, int space) {\\n        long r = 0;\\n        Map<Integer, Long> lastCompletionDay = new HashMap<>();\\n        for (int t : tasks) {\\n            r++;\\n            Long day = lastCompletionDay.get(t);\\n            if (day != null) {\\n                r = Math.max(day + space + 1, r);\\n            }\\n            lastCompletionDay.put(t, r);\\n        }\\n        return r;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2635510,
                "title": "simple-hashmap-o-n",
                "content": "Simple hashmap implementation . \\nAs we should follow the order , no matter what , the second job cannot be picked earlier than its mentioned date.\\nSo , either move to next day  or wait untill the next job  by incrementing the days.\\n```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        freqMap={}\\n        for task in tasks:\\n            freqMap[task]=0\\n        itr=0\\n        day=0\\n        while(itr<len(tasks)):\\n            day=day+1\\n            if freqMap[tasks[itr]]<=day:\\n                freqMap[tasks[itr]]=day+space+1\\n                itr=itr+1\\n        return day\\n```\\nThis would give TLE as we are incrementing the day by 1 , \\nInstead, lets move to the next job by directly incrementing the wait days .\\n```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        freqMap={}\\n        for task in tasks:\\n            freqMap[task]=0\\n        itr=0\\n        day=0\\n        while(itr<len(tasks)):\\n            day=max(day,freqMap[tasks[itr]])+1\\n            if freqMap[tasks[itr]]<=day:\\n                freqMap[tasks[itr]]=day+space\\n            itr=itr+1\\n        return day\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        freqMap={}\\n        for task in tasks:\\n            freqMap[task]=0\\n        itr=0\\n        day=0\\n        while(itr<len(tasks)):\\n            day=day+1\\n            if freqMap[tasks[itr]]<=day:\\n                freqMap[tasks[itr]]=day+space+1\\n                itr=itr+1\\n        return day\\n```\n```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        freqMap={}\\n        for task in tasks:\\n            freqMap[task]=0\\n        itr=0\\n        day=0\\n        while(itr<len(tasks)):\\n            day=max(day,freqMap[tasks[itr]])+1\\n            if freqMap[tasks[itr]]<=day:\\n                freqMap[tasks[itr]]=day+space\\n            itr=itr+1\\n        return day\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630520,
                "title": "use-hashmap",
                "content": "```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        current_day,  hmap = 1, {}\\n        for i, task in enumerate(tasks):\\n            if task not in hmap or current_day - hmap[task] > space:\\n                # execute the task, record it\\'s execution and goto next day\\n                hmap[task] = current_day\\n                current_day+=1\\n            else:\\n                current_day+=(space +1 - (current_day - hmap[task]))\\n                hmap[task] = current_day\\n                current_day+=1\\n        return current_day - 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        current_day,  hmap = 1, {}\\n        for i, task in enumerate(tasks):\\n            if task not in hmap or current_day - hmap[task] > space:\\n                # execute the task, record it\\'s execution and goto next day\\n                hmap[task] = current_day\\n                current_day+=1\\n            else:\\n                current_day+=(space +1 - (current_day - hmap[task]))\\n                hmap[task] = current_day\\n                current_day+=1\\n        return current_day - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2627566,
                "title": "python-hashmap-with-explanation",
                "content": "\\n        hashmap = {}    # task -> next day we can complete \\n        days = 0 \\n        \\n        for task in tasks: \\n            days += 1 \\n\\t\\t\\t\\n\\t\\t\\t# if it\\'s task first appearance or alrady pass the min number of days\\n\\t\\t\\t# we can complete it and map the next day \\n\\t\\t\\t\\n            if hashmap.get(task, 0) < days:               \\n                hashmap[task] = days + space\\n            else:     # we add the difference of the gap, and the additional day to complete this task \\n                days += (hashmap.get(task) - days) + 1\\n                hashmap[task] = days + space\\n\\n        return days\\n            \\n\\t\\t\\t\\nWe can clean up the code as: \\n        \\n        hashmap = {}\\n        days = 0\\n        \\n        for task in tasks: \\n            days += 1 \\n            \\n            if hashmap.get(task, 0) >= days:\\n                days += (hashmap.get(task) - days) + 1\\n            hashmap[task] = days + space\\n            \\n        return days\\n\\t\\t\\nN as number of the tasks \\nTime Complexity: O(N) \\nSpace Complexity: O(N)",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n        hashmap = {}    # task -> next day we can complete \\n        days = 0 \\n        \\n        for task in tasks: \\n            days += 1 \\n\\t\\t\\t\\n\\t\\t\\t# if it\\'s task first appearance or alrady pass the min number of days\\n\\t\\t\\t# we can complete it and map the next day \\n\\t\\t\\t\\n            if hashmap.get(task, 0) < days:               \\n                hashmap[task] = days + space\\n            else:     # we add the difference of the gap, and the additional day to complete this task \\n                days += (hashmap.get(task) - days) + 1\\n                hashmap[task] = days + space\\n\\n        return days\\n            \\n\\t\\t\\t\\nWe can clean up the code as: \\n        \\n        hashmap = {}\\n        days = 0\\n        \\n        for task in tasks: \\n            days += 1 \\n            \\n            if hashmap.get(task, 0) >= days:\\n                days += (hashmap.get(task) - days) + 1\\n            hashmap[task] = days + space\\n            \\n        return days\\n\\t\\t\\nN as number of the tasks \\nTime Complexity: O(N) \\nSpace Complexity: O(N)",
                "codeTag": "Unknown"
            },
            {
                "id": 2626275,
                "title": "python-simple-hashmap",
                "content": "\\n    def taskSchedulerII(self, tasks, space):\\n        dict1, total = defaultdict(int), 0\\n        \\n        for i in tasks:\\n            total += 1\\n            \\n            if dict1[i]:\\n                gap = total - dict1[i] - 1\\n                if gap < space:\\n                    total += space - gap\\n                    \\n            dict1[i] = total\\n        \\n        return total",
                "solutionTags": [],
                "code": "\\n    def taskSchedulerII(self, tasks, space):\\n        dict1, total = defaultdict(int), 0\\n        \\n        for i in tasks:\\n            total += 1\\n            \\n            if dict1[i]:\\n                gap = total - dict1[i] - 1\\n                if gap < space:\\n                    total += space - gap\\n                    \\n            dict1[i] = total\\n        \\n        return total",
                "codeTag": "Python3"
            },
            {
                "id": 2625391,
                "title": "simple-python-hashmap-with-explanation",
                "content": "Intuitions:\\n\\n- work is blocking\\n- keep track of when you last did an item\\n\\nI figured the simple question I always had to ask was, \"Can I do this work today?\" \\n\\nthe anwer was yes if :\\n- the work was new ( not in `calendar`)\\n- the time between count (days passed total) and the last time I saw this work had to be greater than or equal to the required space. \\n\\n\\nIf the answer was no:\\n- I just had to add the difference between timePassed since last time I saw this and the required space. \\n\\nThen:\\ndo the work (count+=1)\\nupdate my calendar with the date the work was done (count);\\n\\n\\nGotchas:\\n\\n- using count instead of i for calendar\\n- updating calendar _after_ you did the work (count+=1)\\n\\n\\n\\n```class Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        count = 0; #days \\n        i = 0;\\n        calendar = {} \\n        \\n        while i < len(tasks):\\n            curr = tasks[i];\\n            if curr in calendar and (count-calendar[curr]) < space:\\n                count += (space - (count - calendar[curr] )) #how many days rest\\n            \\n\\t\\t\\ti+=1\\n            count+=1; #do the job\\n            calendar[curr] = count; #mark when we did the job\\n\\n        return count;\\n    \\n        ```",
                "solutionTags": [],
                "code": "```class Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        count = 0; #days \\n        i = 0;\\n        calendar = {} \\n        \\n        while i < len(tasks):\\n            curr = tasks[i];\\n            if curr in calendar and (count-calendar[curr]) < space:\\n                count += (space - (count - calendar[curr] )) #how many days rest\\n            \\n\\t\\t\\ti+=1\\n            count+=1; #do the job\\n            calendar[curr] = count; #mark when we did the job\\n\\n        return count;\\n    \\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 2609695,
                "title": "c-hashing",
                "content": "class Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        long long n=tasks.size(),day=1,i=0;\\n        unordered_map<int,long long>mp;\\n        while(i<n)\\n        {\\n            if(mp.count(tasks[i])==0)\\n            {\\n                mp[tasks[i]]=day;\\n                i+=1;\\n                day+=1;\\n            }\\n            else if(day>mp[tasks[i]]+space)\\n            {\\n                mp[tasks[i]]=day;\\n                i+=1;\\n                day+=1;\\n            }\\n            else\\n                day=mp[tasks[i]]+space+1; // if current tasks needs to be executed on further day\\n        }\\n        return day-1; // we are  always one day extra\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        long long n=tasks.size(),day=1,i=0;\\n        unordered_map<int,long long>mp;\\n        while(i<n)\\n        {\\n            if(mp.count(tasks[i])==0)\\n            {\\n                mp[tasks[i]]=day;\\n                i+=1;\\n                day+=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2597085,
                "title": "python-fast-using-defaultdict",
                "content": "Using dictionary keep last time excution of a task:\\n* \\t if the gap of present day and last excution is:\\n\\t\\t  ->       greater than or equal space you can countinue the excution\\n\\t\\t  ->       less than  space add the difference to the days counter\\nfinally return your days counter\\n\\t \\n```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        last_time = defaultdict(int)\\n        days = 0\\n        for task in tasks:\\n            days += 1\\n            if last_time[task]:\\n                gap =days- last_time[task]-1\\n                if gap < space:\\n                    days += space -gap\\n            \\n            last_time[task] = days\\n            \\n        return days\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        last_time = defaultdict(int)\\n        days = 0\\n        for task in tasks:\\n            days += 1\\n            if last_time[task]:\\n                gap =days- last_time[task]-1\\n                if gap < space:\\n                    days += space -gap\\n            \\n            last_time[task] = days\\n            \\n        return days\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593307,
                "title": "python-c-unordered-map-fast-efficient-easy-understanding-95-faster",
                "content": "![image](https://assets.leetcode.com/users/images/a84a63a8-7e9e-4f00-8b8a-00e6365f5747_1663511218.2936876.png)\\n`C++ solution`\\n\\nclass Solution {\\npublic:\\n        \\n        long long taskSchedulerII(vector<int>& tasks, int space) {\\n\\t\\t\\tunordered_map<long long,long long> mp;\\n\\t\\t\\tlong long m = tasks.size();\\n\\t\\t\\tlong long time = 0, i = 0;\\n\\n\\t\\t\\twhile (i<m) {\\n\\n\\t\\t\\t\\tif (mp.find(tasks[i]) == mp.end()) { // not present\\n\\t\\t\\t\\t\\tmp[tasks[i]] = time + space + 1;  // we store the next required time for the task.\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\ttime++;\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tlong long x = mp[tasks[i]];\\n\\t\\t\\t\\t\\tif (time >=x) {\\n\\t\\t\\t\\t\\t\\tmp[tasks[i]] = time + space + 1;\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t\\ttime++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\ttime = mp[tasks[i]]; // if time is less than we set it to the time required for the tasks.                \\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn time;\\n    }\\n};\\n\\n`Python Solution`\\n\\nclass Solution:\\n        \\n        def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n\\t\\t\\tmp = dict()\\n\\t\\t\\tm, time, i = len(tasks), 0, 0\\n\\t\\t\\twhile i<m:    \\n\\t\\t\\t\\tif mp.get(tasks[i]) is None:\\n\\t\\t\\t\\t\\tmp[tasks[i]] = time + (space + 1)\\n\\t\\t\\t\\t\\ti+=1\\n\\t\\t\\t\\t\\ttime+=1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tx = mp[tasks[i]]\\n\\t\\t\\t\\t\\tif time >= x:\\n\\t\\t\\t\\t\\t\\tmp[tasks[i]] =  time + (space + 1)\\n\\t\\t\\t\\t\\t\\ti+=1\\n\\t\\t\\t\\t\\t\\ttime+=1  \\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\ttime = mp[tasks[i]]\\n\\t\\t\\treturn time\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n        \\n        long long taskSchedulerII(vector<int>& tasks, int space) {\\n\\t\\t\\tunordered_map<long long,long long> mp;\\n\\t\\t\\tlong long m = tasks.size();\\n\\t\\t\\tlong long time = 0, i = 0;\\n\\n\\t\\t\\twhile (i<m) {\\n\\n\\t\\t\\t\\tif (mp.find(tasks[i]) == mp.end()) { // not present\\n\\t\\t\\t\\t\\tmp[tasks[i]] = time + space + 1;  // we store the next required time for the task.\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\ttime++;\\n\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2590689,
                "title": "unordered-map-c-fast",
                "content": "\\t   long long taskSchedulerII(vector<int>& tasks, int space) \\n\\t\\t{\\n\\t\\t\\tunordered_map<int ,long long int> mp;\\n\\t\\t\\tlong long n = tasks.size(), day = 0;\\n\\t\\t\\tfor(long long int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(mp.count(tasks[i])==0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmp[tasks[i]] = day + space + 1;  \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlong long int day_ = mp[tasks[i]];\\n\\t\\t\\t\\t\\tif(day_>day)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tday = day_; \\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tmp[tasks[i]] = day + space + 1;  \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tday++;\\n\\t\\t\\t}\\n\\t\\t\\treturn day;\\n\\t\\t}",
                "solutionTags": [
                    "C"
                ],
                "code": "\\t   long long taskSchedulerII(vector<int>& tasks, int space) \\n\\t\\t{\\n\\t\\t\\tunordered_map<int ,long long int> mp;\\n\\t\\t\\tlong long n = tasks.size(), day = 0;\\n\\t\\t\\tfor(long long int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(mp.count(tasks[i])==0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmp[tasks[i]] = day + space + 1;  \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlong long int day_ = mp[tasks[i]];\\n\\t\\t\\t\\t\\tif(day_>day)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tday = day_; \\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tmp[tasks[i]] = day + space + 1;  \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tday++;\\n\\t\\t\\t}\\n\\t\\t\\treturn day;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2587619,
                "title": "c-map",
                "content": "* Check weather we are able to complete task if its a new task then surely yes just increase the number of days else just use the number of spaces to get it completed.\\n```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<long long,long long>mp;\\n        long long days=0;\\n        for(auto it:tasks){\\n            if(mp.count(it)){\\n                long long temp=mp[it];\\n                if(days-temp<=space){\\n                  days=temp+space;\\n                }\\n            }   \\n            days++;\\n            mp[it]=days;\\n        }\\n        return days;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<long long,long long>mp;\\n        long long days=0;\\n        for(auto it:tasks){\\n            if(mp.count(it)){\\n                long long temp=mp[it];\\n                if(days-temp<=space){\\n                  days=temp+space;\\n                }\\n            }   \\n            days++;\\n            mp[it]=days;\\n        }\\n        return days;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585052,
                "title": "golang-133-ms-9-1-mb-solution",
                "content": "```\\nfunc taskSchedulerII(tasks []int, space int) int64 {\\n    h := make(map[int32]int32)\\n    \\n    result := 0\\n    for i, iEnd := int32(0), int32(len(tasks)); i < iEnd; i++ {\\n        task := int32(tasks[i])\\n        if lastI, exist := h[task]; exist {\\n            diff := result - tasks[lastI]\\n            if diff < space {\\n                result += space - diff\\n            }\\n        }\\n        result++\\n        h[task] = i\\n        tasks[i] = result\\n    }\\n    \\n    return int64(result)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc taskSchedulerII(tasks []int, space int) int64 {\\n    h := make(map[int32]int32)\\n    \\n    result := 0\\n    for i, iEnd := int32(0), int32(len(tasks)); i < iEnd; i++ {\\n        task := int32(tasks[i])\\n        if lastI, exist := h[task]; exist {\\n            diff := result - tasks[lastI]\\n            if diff < space {\\n                result += space - diff\\n            }\\n        }\\n        result++\\n        h[task] = i\\n        tasks[i] = result\\n    }\\n    \\n    return int64(result)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2576924,
                "title": "python-easy-to-understand-solution",
                "content": "```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        day_checker = {}\\n        day = 1\\n        for i in range(len(tasks)):\\n            if tasks[i] not in day_checker:\\n                day_checker[tasks[i]] = day\\n            else:\\n                if abs(day_checker[tasks[i]] - day) <= space:\\n                    day = day_checker[tasks[i]] + space + 1\\n                    day_checker[tasks[i]] = day \\n                else:\\n                    day_checker[tasks[i]] = day\\n              day += 1       \\n        return day - 1\\n\\t\\t```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        day_checker = {}\\n        day = 1\\n        for i in range(len(tasks)):\\n            if tasks[i] not in day_checker:\\n                day_checker[tasks[i]] = day\\n            else:\\n                if abs(day_checker[tasks[i]] - day) <= space:\\n                    day = day_checker[tasks[i]] + space + 1\\n                    day_checker[tasks[i]] = day \\n                else:\\n                    day_checker[tasks[i]] = day\\n              day += 1       \\n        return day - 1\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2567467,
                "title": "python-simple-solution-with-o-n-time-complexity",
                "content": "```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        d = {}\\n        days = 0\\n        for i in range(len(tasks)):\\n            if tasks[i] in d and  days-d[tasks[i]] >= space+1:\\n                d[tasks[i]] = days\\n            elif tasks[i] in d and  days-d[tasks[i]] < space+1:\\n                days = space +1+d[tasks[i]]\\n                d[tasks[i]] = days\\n            else:\\n                d[tasks[i]] = days\\n            days+=1\\n        return days\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        d = {}\\n        days = 0\\n        for i in range(len(tasks)):\\n            if tasks[i] in d and  days-d[tasks[i]] >= space+1:\\n                d[tasks[i]] = days\\n            elif tasks[i] in d and  days-d[tasks[i]] < space+1:\\n                days = space +1+d[tasks[i]]\\n                d[tasks[i]] = days\\n            else:\\n                d[tasks[i]] = days\\n            days+=1\\n        return days\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567095,
                "title": "gk-s-pyhton-soln",
                "content": "```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        scheduled_tasks = {}\\n        cur_day = 0\\n        for task in tasks:\\n            cur_day += 1\\n            if task in scheduled_tasks and cur_day - scheduled_tasks[task] - 1 < space:\\n                cur_day = scheduled_tasks[task] + space + 1\\n            scheduled_tasks[task] = cur_day\\n        return cur_day\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        scheduled_tasks = {}\\n        cur_day = 0\\n        for task in tasks:\\n            cur_day += 1\\n            if task in scheduled_tasks and cur_day - scheduled_tasks[task] - 1 < space:\\n                cur_day = scheduled_tasks[task] + space + 1\\n            scheduled_tasks[task] = cur_day\\n        return cur_day\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2566830,
                "title": "c-map-hash-table",
                "content": "Please upvote if you find the solution good.\\n***Thank You!!***\\n```\\n#define ll long long int\\n//chal raaste jaha le chale\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<int, bool> once;\\n        unordered_map<int, ll> last;\\n        ll res = 0;\\n        for(int task : tasks) {\\n            if(once[task]) {\\n                res = max(res + 1, last[task] + space + 1);\\n            }\\n            else {\\n                once[task] = 1;\\n                res++;\\n            }\\n            last[task] = res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define ll long long int\\n//chal raaste jaha le chale\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<int, bool> once;\\n        unordered_map<int, ll> last;\\n        ll res = 0;\\n        for(int task : tasks) {\\n            if(once[task]) {\\n                res = max(res + 1, last[task] + space + 1);\\n            }\\n            else {\\n                once[task] = 1;\\n                res++;\\n            }\\n            last[task] = res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2564533,
                "title": "python-o-n-o-n",
                "content": "```py\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        time, last = 1, {}\\n        \\n        for task in tasks:\\n            done = last.get(task, -sys.maxsize)\\n            time = max(time, done + space) + 1\\n            last[task] = time\\n        \\n        return time - 1",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        time, last = 1, {}",
                "codeTag": "Java"
            },
            {
                "id": 2557604,
                "title": "c-map",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long taskSchedulerII(vector<int>& tasks, int space) \\n    {\\n        ll d=1;\\n        unordered_map<ll,ll>m;\\n        for(auto &x:tasks)\\n        {\\n            if(m.find(x)!=m.end())\\n            {\\n                ll diff=d-m[x];\\n                if(diff<=space)\\n                    d+=(space-diff+1);\\n            }\\n            m[x]=d++;\\n        }\\n        return --d;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long taskSchedulerII(vector<int>& tasks, int space) \\n    {\\n        ll d=1;\\n        unordered_map<ll,ll>m;\\n        for(auto &x:tasks)\\n        {\\n            if(m.find(x)!=m.end())\\n            {\\n                ll diff=d-m[x];\\n                if(diff<=space)\\n                    d+=(space-diff+1);\\n            }\\n            m[x]=d++;\\n        }\\n        return --d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535506,
                "title": "c-hashmap-solution-counting",
                "content": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<int,long long>mp; \\n        //map store the total days to complete the task \\n        long long day=0;\\n        for(auto it:tasks){\\n            if(mp.find(it)==mp.end()){\\n                day++;\\n                mp[it]=day;\\n            }\\n            else{\\n    //how many total days passed-days to complete the task when it occured last time\\n            \\n                int req=space-(day-mp[it]);   \\n                \\n               if(req>0) day+=(req+1);\\n                else day+=1;\\n                \\n                mp[it]=day;\\n            }\\n        }\\n        return day;\\n    }\\n\\t\\n\\t** Happy coding !**\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<int,long long>mp; \\n        //map store the total days to complete the task \\n        long long day=0;\\n        for(auto it:tasks){\\n            if(mp.find(it)==mp.end()){\\n                day++;\\n                mp[it]=day;\\n            }\\n            else{\\n    //how many total days passed-days to complete the task when it occured last time\\n            \\n                int req=space-(day-mp[it]);   \\n                \\n               if(req>0) day+=(req+1);\\n                else day+=1;\\n                \\n                mp[it]=day;\\n            }\\n        }\\n        return day;\\n    }\\n\\t\\n\\t** Happy coding !**\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2532950,
                "title": "python-while-loop-dict",
                "content": "```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        d = {}\\n        idx = 0\\n        day = 0\\n        while idx < len(tasks):\\n\\t\\t    day += 1\\n            task = tasks[idx]   \\n            if task not in d:\\n                d[task] = day\\n            else:\\n                last = d[task]\\n                curr = day\\n                diff = curr - last - 1\\n                if diff < space:\\n                    wait = space - diff\\n                    day += wait\\n                d[task] = day                     \\n            idx += 1\\n        return day\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        d = {}\\n        idx = 0\\n        day = 0\\n        while idx < len(tasks):\\n\\t\\t    day += 1\\n            task = tasks[idx]   \\n            if task not in d:\\n                d[task] = day\\n            else:\\n                last = d[task]\\n                curr = day\\n                diff = curr - last - 1\\n                if diff < space:\\n                    wait = space - diff\\n                    day += wait\\n                d[task] = day                     \\n            idx += 1\\n        return day\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524323,
                "title": "segment-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    class stree\\n    {\\n        public:\\n        vector<long long>nodes;\\n        stree(int n){nodes.resize(2*n,0LL);}\\n        void update(int i,int val)\\n        {\\n            i+=nodes.size()/2;\\n            nodes[i]=val;\\n            while(i>1)\\n            {\\n                i/=2;\\n                nodes[i]=nodes[2*i+1]+nodes[2*i];\\n                \\n            }\\n        }\\n        long long sum(int l,int r)\\n        {\\n            long long ans=0;\\n            l+=nodes.size()/2;\\n            r+=nodes.size()/2;\\n            while(l<r)\\n            {\\n                if(r%2==1)\\n                    ans+=nodes[--r];\\n                \\n                if(l%2==1)\\n                    ans+=nodes[l++];\\n                l/=2,r/=2;\\n            }\\n            return ans;\\n        }\\n        \\n        \\n        \\n    };\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<int,int>last;\\n        long long ans=0;\\n        stree breaks(tasks.size());\\n        for(int i=0;i<tasks.size();i++)\\n        {\\n            if(last.find(tasks[i])!=last.end())\\n            {\\n                if(i-last[tasks[i]]-1+breaks.sum(last[tasks[i]],i+1)<space)\\n                {\\n                    ans+=space-(i-last[tasks[i]]+breaks.sum(last[tasks[i]],i+1))+2;\\n                    breaks.update(i-1,space-(i-last[tasks[i]]+breaks.sum(last[tasks[i]],i+1))+1);\\n                    \\n                }\\n                else\\n                    ans++;\\n            }\\n            else\\n            {\\n                ans++;\\n            }\\n            last[tasks[i]]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    class stree\\n    {\\n        public:\\n        vector<long long>nodes;\\n        stree(int n){nodes.resize(2*n,0LL);}\\n        void update(int i,int val)\\n        {\\n            i+=nodes.size()/2;\\n            nodes[i]=val;\\n            while(i>1)\\n            {\\n                i/=2;\\n                nodes[i]=nodes[2*i+1]+nodes[2*i];\\n                \\n            }\\n        }\\n        long long sum(int l,int r)\\n        {\\n            long long ans=0;\\n            l+=nodes.size()/2;\\n            r+=nodes.size()/2;\\n            while(l<r)\\n            {\\n                if(r%2==1)\\n                    ans+=nodes[--r];\\n                \\n                if(l%2==1)\\n                    ans+=nodes[l++];\\n                l/=2,r/=2;\\n            }\\n            return ans;\\n        }\\n        \\n        \\n        \\n    };\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        unordered_map<int,int>last;\\n        long long ans=0;\\n        stree breaks(tasks.size());\\n        for(int i=0;i<tasks.size();i++)\\n        {\\n            if(last.find(tasks[i])!=last.end())\\n            {\\n                if(i-last[tasks[i]]-1+breaks.sum(last[tasks[i]],i+1)<space)\\n                {\\n                    ans+=space-(i-last[tasks[i]]+breaks.sum(last[tasks[i]],i+1))+2;\\n                    breaks.update(i-1,space-(i-last[tasks[i]]+breaks.sum(last[tasks[i]],i+1))+1);\\n                    \\n                }\\n                else\\n                    ans++;\\n            }\\n            else\\n            {\\n                ans++;\\n            }\\n            last[tasks[i]]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2499299,
                "title": "c-simple-c-code",
                "content": "\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        long long n = tasks.size(), day = 0;\\n        unordered_map<int, long long> um;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!um.count(tasks[i]))\\n                um[tasks[i]] = day + space + 1;\\n            else\\n            {\\n                if(um[tasks[i]] > day)\\n                {\\n                    day = um[tasks[i]];   \\n                }\\n                um[tasks[i]] = day + space + 1;\\n            }\\n            day++;\\n        }\\n        return day;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long taskSchedulerII(vector<int>& tasks, int space) {\\n        long long n = tasks.size(), day = 0;\\n        unordered_map<int, long long> um;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!um.count(tasks[i]))\\n                um[tasks[i]] = day + space + 1;\\n            else\\n            {\\n                if(um[tasks[i]] > day)\\n                {\\n                    day = um[tasks[i]];   \\n                }\\n                um[tasks[i]] = day + space + 1;\\n            }\\n            day++;\\n        }\\n        return day;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497539,
                "title": "python-90-faster",
                "content": "```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        map = {tasks[0]:0}\\n        i = 1\\n        n = len(tasks)\\n        j = 1\\n        dash = 0\\n        while i<n:\\n            \\n            if tasks[i] in map and (i+dash)-map[tasks[i]] -1< space:\\n                count = space-((i+dash)-map[tasks[i]]-1)\\n                dash+=count\\n                j+= count\\n                map[tasks[i]] = i+dash\\n                i+=1\\n                j+=1\\n                \\n            else:\\n                map[tasks[i]] = i+dash\\n                j+=1\\n                i+=1\\n        return j\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\\n        map = {tasks[0]:0}\\n        i = 1\\n        n = len(tasks)\\n        j = 1\\n        dash = 0\\n        while i<n:\\n            \\n            if tasks[i] in map and (i+dash)-map[tasks[i]] -1< space:\\n                count = space-((i+dash)-map[tasks[i]]-1)\\n                dash+=count\\n                j+= count\\n                map[tasks[i]] = i+dash\\n                i+=1\\n                j+=1\\n                \\n            else:\\n                map[tasks[i]] = i+dash\\n                j+=1\\n                i+=1\\n        return j\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1989267,
                "content": [
                    {
                        "username": "phalkey89",
                        "content": "I think Example one is somewhat misleading \\n\"3\"  type of job will be done on day 7 as it is first time occuring but  they completed it on day 8 and taking break on day 7 !! "
                    },
                    {
                        "username": "SHI-NE",
                        "content": "i think there should be break on 8th day but they took it on 8th"
                    },
                    {
                        "username": "mohak_a",
                        "content": "For second test case, is this not a valid solution\\n\\nDay 1: Task 5\\nDay 2: Task 8\\nDay 3: Break\\nDay 4: Task 5\\nDay 5: Task 8\\nthe space between both tasks is 2 as mentioned \\nI am getting 5 as minimum days. \\n\\nWhere am I wrong ? "
                    },
                    {
                        "username": "NitishBharat",
                        "content": "[@pr20sh01ant](/pr20sh01ant) thnx"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "the order shold not be changed from what is given in the Q?"
                    },
                    {
                        "username": "askskyler",
                        "content": "\"representing tasks that need to be completed in order\""
                    },
                    {
                        "username": "ningaloo",
                        "content": "should be an easy"
                    },
                    {
                        "username": "SHI-NE",
                        "content": "[@shivasaineelam](/shivasaineelam) why?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "nope"
                    },
                    {
                        "username": "chinu97",
                        "content": "```from collections import defaultdict\nclass Solution:\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\n        log = defaultdict(int)\n        time = 0\n        for idx,task in enumerate(tasks):\n            time+=1\n            if task not in log:\n                next_exec_day = time+space+1\n                log[task]=next_exec_day\n            else:\n                #check if this is the day of execution for the task\n                next_exec_day = log[task]\n                while(time<next_exec_day):\n                    time+=1\n                log[task]=time+space+1\n        return time\n```\nI dont understand why my code wouldnt pass all test cases"
                    },
                    {
                        "username": "rounak_shr",
                        "content": "in the while loop use time = max(time, next_exec_day)...it may help"
                    }
                ]
            },
            {
                "id": 1722988,
                "content": [
                    {
                        "username": "phalkey89",
                        "content": "I think Example one is somewhat misleading \\n\"3\"  type of job will be done on day 7 as it is first time occuring but  they completed it on day 8 and taking break on day 7 !! "
                    },
                    {
                        "username": "SHI-NE",
                        "content": "i think there should be break on 8th day but they took it on 8th"
                    },
                    {
                        "username": "mohak_a",
                        "content": "For second test case, is this not a valid solution\\n\\nDay 1: Task 5\\nDay 2: Task 8\\nDay 3: Break\\nDay 4: Task 5\\nDay 5: Task 8\\nthe space between both tasks is 2 as mentioned \\nI am getting 5 as minimum days. \\n\\nWhere am I wrong ? "
                    },
                    {
                        "username": "NitishBharat",
                        "content": "[@pr20sh01ant](/pr20sh01ant) thnx"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "the order shold not be changed from what is given in the Q?"
                    },
                    {
                        "username": "askskyler",
                        "content": "\"representing tasks that need to be completed in order\""
                    },
                    {
                        "username": "ningaloo",
                        "content": "should be an easy"
                    },
                    {
                        "username": "SHI-NE",
                        "content": "[@shivasaineelam](/shivasaineelam) why?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "nope"
                    },
                    {
                        "username": "chinu97",
                        "content": "```from collections import defaultdict\nclass Solution:\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\n        log = defaultdict(int)\n        time = 0\n        for idx,task in enumerate(tasks):\n            time+=1\n            if task not in log:\n                next_exec_day = time+space+1\n                log[task]=next_exec_day\n            else:\n                #check if this is the day of execution for the task\n                next_exec_day = log[task]\n                while(time<next_exec_day):\n                    time+=1\n                log[task]=time+space+1\n        return time\n```\nI dont understand why my code wouldnt pass all test cases"
                    },
                    {
                        "username": "rounak_shr",
                        "content": "in the while loop use time = max(time, next_exec_day)...it may help"
                    }
                ]
            },
            {
                "id": 1971661,
                "content": [
                    {
                        "username": "phalkey89",
                        "content": "I think Example one is somewhat misleading \\n\"3\"  type of job will be done on day 7 as it is first time occuring but  they completed it on day 8 and taking break on day 7 !! "
                    },
                    {
                        "username": "SHI-NE",
                        "content": "i think there should be break on 8th day but they took it on 8th"
                    },
                    {
                        "username": "mohak_a",
                        "content": "For second test case, is this not a valid solution\\n\\nDay 1: Task 5\\nDay 2: Task 8\\nDay 3: Break\\nDay 4: Task 5\\nDay 5: Task 8\\nthe space between both tasks is 2 as mentioned \\nI am getting 5 as minimum days. \\n\\nWhere am I wrong ? "
                    },
                    {
                        "username": "NitishBharat",
                        "content": "[@pr20sh01ant](/pr20sh01ant) thnx"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "the order shold not be changed from what is given in the Q?"
                    },
                    {
                        "username": "askskyler",
                        "content": "\"representing tasks that need to be completed in order\""
                    },
                    {
                        "username": "ningaloo",
                        "content": "should be an easy"
                    },
                    {
                        "username": "SHI-NE",
                        "content": "[@shivasaineelam](/shivasaineelam) why?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "nope"
                    },
                    {
                        "username": "chinu97",
                        "content": "```from collections import defaultdict\nclass Solution:\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\n        log = defaultdict(int)\n        time = 0\n        for idx,task in enumerate(tasks):\n            time+=1\n            if task not in log:\n                next_exec_day = time+space+1\n                log[task]=next_exec_day\n            else:\n                #check if this is the day of execution for the task\n                next_exec_day = log[task]\n                while(time<next_exec_day):\n                    time+=1\n                log[task]=time+space+1\n        return time\n```\nI dont understand why my code wouldnt pass all test cases"
                    },
                    {
                        "username": "rounak_shr",
                        "content": "in the while loop use time = max(time, next_exec_day)...it may help"
                    }
                ]
            },
            {
                "id": 1901634,
                "content": [
                    {
                        "username": "phalkey89",
                        "content": "I think Example one is somewhat misleading \\n\"3\"  type of job will be done on day 7 as it is first time occuring but  they completed it on day 8 and taking break on day 7 !! "
                    },
                    {
                        "username": "SHI-NE",
                        "content": "i think there should be break on 8th day but they took it on 8th"
                    },
                    {
                        "username": "mohak_a",
                        "content": "For second test case, is this not a valid solution\\n\\nDay 1: Task 5\\nDay 2: Task 8\\nDay 3: Break\\nDay 4: Task 5\\nDay 5: Task 8\\nthe space between both tasks is 2 as mentioned \\nI am getting 5 as minimum days. \\n\\nWhere am I wrong ? "
                    },
                    {
                        "username": "NitishBharat",
                        "content": "[@pr20sh01ant](/pr20sh01ant) thnx"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "the order shold not be changed from what is given in the Q?"
                    },
                    {
                        "username": "askskyler",
                        "content": "\"representing tasks that need to be completed in order\""
                    },
                    {
                        "username": "ningaloo",
                        "content": "should be an easy"
                    },
                    {
                        "username": "SHI-NE",
                        "content": "[@shivasaineelam](/shivasaineelam) why?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "nope"
                    },
                    {
                        "username": "chinu97",
                        "content": "```from collections import defaultdict\nclass Solution:\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\n        log = defaultdict(int)\n        time = 0\n        for idx,task in enumerate(tasks):\n            time+=1\n            if task not in log:\n                next_exec_day = time+space+1\n                log[task]=next_exec_day\n            else:\n                #check if this is the day of execution for the task\n                next_exec_day = log[task]\n                while(time<next_exec_day):\n                    time+=1\n                log[task]=time+space+1\n        return time\n```\nI dont understand why my code wouldnt pass all test cases"
                    },
                    {
                        "username": "rounak_shr",
                        "content": "in the while loop use time = max(time, next_exec_day)...it may help"
                    }
                ]
            }
        ]
    }
]