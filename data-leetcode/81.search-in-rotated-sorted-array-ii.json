[
    {
        "title": "Search in Rotated Sorted Array II",
        "question_content": "There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).\nBefore being passed to your function, nums is rotated at an unknown pivot index k (0 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].\nGiven the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums.\nYou must decrease the overall operation steps as much as possible.\n&nbsp;\nExample 1:\nInput: nums = [2,5,6,0,0,1,2], target = 0\nOutput: true\nExample 2:\nInput: nums = [2,5,6,0,0,1,2], target = 3\nOutput: false\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 5000\n\t-104 <= nums[i] <= 104\n\tnums is guaranteed to be rotated at some pivot.\n\t-104 <= target <= 104\n\n&nbsp;\nFollow up: This problem is similar to&nbsp;Search in Rotated Sorted Array, but&nbsp;nums may contain duplicates. Would this affect the runtime complexity? How and why?",
        "solutions": [
            {
                "id": 1890199,
                "title": "c-algorithm-binary-search",
                "content": "# 81. Search in Rotated Sorted Array II\\n**KNOCKCAT**\\n\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Initution is to use Binary Search\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\\n\\n[LeetCode](http://github.com/knockcat/Leetcode) **LINK TO LEETCODE REPOSITORY**\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n**Before commig over this Problem solve previous version of it.**\\n[33. Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)\\n\\n*  The **idea is the same as the previous one without duplicates.**\\n*   The only **difference is that due to the existence of duplicates,**\\n\\t* **arr[l] == arr[mid] could be possible**, the **first half could be out of order**\\n\\t*  (i.e. **not in the ascending order**, e.g. {3, 1, 2, 3, 3, 3, 3})\\n\\t*  we have to deal this case separately. \\n\\t* In that case, it is **guaranteed that arr[high] also equal to arr[mid],**\\n\\t* so the condition **arr[mid] == arr[l] == arr[r] can be checked before the original logic**, \\n\\t* if **so then move left and right both towards the middle by 1 and repeat.**\\n\\n**Closer look to the duplicate case**\\n\\n* let go in detail...\\n\\n* {3, 1, 2, 3, 3, 3, 3})\\n\\n* I have taken the same eg as above,\\n\\n* so we know when we divide array,\\n* **either of 1 half has to be sorted** because since the array is rotated, still one half will be sorted and i fell you understand this case,\\n\\n* now the problem is , as in above case if i some how find two halves let say\\n* **3 1 2 3** is one half, and **3 3 3** is another half and our **mid is element 3 also it at index \\'3\\'**\\n\\n* ok i hope you get it\\n\\n\\tnow,\\n\\n* can we distingusih over which half we should minimize are search space, **can we ?**\\n\\n* the answer is no\\n\\n* because, if i compared it with nums[low] it is 3 and if i look for nums[high] it is again 3\\n\\n* so **our search space will not be divide correctly as both are same what is correct half we cannot determine and we cannot get to know which is our sorted half and i feel you are getting it now,**\\n\\n* so we have to get rid of the condition nums[low] == nums[mid] == nums[high] seperately.\\n\\n* According to our code,  it will run the if condition which will compare with nums[low] because if condition will run first , but again we cannot determine it would have the correct partition.\\n\\n* so that\\'s why **we trimmed our search space** both from start and end so that we can **determine the valid partition and get to determine the sorted half.**\\n\\n* and handled the case if nums[low] == nums[mid] == nums[high] seperately.\\n\\n* and the worst time complexity is ~ O(n/2) of this entire code, because of duplicate case. average tc is O(logn)\\n\\n**ALGORITHM**\\n* **Check** for if **target == nums[mid]**, if found **return true**.\\n* With d**uplicates we can have nums[l] == nums[r]** so just u**pdate the l and r towards middle.**\\n* If not than check for **first half is that in order (i.e nums[l] <= nums[mid]**\\n\\t* check if **target is in the range of [left, mid -1]**, **if((nums[l] <= target) && (nums[mid] > target))** and search in it.\\n* if not in first half search in **second half.**\\n\\t*  Check if **target is in range of [mid + 1, right]**, **if((nums[mid] < target) && (nums[r]>= target))** and search in it.\\n\\n**Time Complexity - >**\\nAverage **O(log n)**\\nworse **~(O(n) = O(n)**\\n\\n**space Complexity ->  O (1)**\\n\\n**CODE WITH EXPLANATION**\\n\\n```\\n\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int l = 0;\\n        int r = nums.size() - 1;\\n        \\n        while(l <= r)\\n        {\\n            int mid = l + (r-l) / 2;\\n            if (nums[mid] == target)\\n                return true;\\n\\t\\t\\t// with duplicates we can have this contdition, just update left & right\\n            if((nums[l] == nums[mid]) && (nums[r] == nums[mid]))\\n            {\\n                l++;\\n                r--;\\n            }\\n\\t\\t\\t// first half\\n\\t\\t\\t// first half is in order\\n            else if(nums[l] <= nums[mid])\\n            {\\n\\t\\t\\t\\t// target is in first  half\\n                if((nums[l] <= target) && (nums[mid] > target))\\n                    r = mid - 1;\\n                else\\n                    l = mid + 1;\\n            }\\n\\t\\t\\t// second half\\n\\t\\t\\t// second half is order\\n\\t\\t\\t// target is in second half\\n            else\\n            {\\n                if((nums[mid] < target) && (nums[r]>= target))\\n                    l = mid + 1;\\n                else\\n                    r = mid - 1;\\n            }\\n        }\\n        return false;\\n    }\\n\\t// for github repository link go to my profile.\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Initution is to use Binary Search\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\n```\\n\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int l = 0;\\n        int r = nums.size() - 1;\\n        \\n        while(l <= r)\\n        {\\n            int mid = l + (r-l) / 2;\\n            if (nums[mid] == target)\\n                return true;\\n\\t\\t\\t// with duplicates we can have this contdition, just update left & right\\n            if((nums[l] == nums[mid]) && (nums[r] == nums[mid]))\\n            {\\n                l++;\\n                r--;\\n            }\\n\\t\\t\\t// first half\\n\\t\\t\\t// first half is in order\\n            else if(nums[l] <= nums[mid])\\n            {\\n\\t\\t\\t\\t// target is in first  half\\n                if((nums[l] <= target) && (nums[mid] > target))\\n                    r = mid - 1;\\n                else\\n                    l = mid + 1;\\n            }\\n\\t\\t\\t// second half\\n\\t\\t\\t// second half is order\\n\\t\\t\\t// target is in second half\\n            else\\n            {\\n                if((nums[mid] < target) && (nums[r]>= target))\\n                    l = mid + 1;\\n                else\\n                    r = mid - 1;\\n            }\\n        }\\n        return false;\\n    }\\n\\t// for github repository link go to my profile.\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890363,
                "title": "python-binary-search-explained",
                "content": "Since the array is given in a sorted order, so it can be solved using the binary search algorithm.\\n\\nTo solve this problem we have to follow the folllowing steps:\\n\\n1. Calculate the mid index.\\n2. Check if the mid element == target, return True else move to next step.\\n3. Else if the mid element >= left.\\n\\tif mid element >= target and and left <= target, then shift right to mid-1 position, else shift left to mid+1 position.\\n4. Else,\\n  \\tIf target >= mid element and target <=right, then shift left to mid+1 position, else shift right to mid-1 position.\\n15. If the element is not found return False\\n\\nNote: Since duplicate elemnts are present in the array so remove all the duplicates before step step 1.\\nTo remove duplicate,\\n1. Shift left while left == left+1, and \\n2. Shift right while right == right-1.\\n\\n```\\n# If the length of the given array list is 1, then check the first element and return accordingly\\nif len(nums)==1:\\n    if nums[0]!=target:\\n        return False\\n    else:\\n        return True\\n\\nleft=0\\nright=len(nums)-1\\n# binary search \\nwhile(left<=right):\\n\\n    # shifting to remove duplicate elements\\n    while left<right and nums[left] == nums[left+1]:\\n        left+=1\\n    while left<right and nums[right] == nums[right-1]:\\n        right-=1\\n\\n    # step 1 calculate the mid    \\n    mid=(left+right)//2\\n\\n    #step 2\\n    if nums[mid]==target:\\n        return True\\n\\n    #step 3\\n    elif nums[left]<=nums[mid]:\\n        if nums[mid]>=target and nums[left]<=target:\\n            right=mid-1\\n        else:\\n            left=mid+1\\n\\n    # step 4\\n    else:\\n        if target>=nums[mid] and target<=nums[right]:\\n            left=mid+1\\n        else:\\n            right=mid-1\\n\\n# step 5\\nreturn False\\n\\n```\\nSolve the previous problem before moving to this:\\n[33. Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\n# If the length of the given array list is 1, then check the first element and return accordingly\\nif len(nums)==1:\\n    if nums[0]!=target:\\n        return False\\n    else:\\n        return True\\n\\nleft=0\\nright=len(nums)-1\\n# binary search \\nwhile(left<=right):\\n\\n    # shifting to remove duplicate elements\\n    while left<right and nums[left] == nums[left+1]:\\n        left+=1\\n    while left<right and nums[right] == nums[right-1]:\\n        right-=1\\n\\n    # step 1 calculate the mid    \\n    mid=(left+right)//2\\n\\n    #step 2\\n    if nums[mid]==target:\\n        return True\\n\\n    #step 3\\n    elif nums[left]<=nums[mid]:\\n        if nums[mid]>=target and nums[left]<=target:\\n            right=mid-1\\n        else:\\n            left=mid+1\\n\\n    # step 4\\n    else:\\n        if target>=nums[mid] and target<=nums[right]:\\n            left=mid+1\\n        else:\\n            right=mid-1\\n\\n# step 5\\nreturn False\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1890619,
                "title": "an-unique-intuitive-approach-logn",
                "content": "## Intuition\\n- The idea is to find the point of pivot, which separates the array into 2 different monotonic arrays \\n- And apply binary search on one of them \\n\\n#### How to find pivot point\\n\\n- Since the initial array was monotonically non decreasing every element was greater than the previous one\\n- After rotation it divides the array into 2 halves , 1 where the array is increasing and the other where array is decreasing \\n- The pt of pivot would be the one where from where the array starts to decrease \\n- eg  : Before : ```0,0,1,2,2,5,6```  , After ```2,5,6,0,0,1,2```\\n- clearly idx == 3 is the pt of pivot as the array starts to increase from there\\n- Thus the idea is to find the first number which is smaller than nums[0], it is the pt. of pivot\\n\\n#### Modifications for duplicate\\n\\n- We would use binary search to find the pivot point\\n- But since duplicates exist the nums[0] can exist multiple times in the front or in the back \\n- The idea is to keep two pointers l = 0 , r = n-1 \\n- And increase l untill it is the last occurance of nums[0]\\n- decrease r untill it is no longer equals nums[0]\\n- eg : ```1,1,1,1,0,1,1,1,1,1``` reduces to ```1,0``` \\n-  And now we can check which part of the array we want to apply binay search and by comparing with ```nums[r]```\\n-  And check in either ```l : pivot-1``` or ```pivot : r```\\n\\n\\n- In the worst case it takes O(N) but ideally it would take ```num of occurance (nums[0]) + O(logn)``` , ideally ```O(logn)``` assuming the nums[0] occurs less times\\n\\n\\n## Code \\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        \\n        if( nums[0] == target or nums.back() == target ) return true; \\n        // this line is redundant it reduces only the worst case when all elements are same to O(1)\\n        \\n        const int n = nums.size();\\n        int l = 0 , h = n-1;\\n        while( l+1 < n and nums[l] == nums[l+1]) l++;\\n\\n        // if all elements are same\\n        if( l == n-1){\\n            if( nums[0] == target ) return true;\\n            else return false;\\n        }\\n        \\n        // while last element is equal to 1st element\\n        while( h >= 0 and nums[h] == nums[0] ) h--;\\n        int start = l , end = h;\\n        \\n        // find the point of pivot ie from where the rotation starts\\n        int pivot = -1;\\n        while( l <= h ){\\n            int mid = l + (h-l)/2;\\n            if( nums[mid] >= nums[0] ) l = mid+1;\\n            else {\\n                pivot = mid;\\n                h = mid-1;\\n            }\\n        }\\n        \\n        \\n        if( pivot == -1 ) l = start , h = end; // if no pivot exits then search space is from start -e end\\n        else {\\n            if( target > nums[end] ) l = start , h = pivot-1; // search space second half\\n            else l = pivot , h = end; // search space first half\\n        }\\n        \\n        // normal binary search\\n        while ( l <= h ){\\n            int mid = l + (h-l)/2;\\n            if( nums[mid] > target ) h = mid-1;\\n            else if( nums[mid] < target ) l = mid+1;\\n            else return true;\\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```0,0,1,2,2,5,6```\n```2,5,6,0,0,1,2```\n```1,1,1,1,0,1,1,1,1,1```\n```1,0```\n```nums[r]```\n```l : pivot-1```\n```pivot : r```\n```num of occurance (nums[0]) + O(logn)```\n```O(logn)```\n```cpp\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        \\n        if( nums[0] == target or nums.back() == target ) return true; \\n        // this line is redundant it reduces only the worst case when all elements are same to O(1)\\n        \\n        const int n = nums.size();\\n        int l = 0 , h = n-1;\\n        while( l+1 < n and nums[l] == nums[l+1]) l++;\\n\\n        // if all elements are same\\n        if( l == n-1){\\n            if( nums[0] == target ) return true;\\n            else return false;\\n        }\\n        \\n        // while last element is equal to 1st element\\n        while( h >= 0 and nums[h] == nums[0] ) h--;\\n        int start = l , end = h;\\n        \\n        // find the point of pivot ie from where the rotation starts\\n        int pivot = -1;\\n        while( l <= h ){\\n            int mid = l + (h-l)/2;\\n            if( nums[mid] >= nums[0] ) l = mid+1;\\n            else {\\n                pivot = mid;\\n                h = mid-1;\\n            }\\n        }\\n        \\n        \\n        if( pivot == -1 ) l = start , h = end; // if no pivot exits then search space is from start -e end\\n        else {\\n            if( target > nums[end] ) l = start , h = pivot-1; // search space second half\\n            else l = pivot , h = end; // search space first half\\n        }\\n        \\n        // normal binary search\\n        while ( l <= h ){\\n            int mid = l + (h-l)/2;\\n            if( nums[mid] > target ) h = mid-1;\\n            else if( nums[mid] < target ) l = mid+1;\\n            else return true;\\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28218,
                "title": "my-8ms-c-solution-o-logn-on-average-o-n-worst-case",
                "content": "The idea is the same as the previous one without duplicates\\n\\n    1) everytime check if targe == nums[mid], if so, we find it.\\n    2) otherwise, we check if the first half is in order (i.e. nums[left]<=nums[mid]) \\n      and if so, go to step 3), otherwise, the second half is in order,   go to step 4)\\n    3) check if target in the range of [left, mid-1] (i.e. nums[left]<=target < nums[mid]), if so, do search in the first half, i.e. right = mid-1; otherwise, search in the second half left = mid+1;\\n    4)  check if target in the range of [mid+1, right] (i.e. nums[mid]<target <= nums[right]), if so, do search in the second half, i.e. left = mid+1; otherwise search in the first half right = mid-1;\\n\\nThe only difference is that due to the existence of duplicates, we can have nums[left] == nums[mid] and in that case, the first half could be out of order (i.e. NOT in the ascending order, e.g. [3 1 2 3 3 3 3]) and we have to deal this case separately. In that case, it is guaranteed that nums[right] also equals to nums[mid], so what we can do is to check if nums[mid]== nums[left] == nums[right] before the original logic, and if so, we can move left and right both towards the middle by 1. and repeat.  \\n\\n    class Solution {\\n    public:\\n        bool search(vector<int>& nums, int target) {\\n            int left = 0, right =  nums.size()-1, mid;\\n            \\n            while(left<=right)\\n            {\\n                mid = (left + right) >> 1;\\n                if(nums[mid] == target) return true;\\n    \\n                // the only difference from the first one, trickly case, just updat left and right\\n                if( (nums[left] == nums[mid]) && (nums[right] == nums[mid]) ) {++left; --right;}\\n    \\n                else if(nums[left] <= nums[mid])\\n                {\\n                    if( (nums[left]<=target) && (nums[mid] > target) ) right = mid-1;\\n                    else left = mid + 1; \\n                }\\n                else\\n                {\\n                    if((nums[mid] < target) &&  (nums[right] >= target) ) left = mid+1;\\n                    else right = mid-1;\\n                }\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool search(vector<int>& nums, int target) {\\n            int left = 0, right =  nums.size()-1, mid;\\n            \\n            while(left<=right)\\n            {\\n                mid = (left + right) >> 1;\\n                if(nums[mid] == target) return true;\\n    \\n                // the only difference from the first one, trickly case, just updat left and right\\n                if( (nums[left] == nums[mid]) && (nums[right] == nums[mid]) ) {++left; --right;}",
                "codeTag": "Java"
            },
            {
                "id": 28195,
                "title": "python-easy-to-understand-solution-with-comments",
                "content": "        \\n    def search(self, nums, target):\\n        l, r = 0, len(nums)-1\\n        while l <= r:\\n            mid = l + (r-l)//2\\n            if nums[mid] == target:\\n                return True\\n            while l < mid and nums[l] == nums[mid]: # tricky part\\n                l += 1\\n            # the first half is ordered\\n            if nums[l] <= nums[mid]:\\n                # target is in the first half\\n                if nums[l] <= target < nums[mid]:\\n                    r = mid - 1\\n                else:\\n                    l = mid + 1\\n            # the second half is ordered\\n            else:\\n                # target is in the second half\\n                if nums[mid] < target <= nums[r]:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n        return False",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    def search(self, nums, target):\\n        l, r = 0, len(nums)-1\\n        while l <= r:\\n            mid = l + (r-l)//2\\n            if nums[mid] == target:\\n                return True\\n            while l < mid and nums[l] == nums[mid]: # tricky part\\n                l += 1\\n            # the first half is ordered\\n            if nums[l] <= nums[mid]:\\n                # target is in the first half\\n                if nums[l] <= target < nums[mid]:\\n                    r = mid - 1\\n                else:\\n                    l = mid + 1\\n            # the second half is ordered\\n            else:\\n                # target is in the second half\\n                if nums[mid] < target <= nums[r]:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 28202,
                "title": "neat-java-solution-using-binary-search",
                "content": "        public boolean search(int[] nums, int target) {\\n            int start = 0, end = nums.length - 1, mid = -1;\\n            while(start <= end) {\\n                mid = (start + end) / 2;\\n                if (nums[mid] == target) {\\n                    return true;\\n                }\\n                //If we know for sure right side is sorted or left side is unsorted\\n                if (nums[mid] < nums[end] || nums[mid] < nums[start]) {\\n                    if (target > nums[mid] && target <= nums[end]) {\\n                        start = mid + 1;\\n                    } else {\\n                        end = mid - 1;\\n                    }\\n                //If we know for sure left side is sorted or right side is unsorted\\n                } else if (nums[mid] > nums[start] || nums[mid] > nums[end]) {\\n                    if (target < nums[mid] && target >= nums[start]) {\\n                        end = mid - 1;\\n                    } else {\\n                        start = mid + 1;\\n                    }\\n                //If we get here, that means nums[start] == nums[mid] == nums[end], then shifting out\\n                //any of the two sides won't change the result but can help remove duplicate from\\n                //consideration, here we just use end-- but left++ works too\\n                } else {\\n                    end--;\\n                }\\n            }\\n            \\n            return false;\\n        }\\n\\nIn case anyone wonders, yes I agree that we don't need to check two parts. It's just that Doing that can slightly boost the performance, no asymptotic difference though.",
                "solutionTags": [
                    "Java"
                ],
                "code": "        public boolean search(int[] nums, int target) {\\n            int start = 0, end = nums.length - 1, mid = -1;\\n            while(start <= end) {\\n                mid = (start + end) / 2;\\n                if (nums[mid] == target) {\\n                    return true;\\n                }\\n                //If we know for sure right side is sorted or left side is unsorted\\n                if (nums[mid] < nums[end] || nums[mid] < nums[start]) {\\n                    if (target > nums[mid] && target <= nums[end]) {\\n                        start = mid + 1;\\n                    } else {\\n                        end = mid - 1;\\n                    }\\n                //If we know for sure left side is sorted or right side is unsorted\\n                } else if (nums[mid] > nums[start] || nums[mid] > nums[end]) {\\n                    if (target < nums[mid] && target >= nums[start]) {\\n                        end = mid - 1;\\n                    } else {\\n                        start = mid + 1;\\n                    }\\n                //If we get here, that means nums[start] == nums[mid] == nums[end], then shifting out\\n                //any of the two sides won't change the result but can help remove duplicate from\\n                //consideration, here we just use end-- but left++ works too\\n                } else {\\n                    end--;\\n                }\\n            }\\n            \\n            return false;\\n        }\\n\\nIn case anyone wonders, yes I agree that we don't need to check two parts. It's just that Doing that can slightly boost the performance, no asymptotic difference though.",
                "codeTag": "Unknown"
            },
            {
                "id": 28194,
                "title": "c-concise-log-n-solution",
                "content": "    class Solution {\\n    public:\\n      bool search(int A[], int n, int target) {\\n        int lo =0, hi = n-1;\\n        int mid = 0;\\n        while(lo<hi){\\n              mid=(lo+hi)/2;\\n              if(A[mid]==target) return true;\\n              if(A[mid]>A[hi]){\\n                  if(A[mid]>target && A[lo] <= target) hi = mid;\\n                  else lo = mid + 1;\\n              }else if(A[mid] < A[hi]){\\n                  if(A[mid]<target && A[hi] >= target) lo = mid + 1;\\n                  else hi = mid;\\n              }else{\\n                  hi--;\\n              }\\n              \\n        }\\n        return A[lo] == target ? true : false;\\n      }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n      bool search(int A[], int n, int target) {\\n        int lo =0, hi = n-1;\\n        int mid = 0;\\n        while(lo<hi){\\n              mid=(lo+hi)/2;\\n              if(A[mid]==target) return true;\\n              if(A[mid]>A[hi]){\\n                  if(A[mid]>target && A[lo] <= target) hi = mid;\\n                  else lo = mid + 1;\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 28216,
                "title": "java-1ms-binary-search-solution-with-comments",
                "content": "```\\npublic class Solution {\\n    public boolean search(int[] nums, int target) {\\n        // note here end is initialized to len instead of (len-1)\\n        int start = 0, end = nums.length;\\n        while (start < end) {\\n            int mid = (start + end) / 2;\\n            if (nums[mid] == target) return true;\\n            if (nums[mid] > nums[start]) { // nums[start..mid] is sorted\\n                // check if target in left half\\n                if (target < nums[mid] && target >= nums[start]) end = mid;\\n                else start = mid + 1;\\n            } else if (nums[mid] < nums[start]) { // nums[mid..end] is sorted\\n                // check if target in right half\\n                if (target > nums[mid] && target < nums[start]) start = mid + 1;\\n                else end = mid;\\n            } else { // have no idea about the array, but we can exclude nums[start] because nums[start] == nums[mid]\\n                start++;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean search(int[] nums, int target) {\\n        // note here end is initialized to len instead of (len-1)\\n        int start = 0, end = nums.length;\\n        while (start < end) {\\n            int mid = (start + end) / 2;\\n            if (nums[mid] == target) return true;\\n            if (nums[mid] > nums[start]) { // nums[start..mid] is sorted\\n                // check if target in left half\\n                if (target < nums[mid] && target >= nums[start]) end = mid;\\n                else start = mid + 1;\\n            } else if (nums[mid] < nums[start]) { // nums[mid..end] is sorted\\n                // check if target in right half\\n                if (target > nums[mid] && target < nums[start]) start = mid + 1;\\n                else end = mid;\\n            } else { // have no idea about the array, but we can exclude nums[start] because nums[start] == nums[mid]\\n                start++;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 344480,
                "title": "python-3-readable-fast-short-binary-search",
                "content": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        # Initilize two pointers\\n        begin = 0\\n        end = len(nums) - 1 \\n        while begin <= end:\\n            mid = (begin + end)//2\\n            if nums[mid] == target:\\n                return True\\n            if nums[mid] == nums[end]: # Fail to estimate which side is sorted\\n                end -= 1  # In worst case: O(n)\\n            elif nums[mid] > nums[end]: # Left side of mid is sorted\\n                if  nums[begin] <= target and target < nums[mid]: # Target in the left side\\n                    end = mid - 1\\n                else: # in right side\\n                    begin = mid + 1\\n            else: # Right side is sorted\\n                if  nums[mid] < target and target <= nums[end]: # Target in the right side\\n                    begin = mid + 1\\n                else: # in left side\\n                    end = mid - 1\\n        return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        # Initilize two pointers\\n        begin = 0\\n        end = len(nums) - 1 \\n        while begin <= end:\\n            mid = (begin + end)//2\\n            if nums[mid] == target:\\n                return True\\n            if nums[mid] == nums[end]: # Fail to estimate which side is sorted\\n                end -= 1  # In worst case: O(n)\\n            elif nums[mid] > nums[end]: # Left side of mid is sorted\\n                if  nums[begin] <= target and target < nums[mid]: # Target in the left side\\n                    end = mid - 1\\n                else: # in right side\\n                    begin = mid + 1\\n            else: # Right side is sorted\\n                if  nums[mid] < target and target <= nums[end]: # Target in the right side\\n                    begin = mid + 1\\n                else: # in left side\\n                    end = mid - 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888242,
                "title": "100-binary-search-video-with-rotation-handling-optimal",
                "content": "# Problem Understanding\\n\\nThe problem presents us with a modified search challenge where we\\'re provided an array that has been rotated at an undetermined pivot. Unlike a standard sorted array, this comes with the added complexity of having been altered. Imagine a scenario where you take a sorted array, make a cut at a specific point, and then attach the detached segment to the front. The aim here is to ascertain whether a specific target value is present in this rearranged sorted array. Adding to the intricacy, this array might have duplicate values.\\n\\nFor instance, considering the array $$[2,5,6,0,0,1,2]$$, it becomes evident that a rotation occurred after the number 6. If our target is 2, it is indeed present within the array. Similarly, for a target of 6, it is also found in the array. However, should the target be a number like 3, it is absent from the array.\\n\\nBelow are the visualizations for the \"Search in Rotated Sorted Array II\" problem for targets 2 and 6:\\n\\n- The top chart visualizes the search process in the rotated sorted array. Each step highlights the current mid value being considered with a red rectangle.\\n\\n- The table below provides a step-by-step breakdown of the search algorithm, detailing the indices (low, mid, high) and their corresponding values at each step of the search.\\n\\nFor each target:\\n\\n- The top chart shows the search process in the rotated sorted array. Each step of the search process is highlighted by a red rectangle.\\n\\n- The table below provides a step-by-step breakdown of the search algorithm, detailing the indices (low, mid, high) and their corresponding values at each search step.\\n\\n**Target = 2**\\n\\n![t=2.png](https://assets.leetcode.com/users/images/975d9a60-db68-476b-8118-2b94e74ef2e8_1691628777.9348447.png)\\n\\n**Target = 6**\\n\\n![t=6.png](https://assets.leetcode.com/users/images/edbb07a7-8db5-42f7-8e45-2eab3bbdee2c_1691628821.3179991.png)\\n\\n---\\n\\n# Live Coding & Explanation\\n\\nhttps://youtu.be/Py75aDQqrJw\\n\\n# Approach\\n\\nTo tackle this challenge, we employ a binary search strategy, taking into account the rotation and potential duplicates. The primary goal is to identify the sorted part of the array in each step and narrow down our search based on the target.\\n\\n## Binary Search with Rotation Handling\\n\\nOur approach doesn\\'t involve searching for the rotation point. Instead, we modify the binary search to work directly with the rotated array:\\n\\n- We calculate the middle index, `mid`, of our current search interval.\\n- If the value at `mid` is our target, we\\'ve found it.\\n- If the value at `low` is the same as the value at `mid`, we might be dealing with duplicates. In this case, we increment `low` to skip potential duplicates.\\n- If the left part of our interval (from `low` to `mid`) is sorted (i.e., `nums[low] <= nums[mid]`), we check if our target lies within this sorted interval. If it does, we search in the left half; otherwise, we search in the right half.\\n- If the left part isn\\'t sorted, then the right part must be. We apply a similar logic to decide which half to search in next.\\n\\n## Code Breakdown\\n\\n1. Initialize pointers `low` and `high` at the start and end of `nums`, respectively.\\n2. While `low` is less than or equal to `high`, compute `mid`.\\n3. Check if `nums[mid]` is the target. If yes, return `True`.\\n4. If `nums[low]` is equal to `nums[mid]`, increment `low`.\\n5. If the left half is sorted, check if target lies within it. If yes, update `high`; otherwise, update `low`.\\n6. If the right half is sorted, use a similar logic to update `low` or `high`.\\n7. If the loop completes without finding the target, return `False`.\\n\\n## Rationale\\n\\nThe beauty of this solution lies in its adaptability. While binary search is a straightforward algorithm on sorted arrays, this problem added the twist of a rotated array and duplicates. By understanding the structure of the rotated array and handling duplicates wisely, we can still achieve efficient search performance.\\n\\n# Complexity\\n\\n**Time Complexity:** $$O(\\\\log n)$$ for the best case (unique elements). However, in the worst-case scenario (many duplicates), the complexity can degrade to $$O(n)$$.\\n\\n**Space Complexity:** $$O(1)$$ as we only use a constant amount of space.\\n\\n# Performance\\n\\n| Language    | Runtime (ms) | Runtime Beat (%) | Memory (MB) | Memory Beat (%) |\\n|-------------|--------------|------------------|-------------|-----------------|\\n| Rust        | 0 ms         | 100%             | 2.2 MB      | 48%             |\\n| C++         | 0 ms         | 100%             | 13.9 MB     | 50.5%           |\\n| Java        | 0 ms         | 100%             | 43.4 MB     | 15.46%          |\\n| Go          | 5 ms         | 56.57%           | 3.2 MB      | 98.86%          |\\n| JavaScript  | 49 ms        | 92.77%           | 41.6 MB     | 97.20%          |\\n| Python3     | 56 ms        | 92.26%           | 17 MB       | 47.39%          |\\n| C#          | 75 ms        | 98.86%           | 41.6 MB     | 80.11%          |\\n\\n![per_81.png](https://assets.leetcode.com/users/images/edb2e870-610c-4c4e-a3bd-3c06b56514f8_1691627868.3040042.png)\\n\\n\\n# Code\\n``` Python []\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        low, high = 0, len(nums) - 1\\n\\n        while low <= high:\\n            mid = (low + high) // 2\\n            if nums[mid] == target:\\n                return True\\n         \\n            if nums[low] == nums[mid]:\\n                low += 1\\n                continue\\n            \\n            if nums[low] <= nums[mid]:\\n                if nums[low] <= target <= nums[mid]:\\n                    high = mid - 1\\n                else:\\n                    low = mid + 1\\n            else:\\n                if nums[mid] <= target <= nums[high]:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n        \\n        return False\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool search(std::vector<int>& nums, int target) {\\n        int low = 0, high = nums.size() - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            if (nums[mid] == target) return true;\\n\\n            if (nums[low] == nums[mid]) {\\n                low++;\\n                continue;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target <= nums[mid]) high = mid - 1;\\n                else low = mid + 1;\\n            } else {\\n                if (nums[mid] <= target && target <= nums[high]) low = mid + 1;\\n                else high = mid - 1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn search(nums: Vec<i32>, target: i32) -> bool {\\n        let mut low = 0;\\n        let mut high = nums.len() as i32 - 1;\\n\\n        while low <= high {\\n            let mid = (low + high) / 2;\\n            if nums[mid as usize] == target {\\n                return true;\\n            }\\n\\n            if nums[low as usize] == nums[mid as usize] {\\n                low += 1;\\n                continue;\\n            }\\n\\n            if nums[low as usize] <= nums[mid as usize] {\\n                if nums[low as usize] <= target && target <= nums[mid as usize] {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if nums[mid as usize] <= target && target <= nums[high as usize] {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n        false\\n    }\\n}\\n```\\n``` Go []\\nfunc search(nums []int, target int) bool {\\n    low, high := 0, len(nums) - 1\\n\\n    for low <= high {\\n        mid := (low + high) / 2\\n        if nums[mid] == target {\\n            return true\\n        }\\n\\n        if nums[low] == nums[mid] {\\n            low++\\n            continue\\n        }\\n\\n        if nums[low] <= nums[mid] {\\n            if nums[low] <= target && target <= nums[mid] {\\n                high = mid - 1\\n            } else {\\n                low = mid + 1\\n            }\\n        } else {\\n            if nums[mid] <= target && target <= nums[high] {\\n                low = mid + 1\\n            } else {\\n                high = mid - 1\\n            }\\n        }\\n    }\\n    return false\\n}\\n```\\n``` Java []\\npublic class Solution {\\n    public boolean search(int[] nums, int target) {\\n        int low = 0, high = nums.length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            if (nums[mid] == target) return true;\\n\\n            if (nums[low] == nums[mid]) {\\n                low++;\\n                continue;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target <= nums[mid]) high = mid - 1;\\n                else low = mid + 1;\\n            } else {\\n                if (nums[mid] <= target && target <= nums[high]) low = mid + 1;\\n                else high = mid - 1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar search = function(nums, target) {\\n    let low = 0, high = nums.length - 1;\\n\\n    while (low <= high) {\\n        let mid = Math.floor((low + high) / 2);\\n        if (nums[mid] === target) return true;\\n\\n        if (nums[low] === nums[mid]) {\\n            low++;\\n            continue;\\n        }\\n\\n        if (nums[low] <= nums[mid]) {\\n            if (nums[low] <= target && target <= nums[mid]) high = mid - 1;\\n            else low = mid + 1;\\n        } else {\\n            if (nums[mid] <= target && target <= nums[high]) low = mid + 1;\\n            else high = mid - 1;\\n        }\\n    }\\n    return false;\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public bool Search(int[] nums, int target) {\\n        int low = 0, high = nums.Length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            if (nums[mid] == target) return true;\\n\\n            if (nums[low] == nums[mid]) {\\n                low++;\\n                continue;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target <= nums[mid]) high = mid - 1;\\n                else low = mid + 1;\\n            } else {\\n                if (nums[mid] <= target && target <= nums[high]) low = mid + 1;\\n                else high = mid - 1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "Array",
                    "Binary Search"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        low, high = 0, len(nums) - 1\\n\\n        while low <= high:\\n            mid = (low + high) // 2\\n            if nums[mid] == target:\\n                return True\\n         \\n            if nums[low] == nums[mid]:\\n                low += 1\\n                continue\\n            \\n            if nums[low] <= nums[mid]:\\n                if nums[low] <= target <= nums[mid]:\\n                    high = mid - 1\\n                else:\\n                    low = mid + 1\\n            else:\\n                if nums[mid] <= target <= nums[high]:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n        \\n        return False\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    bool search(std::vector<int>& nums, int target) {\\n        int low = 0, high = nums.size() - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            if (nums[mid] == target) return true;\\n\\n            if (nums[low] == nums[mid]) {\\n                low++;\\n                continue;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target <= nums[mid]) high = mid - 1;\\n                else low = mid + 1;\\n            } else {\\n                if (nums[mid] <= target && target <= nums[high]) low = mid + 1;\\n                else high = mid - 1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn search(nums: Vec<i32>, target: i32) -> bool {\\n        let mut low = 0;\\n        let mut high = nums.len() as i32 - 1;\\n\\n        while low <= high {\\n            let mid = (low + high) / 2;\\n            if nums[mid as usize] == target {\\n                return true;\\n            }\\n\\n            if nums[low as usize] == nums[mid as usize] {\\n                low += 1;\\n                continue;\\n            }\\n\\n            if nums[low as usize] <= nums[mid as usize] {\\n                if nums[low as usize] <= target && target <= nums[mid as usize] {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if nums[mid as usize] <= target && target <= nums[high as usize] {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n        false\\n    }\\n}\\n```\n``` Go []\\nfunc search(nums []int, target int) bool {\\n    low, high := 0, len(nums) - 1\\n\\n    for low <= high {\\n        mid := (low + high) / 2\\n        if nums[mid] == target {\\n            return true\\n        }\\n\\n        if nums[low] == nums[mid] {\\n            low++\\n            continue\\n        }\\n\\n        if nums[low] <= nums[mid] {\\n            if nums[low] <= target && target <= nums[mid] {\\n                high = mid - 1\\n            } else {\\n                low = mid + 1\\n            }\\n        } else {\\n            if nums[mid] <= target && target <= nums[high] {\\n                low = mid + 1\\n            } else {\\n                high = mid - 1\\n            }\\n        }\\n    }\\n    return false\\n}\\n```\n``` Java []\\npublic class Solution {\\n    public boolean search(int[] nums, int target) {\\n        int low = 0, high = nums.length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            if (nums[mid] == target) return true;\\n\\n            if (nums[low] == nums[mid]) {\\n                low++;\\n                continue;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target <= nums[mid]) high = mid - 1;\\n                else low = mid + 1;\\n            } else {\\n                if (nums[mid] <= target && target <= nums[high]) low = mid + 1;\\n                else high = mid - 1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar search = function(nums, target) {\\n    let low = 0, high = nums.length - 1;\\n\\n    while (low <= high) {\\n        let mid = Math.floor((low + high) / 2);\\n        if (nums[mid] === target) return true;\\n\\n        if (nums[low] === nums[mid]) {\\n            low++;\\n            continue;\\n        }\\n\\n        if (nums[low] <= nums[mid]) {\\n            if (nums[low] <= target && target <= nums[mid]) high = mid - 1;\\n            else low = mid + 1;\\n        } else {\\n            if (nums[mid] <= target && target <= nums[high]) low = mid + 1;\\n            else high = mid - 1;\\n        }\\n    }\\n    return false;\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public bool Search(int[] nums, int target) {\\n        int low = 0, high = nums.Length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            if (nums[mid] == target) return true;\\n\\n            if (nums[low] == nums[mid]) {\\n                low++;\\n                continue;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target <= nums[mid]) high = mid - 1;\\n                else low = mid + 1;\\n            } else {\\n                if (nums[mid] <= target && target <= nums[high]) low = mid + 1;\\n                else high = mid - 1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28277,
                "title": "ac-answer-based-on-search-in-rotate-sorted-array-so-two-problems-consolidated-as-one",
                "content": "The only difference is the two \"while\" lines, so we don't have to remember/understand totally different solutions for these two series problems: \"Search in Rotate Sorted Array\" and \"Search in Rotate Sorted Array II\"\\n\\n\\n    public boolean search(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n        \\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            // System.out.format(\"start=%d,mid=%d,end=%d\\\\n\",start,mid,end);\\n            if (nums[mid] == target) return true;\\n            \\n            // need to handle: 1,3,1,1,1\\n            while (nums[start] == nums[mid] && start != mid) {\\n                start ++;\\n            }\\n            while (nums[mid] == nums[end] && mid != end) {\\n                end --;\\n            }\\n\\n            // the following is the same as problem I\\n            if (nums[start] <= nums[mid]) {\\n                if (nums[start] <= target && target < nums[mid]) {\\n                    end = mid - 1;\\n                } else {\\n                    start = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[end]) {\\n                    start = mid + 1;\\n                } else {\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }",
                "solutionTags": [],
                "code": "The only difference is the two \"while\" lines, so we don't have to remember/understand totally different solutions for these two series problems: \"Search in Rotate Sorted Array\" and \"Search in Rotate Sorted Array II\"\\n\\n\\n    public boolean search(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n        \\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            // System.out.format(\"start=%d,mid=%d,end=%d\\\\n\",start,mid,end);\\n            if (nums[mid] == target) return true;\\n            \\n            // need to handle: 1,3,1,1,1\\n            while (nums[start] == nums[mid] && start != mid) {\\n                start ++;\\n            }\\n            while (nums[mid] == nums[end] && mid != end) {\\n                end --;\\n            }\\n\\n            // the following is the same as problem I\\n            if (nums[start] <= nums[mid]) {\\n                if (nums[start] <= target && target < nums[mid]) {\\n                    end = mid - 1;\\n                } else {\\n                    start = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[end]) {\\n                    start = mid + 1;\\n                } else {\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 28295,
                "title": "c-from-version-1",
                "content": "If you have solved [Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/) ([my solution](https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/14623/Binary-search-case-by-case)), this problem only requires an additional duplicate removal.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size() - 1;\\n        while (l <= r) {\\n            while (l < r && nums[l] == nums[l + 1]) {\\n                l++;\\n            }\\n            while (l < r && nums[r] == nums[r - 1]) {\\n                r--;\\n            }\\n            int m = l + (r - l) / 2;\\n            if (nums[m] == target) {\\n                return true;\\n            }\\n            if (nums[m] > target) {\\n                if (nums[l] > nums[m] || nums[l] <= target) {\\n                    r = m - 1;\\n                } else {\\n                    l = m + 1;\\n                }\\n            } else {\\n                if (nums[l] <= nums[m] || nums[l] > target) {\\n                    l = m + 1;\\n                } else {\\n                    r = m - 1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\nAnother version suggested by @clubmaster.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size() - 1;\\n        while (l <= r && nums[l] != nums[r]) {\\n            int m = l + (r - l) / 2;\\n            if (nums[m] == target) {\\n                return true;\\n            }\\n            if (nums[m] > target) {\\n                if (nums[l] > nums[m] || nums[l] <= target) {\\n                    r = m - 1;\\n                } else {\\n                    l = m + 1;\\n                }\\n            } else {\\n                if (nums[l] <= nums[m] || nums[l] > target) {\\n                    l = m + 1;\\n                } else {\\n                    r = m - 1;\\n                }\\n            }\\n        }\\n        return find(nums, target, l, r);\\n    }\\nprivate:\\n    bool find(vector<int>& nums, int target, int l, int r) {\\n        while (l <= r) {\\n            if (nums[l++] == target) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size() - 1;\\n        while (l <= r) {\\n            while (l < r && nums[l] == nums[l + 1]) {\\n                l++;\\n            }\\n            while (l < r && nums[r] == nums[r - 1]) {\\n                r--;\\n            }\\n            int m = l + (r - l) / 2;\\n            if (nums[m] == target) {\\n                return true;\\n            }\\n            if (nums[m] > target) {\\n                if (nums[l] > nums[m] || nums[l] <= target) {\\n                    r = m - 1;\\n                } else {\\n                    l = m + 1;\\n                }\\n            } else {\\n                if (nums[l] <= nums[m] || nums[l] > target) {\\n                    l = m + 1;\\n                } else {\\n                    r = m - 1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size() - 1;\\n        while (l <= r && nums[l] != nums[r]) {\\n            int m = l + (r - l) / 2;\\n            if (nums[m] == target) {\\n                return true;\\n            }\\n            if (nums[m] > target) {\\n                if (nums[l] > nums[m] || nums[l] <= target) {\\n                    r = m - 1;\\n                } else {\\n                    l = m + 1;\\n                }\\n            } else {\\n                if (nums[l] <= nums[m] || nums[l] > target) {\\n                    l = m + 1;\\n                } else {\\n                    r = m - 1;\\n                }\\n            }\\n        }\\n        return find(nums, target, l, r);\\n    }\\nprivate:\\n    bool find(vector<int>& nums, int target, int l, int r) {\\n        while (l <= r) {\\n            if (nums[l++] == target) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 180074,
                "title": "java-0ms-solution-clear-and-simple",
                "content": "```\\n    public boolean search(int[] nums, int target) {\\n        int i = 0, j = nums.length - 1;\\n        while(i <= j) {\\n            int m = (i + j) / 2;\\n            if(nums[m] == target) return true;\\n            if(nums[m] == nums[i]) i++;   //\"duplicate\", jump\\n            else if(nums[m] > nums[i]) {\\n                if(nums[m] > target && nums[i] <= target) j = m - 1; \\n                else i = m + 1;\\n            } else {\\n                if(nums[m] < target && nums[j] >= target) i = m + 1;\\n                else j = m - 1;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean search(int[] nums, int target) {\\n        int i = 0, j = nums.length - 1;\\n        while(i <= j) {\\n            int m = (i + j) / 2;\\n            if(nums[m] == target) return true;\\n            if(nums[m] == nums[i]) i++;   //\"duplicate\", jump\\n            else if(nums[m] > nums[i]) {\\n                if(nums[m] > target && nums[i] <= target) j = m - 1; \\n                else i = m + 1;\\n            } else {\\n                if(nums[m] < target && nums[j] >= target) i = m + 1;\\n                else j = m - 1;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 942575,
                "title": "python-binary-search-dfs-explained-with-diagram",
                "content": "The idea here is to use both binary search and dfs: each time we compare `nums[mid]` and `nums[end]` and we can have several options:\\n1. `nums[mid] > nums[end]`, for example data can look like `3,4,5,6,7,1,2`. Then we need to check conditions:\\na. If `nums[end] < target <= nums[mid]`, then it means, that we need to look in the left half of our data: see region `1` on the left image.\\nb. Else means, that we need to look in the right half of data.\\n2. `nums[mid] < nums[end]`, for example data can look like `6,7,1,2,3,4,5`. Then we need to check conditions:\\na. `if nums[mid] < target <= nums[end]`,  then it means, that we need to look in the right half of our data: see region `1` on the right image.\\nb. Else means, that we need to look in the left half of data.\\n3. In this problem it can happen, that `nums[mid] == nums[end]`, and in this case we do not know where to find our number, so we just look for it in both halves.\\n\\n**Complexity**: if we do not have any duplicates, it is for sure `O(log n)`. If we have any, it can be potentially `O(n)` for cases like `111111111111121111`: where we do not know the place of `2` and we basically need to traverse all elements to find it.\\n\\n\\n![image](https://assets.leetcode.com/users/images/ee8db5ad-c766-4a94-a0fe-f1f9ec2a0bb2_1605864275.9943457.png)\\n\\n\\n\\n```\\nclass Solution:\\n    def search(self, nums, target):\\n        def dfs(beg, end):\\n            if end - beg <= 1: return target in nums[beg: end+1]\\n            \\n            mid = (beg + end)//2\\n            if nums[mid] > nums[end]:   # eg. 3,4,5,6,7,1,2\\n                if nums[end] < target <= nums[mid]:\\n                    return dfs(beg, mid)\\n                else:\\n                    return dfs(mid + 1, end)\\n            elif nums[mid] < nums[end]: # eg. 6,7,1,2,3,4,5\\n                if nums[mid] < target <= nums[end]:\\n                    return dfs(mid + 1, end)\\n                else:\\n                    return dfs(beg, mid)\\n            else:\\n                return dfs(mid+1, end) or dfs(beg, mid)\\n    \\n        return dfs(0, len(nums)-1)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def search(self, nums, target):\\n        def dfs(beg, end):\\n            if end - beg <= 1: return target in nums[beg: end+1]\\n            \\n            mid = (beg + end)//2\\n            if nums[mid] > nums[end]:   # eg. 3,4,5,6,7,1,2\\n                if nums[end] < target <= nums[mid]:\\n                    return dfs(beg, mid)\\n                else:\\n                    return dfs(mid + 1, end)\\n            elif nums[mid] < nums[end]: # eg. 6,7,1,2,3,4,5\\n                if nums[mid] < target <= nums[end]:\\n                    return dfs(mid + 1, end)\\n                else:\\n                    return dfs(beg, mid)\\n            else:\\n                return dfs(mid+1, end) or dfs(beg, mid)\\n    \\n        return dfs(0, len(nums)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28212,
                "title": "when-there-are-duplicates-the-worst-case-is-o-n-could-we-do-better",
                "content": "Since we will have some duplicate elements in this problem, it is a little tricky because sometimes we cannot decide whether to go to the left side or right side. So for this condition, I have to probe both left  and right side simultaneously to decide which side we need to find the number. Only in this condition, the time complexity may be *O(n)*. The rest conditions are always *O(log n)*.\\n\\nFor example:\\n\\ninput: `113111111111`,  Looking for *target* `3`.\\n\\nIs my solution correct? My code is as followed:\\n\\n    public class Solution {\\n        public boolean search(int[] A, int target) {\\n            // IMPORTANT: Please reset any member data you declared, as\\n            // the same Solution instance will be reused for each test case.\\n            int i = 0;\\n            int j = A.length - 1;\\n            while(i <= j){\\n                int mid = (i + j) / 2;\\n                if(A[mid] == target)\\n                    return true;\\n                else if(A[mid] < A[i]){\\n                    if(target > A[j])\\n                        j = mid - 1;\\n                    else if(target < A[mid])\\n                        j = mid - 1;\\n                    else\\n                        i = mid + 1;\\n                }else if(A[mid] > A[i]){\\n                    if(target < A[mid] && target >= A[i])\\n                        j = mid - 1;\\n                    else\\n                        i = mid + 1;\\n                }else{ // A[mid] == A[i]\\n                    if(A[mid] != A[j])\\n                        i = mid + 1;\\n                    else{\\n                        boolean flag = true;\\n                        for(int k = 1; mid - k >= i && mid + k <= j; k++){\\n                            if(A[mid] != A[mid - k]){\\n                                j = mid - k;\\n                                flag = false;\\n                                break;\\n                            }else if(A[mid] != A[mid + k]){\\n                                i = mid + k;\\n                                flag = false;\\n                                break;\\n                            }\\n                        }\\n                        if(flag)\\n                            return false;\\n                    }\\n                }\\n            }\\n            return false;\\n        }\\n    }",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\n        public boolean search(int[] A, int target) {\\n            // IMPORTANT: Please reset any member data you declared, as\\n            // the same Solution instance will be reused for each test case.\\n            int i = 0;\\n            int j = A.length - 1;\\n            while(i <= j){\\n                int mid = (i + j) / 2;\\n                if(A[mid] == target)\\n                    return true;\\n                else if(A[mid] < A[i]){\\n                    if(target > A[j])\\n                        j = mid - 1;\\n                    else if(target < A[mid])\\n                        j = mid - 1;\\n                    else\\n                        i = mid + 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2689441,
                "title": "java-best-solution-for-understanding",
                "content": "\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n      int start = 0, end = nums.length - 1;\\n      while(start <= end) {\\n          int mid = start + (end - start) / 2;\\n          if(nums[mid] == target) return true;\\n          \\n          //if there are duplicates\\n          if(nums[start] == nums[mid] && nums[mid] == nums[end]) {\\n                start ++;\\n                end --;\\n            }\\n          \\n          //left half is sorted\\n          else if(nums[start] <= nums[mid]) {\\n              if(target >= nums[start] && target <= nums[mid])\\n              end = mid - 1;\\n\\n              else\\n              start = mid + 1;\\n          }\\n\\n          //right half is sorted\\n          else {\\n              if(target <= nums[end] && target >= nums[mid])\\n              start = mid + 1;\\n\\n              else\\n              end = mid - 1; \\n          }\\n      }\\n      return false;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n      int start = 0, end = nums.length - 1;\\n      while(start <= end) {\\n          int mid = start + (end - start) / 2;\\n          if(nums[mid] == target) return true;\\n          \\n          //if there are duplicates\\n          if(nums[start] == nums[mid] && nums[mid] == nums[end]) {\\n                start ++;\\n                end --;\\n            }\\n          \\n          //left half is sorted\\n          else if(nums[start] <= nums[mid]) {\\n              if(target >= nums[start] && target <= nums[mid])\\n              end = mid - 1;\\n\\n              else\\n              start = mid + 1;\\n          }\\n\\n          //right half is sorted\\n          else {\\n              if(target <= nums[end] && target >= nums[mid])\\n              start = mid + 1;\\n\\n              else\\n              end = mid - 1; \\n          }\\n      }\\n      return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28290,
                "title": "binary-search-java-solution",
                "content": "    public boolean search(int[] nums, int target) {\\n        int l = 0, h = nums.length-1;\\n        while(l <= h){\\n            int mid = l + (h-l)/2;\\n            if(nums[mid] == target)     return true;\\n            if(nums[mid] == nums[h])    h--;\\n            else if(nums[mid] < nums[h]){\\n                if(target > nums[mid] && target <= nums[h])\\n                    l = mid + 1;\\n                else\\n                    h = mid - 1;\\n            }else{\\n                if(target >= nums[l] && target < nums[mid])\\n                    h = mid - 1;\\n                else\\n                    l = mid + 1;\\n            }\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "    public boolean search(int[] nums, int target) {\\n        int l = 0, h = nums.length-1;\\n        while(l <= h){\\n            int mid = l + (h-l)/2;\\n            if(nums[mid] == target)     return true;\\n            if(nums[mid] == nums[h])    h--;\\n            else if(nums[mid] < nums[h]){\\n                if(target > nums[mid] && target <= nums[h])\\n                    l = mid + 1;\\n                else\\n                    h = mid - 1;\\n            }else{\\n                if(target >= nums[l] && target < nums[mid])\\n                    h = mid - 1;\\n                else\\n                    l = mid + 1;\\n            }\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3888368,
                "title": "very-easy-code-binary-search-c-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncheck which part is sorted so we can decide in which part target is present because lets take a case like if left part is sorted then the element is between the range left to mid and if target is between left that range move right to mid-1 otherwise i=mid+1.\\n\\nfor duplicate case lets take a case 4 1 2 4 4 4 4 \\nl=0  r=6  mid=3 \\nNow at element at mid,l,r :  midelement =4  lelement=4  relement=4\\n\\nso we can not decise where to go because range cant be determined so in this case do l++ r-- until we can get the clear idea of range. after that just write same code of search in a rotated sorted array.\\n\\nFor detailed explanation you can refer to my youtube channel (hindi Language)\\nhttps://youtu.be/2SoCUS19JXg\\n or link in my profile.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation (5-10) minutes\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Initialize two pointers `i` and `j` pointing to the start and end of the array.\\n\\n2. While `i` is less than or equal to `j`:\\n   a. Calculate the middle index `mid`.\\n   b. If `nums[mid]` equals the target, return `true`.\\n   c. If `nums[mid]`, `nums[i]`, and `nums[j]` are all the same, increment `i` and decrement `j`.\\n   d. If `nums[mid]` is greater than or equal to `nums[i]`, check if target lies in the left sorted portion (`target >= nums[i] && target < nums[mid]`). Adjust pointers accordingly.\\n   e. If `nums[mid]` is less than or equal to `nums[j]`, check if target lies in the right sorted portion (`target > nums[mid] && target <= nums[j]`). Adjust pointers accordingly.\\n\\n3. If loop completes without returning, return `false`.\\n\\n# Complexity\\n- Time complexity:O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1);\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int i=0;\\n        int j=nums.size()-1;\\n        while(i<=j){\\n            int mid=i+(j-i)/2;\\n            if(nums[mid]==target)\\n                return true;\\n            else if(nums[mid]==nums[i]&&nums[mid]==nums[j]){\\n                i=i+1;\\n                j=j-1;\\n            }\\n            else if(nums[mid]>=nums[i]){\\n                if(target>=nums[i]&& target<nums[mid]){\\n                    j=mid-1;\\n                }\\n                else\\n                  i=mid+1;\\n            }\\n            else if(nums[mid]<=nums[j]){\\n                if(target>nums[mid]&& target<=nums[j]){\\n                    i=mid+1;\\n                }\\n                else\\n                    j=mid-1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int i = 0;\\n        int j = nums.length - 1;\\n        while (i <= j) {\\n            int mid = i + (j - i) / 2;\\n            if (nums[mid] == target) {\\n                return true;\\n            } else if (nums[mid] == nums[i] && nums[mid] == nums[j]) {\\n                i = i + 1;\\n                j = j - 1;\\n            } else if (nums[mid] >= nums[i]) {\\n                if (target >= nums[i] && target < nums[mid]) {\\n                    j = mid - 1;\\n                } else {\\n                    i = mid + 1;\\n                }\\n            } else if (nums[mid] <= nums[j]) {\\n                if (target > nums[mid] && target <= nums[j]) {\\n                    i = mid + 1;\\n                } else {\\n                    j = mid - 1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        i = 0\\n        j = len(nums) - 1\\n        while i <= j:\\n            mid = i + (j - i) // 2\\n            if nums[mid] == target:\\n                return True\\n            elif nums[mid] == nums[i] and nums[mid] == nums[j]:\\n                i = i + 1\\n                j = j - 1\\n            elif nums[mid] >= nums[i]:\\n                if target >= nums[i] and target < nums[mid]:\\n                    j = mid - 1\\n                else:\\n                    i = mid + 1\\n            elif nums[mid] <= nums[j]:\\n                if target > nums[mid] and target <= nums[j]:\\n                    i = mid + 1\\n                else:\\n                    j = mid - 1\\n        return False\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Binary Search"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int i=0;\\n        int j=nums.size()-1;\\n        while(i<=j){\\n            int mid=i+(j-i)/2;\\n            if(nums[mid]==target)\\n                return true;\\n            else if(nums[mid]==nums[i]&&nums[mid]==nums[j]){\\n                i=i+1;\\n                j=j-1;\\n            }\\n            else if(nums[mid]>=nums[i]){\\n                if(target>=nums[i]&& target<nums[mid]){\\n                    j=mid-1;\\n                }\\n                else\\n                  i=mid+1;\\n            }\\n            else if(nums[mid]<=nums[j]){\\n                if(target>nums[mid]&& target<=nums[j]){\\n                    i=mid+1;\\n                }\\n                else\\n                    j=mid-1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int i = 0;\\n        int j = nums.length - 1;\\n        while (i <= j) {\\n            int mid = i + (j - i) / 2;\\n            if (nums[mid] == target) {\\n                return true;\\n            } else if (nums[mid] == nums[i] && nums[mid] == nums[j]) {\\n                i = i + 1;\\n                j = j - 1;\\n            } else if (nums[mid] >= nums[i]) {\\n                if (target >= nums[i] && target < nums[mid]) {\\n                    j = mid - 1;\\n                } else {\\n                    i = mid + 1;\\n                }\\n            } else if (nums[mid] <= nums[j]) {\\n                if (target > nums[mid] && target <= nums[j]) {\\n                    i = mid + 1;\\n                } else {\\n                    j = mid - 1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n```\n```python []\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        i = 0\\n        j = len(nums) - 1\\n        while i <= j:\\n            mid = i + (j - i) // 2\\n            if nums[mid] == target:\\n                return True\\n            elif nums[mid] == nums[i] and nums[mid] == nums[j]:\\n                i = i + 1\\n                j = j - 1\\n            elif nums[mid] >= nums[i]:\\n                if target >= nums[i] and target < nums[mid]:\\n                    j = mid - 1\\n                else:\\n                    i = mid + 1\\n            elif nums[mid] <= nums[j]:\\n                if target > nums[mid] and target <= nums[j]:\\n                    i = mid + 1\\n                else:\\n                    j = mid - 1\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 942601,
                "title": "python-just-return-nums-in-target",
                "content": "When duplicates are present in the array, there will be cases where we cannot decide which way to go. \\n\\n`111111111111111111111121111111111111111111`\\nSay you land in a mid point where you get a `1`.\\n\\nWhere are you?\\n\\n`11111111111111x111111121111111111111111111`\\nMaybe you are here.\\n\\n`111111111111111111111211111111111111x11111`\\nOr here.\\n\\nAs marked by `x`. You cannot know in advance. So in this worst case the runtime will be `O(N)`. This is kinda the whole point of the question.\\n\\nThe condition when this might happen is when `nums[0]==nums[-1]`. You will be fine otherwise. You can filter this out via\\n`if nums[0]==nums[-1]: return x in nums`. But at that point I\\'m not motivated enough the code the rest of it. So just return `target in nums` will be my to-go solution with this one.\\n\\n\\n\\n**Edit:** But just for the sake of good conscience, sth like this\\n```python\\nclass Solution:\\n    def search(self, A, t):\\n        if not A: return False #Leetcode favorite\\n        if len(A)==1: return A[0]==t #Avoid length 1\\n        if A[0]==t or A[-1]==t: return True #Don\\'t bother if end points contain t\\n        if A[0]==A[-1]: return t in A #Makes worst case O(N)\\n        \\n\\t\\t#Use binary search to find offset point\\n\\t\\t#The target will either be in A[start:finish] or absent\\n\\t\\t#O(log N)\\n        if A[0]<A[-1]: #no offset in the array\\n            start, finish = 0, len(A)-1\\n        else: #there is offset in the array\\n            left, right = 0, len(A)-1\\n            while left<right-1:\\n                mid = (left+right)>>1\\n                if A[mid]>=A[0]:\\n                    left = mid\\n                else:\\n                    right = mid\\n            if A[right]<A[left]: left=right\\n            start, finish = (0, left-1) if A[0]<t else (left, len(A)-1)\\n        \\n\\t\\t#Now you know the range to search for, just apply binary search again\\n\\t\\t#O(log N)\\n        while start<finish-1:\\n            mid = (start+finish)>>1\\n            if A[mid]<t:\\n                start = mid\\n            else:\\n                finish = mid\\n        return A[start]==t or A[finish]==t\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def search(self, A, t):\\n        if not A: return False #Leetcode favorite\\n        if len(A)==1: return A[0]==t #Avoid length 1\\n        if A[0]==t or A[-1]==t: return True #Don\\'t bother if end points contain t\\n        if A[0]==A[-1]: return t in A #Makes worst case O(N)\\n        \\n\\t\\t#Use binary search to find offset point\\n\\t\\t#The target will either be in A[start:finish] or absent\\n\\t\\t#O(log N)\\n        if A[0]<A[-1]: #no offset in the array\\n            start, finish = 0, len(A)-1\\n        else: #there is offset in the array\\n            left, right = 0, len(A)-1\\n            while left<right-1:\\n                mid = (left+right)>>1\\n                if A[mid]>=A[0]:\\n                    left = mid\\n                else:\\n                    right = mid\\n            if A[right]<A[left]: left=right\\n            start, finish = (0, left-1) if A[0]<t else (left, len(A)-1)\\n        \\n\\t\\t#Now you know the range to search for, just apply binary search again\\n\\t\\t#O(log N)\\n        while start<finish-1:\\n            mid = (start+finish)>>1\\n            if A[mid]<t:\\n                start = mid\\n            else:\\n                finish = mid\\n        return A[start]==t or A[finish]==t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 436634,
                "title": "c-beats-99-binary-search-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int left = 0, right = nums.size() - 1;\\n        \\n        // There are two scenarios. One where the array is rotated and one \\n        // where it is not.\\n\\t\\t\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) { // Obvious solution\\n                return true;\\n            // Ascending from mid to right.\\n            } else if (nums[mid] < nums[right]) {\\n                // If the target is within the right half\\n                if (nums[mid] < target && target <= nums[right]) {\\n                    left = mid + 1;\\n                } else {\\n                    right = mid - 1;\\n                }\\n                // Ascending from left to mid.\\n            } else if (nums[mid] > nums[right]) {\\n                // Look if number is in the left half.\\n                if (nums[left] <= target && target < nums[mid]) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }       \\n            } else {\\n                // nums[mid] == nums[right], move mid one to the left.\\n                // For instance, if we have\\n                // 2,3,4,5,1,1,1,1,1,1,1,1,1,1,1\\n                right--;\\n            }\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int left = 0, right = nums.size() - 1;\\n        \\n        // There are two scenarios. One where the array is rotated and one \\n        // where it is not.\\n\\t\\t\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) { // Obvious solution\\n                return true;\\n            // Ascending from mid to right.\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1016983,
                "title": "very-simplified-solution-binary-search",
                "content": "We can re-use the same solution that we used in [Search in a Rotated Sorted Array without Duplicates ](https://leetcode.com/problems/search-in-rotated-sorted-array/).\\n\\nWe need to add 1 extra check.\\n\\nWhen number at low, high and mid are all equal, then it\\'s not possible to correctly find out which side is sorted. \\nExample:    Input: [1,0,1,1,1] ,  0\\n                \\nSo we can do `low++` and `high--` and then reuse the same code.\\n\\n```\\n    bool search(vector<int>& nums, int target)\\n    {\\n        int l = 0, h = nums.size() - 1, mid;\\n        while(l <= h)\\n        {\\n            mid = (l + h)/2;\\n            if(target == nums[mid])\\n                return true;\\n            \\n            if(nums[l] == nums[mid] and nums[mid] == nums[h])\\n            {\\n                l++; h--;\\n                continue;\\n            }\\n            \\n            if(nums[l] <= nums[mid])               // left is sorted\\n            {\\n                if(nums[l] <= target and target < nums[mid])\\n                    h = mid - 1;\\n                else\\n                    l = mid + 1;\\n            }\\n            else                                   // right is sorted\\n            {\\n                if(nums[mid] < target and target <= nums[h])\\n                    l = mid + 1;\\n                else\\n                    h = mid - 1;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\n    bool search(vector<int>& nums, int target)\\n    {\\n        int l = 0, h = nums.size() - 1, mid;\\n        while(l <= h)\\n        {\\n            mid = (l + h)/2;\\n            if(target == nums[mid])\\n                return true;\\n            \\n            if(nums[l] == nums[mid] and nums[mid] == nums[h])\\n            {\\n                l++; h--;\\n                continue;\\n            }\\n            \\n            if(nums[l] <= nums[mid])               // left is sorted\\n            {\\n                if(nums[l] <= target and target < nums[mid])\\n                    h = mid - 1;\\n                else\\n                    l = mid + 1;\\n            }\\n            else                                   // right is sorted\\n            {\\n                if(nums[mid] < target and target <= nums[h])\\n                    l = mid + 1;\\n                else\\n                    h = mid - 1;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1529305,
                "title": "java-tc-o-n-2-sc-o-1-modified-binary-search-optimal-solution",
                "content": "```java\\n/**\\n * Modified binary search. This solution can handle duplicate values in input\\n * array.\\n *\\n * Time Complexity:\\n * Worst Case: O(N/2). If all nums are same and target is not equal to mid.\\n * This will reduce to log(N) in there are no duplicates\\n *\\n * Space Complexity: O(1)\\n *\\n * N = length of input array.\\n */\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        if (nums == null || nums.length == 0) {\\n            return false;\\n        }\\n\\n        int start = 0;\\n        int end = nums.length - 1;\\n\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n\\n            while (start < mid && nums[start] == nums[mid] && nums[end] == nums[mid]) {\\n                start++;\\n                end--;\\n            }\\n\\n            if (nums[start] <= nums[mid]) {\\n                // Left side is sorted. Right side is unsorted.\\n                if (target >= nums[start] && target < nums[mid]) {\\n                    end = mid - 1;\\n                } else {\\n                    start = mid + 1;\\n                }\\n            } else {\\n                // Left side is unsorted. Right side is sorted.\\n                if (target > nums[mid] && target <= nums[end]) {\\n                    start = mid + 1;\\n                } else {\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Rotated Sorted Array questions on LeetCode:\\n- [33. Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/1529302/Java-or-TC:-O(logN)-or-SC:-O(1)-or-Modified-Binary-Search-optimal-solution)\\n- [153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/discuss/1529313/Java-or-TC:-O(logN)-or-SC:-O(1)-or-Optimal-Binary-Search-with-Early-Exit)\\n- [154. Find Minimum in Rotated Sorted Array II + FollowUp](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/discuss/1529323/Java-or-TC:-O(N2)-or-SC:-O(1)-or-Optimal-Binary-Search-w-Early-Exit-and-FollowUp)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```java\\n/**\\n * Modified binary search. This solution can handle duplicate values in input\\n * array.\\n *\\n * Time Complexity:\\n * Worst Case: O(N/2). If all nums are same and target is not equal to mid.\\n * This will reduce to log(N) in there are no duplicates\\n *\\n * Space Complexity: O(1)\\n *\\n * N = length of input array.\\n */\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        if (nums == null || nums.length == 0) {\\n            return false;\\n        }\\n\\n        int start = 0;\\n        int end = nums.length - 1;\\n\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n\\n            while (start < mid && nums[start] == nums[mid] && nums[end] == nums[mid]) {\\n                start++;\\n                end--;\\n            }\\n\\n            if (nums[start] <= nums[mid]) {\\n                // Left side is sorted. Right side is unsorted.\\n                if (target >= nums[start] && target < nums[mid]) {\\n                    end = mid - 1;\\n                } else {\\n                    start = mid + 1;\\n                }\\n            } else {\\n                // Left side is unsorted. Right side is sorted.\\n                if (target > nums[mid] && target <= nums[end]) {\\n                    start = mid + 1;\\n                } else {\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 501689,
                "title": "javascript-solution-1-line-difference-between-q-33",
                "content": "### The idea\\n1. Because I\\'m using the left mid, I decide to check if the right part is sorted first. However, when have duplicates, the code will be confused because two numbers are equal. Thus, I check if `nums[mid]==nums[right]` to eliminate duplicate values\\n*Note that I really think every one writes Binary Search in their own styles.\\n``` javascript\\nvar search = function(nums, target) {\\n    let left = 0, right = nums.length - 1;\\n\\n    while (left < right) {\\n        let mid = left + parseInt((right - left) / 2); // lower mid\\n\\n        if (nums[mid] == nums[right]) right--; // the only difference between Q.33\\n        else if (nums[mid] < nums[right]) { // right part sorted\\n            if (target > nums[mid] && target <= nums[right]) left = mid + 1;\\n            else right = mid\\n        } else{\\n            if (target > nums[mid] || target < nums[left]) left = mid + 1;\\n            else right = mid;\\n        } \\n    }\\n    return nums[left]==target;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar search = function(nums, target) {\\n    let left = 0, right = nums.length - 1;\\n\\n    while (left < right) {\\n        let mid = left + parseInt((right - left) / 2); // lower mid\\n\\n        if (nums[mid] == nums[right]) right--; // the only difference between Q.33\\n        else if (nums[mid] < nums[right]) { // right part sorted\\n            if (target > nums[mid] && target <= nums[right]) left = mid + 1;\\n            else right = mid\\n        } else{\\n            if (target > nums[mid] || target < nums[left]) left = mid + 1;\\n            else right = mid;\\n        } \\n    }\\n    return nums[left]==target;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3519916,
                "title": "c-java-python-javascript-binary-search-intuition-approach-complexity-explained",
                "content": "# Intuition:\\nWe can use the binary search approach to solve this problem. The intuition is to determine which part of the array is sorted, and then check if the target element lies in that sorted part. If it does, then continue the search in that part of the array. If not, then continue the search in the other part of the array.\\n\\n# Approach:\\n1. Initialize the start and end indices to the first and last elements of the array, respectively.\\n2. Perform a binary search by repeatedly dividing the search space in half.\\n3. Calculate the middle index using the formula `mid = start + (end - start) / 2`.\\n4. Check if the target value is equal to the element at the middle index. If so, return true since the target is found.\\n5. Compare the element at the start index with the element at the middle index to determine if the left half is sorted or the right half is sorted.\\n   - If the left half is sorted, check if the target value lies within the range of the sorted left half (`nums[start] <= target < nums[mid]`). If it does, update the end index to `mid - 1` to search in the left half; otherwise, update the start index to `mid + 1` to search in the right half.\\n   - If the right half is sorted, check if the target value lies within the range of the sorted right half (`nums[mid] < target <= nums[end]`). If it does, update the start index to `mid + 1` to search in the right half; otherwise, update the end index to `mid - 1` to search in the left half.\\n6. If none of the above conditions are satisfied, it means there are duplicate elements at the start and middle indices. In this case, increment the start index by 1 and continue the search.\\n7. Repeat steps 3-6 until the start index is less than or equal to the end index.\\n8. If the target value is not found after the search, return false.\\n\\n# Complexity:\\n- Time Complexity: The time complexity of the binary search algorithm is O(log N), where N is the number of elements in the array.\\n- Space Complexity: The space complexity is O(1) since the algorithm uses a constant amount of additional space to store the indices and variables.\\n\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int start=0,end=nums.size()-1;\\n        while(start<=end){\\n            int mid = start + (end - start) / 2;\\n            if(target==nums[mid]){\\n                return true;\\n            }\\n            else if(nums[start]<nums[mid]){\\n                if(nums[start]<=target && nums[mid]>target){\\n                    end=mid-1;\\n                }\\n                else{\\n                    start=mid+1;\\n                }\\n            }\\n            else if(nums[mid] < nums[start]){\\n                if(nums[end]>=target && nums[mid]<target){\\n                    start=mid+1;\\n                }\\n                else{\\n                    end=mid-1;\\n                }\\n            } \\n            else {\\n                start += 1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n---\\n# JAVA\\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n\\n            if (target == nums[mid]) {\\n                return true;\\n            } else if (nums[start] < nums[mid]) {\\n                if (nums[start] <= target && nums[mid] > target) {\\n                    end = mid - 1;\\n                } else {\\n                    start = mid + 1;\\n                }\\n            } else if (nums[mid] < nums[start]) {\\n                if (nums[end] >= target && nums[mid] < target) {\\n                    start = mid + 1;\\n                } else {\\n                    end = mid - 1;\\n                }\\n            } else {\\n                start += 1;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```\\n\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def search(self, nums, target):\\n        start = 0\\n        end = len(nums) - 1\\n\\n        while start <= end:\\n            mid = start + (end - start) // 2\\n\\n            if target == nums[mid]:\\n                return True\\n            elif nums[start] < nums[mid]:\\n                if nums[start] <= target and nums[mid] > target:\\n                    end = mid - 1\\n                else:\\n                    start = mid + 1\\n            elif nums[mid] < nums[start]:\\n                if nums[end] >= target and nums[mid] < target:\\n                    start = mid + 1\\n                else:\\n                    end = mid - 1\\n            else:\\n                start += 1\\n\\n        return False\\n\\n```\\n\\n---\\n\\n# JavaScript\\n```\\nvar search = function(nums, target) {\\n    let start = 0;\\n    let end = nums.length - 1;\\n    \\n    while (start <= end) {\\n        let mid = start + Math.floor((end - start) / 2);\\n        if (target === nums[mid]) {\\n            return true;\\n        } else if (nums[start] < nums[mid]) {\\n            if (nums[start] <= target && nums[mid] > target) {\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        } else if (nums[mid] < nums[start]) {\\n            if (nums[end] >= target && nums[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        } else {\\n            start += 1;\\n        }\\n    }\\n\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int start=0,end=nums.size()-1;\\n        while(start<=end){\\n            int mid = start + (end - start) / 2;\\n            if(target==nums[mid]){\\n                return true;\\n            }\\n            else if(nums[start]<nums[mid]){\\n                if(nums[start]<=target && nums[mid]>target){\\n                    end=mid-1;\\n                }\\n                else{\\n                    start=mid+1;\\n                }\\n            }\\n            else if(nums[mid] < nums[start]){\\n                if(nums[end]>=target && nums[mid]<target){\\n                    start=mid+1;\\n                }\\n                else{\\n                    end=mid-1;\\n                }\\n            } \\n            else {\\n                start += 1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n\\n            if (target == nums[mid]) {\\n                return true;\\n            } else if (nums[start] < nums[mid]) {\\n                if (nums[start] <= target && nums[mid] > target) {\\n                    end = mid - 1;\\n                } else {\\n                    start = mid + 1;\\n                }\\n            } else if (nums[mid] < nums[start]) {\\n                if (nums[end] >= target && nums[mid] < target) {\\n                    start = mid + 1;\\n                } else {\\n                    end = mid - 1;\\n                }\\n            } else {\\n                start += 1;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def search(self, nums, target):\\n        start = 0\\n        end = len(nums) - 1\\n\\n        while start <= end:\\n            mid = start + (end - start) // 2\\n\\n            if target == nums[mid]:\\n                return True\\n            elif nums[start] < nums[mid]:\\n                if nums[start] <= target and nums[mid] > target:\\n                    end = mid - 1\\n                else:\\n                    start = mid + 1\\n            elif nums[mid] < nums[start]:\\n                if nums[end] >= target and nums[mid] < target:\\n                    start = mid + 1\\n                else:\\n                    end = mid - 1\\n            else:\\n                start += 1\\n\\n        return False\\n\\n```\n```\\nvar search = function(nums, target) {\\n    let start = 0;\\n    let end = nums.length - 1;\\n    \\n    while (start <= end) {\\n        let mid = start + Math.floor((end - start) / 2);\\n        if (target === nums[mid]) {\\n            return true;\\n        } else if (nums[start] < nums[mid]) {\\n            if (nums[start] <= target && nums[mid] > target) {\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        } else if (nums[mid] < nums[start]) {\\n            if (nums[end] >= target && nums[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        } else {\\n            start += 1;\\n        }\\n    }\\n\\n    return false;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208799,
                "title": "easy-c-100-fastest-same-soln-to-33-search-rotated-array-without-duplicates",
                "content": "//Silimar to solution to problem 33\\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/discuss/1208600/Easy-C%2B%2B-2-Solnoror-Binary-Search-oror-With-pivot-and-without-pivot\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int i=0,j=nums.size()-1;\\n        while(i<=j){\\n            //avoid duplicates\\n            while(i<j && nums[i]==nums[i+1])i++;\\n            while(j>i && nums[j]==nums[j-1])j--;\\n            //use same technique as used in rotated array\\n            int m=(i+j)/2;\\n            if(nums[m]==target)return true;\\n            if(nums[m]>=nums[i]){\\n                if(target>=nums[i] && target<nums[m])j=m-1;\\n                else i=m+1;\\n            }\\n            else{\\n                if(target<=nums[j] && target>nums[m])i=m+1;\\n                else j=m-1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int i=0,j=nums.size()-1;\\n        while(i<=j){\\n            //avoid duplicates\\n            while(i<j && nums[i]==nums[i+1])i++;\\n            while(j>i && nums[j]==nums[j-1])j--;\\n            //use same technique as used in rotated array\\n            int m=(i+j)/2;\\n            if(nums[m]==target)return true;\\n            if(nums[m]>=nums[i]){\\n                if(target>=nums[i] && target<nums[m])j=m-1;\\n                else i=m+1;\\n            }\\n            else{\\n                if(target<=nums[j] && target>nums[m])i=m+1;\\n                else j=m-1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1336563,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int low = 0,high=nums.length-1;\\n        while(low <= high)\\n        {\\n            int mid = low+(high-low)/2;\\n            if(nums[mid] == target)\\n                return true;\\n            if(nums[mid] == nums[low])\\n                low++;\\n            else if(nums[low] < nums[mid])\\n            {\\n                if(target >= nums[low] && target < nums[mid])\\n                    high = mid-1;\\n                else low = mid+1;\\n            }\\n            else\\n            {\\n                if(target > nums[mid] && target <= nums[high])\\n                    low = mid+1;\\n                else    high = mid-1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int low = 0,high=nums.length-1;\\n        while(low <= high)\\n        {\\n            int mid = low+(high-low)/2;\\n            if(nums[mid] == target)\\n                return true;\\n            if(nums[mid] == nums[low])\\n                low++;\\n            else if(nums[low] < nums[mid])\\n            {\\n                if(target >= nums[low] && target < nums[mid])\\n                    high = mid-1;\\n                else low = mid+1;\\n            }\\n            else\\n            {\\n                if(target > nums[mid] && target <= nums[high])\\n                    low = mid+1;\\n                else    high = mid-1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918879,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of nums.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func search(_ nums: [Int], _ target: Int) -> Bool {\\n        guard !nums.isEmpty else { return false }\\n\\n        var start = 0\\n        var end = nums.count - 1\\n\\n        while start <= end {\\n            let mid = start + (end - start) / 2\\n\\n            guard nums[mid] != target else { return true }\\n\\n            if nums[start] == nums[mid], nums[end] == nums[mid] {\\n                start += 1\\n                end -= 1\\n            } else if nums[start] <= nums[mid] {\\n                if nums[start] <= target, target < nums[mid] {\\n                    end = mid - 1\\n                } else {\\n                    start = mid + 1\\n                }\\n            } else {\\n                if nums[mid] < target, target <= nums[end] {\\n                    start = mid + 1\\n                } else {\\n                    end = mid - 1\\n                }\\n            }\\n        }\\n\\n        return false\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of nums.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func search(_ nums: [Int], _ target: Int) -> Bool {\\n        guard !nums.isEmpty else { return false }\\n\\n        var start = 0\\n        var end = nums.count - 1\\n\\n        while start <= end {\\n            let mid = start + (end - start) / 2\\n\\n            guard nums[mid] != target else { return true }\\n\\n            if nums[start] == nums[mid], nums[end] == nums[mid] {\\n                start += 1\\n                end -= 1\\n            } else if nums[start] <= nums[mid] {\\n                if nums[start] <= target, target < nums[mid] {\\n                    end = mid - 1\\n                } else {\\n                    start = mid + 1\\n                }\\n            } else {\\n                if nums[mid] < target, target <= nums[end] {\\n                    start = mid + 1\\n                } else {\\n                    end = mid - 1\\n                }\\n            }\\n        }\\n\\n        return false\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735687,
                "title": "python-binary-search-with-explanation",
                "content": "```\\nclass Solution:\\n    \\n    def search(self, nums: List[int], target: int) -> bool:\\n        \\n        if not nums: ## array is None so element can\\'t be found\\n            return 0\\n        \\n        low = 0\\n        high = len(nums)-1 ## initialise the low and the high variables for BS\\n        \\n        while low<high:\\n\\n            mid = (low+high)//2\\n            \\n            if nums[mid] == target or nums[low]==target or nums[high]==target: \\n                return 1 ## checking for a match of target on each of the three pointer \\n            \\n            if nums[mid]<nums[high]: \\n\\t\\t\\t\\n\\t\\t\\t\\'\\'\\'\\n\\t\\t\\tconsider the case of [2,5,6,0,0,1,2] and target = 1\\n\\t\\t\\tHere high = 6, low = 0 and mid = 3.\\n\\t\\t\\tso nums[mid]<nums[high]\\n\\t\\t\\t\\'\\'\\'\\n                ## now we should check whether the target lies between \\n\\t\\t\\t\\t## mid and high or not. If yes, then shift low to the value next to mid.\\n                if nums[mid]<target<=nums[high]:  \\n\\t\\t\\t\\t\\n                    low = mid+1\\n                \\n                else:\\n\\t\\t\\t\\t## otherwise the value should be in the previous part. \\n\\t\\t\\t\\t## Consider the value of target = 5 in the above example to understand better. \\n                    high = mid-1\\n                       \\n            elif nums[mid]>nums[high]:\\n                \\'\\'\\'\\n\\t\\t\\t\\tTo understand this part, consider the following case:\\n\\t\\t\\t\\tnums = [0,0,1,1,2,0] and target = 0\\n\\t\\t\\t\\tlow = 0, high = 5 and mid = 2\\n\\t\\t\\t\\tnums[mid]>nums[high]\\n\\t\\t\\t\\t\\'\\'\\'\\n\\t\\t\\t\\t\\n                if nums[low] <= target < nums[mid]:\\n\\t\\t\\t\\t## if the value of target is in between low and high, the shift high to mid-1. \\n\\t\\t\\t\\t## Like in the example above\\n                    \\n                    high = mid-1\\n                else:\\n\\t\\t\\t\\t## Otherwise shift the value of low to mid +1. \\n\\t\\t\\t\\t## Consider target =2 in the above example to understand better.\\n                    low = mid+1\\n                \\n            else:\\n                \\'\\'\\'\\n\\t\\t\\t\\tThis will execute when nums[mid] and nums[high] are same.\\n\\t\\t\\t\\tFor e.g: \\n\\t\\t\\t\\tnums=[2,2,2,2,3,4,5,2] and target = 4\\n\\t\\t\\t\\there, low = 0, high = 7 and mid = 3\\n\\t\\t\\t\\tnums[mid] = nums[high] and thus we can\\'t be certain about which direction to go. \\n\\t\\t\\t\\tBut one thing is sure, the value is definitely not at the high position.\\n\\t\\t\\t\\tSo just decrease the value of high pointer\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\'\\'\\'\\n\\t\\t\\t\\t\\n                high-=1\\n                            \\n        if nums[low] == target:\\n            return 1\\n        \\n        return 0\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def search(self, nums: List[int], target: int) -> bool:\\n        \\n        if not nums: ## array is None so element can\\'t be found\\n            return 0\\n        \\n        low = 0\\n        high = len(nums)-1 ## initialise the low and the high variables for BS\\n        \\n        while low<high:\\n\\n            mid = (low+high)//2\\n            \\n            if nums[mid] == target or nums[low]==target or nums[high]==target: \\n                return 1 ## checking for a match of target on each of the three pointer \\n            \\n            if nums[mid]<nums[high]: \\n\\t\\t\\t\\n\\t\\t\\t\\'\\'\\'\\n\\t\\t\\tconsider the case of [2,5,6,0,0,1,2] and target = 1\\n\\t\\t\\tHere high = 6, low = 0 and mid = 3.\\n\\t\\t\\tso nums[mid]<nums[high]\\n\\t\\t\\t\\'\\'\\'\\n                ## now we should check whether the target lies between \\n\\t\\t\\t\\t## mid and high or not. If yes, then shift low to the value next to mid.\\n                if nums[mid]<target<=nums[high]:  \\n\\t\\t\\t\\t\\n                    low = mid+1\\n                \\n                else:\\n\\t\\t\\t\\t## otherwise the value should be in the previous part. \\n\\t\\t\\t\\t## Consider the value of target = 5 in the above example to understand better. \\n                    high = mid-1\\n                       \\n            elif nums[mid]>nums[high]:\\n                \\'\\'\\'\\n\\t\\t\\t\\tTo understand this part, consider the following case:\\n\\t\\t\\t\\tnums = [0,0,1,1,2,0] and target = 0\\n\\t\\t\\t\\tlow = 0, high = 5 and mid = 2\\n\\t\\t\\t\\tnums[mid]>nums[high]\\n\\t\\t\\t\\t\\'\\'\\'\\n\\t\\t\\t\\t\\n                if nums[low] <= target < nums[mid]:\\n\\t\\t\\t\\t## if the value of target is in between low and high, the shift high to mid-1. \\n\\t\\t\\t\\t## Like in the example above\\n                    \\n                    high = mid-1\\n                else:\\n\\t\\t\\t\\t## Otherwise shift the value of low to mid +1. \\n\\t\\t\\t\\t## Consider target =2 in the above example to understand better.\\n                    low = mid+1\\n                \\n            else:\\n                \\'\\'\\'\\n\\t\\t\\t\\tThis will execute when nums[mid] and nums[high] are same.\\n\\t\\t\\t\\tFor e.g: \\n\\t\\t\\t\\tnums=[2,2,2,2,3,4,5,2] and target = 4\\n\\t\\t\\t\\there, low = 0, high = 7 and mid = 3\\n\\t\\t\\t\\tnums[mid] = nums[high] and thus we can\\'t be certain about which direction to go. \\n\\t\\t\\t\\tBut one thing is sure, the value is definitely not at the high position.\\n\\t\\t\\t\\tSo just decrease the value of high pointer\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\'\\'\\'\\n\\t\\t\\t\\t\\n                high-=1\\n                            \\n        if nums[low] == target:\\n            return 1\\n        \\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866781,
                "title": "binary-search-template-solution-intuition-explained-in-detail-video-solution",
                "content": "# Intuition\\nhey every one, i have made video playlist for binary search where i discuss a template solution and intuition behind it, this template solution will be very useful as this will help you solve many other questions in binary search, this question is the part of that playlist:\\n\\nhttps://youtu.be/vLzErDM5d-w\\n\\nPlaylist link: \\nhttps://youtube.com/playlist?list=PLICVjZ3X1AcYYdde4GTp79zfdp_VACSkX\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n bool predicate(int mid,vector<int>& nums, int target){\\n        int val;\\n        if(target< nums[0] == nums[mid]<nums[0]){\\n            val=nums[mid];\\n        }\\n        else{\\n            if(target<nums[0]){\\n                val=INT_MIN;\\n            }\\n            else{\\n                val=INT_MAX;\\n            }\\n        }\\n        return val>=target;\\n\\n    }\\n    bool search(vector<int>& nums, int target) {\\n       \\n        int left=0;\\n        int right=nums.size()-1;\\n        while(left<right){\\n\\n            while(left<right && nums[left]==nums[left+1]){\\n                left++;\\n            }\\n            while(left<right && nums[right]==nums[right-1]){\\n                right--;\\n            }\\n            int mid= left+ (right-left)/2;\\n            \\n\\n            if(predicate(mid,nums,target)){\\n                right=mid;\\n            }\\n            else{\\n                if(left<nums.size()-1)\\n                left=mid+1;\\n            }\\n        }\\n        return nums[left]==target ? true:false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n bool predicate(int mid,vector<int>& nums, int target){\\n        int val;\\n        if(target< nums[0] == nums[mid]<nums[0]){\\n            val=nums[mid];\\n        }\\n        else{\\n            if(target<nums[0]){\\n                val=INT_MIN;\\n            }\\n            else{\\n                val=INT_MAX;\\n            }\\n        }\\n        return val>=target;\\n\\n    }\\n    bool search(vector<int>& nums, int target) {\\n       \\n        int left=0;\\n        int right=nums.size()-1;\\n        while(left<right){\\n\\n            while(left<right && nums[left]==nums[left+1]){\\n                left++;\\n            }\\n            while(left<right && nums[right]==nums[right-1]){\\n                right--;\\n            }\\n            int mid= left+ (right-left)/2;\\n            \\n\\n            if(predicate(mid,nums,target)){\\n                right=mid;\\n            }\\n            else{\\n                if(left<nums.size()-1)\\n                left=mid+1;\\n            }\\n        }\\n        return nums[left]==target ? true:false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28272,
                "title": "simple-c-solution-explained",
                "content": "To see more details about the thought process, please go to my other [post][1]. The only difference here comparing to \"[33. Search in Rotated Sorted Array(Hard)][2]\" is to add a separate condition check for nums[mid] == nums[r], because here we can't decide which side to take, only knowing that nums[r] is not equal to target, so move r to the left one step at a time, which may potentially cause the runtime to go linear which may answer the follow up question.\\n\\n    class Solution {\\n    public:\\n        bool search(vector<int>& nums, int target) {\\n            int l = 0, r = nums.size() - 1;        \\n            while(l <= r){  \\n                int mid = l + (r - l) / 2;            \\n                if(nums[mid] == target) return true;\\n                if(nums[mid] > nums[r]){\\n                    if(target > nums[mid] || target <= nums[r]) l = mid + 1;    \\n                    else r = mid - 1;                                                               \\n                }else if(nums[mid] == nums[r]){\\n                    r --;   // may cause linear time here, e.g. [7, 8, 9, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], search for 0\\n                }\\n                else{\\n                    if(target <= nums[r] && target > nums[mid]) l = mid + 1; \\n                    else r = mid - 1;                                                               \\n                }\\n            }\\n            return false;        \\n        }\\n    };\\n\\n\\n  [1]: https://leetcode.com/discuss/94276/simple-concise-solution-detailed-explanation-thought-process\\n  [2]: https://leetcode.com/problems/search-in-rotated-sorted-array/",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool search(vector<int>& nums, int target) {\\n            int l = 0, r = nums.size() - 1;        \\n            while(l <= r){  \\n                int mid = l + (r - l) / 2;            \\n                if(nums[mid] == target) return true;\\n                if(nums[mid] > nums[r]){\\n                    if(target > nums[mid] || target <= nums[r]) l = mid + 1;    \\n                    else r = mid - 1;                                                               \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 28286,
                "title": "java-solution-with-comments",
                "content": "    public boolean search(int[] A, int target) {\\n        int start = 0;\\n        int end = A.length - 1;\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if (A[mid] == target) // case 0\\n                return true;\\n            // finally start == mid == end, if case 0, return true, else end the loop\\n            else if (A[start] == A[mid])\\n                start++;\\n            else if (A[end] == A[mid])\\n                end--;\\n            else if (A[start] <= target && target <= A[mid]) // case 1\\n                end = mid;\\n            else if (A[mid] < target && target <= A[end]) // case 2\\n                start = mid + 1;\\n            else if (A[start] > A[mid]) // case 2 is false, so target in this range\\n                end = mid;\\n            else   // case A[mid] > A[end] and case 1 is false, similar to above\\n                start = mid + 1;\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "    public boolean search(int[] A, int target) {\\n        int start = 0;\\n        int end = A.length - 1;\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if (A[mid] == target) // case 0\\n                return true;\\n            // finally start == mid == end, if case 0, return true, else end the loop\\n            else if (A[start] == A[mid])\\n                start++;\\n            else if (A[end] == A[mid])\\n                end--;\\n            else if (A[start] <= target && target <= A[mid]) // case 1\\n                end = mid;\\n            else if (A[mid] < target && target <= A[end]) // case 2\\n                start = mid + 1;\\n            else if (A[start] > A[mid]) // case 2 is false, so target in this range\\n                end = mid;\\n            else   // case A[mid] > A[end] and case 1 is false, similar to above\\n                start = mid + 1;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3892127,
                "title": "ex-amazon-explains-a-solution-with-a-video-python-javascript-java-and-c",
                "content": "# Intuition\\nUsing modified binary search and add a few conditions before narrow the searching range.\\n\\n---\\n\\n# Solution Video\\n## *** Please upvote for this article. *** \\n# Subscribe to my channel from here. I have 243 videos as of August 10th\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nhttps://youtu.be/mIa0uYBA85s\\n\\n---\\n\\n# Related video\\n- Search in Rotated Sorted Array\\n\\nhttps://youtu.be/5QDw0rNVlcE\\n\\n# Approach\\nThis is based on Python. Other might be different a bit.\\n\\n1. Initialize `left` to 0 (representing the left boundary of the search range) and `right` to the length of `nums` minus 1 (representing the right boundary of the search range).\\n\\n2. Enter a `while` loop that continues as long as `left` is less than or equal to `right`.\\n\\n3. Calculate the midpoint `mid` using integer division (`//`) of the sum of `left` and `right`.\\n\\n4. Check if the element at the midpoint `nums[mid]` is equal to the target value. If it is, return `True` since the target has been found.\\n\\n5. Check if the element at the midpoint `nums[mid]` is equal to the element at the left boundary `nums[left]`. If they are equal, it means we have duplicate values at the left and mid positions. Increment `left` by 1 to skip duplicates and continue to the next iteration using the `continue` statement.\\n\\n6. If the conditions in steps 4 and 5 were not satisfied, then there are no duplicates at the mid position and the target value was not found. We need to decide whether the target could be in the left or right subarray based on the properties of the rotated sorted array.\\n\\n7. Check if the subarray from `left` to `mid` is sorted (i.e., `nums[left] <= nums[mid]`). If it is, then check whether the target lies within this sorted subarray (`nums[left] <= target < nums[mid]`). If this condition holds, adjust the `right` boundary to `mid - 1` to search the left half, otherwise, adjust the `left` boundary to `mid + 1` to search the right half.\\n\\n8. If the subarray from `left` to `mid` is not sorted, it implies that the rotated part is on the left side of `mid`. In this case, check whether the target lies within the subarray to the right of `mid` (`nums[mid] < target <= nums[right]`). If this condition holds, adjust the `left` boundary to `mid + 1` to search the right half, otherwise, adjust the `right` boundary to `mid - 1` to search the left half.\\n\\n9. Repeat steps 3 to 8 until the `left` boundary is no longer less than or equal to the `right` boundary, indicating that the search space is exhausted.\\n\\n10. If the target value was not found during the entire search, return `False`.\\n\\nIn summary, this algorithm performs a modified binary search on a rotated sorted array with possible duplicates. It efficiently narrows down the search range based on comparisons with the target value and the properties of the array.\\n\\n# Complexity\\n- Time complexity: O(log n)\\nBut if you get an input list like [1,1,1,1,1,1,1,1] target = 3, this condition(if nums[mid] == nums[left]:) is always `True`. In that case, time complexity should be O(n) because we narrow the searching range one by one.\\n\\n- Space complexity: O(1)\\n\\n\\n```python []\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        left, right = 0, len(nums) - 1\\n        \\n        while left <= right:\\n            mid = (left + right) // 2\\n            \\n            if nums[mid] == target:\\n                return True\\n            \\n            if nums[mid] == nums[left]:\\n                left += 1\\n                continue\\n\\n            if nums[left] <= nums[mid]:\\n                if nums[left] <= target < nums[mid]:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n            else:\\n                if nums[mid] < target <= nums[right]:\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n        \\n        return False\\n```\\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar search = function(nums, target) {\\n    let left = 0;\\n    let right = nums.length - 1;\\n    \\n    while (left <= right) {\\n        let mid = Math.floor((left + right) / 2);\\n        \\n        if (nums[mid] === target) {\\n            return true;\\n        }\\n        \\n        if (nums[mid] === nums[left]) {\\n            left++;\\n            continue;\\n        }\\n        \\n        if (nums[left] <= nums[mid]) {\\n            if (nums[left] <= target && target < nums[mid]) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        } else {\\n            if (nums[mid] < target && target <= nums[right]) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n    }\\n    \\n    return false;    \\n};\\n```\\n```java []\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n        \\n        while (left <= right) {\\n            int mid = (left + right) / 2;\\n            \\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n            \\n            if (nums[mid] == nums[left]) {\\n                left++;\\n                continue;\\n            }\\n            \\n            if (nums[left] <= nums[mid]) {\\n                if (nums[left] <= target && target < nums[mid]) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[right]) {\\n                    left = mid + 1;\\n                } else {\\n                    right = mid - 1;\\n                }\\n            }\\n        }\\n        \\n        return false;        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int left = 0;\\n        int right = nums.size() - 1;\\n        \\n        while (left <= right) {\\n            int mid = (left + right) / 2;\\n            \\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n            \\n            if (nums[mid] == nums[left]) {\\n                left++;\\n                continue;\\n            }\\n            \\n            if (nums[left] <= nums[mid]) {\\n                if (nums[left] <= target && target < nums[mid]) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[right]) {\\n                    left = mid + 1;\\n                } else {\\n                    right = mid - 1;\\n                }\\n            }\\n        }\\n        \\n        return false;        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        left, right = 0, len(nums) - 1\\n        \\n        while left <= right:\\n            mid = (left + right) // 2\\n            \\n            if nums[mid] == target:\\n                return True\\n            \\n            if nums[mid] == nums[left]:\\n                left += 1\\n                continue\\n\\n            if nums[left] <= nums[mid]:\\n                if nums[left] <= target < nums[mid]:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n            else:\\n                if nums[mid] < target <= nums[right]:\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n        \\n        return False\\n```\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar search = function(nums, target) {\\n    let left = 0;\\n    let right = nums.length - 1;\\n    \\n    while (left <= right) {\\n        let mid = Math.floor((left + right) / 2);\\n        \\n        if (nums[mid] === target) {\\n            return true;\\n        }\\n        \\n        if (nums[mid] === nums[left]) {\\n            left++;\\n            continue;\\n        }\\n        \\n        if (nums[left] <= nums[mid]) {\\n            if (nums[left] <= target && target < nums[mid]) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        } else {\\n            if (nums[mid] < target && target <= nums[right]) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n    }\\n    \\n    return false;    \\n};\\n```\n```java []\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n        \\n        while (left <= right) {\\n            int mid = (left + right) / 2;\\n            \\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n            \\n            if (nums[mid] == nums[left]) {\\n                left++;\\n                continue;\\n            }\\n            \\n            if (nums[left] <= nums[mid]) {\\n                if (nums[left] <= target && target < nums[mid]) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[right]) {\\n                    left = mid + 1;\\n                } else {\\n                    right = mid - 1;\\n                }\\n            }\\n        }\\n        \\n        return false;        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int left = 0;\\n        int right = nums.size() - 1;\\n        \\n        while (left <= right) {\\n            int mid = (left + right) / 2;\\n            \\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n            \\n            if (nums[mid] == nums[left]) {\\n                left++;\\n                continue;\\n            }\\n            \\n            if (nums[left] <= nums[mid]) {\\n                if (nums[left] <= target && target < nums[mid]) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[right]) {\\n                    left = mid + 1;\\n                } else {\\n                    right = mid - 1;\\n                }\\n            }\\n        }\\n        \\n        return false;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888902,
                "title": "c-binary-search-day-10",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& v, int target) {\\n        int i=0,j=v.size()-1;\\n        while(i<=j){\\n            int m = (i+j)/2;\\n            if(v[m]==target)return true;\\n            if(v[i]==v[m] && v[m]==v[j]){\\n                i++;\\n                j--;\\n                continue;\\n            }\\n            if(v[m]>=v[i]){\\n                if(v[i]<= target && target<=v[m])j=m-1;\\n                else i = m+1;\\n            }\\n            else {\\n                 if(v[j]>= target && target >= v[m])i=m+1;\\n                else j = m-1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/6bfadae6-6858-431d-9c2c-641b25b99459_1691644369.1045384.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& v, int target) {\\n        int i=0,j=v.size()-1;\\n        while(i<=j){\\n            int m = (i+j)/2;\\n            if(v[m]==target)return true;\\n            if(v[i]==v[m] && v[m]==v[j]){\\n                i++;\\n                j--;\\n                continue;\\n            }\\n            if(v[m]>=v[i]){\\n                if(v[i]<= target && target<=v[m])j=m-1;\\n                else i = m+1;\\n            }\\n            else {\\n                 if(v[j]>= target && target >= v[m])i=m+1;\\n                else j = m-1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892086,
                "title": "easy-java-solution-close-to-binary-search",
                "content": "```\\nclass Solution {\\n  public boolean search(int[] nums, int target) {\\n    int start = 0;\\n    int end = nums.length - 1;\\n    \\n    while(start <= end) {\\n      int mid = end + (start - end) / 2;\\n\\t  // Do 3 comparisons\\n      if (nums[mid] == target || nums[start] == target || nums[end] == target) {\\n        return true;\\n      }\\n      \\n      if (target > nums[mid] && target < nums[end]) {\\n\\t    // target on right\\n        start = mid+1;\\n      } else if (target < nums[mid] && target > nums[start]) {\\n        // target on left\\n        end = mid - 1;\\n      } else {\\n        // Equal case\\n        ++start;\\n        --end;\\n      }\\n    }\\n    \\n    return false;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n  public boolean search(int[] nums, int target) {\\n    int start = 0;\\n    int end = nums.length - 1;\\n    \\n    while(start <= end) {\\n      int mid = end + (start - end) / 2;\\n\\t  // Do 3 comparisons\\n      if (nums[mid] == target || nums[start] == target || nums[end] == target) {\\n        return true;\\n      }\\n      \\n      if (target > nums[mid] && target < nums[end]) {\\n\\t    // target on right\\n        start = mid+1;\\n      } else if (target < nums[mid] && target > nums[start]) {\\n        // target on left\\n        end = mid - 1;\\n      } else {\\n        // Equal case\\n        ++start;\\n        --end;\\n      }\\n    }\\n    \\n    return false;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1891836,
                "title": "4-ms-c-binary-search",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool search(vector<int>& nums, int target) {\\n\\t\\tint lo=0;\\n\\t\\tint hi=nums.size()-1;\\n\\t\\twhile(lo<=hi)\\n\\t\\t{\\n\\t\\t\\tint mid=lo+(hi-lo)/2;\\n\\t\\t\\tif(nums[mid]==target) return true;\\n\\t\\t\\t//for test case like [1,0,1,1,1] i.e. same elements at mid,lo,hi\\n\\t\\t\\tif((nums[lo]==nums[mid])&&(nums[hi]==nums[mid]))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlo++;\\n\\t\\t\\t\\t\\thi--;\\n\\t\\t\\t\\t}\\n\\t\\t\\telse if(nums[mid]>=nums[lo])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(target<=nums[mid] and target>=nums[lo])\\n\\n\\t\\t\\t\\t\\thi=mid-1;\\n\\n\\t\\t\\t\\telse\\n\\n\\t\\t\\t\\t\\tlo=mid+1;\\n\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(target>=nums[mid] and target<=nums[hi])\\n\\n\\t\\t\\t\\t\\tlo=mid+1;\\n\\n\\t\\t\\t\\telse\\n\\n\\t\\t\\t\\t\\thi=mid-1;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool search(vector<int>& nums, int target) {\\n\\t\\tint lo=0;\\n\\t\\tint hi=nums.size()-1;\\n\\t\\twhile(lo<=hi)\\n\\t\\t{\\n\\t\\t\\tint mid=lo+(hi-lo)/2;\\n\\t\\t\\tif(nums[mid]==target) return true;\\n\\t\\t\\t//for test case like [1,0,1,1,1] i.e. same elements at mid,lo,hi\\n\\t\\t\\tif((nums[lo]==nums[mid])&&(nums[hi]==nums[mid]))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlo++;\\n\\t\\t\\t\\t\\thi--;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1238238,
                "title": "c-binary-search-after-finding-pivot-easy-comments-added",
                "content": "```\\nclass Solution {\\npublic:\\n    int pivot(vector<int>& nums, int l, int r) {\\n        while(l < r) {\\n            \\n            while(l < r && nums[l] == nums[l+1])\\n                l++;\\n            \\n            while(r > l && nums[r] == nums[r-1])\\n                r--;\\n            \\n            /*\\n                You need to do what I did above because you\\'ll fail in case like\\n                [1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]\\n                2\\n                Here, the nums[mid] <= nums[r] and\\n                and we will cut down the right half but our pivot lies there\\n                So, make it a RULE, whenever there are duplicate elements and you need to to something\\n                like Binary Search, you need to ignore duplicates like done above\\n                Similar Qn : \"Smallest element in a rotated sorted array with duplicates\"\\n            */\\n            int mid = l + (r-l)/2;\\n            \\n            if(nums[mid] < nums[r]) { //sorted part\\n                r = mid; //possibly my pivot\\n            } else {\\n                l = mid+1;\\n            }\\n        }\\n        \\n        return r;\\n    }\\n    \\n    bool binarySearch(vector<int>& nums, int l, int r, int& target) {\\n        while(l <= r) {\\n            int mid = l + (r-l)/2;\\n            \\n            if(nums[mid] == target)\\n                return true;\\n            \\n            if(nums[mid] < target)\\n                l = mid+1;\\n            else\\n                r = mid-1;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        \\n        \\n        int p = pivot(nums, 0 , n-1);\\n        cout <<\"p = \" << p << endl;\\n        if(binarySearch(nums, 0, p-1, target)) {\\n            return true;\\n        }\\n        \\n        return binarySearch(nums, p, n-1, target);\\n            \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivot(vector<int>& nums, int l, int r) {\\n        while(l < r) {\\n            \\n            while(l < r && nums[l] == nums[l+1])\\n                l++;\\n            \\n            while(r > l && nums[r] == nums[r-1])\\n                r--;\\n            \\n            /*\\n                You need to do what I did above because you\\'ll fail in case like\\n                [1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]\\n                2\\n                Here, the nums[mid] <= nums[r] and\\n                and we will cut down the right half but our pivot lies there\\n                So, make it a RULE, whenever there are duplicate elements and you need to to something\\n                like Binary Search, you need to ignore duplicates like done above\\n                Similar Qn : \"Smallest element in a rotated sorted array with duplicates\"\\n            */\\n            int mid = l + (r-l)/2;\\n            \\n            if(nums[mid] < nums[r]) { //sorted part\\n                r = mid; //possibly my pivot\\n            } else {\\n                l = mid+1;\\n            }\\n        }\\n        \\n        return r;\\n    }\\n    \\n    bool binarySearch(vector<int>& nums, int l, int r, int& target) {\\n        while(l <= r) {\\n            int mid = l + (r-l)/2;\\n            \\n            if(nums[mid] == target)\\n                return true;\\n            \\n            if(nums[mid] < target)\\n                l = mid+1;\\n            else\\n                r = mid-1;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        \\n        \\n        int p = pivot(nums, 0 , n-1);\\n        cout <<\"p = \" << p << endl;\\n        if(binarySearch(nums, 0, p-1, target)) {\\n            return true;\\n        }\\n        \\n        return binarySearch(nums, p, n-1, target);\\n            \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 950897,
                "title": "python-solution-99-90",
                "content": "```\\nleft,right = 0,len(nums)-1\\nwhile left <=  right:\\n\\tmid = (left+right) // 2\\n\\tif nums[mid] == target:\\n\\t\\treturn True\\n\\tif nums[left] <= nums[mid]:\\n\\t\\tif nums[left] == nums[mid] and mid != left:\\n\\t\\t\\tleft+=1\\n\\t\\t\\tcontinue\\n\\t\\tif nums[left] <= target< nums[mid]:\\n\\t\\t\\tright = mid-1\\n\\t\\telse: left = mid+1\\n\\telif nums[left] > nums[mid]:\\n\\t\\tif nums[mid] < target <= nums[right]:\\n\\t\\t\\tleft = mid+1\\n\\t\\telse: right = mid-1\\nreturn False\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nleft,right = 0,len(nums)-1\\nwhile left <=  right:\\n\\tmid = (left+right) // 2\\n\\tif nums[mid] == target:\\n\\t\\treturn True\\n\\tif nums[left] <= nums[mid]:\\n\\t\\tif nums[left] == nums[mid] and mid != left:\\n\\t\\t\\tleft+=1\\n\\t\\t\\tcontinue\\n\\t\\tif nums[left] <= target< nums[mid]:\\n\\t\\t\\tright = mid-1\\n\\t\\telse: left = mid+1\\n\\telif nums[left] > nums[mid]:\\n\\t\\tif nums[mid] < target <= nums[right]:\\n\\t\\t\\tleft = mid+1\\n\\t\\telse: right = mid-1\\nreturn False\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 761906,
                "title": "simple-java-code-0ms-modified-binary-search",
                "content": "This is a simple modification of original search in rotated array solution posted [here](https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/761875/Simple-Solution-with-binary-search-and-partition-O(log-N)).\\n\\n- Worst case scenario: If all the elements are duplicate and the element is not present; runtime will be O(n).\\n- Best case scenario: No duplicate elements; while loops to move start and end are not run; runtime will be O(logN).\\n\\n```\\nclass Solution {\\n    public boolean search(int[] a, int t) {\\n        int s = 0;\\n        int e = a.length - 1;\\n        \\n        while(s <= e) {\\n            // reach end of duplicates from start\\n            while ((s+1 <= e) && (a[s] == a[s+1])) {\\n                s++;\\n            }\\n            \\n            // reach end of duplicates from end\\n            while ((s <= e-1) && (a[e] == a[e-1])) {\\n                e--;\\n            }\\n            \\n            int mid = s + (e-s) / 2;\\n            if(a[mid] == t) return true;\\n            if(a[s] <= a[mid]) { // left part is sorted\\n                if(t >= a[s] && t < a[mid]) e = mid-1;\\n                else s = mid+1;\\n            } else { // right part is sorted\\n                if(t > a[mid] && t <= a[e]) s = mid+1;\\n                else e = mid-1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\nHappy Coding!! :D",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean search(int[] a, int t) {\\n        int s = 0;\\n        int e = a.length - 1;\\n        \\n        while(s <= e) {\\n            // reach end of duplicates from start\\n            while ((s+1 <= e) && (a[s] == a[s+1])) {\\n                s++;\\n            }\\n            \\n            // reach end of duplicates from end\\n            while ((s <= e-1) && (a[e] == a[e-1])) {\\n                e--;\\n            }\\n            \\n            int mid = s + (e-s) / 2;\\n            if(a[mid] == t) return true;\\n            if(a[s] <= a[mid]) { // left part is sorted\\n                if(t >= a[s] && t < a[mid]) e = mid-1;\\n                else s = mid+1;\\n            } else { // right part is sorted\\n                if(t > a[mid] && t <= a[e]) s = mid+1;\\n                else e = mid-1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28273,
                "title": "c-binary-search-solution",
                "content": "        \\n    bool search(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size()-1;\\n        while (l<=r) {\\n            int mid = (r-l)/2+l;\\n            if (nums[mid] == target)\\n                return true;\\n            if (nums[mid] < nums[r]) {\\n                if (nums[mid]<target && target<=nums[r])\\n                    l = mid+1;\\n                else\\n                    r = mid-1;\\n            } else if (nums[mid] > nums[r]) {\\n                if (nums[l]<=target && target<nums[mid])\\n                    r = mid-1;\\n                else\\n                    l = mid+1;\\n            } else\\n                r--;\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "        \\n    bool search(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size()-1;\\n        while (l<=r) {\\n            int mid = (r-l)/2+l;\\n            if (nums[mid] == target)\\n                return true;\\n            if (nums[mid] < nums[r]) {\\n                if (nums[mid]<target && target<=nums[r])\\n                    l = mid+1;\\n                else\\n                    r = mid-1;\\n            } else if (nums[mid] > nums[r]) {\\n                if (nums[l]<=target && target<nums[mid])\\n                    r = mid-1;\\n                else\\n                    l = mid+1;\\n            } else\\n                r--;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 304742,
                "title": "java-modified-binary-search-explained",
                "content": "**Idea:** Binary Search\\n* There are 2 sorted sub-arrays in nums and every number is part of at least one of them which means nums[mid] is a part of one such sorted sub-array. So, nums[high] <= nums[mid] (nums[mid] < nums[high] fails) or nums[mid] <= nums[low] (nums[mid] > nums[low] fails) or both, imply that nums[mid] is equal to at least one of nums[high] and nums[low].\\n\\t* Case 1: nums[mid] is a part of an increasing sub-array starting at index low and ending before high\\n\\t\\t* Since this sub-array is sorted, nums[low] >= nums[mid], where low <= mid implies that all the numbers at indices in range [low, mid] are equal.\\n\\t\\t* So in order to perform binary-search, we need to shrink this sorted sub-array until nums[low] != nums[mid]. Once this condition is satisfied we can perform binary search on the remaining sorted sub-array.\\n\\t * Similarly for cases 2 and 3.\\n\\t * Case 2: nums[mid] is a part of an increasing sub-array starting after index start and ending at high\\n\\t * Case 3: nums[mid] is a part of an increasing sub-array starting at index low and ending at high\\n* Due to the existence of duplicates, we can have nums[left] == nums[mid] and in that case, the first half could be out of order (i.e. NOT in the ascending order, e.g. [3 1 2 3 3 3 3]) and we have to deal this case separately. \\n* In that case, it is guaranteed that nums[right] also equals to nums[mid], so what we can do is to check if nums[mid]== nums[left] == nums[right] before the original logic, and if so, we can move left and right both towards the middle by 1. and repeat.\\n>**T/S:** O(n)/O(1), where n = size(nums)\\n```\\npublic boolean search(int[] nums, int target) {\\n\\tvar high = nums.length - 1;\\n\\n\\tfor (var low = 0; low <= high;) {\\n\\t\\tvar mid = low + (high - low >> 1);\\n\\n\\t\\tif (nums[mid] == target)\\n\\t\\t\\treturn true;\\n\\t\\tif (nums[mid] > nums[low]) {\\n\\t\\t\\t// low to mid is sorted, search in this range\\n\\t\\t\\tif (nums[low] <= target && target < nums[mid])\\n\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t} else if (nums[mid] < nums[high]) {\\n\\t\\t\\t// mid to high is sorted, search in this range\\n\\t\\t\\tif (nums[mid] < target && target <= nums[high])\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t} else if (nums[mid] == nums[low]) {\\n\\t\\t\\t// have no idea about the array, but we can exclude nums[low] because nums[low] == nums[mid]\\n\\t\\t\\tlow++;\\n\\t\\t} else if (nums[mid] == nums[high]) {\\n\\t\\t\\t// have no idea about the array, but we can exclude nums[high] because nums[high] == nums[mid]\\n\\t\\t\\thigh--;\\n\\t\\t}\\n\\t}\\n\\n\\treturn false;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean search(int[] nums, int target) {\\n\\tvar high = nums.length - 1;\\n\\n\\tfor (var low = 0; low <= high;) {\\n\\t\\tvar mid = low + (high - low >> 1);\\n\\n\\t\\tif (nums[mid] == target)\\n\\t\\t\\treturn true;\\n\\t\\tif (nums[mid] > nums[low]) {\\n\\t\\t\\t// low to mid is sorted, search in this range\\n\\t\\t\\tif (nums[low] <= target && target < nums[mid])\\n\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t} else if (nums[mid] < nums[high]) {\\n\\t\\t\\t// mid to high is sorted, search in this range\\n\\t\\t\\tif (nums[mid] < target && target <= nums[high])\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t} else if (nums[mid] == nums[low]) {\\n\\t\\t\\t// have no idea about the array, but we can exclude nums[low] because nums[low] == nums[mid]\\n\\t\\t\\tlow++;\\n\\t\\t} else if (nums[mid] == nums[high]) {\\n\\t\\t\\t// have no idea about the array, but we can exclude nums[high] because nums[high] == nums[mid]\\n\\t\\t\\thigh--;\\n\\t\\t}\\n\\t}\\n\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3888593,
                "title": "c-finds-peak-first-then-binary-search-beats-91-34",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is solved by using binary search several times. \\n\\nFirstly, it is suggested to find the location for the peak which can be done by binary search.\\nSecondly, using usual binary search to find target. \\n\\nThis C++ program is modified from the one solving \\n[Leetcode 33. Search in Rotated Sorted Array\\n](https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3879257/cpython-binary-search-beats-100/)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are more edge cases to deal with. The major change is to add the following line in the function findK() which is not removable:\\n```\\nwhile (l < r-1 && x[l] == x[l+1]) l++; // Skip duplicates\\n```\\nOnce the location for the peak is sure. then use C++ binary_search!\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\naverage $O(n\\\\log n)$ but worst $O(n)$ for the testcase\\n```\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]\\n2\\n```\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(1)$\\n# Code runtime 3 ms Beats 91.34%\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int findK(const vector<int>& x) {\\n        if (n==1) return 0;\\n        if (n==2) return (x[0]<x[1])?1:0;\\n        int l = 0, r = n, m;\\n        while (l < r) {\\n            while (l < r-1 && x[l] == x[l+1]) l++; // Skip duplicates\\n            m = (r+l) / 2;\\n            if (m == n-1 || x[m] > x[m+1]) return m;\\n            if (x[m] > x[l]) l = m;\\n            else r=m;    \\n        }\\n        return m;\\n    }\\n\\n    bool search(vector<int>& nums, int target) {\\n        n=nums.size();\\n        int k=findK(nums);\\n    //    cout<<\"k=\"<<k<<endl;\\n    //    cout<<nums[k]<<endl;\\n        if (nums[k]==target) return 1;\\n        auto it=nums.begin();\\n        if (target>=nums[0] || k==n-1)\\n            return binary_search(it,it+k+1,target);      \\n        else\\n            return binary_search(it+k+1,it+n,target);\\n    }      \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nwhile (l < r-1 && x[l] == x[l+1]) l++; // Skip duplicates\\n```\n```\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]\\n2\\n```\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int findK(const vector<int>& x) {\\n        if (n==1) return 0;\\n        if (n==2) return (x[0]<x[1])?1:0;\\n        int l = 0, r = n, m;\\n        while (l < r) {\\n            while (l < r-1 && x[l] == x[l+1]) l++; // Skip duplicates\\n            m = (r+l) / 2;\\n            if (m == n-1 || x[m] > x[m+1]) return m;\\n            if (x[m] > x[l]) l = m;\\n            else r=m;    \\n        }\\n        return m;\\n    }\\n\\n    bool search(vector<int>& nums, int target) {\\n        n=nums.size();\\n        int k=findK(nums);\\n    //    cout<<\"k=\"<<k<<endl;\\n    //    cout<<nums[k]<<endl;\\n        if (nums[k]==target) return 1;\\n        auto it=nums.begin();\\n        if (target>=nums[0] || k==n-1)\\n            return binary_search(it,it+k+1,target);      \\n        else\\n            return binary_search(it+k+1,it+n,target);\\n    }      \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3382891,
                "title": "java-binary-search",
                "content": "### *Similar solution to Search in Rotated Sorted Array 1, just one extra condition at the end to skip the duplicate.*\\n# Code:\\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int lo = 0, hi = nums.length - 1;\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n            if (nums[lo] < nums[mid]) {\\n                if (target >= nums[lo] && target < nums[mid])\\n                    hi = mid - 1; \\n                else \\n                    lo = mid + 1;\\n            } else if (nums[lo] > nums[mid]) {\\n                if (target > nums[mid] && target <= nums[hi])\\n                    lo = mid + 1;\\n                else \\n                    hi = mid - 1;\\n            } else {  // skip the duplicate and move \\'lo\\' up\\n                lo++;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```\\n##### Time complexioty: $$O(logn)$$",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int lo = 0, hi = nums.length - 1;\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n            if (nums[lo] < nums[mid]) {\\n                if (target >= nums[lo] && target < nums[mid])\\n                    hi = mid - 1; \\n                else \\n                    lo = mid + 1;\\n            } else if (nums[lo] > nums[mid]) {\\n                if (target > nums[mid] && target <= nums[hi])\\n                    lo = mid + 1;\\n                else \\n                    hi = mid - 1;\\n            } else {  // skip the duplicate and move \\'lo\\' up\\n                lo++;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1436958,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& arr, int target) {\\n        int start=0, end=arr.size()-1;\\n        while(start<=end){\\n            int mid = start+(end-start)/2;\\n            if(arr[mid]==target) return true;\\n            if(arr[start]==arr[mid] && arr[end]==arr[mid]){\\n                while(start<=end && arr[start]==arr[mid] && arr[end]==arr[mid]){\\n                    start++;\\n                    end--;\\n                }                \\n            }\\n            else if(arr[start]<=arr[mid]){\\n                if(target>=arr[start] && target<=arr[mid]) end=mid-1;\\n                else start=mid+1;\\n            }else{\\n                if(target>=arr[mid] && target<=arr[end]) start=mid+1;\\n                else end=mid-1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& arr, int target) {\\n        int start=0, end=arr.size()-1;\\n        while(start<=end){\\n            int mid = start+(end-start)/2;\\n            if(arr[mid]==target) return true;\\n            if(arr[start]==arr[mid] && arr[end]==arr[mid]){\\n                while(start<=end && arr[start]==arr[mid] && arr[end]==arr[mid]){\\n                    start++;\\n                    end--;\\n                }                \\n            }\\n            else if(arr[start]<=arr[mid]){\\n                if(target>=arr[start] && target<=arr[mid]) end=mid-1;\\n                else start=mid+1;\\n            }else{\\n                if(target>=arr[mid] && target<=arr[end]) start=mid+1;\\n                else end=mid-1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1328569,
                "title": "js-o-logn-avg-o-n-worst-case-using-binary-search",
                "content": "```\\nvar search = function(nums, target) {\\n    const n = nums.length;\\n    let lo = 0,\\n        hi = n - 1,\\n        mid;\\n    \\n    while(lo <= hi) {\\n        mid = lo + Math.floor((hi - lo) / 2);\\n\\n\\t\\t// found the target\\n        if(nums[mid] === target) {\\n            return true;\\n        } else if(nums[mid] > nums[hi]) {\\n\\t\\t\\t// if mid element is greater than the last element - first half is sorted\\n\\t\\t\\t// Ex. [4,5,6,7,1,2,3] or [3,4,5,6,7,1,2]\\n\\t\\t\\t// if target lies between lower element and the middle element, search in that half\\n            if(nums[lo] <= target && target < nums[mid]) {\\n                hi = mid - 1;\\n            } else {\\n\\t\\t\\t\\t// else search in the other half\\n                lo = mid + 1;\\n            }\\n        } else if(nums[mid] < nums[hi]) {\\n\\t\\t\\t// if mid element is less than the last element - second half is sorted\\n\\t\\t\\t// Ex. [5,6,7,1,2,3,4] or [7,1,2,3,4,5,6]\\n\\t\\t\\t// if target lies between middle element and the last element, search in that half\\n\\t\\t\\t// if we would have consider nums[mid] === nums[hi] case in this (as in the first part problem),\\n\\t\\t\\t// [1,1,1,1,1,5,6,1] such cases will fail, so handling the case separately in the else clause\\n            if(nums[mid] < target && target <= nums[hi]) {\\n                lo = mid + 1;\\n            } else {\\n\\t\\t\\t\\t// else search in the other half\\n                hi = mid - 1;\\n            }\\n        } else {\\n\\t\\t\\t// this case is required to handle the duplicates\\n\\t\\t\\t// Ex. [4,1,2,4,4,4,4], [1,1,1,1,1,5,6,1] - the mid element is equal to the last element\\n\\t\\t\\t--hi;\\n    }\\n\\t// target not found\\n    return false;\\n}\\n```\\n\\nTime Complexity = O(logn) - avg, O(n) - worst\\nSpace Complexity = O(1)\\n```\\nWorst case - O(n): [1,1,1,1,1,1,1,1,1,1,1]\\n\\nDuplicate cases to consider - \\n[4,5,6,7,1,1,1]\\n[7,1,1,1,4,5,6]\\n[1,1,4,5,6,7,1]\\n[1,1,1,1,4,5,6,1]\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nvar search = function(nums, target) {\\n    const n = nums.length;\\n    let lo = 0,\\n        hi = n - 1,\\n        mid;\\n    \\n    while(lo <= hi) {\\n        mid = lo + Math.floor((hi - lo) / 2);\\n\\n\\t\\t// found the target\\n        if(nums[mid] === target) {\\n            return true;\\n        } else if(nums[mid] > nums[hi]) {\\n\\t\\t\\t// if mid element is greater than the last element - first half is sorted\\n\\t\\t\\t// Ex. [4,5,6,7,1,2,3] or [3,4,5,6,7,1,2]\\n\\t\\t\\t// if target lies between lower element and the middle element, search in that half\\n            if(nums[lo] <= target && target < nums[mid]) {\\n                hi = mid - 1;\\n            } else {\\n\\t\\t\\t\\t// else search in the other half\\n                lo = mid + 1;\\n            }\\n        } else if(nums[mid] < nums[hi]) {\\n\\t\\t\\t// if mid element is less than the last element - second half is sorted\\n\\t\\t\\t// Ex. [5,6,7,1,2,3,4] or [7,1,2,3,4,5,6]\\n\\t\\t\\t// if target lies between middle element and the last element, search in that half\\n\\t\\t\\t// if we would have consider nums[mid] === nums[hi] case in this (as in the first part problem),\\n\\t\\t\\t// [1,1,1,1,1,5,6,1] such cases will fail, so handling the case separately in the else clause\\n            if(nums[mid] < target && target <= nums[hi]) {\\n                lo = mid + 1;\\n            } else {\\n\\t\\t\\t\\t// else search in the other half\\n                hi = mid - 1;\\n            }\\n        } else {\\n\\t\\t\\t// this case is required to handle the duplicates\\n\\t\\t\\t// Ex. [4,1,2,4,4,4,4], [1,1,1,1,1,5,6,1] - the mid element is equal to the last element\\n\\t\\t\\t--hi;\\n    }\\n\\t// target not found\\n    return false;\\n}\\n```\n```\\nWorst case - O(n): [1,1,1,1,1,1,1,1,1,1,1]\\n\\nDuplicate cases to consider - \\n[4,5,6,7,1,1,1]\\n[7,1,1,1,4,5,6]\\n[1,1,4,5,6,7,1]\\n[1,1,1,1,4,5,6,1]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 942545,
                "title": "java-short-and-crisp-binary-search-beats-100-with-comments",
                "content": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        if(nums.length==0) return false;\\n        int s=0,e=nums.length-1;\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(nums[mid]==target || nums[s]==target || nums[e]==target) return true;\\n\\t\\t\\t//Left side is sorted\\n            else if(nums[s]<nums[mid]){\\n\\t\\t\\t\\t//If target is within range of  (nums[start],nums[mid])\\n                if(nums[s]<target && target<nums[mid]) e=mid-1;            \\n\\t\\t\\t\\t//Else search in right part\\n                else s=mid+1;\\n            }\\n\\t\\t\\t//Right side is sorted\\n           else  if(nums[mid]<nums[e]) {\\n\\t\\t       //If target is within range of  (nums[mid],nums[end])\\n                if( nums[mid]<target && target<nums[e]) s=mid+1;              \\n\\t\\t\\t\\t//Else search in left part\\n                else e=mid-1;\\n            }\\n\\t\\t\\t//We definitely cant say which side is sorted, so reduce search space by 1 and repeat\\n           else e--;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        if(nums.length==0) return false;\\n        int s=0,e=nums.length-1;\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(nums[mid]==target || nums[s]==target || nums[e]==target) return true;\\n\\t\\t\\t//Left side is sorted\\n            else if(nums[s]<nums[mid]){\\n\\t\\t\\t\\t//If target is within range of  (nums[start],nums[mid])\\n                if(nums[s]<target && target<nums[mid]) e=mid-1;            \\n\\t\\t\\t\\t//Else search in right part\\n                else s=mid+1;\\n            }\\n\\t\\t\\t//Right side is sorted\\n           else  if(nums[mid]<nums[e]) {\\n\\t\\t       //If target is within range of  (nums[mid],nums[end])\\n                if( nums[mid]<target && target<nums[e]) s=mid+1;              \\n\\t\\t\\t\\t//Else search in left part\\n                else e=mid-1;\\n            }\\n\\t\\t\\t//We definitely cant say which side is sorted, so reduce search space by 1 and repeat\\n           else e--;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889926,
                "title": "o-log-n-the-most-efficient-solution-beginner-friendly-with-an-explanation",
                "content": "# Approach\\nWe\\'ll use a binary search approach to efficiently search for the target element in the rotated and sorted array. This approach takes advantage of the fact that one of the two halves of the rotated array is always sorted.\\n\\n**Logic:**\\n1. Initialize two pointers, `left` and `right`, to point to the beginning and end of the array, respectively.\\n2. Use a while loop to continue searching while `left` is less than or equal to `right`.\\n3. Calculate the middle index as `mid = left + (right - left) / 2` to avoid potential integer overflow.\\n4. Check if the element at the `mid` index is equal to the target:\\n   - If it\\'s equal, return `true`, as we\\'ve found the target.\\n5. Handle the special case when `nums[left]`, `nums[mid]`, and `nums[right]` are all equal. In this case, we can\\'t decide which half is sorted, so we\\'ll increment `left` and decrement `right`.\\n6. Check if the left half of the array is sorted (`nums[left] <= nums[mid]`):\\n   - If it is, check if the target falls within the range of values in the left half (`nums[left] <= target <= nums[mid]`).\\n     - If it does, update `right` to `mid - 1` to search the left half.\\n     - Otherwise, update `left` to `mid + 1` to search the right half.\\n7. If the left half is not sorted, then the right half must be sorted:\\n   - Check if the target falls within the range of values in the right half (`nums[mid] <= target <= nums[right]`).\\n     - If it does, update `left` to `mid + 1` to search the right half.\\n     - Otherwise, update `right` to `mid - 1` to search the left half.\\n8. If the loop completes without finding the target, return `false`.\\n\\n**Summary:**\\nBy utilizing binary search and considering the sorted nature of at least one half of the rotated array, this approach efficiently narrows down the search space until either the target element is found or the search space is exhausted. The handling of cases with duplicate values ensures that the solution remains accurate even in the presence of duplicates.\\n\\n# Complexity\\n- Time complexity: $$O(log n)$$\\n    - Runtime: 0ms - 100% beats \\n\\n- Space complexity: $$O(1)$$\\n    - Memory: 42.4 MB - 99% beats\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n\\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n\\n            if (nums[left] == nums[mid] && nums[mid] == nums[right]) {\\n                left++;\\n                right--;\\n            } else if (nums[left] <= nums[mid]) {\\n                if (nums[left] <= target && target <= nums[mid]) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] <= target && target <= nums[right]) {\\n                    left = mid + 1;\\n                } else {\\n                    right = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n\\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n\\n            if (nums[left] == nums[mid] && nums[mid] == nums[right]) {\\n                left++;\\n                right--;\\n            } else if (nums[left] <= nums[mid]) {\\n                if (nums[left] <= target && target <= nums[mid]) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] <= target && target <= nums[right]) {\\n                    left = mid + 1;\\n                } else {\\n                    right = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104563,
                "title": "best-o-logn-solution",
                "content": "# Approach 1\\nLinear Search\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        for (int i = 0; i < nums.size(); i++)\\n            if (nums[i] == target)\\n                return true;\\n        return false;        \\n    }\\n};\\n```\\n\\n# Approach 2\\nBinary Search\\n\\n# Complexity\\n- Time complexity:\\n$$O(logn)$$ \\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int low = 0, high = nums.size() - 1;\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            if (nums[mid] == target)\\n                return true;\\n            if (nums[low] == nums[mid] && nums[high] == nums[mid]) {\\n                low++;\\n                high--;\\n            } else if (nums[low] <= nums[mid]) {\\n                if (target >= nums[low] && target < nums[mid])\\n                    high = mid - 1;\\n                else\\n                    low = mid + 1;    \\n            } else {\\n                if (target > nums[mid] && target <= nums[high])\\n                    low = mid + 1;\\n                else\\n                    high = mid - 1; \\n            }    \\n        }\\n        return false;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        for (int i = 0; i < nums.size(); i++)\\n            if (nums[i] == target)\\n                return true;\\n        return false;        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int low = 0, high = nums.size() - 1;\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            if (nums[mid] == target)\\n                return true;\\n            if (nums[low] == nums[mid] && nums[high] == nums[mid]) {\\n                low++;\\n                high--;\\n            } else if (nums[low] <= nums[mid]) {\\n                if (target >= nums[low] && target < nums[mid])\\n                    high = mid - 1;\\n                else\\n                    low = mid + 1;    \\n            } else {\\n                if (target > nums[mid] && target <= nums[high])\\n                    low = mid + 1;\\n                else\\n                    high = mid - 1; \\n            }    \\n        }\\n        return false;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063376,
                "title": "super-easy-java-sol-0ms-100-beats-o-log-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : Binary Search\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n         int low=0;\\n         int high=nums.length-1;\\n        while(low<=high)\\n        {\\n            int mid = low+(high-low)/2;\\n            if(nums[mid]==target)\\n            return true;\\n            if((nums[mid]==nums[low])&&(nums[high]==nums[mid]))\\n            {\\n                 low++;\\n                 high--;\\n            }\\n            else if (nums[mid]>=nums[low])\\n            {\\n                if(target>=nums[low]&&target<nums[mid])\\n                 high = mid-1;\\n                else\\n                 low = mid+1;\\n            }\\n            else\\n            {\\n                if(target>nums[mid]&&target<=nums[high])\\n                 low = mid+1;\\n                else\\n                 high = mid-1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n         int low=0;\\n         int high=nums.length-1;\\n        while(low<=high)\\n        {\\n            int mid = low+(high-low)/2;\\n            if(nums[mid]==target)\\n            return true;\\n            if((nums[mid]==nums[low])&&(nums[high]==nums[mid]))\\n            {\\n                 low++;\\n                 high--;\\n            }\\n            else if (nums[mid]>=nums[low])\\n            {\\n                if(target>=nums[low]&&target<nums[mid])\\n                 high = mid-1;\\n                else\\n                 low = mid+1;\\n            }\\n            else\\n            {\\n                if(target>nums[mid]&&target<=nums[high])\\n                 low = mid+1;\\n                else\\n                 high = mid-1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401095,
                "title": "java-0ms-100-faster-solution",
                "content": "```\\nint start =0;\\n        int end = nums.length-1;\\n        \\n        while(start <= end)\\n        {\\n            int mid = start + (end-start)/2;\\n            \\n            if(nums[mid] == target)\\n                return true;\\n            \\n            if(nums[mid] == nums[end])\\n                end--;\\n            \\n            else if(nums[start] <= nums[mid])\\n            {\\n                if(target >= nums[start] && target <nums[mid])\\n                    end = mid -1;\\n                else\\n                    start = mid+1;\\n            }\\n            else\\n            {\\n                if(target > nums[mid] && target <= nums[end])\\n                    start = mid+1;\\n                else\\n                    end = mid -1;\\n            }\\n            \\n            \\n        }\\n        \\n        return false;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nint start =0;\\n        int end = nums.length-1;\\n        \\n        while(start <= end)\\n        {\\n            int mid = start + (end-start)/2;\\n            \\n            if(nums[mid] == target)\\n                return true;\\n            \\n            if(nums[mid] == nums[end])\\n                end--;\\n            \\n            else if(nums[start] <= nums[mid])\\n            {\\n                if(target >= nums[start] && target <nums[mid])\\n                    end = mid -1;\\n                else\\n                    start = mid+1;\\n            }\\n            else\\n            {\\n                if(target > nums[mid] && target <= nums[end])\\n                    start = mid+1;\\n                else\\n                    end = mid -1;\\n            }\\n            \\n            \\n        }\\n        \\n        return false;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1892425,
                "title": "search-in-rotated-sorted-array-2-python-easy-binary-search-approach-73-ms-beats-54-24",
                "content": "1. Following are the steps to solve this problem using binary search:-\\n1- Sort the array.\\n2 - Initialize left pointer as 0 and right pointer as length of array -1\\n3- initialize mid_index as 0\\n4- Start a loop till l<=r\\n5- initialize mid_index as sum of left and right poinder divided by 2\\n6- initialize mid_number as arr[mid_index]\\n7- Check whether mid_number = target, if it is then return True\\n9- Check whether mid_number is less than target then change the value of l to mid_index +1\\n10- Else change the value of r to mid_index -1\\n11- Exit the loop and return False\\n\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        nums.sort()\\n        l = 0\\n        r = len(nums)-1\\n        mid_index = 0\\n        \\n        while(l<=r):\\n            mid_index = (l+r)//2\\n            mid_number = nums[mid_index]\\n            \\n            if mid_number == target:\\n                return True\\n            if mid_number<target:\\n                l = mid_index+1\\n            else:\\n                r = mid_index-1\\n        return False\\n```\\t\\n\\n2- There is one more simple solution to solve this question that is:-\\nCheck whether target is present in the list using if statement and return True or False\\n\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        if target in nums:\\n            return True\\n        else:\\n            return False\\n```\\n\\nIf you have any queries do let me know in comments!!\\n  \\n\\n",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        nums.sort()\\n        l = 0\\n        r = len(nums)-1\\n        mid_index = 0\\n        \\n        while(l<=r):\\n            mid_index = (l+r)//2\\n            mid_number = nums[mid_index]\\n            \\n            if mid_number == target:\\n                return True\\n            if mid_number<target:\\n                l = mid_index+1\\n            else:\\n                r = mid_index-1\\n        return False\\n```\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        if target in nums:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1891315,
                "title": "python-binary-search",
                "content": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        l = 0\\n        r = len(nums)-1\\n        while l<=r:\\n            m=(r+l)//2\\n            if target in [nums[m], nums[r], nums[l]]: return True\\n            elif nums[m]==nums[l] or nums[m]==nums[r]:\\n                r-=1\\n                l+=1\\n            elif nums[l]<=nums[m]:\\n                if nums[l]<target<nums[m]: r=m-1\\n                else: l=m+1\\n            else:\\n                if nums[m]<target<nums[r]: l=m+1\\n                else: r=m-1\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        l = 0\\n        r = len(nums)-1\\n        while l<=r:\\n            m=(r+l)//2\\n            if target in [nums[m], nums[r], nums[l]]: return True\\n            elif nums[m]==nums[l] or nums[m]==nums[r]:\\n                r-=1\\n                l+=1\\n            elif nums[l]<=nums[m]:\\n                if nums[l]<target<nums[m]: r=m-1\\n                else: l=m+1\\n            else:\\n                if nums[m]<target<nums[r]: l=m+1\\n                else: r=m-1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890225,
                "title": "python3-one-line-solution",
                "content": "be relax, it\\'s just a joke :P\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        return target in nums\\n```\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        return target in nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1217301,
                "title": "2-c-simple-solutions-binary-search-two-pointer",
                "content": "****1. Using two pointer approch.\\ntime complexity: O(n)****\\n```\\nbool search(vector<int>& nums, int target) {\\n        if(nums.size() == 0)return false;\\n        if(nums.size() == 1){\\n            if(nums[0] == target)return true;\\n            return false;\\n        }\\n        int i = 0;\\n        int j = nums.size()-1;\\n        while(i<=j){\\n            if(nums[i] == target)return true;\\n            if(nums[j] == target) return true;\\n            i++;j--;\\n        }\\n        return false;\\n    }\\n```\\n***2. Using binary search\\nTime complexity: O(log(n))***\\n```\\nbool search(vector<int>& nums, int target) {\\n\\n        if(nums.size() == 0)return false;\\n        if(nums.size() == 1){\\n            if(nums[0] == target)return true;\\n            return false;\\n        }\\n        int i = 0;\\n        int j = nums.size()-1;\\n        while(i<=j){\\n            int mid  = (i+j)/2;\\n            if(nums[mid] == target )return true;\\n            if(nums[i] == nums[mid] && nums[j] == nums[mid]){ /*if not able to figure out which part is sorted*/\\n                i++;\\n                j--;\\n                continue;\\n            }\\n            if(nums[i] <= nums[mid]){  /*left part is sorted*/\\n                if(target >= nums[i] && target < nums[mid]){\\n                    j = mid-1;\\n                }else{\\n                   i = mid+1; \\n                }\\n            }else{ /*right part is sorted*/\\n                if(target > nums[mid] && target <= nums[j]){\\n                    i = mid+1;\\n                }else{\\n                    j = mid-1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n```\\n***Feel free to ask any doubt.\\ndo upvote if you like the solution.\\nHappy Coding.! :)***",
                "solutionTags": [],
                "code": "```\\nbool search(vector<int>& nums, int target) {\\n        if(nums.size() == 0)return false;\\n        if(nums.size() == 1){\\n            if(nums[0] == target)return true;\\n            return false;\\n        }\\n        int i = 0;\\n        int j = nums.size()-1;\\n        while(i<=j){\\n            if(nums[i] == target)return true;\\n            if(nums[j] == target) return true;\\n            i++;j--;\\n        }\\n        return false;\\n    }\\n```\n```\\nbool search(vector<int>& nums, int target) {\\n\\n        if(nums.size() == 0)return false;\\n        if(nums.size() == 1){\\n            if(nums[0] == target)return true;\\n            return false;\\n        }\\n        int i = 0;\\n        int j = nums.size()-1;\\n        while(i<=j){\\n            int mid  = (i+j)/2;\\n            if(nums[mid] == target )return true;\\n            if(nums[i] == nums[mid] && nums[j] == nums[mid]){ /*if not able to figure out which part is sorted*/\\n                i++;\\n                j--;\\n                continue;\\n            }\\n            if(nums[i] <= nums[mid]){  /*left part is sorted*/\\n                if(target >= nums[i] && target < nums[mid]){\\n                    j = mid-1;\\n                }else{\\n                   i = mid+1; \\n                }\\n            }else{ /*right part is sorted*/\\n                if(target > nums[mid] && target <= nums[j]){\\n                    i = mid+1;\\n                }else{\\n                    j = mid-1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1117605,
                "title": "javascript-elegant-binary-search",
                "content": "Time: `O(log N)` on average, `O(N)` worst case (e.g. if all numbers are the same)\\nSpace: `O(log N)`\\n```javascript\\nvar search = function(nums, target) {\\n    \\n    function findPivot(low, high) {\\n        if(high - low === 1 && nums[high] < nums[low]) return high;\\n        if(high - low <= 1) return 0;\\n        \\n        const mid = Math.floor((low + high) / 2);\\n        \\n        if(nums[mid] > nums[high]) return findPivot(mid, high);\\n        if(nums[mid] < nums[low]) return findPivot(low, mid);\\n        return Math.max(findPivot(low, mid), findPivot(mid, high));\\n    }\\n    \\n    function binarySearch(start, end) {\\n        while(start <= end) {\\n            const mid = Math.floor((start + end) / 2);\\n            \\n            if(nums[mid] === target) return true;\\n            if(nums[mid] > target) end = mid - 1;\\n            else start = mid + 1;\\n        }\\n        return false;\\n    }\\n    \\n    const minIdx = findPivot(0, nums.length-1)\\n    return binarySearch(0, minIdx-1) || binarySearch(minIdx, nums.length-1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```javascript\\nvar search = function(nums, target) {\\n    \\n    function findPivot(low, high) {\\n        if(high - low === 1 && nums[high] < nums[low]) return high;\\n        if(high - low <= 1) return 0;\\n        \\n        const mid = Math.floor((low + high) / 2);\\n        \\n        if(nums[mid] > nums[high]) return findPivot(mid, high);\\n        if(nums[mid] < nums[low]) return findPivot(low, mid);\\n        return Math.max(findPivot(low, mid), findPivot(mid, high));\\n    }\\n    \\n    function binarySearch(start, end) {\\n        while(start <= end) {\\n            const mid = Math.floor((start + end) / 2);\\n            \\n            if(nums[mid] === target) return true;\\n            if(nums[mid] > target) end = mid - 1;\\n            else start = mid + 1;\\n        }\\n        return false;\\n    }\\n    \\n    const minIdx = findPivot(0, nums.length-1)\\n    return binarySearch(0, minIdx-1) || binarySearch(minIdx, nums.length-1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 754446,
                "title": "java-binary-search-with-comments-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        \\n        int l = 0, r = nums.length - 1, mid = 0;\\n        \\n        while(l <= r) {\\n            \\n            mid = (r + l) / 2;\\n            \\n            if(target == nums[mid]) {\\n                return true;\\n            }\\n            //stable left\\n            if(nums[l] < nums[mid]) {\\n                if(target < nums[mid] && target >= nums[l]) {\\n                    //search left\\n                    r = mid - 1;\\n                } else {\\n                    //search unstable right;\\n                    l = mid + 1;   \\n                }\\n            //stable right\\n            } else if (nums[mid] < nums[r]) {\\n                //search stable right\\n                if(target > nums[mid] && target <= nums[r]) {\\n                    l = mid + 1;\\n                } else {\\n                    //search unstable left\\n                    r = mid - 1;\\n                }\\n            //nums[l] == nums[mid] == nums[r] ex [1,1,3,1]\\n            } else if(nums[mid] == nums[l] && nums[mid] == nums[r]){\\n                r--;\\n                l++;\\n            //left fill with same characters [1,1,3]\\n            } else if(nums[mid] == nums[l]) {\\n                l = mid + 1;\\n            //[3,1,1]\\n            } else {\\n                r = mid - 1;\\n            }\\n                        \\n        }\\n        \\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean search(int[] nums, int target) {\\n        \\n        int l = 0, r = nums.length - 1, mid = 0;\\n        \\n        while(l <= r) {\\n            \\n            mid = (r + l) / 2;\\n            \\n            if(target == nums[mid]) {\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 299980,
                "title": "in-depth-analysis-of-this-problem",
                "content": "it\\'s an old problem and all the possible solutions have been posted here.\\nbut after reading some most voted solutions, I feel like some basic analysis is missing. \\n\\nwe can start with all the basic scenarios of this problems - sorted array with deplicates and rotated:\\n| case | a[start] | ? | a[mid] | ? | a[end] | example |\\n| --- | --- | --- | ---|---|---|---|\\n|  1 | |   >| |    = | |     [4 2 3 3 3]\\n | 2  ||  > ||     < ||      [4 2 3 3 4]\\n | 3  ||  =  ||    <   ||    [3 3 3 1 2]\\n | 4  ||  =   ||   =      || [3 3 3 2 3]\\n | 5  ||  <  ||    <      || [1 2 3 3 4]\\n | 6    ||<  ||    =  ||     [1 2 3 3 3]\\n | 7  ||  <  ||    >    ||   [3 4 5 1 2]\\n | 8   || =   ||   >   ||    [3 3 3 1 2]\\n \\n so why we cannot use the method of binary search in last question for this?\\n here is the **WRONG** solution:\\n ```\\n     public boolean search1(int[] nums, int target) {\\n        int s = 0;\\n        int e = nums.length - 1;\\n        while (s <= e) {\\n            int mid = s + (e - s) / 2;\\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n            if (nums[mid] < nums[e]) { // right half is sorted\\n                if (nums[mid] < target && target <= nums[e]) {\\n                    s = mid + 1;\\n                } else {\\n                    e = mid - 1;\\n                }\\n            } else if (nums[s] < nums[mid]) { // left half is sorted\\n                if (nums[s] <= target && target < nums[mid]) {\\n                    e = mid - 1;\\n                } else {\\n                    s = mid + 1;\\n                }\\n            } else { // nums[mid] = either or both of start and end\\n                s++;\\n            }\\n        }\\n        return false;\\n    }\\n```\\nthe reasons that it it wrong because:\\n * the impact of duplicates - more different scenarios \\n * if we just compare `a[start] < a[mid]` and `a[mid] < a[end]` and then determine whether we should go left half or right half, and `s++` elsewise. we are including 3 scenarios (1, 2, 8 in the table) in the `else` block\\n * if we simply `s++` then potentially we are missing the cases\\n\\nthen it comes to the solution that covers and handles all the cases in the table:\\nthe solution is just trivial, but considering to cover all the \"combinations\" is more important.\\n```\\n    public boolean search(int[] nums, int target) {\\n        int s = 0, e = nums.length - 1;\\n        while (s <= e) {\\n            int mid = s + (e - s) / 2;\\n            if (nums[mid] == target) return true;\\n            if (nums[s] < nums[mid]) {\\n                if (target >= nums[s] && target < nums[mid]) {\\n                    e = mid - 1;\\n                } else {\\n                    s = mid + 1;\\n                }\\n            } else if (nums[s] > nums[mid]) { // right half is sorted\\n                if (target < nums[mid] || target > nums[e]) {\\n                    e = mid - 1;\\n                } else {\\n                    s = mid + 1;\\n                }\\n            } else {\\n                s++;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n     public boolean search1(int[] nums, int target) {\\n        int s = 0;\\n        int e = nums.length - 1;\\n        while (s <= e) {\\n            int mid = s + (e - s) / 2;\\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n            if (nums[mid] < nums[e]) { // right half is sorted\\n                if (nums[mid] < target && target <= nums[e]) {\\n                    s = mid + 1;\\n                } else {\\n                    e = mid - 1;\\n                }\\n            } else if (nums[s] < nums[mid]) { // left half is sorted\\n                if (nums[s] <= target && target < nums[mid]) {\\n                    e = mid - 1;\\n                } else {\\n                    s = mid + 1;\\n                }\\n            } else { // nums[mid] = either or both of start and end\\n                s++;\\n            }\\n        }\\n        return false;\\n    }\\n```\n```\\n    public boolean search(int[] nums, int target) {\\n        int s = 0, e = nums.length - 1;\\n        while (s <= e) {\\n            int mid = s + (e - s) / 2;\\n            if (nums[mid] == target) return true;\\n            if (nums[s] < nums[mid]) {\\n                if (target >= nums[s] && target < nums[mid]) {\\n                    e = mid - 1;\\n                } else {\\n                    s = mid + 1;\\n                }\\n            } else if (nums[s] > nums[mid]) { // right half is sorted\\n                if (target < nums[mid] || target > nums[e]) {\\n                    e = mid - 1;\\n                } else {\\n                    s = mid + 1;\\n                }\\n            } else {\\n                s++;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 251026,
                "title": "same-as-sorted-array-i-get-the-smallest-element-index-first-normal-binary-search",
                "content": "**Update**: I annouce this post is deprecated, I came up with another one, thought could be better: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array-ii/discuss/1271030/Come-and-check!-A-complete-different-way-from-other-solutions-still-binary-search\\n\\n---\\n```java\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        // corner case\\n        if(nums == null || nums.length == 0) return false;\\n        \\n        int n = nums.length;\\n        int left = 0;\\n        int right = n - 1;\\n\\t\\t\\n        // find the smallest element index\\n        // pre-processing: remove the effect of duplciates numbers in the left half\\n        while(left < n && nums[left] == nums[n - 1]) left++;\\n        if(left == n - 1) return target == nums[n - 1];\\n        \\n\\t\\t// binary search to find the smallest element index\\n        while(left < right){\\n            int mid = left + (right - left)/2;\\n            if(nums[mid] <= nums[right]) right = mid;\\n            else left = mid + 1;\\n        }\\n        \\n        // the smallest element index is left/right\\n        int minIdx = left;\\n        if(target == nums[n - 1]) return true;\\n        left = target < nums[n - 1] ? minIdx : 0;\\n        right = target < nums[n - 1] ? n - 1 : minIdx - 1;\\n\\t\\t\\n        // regular binary search\\n        while(left <= right){\\n            int mid = left + (right - left)/2;\\n            if(nums[mid] == target) return true;\\n            else if(nums[mid] > target) right = mid - 1;\\n            else left = mid + 1;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n\\ntime complexity: `O(n)`(worst case happens at all duplicates)\\nspace complexity: `O(1)`",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        // corner case\\n        if(nums == null || nums.length == 0) return false;\\n        \\n        int n = nums.length;\\n        int left = 0;\\n        int right = n - 1;\\n\\t\\t\\n        // find the smallest element index\\n        // pre-processing: remove the effect of duplciates numbers in the left half\\n        while(left < n && nums[left] == nums[n - 1]) left++;\\n        if(left == n - 1) return target == nums[n - 1];\\n        \\n\\t\\t// binary search to find the smallest element index\\n        while(left < right){\\n            int mid = left + (right - left)/2;\\n            if(nums[mid] <= nums[right]) right = mid;\\n            else left = mid + 1;\\n        }\\n        \\n        // the smallest element index is left/right\\n        int minIdx = left;\\n        if(target == nums[n - 1]) return true;\\n        left = target < nums[n - 1] ? minIdx : 0;\\n        right = target < nums[n - 1] ? n - 1 : minIdx - 1;\\n\\t\\t\\n        // regular binary search\\n        while(left <= right){\\n            int mid = left + (right - left)/2;\\n            if(nums[mid] == target) return true;\\n            else if(nums[mid] > target) right = mid - 1;\\n            else left = mid + 1;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888878,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        return True if target in nums else False\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        return True if target in nums else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888467,
                "title": "python3-one-liner-solution",
                "content": "\\n```\\nclass Solution:\\n    def search(self,nums:List[int],target:int)->bool:\\n        return True if target in nums else False       \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def search(self,nums:List[int],target:int)->bool:\\n        return True if target in nums else False       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881270,
                "title": "0-liner-code-no-line-used-beats-96-68-in-runtime-only-53ms",
                "content": "![image.png](https://assets.leetcode.com/users/images/5605dbb2-67ea-489b-8a2b-ca19240a095c_1691491058.1089356.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:return True if target in nums else False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:return True if target in nums else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870685,
                "title": "most-optimal-solution-using-binary-search-c-and-java-code",
                "content": "\\n\\n# Approach\\nThis solution is an efficient binary search approach to find the target in a rotated sorted array with non-distinct elements. It uses two pointers, low and high, to maintain the search range. It repeatedly divides the array in half and checks if the target is in the left or right half.\\n\\nThe key idea is to handle the cases where the values at low, mid, and high are the same. This situation can arise due to duplicate elements in the array. In such cases, the algorithm moves the low and high pointers closer to each other by one step until they are not equal, effectively reducing the search space.\\n\\nThe algorithm then checks which half of the array is sorted (left or right of the mid), and based on that, it narrows down the search range accordingly. It keeps performing binary search until the target is found or the search space is exhausted.\\n\\nThe overall time complexity of this solution is O(log n), where n is the size of the input array nums, making it an efficient way to search for the target in a rotated sorted array with non-distinct elements.\\n\\n# Complexity\\n- Time complexity:\\nO(log(n)), if the input array contains a lot of duplicates then it might go to O(n/2)\\n\\n- Space complexity:\\nO(1)\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int low = 0, high = nums.size()-1;\\n        while(low<=high) {\\n            int mid = (low+high)/2;\\n            if(nums[mid] == target) return true;\\n            if(nums[low] == nums[mid] && nums[mid] == nums[high]) {\\n                low++;\\n                high--;\\n                continue;\\n            }\\n            if(nums[low]<=nums[mid]) {\\n                if(nums[low]<=target && target <= nums[mid]) high = mid-1;\\n                else low = mid+1;\\n            }\\n            else {\\n                if(nums[mid]<=target && target<=nums[high]) low = mid+1;\\n                else high = mid-1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n# JAVA Code:\\n```\\npublic class Solution {\\n    public boolean search(int[] nums, int target) {\\n        int low = 0, high = nums.length - 1;\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n            if (nums[low] == nums[mid] && nums[mid] == nums[high]) {\\n                low++;\\n                high--;\\n                continue;\\n            }\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target <= nums[mid]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] <= target && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int low = 0, high = nums.size()-1;\\n        while(low<=high) {\\n            int mid = (low+high)/2;\\n            if(nums[mid] == target) return true;\\n            if(nums[low] == nums[mid] && nums[mid] == nums[high]) {\\n                low++;\\n                high--;\\n                continue;\\n            }\\n            if(nums[low]<=nums[mid]) {\\n                if(nums[low]<=target && target <= nums[mid]) high = mid-1;\\n                else low = mid+1;\\n            }\\n            else {\\n                if(nums[mid]<=target && target<=nums[high]) low = mid+1;\\n                else high = mid-1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\npublic class Solution {\\n    public boolean search(int[] nums, int target) {\\n        int low = 0, high = nums.length - 1;\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n            if (nums[low] == nums[mid] && nums[mid] == nums[high]) {\\n                low++;\\n                high--;\\n                continue;\\n            }\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target <= nums[mid]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] <= target && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287046,
                "title": "java-binary-search-solution-with-clear-explanation-and-real-life-application",
                "content": "# Intuition\\nThe \"Search in Rotated Sorted Array II\" problem involves finding a target value in a sorted array that has been rotated at some pivot point. The array may contains duplicates.\\n\\nThis problem is an upgrade version of \"Search in Rotated Sorted Array\". However the previous problem assumes that there are no duplicate elements in the array.\\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3282328/java-binary-search-solution-with-clear-explanation-and-real-life-application/\\n\\nThe only difference between the two problems is that we will handle the case where `nums[mid] == nums[left] && nums[mid] == nums[right]`. Please check out **STEP 2** in the approach section.\\n\\n\\n# Approach\\nHere are the steps to solve this problem:\\n1. First we initialize two pointers `left and right` to the start and end of the array.\\n\\n2. At each iteration of the binary search, we compare the middle element to the first and last elements, and adjust the indices of the search range. If `nums[mid] == nums[left] && nums[mid] == nums[right]`, we know that the other half of the array must cointain the pivot point and any values that are less than or equal to the middle element\\n\\n2. If  we pass step 2, compare the left and middle elements of the array. If `nums[left] <= nums[mid]`, then the left half of the array is sorted. Otherwise, the right half of the array is sorted.\\n\\n3. **If the left half is sorted**, we can check if the target value is within that range. If it is, we update the right index to be the middle element minus one `right = mid - 1`. Else, we update the left index to be the middle element plus one `left = mid + 1`.\\n\\n4. **If the right half is sorted**, we check if the target value is within that range. If it is, we update the left index to be the middle element plus one `left = mid + 1`. Else, we update the right index to be the middle element minus one `right = mid - 1`\\n\\n5. We continue this process until we either find the target value or the left and right indices cross over each other (in which case we know the target value is not in the array).\\n\\n# Code\\n```java []\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        //Step 1\\n        int left = 0;\\n        int right = nums.length-1;\\n        while(left <= right)\\n        {\\n            int mid = left + (right - left)/2;\\n            //Step 6\\n            if(nums[mid] == target) return true;\\n            //Step 2\\n            if(nums[mid] == nums[left] && nums[mid] == nums[right])\\n            {\\n                left++;\\n                right--;\\n            }\\n            //Step 3\\n            else if(nums[mid] >= nums[left])\\n            {\\n                //Step 4 - Left half is sorted\\n                if(target > nums[mid] || target < nums[left])\\n                    left = mid + 1;\\n                else\\n                    right = mid - 1;\\n            }\\n            else\\n            {\\n                //Step 5 - Right half is sorted\\n                if(target < nums[mid] || target > nums[right])\\n                    right = mid - 1;\\n                else\\n                    left = mid + 1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n```python []\\nclass Solution(object):\\n    def search(self, nums, target):\\n        #Step 1\\n        left = 0\\n        right = len(nums)-1\\n        while left <= right:\\n            mid = left + (right - left)//2\\n\\n            #Step 6\\n            if nums[mid] == target:\\n                 return True\\n\\n            #Step 2\\n            if nums[mid] == nums[left] == nums[right]:\\n                left+=1\\n                right-=1\\n\\n            #Step 3\\n            elif nums[mid] >= nums[left]:\\n\\n                #Step 4\\n                if target > nums[mid] or target < nums[left]:\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n            else:\\n\\n                #Step 5\\n                if target < nums[mid] or target > nums[right]:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n\\n        return False\\n```\\n``` rust []\\nimpl Solution {\\n    pub fn search(nums: Vec<i32>, target: i32) -> bool {\\n        //Step 1\\n        let mut left : i32 = 0;\\n        let mut right: i32 = (nums.len() - 1) as i32;\\n        while left <= right {\\n            let mid = left + (right - left) / 2;\\n            //Step 6\\n            if nums[mid as usize] == target {\\n                return true;\\n            }\\n\\n            //Step 2\\n            if nums[mid as usize] == nums[left as usize] && nums[mid as usize] == nums[right as usize] {\\n                left +=1;\\n                right -=1;\\n            } \\n            //Step 3\\n            else if nums[mid as usize] >= nums[left as usize] {   \\n                //Step 4\\n                if target > nums[mid as usize] || target < nums[left as usize] {\\n                    left = mid + 1;\\n                } else {\\n                    right = mid - 1;\\n                }\\n            } else {\\n                //Step 5\\n                if target < nums[mid as usize] || target > nums[right as usize] {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n- Time complexity: $$O(log(n))$$ in the average case and $$O(n)$$ in the worst case, where `n` is the length of the input array. If all the elements in the input array are the same, we need to check each element in the array, which results in the worst case scenario with a time complexity of $$O(n)$$.\\n\\n- Space complexity: $$O(1)$$ because we use a constant amount of extra space to perform the search.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Application\\nThe \"Search in Rotated Sorted Array II\" problem have several real-life applications:\\n\\n1. **Inventory management:** In a warehouse, inventory lists may be sorted but can be rotated based on the aisle or rack location. The search problem can be used to find a specific item quickly.\\n\\n2. **Data encryption:** The search problem can be used in encryption algorithms to locate specific bits of data that have been rotated or shuffled to protect sensitive information.\\n\\n3. **DNA sequencing:** In bioinformatics, the search problem can be used to find specific sequences in rotated or transposed DNA data sets.\\n\\n4. **Image recognition:** locate specific objects or patterns in an image that have been rotated or flipped.\\n\\n5. **Supply chain management:** find a specific shipment in a list of orders that has been rotated based on delivery dates or locations.\\n\\n6. **Website indexing:** find specific web pages or content that have been rotated or shuffled to improve search results.\\n\\n*Thank you for reading! If you found this solution helpful, please give me an upvote. Feel free to add suggestions.*",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Rust",
                    "Binary Search"
                ],
                "code": "```java []\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        //Step 1\\n        int left = 0;\\n        int right = nums.length-1;\\n        while(left <= right)\\n        {\\n            int mid = left + (right - left)/2;\\n            //Step 6\\n            if(nums[mid] == target) return true;\\n            //Step 2\\n            if(nums[mid] == nums[left] && nums[mid] == nums[right])\\n            {\\n                left++;\\n                right--;\\n            }\\n            //Step 3\\n            else if(nums[mid] >= nums[left])\\n            {\\n                //Step 4 - Left half is sorted\\n                if(target > nums[mid] || target < nums[left])\\n                    left = mid + 1;\\n                else\\n                    right = mid - 1;\\n            }\\n            else\\n            {\\n                //Step 5 - Right half is sorted\\n                if(target < nums[mid] || target > nums[right])\\n                    right = mid - 1;\\n                else\\n                    left = mid + 1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```python []\\nclass Solution(object):\\n    def search(self, nums, target):\\n        #Step 1\\n        left = 0\\n        right = len(nums)-1\\n        while left <= right:\\n            mid = left + (right - left)//2\\n\\n            #Step 6\\n            if nums[mid] == target:\\n                 return True\\n\\n            #Step 2\\n            if nums[mid] == nums[left] == nums[right]:\\n                left+=1\\n                right-=1\\n\\n            #Step 3\\n            elif nums[mid] >= nums[left]:\\n\\n                #Step 4\\n                if target > nums[mid] or target < nums[left]:\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n            else:\\n\\n                #Step 5\\n                if target < nums[mid] or target > nums[right]:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n\\n        return False\\n```\n``` rust []\\nimpl Solution {\\n    pub fn search(nums: Vec<i32>, target: i32) -> bool {\\n        //Step 1\\n        let mut left : i32 = 0;\\n        let mut right: i32 = (nums.len() - 1) as i32;\\n        while left <= right {\\n            let mid = left + (right - left) / 2;\\n            //Step 6\\n            if nums[mid as usize] == target {\\n                return true;\\n            }\\n\\n            //Step 2\\n            if nums[mid as usize] == nums[left as usize] && nums[mid as usize] == nums[right as usize] {\\n                left +=1;\\n                right -=1;\\n            } \\n            //Step 3\\n            else if nums[mid as usize] >= nums[left as usize] {   \\n                //Step 4\\n                if target > nums[mid as usize] || target < nums[left as usize] {\\n                    left = mid + 1;\\n                } else {\\n                    right = mid - 1;\\n                }\\n            } else {\\n                //Step 5\\n                if target < nums[mid as usize] || target > nums[right as usize] {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3122240,
                "title": "best-2-lines-code-in-java-ever",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean search(int[] arr, int key) {\\n        for(int i = 0;i<arr.length;i++) if(arr[i]==key) return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean search(int[] arr, int key) {\\n        for(int i = 0;i<arr.length;i++) if(arr[i]==key) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569375,
                "title": "python-c-java-beginner-level-100-faster-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q81. Search in Rotated Sorted Array II***\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        nums.sort()\\n        if target in nums:\\n            return True\\n        else:\\n            return False       \\n```\\n**Runtime:**  65 ms\\t\\n**Memory Usage:**  14.6 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public boolean search(int[] n, int t) {\\n       int m,l=0,r=n.length-1;\\n        while(l<=r)\\n        {   m=l+r>>1;\\n            if (n[m]==t)\\n                return true;\\n            if((n[m]==n[l])&&(n[m]==n[r]))\\n            {   ++l;\\n                --r;\\n            }\\n            else if(n[m]>=n[l])\\n            {\\n                if((n[l]<=t)&&(n[m]>t))\\n                    r=m-1;\\n                else \\n                    l=m+1;\\n            }\\n            else{\\n                if((n[m]<t)&&n[r]>=t)\\n                    l=m+1;\\n                else \\n                    r=m-1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n**Runtime:**  1 ms\\t\\t\\n**Memory Usage:**  43..8 MB\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& n, int t) {\\n     int m,l=0,r=n.size()-1;\\n        while(l<=r)\\n        {   m=l+r>>1;\\n            if (n[m]==t)\\n                return true;\\n            if((n[m]==n[l])&&(n[m]==n[r]))\\n            {   ++l;\\n                --r;\\n            }\\n            else if(n[m]>=n[l])\\n            {\\n                if((n[l]<=t)&&(n[m]>t))\\n                    r=m-1;\\n                else \\n                    l=m+1;\\n            }\\n            else{\\n                if((n[m]<t)&&n[r]>=t)\\n                    l=m+1;\\n                else \\n                    r=m-1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```\\n**Runtime:** 0 ms\\t\\n**Memory Usage:**  14.3 MB\\t\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        nums.sort()\\n        if target in nums:\\n            return True\\n        else:\\n            return False       \\n```\n```\\nclass Solution {\\n    public boolean search(int[] n, int t) {\\n       int m,l=0,r=n.length-1;\\n        while(l<=r)\\n        {   m=l+r>>1;\\n            if (n[m]==t)\\n                return true;\\n            if((n[m]==n[l])&&(n[m]==n[r]))\\n            {   ++l;\\n                --r;\\n            }\\n            else if(n[m]>=n[l])\\n            {\\n                if((n[l]<=t)&&(n[m]>t))\\n                    r=m-1;\\n                else \\n                    l=m+1;\\n            }\\n            else{\\n                if((n[m]<t)&&n[r]>=t)\\n                    l=m+1;\\n                else \\n                    r=m-1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& n, int t) {\\n     int m,l=0,r=n.size()-1;\\n        while(l<=r)\\n        {   m=l+r>>1;\\n            if (n[m]==t)\\n                return true;\\n            if((n[m]==n[l])&&(n[m]==n[r]))\\n            {   ++l;\\n                --r;\\n            }\\n            else if(n[m]>=n[l])\\n            {\\n                if((n[l]<=t)&&(n[m]>t))\\n                    r=m-1;\\n                else \\n                    l=m+1;\\n            }\\n            else{\\n                if((n[m]<t)&&n[r]>=t)\\n                    l=m+1;\\n                else \\n                    r=m-1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2123303,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) \\n    {\\n        int rotate = 0;\\n        for(int i=0; i<nums.length-1; i++)                // Finding pivot\\n        {\\n            if(nums[i+1] - nums[i] < 0)\\n            {\\n                rotate = i+1;\\n                break;\\n            }\\n        }\\n        for(int i=0; i<rotate; i++)                       // Rotating equal to pivot\\n            rotate(nums); \\n\\t\\t\\t\\n        //  After rotation the array is sorted now so we can apply the Binary Search.\\n\\t\\t\\n        int start = 0;                                    // Binary Search on rotated and sorted array\\n        int end = nums.length - 1;\\n        while(start <= end)\\n        {\\n            int mid = start + (end - start) / 2;\\n            if(nums[mid] == target)\\n                return true;\\n            else if(nums[mid] > target)\\n                end = mid - 1;\\n            else\\n                start = mid + 1;\\n        }\\n        return false;\\n    }\\n    \\n\\t\\tvoid rotate(int a[])                                      // Rotate Array to left\\n    {   \\n        int temp = a[0];   \\n        for (int i = 0; i<a.length-1; i++)    \\n            a[i] = a[i + 1];  \\n        a[a.length - 1] = temp;   \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public boolean search(int[] nums, int target) \\n    {\\n        int rotate = 0;\\n        for(int i=0; i<nums.length-1; i++)                // Finding pivot\\n        {\\n            if(nums[i+1] - nums[i] < 0)\\n            {\\n                rotate = i+1;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1891912,
                "title": "java-o-logn-simple-solution-binary-search",
                "content": "**Approach 1**: Find the pivot and then do binary search.\\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int l = 0;\\n        int r = nums.length - 1;\\n        while (l < r) {\\n            int m = l + (r - l) / 2;\\n            if (nums[m] == target || nums[l] == target || nums[r] == target) {\\n                return true;\\n            } else if (nums[m] < nums[r]) {\\n                r = m - 1;\\n            } else if (nums[m] > nums[r]){\\n                l = m + 1;\\n            } else {\\n                // make sure it\\'s not skipping potential pivot if mid equals right \\n\\t\\t\\t\\t// e.g. [1,1,1,1,2,1]\\n                r--;\\n            }\\n        }\\n        int n = nums.length;\\n        // sorted range i from [l, l + 1, ... l + n - 1], \\n\\t\\t// which i % n is the real index in nums\\n\\t\\t// l = l, r = l + n - 1\\n        r = l + nums.length - 1;\\n        while(l <= r) {\\n            if(l >= r) return nums[l % n] == target;\\n            int m = l + (r - l) / 2;\\n            int mModed = m % n;\\n            if (nums[mModed] == target) {\\n                return true;\\n            } else if(nums[mModed] > target) {\\n                r = m - 1;\\n            } else {\\n                l = m + 1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n**Approach 2**: Binary search without getting the pivot\\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int l = 0, r = nums.length - 1;\\n        while(l <= r) {        \\n            int m = l + (r - l) / 2;\\n            // System.out.println(l + \" \"+ r + \" \" + m);\\n            if (nums[m] == target) {\\n                return true;\\n            }\\n            if (nums[m] == nums[r]) {\\n\\t\\t\\t    // make sure it\\'s not skipping potential pivot if mid equals right \\n\\t\\t\\t\\t// e.g. [1,1,1,1,2,1]\\n                r--;\\n            } else if (nums[m] > nums[r]) {\\n                // e.g. [4,5,6,7,8,1,2] target = 4\\n                if(nums[l] <= target && nums[m] > target) {\\n                    r = m - 1;\\n                } else {\\n                    l = m + 1;\\n                }                \\n            } else {\\n                // e.g. [7,8,1,2,3,4,5,6] target = 5\\n                if(nums[m] < target && target <= nums[r]) {\\n                    l = m + 1;                   \\n                } else {\\n                    r = m - 1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int l = 0;\\n        int r = nums.length - 1;\\n        while (l < r) {\\n            int m = l + (r - l) / 2;\\n            if (nums[m] == target || nums[l] == target || nums[r] == target) {\\n                return true;\\n            } else if (nums[m] < nums[r]) {\\n                r = m - 1;\\n            } else if (nums[m] > nums[r]){\\n                l = m + 1;\\n            } else {\\n                // make sure it\\'s not skipping potential pivot if mid equals right \\n\\t\\t\\t\\t// e.g. [1,1,1,1,2,1]\\n                r--;\\n            }\\n        }\\n        int n = nums.length;\\n        // sorted range i from [l, l + 1, ... l + n - 1], \\n\\t\\t// which i % n is the real index in nums\\n\\t\\t// l = l, r = l + n - 1\\n        r = l + nums.length - 1;\\n        while(l <= r) {\\n            if(l >= r) return nums[l % n] == target;\\n            int m = l + (r - l) / 2;\\n            int mModed = m % n;\\n            if (nums[mModed] == target) {\\n                return true;\\n            } else if(nums[mModed] > target) {\\n                r = m - 1;\\n            } else {\\n                l = m + 1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int l = 0, r = nums.length - 1;\\n        while(l <= r) {        \\n            int m = l + (r - l) / 2;\\n            // System.out.println(l + \" \"+ r + \" \" + m);\\n            if (nums[m] == target) {\\n                return true;\\n            }\\n            if (nums[m] == nums[r]) {\\n\\t\\t\\t    // make sure it\\'s not skipping potential pivot if mid equals right \\n\\t\\t\\t\\t// e.g. [1,1,1,1,2,1]\\n                r--;\\n            } else if (nums[m] > nums[r]) {\\n                // e.g. [4,5,6,7,8,1,2] target = 4\\n                if(nums[l] <= target && nums[m] > target) {\\n                    r = m - 1;\\n                } else {\\n                    l = m + 1;\\n                }                \\n            } else {\\n                // e.g. [7,8,1,2,3,4,5,6] target = 5\\n                if(nums[m] < target && target <= nums[r]) {\\n                    l = m + 1;                   \\n                } else {\\n                    r = m - 1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1891790,
                "title": "two-lines-solution-in-c-intuition-stl-only",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n\\t   // if element is present in vector, iterator would be pointing to the element or else to the end of vector\\n        if (find (nums.begin(),nums.end(),target) != nums.end() ) return true;\\n        else return false;\\n    }\\n\\t//Do Upvote if u find this useful\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n\\t   // if element is present in vector, iterator would be pointing to the element or else to the end of vector\\n        if (find (nums.begin(),nums.end(),target) != nums.end() ) return true;\\n        else return false;\\n    }\\n\\t//Do Upvote if u find this useful\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1336607,
                "title": "c-0ms-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n\\t\\t\\n\\t\\t // searching the starting point of the original array (without rotation)\\n\\t\\tint left=0, right=n-1;\\n        while(left< right and nums[left] >= nums[right]){  \\n            int mid = left + (right - left)/2; \\n            \\n            if(nums[mid] == target) return true;\\n            \\n            if(nums[mid] < nums[right] ) right = mid;\\n            else if(nums[mid] > nums[left]) left = mid+1;\\n            else if(right-1 >= 0 and nums[right-1] > nums[right]){left=right; break;}\\n            else right = right - 1;\\n        }\\n        \\n        int st ,ed;\\n        if(target <= nums[n-1] and target >= nums[left]){   // deciding the section to search\\n            st = left; ed = n-1;\\n        }else{\\n            st = 0; ed = left-1;\\n        }\\n        \\n        while(st <= ed){            // searching in that specific section\\n            int mid = st + (ed - st)/2;\\n            \\n            if(nums[mid] == target) return true;\\n            else if(nums[mid] < target) st = mid+1;\\n            else ed = mid-1;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n\\t\\t\\n\\t\\t // searching the starting point of the original array (without rotation)\\n\\t\\tint left=0, right=n-1;\\n        while(left< right and nums[left] >= nums[right]){  \\n            int mid = left + (right - left)/2; \\n            \\n            if(nums[mid] == target) return true;\\n            \\n            if(nums[mid] < nums[right] ) right = mid;\\n            else if(nums[mid] > nums[left]) left = mid+1;\\n            else if(right-1 >= 0 and nums[right-1] > nums[right]){left=right; break;}\\n            else right = right - 1;\\n        }\\n        \\n        int st ,ed;\\n        if(target <= nums[n-1] and target >= nums[left]){   // deciding the section to search\\n            st = left; ed = n-1;\\n        }else{\\n            st = 0; ed = left-1;\\n        }\\n        \\n        while(st <= ed){            // searching in that specific section\\n            int mid = st + (ed - st)/2;\\n            \\n            if(nums[mid] == target) return true;\\n            else if(nums[mid] < target) st = mid+1;\\n            else ed = mid-1;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 946004,
                "title": "java-intuitive-explanation",
                "content": "**Intution**\\n\\nIf we divide the array in half in any way, at least one of the subarrays should be sorted.\\n\\nWhy? Being otherwise would imply that the array was not originally sorted. We can picture this in a diagram: if we plot values of a sorted array in a line, however many times we rotate the line, we can always find a portion of the line where graident is non-decreasing.\\n\\n**Algorithm**\\n\\n* If `nums[mid]` is less than or equal to `nums[hi]`, we know that the right subarray is sorted.\\n  * If the target lies within the right subarray range, look right, otherwise look left.\\n* If the right subarray is not sorted, the left must be sorted.\\n  * If the target lies within the left subarray range, look left, otherwise look right.\\n\\n**Code**\\n\\n```java\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int n = nums.length;\\n        int lo = 0;\\n        int hi = n - 1;\\n        \\n        while (hi >= lo) {\\n            int mid = (hi - lo) / 2 + lo;\\n            int val = nums[mid];\\n            \\n            if (val == target || target == nums[hi] || target == nums[lo]) {\\n                return true;\\n            }\\n            \\n\\t\\t\\t// If we are unsure which half to search, simply decrease the search space by one at random.\\n            if (nums[hi] == nums[lo]) {\\n                hi--;\\n                continue;\\n            }\\n\\n            if (val <= nums[hi]) { // is right half sorted?\\n                if (val <= target && target <= nums[hi]) { // can the target lie in the right half?\\n                    lo = mid + 1;\\n                } else {\\n                    hi = mid - 1;\\n                }\\n            } else { // otherwise, the left-half must be sorted\\n                if (nums[lo] <= target && target <= val) { // can the target lie in the left half?\\n                    hi = mid - 1;                    \\n                } else {\\n                    lo = mid + 1;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n\\n**Analysis**\\n\\nSince we decrease the search space by 1 when we can\\'t tell which half to look to, the algorithm takes a linear time in the worst case.\\n\\nFormally, let `N` be the length of `nums`. The algorithm takes `~O(N)` time, and `~O(1)` space.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int n = nums.length;\\n        int lo = 0;\\n        int hi = n - 1;\\n        \\n        while (hi >= lo) {\\n            int mid = (hi - lo) / 2 + lo;\\n            int val = nums[mid];\\n            \\n            if (val == target || target == nums[hi] || target == nums[lo]) {\\n                return true;\\n            }\\n            \\n\\t\\t\\t// If we are unsure which half to search, simply decrease the search space by one at random.\\n            if (nums[hi] == nums[lo]) {\\n                hi--;\\n                continue;\\n            }\\n\\n            if (val <= nums[hi]) { // is right half sorted?\\n                if (val <= target && target <= nums[hi]) { // can the target lie in the right half?\\n                    lo = mid + 1;\\n                } else {\\n                    hi = mid - 1;\\n                }\\n            } else { // otherwise, the left-half must be sorted\\n                if (nums[lo] <= target && target <= val) { // can the target lie in the left half?\\n                    hi = mid - 1;                    \\n                } else {\\n                    lo = mid + 1;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 943119,
                "title": "clean-python-binary-search",
                "content": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        left, right = 0, len(nums) - 1\\n        while left <= right:\\n            m = left + right >> 1\\n            if nums[m] == target: return True\\n            \\n            while nums[left] == nums[m] == nums[right]:\\n                left += 1; right -= 1\\n                if left > right: return False\\n            \\n            if (target < nums[left], target) < (nums[m] < nums[left], nums[m]):\\n                right = m - 1\\n            else:\\n                left = m + 1\\n                \\n        return False\\n```\\n\\n* Easy way to solve an ambiguity of duplicates is to decrease window from both sides.\\n* Easy way to compare rotated numbers is to compare pairs of bool and int  (value < left, value).",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        left, right = 0, len(nums) - 1\\n        while left <= right:\\n            m = left + right >> 1\\n            if nums[m] == target: return True\\n            \\n            while nums[left] == nums[m] == nums[right]:\\n                left += 1; right -= 1\\n                if left > right: return False\\n            \\n            if (target < nums[left], target) < (nums[m] < nums[left], nums[m]):\\n                right = m - 1\\n            else:\\n                left = m + 1\\n                \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 942594,
                "title": "c-c-simple-efficient-iterative-binary-search-solution-with-explanations",
                "content": "```\\nbool search(int* nums, int numsSize, int target){\\n    int r = numsSize-1, l=0, mid = r/2;\\n    while (l <= r)\\n    {\\n        mid = l+(r-l)/2;\\n        if ((l == r) && (nums[l] != target)) //target wasn\\'t found\\n            return false;\\n\\n        if ((target == nums[mid]) || (target == nums[l]) || (target == nums[r])) // target found\\n            return true;\\n        \\n        if ((target >= nums[r]) && (target < nums[mid])) //target on left side\\n            r = mid-1;\\n \\n        else if ((target <= nums[l]) && (target > nums[mid])) //target on right side\\n            l = mid+1;\\n\\n        else if ((target <= nums[l])||(target >= nums[r])) //otherwise\\n        {\\n            if (nums[mid] <= nums[r])\\n            {\\n                r-=1;\\n                l+=1;\\n            }\\n            else\\n                l = mid+1;\\n        }\\n        else //regular binary search\\n        {\\n            if (target < nums[mid])\\n                r = mid-1;\\n            else if (target > nums[mid])\\n                l = mid+1;\\n        }\\n    }\\n    return false;\\n}\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nbool search(int* nums, int numsSize, int target){\\n    int r = numsSize-1, l=0, mid = r/2;\\n    while (l <= r)\\n    {\\n        mid = l+(r-l)/2;\\n        if ((l == r) && (nums[l] != target)) //target wasn\\'t found\\n            return false;\\n\\n        if ((target == nums[mid]) || (target == nums[l]) || (target == nums[r])) // target found\\n            return true;\\n        \\n        if ((target >= nums[r]) && (target < nums[mid])) //target on left side\\n            r = mid-1;\\n \\n        else if ((target <= nums[l]) && (target > nums[mid])) //target on right side\\n            l = mid+1;\\n\\n        else if ((target <= nums[l])||(target >= nums[r])) //otherwise\\n        {\\n            if (nums[mid] <= nums[r])\\n            {\\n                r-=1;\\n                l+=1;\\n            }\\n            else\\n                l = mid+1;\\n        }\\n        else //regular binary search\\n        {\\n            if (target < nums[mid])\\n                r = mid-1;\\n            else if (target > nums[mid])\\n                l = mid+1;\\n        }\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 784703,
                "title": "c-iterative-binary-search-simple-with-explanations",
                "content": "```\\nbool search(int* nums, int numsSize, int target){\\n    int r = numsSize-1, l=0, mid = r/2;\\n    while (l <= r)\\n    {\\n        mid = l+(r-l)/2;\\n        if ((l == r) && (nums[l] != target)) //target wasn\\'t found\\n            return false;\\n\\n        if ((target == nums[mid]) || (target == nums[l]) || (target == nums[r])) // target found\\n            return true;\\n        \\n        if ((target >= nums[r]) && (target < nums[mid])) //target on left side\\n            r = mid-1;\\n \\n        else if ((target <= nums[l]) && (target > nums[mid])) //target on right side\\n            l = mid+1;\\n\\n        else if ((target <= nums[l])||(target >= nums[r])) //otherwise\\n        {\\n            if (nums[mid] <= nums[r])\\n            {\\n                r-=1;\\n                l+=1;\\n            }\\n            else\\n                l = mid+1;\\n        }\\n        else //regular binary search\\n        {\\n            if (target < nums[mid])\\n                r = mid-1;\\n            else if (target > nums[mid])\\n                l = mid+1;\\n        }\\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool search(int* nums, int numsSize, int target){\\n    int r = numsSize-1, l=0, mid = r/2;\\n    while (l <= r)\\n    {\\n        mid = l+(r-l)/2;\\n        if ((l == r) && (nums[l] != target)) //target wasn\\'t found\\n            return false;\\n\\n        if ((target == nums[mid]) || (target == nums[l]) || (target == nums[r])) // target found\\n            return true;\\n        \\n        if ((target >= nums[r]) && (target < nums[mid])) //target on left side\\n            r = mid-1;\\n \\n        else if ((target <= nums[l]) && (target > nums[mid])) //target on right side\\n            l = mid+1;\\n\\n        else if ((target <= nums[l])||(target >= nums[r])) //otherwise\\n        {\\n            if (nums[mid] <= nums[r])\\n            {\\n                r-=1;\\n                l+=1;\\n            }\\n            else\\n                l = mid+1;\\n        }\\n        else //regular binary search\\n        {\\n            if (target < nums[mid])\\n                r = mid-1;\\n            else if (target > nums[mid])\\n                l = mid+1;\\n        }\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 345867,
                "title": "binary-search-solution-and-implication-of-duplicates-on-runtime-complexity",
                "content": "```python\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        lo, hi = 0, len(nums)\\n        while lo < hi:\\n            mid = (lo + hi)//2\\n            if nums[mid] == target:\\n                return True\\n            # if the right half is sorted, and the target happens to exist in \\n            # this half\\n            if nums[mid] < target <= nums[hi - 1]:\\n                lo = mid + 1\\n            # otherwise, if the right half is sorted, i.e., the number at the \\n            # left boundary is less than the right, the target must exist in the\\n            # left half\\n            elif nums[mid] < nums[hi - 1]:\\n                hi = mid\\n            # if the left half is sorted, and the target happens to exist in \\n            # this half\\n            elif nums[lo] <= target < nums[mid]:\\n                hi = mid\\n            # otherwise, if the left half is sorted, the target must exist in \\n            # the right half\\n            elif nums[lo] < nums[mid]:\\n                lo = mid + 1\\n            # if the numbers at the left and right boundaries are identical, \\n            # the numbers in between are identical, and we cannot tell which \\n            # side the target might be. So we shift the boundaries to help the \\n            # `mid` to escape the subarray of duplicate numbers\\n            elif nums[mid] == nums[hi - 1]:\\n                hi -= 1\\n            elif nums[mid] == nums[lo]:\\n                lo += 1\\n        return False\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        lo, hi = 0, len(nums)\\n        while lo < hi:\\n            mid = (lo + hi)//2\\n            if nums[mid] == target:\\n                return True\\n            # if the right half is sorted, and the target happens to exist in \\n            # this half\\n            if nums[mid] < target <= nums[hi - 1]:\\n                lo = mid + 1\\n            # otherwise, if the right half is sorted, i.e., the number at the \\n            # left boundary is less than the right, the target must exist in the\\n            # left half\\n            elif nums[mid] < nums[hi - 1]:\\n                hi = mid\\n            # if the left half is sorted, and the target happens to exist in \\n            # this half\\n            elif nums[lo] <= target < nums[mid]:\\n                hi = mid\\n            # otherwise, if the left half is sorted, the target must exist in \\n            # the right half\\n            elif nums[lo] < nums[mid]:\\n                lo = mid + 1\\n            # if the numbers at the left and right boundaries are identical, \\n            # the numbers in between are identical, and we cannot tell which \\n            # side the target might be. So we shift the boundaries to help the \\n            # `mid` to escape the subarray of duplicate numbers\\n            elif nums[mid] == nums[hi - 1]:\\n                hi -= 1\\n            elif nums[mid] == nums[lo]:\\n                lo += 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 315407,
                "title": "c-80-90-beat-o-n-usually-o-log-n-using-clever-skips",
                "content": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        \\n        int aLo = 0;\\n        int aHi = nums.size() - 1;\\n        \\n        while (aLo <= aHi) {\\n            \\n            //This gets us our sticky situation of [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 8, 2]\\n            while (aLo < aHi && nums[aLo] == nums[aLo + 1]) { ++aLo; }\\n            while (aLo < aHi && nums[aHi] == nums[aHi - 1]) { --aHi; }\\n            \\n            if (aLo <= aHi) {\\n                \\n                int aMid = (aLo + aHi) >> 1;\\n               \\n                if (nums[aMid] == target) { return true; }\\n                \\n                if (nums[aMid] <= nums[aHi]) {\\n                    if (target >= nums[aMid] && target <= nums[aHi]) {\\n                        aLo = aMid + 1;\\n                    } else {\\n                        aHi = aMid - 1;\\n                    }\\n                } else {\\n                    if (target >= nums[aLo] && target <= nums[aMid]) {\\n                        aHi = aMid - 1;   \\n                    } else {\\n                        aLo = aMid + 1;\\n                    }\\n                }   \\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n\\nGrip it good, grip it and go.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        \\n        int aLo = 0;\\n        int aHi = nums.size() - 1;\\n        \\n        while (aLo <= aHi) {\\n            \\n            //This gets us our sticky situation of [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 8, 2]\\n            while (aLo < aHi && nums[aLo] == nums[aLo + 1]) { ++aLo; }\\n            while (aLo < aHi && nums[aHi] == nums[aHi - 1]) { --aHi; }\\n            \\n            if (aLo <= aHi) {\\n                \\n                int aMid = (aLo + aHi) >> 1;\\n               \\n                if (nums[aMid] == target) { return true; }\\n                \\n                if (nums[aMid] <= nums[aHi]) {\\n                    if (target >= nums[aMid] && target <= nums[aHi]) {\\n                        aLo = aMid + 1;\\n                    } else {\\n                        aHi = aMid - 1;\\n                    }\\n                } else {\\n                    if (target >= nums[aLo] && target <= nums[aMid]) {\\n                        aHi = aMid - 1;   \\n                    } else {\\n                        aLo = aMid + 1;\\n                    }\\n                }   \\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28225,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Search in Rotated Sorted Array II** https://leetcode.com/problems/search-in-rotated-sorted-array-ii/\\n\\n**Algorithm**\\n* Finding a pivot and then doing bsearch will not work in this scenario.\\n* The ideas follow from Find minimum in Rotated Sorted Array and Finding Minimum with Duplicates.\\n* If mid is target, then return.\\n* If right is sorted, then bounds are adjusted based on whether target is contained in it or not.\\n* If left is sorted, then bounds are adjusted based on whether target is contained in it or not.\\n* Add the condition for nums[mid] == nums[high]\\n```\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        low, high = 0, len(nums)-1\\n        while low <= high:\\n            mid = low + int((high-low)/2)\\n            if nums[mid] == target:\\n                return True\\n            elif nums[mid] < nums[high]:\\n                if target >= nums[mid] and target <= nums[high]:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n            elif nums[mid] > nums[high]:\\n                if target >= nums[low] and target <= nums[mid]:\\n                    high = mid - 1\\n                else:\\n                    low = mid + 1\\n            else:\\n                high = high-1\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        low, high = 0, len(nums)-1\\n        while low <= high:\\n            mid = low + int((high-low)/2)\\n            if nums[mid] == target:\\n                return True\\n            elif nums[mid] < nums[high]:\\n                if target >= nums[mid] and target <= nums[high]:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n            elif nums[mid] > nums[high]:\\n                if target >= nums[low] and target <= nums[mid]:\\n                    high = mid - 1\\n                else:\\n                    low = mid + 1\\n            else:\\n                high = high-1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28242,
                "title": "simple-java-solution-using-binary-search",
                "content": "```\\npublic class Solution {\\n    public boolean search(int[] nums, int target) {\\n        int l=0,r=nums.length-1;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(nums[mid]==target) return true;\\n            if(nums[l]<nums[mid]){\\n                if(nums[l]<=target&&target<nums[mid]){\\n                    r=mid-1;\\n                }else{\\n                    l=mid+1;\\n                }\\n            }else if(nums[l]>nums[mid]){\\n                if(nums[mid]<target&&target<=nums[r]){\\n                    l=mid+1;\\n                }else{\\n                    r=mid-1;\\n                }\\n            }\\n            else{\\n                l++;\\n            }\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean search(int[] nums, int target) {\\n        int l=0,r=nums.length-1;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(nums[mid]==target) return true;\\n            if(nums[l]<nums[mid]){\\n                if(nums[l]<=target&&target<nums[mid]){\\n                    r=mid-1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 28309,
                "title": "my-concise-c-solution-with-explanation-o-n-worst-case-o-logn-on-average",
                "content": "The idea is the same as the previous one without duplicates\\n\\n    1) everytime check if targe == nums[mid], if so, we find it.\\n    2) otherwise, we check if the first half is in order (i.e. nums[left]<=nums[mid]) \\n      and if so, go to step 3), otherwise, the second half is in order,   go to step 4)\\n    3) check if target in the range of [left, mid-1] (i.e. nums[left]<=target < nums[mid]), if so, do search in the first half, i.e. right = mid-1; otherwise, search in the second half left = mid+1;\\n    4)  check if target in the range of [mid+1, right] (i.e. nums[mid]<target <= nums[right]), if so, do search in the second half, i.e. left = mid+1; otherwise search in the first half right = mid-1;\\n\\nThe only difference is that due to the existence of duplicates, we can have nums[left] == nums[mid] and in that case, the first half could be out of order (i.e. NOT in the ascending order, e.g. [3 1 2 3 3 3 3]) and we have to deal this case separately. In that case, it is guaranteed that nums[right] also equals to nums[mid], so what we can do is to check if nums[mid]== nums[left] == nums[right] before the original logic, and if so, we can move left and right both towards the middle by 1. and repeat.  \\n\\n    class Solution {\\n    public:\\n        bool search(vector<int>& nums, int target) {\\n            int left = 0, right =  nums.size()-1, mid;\\n            \\n            while(left<=right)\\n            {\\n                mid = (left + right) >> 1;\\n                if(nums[mid] == target) return true;\\n    \\n                // the only difference from the first one, trickly case, just updat left and right\\n                if( (nums[left] == nums[mid]) && (nums[right] == nums[mid]) ) {++left; --right;}\\n                else if(nums[left] <= nums[mid])\\n                {// first half is in order\\n                    if( (nums[left]<=target) && (nums[mid] > target) ) right = mid-1; // if target is in the first half\\n                    else left = mid + 1; \\n                }\\n                else\\n                { // second half is in order\\n                    if((nums[mid] < target) &&  (nums[right] >= target) ) left = mid+1; // if target is in the second half\\n                    else right = mid-1;\\n                }\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool search(vector<int>& nums, int target) {\\n            int left = 0, right =  nums.size()-1, mid;\\n            \\n            while(left<=right)\\n            {\\n                mid = (left + right) >> 1;\\n                if(nums[mid] == target) return true;\\n    \\n                // the only difference from the first one, trickly case, just updat left and right\\n                if( (nums[left] == nums[mid]) && (nums[right] == nums[mid]) ) {++left; --right;}",
                "codeTag": "Java"
            },
            {
                "id": 3918770,
                "title": "easy-c-solution-using-binary-search-very-easy-and-beginner-friendly-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int left = 0;\\n        int right = nums.size() - 1;\\n        \\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n            \\n            if (nums[left] == nums[mid] && nums[mid] == nums[right]) {\\n                // Handle the case where elements at left, mid, and right are equal\\n                ++left;\\n                --right;\\n            } else if (nums[left] <= nums[mid]) {\\n                if (target >= nums[left] && target < nums[mid]) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            } else {\\n                if (target > nums[mid] && target <= nums[right]) {\\n                    left = mid + 1;\\n                } else {\\n                    right = mid - 1;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int left = 0;\\n        int right = nums.size() - 1;\\n        \\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n            \\n            if (nums[left] == nums[mid] && nums[mid] == nums[right]) {\\n                // Handle the case where elements at left, mid, and right are equal\\n                ++left;\\n                --right;\\n            } else if (nums[left] <= nums[mid]) {\\n                if (target >= nums[left] && target < nums[mid]) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            } else {\\n                if (target > nums[mid] && target <= nums[right]) {\\n                    left = mid + 1;\\n                } else {\\n                    right = mid - 1;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3891516,
                "title": "c-solution-easy-to-understand-100-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        auto ans = find(nums.begin() , nums.end() , target);\\n\\n        if(ans!= nums.end())\\n        {\\n            return true;\\n        }\\n        else\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        auto ans = find(nums.begin() , nums.end() , target);\\n\\n        if(ans!= nums.end())\\n        {\\n            return true;\\n        }\\n        else\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888964,
                "title": "c-java-simple-and-easy-solution-binary-search",
                "content": "# Please Upvote if you liked my Solution \\uD83E\\uDD17\\uD83E\\uDD17\\n> **Please do UpVote** it took lot of time to figure out these solutions\\n\\n# Complexity \\n- Time complexity: $$O(N)$$ where `N = nums.length`. \\nBecause, in the worst case finding the pivot can take $$O(N)$$ time. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int t) {\\n        int n = nums.size(), l = 0, r = n-1, p = 0;\\n        \\n        // Find pivot index\\n        for(int i=1; i<n; i++){\\n            if( nums[i-1] > nums[i] ) {\\n                p = i;\\n                break;\\n            }\\n        }\\n\\n        while( l<=r ){\\n            int mid = (l+r)>>1;\\n            if( nums[mid] == t ) return true;\\n\\n            if( p <= mid ){\\n                // mid is in right of the pivot\\n                if( nums[mid] <= t && t <= nums[r] ) l = mid+1;\\n                else r = mid-1;\\n            }else{\\n                // mid is in the left of the pivot\\n                if( nums[l] <= t && t <= nums[mid] ) r = mid-1;\\n                else l = mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n---\\n\\n# Java Code\\n```\\nclass Solution {\\n    public boolean search(int[] nums, int t) {\\n        int n = nums.length, l = 0, r = n-1, p = 0;\\n        \\n        // Find pivot index\\n        for(int i=1; i<n; i++){\\n            if( nums[i-1] > nums[i] ) {\\n                p = i;\\n                break;\\n            }\\n        }\\n\\n        while( l<=r ){\\n            int mid = (l+r)>>1;\\n            if( nums[mid] == t ) return true;\\n\\n            if( p <= mid ){\\n                // mid is in right of the pivot\\n                if( nums[mid] <= t && t <= nums[r] ) l = mid+1;\\n                else r = mid-1;\\n            }else{\\n                // mid is in the left of the pivot\\n                if( nums[l] <= t && t <= nums[mid] ) r = mid-1;\\n                else l = mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n![upvote-4.png](https://assets.leetcode.com/users/images/5af4e2a5-e8b2-4f46-be00-75247cfdf9ff_1689947516.7818904.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int t) {\\n        int n = nums.size(), l = 0, r = n-1, p = 0;\\n        \\n        // Find pivot index\\n        for(int i=1; i<n; i++){\\n            if( nums[i-1] > nums[i] ) {\\n                p = i;\\n                break;\\n            }\\n        }\\n\\n        while( l<=r ){\\n            int mid = (l+r)>>1;\\n            if( nums[mid] == t ) return true;\\n\\n            if( p <= mid ){\\n                // mid is in right of the pivot\\n                if( nums[mid] <= t && t <= nums[r] ) l = mid+1;\\n                else r = mid-1;\\n            }else{\\n                // mid is in the left of the pivot\\n                if( nums[l] <= t && t <= nums[mid] ) r = mid-1;\\n                else l = mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean search(int[] nums, int t) {\\n        int n = nums.length, l = 0, r = n-1, p = 0;\\n        \\n        // Find pivot index\\n        for(int i=1; i<n; i++){\\n            if( nums[i-1] > nums[i] ) {\\n                p = i;\\n                break;\\n            }\\n        }\\n\\n        while( l<=r ){\\n            int mid = (l+r)>>1;\\n            if( nums[mid] == t ) return true;\\n\\n            if( p <= mid ){\\n                // mid is in right of the pivot\\n                if( nums[mid] <= t && t <= nums[r] ) l = mid+1;\\n                else r = mid-1;\\n            }else{\\n                // mid is in the left of the pivot\\n                if( nums[l] <= t && t <= nums[mid] ) r = mid-1;\\n                else l = mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888590,
                "title": "binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int t) {\\n        int n= nums.size();\\n        int low=0, high=n-1;\\n        while(low<=high)\\n        {\\n           int mid=low+(high-low)/2;\\n           if(nums[mid]==t)\\n           {return true;}\\n    else if((nums[low]==nums[mid]) && (nums[high]==nums[mid])){\\n                low++; high--;\\n            }\\n           else if(nums[low]<=nums[mid])\\n           {\\n              if(nums[low]<=t and t<nums[mid])\\n              {\\n                high=mid-1;\\n              }\\n              else\\n              {\\n                low=mid+1; \\n              }\\n           }\\n           else\\n           {\\n              if(nums[mid]<t and t<=nums[high])\\n              {\\n                low=mid+1;\\n              }\\n              else\\n              {\\n                high=mid-1;\\n              }\\n           }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int t) {\\n        int n= nums.size();\\n        int low=0, high=n-1;\\n        while(low<=high)\\n        {\\n           int mid=low+(high-low)/2;\\n           if(nums[mid]==t)\\n           {return true;}\\n    else if((nums[low]==nums[mid]) && (nums[high]==nums[mid])){\\n                low++; high--;\\n            }\\n           else if(nums[low]<=nums[mid])\\n           {\\n              if(nums[low]<=t and t<nums[mid])\\n              {\\n                high=mid-1;\\n              }\\n              else\\n              {\\n                low=mid+1; \\n              }\\n           }\\n           else\\n           {\\n              if(nums[mid]<t and t<=nums[high])\\n              {\\n                low=mid+1;\\n              }\\n              else\\n              {\\n                high=mid-1;\\n              }\\n           }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888307,
                "title": "tricky-binary-search-duplicates-handling-c",
                "content": "->Before commig over this Problem solve previous version of it.\\n->33. Search in Rotated Sorted Array\\n\\n->The idea is the same as the previous one without duplicates.\\n1.The only difference is that due to the existence of duplicates,\\narr[l] == arr[mid] && arr[r] == arr[mid] could be possible, the first half could be out of order\\n(i.e. not in the ascending order, e.g. {1,0,1,1,1})\\nwe have to deal this case separately.\\nThen move left and right both towards the middle by 1 and repeat.\\nALGORITHM\\n\\n2.Check for if target == nums[mid], if found return true.\\nWith duplicates we can have nums[l] == nums[r] so just update the l and r towards middle.\\n3.If not than check for first half is that in order (i.e nums[l] <= nums[mid]\\n4.check if target is in the range of [left, mid -1], if((nums[l] <= target) && (nums[mid] > target)) and search in it.\\nif not in first half search in second half.\\n5.Check if target is in range of [mid + 1, right], if((nums[mid] < target) && (nums[r]>= target)) and search in it.\\nCODE WITH EXPLANATION\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int left=0;\\n        int right=nums.size()-1;\\n        while(left <= right) {\\n            int mid=(left+right)/2;\\n// if found return true;\\n            if(nums[mid]==target) return true;\\n// condition with duplicates if arr[left] == arr[mid] == arr[right]\\n            if(nums[mid]==nums[left] && nums[right]==nums[mid]) {\\n                left++;\\n                right--;\\n// searching in first half\\n            } else if(nums[mid]>=nums[left]) {\\n                if(target>=nums[left] && target<nums[mid]) {\\n                    right=mid-1;\\n                } else {\\n                    left=mid+1;\\n                }\\n// searching in second half\\n            } else  {\\n                if(target<=nums[right] && target>nums[mid]) {\\n                    left=mid+1;\\n                } else {\\n                    right=mid-1;\\n                }\\n            }\\n        }\\n// not found return false\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Binary Search",
                    "Divide and Conquer",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int left=0;\\n        int right=nums.size()-1;\\n        while(left <= right) {\\n            int mid=(left+right)/2;\\n// if found return true;\\n            if(nums[mid]==target) return true;\\n// condition with duplicates if arr[left] == arr[mid] == arr[right]\\n            if(nums[mid]==nums[left] && nums[right]==nums[mid]) {\\n                left++;\\n                right--;\\n// searching in first half\\n            } else if(nums[mid]>=nums[left]) {\\n                if(target>=nums[left] && target<nums[mid]) {\\n                    right=mid-1;\\n                } else {\\n                    left=mid+1;\\n                }\\n// searching in second half\\n            } else  {\\n                if(target<=nums[right] && target>nums[mid]) {\\n                    left=mid+1;\\n                } else {\\n                    right=mid-1;\\n                }\\n            }\\n        }\\n// not found return false\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869103,
                "title": "easy-to-understand-two-solution",
                "content": "# Brute Force Solution\\n# Intuition\\nWe can do simple linear search\\n# Complexity\\n- Time Complexity:\\nWorst and Average Case -->\\n$$O(n)$$\\nBest Case -->\\n$$O(1)$$\\n\\n- Space Complexity:\\n$$O(1)$$\\n\\n**if the first value is the target value**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n# Optimal Solution\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere Sorted array is given to be searched. So we can think of applying **\"Binary Search\"**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn \"Search in rotated and sorted array\" we have to find out the sorted half by checking--\\n```\\nif(nums[mid]>=nums[low]) // Then left sorted\\nif(nums[mid]<=nums[high]) // Then right sorted\\n``` \\nBut in this case we can get a situation where,\\n```\\nnums[mid]==nums[low] && nums[mid]==nums[high]\\n```\\nIn such case it is hard to find out the sorted half\\n**So, in such case we will increase the pointer \"low\" and decrease the pointer \"high\". And we will continue the process as long as we get the above situation.**\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWorst Case -->\\n$$O(n/2)$$\\n**if all the elements are identical.**\\n\\nBest Case -->\\n$$O(logn)$$\\n**if the above condition does not arrives**\\n$$(nums[mid]==nums[low] && nums[mid]==nums[high])$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int low = 0;\\n        int high = nums.size()-1;\\n        // int ans = INT_MIN;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(nums[mid]==target){\\n                return true;\\n            }\\n            else if(nums[mid]==nums[low] && nums[mid]==nums[high]){\\n                low++;\\n                high--;\\n            }\\n            else if(nums[mid]>=nums[low]){\\n                if(nums[mid]>=target && nums[low]<=target){\\n                    high=mid-1;\\n                }else{\\n                    low=mid+1;\\n                }\\n            }else{\\n                if(nums[mid]<=target && nums[high]>=target){\\n                    low=mid+1;\\n                }else{\\n                    high=mid-1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n# Please Upvote if it was helpful\\u2B06\\uFE0F",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nif(nums[mid]>=nums[low]) // Then left sorted\\nif(nums[mid]<=nums[high]) // Then right sorted\\n```\n```\\nnums[mid]==nums[low] && nums[mid]==nums[high]\\n```\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int low = 0;\\n        int high = nums.size()-1;\\n        // int ans = INT_MIN;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(nums[mid]==target){\\n                return true;\\n            }\\n            else if(nums[mid]==nums[low] && nums[mid]==nums[high]){\\n                low++;\\n                high--;\\n            }\\n            else if(nums[mid]>=nums[low]){\\n                if(nums[mid]>=target && nums[low]<=target){\\n                    high=mid-1;\\n                }else{\\n                    low=mid+1;\\n                }\\n            }else{\\n                if(nums[mid]<=target && nums[high]>=target){\\n                    low=mid+1;\\n                }else{\\n                    high=mid-1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538084,
                "title": "simple-python-solution-using-binary-search",
                "content": "# Code\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        n=len(nums)\\n        low,high=0,n-1\\n        while low<=high:\\n            mid=low+(high-low)//2\\n            print(mid,end=\" \")\\n            if target==nums[mid]:\\n                return True\\n            if (nums[mid]==nums[low]) and (nums[mid]==nums[high]):\\n                low+=1\\n                high-=1\\n            elif nums[mid]>=nums[low]:\\n                if target>=nums[low] and target<=nums[mid]:\\n                    high=mid-1\\n                else:\\n                    low=mid+1\\n            else:\\n                if target<=nums[high] and target>=nums[mid]:\\n                    low=mid+1\\n                else:\\n                    high=mid-1\\n        return False\\n\\n\\n            \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        n=len(nums)\\n        low,high=0,n-1\\n        while low<=high:\\n            mid=low+(high-low)//2\\n            print(mid,end=\" \")\\n            if target==nums[mid]:\\n                return True\\n            if (nums[mid]==nums[low]) and (nums[mid]==nums[high]):\\n                low+=1\\n                high-=1\\n            elif nums[mid]>=nums[low]:\\n                if target>=nums[low] and target<=nums[mid]:\\n                    high=mid-1\\n                else:\\n                    low=mid+1\\n            else:\\n                if target<=nums[high] and target>=nums[mid]:\\n                    low=mid+1\\n                else:\\n                    high=mid-1\\n        return False\\n\\n\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510953,
                "title": "java-solution-for-search-in-a-rotated-array-ii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is similar to the previous implementation for searching in a rotated sorted array. However, this modified version handles the case where there are duplicate elements in the array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The code initializes the left and right pointers, representing the indices of the leftmost and rightmost elements in the search range.\\n2. It enters a while loop where the search range is not empty (left <= right).\\n3. In each iteration, the code calculates the middle index mid as the average of the left and right indices.\\n4. If the target is equal to the element at the mid index, the function returns true indicating that the target is found.\\n5. If the element at the left index is less than the element at the mid index, it means the left half of the array is sorted in ascending order.\\n- If the target is within the range of the left half (between left and mid), the right pointer is updated to mid - 1 to continue the search in the left half.\\n- Otherwise, the left pointer is updated to mid + 1 to search in the right half.\\n6. If the element at the left index is greater than the element at the mid index, it means the right half of the array is sorted in ascending order.\\n- If the target is within the range of the right half (between mid and right), the left pointer is updated to mid + 1 to continue the search in the right half.\\n- Otherwise, the right pointer is updated to mid - 1 to search in the left half.\\n7. If the element at the left index is equal to the element at the mid index, it means there are duplicates present.\\n- In this case, the left pointer is incremented by 1 to narrow down the search range and eliminate the duplicate element.\\n8. If the target is not found in the array, the while loop terminates, and the function returns false indicating that the target is not present in the array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the modified binary search algorithm is O(n) in the worst case, where n is the length of the input array. This occurs when all elements in the array are the same, and we have to traverse the entire array to determine if the target is present or not.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(1) because it uses a constant amount of extra space for the variables left, right, and mid. The space does not depend on the input size.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int left=0;\\n        int right=nums.length-1;\\n        while(left<=right)\\n        {\\n            int mid = (left+right)/2;\\n            if(nums[mid]==target)\\n                return true;\\n            if(nums[left]<nums[mid])\\n            {\\n                if(nums[left]<=target&& target<nums[mid])\\n                {\\n                    right=mid-1;\\n                }\\n                else\\n                {\\n                    left=mid+1;\\n                }\\n            }\\n            else if(nums[left]>nums[mid])\\n            {\\n                if(nums[mid]<target&&target<=nums[right])\\n                {\\n                    left=mid+1;\\n                }\\n                else\\n                {\\n                    right=mid-1;\\n                }\\n            }\\n            else\\n            {\\n                left++;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int left=0;\\n        int right=nums.length-1;\\n        while(left<=right)\\n        {\\n            int mid = (left+right)/2;\\n            if(nums[mid]==target)\\n                return true;\\n            if(nums[left]<nums[mid])\\n            {\\n                if(nums[left]<=target&& target<nums[mid])\\n                {\\n                    right=mid-1;\\n                }\\n                else\\n                {\\n                    left=mid+1;\\n                }\\n            }\\n            else if(nums[left]>nums[mid])\\n            {\\n                if(nums[mid]<target&&target<=nums[right])\\n                {\\n                    left=mid+1;\\n                }\\n                else\\n                {\\n                    right=mid-1;\\n                }\\n            }\\n            else\\n            {\\n                left++;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232477,
                "title": "best-approach-easy-to-understand-o-logn-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBinary search\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(logn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) \\n    {\\n        int low = 0;\\n        int high = nums.size()-1;\\n        while(low <= high)\\n        {\\n            int mid = (low + high)/2;\\n            if(nums[mid] == target)\\n            {\\n                return true;\\n            }\\n            if((nums[low] == nums[mid]) && (nums[high] == nums[mid]))\\n            {\\n               low++;\\n               high--;\\n            }\\n            else if(nums[low] <= nums[mid])\\n            {\\n                if(target >= nums[low] && target < nums[mid])\\n                {\\n                    high = mid-1;\\n                }\\n                else\\n                {\\n                    low = mid + 1;\\n                }\\n            }\\n            else\\n            {\\n                if(target > nums[mid] && target <= nums[high])\\n                {\\n                    low = mid + 1;\\n                }\\n                else\\n                {\\n                    high = mid -1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) \\n    {\\n        int low = 0;\\n        int high = nums.size()-1;\\n        while(low <= high)\\n        {\\n            int mid = (low + high)/2;\\n            if(nums[mid] == target)\\n            {\\n                return true;\\n            }\\n            if((nums[low] == nums[mid]) && (nums[high] == nums[mid]))\\n            {\\n               low++;\\n               high--;\\n            }\\n            else if(nums[low] <= nums[mid])\\n            {\\n                if(target >= nums[low] && target < nums[mid])\\n                {\\n                    high = mid-1;\\n                }\\n                else\\n                {\\n                    low = mid + 1;\\n                }\\n            }\\n            else\\n            {\\n                if(target > nums[mid] && target <= nums[high])\\n                {\\n                    low = mid + 1;\\n                }\\n                else\\n                {\\n                    high = mid -1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3183459,
                "title": "81-search-in-rotated-sorted-array-ii-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Define two pointers left and right that point to the first and last elements of the array.\\n\\n2. In the binary search loop, calculate the middle index mid as the average of left and right.\\n\\n3. If the target is equal to the middle element, return True.\\n\\n4. If the left part is sorted (nums[left] < nums[mid]), we check if the target is in the left part. If it is, we update right to mid - 1 and search in the left part. If it is not, we update left to mid + 1 and search in the right part.\\n\\n5. If the right part is sorted (nums[left] > nums[mid]), we check if the target is in the right part. If it is, we update left to mid + 1 and search in the right part. If it is not, we update right to mid - 1 and search in the left part.\\n\\n6. If nums[left] == nums[mid], we cannot determine which part is sorted, so we have to search both parts. To avoid infinite loop, we increase left by 1 and search again.\\n\\n7. Repeat the binary search loop until left is greater than right or the target is found.\\n\\n8. If the target is not found, return False.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        # define left and right pointers\\n        left, right = 0, len(nums) - 1\\n        \\n        # binary search loop\\n        while left <= right:\\n            # calculate the middle index\\n            mid = left + (right - left) // 2\\n            \\n            # if the target is equal to the middle element, return True\\n            if nums[mid] == target:\\n                return True\\n            \\n            # if the left part is sorted\\n            if nums[left] < nums[mid]:\\n                # if the target is in the left part\\n                if nums[left] <= target < nums[mid]:\\n                    # search in the left part\\n                    right = mid - 1\\n                else:\\n                    # search in the right part\\n                    left = mid + 1\\n            # if the right part is sorted\\n            elif nums[left] > nums[mid]:\\n                # if the target is in the right part\\n                if nums[mid] < target <= nums[right]:\\n                    # search in the right part\\n                    left = mid + 1\\n                else:\\n                    # search in the left part\\n                    right = mid - 1\\n            # if nums[left] == nums[mid], we cannot determine which part is sorted\\n            # so we have to search both parts\\n            else:\\n                left += 1\\n        \\n        # if the target is not found, return False\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        # define left and right pointers\\n        left, right = 0, len(nums) - 1\\n        \\n        # binary search loop\\n        while left <= right:\\n            # calculate the middle index\\n            mid = left + (right - left) // 2\\n            \\n            # if the target is equal to the middle element, return True\\n            if nums[mid] == target:\\n                return True\\n            \\n            # if the left part is sorted\\n            if nums[left] < nums[mid]:\\n                # if the target is in the left part\\n                if nums[left] <= target < nums[mid]:\\n                    # search in the left part\\n                    right = mid - 1\\n                else:\\n                    # search in the right part\\n                    left = mid + 1\\n            # if the right part is sorted\\n            elif nums[left] > nums[mid]:\\n                # if the target is in the right part\\n                if nums[mid] < target <= nums[right]:\\n                    # search in the right part\\n                    left = mid + 1\\n                else:\\n                    # search in the left part\\n                    right = mid - 1\\n            # if nums[left] == nums[mid], we cannot determine which part is sorted\\n            # so we have to search both parts\\n            else:\\n                left += 1\\n        \\n        # if the target is not found, return False\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166744,
                "title": "simple-c-code-using-binary-search-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int n=nums.size(),l=0,r=n-1,m=0;\\n        sort(nums.begin(),nums.end());\\n        while(l<=r){\\n            m=l+(r-l)/2;\\n            if(nums[m]==target) return true;\\n            if(nums[m]>=nums[l]){\\n                if(nums[m]>=target && nums[l]<=target) r=m-1;\\n                else l=m+1;\\n            }\\n            else {\\n                if(nums[m]<=target && nums[r]>=target) l=m+1;\\n                else r=l-1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\nDo UPVOTE if you like\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int n=nums.size(),l=0,r=n-1,m=0;\\n        sort(nums.begin(),nums.end());\\n        while(l<=r){\\n            m=l+(r-l)/2;\\n            if(nums[m]==target) return true;\\n            if(nums[m]>=nums[l]){\\n                if(nums[m]>=target && nums[l]<=target) r=m-1;\\n                else l=m+1;\\n            }\\n            else {\\n                if(nums[m]<=target && nums[r]>=target) l=m+1;\\n                else r=l-1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\nDo UPVOTE if you like\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148174,
                "title": "java-solution-0-ms-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int low=0;\\n        int high=nums.length-1;\\n        while(low<=high)\\n        {\\n            int mid = low+(high-low)/2;\\n            if(nums[mid]==target)\\n                return true;\\n            if((nums[mid]==nums[low])&&(nums[high]==nums[mid]))\\n            {\\n                low++;\\n                high--;\\n            }\\n            else if (nums[mid]>=nums[low])\\n            {\\n                if(target>=nums[low]&&target<nums[mid])\\n                    high = mid-1;\\n                else\\n                    low = mid+1;\\n            }\\n            else\\n            {\\n                if(target>nums[mid]&&target<=nums[high])\\n                    low = mid+1;\\n                else\\n                    high = mid-1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int low=0;\\n        int high=nums.length-1;\\n        while(low<=high)\\n        {\\n            int mid = low+(high-low)/2;\\n            if(nums[mid]==target)\\n                return true;\\n            if((nums[mid]==nums[low])&&(nums[high]==nums[mid]))\\n            {\\n                low++;\\n                high--;\\n            }\\n            else if (nums[mid]>=nums[low])\\n            {\\n                if(target>=nums[low]&&target<nums[mid])\\n                    high = mid-1;\\n                else\\n                    low = mid+1;\\n            }\\n            else\\n            {\\n                if(target>nums[mid]&&target<=nums[high])\\n                    low = mid+1;\\n                else\\n                    high = mid-1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3138096,
                "title": "easy-c-solution-binary-search-linear-search-brute-force-optimize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can Solved this question using Two approach.\\n\\n1. Using Linear Search (Brute Force).\\n2. Using Linear Search + Binary Search (Optimize).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity provided in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity provided in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N), because in the worst case, the target element may be present at the end of the array.\\n    Thus the time complexity is linear.\\n\\n    Space Complexity : O(1), the space complexity is constant.\\n\\n    Solved Using linear Search + Array.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int n= nums.size();\\n        for(int i=0; i<n; i++){\\n            if(nums[i] == target){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), worst case, O(log\\u2061N) best case, where N is the length of the input array(nums).\\n    \\n    Worst case : This happens when all the elements are the same and we search for some different element. At each\\n    step, we will only be able to reduce the search space by 1 since arr[mid] equals arr[start] and it\\'s not\\n    possible to decide the relative position of target from arr[mid]. Example: [1, 1, 1, 1, 1, 1, 1], target = 2.\\n\\n    Best case: This happens when all the elements are distinct. At each step, we will be able to divide our search\\n    space into half just like a normal binary search.\\n\\n\\n    Space Complexity : O(1), since we stored only some constant number of elements, the space complexity is\\n    constant.\\n\\n    Solved Using linear Search + Binary Search + Array.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int low = 0;\\n        int high = nums.size()-1;\\n        while(low <= high){\\n            while(low < high && nums[low] == nums[low+1]){\\n                low++;\\n            }\\n            while(low < high && nums[high-1] == nums[high]){\\n                high--;\\n            }\\n            int mid = (low + high) >> 1;\\n            if(nums[mid] == target){\\n                return true;\\n            }\\n            if(nums[low] <= nums[mid]){\\n                if(nums[low] <= target && nums[mid] > target){\\n                    high = mid - 1;\\n                }\\n                else{\\n                    low = mid + 1;\\n                }\\n            }\\n            else{\\n                if(target > nums[mid] && target <= nums[high]){\\n                    low = mid + 1;\\n                }\\n                else{\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N), because in the worst case, the target element may be present at the end of the array.\\n    Thus the time complexity is linear.\\n\\n    Space Complexity : O(1), the space complexity is constant.\\n\\n    Solved Using linear Search + Array.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int n= nums.size();\\n        for(int i=0; i<n; i++){\\n            if(nums[i] == target){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), worst case, O(log\\u2061N) best case, where N is the length of the input array(nums).\\n    \\n    Worst case : This happens when all the elements are the same and we search for some different element. At each\\n    step, we will only be able to reduce the search space by 1 since arr[mid] equals arr[start] and it\\'s not\\n    possible to decide the relative position of target from arr[mid]. Example: [1, 1, 1, 1, 1, 1, 1], target = 2.\\n\\n    Best case: This happens when all the elements are distinct. At each step, we will be able to divide our search\\n    space into half just like a normal binary search.\\n\\n\\n    Space Complexity : O(1), since we stored only some constant number of elements, the space complexity is\\n    constant.\\n\\n    Solved Using linear Search + Binary Search + Array.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int low = 0;\\n        int high = nums.size()-1;\\n        while(low <= high){\\n            while(low < high && nums[low] == nums[low+1]){\\n                low++;\\n            }\\n            while(low < high && nums[high-1] == nums[high]){\\n                high--;\\n            }\\n            int mid = (low + high) >> 1;\\n            if(nums[mid] == target){\\n                return true;\\n            }\\n            if(nums[low] <= nums[mid]){\\n                if(nums[low] <= target && nums[mid] > target){\\n                    high = mid - 1;\\n                }\\n                else{\\n                    low = mid + 1;\\n                }\\n            }\\n            else{\\n                if(target > nums[mid] && target <= nums[high]){\\n                    low = mid + 1;\\n                }\\n                else{\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105512,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& a, int k) {\\n        int l=0;\\n       int h=a.size()-1;\\n       while(l<=h){\\n            int mid=(l+h)/2;\\n            \\n            if(a[mid]==k) return true;\\n            if((a[l]==a[mid]) && (a[h]==a[mid]))\\n            {\\n                l++;\\n                h--;\\n            }\\n            else if(a[l]<=a[mid]){\\n                if(k>=a[l] && k<a[mid]){\\n                    h=mid-1;\\n                }\\n                else{\\n                    l=mid+1;\\n                }\\n            }\\n            else{\\n                if(k<=a[h] && k>a[mid]){\\n                    l=mid+1;\\n                }\\n                else{\\n                    h=mid-1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& a, int k) {\\n        int l=0;\\n       int h=a.size()-1;\\n       while(l<=h){\\n            int mid=(l+h)/2;\\n            \\n            if(a[mid]==k) return true;\\n            if((a[l]==a[mid]) && (a[h]==a[mid]))\\n            {\\n                l++;\\n                h--;\\n            }\\n            else if(a[l]<=a[mid]){\\n                if(k>=a[l] && k<a[mid]){\\n                    h=mid-1;\\n                }\\n                else{\\n                    l=mid+1;\\n                }\\n            }\\n            else{\\n                if(k<=a[h] && k>a[mid]){\\n                    l=mid+1;\\n                }\\n                else{\\n                    h=mid-1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945640,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int l=0, h=n-1, m;\\n        while(l<=h)\\n        {\\n            m=(l+h)/2;\\n            if(nums[m]==target)\\n            return true;\\n            if((nums[l] == nums[m]) && (nums[h] == nums[m]))\\n            {\\n                l++;\\n                h--;\\n            }\\n            else if(nums[l]<=nums[m])\\n            {\\n                if(target>=nums[l] && target<nums[m])\\n                h=m-1;\\n                else\\n                l=m+1;\\n            }\\n            else \\n            {\\n                if(target>nums[m] && target<=nums[h])\\n                    l=m+1;\\n                else\\n                    h=m-1;\\n            }\\n        }\\n        return false; \\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int l=0, h=n-1, m;\\n        while(l<=h)\\n        {\\n            m=(l+h)/2;\\n            if(nums[m]==target)\\n            return true;\\n            if((nums[l] == nums[m]) && (nums[h] == nums[m]))\\n            {\\n                l++;\\n                h--;\\n            }\\n            else if(nums[l]<=nums[m])\\n            {\\n                if(target>=nums[l] && target<nums[m])\\n                h=m-1;\\n                else\\n                l=m+1;\\n            }\\n            else \\n            {\\n                if(target>nums[m] && target<=nums[h])\\n                    l=m+1;\\n                else\\n                    h=m-1;\\n            }\\n        }\\n        return false; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850333,
                "title": "c-unique-intuitive-approach-o-log-n",
                "content": "```\\n\\n\\nclass Solution {\\npublic:\\n    bool search(vector<int>& A, int Key) {\\n        int st=0;\\n        int en=A.size()-1;\\n        while(st<=en){\\n            int mid=(st+en)/2;\\n            if(A[mid]==Key){\\n                return true;\\n            }\\n            if(A[mid]==A[st] && A[mid]==A[en]){\\n                st++;\\n                en--;\\n            }\\n            else if(A[st]<= A[mid]){\\n                if(A[st]<=Key && A[mid]>Key){\\n                    en=mid-1;\\n                }\\n                else{\\n                    st=mid+1;\\n                }\\n            }\\n            else{\\n                if(A[en]>=Key && A[mid]<Key){\\n                    st=mid+1;\\n                }\\n                else{\\n                    en=mid-1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    bool search(vector<int>& A, int Key) {\\n        int st=0;\\n        int en=A.size()-1;\\n        while(st<=en){\\n            int mid=(st+en)/2;\\n            if(A[mid]==Key){\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2619772,
                "title": "python-solution-99-faster",
                "content": "***Upvote if you like the solution!!!***\\n\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        s = 0\\n        e = len(nums) - 1\\n        while s <= e:\\n            mid = (s + e) // 2\\n            if nums[mid] == target or nums[s] == target or nums[e] == target:\\n                return True\\n            elif nums[mid] == nums[s] == nums[e]:\\n                s += 1\\n                e -= 1\\n            elif nums[mid] >= nums[s]:\\n                if nums[s] <= target <nums[mid]:\\n                    e = mid - 1\\n                else:\\n                    s = mid + 1\\n            else:\\n                if nums[mid] < target <= nums[e]:\\n                    s = mid + 1\\n                else:\\n                    e = mid - 1\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        s = 0\\n        e = len(nums) - 1\\n        while s <= e:\\n            mid = (s + e) // 2\\n            if nums[mid] == target or nums[s] == target or nums[e] == target:\\n                return True\\n            elif nums[mid] == nums[s] == nums[e]:\\n                s += 1\\n                e -= 1\\n            elif nums[mid] >= nums[s]:\\n                if nums[s] <= target <nums[mid]:\\n                    e = mid - 1\\n                else:\\n                    s = mid + 1\\n            else:\\n                if nums[mid] < target <= nums[e]:\\n                    s = mid + 1\\n                else:\\n                    e = mid - 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2107260,
                "title": "customized-binary-search-c-explained-with-comments-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        \\n        int l=0,h=nums.size()-1;\\n        int m;\\n        \\n        while(l<=h){\\n            \\n            m=l+(h-l)/2;\\n            \\n            if(nums[m]==target)\\n                return true;\\n                        \\n            //check if left part is surely sorted \\n\\n            else if(nums[m]>nums[l]){\\n                if(nums[l]<=target && nums[m]>target)//if it falls in the range\\n                    h=m-1;   //continue left search\\n                else\\n                    l=m+1;// if it is not in the range of left sorted part then its surely on right\\n            }\\n            //if left part isnt sorted then check if right part is obviously sorted\\n            else if(nums[m]<nums[h]){\\n                if(nums[m]<target && nums[h]>=target)  //if it fall in the sorted rage continue search\\n                    l=m+1;\\n                else\\n                    h=m-1;  //else search on left part\\n            }\\n            else{              //if its not sure whether left or right part is sorted do check if last elemnt is the target or not..if not.reduce the search space from end\\n                if(nums[h]==target)\\n                    return h;\\n                h--;\\n            }\\n               \\n        }\\n         return false;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        \\n        int l=0,h=nums.size()-1;\\n        int m;\\n        \\n        while(l<=h){\\n            \\n            m=l+(h-l)/2;\\n            \\n            if(nums[m]==target)\\n                return true;\\n                        \\n            //check if left part is surely sorted \\n\\n            else if(nums[m]>nums[l]){\\n                if(nums[l]<=target && nums[m]>target)//if it falls in the range\\n                    h=m-1;   //continue left search\\n                else\\n                    l=m+1;// if it is not in the range of left sorted part then its surely on right\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2006583,
                "title": "binary-search-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        //This problem can br solved by thinking it in two steps\\n        \\n        //1st find the pivot point i.e point or index of least element.\\n        //In this way we can divide the array into two parts\\n        \\n        //2nd Search for the target in both the halves and if you get return true\\n        \\n        \\n        //Step 1\\n        int lo = 0;\\n        int  hi = nums.size() - 1;\\n        int k=0;\\n        \\n        //This is an important step to make sure that if array has multiple pivot points then we screen them as they are unusual\\n        //Consider the TC [1,1,1,1,2,1,1,1,1] and target=2\\n        while(hi>0 && nums[hi]==nums[lo])\\n            hi--;\\n        k = hi;\\n        while(lo<hi)\\n        {\\n            int mid = lo+(hi-lo)/2;\\n            if(nums[mid]>nums[hi]){\\n                lo = mid+1;\\n            }\\n            else if(nums[mid]<nums[hi]){\\n                hi = mid;\\n            }\\n            else{\\n                hi = hi-1;\\n            }\\n        }\\n        \\n        int p = lo;\\n        hi = k;\\n        if(target>nums[hi])\\n        {\\n            lo = 0;\\n            hi = p-1;\\n        }\\n        else{\\n            lo = p;\\n            hi = k;\\n        }\\n        \\n        \\n        while(lo<=hi)\\n        {\\n            int mid = lo+(hi-lo)/2;\\n            \\n            if(nums[mid]==target)\\n            {\\n                return true;\\n            }\\n            \\n            if(nums[mid]<target)\\n                lo = mid+1;\\n            else\\n                hi = mid-1;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        //This problem can br solved by thinking it in two steps\\n        \\n        //1st find the pivot point i.e point or index of least element.\\n        //In this way we can divide the array into two parts\\n        \\n        //2nd Search for the target in both the halves and if you get return true\\n        \\n        \\n        //Step 1\\n        int lo = 0;\\n        int  hi = nums.size() - 1;\\n        int k=0;\\n        \\n        //This is an important step to make sure that if array has multiple pivot points then we screen them as they are unusual\\n        //Consider the TC [1,1,1,1,2,1,1,1,1] and target=2\\n        while(hi>0 && nums[hi]==nums[lo])\\n            hi--;\\n        k = hi;\\n        while(lo<hi)\\n        {\\n            int mid = lo+(hi-lo)/2;\\n            if(nums[mid]>nums[hi]){\\n                lo = mid+1;\\n            }\\n            else if(nums[mid]<nums[hi]){\\n                hi = mid;\\n            }\\n            else{\\n                hi = hi-1;\\n            }\\n        }\\n        \\n        int p = lo;\\n        hi = k;\\n        if(target>nums[hi])\\n        {\\n            lo = 0;\\n            hi = p-1;\\n        }\\n        else{\\n            lo = p;\\n            hi = k;\\n        }\\n        \\n        \\n        while(lo<=hi)\\n        {\\n            int mid = lo+(hi-lo)/2;\\n            \\n            if(nums[mid]==target)\\n            {\\n                return true;\\n            }\\n            \\n            if(nums[mid]<target)\\n                lo = mid+1;\\n            else\\n                hi = mid-1;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893326,
                "title": "c-0ms-faster-than-100-o-log-n-k-o-k-k-is-rotated-duplicated-number",
                "content": "I think this is the best solution for this problem, please just correct me \\nif my thinking is wrong.\\n\\n\\n# Define rotated duplicated number\\nIf nums is [8,9,9,9,9,0,1,2,3,4,4,5,5,5,6,6,6,7,7,7,8], the \\nrotated duplicated number K = 2. \\nBecause 8 is the the only **rotated duplicated number** in nums and \\nthere are K=2 number of 8 in nums. \\nif nums is [9,0,1,7,7,7,7,7,.....7,8], the **rotated duplicated number** here is 0\\nbecause there is no any value repeat in nums[0] and nums[n-1]. \\n\\n\\nDepdend on the solution of Search In Rotated Sorted Array, we can \\nkeep going to improve solution to become the solution of Rotated Sorted Array II \\nMy solution of Search In Rotated Sorted Array in this forum is here\\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/discuss/1891071/C%2B%2B-or-binary-like-search-approach-or-recursive-and-iterative-solution-or-O(logN)\\n\\nAnd I only need to do preprocessing for \\nrotated duplicated number before searching. \\n        \\nConsider the case like this\\n[999....999... 0,0,1,2,3,4,5,6,7,8,8 ...999...999 ...999 ...999 ...999] \\nwith target = 6, and we want to only take care the nums = [0,0,1,2,3,4,5,6,7,8,8] \\nwith target =6  after preprocessing procedure.\\n\\n```C++\\nif(a[L] == a[R]) {\\n\\tif (t==a[L]) return true;\\n\\tint i, same = a[L];\\n\\tfor(i=L;a[i]==same && ++i<R;);\\n\\tL = i;\\n\\tfor(i=R;a[i]==same && --i>L;);\\n\\tR = i;\\n} \\n```\\n\\nThus , the solution is the following code.\\n\\n```C++\\nclass Solution {\\npublic:\\n    bool search(vector<int>& a, int t) {\\n        int L = 0, R = a.size() - 1;\\n        if(a[L] == a[R]) {\\n            if (t==a[L]) return true;\\n            int i, same = a[L];\\n            for(i=L;a[i]==same && ++i<R;);\\n            L = i;\\n            for(i=R;a[i]==same && --i>L;);\\n            R = i;\\n        }\\n\\n        while(L<=R) {\\n            int M = L + (R-L)/2; \\n            if(a[M] == t) return true;            \\n            if(a[M]>=a[L])  //case M is in left-up raising edge\\n                if(a[L]<=t && t<=a[M]) \\n                    return binary_search(L,M-1,t,a);\\n                else \\n                    L = M+1;\\n            else //case M is in bottom-down raising edge\\n                if(a[M]<=t && t<=a[R]) \\n                    return binary_search(M+1,R,t,a);\\n                else \\n                    R = M-1;\\n        }\\n        return false;\\n    }\\n        \\n    bool binary_search(int L, int R, int t, vector<int>& a) {\\n        while(L<=R) {\\n            int M = L + (R-L)/2; // (L+H)/2;\\n            if(t<a[M]) \\n                R = M-1;\\n            else if(t>a[M]) \\n                L = M+1;\\n            else \\n                return true;\\n        }\\n        return false;        \\n    }    \\n};\\n```\\n\\n# Complexity Analysis \\n## Time Complexity O(log(N-K)) + O(K)\\nThe K is the **rotated duplicated number** that is the duplicated number that\\nput in nums[0] and nums[n-1]. The solution is always be O(log(N)) if there is no\\nrotated duplicated number in nums.\\nBut if there is, we at least and at most to use time O(K) to process it.\\nConsider this case, [1,0,1,1,1,1,1,1,1,....,1], \\nyou at least need to use O(K) time to process it.\\n\\nSo this solution is best soltuion in time complexity. \\nWe use O(K) to clean rotated duplicated number before search. \\nAnd then use O(log(N-K)) to search in the rotated array with no \\nrotated duplicated number. \\n\\n\\n\\n## Space Complexity O(1)\\nWe only use constant number of size for the space , so \\nSpece complexity is space O(1). \\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```C++\\nif(a[L] == a[R]) {\\n\\tif (t==a[L]) return true;\\n\\tint i, same = a[L];\\n\\tfor(i=L;a[i]==same && ++i<R;);\\n\\tL = i;\\n\\tfor(i=R;a[i]==same && --i>L;);\\n\\tR = i;\\n} \\n```\n```C++\\nclass Solution {\\npublic:\\n    bool search(vector<int>& a, int t) {\\n        int L = 0, R = a.size() - 1;\\n        if(a[L] == a[R]) {\\n            if (t==a[L]) return true;\\n            int i, same = a[L];\\n            for(i=L;a[i]==same && ++i<R;);\\n            L = i;\\n            for(i=R;a[i]==same && --i>L;);\\n            R = i;\\n        }\\n\\n        while(L<=R) {\\n            int M = L + (R-L)/2; \\n            if(a[M] == t) return true;            \\n            if(a[M]>=a[L])  //case M is in left-up raising edge\\n                if(a[L]<=t && t<=a[M]) \\n                    return binary_search(L,M-1,t,a);\\n                else \\n                    L = M+1;\\n            else //case M is in bottom-down raising edge\\n                if(a[M]<=t && t<=a[R]) \\n                    return binary_search(M+1,R,t,a);\\n                else \\n                    R = M-1;\\n        }\\n        return false;\\n    }\\n        \\n    bool binary_search(int L, int R, int t, vector<int>& a) {\\n        while(L<=R) {\\n            int M = L + (R-L)/2; // (L+H)/2;\\n            if(t<a[M]) \\n                R = M-1;\\n            else if(t>a[M]) \\n                L = M+1;\\n            else \\n                return true;\\n        }\\n        return false;        \\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1891671,
                "title": "c-simple-code-easy-to-understand-tc-o-log-n-sc-o-1",
                "content": "#### *Upvote if it helps\\u2B06\\uFE0F*\\n```\\n\\tbool search(vector<int>& nums, int target) {\\n        int lo = 0, hi = nums.size()-1;\\n        while (lo<=hi) {\\n            int mid = (lo + hi) / 2;\\n            if(nums[mid]==target) return 1;\\n            if(nums[lo]==nums[mid] && nums[hi]==nums[lo]) lo++,hi--;\\n            else if(nums[lo]<=nums[mid]){\\n                if(nums[lo]<=target && nums[mid]>target) hi= mid-1;\\n                else lo= mid+1;\\n            }\\n            else{\\n                if(nums[mid]<target && nums[hi]>= target)  lo= mid+1;\\n                else  hi=mid-1;\\n            }\\n        }\\n        return 0;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n\\tbool search(vector<int>& nums, int target) {\\n        int lo = 0, hi = nums.size()-1;\\n        while (lo<=hi) {\\n            int mid = (lo + hi) / 2;\\n            if(nums[mid]==target) return 1;\\n            if(nums[lo]==nums[mid] && nums[hi]==nums[lo]) lo++,hi--;\\n            else if(nums[lo]<=nums[mid]){\\n                if(nums[lo]<=target && nums[mid]>target) hi= mid-1;\\n                else lo= mid+1;\\n            }\\n            else{\\n                if(nums[mid]<target && nums[hi]>= target)  lo= mid+1;\\n                else  hi=mid-1;\\n            }\\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1891574,
                "title": "java-solution-two-approaches-search-in-rotated-sorted-array-ii",
                "content": "First Simple Approach\\nTime Complexity : O(N), N is the length of the array\\nSpace Complexity: O(1)\\n\\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int low  = 0;\\n        int high = nums.length - 1;\\n        \\n        while(low <= high){\\n            \\n            if(nums[low] ==  target || nums[high] == target)return true;\\n            \\n            else if(target > nums[low]){\\n                while(low < high && nums[low+1] == nums[low]){\\n                    low++;\\n                }\\n                low++;\\n            }\\n            else if(target < nums[high]){\\n                while(high > low && nums[high-1] == nums[high]){\\n                    high--;\\n                }\\n                high--;\\n            }\\n            else break;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\nOptimal Approach : Binary Search\\nTime Complexity : O(N(logN))\\nSpace Complexity : O(1)\\n\\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        \\n        int low = 0;\\n        int high = nums.length - 1;\\n        \\n        while(low <= high){\\n            \\n            int mid = low + (high - low) / 2;\\n            \\n            if(nums[mid] == target) return true;\\n            \\n            if(nums[mid] > nums[low]){\\n                \\n                if(target < nums[mid] && target >= nums[low]) high = mid;\\n                \\n                else low = mid +1;\\n            }\\n            \\n            else if(nums[mid] < nums[low]){\\n                \\n                if(target > nums[mid] && target < nums[low]) low = mid + 1;\\n                \\n                else high = mid;\\n            }\\n            else low++;\\n        }\\n        return false;\\n    }\\n        \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int low  = 0;\\n        int high = nums.length - 1;\\n        \\n        while(low <= high){\\n            \\n            if(nums[low] ==  target || nums[high] == target)return true;\\n            \\n            else if(target > nums[low]){\\n                while(low < high && nums[low+1] == nums[low]){\\n                    low++;\\n                }\\n                low++;\\n            }\\n            else if(target < nums[high]){\\n                while(high > low && nums[high-1] == nums[high]){\\n                    high--;\\n                }\\n                high--;\\n            }\\n            else break;\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        \\n        int low = 0;\\n        int high = nums.length - 1;\\n        \\n        while(low <= high){\\n            \\n            int mid = low + (high - low) / 2;\\n            \\n            if(nums[mid] == target) return true;\\n            \\n            if(nums[mid] > nums[low]){\\n                \\n                if(target < nums[mid] && target >= nums[low]) high = mid;\\n                \\n                else low = mid +1;\\n            }\\n            \\n            else if(nums[mid] < nums[low]){\\n                \\n                if(target > nums[mid] && target < nums[low]) low = mid + 1;\\n                \\n                else high = mid;\\n            }\\n            else low++;\\n        }\\n        return false;\\n    }\\n        \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1891432,
                "title": "81-c-o-logn-solution-with-explanation",
                "content": "**Please upvote if you find this solution helpful :)**\\n\\n**Approach:**\\n* We find middle of the nums and check whether it is equal to the target if yes return true;\\n* Now, In this question duplicates are allowed and it may cause problem in searching the target.\\n* So, To treat duplicates we check whether right most value, left most value and middle value are equal, if they are then we move right and left pointer by 1 towards the middle.\\n**E.g.** *[3,1,2,3,3,3,3]* \\n* Now, we check whether left half of the middle is sorted (i.e. **nums[left] <= nums[mid]**) if it is. we check target lies in left half by **nums[left] <= target && target < nums[mid]** and move right pointer to **mid-1** otheriwise move left pointer to **mid+1**.\\n* Otherwise right half of the middle is sorted i.e. **nums[mid] <= nums[right]**. we check target lies in right half by **nums[right] >= target && target > nums[mid]**  and move left pointer to **mid+1** otheriwise move left pointer to **mid-1**.\\n\\n**TC: O(logn), SC: O(1)**\\n\\n\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) \\n    {\\n        int l=0, r=nums.size()-1;\\n        \\n        while(l<=r)\\n        {\\n            int mid = (l+r)/2;\\n            \\n            //return true if middle value is equal to the target\\n            if(nums[mid] == target) return true;\\n            \\n            //to handle duplicates we move start and end pointers by 1 towards middle.\\n            if(nums[mid] == nums[l] && nums[mid] == nums[r])\\n            {\\n                l++;\\n                r--;\\n            }\\n            \\n            //if first half is sorted\\n            else if(nums[l] <= nums[mid])\\n            {\\n                //whem target lies in first half\\n                if(nums[l] <= target && target < nums[mid])\\n                    r = mid-1;\\n                \\n                //when target lies in second half\\n                else\\n                    l = mid+1;\\n            }\\n            \\n            //if second half is sorted\\n            else\\n            {\\n                //when target lies in second half\\n                if(nums[mid] < target && target <= nums[r])\\n                    l = mid+1;\\n                \\n                //when target lies in first half\\n                else\\n                    r = mid-1;\\n            }\\n        }\\n        \\n        //if target not found in nums return false\\n        return false;\\n    }\\n};\\n```\\n\\n**Please upvote if you find this solution helpful :)**",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) \\n    {\\n        int l=0, r=nums.size()-1;\\n        \\n        while(l<=r)\\n        {\\n            int mid = (l+r)/2;\\n            \\n            //return true if middle value is equal to the target\\n            if(nums[mid] == target) return true;\\n            \\n            //to handle duplicates we move start and end pointers by 1 towards middle.\\n            if(nums[mid] == nums[l] && nums[mid] == nums[r])\\n            {\\n                l++;\\n                r--;\\n            }\\n            \\n            //if first half is sorted\\n            else if(nums[l] <= nums[mid])\\n            {\\n                //whem target lies in first half\\n                if(nums[l] <= target && target < nums[mid])\\n                    r = mid-1;\\n                \\n                //when target lies in second half\\n                else\\n                    l = mid+1;\\n            }\\n            \\n            //if second half is sorted\\n            else\\n            {\\n                //when target lies in second half\\n                if(nums[mid] < target && target <= nums[r])\\n                    l = mid+1;\\n                \\n                //when target lies in first half\\n                else\\n                    r = mid-1;\\n            }\\n        }\\n        \\n        //if target not found in nums return false\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1891069,
                "title": "c-using-find",
                "content": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        vector<int>::iterator it;\\n        it = find(nums.begin(),nums.end(),target);\\n        if(it!=nums.end()){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        vector<int>::iterator it;\\n        it = find(nums.begin(),nums.end(),target);\\n        if(it!=nums.end()){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890205,
                "title": "beginner-friendly-python-solution",
                "content": "**Approach 1 :**\\nLinear sort, Time Complexity : O(n)\\n```\\nclass Solution(object):\\n    def search(self, nums, target):\\n        for num in nums:\\n            if num == target:\\n                return True\\n        return False\\n```\\n\\n**Approach 2:**\\nBinart search, Time complexity : O(logn)\\n```\\nclass Solution(object):\\n    def search(self, nums, target):\\n        start, end = 0, len(nums) - 1 \\n        while start <= end :\\n            mid = start + (end - start) // 2\\n            if nums[mid] == target:\\n                return True\\n            if nums[mid] > nums[start] :\\n                if nums[mid] > target and nums[start] <= target :\\n                    end = mid - 1\\n                else :\\n                    start = mid + 1\\n            elif nums[mid] < nums[start] :\\n                if nums[mid] < target and nums[start] > target :\\n                    start = mid + 1\\n                else :\\n                    end = mid - 1\\n            else:\\n                start += 1\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def search(self, nums, target):\\n        for num in nums:\\n            if num == target:\\n                return True\\n        return False\\n```\n```\\nclass Solution(object):\\n    def search(self, nums, target):\\n        start, end = 0, len(nums) - 1 \\n        while start <= end :\\n            mid = start + (end - start) // 2\\n            if nums[mid] == target:\\n                return True\\n            if nums[mid] > nums[start] :\\n                if nums[mid] > target and nums[start] <= target :\\n                    end = mid - 1\\n                else :\\n                    start = mid + 1\\n            elif nums[mid] < nums[start] :\\n                if nums[mid] < target and nums[start] > target :\\n                    start = mid + 1\\n                else :\\n                    end = mid - 1\\n            else:\\n                start += 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890198,
                "title": "beginner-friendly-javascript-solution",
                "content": "**Approach 1 :**\\nLinear sort, Time Complexity : O(n)\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar search = function(nums, target) {\\n    for(let i of nums)\\n        if(i == target) return true\\n    return false\\n};\\n```\\n\\n**Approach 2:**\\nBinart search, Time complexity : O(logn)\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar search = function(nums, target) {\\n    let start = 0, end = nums.length-1 \\n    while(start <= end){\\n        let mid = start + Math.floor((end - start) / 2)\\n        if(nums[mid] == target) return true\\n        if(nums[mid] > nums[start]){\\n            if(nums[mid] > target && nums[start] <= target)    end = mid - 1\\n            else    start = mid + 1\\n        } else if(nums[mid] < nums[start]){\\n            if(nums[mid] < target && nums[start] > target)  start = mid + 1\\n            else    end = mid - 1\\n        } else{\\n            start++\\n        }\\n    }\\n    return false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar search = function(nums, target) {\\n    for(let i of nums)\\n        if(i == target) return true\\n    return false\\n};\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar search = function(nums, target) {\\n    let start = 0, end = nums.length-1 \\n    while(start <= end){\\n        let mid = start + Math.floor((end - start) / 2)\\n        if(nums[mid] == target) return true\\n        if(nums[mid] > nums[start]){\\n            if(nums[mid] > target && nums[start] <= target)    end = mid - 1\\n            else    start = mid + 1\\n        } else if(nums[mid] < nums[start]){\\n            if(nums[mid] < target && nums[start] > target)  start = mid + 1\\n            else    end = mid - 1\\n        } else{\\n            start++\\n        }\\n    }\\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1750489,
                "title": "c-beats-100-explanation-o-logn-iterative",
                "content": "Either left to mid or mid to right side will be a smooth curve(not containing the pivot). We search in this smooth curve if the given element is not within this range then we go for the other half and do the same procedure.\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int l=0;\\n        int r=nums.size()-1;\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(nums[m]==target)return true;\\n            if(nums[l]==nums[m] and nums[m]==nums[r]) { l++; r--;}\\n            else if(nums[l]<=nums[m]){\\n                if(target>=nums[l] and target <=nums[m])r=m-1;\\n                else l=m+1;\\n            }\\n            else {\\n                if(target>=nums[m] and target<=nums[r])l=m+1;\\n                else r=m-1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int l=0;\\n        int r=nums.size()-1;\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(nums[m]==target)return true;\\n            if(nums[l]==nums[m] and nums[m]==nums[r]) { l++; r--;}\\n            else if(nums[l]<=nums[m]){\\n                if(target>=nums[l] and target <=nums[m])r=m-1;\\n                else l=m+1;\\n            }\\n            else {\\n                if(target>=nums[m] and target<=nums[r])l=m+1;\\n                else r=m-1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1570679,
                "title": "java-100-binary-search-solution-with-explanation-with-intution",
                "content": "Approach :-\\n\\tstep1:- first we have to find the pivot\\n\\t\\t\\tcase1.1:- if mid < end && arr[mid] > arr[mid+1] so basically mid is the largest so that is the pivot element.\\n\\t\\t\\tcase1.2:- if mid > start && arr[mid] < arr[mid-1] so basically mid - 1 is the largest so that is the pivot element.\\n\\t\\t\\tcase1.3:- if element at start == mid == end just skip the duplicate by increment and decrement the start & end pointer\\n\\t\\t\\t\\t\\tcase1.3.1:- if arr[start] > arr[start+1] so basically start is the largest so that is the pivot element.\\n\\t\\t\\t\\t\\tcase1.3.2:- if arr[end] < arr[end-1] so basically end - 1 is the largest so that is the pivot element.\\n\\t\\t\\tcase1.4:- if arr[start] < arr[mid] || arr[start] == arr[mid] && arr[mid] > arr[end] left side is sorted so pivot should be in right.\\n\\t\\t\\tcase1.5:- if arr[start] > arr[mid] || arr[start] == arr[mid] && arr[mid] < arr[end] right side is sorted so pivot should be in left.\\n \\tstep2:- then we have to apply the normal binary search for finding the target element\\n\\t\\n\\t\\n\\tclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int pivot = findPivot(nums);\\n\\n        //if you did not find a pivot, it means the array is not rotated\\n        if(pivot == -1){\\n            //just do normal binary search\\n            return binarySearch(nums,target,0,nums.length-1);\\n        }\\n\\n        //if pivot is found, you have two ascending sorted arrays\\n        if(nums[pivot] == target){\\n            return true;\\n        }\\n        if(target >= nums[0]){\\n            return binarySearch(nums,target,0,pivot-1);\\n        }\\n        return binarySearch(nums,target,pivot+1,nums.length-1);\\n    }\\n    public static boolean binarySearch(int[] arr,int target ,int start ,int end){\\n        while (start <= end){\\n            int mid = start + (end - start)/2;\\n\\n            if(target < arr[mid]){\\n                end = mid - 1;\\n            }else if(target > arr[mid]){\\n                start = mid + 1;\\n            }else{\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    public static int findPivot(int[] arr){\\n        int start = 0;\\n        int end = arr.length-1;\\n        while(start <= end){\\n\\n            int mid = start + (end - start)/2;\\n\\n            //4 cases\\n            if(mid < end && arr[mid] > arr[mid+1]){\\n                return mid;\\n            }\\n            if(mid > start && arr[mid] < arr[mid-1]){\\n                return mid - 1;\\n            }\\n\\t\\t\\t//if elements at middle, start, end are equal then just skip the duplicates\\n            if(start < end && arr[mid] == arr[start] && arr[mid] == arr[end]){\\n                //skip the duplicate\\n\\n                //NOTE: what if these elements at the start and end were the pivot??\\n                //check if start is pivot\\n\\t\\t\\t\\tif(arr[start] > arr[start+1]){\\n                    return start;\\n                }\\n                start++;\\n                \\n                if(arr[end] < arr[end-1]){\\n                    return end-1;\\n                }\\n                end--;\\n            }\\n\\t\\t\\t//left side is sorted, so pivot should be in right\\n\\t\\t\\telse if(arr[start] < arr[mid] || (arr[start] == arr[mid] && arr[mid] > arr[end])){\\n                start = mid + 1;\\n            }else{\\n                end = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public boolean search(int[] nums, int target) {\\n        int pivot = findPivot(nums);\\n\\n        //if you did not find a pivot, it means the array is not rotated\\n        if(pivot == -1){\\n            //just do normal binary search\\n            return binarySearch(nums,target,0,nums.length-1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1570377,
                "title": "golang-recursive-case-o-n-with-comments",
                "content": "The solution below is quite like merge sort , as it splits the given slice in half, until it hit\\'s the base case of `len(nums) = 1`, then it check isf the base case is the target.\\n\\n```golang\\nfunc search(nums []int, target int) bool {\\n    if len(nums) == 1{\\n        // base case\\n        return nums[0] == target\\n    }\\n    if search(nums[:len(nums)/2],target) || search(nums[len(nums)/2:],target){\\n        /*\\n        We call the function with the left half of the array and the right half. Those, in turn,\\n        call themselves with their own half\\'s until we hit the base case where we can\\'t divide nums in half. \\n\\t\\tHere we check if nums = target. If so, we return true up, and this checks if either \\n\\t\\tits left or right half has returned true. If so, it also returns true.\\n        */\\n        return true\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```golang\\nfunc search(nums []int, target int) bool {\\n    if len(nums) == 1{\\n        // base case\\n        return nums[0] == target\\n    }\\n    if search(nums[:len(nums)/2],target) || search(nums[len(nums)/2:],target){\\n        /*\\n        We call the function with the left half of the array and the right half. Those, in turn,\\n        call themselves with their own half\\'s until we hit the base case where we can\\'t divide nums in half. \\n\\t\\tHere we check if nums = target. If so, we return true up, and this checks if either \\n\\t\\tits left or right half has returned true. If so, it also returns true.\\n        */\\n        return true\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1505000,
                "title": "c-binary-search-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    //basic idea is to find the sorted part by cmp nums[low] with nums[mid]\\n    // one edge case would be nums[low]==nums[mid]      eg 1,0,1,1    just do low++ to find new low that satisfy the first point\\n    bool search(vector<int>& nums, int target) {\\n        \\n        int low=0,high=nums.size()-1,n=nums.size();\\n        int no=INT32_MAX;\\n        while(low<=high)\\n        {\\n            int mid= low+(high-low)/2;\\n            if (nums[mid]==target)  return true;\\n            \\n            if (nums[low]<nums[mid])\\n            {\\n                if (target <nums[low] || target> nums[mid]) low=mid+1;\\n                else high=mid-1;\\n            }\\n            else if (nums[low]>nums[mid])\\n            {\\n                if (target<nums[mid]  || target >nums[high]) high=mid-1;\\n                else low= mid+1;\\n            }\\n            else  low++;         // handle eg:1,0,1,1,1   or 2,2,2,0,2    like\\n                \\n                \\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    //basic idea is to find the sorted part by cmp nums[low] with nums[mid]\\n    // one edge case would be nums[low]==nums[mid]      eg 1,0,1,1    just do low++ to find new low that satisfy the first point\\n    bool search(vector<int>& nums, int target) {\\n        \\n        int low=0,high=nums.size()-1,n=nums.size();\\n        int no=INT32_MAX;\\n        while(low<=high)\\n        {\\n            int mid= low+(high-low)/2;\\n            if (nums[mid]==target)  return true;\\n            \\n            if (nums[low]<nums[mid])\\n            {\\n                if (target <nums[low] || target> nums[mid]) low=mid+1;\\n                else high=mid-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 965549,
                "title": "c-binary-search-solution-o-log-n-time-o-1-space",
                "content": "```\\npublic bool Search(int[] nums, int target)\\n{\\n    if (nums == null || nums.Length == 0) { return false; }\\n    int n = nums.Length;\\n    int l = 0; int r = n - 1;\\n    while (l <= r)\\n    {\\n        int mid = l + (r - l) / 2;\\n        if (target == nums[mid])\\n        {\\n            return true;\\n        }\\n        if (nums[mid] == nums[l] && nums[r] == nums[mid])\\n        {\\n            l++; r--;\\n        }\\n        else if (nums[l] <= nums[mid])\\n        {\\n            if (target >= nums[l] && target < nums[mid])\\n            {\\n                r = mid - 1;\\n            }\\n            else\\n            {\\n                l = mid + 1;\\n            }\\n        }\\n        else\\n        {\\n            if (target > nums[mid] && target <= nums[r])\\n            {\\n                l = mid + 1;\\n            }\\n            else\\n            {\\n                r = mid - 1;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\npublic bool Search(int[] nums, int target)\\n{\\n    if (nums == null || nums.Length == 0) { return false; }\\n    int n = nums.Length;\\n    int l = 0; int r = n - 1;\\n    while (l <= r)\\n    {\\n        int mid = l + (r - l) / 2;\\n        if (target == nums[mid])\\n        {\\n            return true;\\n        }\\n        if (nums[mid] == nums[l] && nums[r] == nums[mid])\\n        {\\n            l++; r--;\\n        }\\n        else if (nums[l] <= nums[mid])\\n        {\\n            if (target >= nums[l] && target < nums[mid])\\n            {\\n                r = mid - 1;\\n            }\\n            else\\n            {\\n                l = mid + 1;\\n            }\\n        }\\n        else\\n        {\\n            if (target > nums[mid] && target <= nums[r])\\n            {\\n                l = mid + 1;\\n            }\\n            else\\n            {\\n                r = mid - 1;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 942849,
                "title": "c-binary-search",
                "content": "```\\nclass Solution { // Binary Search\\npublic: // Time/Space: O(logN); O(1)\\n    bool search(vector<int>& nums, int target) {\\n        int left = 0, right = nums.size() -1;\\n        while(left <= right){\\n            int mid = left + (right - left) /2;\\n            if(nums[mid] == target)\\n                return true;\\n            else if(nums[mid] < nums[right]){\\n                if(nums[mid] < target && target <= nums[right])\\n                    left = mid + 1;\\n                else\\n                    right = mid -1;           \\n            }else if (nums[mid] > nums[right]){\\n                if(nums[left] <= target && target < nums[mid])\\n                    right = mid - 1;\\n                else\\n                    left = mid + 1;                              \\n            }else{  // nums[mid] == nums[right], so we tighten right bound\\n                //cout << \"mid:right= \"<< mid << \":\" << right << \" \" << nums[mid]<< \" \" << nums[right] << endl;\\n                right--;\\n\\t\\t\\t}          \\n        }\\n        return false;        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution { // Binary Search\\npublic: // Time/Space: O(logN); O(1)\\n    bool search(vector<int>& nums, int target) {\\n        int left = 0, right = nums.size() -1;\\n        while(left <= right){\\n            int mid = left + (right - left) /2;\\n            if(nums[mid] == target)\\n                return true;\\n            else if(nums[mid] < nums[right]){\\n                if(nums[mid] < target && target <= nums[right])\\n                    left = mid + 1;\\n                else\\n                    right = mid -1;           \\n            }else if (nums[mid] > nums[right]){\\n                if(nums[left] <= target && target < nums[mid])\\n                    right = mid - 1;\\n                else\\n                    left = mid + 1;                              \\n            }else{  // nums[mid] == nums[right], so we tighten right bound\\n                //cout << \"mid:right= \"<< mid << \":\" << right << \" \" << nums[mid]<< \" \" << nums[right] << endl;\\n                right--;\\n\\t\\t\\t}          \\n        }\\n        return false;        \\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 857673,
                "title": "c-easy-approach",
                "content": "class Solution {\\npublic:\\n\\n    bool search(vector<int>& nums, int target) {\\n        int left = 0, right = nums.size() - 1;        \\n        while(left <= right){  \\n            int mid = left + (right - left) / 2;            \\n            if(nums[mid] == target) \\n                return true;\\n            if(nums[mid] > nums[right]){\\n                if(target > nums[mid] || target <= nums[right]) \\n                    left = mid + 1;    \\n                else \\n                    right = mid - 1;                                                           \\n            }\\n            else if(nums[mid] == nums[right])\\n                right--;   \\n            else{\\n                if(target <= nums[right] && target > nums[mid]) \\n                    left = mid + 1; \\n                else \\n                    right = mid - 1;\\n            }\\n        }\\n        return false;        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool search(vector<int>& nums, int target) {\\n        int left = 0, right = nums.size() - 1;        \\n        while(left <= right){  \\n            int mid = left + (right - left) / 2;            \\n            if(nums[mid] == target) \\n                return true;\\n            if(nums[mid] > nums[right]){\\n                if(target > nums[mid] || target <= nums[right]) \\n                    left = mid + 1;    \\n                else \\n                    right = mid - 1;                                                           \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 725440,
                "title": "c-solution-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int left = 0, right = nums.size() - 1;\\n\\t\\t\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target)  return true;\\n             else if (nums[mid] < nums[right]) {\\n                // If the target is within the right half\\n                if (nums[mid] < target && target <= nums[right]) left = mid + 1;\\n                else right = mid - 1;\\n                \\n            } \\n            // Ascending from left to mid.\\n            else if (nums[mid] > nums[right]) {\\n                // Look if number is in the left half.\\n                if (nums[left] <= target && target < nums[mid]) right = mid - 1; \\n                 else left = mid + 1;       \\n            }\\n            \\n            else \\n                // nums[mid] == nums[right], move mid one to the left.\\n                // For instance, if we have\\n                // 2,3,4,5,1,1,1,1,1,1,1,1,1,1,1\\n                right--;\\n            \\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int left = 0, right = nums.size() - 1;\\n\\t\\t\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target)  return true;\\n             else if (nums[mid] < nums[right]) {\\n                // If the target is within the right half\\n                if (nums[mid] < target && target <= nums[right]) left = mid + 1;\\n                else right = mid - 1;\\n                \\n            } \\n            // Ascending from left to mid.\\n            else if (nums[mid] > nums[right]) {\\n                // Look if number is in the left half.\\n                if (nums[left] <= target && target < nums[mid]) right = mid - 1; \\n                 else left = mid + 1;       \\n            }\\n            \\n            else \\n                // nums[mid] == nums[right], move mid one to the left.\\n                // For instance, if we have\\n                // 2,3,4,5,1,1,1,1,1,1,1,1,1,1,1\\n                right--;\\n            \\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 703706,
                "title": "binary-search-iterative-and-recursive-solution",
                "content": "class Solution {\\n    public boolean search(int[] nums, int target) {\\n    \\n\\tint left = 0, right = nums.length - 1;\\n        \\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) { \\n                return true;\\n            // Ascending from mid to right.\\n            } else if (nums[mid] < nums[right]) {\\n                // If the target is within the right half\\n                if (nums[mid] < target && target <= nums[right]) {\\n                    left = mid + 1;\\n                } else {\\n                    right = mid - 1;\\n                }\\n                // Ascending from left to mid.\\n            } else if (nums[mid] > nums[right]) {\\n                // Look if number is in the left half.\\n                if (nums[left] <= target && target < nums[mid]) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }       \\n            } else {\\n                // nums[mid] == nums[right], move mid one to the left.\\n                right--;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    boolean searchRecursive(int []nums,int start,int end,int target){\\n        \\n        if(start>end){\\n            return false;\\n        }\\n        \\n        int mid= (start+end)/2;\\n        \\n        if(nums[mid]==target){\\n            return true;\\n        }\\n        \\n        if(nums[mid]<nums[end]){\\n            if(target>nums[mid] && target<=nums[end]){\\n               return helper(nums,mid+1, end, target);\\n            }else{\\n                return helper(nums,start, mid-1, target);\\n            }\\n        }else if(nums[mid]>nums[end]){\\n            \\n            if(target<nums[mid] && target>=nums[start]){\\n               return  helper(nums,start, mid-1, target);\\n            }else{\\n                return helper(nums,mid+1, end, target);\\n            }\\n            \\n        }else{\\n            return helper(nums,start, end-1, target);\\n        }\\n        \\n    }\\n}\\n        \\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean search(int[] nums, int target) {\\n    \\n\\tint left = 0, right = nums.length - 1;\\n        \\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) { \\n                return true;\\n            // Ascending from mid to right.\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 613858,
                "title": "cpp-modified-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        if (nums.empty()) return false;\\n        \\n        int l = 0, r = nums.size() - 1, m;\\n        \\n        while (l <= r) {\\n            m = (l + r) / 2;\\n            \\n            if (nums[m] == target) return true;\\n            \\n            if (nums[l] < nums[m]) {\\n                if (nums[l] <= target && nums[m] > target) r = m - 1;\\n                else l = m + 1;\\n            }\\n            \\n            else if (nums[l] == nums[m]) {\\n                l++;\\n            } \\n            \\n            else {\\n                if(nums[m] < target && nums[r] >= target) l = m + 1;\\n                else r = m - 1;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        if (nums.empty()) return false;\\n        \\n        int l = 0, r = nums.size() - 1, m;\\n        \\n        while (l <= r) {\\n            m = (l + r) / 2;\\n            \\n            if (nums[m] == target) return true;\\n            \\n            if (nums[l] < nums[m]) {\\n                if (nums[l] <= target && nums[m] > target) r = m - 1;\\n                else l = m + 1;\\n            }\\n            \\n            else if (nums[l] == nums[m]) {\\n                l++;\\n            } \\n            \\n            else {\\n                if(nums[m] < target && nums[r] >= target) l = m + 1;\\n                else r = m - 1;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588538,
                "title": "c-binary-search-solution",
                "content": "The main difference between LC 81 and LC33 is that LC 81 may have duplicates in the rotated sorted array while LC 33 doesn\\'t. But we still can find monotone intervals and use them to keep narrowing down the search range by comparing nums[mid] and nums[left]. Below diagram shows how to find monotone intervals by compaing nums[mid] and nums[left]. Elements in intervals highlighed in green are sorted in ascending order.\\n\\n- if nums[mid] >= nums[left], then [left, mid] is a monotone interval in which all the elements are sorted in ascending order.\\n- if nums[mid] < nums[left], then [mid, right] is a monotone interval in which all the elements are sorted in ascending order.\\n\\n![image](https://assets.leetcode.com/users/images/4559b768-935f-4148-81a9-3cc6d89464d4_1596000410.0358355.png)\\n\\nSince the array may contain duplicates, there is a special case that when nums[mid] == nums[left], range [left, mid] is not a monotone interval. So we need to handle this case sperately. When nums[mid] == nums[left], it\\'s guranteed that nums[right] == nums[mid] as well (if not, the array won\\'t be a rotated sorted array). And we can narrow down the search range by moving left pointer rightward by 1 and moving right pointer leftward by one, because:\\n\\n- if target == nums[mid], then target will be found later after narrowing down the search range.\\n- if target != nums[mid], then the operation will narrow down the search range.\\n\\t\\n   ![image](https://assets.leetcode.com/users/images/18c35783-da45-4a71-a1e2-da9d926da94b_1596000423.5927882.png)\\n\\n\\n```\\npublic class Solution {\\n    public bool Search(int[] nums, int target) {\\n        \\n        int low = 0, high = nums.Length - 1;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            \\n            if(nums[mid] == target)\\n                return true;\\n            \\n            if(nums[low] == nums[mid] && nums[mid] == nums[high])\\n            {\\n                low++;\\n                high--;\\n            }\\n            else if(nums[low] <= nums[mid])\\n            {               \\n                if(nums[low] <= target && target <= nums[mid])\\n                    high = mid - 1;\\n                else\\n                    low = mid + 1;\\n            }\\n            else\\n            {\\n                if(nums[high] >= target && target >= nums[mid])\\n                    low = mid + 1;\\n                else\\n                    high = mid - 1;\\n            }\\n        }\\n        \\n        return false;        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool Search(int[] nums, int target) {\\n        \\n        int low = 0, high = nums.Length - 1;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            \\n            if(nums[mid] == target)\\n                return true;\\n            \\n            if(nums[low] == nums[mid] && nums[mid] == nums[high])\\n            {\\n                low++;\\n                high--;\\n            }\\n            else if(nums[low] <= nums[mid])\\n            {               \\n                if(nums[low] <= target && target <= nums[mid])\\n                    high = mid - 1;\\n                else\\n                    low = mid + 1;\\n            }\\n            else\\n            {\\n                if(nums[high] >= target && target >= nums[mid])\\n                    low = mid + 1;\\n                else\\n                    high = mid - 1;\\n            }\\n        }\\n        \\n        return false;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 578522,
                "title": "python-o-logn-easy-to-understand",
                "content": "```\\ndef search(L: List[int], target: int) -> int:\\n    \"\"\"\\n    Search in Rotated Sorted Array II\\n\\n    time: O(logn)\\n    space: O(1)\\n\\n    :param List[int] L:\\n    :param int target:\\n    :return int:\\n    \"\"\"\\n    N = len(L)\\n\\n    lo = 0\\n    hi = N - 1\\n\\n    while lo <= hi:\\n        mid = (lo + hi) // 2\\n\\n        if target == L[mid]:\\n            return True\\n\\n        elif L[lo] == L[mid] == L[hi]:\\n            lo += 1\\n            hi -= 1\\n\\n        elif L[lo] <= L[mid]:\\n            if L[lo] <= target < L[mid]:\\n                hi = mid - 1\\n            else:\\n                lo = mid + 1\\n\\n\\t\\t# elif L[mid] <= L[hi]:\\n        else:\\n            if L[mid] < target <= L[hi]:\\n                lo = mid + 1\\n            else:\\n                hi = mid - 1\\n\\n    return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\ndef search(L: List[int], target: int) -> int:\\n    \"\"\"\\n    Search in Rotated Sorted Array II\\n\\n    time: O(logn)\\n    space: O(1)\\n\\n    :param List[int] L:\\n    :param int target:\\n    :return int:\\n    \"\"\"\\n    N = len(L)\\n\\n    lo = 0\\n    hi = N - 1\\n\\n    while lo <= hi:\\n        mid = (lo + hi) // 2\\n\\n        if target == L[mid]:\\n            return True\\n\\n        elif L[lo] == L[mid] == L[hi]:\\n            lo += 1\\n            hi -= 1\\n\\n        elif L[lo] <= L[mid]:\\n            if L[lo] <= target < L[mid]:\\n                hi = mid - 1\\n            else:\\n                lo = mid + 1\\n\\n\\t\\t# elif L[mid] <= L[hi]:\\n        else:\\n            if L[mid] < target <= L[hi]:\\n                lo = mid + 1\\n            else:\\n                hi = mid - 1\\n\\n    return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 509530,
                "title": "python3-solution-o-n-in-worst-case",
                "content": "```\\nclass Solution:\\n    \\n    def binary_search(self,a,low,high,target):\\n        while low<=high:\\n            mid = (low+high)//2\\n            if a[mid]==target:\\n                return True\\n            if a[mid]>target:\\n                high-=1\\n            else:\\n                low+=1\\n        return False\\n    \\n    def search(self, nums: List[int], target: int) -> bool:\\n        index = 0\\n        length = len(nums)\\n        if length==0:\\n            return False\\n        for i in range(length-1):\\n            if nums[i]>nums[i+1]:\\n                index = i\\n                break\\n        if self.binary_search(nums,0,index,target):\\n            return True\\n        return self.binary_search(nums,index+1,length-1,target)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def binary_search(self,a,low,high,target):\\n        while low<=high:\\n            mid = (low+high)//2\\n            if a[mid]==target:\\n                return True\\n            if a[mid]>target:\\n                high-=1\\n            else:\\n                low+=1\\n        return False\\n    \\n    def search(self, nums: List[int], target: int) -> bool:\\n        index = 0\\n        length = len(nums)\\n        if length==0:\\n            return False\\n        for i in range(length-1):\\n            if nums[i]>nums[i+1]:\\n                index = i\\n                break\\n        if self.binary_search(nums,0,index,target):\\n            return True\\n        return self.binary_search(nums,index+1,length-1,target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 499992,
                "title": "java-binary-search-clean-code-beats-100",
                "content": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        return binarySearch(nums, 0, nums.length-1, target);\\n    }\\n    \\n    private boolean binarySearch(int[] nums, int start, int end, int target) {\\n        while(start<=end) {\\n            int mid = (start + end) / 2;\\n            \\n            if(target == nums[mid] || target == nums[start] || target == nums[end]) return true;\\n            \\n            if(nums[start] == nums[end]) {\\n                start = start + 1;\\n                end = end -1;\\n                continue;\\n            }\\n            \\n            boolean isInLeft = isInLeft(nums[start], nums[mid], nums[end], target);\\n            \\n            if(isInLeft) {\\n                start = start + 1;\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n                end = end - 1;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean isInLeft(int leftValue, int midValue, int rightValue, int target) {\\n        if(leftValue <= midValue) {\\n            return target < midValue && target > leftValue;\\n        } else {\\n            return !(target > midValue && target < rightValue);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        return binarySearch(nums, 0, nums.length-1, target);\\n    }\\n    \\n    private boolean binarySearch(int[] nums, int start, int end, int target) {\\n        while(start<=end) {\\n            int mid = (start + end) / 2;\\n            \\n            if(target == nums[mid] || target == nums[start] || target == nums[end]) return true;\\n            \\n            if(nums[start] == nums[end]) {\\n                start = start + 1;\\n                end = end -1;\\n                continue;\\n            }\\n            \\n            boolean isInLeft = isInLeft(nums[start], nums[mid], nums[end], target);\\n            \\n            if(isInLeft) {\\n                start = start + 1;\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n                end = end - 1;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean isInLeft(int leftValue, int midValue, int rightValue, int target) {\\n        if(leftValue <= midValue) {\\n            return target < midValue && target > leftValue;\\n        } else {\\n            return !(target > midValue && target < rightValue);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 271714,
                "title": "clean-readable-python-binary-search",
                "content": "```\\ndef search(self, nums: List[int], target: int) -> int:\\n\\tlo, hi = 0, len(nums)-1\\n\\t\\n\\twhile lo <= hi:\\n\\t\\tmiddle = lo + (hi - lo) // 2\\n\\t\\t\\n\\t\\tif nums[middle] == target: \\n\\t\\t\\treturn middle\\n\\t\\tif nums[lo] == nums[hi]: \\n\\t\\t\\tlo += 1 # added to handle duplicates\\n\\t\\t\\n\\t\\tif nums[lo] <= target <= nums[middle] or nums[middle] <= nums[hi] and not nums[middle] <= target <= nums[hi]:\\n\\t\\t\\thi = middle-1\\n\\t\\telse:\\n\\t\\t\\tlo = middle+1\\n\\n\\treturn -1\\n```",
                "solutionTags": [],
                "code": "```\\ndef search(self, nums: List[int], target: int) -> int:\\n\\tlo, hi = 0, len(nums)-1\\n\\t\\n\\twhile lo <= hi:\\n\\t\\tmiddle = lo + (hi - lo) // 2\\n\\t\\t\\n\\t\\tif nums[middle] == target: \\n\\t\\t\\treturn middle\\n\\t\\tif nums[lo] == nums[hi]: \\n\\t\\t\\tlo += 1 # added to handle duplicates\\n\\t\\t\\n\\t\\tif nums[lo] <= target <= nums[middle] or nums[middle] <= nums[hi] and not nums[middle] <= target <= nums[hi]:\\n\\t\\t\\thi = middle-1\\n\\t\\telse:\\n\\t\\t\\tlo = middle+1\\n\\n\\treturn -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 201691,
                "title": "c-binary-search-with-sliding-window-100-runtime-4ms-99-01-faster",
                "content": "No recursion and a few dirty tricks to work with the rotated array.\\n\\n* * Return false if the array is empty, as there is nothing to find.\\n* Start with the 0th and final indices to see if the target is there, keeps it constant time, otherwise, go into the search which is Log(N). \\n\\nBuild the binary basic search, either with a <= or <  and right + 1; either works. \\nUse a bitwise operator rather than a division operator to speed up the operations. Using >> 1 can speed up things by a factor of 8, as it is equivalent to x / 2 for integers. \\n\\nTreat the left and right partitions like you would a standard sorted binary search. If something is based on the partition, like the target is greater than the current middle index and the right-most current index is greater than the target, increment the left, otherwise decrement the right. \\n\\nSpace Complexity: O(1)\\nBest Case Time Complexity: O(1)\\nAverage/Worst Case Time Complexity: O(log n)\\n\\n```\\nclass Solution {\\npublic:\\n       \\n    bool search(vector<int>& nums, int target) {\\n        if(!nums.size()) return false;\\n        \\n        int left = 0;\\n        int right = nums.size() - 1;\\n        \\n        if(nums[left] == target || nums[right] == target) return true;\\n        \\n        while(left <= right) { \\n            int mid = (left + right) >> 1;\\n            \\n            if(nums[mid] == target) return true;\\n            \\n            if(nums[left] <= target && nums[mid] > target) { // this would be a normal situation...\\n                right = mid - 1;\\n            } else if(nums[right] >= target && nums[mid] < target) { \\n                left = mid + 1;              \\n            } else if(nums[right] >= target && nums[mid] > target){ \\n                left++;\\n            } else { \\n                right--;\\n            }\\n        }\\n        \\n        return false;                     \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n       \\n    bool search(vector<int>& nums, int target) {\\n        if(!nums.size()) return false;\\n        \\n        int left = 0;\\n        int right = nums.size() - 1;\\n        \\n        if(nums[left] == target || nums[right] == target) return true;\\n        \\n        while(left <= right) { \\n            int mid = (left + right) >> 1;\\n            \\n            if(nums[mid] == target) return true;\\n            \\n            if(nums[left] <= target && nums[mid] > target) { // this would be a normal situation...\\n                right = mid - 1;\\n            } else if(nums[right] >= target && nums[mid] < target) { \\n                left = mid + 1;              \\n            } else if(nums[right] >= target && nums[mid] > target){ \\n                left++;\\n            } else { \\n                right--;\\n            }\\n        }\\n        \\n        return false;                     \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 199349,
                "title": "java-binary-search-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n        while(start <= end) {\\n            int mid = (start + end)/2;\\n            if(nums[mid] == target)\\n                return true;\\n            //if nums[mid..end] is sorted\\n            else if(nums[mid] < nums[end]) {\\n                if(target > nums[mid] && target <= nums[end]) {\\n                    start = mid + 1;\\n                }\\n                else {\\n                    end = mid - 1;\\n                }\\n            }\\n            //if nums[start..mid] is sorted\\n            else if(nums[mid] > nums[end]) {\\n                if(target < nums[mid] && target >= nums[start]) {\\n                    end = mid - 1;\\n                }\\n                else {\\n                    start = mid + 1;\\n                }\\n            }\\n            //can exclude nums[end] because nums[end] == nums[mid]\\n            else {\\n                end--;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n        while(start <= end) {\\n            int mid = (start + end)/2;\\n            if(nums[mid] == target)\\n                return true;\\n            //if nums[mid..end] is sorted\\n            else if(nums[mid] < nums[end]) {\\n                if(target > nums[mid] && target <= nums[end]) {\\n                    start = mid + 1;\\n                }\\n                else {\\n                    end = mid - 1;\\n                }\\n            }\\n            //if nums[start..mid] is sorted\\n            else if(nums[mid] > nums[end]) {\\n                if(target < nums[mid] && target >= nums[start]) {\\n                    end = mid - 1;\\n                }\\n                else {\\n                    start = mid + 1;\\n                }\\n            }\\n            //can exclude nums[end] because nums[end] == nums[mid]\\n            else {\\n                end--;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 191993,
                "title": "python-1-line-beats-100",
                "content": "```\\nclass Solution:\\n    def search(self, nums, target):\\n        return target in nums\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def search(self, nums, target):\\n        return target in nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 147223,
                "title": "python3-1-line-beats-100",
                "content": "```\\nclass Solution:\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        return target in nums\\n\\t\\t\\t\\t\\n\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        return target in nums\\n\\t\\t\\t\\t\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 28297,
                "title": "take-it-as-a-sorted-array-with-binary-search-in-python",
                "content": " This problem can be simply seen as a searching problem in a sorted array. The only difference is to first find the start and end point and extend the index. The extended virtual index will not cause extra space, because you do not need to store them at the end of the original array, but only map them to the original ones. As shown below:\\n\\n    class Solution:\\n        # @param A a list of integers\\n        # @param target an integer\\n        # @return a boolean\\n        def search(self, A, target):\\n            if len(A) == 0:\\n                return False\\n            else:\\n                start = 0\\n                end = len(A) - 1\\n                # To find the start point(smallest integer)\\n                for i in range(len(A)-1):\\n                    if A[i] > A[i+1]:\\n                        start = i+1\\n                        end = i + len(A)    # Extend the index of the list\\n                while start<=end:\\n                    mid = start + (end - start)/2\\n                    cur = A[mid%len(A)] #To get the index in original list\\n                    if cur == target:\\n                        return True\\n                    elif cur > target:\\n                        end = mid - 1\\n                    else:\\n                        start = mid + 1\\n                \\n                return False",
                "solutionTags": [],
                "code": " This problem can be simply seen as a searching problem in a sorted array. The only difference is to first find the start and end point and extend the index. The extended virtual index will not cause extra space, because you do not need to store them at the end of the original array, but only map them to the original ones. As shown below:\\n\\n    class Solution:\\n        # @param A a list of integers\\n        # @param target an integer\\n        # @return a boolean\\n        def search(self, A, target):\\n            if len(A) == 0:\\n                return False\\n            else:\\n                start = 0\\n                end = len(A) - 1\\n                # To find the start point(smallest integer)\\n                for i in range(len(A)-1):\\n                    if A[i] > A[i+1]:\\n                        start = i+1\\n                        end = i + len(A)    # Extend the index of the list\\n                while start<=end:\\n                    mid = start + (end - start)/2\\n                    cur = A[mid%len(A)] #To get the index in original list\\n                    if cur == target:\\n                        return True\\n                    elif cur > target:\\n                        end = mid - 1\\n                    else:\\n                        start = mid + 1\\n                \\n                return False",
                "codeTag": "Java"
            },
            {
                "id": 3984991,
                "title": "search-in-rotated-sorted-array-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int sz = nums.size();\\n     \\n        int left = 0, right = sz-1;\\n        while(left <= right){\\n    \\n            int midPos = left + (right - left) / 2;\\n            \\n            if(nums[midPos] == target)return true;\\n    \\n            else if(nums[midPos] == nums[left] && nums[midPos] == nums[right]){\\n                left++,right--;\\n            }\\n          \\n            else if(nums[midPos] >  nums[right]){ \\n              if(nums[midPos] > target && nums[left] <= target){\\n                  right = midPos - 1;\\n              }else{\\n                  left = midPos + 1;\\n              }\\n            }else{\\n                if(nums[midPos] < target && nums[right] >= target){\\n                     left = midPos + 1;\\n                }else{\\n                     right = midPos - 1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int sz = nums.size();\\n     \\n        int left = 0, right = sz-1;\\n        while(left <= right){\\n    \\n            int midPos = left + (right - left) / 2;\\n            \\n            if(nums[midPos] == target)return true;\\n    \\n            else if(nums[midPos] == nums[left] && nums[midPos] == nums[right]){\\n                left++,right--;\\n            }\\n          \\n            else if(nums[midPos] >  nums[right]){ \\n              if(nums[midPos] > target && nums[left] <= target){\\n                  right = midPos - 1;\\n              }else{\\n                  left = midPos + 1;\\n              }\\n            }else{\\n                if(nums[midPos] < target && nums[right] >= target){\\n                     left = midPos + 1;\\n                }else{\\n                     right = midPos - 1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899668,
                "title": "java-binary-search-detailed-comments-beats-100",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(logN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n\\n        while (start <= end) {\\n\\n            int mid = start + (end - start) / 2;\\n\\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n\\n            //shrink the array when mid is equal to both low and end. \\n            //Given that nums[mid] != target, we can safely say nums[start] and nums[end] != target as well \\n            //and keep shrinking the array from both ends\\n            while(nums[start] == nums[mid] && nums[mid] == nums[end] && start < end){\\n                start++;\\n                end--;\\n            }\\n\\n            // Left side is sorted\\n            if (nums[start] <= nums[mid]) {\\n                // Check if target lies in the left side\\n                if (target >= nums[start] && target < nums[mid]) {\\n                    end = mid - 1; // Update end index\\n                } else {\\n                    start = mid + 1; // Update start index\\n                }\\n            }\\n            // Right side is sorted\\n            else {\\n                // Check if target lies in the right side\\n                if (target > nums[mid] && target <= nums[end]) {\\n                    start = mid + 1; // Update start index\\n                } else {\\n                    end = mid - 1; // Update end index\\n                }\\n            }\\n        }\\n\\n        return false; // Target not found\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n\\n        while (start <= end) {\\n\\n            int mid = start + (end - start) / 2;\\n\\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n\\n            //shrink the array when mid is equal to both low and end. \\n            //Given that nums[mid] != target, we can safely say nums[start] and nums[end] != target as well \\n            //and keep shrinking the array from both ends\\n            while(nums[start] == nums[mid] && nums[mid] == nums[end] && start < end){\\n                start++;\\n                end--;\\n            }\\n\\n            // Left side is sorted\\n            if (nums[start] <= nums[mid]) {\\n                // Check if target lies in the left side\\n                if (target >= nums[start] && target < nums[mid]) {\\n                    end = mid - 1; // Update end index\\n                } else {\\n                    start = mid + 1; // Update start index\\n                }\\n            }\\n            // Right side is sorted\\n            else {\\n                // Check if target lies in the right side\\n                if (target > nums[mid] && target <= nums[end]) {\\n                    start = mid + 1; // Update start index\\n                } else {\\n                    end = mid - 1; // Update end index\\n                }\\n            }\\n        }\\n\\n        return false; // Target not found\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892398,
                "title": "python-o-n-binary-search-discontinuity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSuppose some sorted nondecreasing array `original` gets rotated.\\n\\nSince `original` is nondecreasing, we know that either the entire array is flat, or the last element must be greater than the first element.\\n\\nNo matter how much the array is rotated, there must be **no more than one decrease**. This allows us to still use binary search unless the array is very flat.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConsider some subarray of `nums` with first element `left`, last element `right`, and middle element `mid` (might all be the same element).\\n\\nBecause of the possiblity of duplicates, we cannot say `left >= right` means rotated as was true in [Search in Rotated Sorted Array I](https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3883855/python-o-log-n-binary-search-discontinuity/).\\n\\nInstead, if `left > right`, the array must have been rotated, since the original was nondecreasing.\\n\\n![image.png](https://assets.leetcode.com/users/images/d60d0510-dacf-4238-af50-d57aeb07d148_1691698622.921585.png)\\n\\nNotice that wherever you place `mid` and `target`, the direction is always the same as a regular binary search except **when the discontinuity is between `mid` and `target`**. In that case the direction is reversed.\\n\\n![image.png](https://assets.leetcode.com/users/images/9190c3e5-dc70-43e0-9d20-3019ec058f0a_1691699417.641912.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/6773c634-0c8b-41d1-a6fa-d41f3a23576f_1691699583.6068969.png)\\n\\n\\n\\n\\nIf `left < right`, the subarray must be sorted since if there was some decrease in between, there would now be two decreases in the circular array which is invalid. In this case a regular binary search can be used.\\n\\n![image.png](https://assets.leetcode.com/users/images/8b5ad43c-cb8e-430d-ac0d-0f99beed8a05_1691698402.1986876.png)\\n\\n\\nif `left == right`, `nums` is either flat or rotated and there is no way to guarantee which one it is in faster than linear time, and if `left == mid == right`, we cannot guarantee which side of `mid` the target will be on.\\n\\n![image.png](https://assets.leetcode.com/users/images/46f3680b-a94f-4f14-b4ea-f7936c00f2ce_1691698862.2143118.png)\\n\\nIn this case we can linearly search from the ends of the array, shrinking the bounds until either a different number is found or the search is done. \\n```py\\n    while nums[l] == nums[r]:\\n        l += 1\\n        r -= 1\\n```\\n\\n# Complexity\\n- Time complexity:  $$ O(n) $$\\n    - Worst case `nums` is flat and `target` is not in `nums`.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$ O(1) $$\\n    - Store pointers.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```py\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        n, l, r = len(nums), 0, n - 1\\n\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if target in (nums[l], nums[mid], nums[r]):\\n                return True\\n            elif nums[l] == nums[mid] == nums[r]:\\n                while 0 <= l <= r <= n - 1 and nums[l] == nums[r]:\\n                    l += 1\\n                    r -= 1\\n            elif target > nums[mid]:\\n                if nums[mid] <= nums[r] <= target:\\n                    r = mid - 1\\n                else:\\n                    l = mid + 1\\n            else:\\n                if nums[mid] >= nums[l] >= target:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```py\\n    while nums[l] == nums[r]:\\n        l += 1\\n        r -= 1\\n```\n```py\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        n, l, r = len(nums), 0, n - 1\\n\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if target in (nums[l], nums[mid], nums[r]):\\n                return True\\n            elif nums[l] == nums[mid] == nums[r]:\\n                while 0 <= l <= r <= n - 1 and nums[l] == nums[r]:\\n                    l += 1\\n                    r -= 1\\n            elif target > nums[mid]:\\n                if nums[mid] <= nums[r] <= target:\\n                    r = mid - 1\\n                else:\\n                    l = mid + 1\\n            else:\\n                if nums[mid] >= nums[l] >= target:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889693,
                "title": "100-beats-easy-beginner-friendly-solution-binary-search-java-c-python",
                "content": "# Intuition\\nThe problem asks whether a given target element exists in a rotated sorted array with possible duplicates.\\n\\n# Approach\\n1. **Initialization:** You start by setting two pointers, `l` and `r`, at the beginning and end of the array.\\n\\n2. **Binary Search**: You perform a special kind of binary search:\\n\\n    - Calculate the middle index `mid` between `l` and `r`.\\n    - Compare the number at index `mid` with the `target`:\\n        - If they are the same, you\\'ve found the `target`, so you return `true`.\\n        - If the number at `mid` is greater than the number at `l`, it means the left part of the array is sorted.\\n            - If the `target` is within the range of the sorted left part, update `r` to `mid - 1` to focus the search on the left side.\\n            - Otherwise, move the `l` pointer to `mid + 1` to search the right side.\\n        - If the number at `mid` is less than the number at `l`, it means the right part of the array is sorted.\\n            - If the `target` is within the range of the sorted right part, update `l` to `mid + 1` to focus the search on the right side.\\n            - Otherwise, move the `r` pointer to `mid - 1` to search the left side.\\n        - If the number at `mid` is equal to the number at `l`, it\\'s a bit tricky because it might be due to duplicates and you\\'re not sure which side is sorted. So, just move the `l` pointer forward by one position.\\n3. **Repeat:** You keep doing this binary search approach until `l` is greater than `r`, which means you\\'ve searched the whole array without finding the `target`.\\n\\n4. **Result:** If you never found the `target`, return `false`.\\n\\n# Complexity\\n- Time complexity:\\nOn average, this approach takes `O(log n)` time because in each step you eliminate half of the remaining search space. However, in the worst case where there are many duplicates, it could take `O(n)` time because you might end up checking each element.\\n\\n- Space complexity:\\n This approach uses only a few extra variables to keep track of pointers, so the space complexity is `O(1)`, meaning it uses very little extra memory.\\n\\n# Code\\n```Java []\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int n = nums.length;\\n        int l = 0;\\n        int r = nums.length - 1;\\n\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n            else if (nums[mid] > nums[l]) {\\n                if (target >= nums[l] && target < nums[mid]) {\\n                    r = mid - 1;\\n                }\\n                else {\\n                    l = mid + 1;\\n                }\\n            }\\n            else if (nums[mid] < nums[l]) {\\n                if (target > nums[mid] && target <= nums[r]) {\\n                    l = mid + 1;\\n                }\\n                else {\\n                    r = mid - 1;\\n                }\\n            }\\n            else {\\n                l++;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int l = 0;\\n        int r = n - 1;\\n\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n            else if (nums[mid] > nums[l]) {\\n                if (target >= nums[l] && target < nums[mid]) {\\n                    r = mid - 1;\\n                }\\n                else {\\n                    l = mid + 1;\\n                }\\n            }\\n            else if (nums[mid] < nums[l]) {\\n                if (target > nums[mid] && target <= nums[r]) {\\n                    l = mid + 1;\\n                }\\n                else {\\n                    r = mid - 1;\\n                }\\n            }\\n            else {\\n                l++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n```Python []\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        n = len(nums)\\n        l = 0\\n        r = n - 1\\n\\n        while l <= r:\\n            mid = l + (r - l) // 2\\n            if nums[mid] == target:\\n                return True\\n            elif nums[mid] > nums[l]:\\n                if target >= nums[l] and target < nums[mid]:\\n                    r = mid - 1\\n                else:\\n                    l = mid + 1\\n            elif nums[mid] < nums[l]:\\n                if target > nums[mid] and target <= nums[r]:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n            else:\\n                l += 1\\n                \\n        return False\\n```\\n**NOTE** - Remember, binary search is a technique that divides the problem in half at each step, which can be more efficient than searching through every element, especially in larger arrays.\\n![image.png](https://assets.leetcode.com/users/images/875417a6-7d73-4bf9-a621-c41a4b967f55_1691657546.8318427.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```Java []\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int n = nums.length;\\n        int l = 0;\\n        int r = nums.length - 1;\\n\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n            else if (nums[mid] > nums[l]) {\\n                if (target >= nums[l] && target < nums[mid]) {\\n                    r = mid - 1;\\n                }\\n                else {\\n                    l = mid + 1;\\n                }\\n            }\\n            else if (nums[mid] < nums[l]) {\\n                if (target > nums[mid] && target <= nums[r]) {\\n                    l = mid + 1;\\n                }\\n                else {\\n                    r = mid - 1;\\n                }\\n            }\\n            else {\\n                l++;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int l = 0;\\n        int r = n - 1;\\n\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n            else if (nums[mid] > nums[l]) {\\n                if (target >= nums[l] && target < nums[mid]) {\\n                    r = mid - 1;\\n                }\\n                else {\\n                    l = mid + 1;\\n                }\\n            }\\n            else if (nums[mid] < nums[l]) {\\n                if (target > nums[mid] && target <= nums[r]) {\\n                    l = mid + 1;\\n                }\\n                else {\\n                    r = mid - 1;\\n                }\\n            }\\n            else {\\n                l++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```Python []\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        n = len(nums)\\n        l = 0\\n        r = n - 1\\n\\n        while l <= r:\\n            mid = l + (r - l) // 2\\n            if nums[mid] == target:\\n                return True\\n            elif nums[mid] > nums[l]:\\n                if target >= nums[l] and target < nums[mid]:\\n                    r = mid - 1\\n                else:\\n                    l = mid + 1\\n            elif nums[mid] < nums[l]:\\n                if target > nums[mid] and target <= nums[r]:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n            else:\\n                l += 1\\n                \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889384,
                "title": "beats-100-java-solved-using-simple-linear-search-with-explanation-beginner-friendly",
                "content": "# Intuition\\nThe code searches for a specific \\'target\\' value within the \\'nums\\' array. It iterates through the array, and if the \\'target\\' value is found, it sets the boolean variable \\'b\\' to true and terminates the loop. The final result returned indicates whether the \\'target\\' value was present in the array or not. The algorithm essentially performs a linear search.\\n\\n# Approach\\n1. Initialize a boolean variable \\'b\\' as false.\\n2. Iterate through each element \\'num\\' in the \\'nums\\' array.\\n3. If the current \\'num\\' is equal to the \\'target\\', set \\'b\\' to true and break the loop.\\n4. Return the value of \\'b\\'.\\n\\n# Complexity\\n- Time complexity: O(n) (linear)\\n\\n- Space complexity: O(1) (constant)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        boolean b = false;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]==target){\\n                b = true;\\n                break;\\n            }\\n        }\\n        return b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        boolean b = false;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]==target){\\n                b = true;\\n                break;\\n            }\\n        }\\n        return b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888892,
                "title": "c-count-stl",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        if(count(nums.begin(),nums.end(),target)) {\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        if(count(nums.begin(),nums.end(),target)) {\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888775,
                "title": "video-solution-c-java-explanation-with-drawings",
                "content": "# Intuition, approach, complexity discussed in detail in video solution.\\nhttps://youtu.be/DzrrT0OjeK8\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int sz = nums.size();\\n     \\n        int left = 0, right = sz-1;\\n        while(left <= right){\\n    \\n            int midPos = left + (right - left) / 2;\\n            \\n            if(nums[midPos] == target)return true;\\n    \\n            else if(nums[midPos] == nums[left] && nums[midPos] == nums[right]){\\n                left++,right--;\\n            }\\n          \\n            else if(nums[midPos] >  nums[right]){ \\n              if(nums[midPos] > target && nums[left] <= target){\\n                  right = midPos - 1;\\n              }else{\\n                  left = midPos + 1;\\n              }\\n            }else{\\n                if(nums[midPos] < target && nums[right] >= target){\\n                     left = midPos + 1;\\n                }else{\\n                     right = midPos - 1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int sz = nums.length;\\n        int left = 0, right = sz-1;\\n        while(left <= right){\\n\\n            int midPos = left + (right - left) / 2;\\n    \\n            if(nums[midPos] == target)return true;\\n            else if(nums[midPos] == nums[left] && nums[midPos] == nums[right]){\\n                left++;\\n                 right--;\\n            }\\n       \\n            else if(nums[midPos] >  nums[right]){ \\n              if(nums[midPos] > target && nums[left] <= target){\\n                  right = midPos - 1;\\n              }else{\\n                  left = midPos + 1;\\n              }\\n            }else{\\n                if(nums[midPos] < target && nums[right] >= target){\\n                     left = midPos + 1;\\n                }else{\\n                     right = midPos - 1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int sz = nums.size();\\n     \\n        int left = 0, right = sz-1;\\n        while(left <= right){\\n    \\n            int midPos = left + (right - left) / 2;\\n            \\n            if(nums[midPos] == target)return true;\\n    \\n            else if(nums[midPos] == nums[left] && nums[midPos] == nums[right]){\\n                left++,right--;\\n            }\\n          \\n            else if(nums[midPos] >  nums[right]){ \\n              if(nums[midPos] > target && nums[left] <= target){\\n                  right = midPos - 1;\\n              }else{\\n                  left = midPos + 1;\\n              }\\n            }else{\\n                if(nums[midPos] < target && nums[right] >= target){\\n                     left = midPos + 1;\\n                }else{\\n                     right = midPos - 1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int sz = nums.length;\\n        int left = 0, right = sz-1;\\n        while(left <= right){\\n\\n            int midPos = left + (right - left) / 2;\\n    \\n            if(nums[midPos] == target)return true;\\n            else if(nums[midPos] == nums[left] && nums[midPos] == nums[right]){\\n                left++;\\n                 right--;\\n            }\\n       \\n            else if(nums[midPos] >  nums[right]){ \\n              if(nums[midPos] > target && nums[left] <= target){\\n                  right = midPos - 1;\\n              }else{\\n                  left = midPos + 1;\\n              }\\n            }else{\\n                if(nums[midPos] < target && nums[right] >= target){\\n                     left = midPos + 1;\\n                }else{\\n                     right = midPos - 1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888760,
                "title": "easy-shortest-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe want to find the target value in array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntraverse in array if target value find in the arr return true otherwise return false.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nthe time complexity of program is O(n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwe use n to strore size of nums.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int n = nums.length;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==target){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int n = nums.length;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==target){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888605,
                "title": "c-solution-for-search-in-rotated-array-ii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe solution takes advantage of the fact that even though the array is rotated, at least one half of it will still be sorted. This property allows us to perform a modified binary search to efficiently find the target value.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach involves using a modified binary search algorithm. Here are the main steps:\\n\\n- Initialize two pointers, left and right, which represent the current search range within the array.\\n- While the left pointer is less than or equal to the right pointer, perform the following steps:\\n1. Calculate the middle index, mid, of the current search range.\\n1. Check if the value at the middle index, nums[mid], is equal to the target value. If it is, return true.\\n1. If the left half of the array (nums[left] to nums[mid]) is sorted:\\n1. Check if the target value lies within this sorted range. If it does, adjust the right pointer to mid - 1. Otherwise, adjust the left pointer to mid + 1.\\n1. If the right half of the array (nums[mid] to nums[right]) is sorted:\\n1. Check if the target value lies within this sorted range. If it does, adjust the left pointer to mid + 1. Otherwise, adjust the right pointer to mid - 1.\\n1. If there are duplicate values at the left and mid indices, move the left pointer one step to the right.\\n- If the target value is not found after the while loop, return false.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(log n), where n is the number of elements in the input array. The binary search halves the search range in each step, so the search completes in logarithmic time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this solution is O(1), which means it uses a constant amount of extra space to store variables regardless of the input array size. This is because it doesn\\'t use any additional data structures that grow with the input size.\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool Search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.Length - 1;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n\\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n\\n            // If the left half is sorted\\n            if (nums[left] < nums[mid]) {\\n                if (nums[left] <= target && target < nums[mid]) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n            // If the right half is sorted\\n            else if (nums[left] > nums[mid]) {\\n                if (nums[mid] < target && target <= nums[right]) {\\n                    left = mid + 1;\\n                } else {\\n                    right = mid - 1;\\n                }\\n            }\\n            // If we have duplicate values, move the left pointer\\n            else {\\n                left++;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool Search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.Length - 1;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n\\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n\\n            // If the left half is sorted\\n            if (nums[left] < nums[mid]) {\\n                if (nums[left] <= target && target < nums[mid]) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n            // If the right half is sorted\\n            else if (nums[left] > nums[mid]) {\\n                if (nums[mid] < target && target <= nums[right]) {\\n                    left = mid + 1;\\n                } else {\\n                    right = mid - 1;\\n                }\\n            }\\n            // If we have duplicate values, move the left pointer\\n            else {\\n                left++;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888579,
                "title": "shortcut-c-solution-leetcode-daily-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n```c++ []\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        \\n        sort(nums.begin(),nums.end());\\n        vector<int>::iterator it;\\n        it=find(nums.begin(),nums.end(),target);\\n        if(it!=nums.end())\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& v, int target) {\\n        set<int> st;\\n        vector<int> nums;\\n        for(auto x:v)\\n        {\\n            if(st.find(x)==st.end())\\n            {\\n                st.insert(x);\\n                nums.push_back(x);\\n            }\\n        }\\n        \\n        int n=nums.size();\\n        int left=0,right = n-1,mid;\\n        while(left<=right)\\n        {\\n            mid = (left + right)/2;\\n            if(nums[mid]== target)\\n            {\\n                return true;\\n            }\\n            else if(nums[mid]>=nums[left])\\n            {\\n                if(target <=nums[mid] && target >= nums[left])\\n                {\\n                    right = mid-1;\\n                }\\n                else\\n                {\\n                    left=mid+1;\\n                }\\n            }\\n            else\\n            {\\n                if(target >= nums[mid] && target <= nums[right])\\n                {\\n                    left = mid +1;\\n                }\\n                else\\n                {\\n                    right= mid -1;\\n                }\\n            }\\n           \\n            \\n        }return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```c++ []\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        \\n        sort(nums.begin(),nums.end());\\n        vector<int>::iterator it;\\n        it=find(nums.begin(),nums.end(),target);\\n        if(it!=nums.end())\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& v, int target) {\\n        set<int> st;\\n        vector<int> nums;\\n        for(auto x:v)\\n        {\\n            if(st.find(x)==st.end())\\n            {\\n                st.insert(x);\\n                nums.push_back(x);\\n            }\\n        }\\n        \\n        int n=nums.size();\\n        int left=0,right = n-1,mid;\\n        while(left<=right)\\n        {\\n            mid = (left + right)/2;\\n            if(nums[mid]== target)\\n            {\\n                return true;\\n            }\\n            else if(nums[mid]>=nums[left])\\n            {\\n                if(target <=nums[mid] && target >= nums[left])\\n                {\\n                    right = mid-1;\\n                }\\n                else\\n                {\\n                    left=mid+1;\\n                }\\n            }\\n            else\\n            {\\n                if(target >= nums[mid] && target <= nums[right])\\n                {\\n                    left = mid +1;\\n                }\\n                else\\n                {\\n                    right= mid -1;\\n                }\\n            }\\n           \\n            \\n        }return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822516,
                "title": "python-easy-one-line-solution-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have check weather element in list or not.\\n\\n# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        return target in set(nums)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        return target in set(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794497,
                "title": "java-binary-search-beats-100-t-c-o-logn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf i try to solve it as a normal question(means if all the element are unique) then we are going to face problem that we cannot tell which side is sorted if the n[low]==n[mid] && n[mid]==n[high].\\nFor overcoming this problem we need to increase the low value and decrease the high value until that condition becomes false.    \\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nMost of the time the tc is going to be O(logN)\\nBut in the worst case the tc is going to be approximately n/2\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int low =0;\\n        int high =nums.length-1;\\n\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n\\n            if(nums[mid]==target)return true;\\n\\n            if(nums[low]==nums[mid] && nums[mid]==nums[high]){\\n                low=low+1;\\n                high=high-1;\\n                continue;\\n            }\\n\\n            if(nums[low]<=nums[mid]){\\n                if(nums[low]<=target && target<=nums[mid])high=mid-1;\\n                else low =mid+1;\\n            }\\n\\n            else{\\n                if(nums[mid]<=target && target <= nums[high])low=mid+1;\\n                else high =mid-1;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int low =0;\\n        int high =nums.length-1;\\n\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n\\n            if(nums[mid]==target)return true;\\n\\n            if(nums[low]==nums[mid] && nums[mid]==nums[high]){\\n                low=low+1;\\n                high=high-1;\\n                continue;\\n            }\\n\\n            if(nums[low]<=nums[mid]){\\n                if(nums[low]<=target && target<=nums[mid])high=mid-1;\\n                else low =mid+1;\\n            }\\n\\n            else{\\n                if(nums[mid]<=target && target <= nums[high])low=mid+1;\\n                else high =mid-1;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717268,
                "title": "syper-easy-solution-algorithm-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n         int st=0;int end=nums.size()-1;\\n        while(st<=end){\\n        int mid=(st+end)/2;\\n            if(nums[mid]==target)return true;\\n            if(nums[st]== nums[mid] && nums[end]== nums[mid] )st++,end--;\\n            else if(nums[mid]>=nums[st]){\\n                if(target>=nums[st] && target<=nums[mid]){\\n                    end=mid-1;\\n                }else{\\n                    st=mid+1;\\n                }\\n            }\\n            else{\\n                if(target<=nums[end] && target>=nums[mid] ){\\n                    st=mid+1;\\n                }else{\\n                    end=mid-1;\\n                }\\n            }\\n        }\\nreturn false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n         int st=0;int end=nums.size()-1;\\n        while(st<=end){\\n        int mid=(st+end)/2;\\n            if(nums[mid]==target)return true;\\n            if(nums[st]== nums[mid] && nums[end]== nums[mid] )st++,end--;\\n            else if(nums[mid]>=nums[st]){\\n                if(target>=nums[st] && target<=nums[mid]){\\n                    end=mid-1;\\n                }else{\\n                    st=mid+1;\\n                }\\n            }\\n            else{\\n                if(target<=nums[end] && target>=nums[mid] ){\\n                    st=mid+1;\\n                }else{\\n                    end=mid-1;\\n                }\\n            }\\n        }\\nreturn false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689104,
                "title": "4ms-binary-search-intutive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we say there are two sorted parts - [k to n-1] and [ 0 to k-1]\\nIf target<nums[mid], We move to the left if\\n1. If lo to mid-segment are in the same part of the rotated array and if the value of the target is in between them. \\n2. If the lo pointer is in the first part of the rotated array and the mid pointer is in the second part, then the target is even less than the value at the lo pointer, we move left.  \\nOther than this, we move right.\\nSimilar logic can be applied for target>nums[mid] based on the mid to hi segment. \\n\\n\\nWhen there are Duplicate elements-\\nFollow the same logic except when\\n1 . target!=nums[mid] && nums[mid]==nums[hi] && nums[hi]==nums[lo]\\n   Here since the answer will always lie between lo and hi, but not at these points. So reduce both pointers by one unit. \\n2 . target>nums[mid]  and nums[mid]=nums[hi]. Refer to the lo to decide where to move next.\\n3   . target<nums[mid]  and nums[mid]=nums[lo]. Refer to the hi to decide where to move next.\\n\\nWorst Case Complexity will be O(n).\\nConsider the example- [1,1,1,1,0,1,1,1]. In this case we will keep shifting lo and hi by one unit in each iteration.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nNo Duplicates: O(log(n))\\nWorst Case: O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int lo=0;\\n        int hi=n-1;\\n        int mid;\\n        while(lo<=hi){\\n            mid=(lo+hi)/2;\\n            if(nums[mid]==target){\\n                return true;\\n            }\\n            if(nums[mid]==nums[lo] && nums[lo]==nums[hi]){\\n                hi--;\\n                lo++;\\n                continue;\\n            }\\n            if(nums[mid]<target){\\n                if(nums[mid]==nums[hi] && nums[lo]!=nums[mid] ){\\n                    hi=mid-1;\\n                }\\n                else if(target<=nums[hi] && nums[mid]<nums[hi]){\\n                    lo=mid+1;\\n                }\\n                else if(target>=nums[hi] && nums[hi]<=nums[mid]){\\n                    lo=mid+1;\\n                }\\n                else{\\n                    hi=mid-1;\\n                }  \\n            }\\n            else{\\n                if(nums[mid]==nums[lo] && nums[hi]!=nums[mid]){\\n                    lo=mid+1;\\n                }\\n                else if(target>=nums[lo] && nums[mid]>nums[lo]){\\n                    hi=mid-1;\\n                } \\n                else if(target<=nums[lo] && nums[lo]>=nums[mid]){\\n                    hi=mid-1;\\n                }\\n                else{\\n                    lo=mid+1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int lo=0;\\n        int hi=n-1;\\n        int mid;\\n        while(lo<=hi){\\n            mid=(lo+hi)/2;\\n            if(nums[mid]==target){\\n                return true;\\n            }\\n            if(nums[mid]==nums[lo] && nums[lo]==nums[hi]){\\n                hi--;\\n                lo++;\\n                continue;\\n            }\\n            if(nums[mid]<target){\\n                if(nums[mid]==nums[hi] && nums[lo]!=nums[mid] ){\\n                    hi=mid-1;\\n                }\\n                else if(target<=nums[hi] && nums[mid]<nums[hi]){\\n                    lo=mid+1;\\n                }\\n                else if(target>=nums[hi] && nums[hi]<=nums[mid]){\\n                    lo=mid+1;\\n                }\\n                else{\\n                    hi=mid-1;\\n                }  \\n            }\\n            else{\\n                if(nums[mid]==nums[lo] && nums[hi]!=nums[mid]){\\n                    lo=mid+1;\\n                }\\n                else if(target>=nums[lo] && nums[mid]>nums[lo]){\\n                    hi=mid-1;\\n                } \\n                else if(target<=nums[lo] && nums[lo]>=nums[mid]){\\n                    hi=mid-1;\\n                }\\n                else{\\n                    lo=mid+1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675095,
                "title": "easiest-and-commented-c-solution-binary-search-100",
                "content": "\\n# Complexity\\n- Time complexity: O(logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int low = 0, high = n-1, mid;\\n        while(low<=high)\\n        {\\n            mid=(low+high)/2;\\n            if(nums[mid]==target) return true;\\n            //Check which half is sorted\\n            //Also since duplicates are possible we could have a problem for the edge case such as nums[low]==nums[mid]==nums[high]\\n            //eg [3 1 2 3 3 3 3] now its fucked so we need to take care of this case\\n            if(nums[low] == nums[mid] && nums[mid] == nums[high])\\n            {\\n                low++;\\n                high--;\\n                continue;\\n            } \\n            if(nums[low] <= nums[mid]) //left half is sorted\\n            {\\n                if(target<nums[mid] && target>=nums[low]) high = mid-1;\\n                else low = mid+1;\\n            }\\n            else //right half is sorted\\n            {\\n                if(target>nums[mid] && target<=nums[high]) low = mid+1;\\n                else high = mid-1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n![d691ebb2-63ce-470b-92ab-474a955c3392_1676870623.1558764.jpeg](https://assets.leetcode.com/users/images/ccc005fe-01af-4dc5-82e0-50395b2addcf_1687554729.0037694.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int low = 0, high = n-1, mid;\\n        while(low<=high)\\n        {\\n            mid=(low+high)/2;\\n            if(nums[mid]==target) return true;\\n            //Check which half is sorted\\n            //Also since duplicates are possible we could have a problem for the edge case such as nums[low]==nums[mid]==nums[high]\\n            //eg [3 1 2 3 3 3 3] now its fucked so we need to take care of this case\\n            if(nums[low] == nums[mid] && nums[mid] == nums[high])\\n            {\\n                low++;\\n                high--;\\n                continue;\\n            } \\n            if(nums[low] <= nums[mid]) //left half is sorted\\n            {\\n                if(target<nums[mid] && target>=nums[low]) high = mid-1;\\n                else low = mid+1;\\n            }\\n            else //right half is sorted\\n            {\\n                if(target>nums[mid] && target<=nums[high]) low = mid+1;\\n                else high = mid-1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566004,
                "title": "cpp-simple-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n`Initialize two pointers, l and r, to represent the left and right boundaries of the search range.`\\n\\n`Use binary search logic to repeatedly narrow down the search range by comparing the middle element with the target value and updating l and r accordingly.`\\n\\n`Return true if the target value is found, and false if it is not found in the array.`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We start by initializing two pointers, l and r, to represent the left and right boundaries of the search range. Initially, l points to the first element of the array, and r points to the last element.\\n\\n- We enter a while loop that continues as long as there are elements left to search within the range. The loop terminates when l becomes greater than r.\\n\\n- Inside the loop, we calculate the middle index mid as the average of l and r. This ensures that we select the middle element in case l and r are close to each other.\\n\\n- We check if the value at the middle index mid is equal to the target value. If it is, we return true to indicate that the target value has been found.\\n\\n- If the left value nums[l] is equal to the middle value nums[mid], and the right value nums[r] is also equal to nums[mid], it means there are duplicate elements at the boundaries of the search range. In this case, we increment l by 1 and decrement r by 1 to narrow down the search range and eliminate the duplicate elements.\\n\\n- If the subarray from l to mid is sorted, it means the pivot point (the point where the rotation occurs) is on the right side. We check if the target value falls within the sorted range. If it does, we update r to mid - 1 to search the left half of the array in the next iteration. Otherwise, we update l to mid + 1 to search the right half.\\n\\n- If the pivot point is on the left side of the mid index, it means the subarray from mid to r is sorted. We check if the target value falls within this sorted range. If it does, we update l to mid + 1 to search the right half of the array in the next iteration. Otherwise, we update r to mid - 1 to search the left half.\\n\\n- If none of the above conditions are met within the while loop, it means the target value is not found in the array. In this case, we return false.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n`The time complexity of this code is O(log n), where n is the number of elements in the input array. This is because the code utilizes a binary search algorithm, which divides the search range in half in each iteration. As a result, the number of iterations required to find the target value grows logarithmically with respect to the size of the array.`\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n`The space complexity of this code is O(1) because it uses a constant amount of extra space. The only variables used are l, r, and mid, which occupy a constant amount of memory regardless of the size of the input array. The code does not utilize any additional data structures or recursion that would consume additional space proportional to the input size.`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int start = 0, end = n-1;\\n\\n        while(start<=end)\\n        {\\n            int mid = (start+end)/2;\\n\\n            if(nums[mid]==target) return true;\\n\\n            if((nums[start] == nums[mid]) && (nums[end] == nums[mid]))\\n            {\\n                start++;\\n                end--;\\n            }\\n            else if(nums[mid]>nums[end])\\n            {\\n               if(target<nums[mid] && target>=nums[start])\\n               end = mid-1;\\n               else\\n               start = mid+1;\\n            }\\n            else if(nums[mid]<nums[start])\\n            {\\n               if(target>nums[mid] && target<=nums[end])\\n               start = mid+1;\\n               else\\n               end = mid-1;\\n            }\\n            else\\n            {\\n                if(target<nums[mid])\\n                end = mid-1;\\n                else\\n                start = mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int start = 0, end = n-1;\\n\\n        while(start<=end)\\n        {\\n            int mid = (start+end)/2;\\n\\n            if(nums[mid]==target) return true;\\n\\n            if((nums[start] == nums[mid]) && (nums[end] == nums[mid]))\\n            {\\n                start++;\\n                end--;\\n            }\\n            else if(nums[mid]>nums[end])\\n            {\\n               if(target<nums[mid] && target>=nums[start])\\n               end = mid-1;\\n               else\\n               start = mid+1;\\n            }\\n            else if(nums[mid]<nums[start])\\n            {\\n               if(target>nums[mid] && target<=nums[end])\\n               start = mid+1;\\n               else\\n               end = mid-1;\\n            }\\n            else\\n            {\\n                if(target<nums[mid])\\n                end = mid-1;\\n                else\\n                start = mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401930,
                "title": "java-solution-beats-100-binary-search",
                "content": "# Intuition\\nBinary Search\\n\\n# Approach\\nFind the pivot point then apply Binary Search to both set of elements which are before pivot and after pivot\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int pivot = 0;\\n        for(int i = 0; i < nums.length - 1; i++) {\\n            if(nums[i] > nums[i+1]) {\\n                pivot = i;\\n                break;\\n            }\\n        }\\n        int a = binarySearch(nums, 0 , pivot, target);\\n        if(a >= 0)\\n            return true;\\n        a = binarySearch(nums, pivot+1, nums.length - 1, target);\\n        if(a > 0)\\n            return true;\\n        return false;\\n    }\\n    int binarySearch(int nums[], int l, int r, int target) {\\n\\n        while(l <= r) {\\n            int mid = (l + r)/2;\\n            if(nums[mid] == target)\\n                return mid;\\n            else if(nums[mid] < target)\\n                l = mid + 1;\\n            else\\n                r = mid - 1; \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int pivot = 0;\\n        for(int i = 0; i < nums.length - 1; i++) {\\n            if(nums[i] > nums[i+1]) {\\n                pivot = i;\\n                break;\\n            }\\n        }\\n        int a = binarySearch(nums, 0 , pivot, target);\\n        if(a >= 0)\\n            return true;\\n        a = binarySearch(nums, pivot+1, nums.length - 1, target);\\n        if(a > 0)\\n            return true;\\n        return false;\\n    }\\n    int binarySearch(int nums[], int l, int r, int target) {\\n\\n        while(l <= r) {\\n            int mid = (l + r)/2;\\n            if(nums[mid] == target)\\n                return mid;\\n            else if(nums[mid] < target)\\n                l = mid + 1;\\n            else\\n                r = mid - 1; \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281351,
                "title": "binary-search-best-solution-c-explanation",
                "content": "# Intuition\\nwe can divide a given array into two parts that are sorted. This gives us hints to use binary search.\\n\\n# Approach\\n1. We divide the array into parts. It is done using two pointers, low and high, and dividing the range between them by 2\\n2. Check if the target is present in the midpoint, calculated before, of the array. If not present, \\n3. check if the left half of the array is sorted. This implies that binary search can be applied in the left half of the array provided the target lies between the value range. \\n4. Else check into the right half of the array. Repeat the above steps until low <= high.\\n\\n# Complexity\\n- Time complexity:\\n$$O(log(n))$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int t) {\\n        int n= nums.size();\\n        int low=0, high=n-1;\\n        while(low<=high)\\n        {\\n           int mid=low+(high-low)/2;\\n           if(nums[mid]==t)\\n           {return true;}\\n    else if((nums[low]==nums[mid]) && (nums[high]==nums[mid])){\\n                low++; high--;\\n            }\\n           else if(nums[low]<=nums[mid])\\n           {\\n              if(nums[low]<=t and t<nums[mid])\\n              {\\n                high=mid-1;\\n              }\\n              else\\n              {\\n                low=mid+1; \\n              }\\n           }\\n           else\\n           {\\n              if(nums[mid]<t and t<=nums[high])\\n              {\\n                low=mid+1;\\n              }\\n              else\\n              {\\n                high=mid-1;\\n              }\\n           }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int t) {\\n        int n= nums.size();\\n        int low=0, high=n-1;\\n        while(low<=high)\\n        {\\n           int mid=low+(high-low)/2;\\n           if(nums[mid]==t)\\n           {return true;}\\n    else if((nums[low]==nums[mid]) && (nums[high]==nums[mid])){\\n                low++; high--;\\n            }\\n           else if(nums[low]<=nums[mid])\\n           {\\n              if(nums[low]<=t and t<nums[mid])\\n              {\\n                high=mid-1;\\n              }\\n              else\\n              {\\n                low=mid+1; \\n              }\\n           }\\n           else\\n           {\\n              if(nums[mid]<t and t<=nums[high])\\n              {\\n                low=mid+1;\\n              }\\n              else\\n              {\\n                high=mid-1;\\n              }\\n           }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259378,
                "title": "easy-solution-in-java-using-hashset-binary-search",
                "content": "Upvote if you like it\\n\\n# Code\\n\\n# Using binary search\\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int first=0;\\n        int last=nums.length-1;\\n        while(first<=last)\\n        {\\n            int mid=(last-first)/2+first;\\n            if(nums[mid]==target)\\n            {\\n                return true;\\n            }\\n            else if(nums[mid]<target)\\n            {\\n                first=mid+1;\\n            }\\n            else\\n            {\\n                last=mid-1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n# Using HashSet\\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i:nums)\\n        {\\n            set.add(i);\\n        }\\n        return set.contains(target);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int first=0;\\n        int last=nums.length-1;\\n        while(first<=last)\\n        {\\n            int mid=(last-first)/2+first;\\n            if(nums[mid]==target)\\n            {\\n                return true;\\n            }\\n            else if(nums[mid]<target)\\n            {\\n                first=mid+1;\\n            }\\n            else\\n            {\\n                last=mid-1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i:nums)\\n        {\\n            set.add(i);\\n        }\\n        return set.contains(target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228571,
                "title": "searching-in-rotated-sorted-array-using-modified-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking to search for a target value in a rotated sorted array. My initial thoughts would be to use binary search to find the target value. However, since the array is rotated, we cannot directly apply binary search on it. We have to come up with some modifications to the standard binary search algorithm to apply it on a rotated sorted array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, we can use a modified version of binary search. The idea is to divide the array into two parts and find which part the target value belongs to. We can do this by comparing the target value with the middle element of the array. If the middle element is equal to the target value, we return true. If not, we check which part of the array the target value belongs to. We can determine this by checking if the left half or the right half of the array is sorted. If the left half is sorted, we check if the target value is within the range of the left half, and if it is, we continue the search on the left half. Otherwise, we search on the right half. Similarly, if the right half is sorted, we check if the target value is within the range of the right half, and if it is, we continue the search on the right half. Otherwise, we search on the left half. We repeat this process until we find the target value or until we have exhausted the entire array.\\n# Complexity\\n- Time complexity: The time complexity of this approach is $$O(log n)$$ because we are dividing the array in half at each iteration of the while loop, so the search space is reduced by half with each iteration.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity of this approach is $$O(1)$$ because we are not using any extra space, only the variables low, high, and mid.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n\\n        low = 0\\n        high = len(nums) - 1\\n\\n\\n        while low <= high:\\n            mid = (low + high) // 2\\n            \\n            if nums[mid] == target:\\n                return True\\n            \\n            if nums[mid] == nums[low]:\\n                low += 1\\n                continue\\n                \\n            if nums[mid] > nums[high]:\\n                if nums[low] <= target < nums[mid]:\\n                    high = mid - 1\\n                else:\\n                    low = mid + 1\\n            elif nums[mid] < nums[high]:\\n                if nums[mid] < target <= nums[high]:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n            else:\\n                high -= 1\\n                \\n\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n\\n        low = 0\\n        high = len(nums) - 1\\n\\n\\n        while low <= high:\\n            mid = (low + high) // 2\\n            \\n            if nums[mid] == target:\\n                return True\\n            \\n            if nums[mid] == nums[low]:\\n                low += 1\\n                continue\\n                \\n            if nums[mid] > nums[high]:\\n                if nums[low] <= target < nums[mid]:\\n                    high = mid - 1\\n                else:\\n                    low = mid + 1\\n            elif nums[mid] < nums[high]:\\n                if nums[mid] < target <= nums[high]:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n            else:\\n                high -= 1\\n                \\n\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151004,
                "title": "o-log-n-solution-c-o-1-sc",
                "content": "# Intuition\\nbinary search reduces the search space size/2 so we only have to chose one part where the element may lie.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int s=0,e=nums.size()-1;\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(nums[mid]==target){\\n                return true;\\n            }\\n            if(nums[mid]==nums[s]&&nums[mid]==nums[e]){\\n                s++;e--;\\n            }\\n            else if(nums[mid]>=nums[s]){\\n                if(nums[s]<=target &&nums[mid]>target) e=mid-1;\\n                else s=mid+1;\\n            }\\n            else{\\n            if(nums[mid]<target &&nums[e]>=target) s=mid+1;\\n            else e=mid-1;\\n            }\\n        }\\n        return false;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int s=0,e=nums.size()-1;\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(nums[mid]==target){\\n                return true;\\n            }\\n            if(nums[mid]==nums[s]&&nums[mid]==nums[e]){\\n                s++;e--;\\n            }\\n            else if(nums[mid]>=nums[s]){\\n                if(nums[s]<=target &&nums[mid]>target) e=mid-1;\\n                else s=mid+1;\\n            }\\n            else{\\n            if(nums[mid]<target &&nums[e]>=target) s=mid+1;\\n            else e=mid-1;\\n            }\\n        }\\n        return false;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970283,
                "title": "java-2-line-100-faster-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        for (int n : nums) if (n == target) return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        for (int n : nums) if (n == target) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962805,
                "title": "c-binary-search-easy-approach",
                "content": "Here is my c++ code for this problem\\n\\n# Brute Force:-\\n# Complexity\\n- Time complexity:O(N)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        for(int i=0; i<nums.size(); i++){if(nums[i]==target){return true;}}\\n        return false;\\n    }\\n};\\n```\\n\\n# Binary Search\\n# Complexity\\n- Time complexity:O(logN)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int i=0, j=nums.size()-1;\\n        while(i<=j){\\n            int mid=i+(j-i)/2;\\n            if (nums[mid]==target){return true;}\\n            if((nums[i]==nums[mid]) && (nums[j]==nums[mid])){\\n                i++; j--;\\n            }\\n            else if(nums[i]<=nums[mid]){\\n                if((nums[i]<=target) && (nums[mid]>target)){\\n                    j=mid-1;\\n                }\\n                else{\\n                    i=mid+1;\\n                }\\n            }\\n            else{\\n                if((nums[mid]<target) && (nums[j]>=target)){\\n                    i=mid+1;\\n                }\\n                else{\\n                    j=mid-1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        for(int i=0; i<nums.size(); i++){if(nums[i]==target){return true;}}\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int i=0, j=nums.size()-1;\\n        while(i<=j){\\n            int mid=i+(j-i)/2;\\n            if (nums[mid]==target){return true;}\\n            if((nums[i]==nums[mid]) && (nums[j]==nums[mid])){\\n                i++; j--;\\n            }\\n            else if(nums[i]<=nums[mid]){\\n                if((nums[i]<=target) && (nums[mid]>target)){\\n                    j=mid-1;\\n                }\\n                else{\\n                    i=mid+1;\\n                }\\n            }\\n            else{\\n                if((nums[mid]<target) && (nums[j]>=target)){\\n                    i=mid+1;\\n                }\\n                else{\\n                    j=mid-1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875547,
                "title": "60-faster-binary-search-o-logn-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int l = 0,r = nums.size() - 1,mid;\\n        while(l <= r)\\n        {\\n            mid = l + ((r-l)>>1);\\n            if (nums[mid] == target)\\n                return true;\\n            if((nums[l] == nums[mid]) && (nums[r] == nums[mid]))\\n            {\\n                l++;\\n                r--;\\n            }\\n            else if(nums[l] <= nums[mid])\\n            {\\n                if((nums[l] <= target) && (nums[mid] > target))\\n                    r = mid - 1;\\n                else\\n                    l = mid + 1;\\n            }\\n            else\\n            {\\n                if((nums[mid] < target) && (nums[r]>= target))\\n                    l = mid + 1;\\n                else\\n                    r = mid - 1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int l = 0,r = nums.size() - 1,mid;\\n        while(l <= r)\\n        {\\n            mid = l + ((r-l)>>1);\\n            if (nums[mid] == target)\\n                return true;\\n            if((nums[l] == nums[mid]) && (nums[r] == nums[mid]))\\n            {\\n                l++;\\n                r--;\\n            }\\n            else if(nums[l] <= nums[mid])\\n            {\\n                if((nums[l] <= target) && (nums[mid] > target))\\n                    r = mid - 1;\\n                else\\n                    l = mid + 1;\\n            }\\n            else\\n            {\\n                if((nums[mid] < target) && (nums[r]>= target))\\n                    l = mid + 1;\\n                else\\n                    r = mid - 1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765632,
                "title": "python-easy-solution-faster-than-97-545-in-o-log-n-time-complexity",
                "content": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        l=0\\n        h=len(nums)-1\\n        m=(l+h)>>1\\n        while l<=h:\\n            if nums[m]==target:\\n                return True\\n            elif nums[l]==nums[m] and nums[h]==nums[m]:\\n                l+=1\\n                h-=1\\n            elif nums[m]>=nums[l]:\\n                if target<=nums[m] and target>=nums[l]:\\n                    h=m-1\\n                else:\\n                    l=m+1\\n            else:\\n                if target>=nums[m] and target<=nums[h]:\\n                    l=m+1\\n                else:\\n                    h=m-1\\n            m=(l+h)>>1\\n        return False\\n ```   \\n            \\n                \\n                \\n",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        l=0\\n        h=len(nums)-1\\n        m=(l+h)>>1\\n        while l<=h:\\n            if nums[m]==target:\\n                return True\\n            elif nums[l]==nums[m] and nums[h]==nums[m]:\\n                l+=1\\n                h-=1\\n            elif nums[m]>=nums[l]:\\n                if target<=nums[m] and target>=nums[l]:\\n                    h=m-1\\n                else:\\n                    l=m+1\\n            else:\\n                if target>=nums[m] and target<=nums[h]:\\n                    l=m+1\\n                else:\\n                    h=m-1\\n            m=(l+h)>>1\\n        return False\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2746379,
                "title": "0-ms-faster-than-100-00-java",
                "content": "If you like it pls upvote\\n```\\n\\n    public boolean search(int[] nums, int target) {\\n        int end = nums.length-1;\\n        int mid = end/2;\\n        for (int i = 0, a=mid, b=mid, v=end; i <= mid; i++, a--, b++, v--)\\n            if (nums[i] == target || nums[a] == target || nums[v] == target || nums[b] == target) return true;\\n        return false;\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n    public boolean search(int[] nums, int target) {\\n        int end = nums.length-1;\\n        int mid = end/2;\\n        for (int i = 0, a=mid, b=mid, v=end; i <= mid; i++, a--, b++, v--)\\n            if (nums[i] == target || nums[a] == target || nums[v] == target || nums[b] == target) return true;\\n        return false;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2650486,
                "title": "easy-c-solution-faster-than-others-binary-search-algorithm-o-logn",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int len=nums.size();\\n        int low=0,high=len-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(nums[mid]==target)\\n                return true;\\n            \\n            if((nums[low]==nums[mid]) && (nums[mid]==nums[high])){\\n                low++;\\n                high--;\\n            }\\n            \\n            else if(nums[mid]>=nums[low]){\\n                //means first half is sorted\\n                if(target>=nums[low] && target<nums[mid])\\n                    high=mid-1;\\n                else\\n                    low=mid+1;\\n            }\\n            else{\\n                //means right part is sorted\\n\\n                if(target>nums[mid] && target<=nums[high])\\n                    low=mid+1;\\n                else\\n                    high=mid-1;\\n                \\n\\n            }\\n        }\\n        return false;\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int len=nums.size();\\n        int low=0,high=len-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(nums[mid]==target)\\n                return true;\\n            \\n            if((nums[low]==nums[mid]) && (nums[mid]==nums[high])){\\n                low++;\\n                high--;\\n            }\\n            \\n            else if(nums[mid]>=nums[low]){\\n                //means first half is sorted\\n                if(target>=nums[low] && target<nums[mid])\\n                    high=mid-1;\\n                else\\n                    low=mid+1;\\n            }\\n            else{\\n                //means right part is sorted\\n\\n                if(target>nums[mid] && target<=nums[high])\\n                    low=mid+1;\\n                else\\n                    high=mid-1;\\n                \\n\\n            }\\n        }\\n        return false;\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2007614,
                "content": [
                    {
                        "username": "Polokniko",
                        "content": "Forgive me for I have sinned.\n```\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        return target in nums\n```\n92.3% runtime 96.3% memory"
                    },
                    {
                        "username": "trag",
                        "content": "They won\\'t forgive you at the interview tho be aware of it"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@wafsinc](/wafsinc) Average case runtime of Editorial is still much better than the trivial solution. "
                    },
                    {
                        "username": "GD18",
                        "content": "damn you monster lol"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@0xcaffe1ne](/0xcaffe1ne) The \"Best Case Time Complexity\" is always O(1) if, e.g. the target is the first number in nums. The editorial solution does not do any better than the trivial solution."
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Setting the argument about whether this solution would work in an actual interview aside, this is still not optimal since the best case time complexity is $$O(n)$$ compared to the editorial\\'s $$O(\\\\log n)$$ (which was... kind of the whole point of this problem). The only reason that this solution is faster than 92.3% is because Python\\'s `in` keyword calls the magic function `__contains__`, which is most likely implemented in C - and is obviously going to be orders of magnitudes faster than interpreted Python code.  "
                    },
                    {
                        "username": "vivekup3424",
                        "content": "[@jeevanjoyal77](/jeevanjoyal77) Yeah we somtimes tend to overcomplicate things, but this question can be solved optimally using binary search."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "This one is definitely a solution, but here the runtime complexity is O(n), but we have to solve it in O(logn), So try to find the solution using Binary Search."
                    },
                    {
                        "username": "vivek-raj-gupta-2002",
                        "content": "Same for me God !!\\uD83D\\uDE05"
                    },
                    {
                        "username": "jeevanjoyal77",
                        "content": "lol\nI literally forgot about \"Common-Sense\".\nAnd did all types of circuses to solve this."
                    },
                    {
                        "username": "m-Just",
                        "content": "Given a size `n` and two integers `a != b`, we can always construct `n` different arrays of size `n` such that there is a single `a` while the rest are `b`, and clearly they are all valid rotated sorted arrays. In other words, even if `a` exists, it can be at any location; so in the worst case where the input array only contains `b`, an algorithm must access all `n` locations of such array to determine whether `a` exists."
                    },
                    {
                        "username": "exquiro",
                        "content": "Rather than making a new array, why not simply use linear search?"
                    },
                    {
                        "username": "ouromoros",
                        "content": "Consider the following array:\\n[0, 0, 0, 1]\\n\\nAfter rotation, the array could basically be any of the following:\\n1. [1, 0, 0, 0]\\n2. [0, 1, 0, 0]\\n3. [0, 0, 1, 0]\\n4. [0, 0, 0, 1]\\n\\nAnd without checking all of the elements (O(n) opeartion), no algorithm can be sure that it hasn\\'t met one of the above scenarios. \\n\\nEven after checking n-1 elements (which are all 0s), the algorithm cannot determine if the remaining one is the target.\\n\\nSummarized, an array whose elements are all of the same value must take O(n) time to check, no matter what clever trick is used."
                    },
                    {
                        "username": "r_patwari",
                        "content": "[@Mister_CK](/Mister_CK) Not really. Adding elements in the set `new Set(nums)` itself runs at `O(n)`. Thus complexity becomes `O(n)`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only need to know if a certain number is included right? I just made a Set from the array and use Set.has(), so:\n\nvar search = function(nums, target) {\n        let numsSet = new Set(nums);\n        return numsSet.has(target);\n};\n\nIs my whole answer, is that not O(1) complexity?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I agree. I solved this one and it is not a good interview question. The best solution here is to perform a search which decrements right if nums[mid] == nums[left].\\n\\nBasically you perform binary search if you can, and where you can\\'t you just iterate until you either find the pivot/target or can binary search further. It keeps the worst case at O(n)."
                    },
                    {
                        "username": "valree",
                        "content": "I\\'ve just spent half an hour debugging my code only to realize that the stupid test cases are actually looking for a true-false answer not an index where **the question CLEARLY states that we need to return an index...** I kind of suspected this since the outputs were true/false for the test cases but I was sure that someone would have fixed it by now given that this question is at least **6 YEARS OLD!!**\\n\\nI\\'ve been thinking about getting a premium but why would I do that if these people don\\'t care enough to fix a sentence on the question. There are a lot of questions out there where question makes no sense at all or completely incomprehensible with the language they use until you go to the discussion where people literally sit down and try to decipher what they actually mean on multiple topics."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The worst case is linear time which can not be improved.\neg. nums =\n[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1] \nIf I'm wrong, please correct me! There are many annoying testcases. In fact the linear search is not slow for those annoying testcases.\n"
                    },
                    {
                        "username": "marasigana",
                        "content": "Worst case is definitely O(n) because of the duplicates, like you mentioned. Binary search should work in close to O(log n) in the scenarios where there are not many duplicates."
                    },
                    {
                        "username": "kaxuna",
                        "content": "If someone asks this question on interview. They are probably looking for whether you can find an above statement or not more than whether you can bland bs & iterations "
                    },
                    {
                        "username": "Aadil42",
                        "content": "I\\'m stuck on the same test case. What a bitchy test case!!"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "It says this problem is a follow up for Search in Rotated Sorted Array.\\n\\nSearch in Rotated Sorted Array is a hard level question.\\n\\nIt is kinda un-intuitive for a medium level question to be a follow up for a hard question since I am doing all medium level questions first before I do hard level questions.\\n\\nIf this problem is easier than Search in Rotated Sorted Array, then I think Search in Rotated Sorted Array should be the follow up problem for this, not the other way around."
                    },
                    {
                        "username": "GustawB",
                        "content": "[@TheStormBird](/TheStormBird) the question you are replying to was posted 8 years ago"
                    },
                    {
                        "username": "TheStormBird",
                        "content": "Search in Rotated Sorted Array is not a hard level question, neither should it be."
                    },
                    {
                        "username": "aDDyy",
                        "content": "```\nif(nums[mid] == nums[ll] && nums[mid] == nums[ul])\n{\n       ll++;\n       ul--;\n}\n```\nJust remember this edge case if there r duplicates in the array. This edge case will make your work easier BUT yaa remember that in worst case TC will go O(n) & not O(log n)"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@shrutisharma99](/shrutisharma99) okk firstly for that u have to solve its easier version i.e search in rotated sorted array - i & then come to this problem & try to solve it . Here basically its same like the previous one but only diff is that u  have to take care of duplicates so for that u can use the above edge case that i have provided......u can also look at my code : https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/3888532/binarysearch-clean-c-code-valuable-variable-names/\nFor any queries u can DM me on my LinkedIN"
                    },
                    {
                        "username": "shrutisharma99",
                        "content": "can u tell me how u come up with solution\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "qkhhly",
                        "content": "first of all, the array is sorted so we must be able to use this information somehow. the rotated array can be visualized as below. We need to figure out a way to eliminate part of the array. we start with regular binary search, but we have to distinguish between the mid point being case A or case B (shown in figure). after that we can compare target with mid and eliminate part of the array.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813568.png)\\n\\nbut with duplicates, we will have some difficulty because in the following we cannot distinguish case A and case B. if mid == start, then it could be either case A or case B.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813918.png)\\n\\nin this case, we can just ignore start by doing start = start + 1, because we already know target is not nums[mid] (otherwise we would have returned already).\\n\\n#mahoupao"
                    },
                    {
                        "username": "kAc",
                        "content": "In general this problem cannot be solved faster than O(n) in worst case. \\nConsider a much simpler problem: given an array arr, there are two possible cases:\\n1. All elements are 0;\\n2. One element is 1, all other elements are 0.\\n\\nWe want to know which case we are in. Even for this simpler problem it requires O(n) time to solve since we easily construct an adversary to force the algorithm to query all positions. "
                    }
                ]
            },
            {
                "id": 1565702,
                "content": [
                    {
                        "username": "Polokniko",
                        "content": "Forgive me for I have sinned.\n```\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        return target in nums\n```\n92.3% runtime 96.3% memory"
                    },
                    {
                        "username": "trag",
                        "content": "They won\\'t forgive you at the interview tho be aware of it"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@wafsinc](/wafsinc) Average case runtime of Editorial is still much better than the trivial solution. "
                    },
                    {
                        "username": "GD18",
                        "content": "damn you monster lol"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@0xcaffe1ne](/0xcaffe1ne) The \"Best Case Time Complexity\" is always O(1) if, e.g. the target is the first number in nums. The editorial solution does not do any better than the trivial solution."
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Setting the argument about whether this solution would work in an actual interview aside, this is still not optimal since the best case time complexity is $$O(n)$$ compared to the editorial\\'s $$O(\\\\log n)$$ (which was... kind of the whole point of this problem). The only reason that this solution is faster than 92.3% is because Python\\'s `in` keyword calls the magic function `__contains__`, which is most likely implemented in C - and is obviously going to be orders of magnitudes faster than interpreted Python code.  "
                    },
                    {
                        "username": "vivekup3424",
                        "content": "[@jeevanjoyal77](/jeevanjoyal77) Yeah we somtimes tend to overcomplicate things, but this question can be solved optimally using binary search."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "This one is definitely a solution, but here the runtime complexity is O(n), but we have to solve it in O(logn), So try to find the solution using Binary Search."
                    },
                    {
                        "username": "vivek-raj-gupta-2002",
                        "content": "Same for me God !!\\uD83D\\uDE05"
                    },
                    {
                        "username": "jeevanjoyal77",
                        "content": "lol\nI literally forgot about \"Common-Sense\".\nAnd did all types of circuses to solve this."
                    },
                    {
                        "username": "m-Just",
                        "content": "Given a size `n` and two integers `a != b`, we can always construct `n` different arrays of size `n` such that there is a single `a` while the rest are `b`, and clearly they are all valid rotated sorted arrays. In other words, even if `a` exists, it can be at any location; so in the worst case where the input array only contains `b`, an algorithm must access all `n` locations of such array to determine whether `a` exists."
                    },
                    {
                        "username": "exquiro",
                        "content": "Rather than making a new array, why not simply use linear search?"
                    },
                    {
                        "username": "ouromoros",
                        "content": "Consider the following array:\\n[0, 0, 0, 1]\\n\\nAfter rotation, the array could basically be any of the following:\\n1. [1, 0, 0, 0]\\n2. [0, 1, 0, 0]\\n3. [0, 0, 1, 0]\\n4. [0, 0, 0, 1]\\n\\nAnd without checking all of the elements (O(n) opeartion), no algorithm can be sure that it hasn\\'t met one of the above scenarios. \\n\\nEven after checking n-1 elements (which are all 0s), the algorithm cannot determine if the remaining one is the target.\\n\\nSummarized, an array whose elements are all of the same value must take O(n) time to check, no matter what clever trick is used."
                    },
                    {
                        "username": "r_patwari",
                        "content": "[@Mister_CK](/Mister_CK) Not really. Adding elements in the set `new Set(nums)` itself runs at `O(n)`. Thus complexity becomes `O(n)`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only need to know if a certain number is included right? I just made a Set from the array and use Set.has(), so:\n\nvar search = function(nums, target) {\n        let numsSet = new Set(nums);\n        return numsSet.has(target);\n};\n\nIs my whole answer, is that not O(1) complexity?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I agree. I solved this one and it is not a good interview question. The best solution here is to perform a search which decrements right if nums[mid] == nums[left].\\n\\nBasically you perform binary search if you can, and where you can\\'t you just iterate until you either find the pivot/target or can binary search further. It keeps the worst case at O(n)."
                    },
                    {
                        "username": "valree",
                        "content": "I\\'ve just spent half an hour debugging my code only to realize that the stupid test cases are actually looking for a true-false answer not an index where **the question CLEARLY states that we need to return an index...** I kind of suspected this since the outputs were true/false for the test cases but I was sure that someone would have fixed it by now given that this question is at least **6 YEARS OLD!!**\\n\\nI\\'ve been thinking about getting a premium but why would I do that if these people don\\'t care enough to fix a sentence on the question. There are a lot of questions out there where question makes no sense at all or completely incomprehensible with the language they use until you go to the discussion where people literally sit down and try to decipher what they actually mean on multiple topics."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The worst case is linear time which can not be improved.\neg. nums =\n[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1] \nIf I'm wrong, please correct me! There are many annoying testcases. In fact the linear search is not slow for those annoying testcases.\n"
                    },
                    {
                        "username": "marasigana",
                        "content": "Worst case is definitely O(n) because of the duplicates, like you mentioned. Binary search should work in close to O(log n) in the scenarios where there are not many duplicates."
                    },
                    {
                        "username": "kaxuna",
                        "content": "If someone asks this question on interview. They are probably looking for whether you can find an above statement or not more than whether you can bland bs & iterations "
                    },
                    {
                        "username": "Aadil42",
                        "content": "I\\'m stuck on the same test case. What a bitchy test case!!"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "It says this problem is a follow up for Search in Rotated Sorted Array.\\n\\nSearch in Rotated Sorted Array is a hard level question.\\n\\nIt is kinda un-intuitive for a medium level question to be a follow up for a hard question since I am doing all medium level questions first before I do hard level questions.\\n\\nIf this problem is easier than Search in Rotated Sorted Array, then I think Search in Rotated Sorted Array should be the follow up problem for this, not the other way around."
                    },
                    {
                        "username": "GustawB",
                        "content": "[@TheStormBird](/TheStormBird) the question you are replying to was posted 8 years ago"
                    },
                    {
                        "username": "TheStormBird",
                        "content": "Search in Rotated Sorted Array is not a hard level question, neither should it be."
                    },
                    {
                        "username": "aDDyy",
                        "content": "```\nif(nums[mid] == nums[ll] && nums[mid] == nums[ul])\n{\n       ll++;\n       ul--;\n}\n```\nJust remember this edge case if there r duplicates in the array. This edge case will make your work easier BUT yaa remember that in worst case TC will go O(n) & not O(log n)"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@shrutisharma99](/shrutisharma99) okk firstly for that u have to solve its easier version i.e search in rotated sorted array - i & then come to this problem & try to solve it . Here basically its same like the previous one but only diff is that u  have to take care of duplicates so for that u can use the above edge case that i have provided......u can also look at my code : https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/3888532/binarysearch-clean-c-code-valuable-variable-names/\nFor any queries u can DM me on my LinkedIN"
                    },
                    {
                        "username": "shrutisharma99",
                        "content": "can u tell me how u come up with solution\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "qkhhly",
                        "content": "first of all, the array is sorted so we must be able to use this information somehow. the rotated array can be visualized as below. We need to figure out a way to eliminate part of the array. we start with regular binary search, but we have to distinguish between the mid point being case A or case B (shown in figure). after that we can compare target with mid and eliminate part of the array.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813568.png)\\n\\nbut with duplicates, we will have some difficulty because in the following we cannot distinguish case A and case B. if mid == start, then it could be either case A or case B.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813918.png)\\n\\nin this case, we can just ignore start by doing start = start + 1, because we already know target is not nums[mid] (otherwise we would have returned already).\\n\\n#mahoupao"
                    },
                    {
                        "username": "kAc",
                        "content": "In general this problem cannot be solved faster than O(n) in worst case. \\nConsider a much simpler problem: given an array arr, there are two possible cases:\\n1. All elements are 0;\\n2. One element is 1, all other elements are 0.\\n\\nWe want to know which case we are in. Even for this simpler problem it requires O(n) time to solve since we easily construct an adversary to force the algorithm to query all positions. "
                    }
                ]
            },
            {
                "id": 1568087,
                "content": [
                    {
                        "username": "Polokniko",
                        "content": "Forgive me for I have sinned.\n```\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        return target in nums\n```\n92.3% runtime 96.3% memory"
                    },
                    {
                        "username": "trag",
                        "content": "They won\\'t forgive you at the interview tho be aware of it"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@wafsinc](/wafsinc) Average case runtime of Editorial is still much better than the trivial solution. "
                    },
                    {
                        "username": "GD18",
                        "content": "damn you monster lol"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@0xcaffe1ne](/0xcaffe1ne) The \"Best Case Time Complexity\" is always O(1) if, e.g. the target is the first number in nums. The editorial solution does not do any better than the trivial solution."
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Setting the argument about whether this solution would work in an actual interview aside, this is still not optimal since the best case time complexity is $$O(n)$$ compared to the editorial\\'s $$O(\\\\log n)$$ (which was... kind of the whole point of this problem). The only reason that this solution is faster than 92.3% is because Python\\'s `in` keyword calls the magic function `__contains__`, which is most likely implemented in C - and is obviously going to be orders of magnitudes faster than interpreted Python code.  "
                    },
                    {
                        "username": "vivekup3424",
                        "content": "[@jeevanjoyal77](/jeevanjoyal77) Yeah we somtimes tend to overcomplicate things, but this question can be solved optimally using binary search."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "This one is definitely a solution, but here the runtime complexity is O(n), but we have to solve it in O(logn), So try to find the solution using Binary Search."
                    },
                    {
                        "username": "vivek-raj-gupta-2002",
                        "content": "Same for me God !!\\uD83D\\uDE05"
                    },
                    {
                        "username": "jeevanjoyal77",
                        "content": "lol\nI literally forgot about \"Common-Sense\".\nAnd did all types of circuses to solve this."
                    },
                    {
                        "username": "m-Just",
                        "content": "Given a size `n` and two integers `a != b`, we can always construct `n` different arrays of size `n` such that there is a single `a` while the rest are `b`, and clearly they are all valid rotated sorted arrays. In other words, even if `a` exists, it can be at any location; so in the worst case where the input array only contains `b`, an algorithm must access all `n` locations of such array to determine whether `a` exists."
                    },
                    {
                        "username": "exquiro",
                        "content": "Rather than making a new array, why not simply use linear search?"
                    },
                    {
                        "username": "ouromoros",
                        "content": "Consider the following array:\\n[0, 0, 0, 1]\\n\\nAfter rotation, the array could basically be any of the following:\\n1. [1, 0, 0, 0]\\n2. [0, 1, 0, 0]\\n3. [0, 0, 1, 0]\\n4. [0, 0, 0, 1]\\n\\nAnd without checking all of the elements (O(n) opeartion), no algorithm can be sure that it hasn\\'t met one of the above scenarios. \\n\\nEven after checking n-1 elements (which are all 0s), the algorithm cannot determine if the remaining one is the target.\\n\\nSummarized, an array whose elements are all of the same value must take O(n) time to check, no matter what clever trick is used."
                    },
                    {
                        "username": "r_patwari",
                        "content": "[@Mister_CK](/Mister_CK) Not really. Adding elements in the set `new Set(nums)` itself runs at `O(n)`. Thus complexity becomes `O(n)`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only need to know if a certain number is included right? I just made a Set from the array and use Set.has(), so:\n\nvar search = function(nums, target) {\n        let numsSet = new Set(nums);\n        return numsSet.has(target);\n};\n\nIs my whole answer, is that not O(1) complexity?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I agree. I solved this one and it is not a good interview question. The best solution here is to perform a search which decrements right if nums[mid] == nums[left].\\n\\nBasically you perform binary search if you can, and where you can\\'t you just iterate until you either find the pivot/target or can binary search further. It keeps the worst case at O(n)."
                    },
                    {
                        "username": "valree",
                        "content": "I\\'ve just spent half an hour debugging my code only to realize that the stupid test cases are actually looking for a true-false answer not an index where **the question CLEARLY states that we need to return an index...** I kind of suspected this since the outputs were true/false for the test cases but I was sure that someone would have fixed it by now given that this question is at least **6 YEARS OLD!!**\\n\\nI\\'ve been thinking about getting a premium but why would I do that if these people don\\'t care enough to fix a sentence on the question. There are a lot of questions out there where question makes no sense at all or completely incomprehensible with the language they use until you go to the discussion where people literally sit down and try to decipher what they actually mean on multiple topics."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The worst case is linear time which can not be improved.\neg. nums =\n[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1] \nIf I'm wrong, please correct me! There are many annoying testcases. In fact the linear search is not slow for those annoying testcases.\n"
                    },
                    {
                        "username": "marasigana",
                        "content": "Worst case is definitely O(n) because of the duplicates, like you mentioned. Binary search should work in close to O(log n) in the scenarios where there are not many duplicates."
                    },
                    {
                        "username": "kaxuna",
                        "content": "If someone asks this question on interview. They are probably looking for whether you can find an above statement or not more than whether you can bland bs & iterations "
                    },
                    {
                        "username": "Aadil42",
                        "content": "I\\'m stuck on the same test case. What a bitchy test case!!"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "It says this problem is a follow up for Search in Rotated Sorted Array.\\n\\nSearch in Rotated Sorted Array is a hard level question.\\n\\nIt is kinda un-intuitive for a medium level question to be a follow up for a hard question since I am doing all medium level questions first before I do hard level questions.\\n\\nIf this problem is easier than Search in Rotated Sorted Array, then I think Search in Rotated Sorted Array should be the follow up problem for this, not the other way around."
                    },
                    {
                        "username": "GustawB",
                        "content": "[@TheStormBird](/TheStormBird) the question you are replying to was posted 8 years ago"
                    },
                    {
                        "username": "TheStormBird",
                        "content": "Search in Rotated Sorted Array is not a hard level question, neither should it be."
                    },
                    {
                        "username": "aDDyy",
                        "content": "```\nif(nums[mid] == nums[ll] && nums[mid] == nums[ul])\n{\n       ll++;\n       ul--;\n}\n```\nJust remember this edge case if there r duplicates in the array. This edge case will make your work easier BUT yaa remember that in worst case TC will go O(n) & not O(log n)"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@shrutisharma99](/shrutisharma99) okk firstly for that u have to solve its easier version i.e search in rotated sorted array - i & then come to this problem & try to solve it . Here basically its same like the previous one but only diff is that u  have to take care of duplicates so for that u can use the above edge case that i have provided......u can also look at my code : https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/3888532/binarysearch-clean-c-code-valuable-variable-names/\nFor any queries u can DM me on my LinkedIN"
                    },
                    {
                        "username": "shrutisharma99",
                        "content": "can u tell me how u come up with solution\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "qkhhly",
                        "content": "first of all, the array is sorted so we must be able to use this information somehow. the rotated array can be visualized as below. We need to figure out a way to eliminate part of the array. we start with regular binary search, but we have to distinguish between the mid point being case A or case B (shown in figure). after that we can compare target with mid and eliminate part of the array.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813568.png)\\n\\nbut with duplicates, we will have some difficulty because in the following we cannot distinguish case A and case B. if mid == start, then it could be either case A or case B.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813918.png)\\n\\nin this case, we can just ignore start by doing start = start + 1, because we already know target is not nums[mid] (otherwise we would have returned already).\\n\\n#mahoupao"
                    },
                    {
                        "username": "kAc",
                        "content": "In general this problem cannot be solved faster than O(n) in worst case. \\nConsider a much simpler problem: given an array arr, there are two possible cases:\\n1. All elements are 0;\\n2. One element is 1, all other elements are 0.\\n\\nWe want to know which case we are in. Even for this simpler problem it requires O(n) time to solve since we easily construct an adversary to force the algorithm to query all positions. "
                    }
                ]
            },
            {
                "id": 1567017,
                "content": [
                    {
                        "username": "Polokniko",
                        "content": "Forgive me for I have sinned.\n```\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        return target in nums\n```\n92.3% runtime 96.3% memory"
                    },
                    {
                        "username": "trag",
                        "content": "They won\\'t forgive you at the interview tho be aware of it"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@wafsinc](/wafsinc) Average case runtime of Editorial is still much better than the trivial solution. "
                    },
                    {
                        "username": "GD18",
                        "content": "damn you monster lol"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@0xcaffe1ne](/0xcaffe1ne) The \"Best Case Time Complexity\" is always O(1) if, e.g. the target is the first number in nums. The editorial solution does not do any better than the trivial solution."
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Setting the argument about whether this solution would work in an actual interview aside, this is still not optimal since the best case time complexity is $$O(n)$$ compared to the editorial\\'s $$O(\\\\log n)$$ (which was... kind of the whole point of this problem). The only reason that this solution is faster than 92.3% is because Python\\'s `in` keyword calls the magic function `__contains__`, which is most likely implemented in C - and is obviously going to be orders of magnitudes faster than interpreted Python code.  "
                    },
                    {
                        "username": "vivekup3424",
                        "content": "[@jeevanjoyal77](/jeevanjoyal77) Yeah we somtimes tend to overcomplicate things, but this question can be solved optimally using binary search."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "This one is definitely a solution, but here the runtime complexity is O(n), but we have to solve it in O(logn), So try to find the solution using Binary Search."
                    },
                    {
                        "username": "vivek-raj-gupta-2002",
                        "content": "Same for me God !!\\uD83D\\uDE05"
                    },
                    {
                        "username": "jeevanjoyal77",
                        "content": "lol\nI literally forgot about \"Common-Sense\".\nAnd did all types of circuses to solve this."
                    },
                    {
                        "username": "m-Just",
                        "content": "Given a size `n` and two integers `a != b`, we can always construct `n` different arrays of size `n` such that there is a single `a` while the rest are `b`, and clearly they are all valid rotated sorted arrays. In other words, even if `a` exists, it can be at any location; so in the worst case where the input array only contains `b`, an algorithm must access all `n` locations of such array to determine whether `a` exists."
                    },
                    {
                        "username": "exquiro",
                        "content": "Rather than making a new array, why not simply use linear search?"
                    },
                    {
                        "username": "ouromoros",
                        "content": "Consider the following array:\\n[0, 0, 0, 1]\\n\\nAfter rotation, the array could basically be any of the following:\\n1. [1, 0, 0, 0]\\n2. [0, 1, 0, 0]\\n3. [0, 0, 1, 0]\\n4. [0, 0, 0, 1]\\n\\nAnd without checking all of the elements (O(n) opeartion), no algorithm can be sure that it hasn\\'t met one of the above scenarios. \\n\\nEven after checking n-1 elements (which are all 0s), the algorithm cannot determine if the remaining one is the target.\\n\\nSummarized, an array whose elements are all of the same value must take O(n) time to check, no matter what clever trick is used."
                    },
                    {
                        "username": "r_patwari",
                        "content": "[@Mister_CK](/Mister_CK) Not really. Adding elements in the set `new Set(nums)` itself runs at `O(n)`. Thus complexity becomes `O(n)`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only need to know if a certain number is included right? I just made a Set from the array and use Set.has(), so:\n\nvar search = function(nums, target) {\n        let numsSet = new Set(nums);\n        return numsSet.has(target);\n};\n\nIs my whole answer, is that not O(1) complexity?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I agree. I solved this one and it is not a good interview question. The best solution here is to perform a search which decrements right if nums[mid] == nums[left].\\n\\nBasically you perform binary search if you can, and where you can\\'t you just iterate until you either find the pivot/target or can binary search further. It keeps the worst case at O(n)."
                    },
                    {
                        "username": "valree",
                        "content": "I\\'ve just spent half an hour debugging my code only to realize that the stupid test cases are actually looking for a true-false answer not an index where **the question CLEARLY states that we need to return an index...** I kind of suspected this since the outputs were true/false for the test cases but I was sure that someone would have fixed it by now given that this question is at least **6 YEARS OLD!!**\\n\\nI\\'ve been thinking about getting a premium but why would I do that if these people don\\'t care enough to fix a sentence on the question. There are a lot of questions out there where question makes no sense at all or completely incomprehensible with the language they use until you go to the discussion where people literally sit down and try to decipher what they actually mean on multiple topics."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The worst case is linear time which can not be improved.\neg. nums =\n[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1] \nIf I'm wrong, please correct me! There are many annoying testcases. In fact the linear search is not slow for those annoying testcases.\n"
                    },
                    {
                        "username": "marasigana",
                        "content": "Worst case is definitely O(n) because of the duplicates, like you mentioned. Binary search should work in close to O(log n) in the scenarios where there are not many duplicates."
                    },
                    {
                        "username": "kaxuna",
                        "content": "If someone asks this question on interview. They are probably looking for whether you can find an above statement or not more than whether you can bland bs & iterations "
                    },
                    {
                        "username": "Aadil42",
                        "content": "I\\'m stuck on the same test case. What a bitchy test case!!"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "It says this problem is a follow up for Search in Rotated Sorted Array.\\n\\nSearch in Rotated Sorted Array is a hard level question.\\n\\nIt is kinda un-intuitive for a medium level question to be a follow up for a hard question since I am doing all medium level questions first before I do hard level questions.\\n\\nIf this problem is easier than Search in Rotated Sorted Array, then I think Search in Rotated Sorted Array should be the follow up problem for this, not the other way around."
                    },
                    {
                        "username": "GustawB",
                        "content": "[@TheStormBird](/TheStormBird) the question you are replying to was posted 8 years ago"
                    },
                    {
                        "username": "TheStormBird",
                        "content": "Search in Rotated Sorted Array is not a hard level question, neither should it be."
                    },
                    {
                        "username": "aDDyy",
                        "content": "```\nif(nums[mid] == nums[ll] && nums[mid] == nums[ul])\n{\n       ll++;\n       ul--;\n}\n```\nJust remember this edge case if there r duplicates in the array. This edge case will make your work easier BUT yaa remember that in worst case TC will go O(n) & not O(log n)"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@shrutisharma99](/shrutisharma99) okk firstly for that u have to solve its easier version i.e search in rotated sorted array - i & then come to this problem & try to solve it . Here basically its same like the previous one but only diff is that u  have to take care of duplicates so for that u can use the above edge case that i have provided......u can also look at my code : https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/3888532/binarysearch-clean-c-code-valuable-variable-names/\nFor any queries u can DM me on my LinkedIN"
                    },
                    {
                        "username": "shrutisharma99",
                        "content": "can u tell me how u come up with solution\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "qkhhly",
                        "content": "first of all, the array is sorted so we must be able to use this information somehow. the rotated array can be visualized as below. We need to figure out a way to eliminate part of the array. we start with regular binary search, but we have to distinguish between the mid point being case A or case B (shown in figure). after that we can compare target with mid and eliminate part of the array.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813568.png)\\n\\nbut with duplicates, we will have some difficulty because in the following we cannot distinguish case A and case B. if mid == start, then it could be either case A or case B.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813918.png)\\n\\nin this case, we can just ignore start by doing start = start + 1, because we already know target is not nums[mid] (otherwise we would have returned already).\\n\\n#mahoupao"
                    },
                    {
                        "username": "kAc",
                        "content": "In general this problem cannot be solved faster than O(n) in worst case. \\nConsider a much simpler problem: given an array arr, there are two possible cases:\\n1. All elements are 0;\\n2. One element is 1, all other elements are 0.\\n\\nWe want to know which case we are in. Even for this simpler problem it requires O(n) time to solve since we easily construct an adversary to force the algorithm to query all positions. "
                    }
                ]
            },
            {
                "id": 2007640,
                "content": [
                    {
                        "username": "Polokniko",
                        "content": "Forgive me for I have sinned.\n```\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        return target in nums\n```\n92.3% runtime 96.3% memory"
                    },
                    {
                        "username": "trag",
                        "content": "They won\\'t forgive you at the interview tho be aware of it"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@wafsinc](/wafsinc) Average case runtime of Editorial is still much better than the trivial solution. "
                    },
                    {
                        "username": "GD18",
                        "content": "damn you monster lol"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@0xcaffe1ne](/0xcaffe1ne) The \"Best Case Time Complexity\" is always O(1) if, e.g. the target is the first number in nums. The editorial solution does not do any better than the trivial solution."
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Setting the argument about whether this solution would work in an actual interview aside, this is still not optimal since the best case time complexity is $$O(n)$$ compared to the editorial\\'s $$O(\\\\log n)$$ (which was... kind of the whole point of this problem). The only reason that this solution is faster than 92.3% is because Python\\'s `in` keyword calls the magic function `__contains__`, which is most likely implemented in C - and is obviously going to be orders of magnitudes faster than interpreted Python code.  "
                    },
                    {
                        "username": "vivekup3424",
                        "content": "[@jeevanjoyal77](/jeevanjoyal77) Yeah we somtimes tend to overcomplicate things, but this question can be solved optimally using binary search."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "This one is definitely a solution, but here the runtime complexity is O(n), but we have to solve it in O(logn), So try to find the solution using Binary Search."
                    },
                    {
                        "username": "vivek-raj-gupta-2002",
                        "content": "Same for me God !!\\uD83D\\uDE05"
                    },
                    {
                        "username": "jeevanjoyal77",
                        "content": "lol\nI literally forgot about \"Common-Sense\".\nAnd did all types of circuses to solve this."
                    },
                    {
                        "username": "m-Just",
                        "content": "Given a size `n` and two integers `a != b`, we can always construct `n` different arrays of size `n` such that there is a single `a` while the rest are `b`, and clearly they are all valid rotated sorted arrays. In other words, even if `a` exists, it can be at any location; so in the worst case where the input array only contains `b`, an algorithm must access all `n` locations of such array to determine whether `a` exists."
                    },
                    {
                        "username": "exquiro",
                        "content": "Rather than making a new array, why not simply use linear search?"
                    },
                    {
                        "username": "ouromoros",
                        "content": "Consider the following array:\\n[0, 0, 0, 1]\\n\\nAfter rotation, the array could basically be any of the following:\\n1. [1, 0, 0, 0]\\n2. [0, 1, 0, 0]\\n3. [0, 0, 1, 0]\\n4. [0, 0, 0, 1]\\n\\nAnd without checking all of the elements (O(n) opeartion), no algorithm can be sure that it hasn\\'t met one of the above scenarios. \\n\\nEven after checking n-1 elements (which are all 0s), the algorithm cannot determine if the remaining one is the target.\\n\\nSummarized, an array whose elements are all of the same value must take O(n) time to check, no matter what clever trick is used."
                    },
                    {
                        "username": "r_patwari",
                        "content": "[@Mister_CK](/Mister_CK) Not really. Adding elements in the set `new Set(nums)` itself runs at `O(n)`. Thus complexity becomes `O(n)`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only need to know if a certain number is included right? I just made a Set from the array and use Set.has(), so:\n\nvar search = function(nums, target) {\n        let numsSet = new Set(nums);\n        return numsSet.has(target);\n};\n\nIs my whole answer, is that not O(1) complexity?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I agree. I solved this one and it is not a good interview question. The best solution here is to perform a search which decrements right if nums[mid] == nums[left].\\n\\nBasically you perform binary search if you can, and where you can\\'t you just iterate until you either find the pivot/target or can binary search further. It keeps the worst case at O(n)."
                    },
                    {
                        "username": "valree",
                        "content": "I\\'ve just spent half an hour debugging my code only to realize that the stupid test cases are actually looking for a true-false answer not an index where **the question CLEARLY states that we need to return an index...** I kind of suspected this since the outputs were true/false for the test cases but I was sure that someone would have fixed it by now given that this question is at least **6 YEARS OLD!!**\\n\\nI\\'ve been thinking about getting a premium but why would I do that if these people don\\'t care enough to fix a sentence on the question. There are a lot of questions out there where question makes no sense at all or completely incomprehensible with the language they use until you go to the discussion where people literally sit down and try to decipher what they actually mean on multiple topics."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The worst case is linear time which can not be improved.\neg. nums =\n[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1] \nIf I'm wrong, please correct me! There are many annoying testcases. In fact the linear search is not slow for those annoying testcases.\n"
                    },
                    {
                        "username": "marasigana",
                        "content": "Worst case is definitely O(n) because of the duplicates, like you mentioned. Binary search should work in close to O(log n) in the scenarios where there are not many duplicates."
                    },
                    {
                        "username": "kaxuna",
                        "content": "If someone asks this question on interview. They are probably looking for whether you can find an above statement or not more than whether you can bland bs & iterations "
                    },
                    {
                        "username": "Aadil42",
                        "content": "I\\'m stuck on the same test case. What a bitchy test case!!"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "It says this problem is a follow up for Search in Rotated Sorted Array.\\n\\nSearch in Rotated Sorted Array is a hard level question.\\n\\nIt is kinda un-intuitive for a medium level question to be a follow up for a hard question since I am doing all medium level questions first before I do hard level questions.\\n\\nIf this problem is easier than Search in Rotated Sorted Array, then I think Search in Rotated Sorted Array should be the follow up problem for this, not the other way around."
                    },
                    {
                        "username": "GustawB",
                        "content": "[@TheStormBird](/TheStormBird) the question you are replying to was posted 8 years ago"
                    },
                    {
                        "username": "TheStormBird",
                        "content": "Search in Rotated Sorted Array is not a hard level question, neither should it be."
                    },
                    {
                        "username": "aDDyy",
                        "content": "```\nif(nums[mid] == nums[ll] && nums[mid] == nums[ul])\n{\n       ll++;\n       ul--;\n}\n```\nJust remember this edge case if there r duplicates in the array. This edge case will make your work easier BUT yaa remember that in worst case TC will go O(n) & not O(log n)"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@shrutisharma99](/shrutisharma99) okk firstly for that u have to solve its easier version i.e search in rotated sorted array - i & then come to this problem & try to solve it . Here basically its same like the previous one but only diff is that u  have to take care of duplicates so for that u can use the above edge case that i have provided......u can also look at my code : https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/3888532/binarysearch-clean-c-code-valuable-variable-names/\nFor any queries u can DM me on my LinkedIN"
                    },
                    {
                        "username": "shrutisharma99",
                        "content": "can u tell me how u come up with solution\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "qkhhly",
                        "content": "first of all, the array is sorted so we must be able to use this information somehow. the rotated array can be visualized as below. We need to figure out a way to eliminate part of the array. we start with regular binary search, but we have to distinguish between the mid point being case A or case B (shown in figure). after that we can compare target with mid and eliminate part of the array.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813568.png)\\n\\nbut with duplicates, we will have some difficulty because in the following we cannot distinguish case A and case B. if mid == start, then it could be either case A or case B.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813918.png)\\n\\nin this case, we can just ignore start by doing start = start + 1, because we already know target is not nums[mid] (otherwise we would have returned already).\\n\\n#mahoupao"
                    },
                    {
                        "username": "kAc",
                        "content": "In general this problem cannot be solved faster than O(n) in worst case. \\nConsider a much simpler problem: given an array arr, there are two possible cases:\\n1. All elements are 0;\\n2. One element is 1, all other elements are 0.\\n\\nWe want to know which case we are in. Even for this simpler problem it requires O(n) time to solve since we easily construct an adversary to force the algorithm to query all positions. "
                    }
                ]
            },
            {
                "id": 1565095,
                "content": [
                    {
                        "username": "Polokniko",
                        "content": "Forgive me for I have sinned.\n```\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        return target in nums\n```\n92.3% runtime 96.3% memory"
                    },
                    {
                        "username": "trag",
                        "content": "They won\\'t forgive you at the interview tho be aware of it"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@wafsinc](/wafsinc) Average case runtime of Editorial is still much better than the trivial solution. "
                    },
                    {
                        "username": "GD18",
                        "content": "damn you monster lol"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@0xcaffe1ne](/0xcaffe1ne) The \"Best Case Time Complexity\" is always O(1) if, e.g. the target is the first number in nums. The editorial solution does not do any better than the trivial solution."
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Setting the argument about whether this solution would work in an actual interview aside, this is still not optimal since the best case time complexity is $$O(n)$$ compared to the editorial\\'s $$O(\\\\log n)$$ (which was... kind of the whole point of this problem). The only reason that this solution is faster than 92.3% is because Python\\'s `in` keyword calls the magic function `__contains__`, which is most likely implemented in C - and is obviously going to be orders of magnitudes faster than interpreted Python code.  "
                    },
                    {
                        "username": "vivekup3424",
                        "content": "[@jeevanjoyal77](/jeevanjoyal77) Yeah we somtimes tend to overcomplicate things, but this question can be solved optimally using binary search."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "This one is definitely a solution, but here the runtime complexity is O(n), but we have to solve it in O(logn), So try to find the solution using Binary Search."
                    },
                    {
                        "username": "vivek-raj-gupta-2002",
                        "content": "Same for me God !!\\uD83D\\uDE05"
                    },
                    {
                        "username": "jeevanjoyal77",
                        "content": "lol\nI literally forgot about \"Common-Sense\".\nAnd did all types of circuses to solve this."
                    },
                    {
                        "username": "m-Just",
                        "content": "Given a size `n` and two integers `a != b`, we can always construct `n` different arrays of size `n` such that there is a single `a` while the rest are `b`, and clearly they are all valid rotated sorted arrays. In other words, even if `a` exists, it can be at any location; so in the worst case where the input array only contains `b`, an algorithm must access all `n` locations of such array to determine whether `a` exists."
                    },
                    {
                        "username": "exquiro",
                        "content": "Rather than making a new array, why not simply use linear search?"
                    },
                    {
                        "username": "ouromoros",
                        "content": "Consider the following array:\\n[0, 0, 0, 1]\\n\\nAfter rotation, the array could basically be any of the following:\\n1. [1, 0, 0, 0]\\n2. [0, 1, 0, 0]\\n3. [0, 0, 1, 0]\\n4. [0, 0, 0, 1]\\n\\nAnd without checking all of the elements (O(n) opeartion), no algorithm can be sure that it hasn\\'t met one of the above scenarios. \\n\\nEven after checking n-1 elements (which are all 0s), the algorithm cannot determine if the remaining one is the target.\\n\\nSummarized, an array whose elements are all of the same value must take O(n) time to check, no matter what clever trick is used."
                    },
                    {
                        "username": "r_patwari",
                        "content": "[@Mister_CK](/Mister_CK) Not really. Adding elements in the set `new Set(nums)` itself runs at `O(n)`. Thus complexity becomes `O(n)`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only need to know if a certain number is included right? I just made a Set from the array and use Set.has(), so:\n\nvar search = function(nums, target) {\n        let numsSet = new Set(nums);\n        return numsSet.has(target);\n};\n\nIs my whole answer, is that not O(1) complexity?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I agree. I solved this one and it is not a good interview question. The best solution here is to perform a search which decrements right if nums[mid] == nums[left].\\n\\nBasically you perform binary search if you can, and where you can\\'t you just iterate until you either find the pivot/target or can binary search further. It keeps the worst case at O(n)."
                    },
                    {
                        "username": "valree",
                        "content": "I\\'ve just spent half an hour debugging my code only to realize that the stupid test cases are actually looking for a true-false answer not an index where **the question CLEARLY states that we need to return an index...** I kind of suspected this since the outputs were true/false for the test cases but I was sure that someone would have fixed it by now given that this question is at least **6 YEARS OLD!!**\\n\\nI\\'ve been thinking about getting a premium but why would I do that if these people don\\'t care enough to fix a sentence on the question. There are a lot of questions out there where question makes no sense at all or completely incomprehensible with the language they use until you go to the discussion where people literally sit down and try to decipher what they actually mean on multiple topics."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The worst case is linear time which can not be improved.\neg. nums =\n[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1] \nIf I'm wrong, please correct me! There are many annoying testcases. In fact the linear search is not slow for those annoying testcases.\n"
                    },
                    {
                        "username": "marasigana",
                        "content": "Worst case is definitely O(n) because of the duplicates, like you mentioned. Binary search should work in close to O(log n) in the scenarios where there are not many duplicates."
                    },
                    {
                        "username": "kaxuna",
                        "content": "If someone asks this question on interview. They are probably looking for whether you can find an above statement or not more than whether you can bland bs & iterations "
                    },
                    {
                        "username": "Aadil42",
                        "content": "I\\'m stuck on the same test case. What a bitchy test case!!"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "It says this problem is a follow up for Search in Rotated Sorted Array.\\n\\nSearch in Rotated Sorted Array is a hard level question.\\n\\nIt is kinda un-intuitive for a medium level question to be a follow up for a hard question since I am doing all medium level questions first before I do hard level questions.\\n\\nIf this problem is easier than Search in Rotated Sorted Array, then I think Search in Rotated Sorted Array should be the follow up problem for this, not the other way around."
                    },
                    {
                        "username": "GustawB",
                        "content": "[@TheStormBird](/TheStormBird) the question you are replying to was posted 8 years ago"
                    },
                    {
                        "username": "TheStormBird",
                        "content": "Search in Rotated Sorted Array is not a hard level question, neither should it be."
                    },
                    {
                        "username": "aDDyy",
                        "content": "```\nif(nums[mid] == nums[ll] && nums[mid] == nums[ul])\n{\n       ll++;\n       ul--;\n}\n```\nJust remember this edge case if there r duplicates in the array. This edge case will make your work easier BUT yaa remember that in worst case TC will go O(n) & not O(log n)"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@shrutisharma99](/shrutisharma99) okk firstly for that u have to solve its easier version i.e search in rotated sorted array - i & then come to this problem & try to solve it . Here basically its same like the previous one but only diff is that u  have to take care of duplicates so for that u can use the above edge case that i have provided......u can also look at my code : https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/3888532/binarysearch-clean-c-code-valuable-variable-names/\nFor any queries u can DM me on my LinkedIN"
                    },
                    {
                        "username": "shrutisharma99",
                        "content": "can u tell me how u come up with solution\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "qkhhly",
                        "content": "first of all, the array is sorted so we must be able to use this information somehow. the rotated array can be visualized as below. We need to figure out a way to eliminate part of the array. we start with regular binary search, but we have to distinguish between the mid point being case A or case B (shown in figure). after that we can compare target with mid and eliminate part of the array.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813568.png)\\n\\nbut with duplicates, we will have some difficulty because in the following we cannot distinguish case A and case B. if mid == start, then it could be either case A or case B.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813918.png)\\n\\nin this case, we can just ignore start by doing start = start + 1, because we already know target is not nums[mid] (otherwise we would have returned already).\\n\\n#mahoupao"
                    },
                    {
                        "username": "kAc",
                        "content": "In general this problem cannot be solved faster than O(n) in worst case. \\nConsider a much simpler problem: given an array arr, there are two possible cases:\\n1. All elements are 0;\\n2. One element is 1, all other elements are 0.\\n\\nWe want to know which case we are in. Even for this simpler problem it requires O(n) time to solve since we easily construct an adversary to force the algorithm to query all positions. "
                    }
                ]
            },
            {
                "id": 2007681,
                "content": [
                    {
                        "username": "Polokniko",
                        "content": "Forgive me for I have sinned.\n```\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        return target in nums\n```\n92.3% runtime 96.3% memory"
                    },
                    {
                        "username": "trag",
                        "content": "They won\\'t forgive you at the interview tho be aware of it"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@wafsinc](/wafsinc) Average case runtime of Editorial is still much better than the trivial solution. "
                    },
                    {
                        "username": "GD18",
                        "content": "damn you monster lol"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@0xcaffe1ne](/0xcaffe1ne) The \"Best Case Time Complexity\" is always O(1) if, e.g. the target is the first number in nums. The editorial solution does not do any better than the trivial solution."
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Setting the argument about whether this solution would work in an actual interview aside, this is still not optimal since the best case time complexity is $$O(n)$$ compared to the editorial\\'s $$O(\\\\log n)$$ (which was... kind of the whole point of this problem). The only reason that this solution is faster than 92.3% is because Python\\'s `in` keyword calls the magic function `__contains__`, which is most likely implemented in C - and is obviously going to be orders of magnitudes faster than interpreted Python code.  "
                    },
                    {
                        "username": "vivekup3424",
                        "content": "[@jeevanjoyal77](/jeevanjoyal77) Yeah we somtimes tend to overcomplicate things, but this question can be solved optimally using binary search."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "This one is definitely a solution, but here the runtime complexity is O(n), but we have to solve it in O(logn), So try to find the solution using Binary Search."
                    },
                    {
                        "username": "vivek-raj-gupta-2002",
                        "content": "Same for me God !!\\uD83D\\uDE05"
                    },
                    {
                        "username": "jeevanjoyal77",
                        "content": "lol\nI literally forgot about \"Common-Sense\".\nAnd did all types of circuses to solve this."
                    },
                    {
                        "username": "m-Just",
                        "content": "Given a size `n` and two integers `a != b`, we can always construct `n` different arrays of size `n` such that there is a single `a` while the rest are `b`, and clearly they are all valid rotated sorted arrays. In other words, even if `a` exists, it can be at any location; so in the worst case where the input array only contains `b`, an algorithm must access all `n` locations of such array to determine whether `a` exists."
                    },
                    {
                        "username": "exquiro",
                        "content": "Rather than making a new array, why not simply use linear search?"
                    },
                    {
                        "username": "ouromoros",
                        "content": "Consider the following array:\\n[0, 0, 0, 1]\\n\\nAfter rotation, the array could basically be any of the following:\\n1. [1, 0, 0, 0]\\n2. [0, 1, 0, 0]\\n3. [0, 0, 1, 0]\\n4. [0, 0, 0, 1]\\n\\nAnd without checking all of the elements (O(n) opeartion), no algorithm can be sure that it hasn\\'t met one of the above scenarios. \\n\\nEven after checking n-1 elements (which are all 0s), the algorithm cannot determine if the remaining one is the target.\\n\\nSummarized, an array whose elements are all of the same value must take O(n) time to check, no matter what clever trick is used."
                    },
                    {
                        "username": "r_patwari",
                        "content": "[@Mister_CK](/Mister_CK) Not really. Adding elements in the set `new Set(nums)` itself runs at `O(n)`. Thus complexity becomes `O(n)`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only need to know if a certain number is included right? I just made a Set from the array and use Set.has(), so:\n\nvar search = function(nums, target) {\n        let numsSet = new Set(nums);\n        return numsSet.has(target);\n};\n\nIs my whole answer, is that not O(1) complexity?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I agree. I solved this one and it is not a good interview question. The best solution here is to perform a search which decrements right if nums[mid] == nums[left].\\n\\nBasically you perform binary search if you can, and where you can\\'t you just iterate until you either find the pivot/target or can binary search further. It keeps the worst case at O(n)."
                    },
                    {
                        "username": "valree",
                        "content": "I\\'ve just spent half an hour debugging my code only to realize that the stupid test cases are actually looking for a true-false answer not an index where **the question CLEARLY states that we need to return an index...** I kind of suspected this since the outputs were true/false for the test cases but I was sure that someone would have fixed it by now given that this question is at least **6 YEARS OLD!!**\\n\\nI\\'ve been thinking about getting a premium but why would I do that if these people don\\'t care enough to fix a sentence on the question. There are a lot of questions out there where question makes no sense at all or completely incomprehensible with the language they use until you go to the discussion where people literally sit down and try to decipher what they actually mean on multiple topics."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The worst case is linear time which can not be improved.\neg. nums =\n[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1] \nIf I'm wrong, please correct me! There are many annoying testcases. In fact the linear search is not slow for those annoying testcases.\n"
                    },
                    {
                        "username": "marasigana",
                        "content": "Worst case is definitely O(n) because of the duplicates, like you mentioned. Binary search should work in close to O(log n) in the scenarios where there are not many duplicates."
                    },
                    {
                        "username": "kaxuna",
                        "content": "If someone asks this question on interview. They are probably looking for whether you can find an above statement or not more than whether you can bland bs & iterations "
                    },
                    {
                        "username": "Aadil42",
                        "content": "I\\'m stuck on the same test case. What a bitchy test case!!"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "It says this problem is a follow up for Search in Rotated Sorted Array.\\n\\nSearch in Rotated Sorted Array is a hard level question.\\n\\nIt is kinda un-intuitive for a medium level question to be a follow up for a hard question since I am doing all medium level questions first before I do hard level questions.\\n\\nIf this problem is easier than Search in Rotated Sorted Array, then I think Search in Rotated Sorted Array should be the follow up problem for this, not the other way around."
                    },
                    {
                        "username": "GustawB",
                        "content": "[@TheStormBird](/TheStormBird) the question you are replying to was posted 8 years ago"
                    },
                    {
                        "username": "TheStormBird",
                        "content": "Search in Rotated Sorted Array is not a hard level question, neither should it be."
                    },
                    {
                        "username": "aDDyy",
                        "content": "```\nif(nums[mid] == nums[ll] && nums[mid] == nums[ul])\n{\n       ll++;\n       ul--;\n}\n```\nJust remember this edge case if there r duplicates in the array. This edge case will make your work easier BUT yaa remember that in worst case TC will go O(n) & not O(log n)"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@shrutisharma99](/shrutisharma99) okk firstly for that u have to solve its easier version i.e search in rotated sorted array - i & then come to this problem & try to solve it . Here basically its same like the previous one but only diff is that u  have to take care of duplicates so for that u can use the above edge case that i have provided......u can also look at my code : https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/3888532/binarysearch-clean-c-code-valuable-variable-names/\nFor any queries u can DM me on my LinkedIN"
                    },
                    {
                        "username": "shrutisharma99",
                        "content": "can u tell me how u come up with solution\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "qkhhly",
                        "content": "first of all, the array is sorted so we must be able to use this information somehow. the rotated array can be visualized as below. We need to figure out a way to eliminate part of the array. we start with regular binary search, but we have to distinguish between the mid point being case A or case B (shown in figure). after that we can compare target with mid and eliminate part of the array.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813568.png)\\n\\nbut with duplicates, we will have some difficulty because in the following we cannot distinguish case A and case B. if mid == start, then it could be either case A or case B.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813918.png)\\n\\nin this case, we can just ignore start by doing start = start + 1, because we already know target is not nums[mid] (otherwise we would have returned already).\\n\\n#mahoupao"
                    },
                    {
                        "username": "kAc",
                        "content": "In general this problem cannot be solved faster than O(n) in worst case. \\nConsider a much simpler problem: given an array arr, there are two possible cases:\\n1. All elements are 0;\\n2. One element is 1, all other elements are 0.\\n\\nWe want to know which case we are in. Even for this simpler problem it requires O(n) time to solve since we easily construct an adversary to force the algorithm to query all positions. "
                    }
                ]
            },
            {
                "id": 1567113,
                "content": [
                    {
                        "username": "Polokniko",
                        "content": "Forgive me for I have sinned.\n```\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        return target in nums\n```\n92.3% runtime 96.3% memory"
                    },
                    {
                        "username": "trag",
                        "content": "They won\\'t forgive you at the interview tho be aware of it"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@wafsinc](/wafsinc) Average case runtime of Editorial is still much better than the trivial solution. "
                    },
                    {
                        "username": "GD18",
                        "content": "damn you monster lol"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@0xcaffe1ne](/0xcaffe1ne) The \"Best Case Time Complexity\" is always O(1) if, e.g. the target is the first number in nums. The editorial solution does not do any better than the trivial solution."
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Setting the argument about whether this solution would work in an actual interview aside, this is still not optimal since the best case time complexity is $$O(n)$$ compared to the editorial\\'s $$O(\\\\log n)$$ (which was... kind of the whole point of this problem). The only reason that this solution is faster than 92.3% is because Python\\'s `in` keyword calls the magic function `__contains__`, which is most likely implemented in C - and is obviously going to be orders of magnitudes faster than interpreted Python code.  "
                    },
                    {
                        "username": "vivekup3424",
                        "content": "[@jeevanjoyal77](/jeevanjoyal77) Yeah we somtimes tend to overcomplicate things, but this question can be solved optimally using binary search."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "This one is definitely a solution, but here the runtime complexity is O(n), but we have to solve it in O(logn), So try to find the solution using Binary Search."
                    },
                    {
                        "username": "vivek-raj-gupta-2002",
                        "content": "Same for me God !!\\uD83D\\uDE05"
                    },
                    {
                        "username": "jeevanjoyal77",
                        "content": "lol\nI literally forgot about \"Common-Sense\".\nAnd did all types of circuses to solve this."
                    },
                    {
                        "username": "m-Just",
                        "content": "Given a size `n` and two integers `a != b`, we can always construct `n` different arrays of size `n` such that there is a single `a` while the rest are `b`, and clearly they are all valid rotated sorted arrays. In other words, even if `a` exists, it can be at any location; so in the worst case where the input array only contains `b`, an algorithm must access all `n` locations of such array to determine whether `a` exists."
                    },
                    {
                        "username": "exquiro",
                        "content": "Rather than making a new array, why not simply use linear search?"
                    },
                    {
                        "username": "ouromoros",
                        "content": "Consider the following array:\\n[0, 0, 0, 1]\\n\\nAfter rotation, the array could basically be any of the following:\\n1. [1, 0, 0, 0]\\n2. [0, 1, 0, 0]\\n3. [0, 0, 1, 0]\\n4. [0, 0, 0, 1]\\n\\nAnd without checking all of the elements (O(n) opeartion), no algorithm can be sure that it hasn\\'t met one of the above scenarios. \\n\\nEven after checking n-1 elements (which are all 0s), the algorithm cannot determine if the remaining one is the target.\\n\\nSummarized, an array whose elements are all of the same value must take O(n) time to check, no matter what clever trick is used."
                    },
                    {
                        "username": "r_patwari",
                        "content": "[@Mister_CK](/Mister_CK) Not really. Adding elements in the set `new Set(nums)` itself runs at `O(n)`. Thus complexity becomes `O(n)`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only need to know if a certain number is included right? I just made a Set from the array and use Set.has(), so:\n\nvar search = function(nums, target) {\n        let numsSet = new Set(nums);\n        return numsSet.has(target);\n};\n\nIs my whole answer, is that not O(1) complexity?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I agree. I solved this one and it is not a good interview question. The best solution here is to perform a search which decrements right if nums[mid] == nums[left].\\n\\nBasically you perform binary search if you can, and where you can\\'t you just iterate until you either find the pivot/target or can binary search further. It keeps the worst case at O(n)."
                    },
                    {
                        "username": "valree",
                        "content": "I\\'ve just spent half an hour debugging my code only to realize that the stupid test cases are actually looking for a true-false answer not an index where **the question CLEARLY states that we need to return an index...** I kind of suspected this since the outputs were true/false for the test cases but I was sure that someone would have fixed it by now given that this question is at least **6 YEARS OLD!!**\\n\\nI\\'ve been thinking about getting a premium but why would I do that if these people don\\'t care enough to fix a sentence on the question. There are a lot of questions out there where question makes no sense at all or completely incomprehensible with the language they use until you go to the discussion where people literally sit down and try to decipher what they actually mean on multiple topics."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The worst case is linear time which can not be improved.\neg. nums =\n[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1] \nIf I'm wrong, please correct me! There are many annoying testcases. In fact the linear search is not slow for those annoying testcases.\n"
                    },
                    {
                        "username": "marasigana",
                        "content": "Worst case is definitely O(n) because of the duplicates, like you mentioned. Binary search should work in close to O(log n) in the scenarios where there are not many duplicates."
                    },
                    {
                        "username": "kaxuna",
                        "content": "If someone asks this question on interview. They are probably looking for whether you can find an above statement or not more than whether you can bland bs & iterations "
                    },
                    {
                        "username": "Aadil42",
                        "content": "I\\'m stuck on the same test case. What a bitchy test case!!"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "It says this problem is a follow up for Search in Rotated Sorted Array.\\n\\nSearch in Rotated Sorted Array is a hard level question.\\n\\nIt is kinda un-intuitive for a medium level question to be a follow up for a hard question since I am doing all medium level questions first before I do hard level questions.\\n\\nIf this problem is easier than Search in Rotated Sorted Array, then I think Search in Rotated Sorted Array should be the follow up problem for this, not the other way around."
                    },
                    {
                        "username": "GustawB",
                        "content": "[@TheStormBird](/TheStormBird) the question you are replying to was posted 8 years ago"
                    },
                    {
                        "username": "TheStormBird",
                        "content": "Search in Rotated Sorted Array is not a hard level question, neither should it be."
                    },
                    {
                        "username": "aDDyy",
                        "content": "```\nif(nums[mid] == nums[ll] && nums[mid] == nums[ul])\n{\n       ll++;\n       ul--;\n}\n```\nJust remember this edge case if there r duplicates in the array. This edge case will make your work easier BUT yaa remember that in worst case TC will go O(n) & not O(log n)"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@shrutisharma99](/shrutisharma99) okk firstly for that u have to solve its easier version i.e search in rotated sorted array - i & then come to this problem & try to solve it . Here basically its same like the previous one but only diff is that u  have to take care of duplicates so for that u can use the above edge case that i have provided......u can also look at my code : https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/3888532/binarysearch-clean-c-code-valuable-variable-names/\nFor any queries u can DM me on my LinkedIN"
                    },
                    {
                        "username": "shrutisharma99",
                        "content": "can u tell me how u come up with solution\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "qkhhly",
                        "content": "first of all, the array is sorted so we must be able to use this information somehow. the rotated array can be visualized as below. We need to figure out a way to eliminate part of the array. we start with regular binary search, but we have to distinguish between the mid point being case A or case B (shown in figure). after that we can compare target with mid and eliminate part of the array.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813568.png)\\n\\nbut with duplicates, we will have some difficulty because in the following we cannot distinguish case A and case B. if mid == start, then it could be either case A or case B.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813918.png)\\n\\nin this case, we can just ignore start by doing start = start + 1, because we already know target is not nums[mid] (otherwise we would have returned already).\\n\\n#mahoupao"
                    },
                    {
                        "username": "kAc",
                        "content": "In general this problem cannot be solved faster than O(n) in worst case. \\nConsider a much simpler problem: given an array arr, there are two possible cases:\\n1. All elements are 0;\\n2. One element is 1, all other elements are 0.\\n\\nWe want to know which case we are in. Even for this simpler problem it requires O(n) time to solve since we easily construct an adversary to force the algorithm to query all positions. "
                    }
                ]
            },
            {
                "id": 1573439,
                "content": [
                    {
                        "username": "Polokniko",
                        "content": "Forgive me for I have sinned.\n```\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        return target in nums\n```\n92.3% runtime 96.3% memory"
                    },
                    {
                        "username": "trag",
                        "content": "They won\\'t forgive you at the interview tho be aware of it"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@wafsinc](/wafsinc) Average case runtime of Editorial is still much better than the trivial solution. "
                    },
                    {
                        "username": "GD18",
                        "content": "damn you monster lol"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@0xcaffe1ne](/0xcaffe1ne) The \"Best Case Time Complexity\" is always O(1) if, e.g. the target is the first number in nums. The editorial solution does not do any better than the trivial solution."
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Setting the argument about whether this solution would work in an actual interview aside, this is still not optimal since the best case time complexity is $$O(n)$$ compared to the editorial\\'s $$O(\\\\log n)$$ (which was... kind of the whole point of this problem). The only reason that this solution is faster than 92.3% is because Python\\'s `in` keyword calls the magic function `__contains__`, which is most likely implemented in C - and is obviously going to be orders of magnitudes faster than interpreted Python code.  "
                    },
                    {
                        "username": "vivekup3424",
                        "content": "[@jeevanjoyal77](/jeevanjoyal77) Yeah we somtimes tend to overcomplicate things, but this question can be solved optimally using binary search."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "This one is definitely a solution, but here the runtime complexity is O(n), but we have to solve it in O(logn), So try to find the solution using Binary Search."
                    },
                    {
                        "username": "vivek-raj-gupta-2002",
                        "content": "Same for me God !!\\uD83D\\uDE05"
                    },
                    {
                        "username": "jeevanjoyal77",
                        "content": "lol\nI literally forgot about \"Common-Sense\".\nAnd did all types of circuses to solve this."
                    },
                    {
                        "username": "m-Just",
                        "content": "Given a size `n` and two integers `a != b`, we can always construct `n` different arrays of size `n` such that there is a single `a` while the rest are `b`, and clearly they are all valid rotated sorted arrays. In other words, even if `a` exists, it can be at any location; so in the worst case where the input array only contains `b`, an algorithm must access all `n` locations of such array to determine whether `a` exists."
                    },
                    {
                        "username": "exquiro",
                        "content": "Rather than making a new array, why not simply use linear search?"
                    },
                    {
                        "username": "ouromoros",
                        "content": "Consider the following array:\\n[0, 0, 0, 1]\\n\\nAfter rotation, the array could basically be any of the following:\\n1. [1, 0, 0, 0]\\n2. [0, 1, 0, 0]\\n3. [0, 0, 1, 0]\\n4. [0, 0, 0, 1]\\n\\nAnd without checking all of the elements (O(n) opeartion), no algorithm can be sure that it hasn\\'t met one of the above scenarios. \\n\\nEven after checking n-1 elements (which are all 0s), the algorithm cannot determine if the remaining one is the target.\\n\\nSummarized, an array whose elements are all of the same value must take O(n) time to check, no matter what clever trick is used."
                    },
                    {
                        "username": "r_patwari",
                        "content": "[@Mister_CK](/Mister_CK) Not really. Adding elements in the set `new Set(nums)` itself runs at `O(n)`. Thus complexity becomes `O(n)`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only need to know if a certain number is included right? I just made a Set from the array and use Set.has(), so:\n\nvar search = function(nums, target) {\n        let numsSet = new Set(nums);\n        return numsSet.has(target);\n};\n\nIs my whole answer, is that not O(1) complexity?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I agree. I solved this one and it is not a good interview question. The best solution here is to perform a search which decrements right if nums[mid] == nums[left].\\n\\nBasically you perform binary search if you can, and where you can\\'t you just iterate until you either find the pivot/target or can binary search further. It keeps the worst case at O(n)."
                    },
                    {
                        "username": "valree",
                        "content": "I\\'ve just spent half an hour debugging my code only to realize that the stupid test cases are actually looking for a true-false answer not an index where **the question CLEARLY states that we need to return an index...** I kind of suspected this since the outputs were true/false for the test cases but I was sure that someone would have fixed it by now given that this question is at least **6 YEARS OLD!!**\\n\\nI\\'ve been thinking about getting a premium but why would I do that if these people don\\'t care enough to fix a sentence on the question. There are a lot of questions out there where question makes no sense at all or completely incomprehensible with the language they use until you go to the discussion where people literally sit down and try to decipher what they actually mean on multiple topics."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The worst case is linear time which can not be improved.\neg. nums =\n[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1] \nIf I'm wrong, please correct me! There are many annoying testcases. In fact the linear search is not slow for those annoying testcases.\n"
                    },
                    {
                        "username": "marasigana",
                        "content": "Worst case is definitely O(n) because of the duplicates, like you mentioned. Binary search should work in close to O(log n) in the scenarios where there are not many duplicates."
                    },
                    {
                        "username": "kaxuna",
                        "content": "If someone asks this question on interview. They are probably looking for whether you can find an above statement or not more than whether you can bland bs & iterations "
                    },
                    {
                        "username": "Aadil42",
                        "content": "I\\'m stuck on the same test case. What a bitchy test case!!"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "It says this problem is a follow up for Search in Rotated Sorted Array.\\n\\nSearch in Rotated Sorted Array is a hard level question.\\n\\nIt is kinda un-intuitive for a medium level question to be a follow up for a hard question since I am doing all medium level questions first before I do hard level questions.\\n\\nIf this problem is easier than Search in Rotated Sorted Array, then I think Search in Rotated Sorted Array should be the follow up problem for this, not the other way around."
                    },
                    {
                        "username": "GustawB",
                        "content": "[@TheStormBird](/TheStormBird) the question you are replying to was posted 8 years ago"
                    },
                    {
                        "username": "TheStormBird",
                        "content": "Search in Rotated Sorted Array is not a hard level question, neither should it be."
                    },
                    {
                        "username": "aDDyy",
                        "content": "```\nif(nums[mid] == nums[ll] && nums[mid] == nums[ul])\n{\n       ll++;\n       ul--;\n}\n```\nJust remember this edge case if there r duplicates in the array. This edge case will make your work easier BUT yaa remember that in worst case TC will go O(n) & not O(log n)"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@shrutisharma99](/shrutisharma99) okk firstly for that u have to solve its easier version i.e search in rotated sorted array - i & then come to this problem & try to solve it . Here basically its same like the previous one but only diff is that u  have to take care of duplicates so for that u can use the above edge case that i have provided......u can also look at my code : https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/3888532/binarysearch-clean-c-code-valuable-variable-names/\nFor any queries u can DM me on my LinkedIN"
                    },
                    {
                        "username": "shrutisharma99",
                        "content": "can u tell me how u come up with solution\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "qkhhly",
                        "content": "first of all, the array is sorted so we must be able to use this information somehow. the rotated array can be visualized as below. We need to figure out a way to eliminate part of the array. we start with regular binary search, but we have to distinguish between the mid point being case A or case B (shown in figure). after that we can compare target with mid and eliminate part of the array.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813568.png)\\n\\nbut with duplicates, we will have some difficulty because in the following we cannot distinguish case A and case B. if mid == start, then it could be either case A or case B.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813918.png)\\n\\nin this case, we can just ignore start by doing start = start + 1, because we already know target is not nums[mid] (otherwise we would have returned already).\\n\\n#mahoupao"
                    },
                    {
                        "username": "kAc",
                        "content": "In general this problem cannot be solved faster than O(n) in worst case. \\nConsider a much simpler problem: given an array arr, there are two possible cases:\\n1. All elements are 0;\\n2. One element is 1, all other elements are 0.\\n\\nWe want to know which case we are in. Even for this simpler problem it requires O(n) time to solve since we easily construct an adversary to force the algorithm to query all positions. "
                    }
                ]
            },
            {
                "id": 1572048,
                "content": [
                    {
                        "username": "Polokniko",
                        "content": "Forgive me for I have sinned.\n```\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        return target in nums\n```\n92.3% runtime 96.3% memory"
                    },
                    {
                        "username": "trag",
                        "content": "They won\\'t forgive you at the interview tho be aware of it"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@wafsinc](/wafsinc) Average case runtime of Editorial is still much better than the trivial solution. "
                    },
                    {
                        "username": "GD18",
                        "content": "damn you monster lol"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@0xcaffe1ne](/0xcaffe1ne) The \"Best Case Time Complexity\" is always O(1) if, e.g. the target is the first number in nums. The editorial solution does not do any better than the trivial solution."
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Setting the argument about whether this solution would work in an actual interview aside, this is still not optimal since the best case time complexity is $$O(n)$$ compared to the editorial\\'s $$O(\\\\log n)$$ (which was... kind of the whole point of this problem). The only reason that this solution is faster than 92.3% is because Python\\'s `in` keyword calls the magic function `__contains__`, which is most likely implemented in C - and is obviously going to be orders of magnitudes faster than interpreted Python code.  "
                    },
                    {
                        "username": "vivekup3424",
                        "content": "[@jeevanjoyal77](/jeevanjoyal77) Yeah we somtimes tend to overcomplicate things, but this question can be solved optimally using binary search."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "This one is definitely a solution, but here the runtime complexity is O(n), but we have to solve it in O(logn), So try to find the solution using Binary Search."
                    },
                    {
                        "username": "vivek-raj-gupta-2002",
                        "content": "Same for me God !!\\uD83D\\uDE05"
                    },
                    {
                        "username": "jeevanjoyal77",
                        "content": "lol\nI literally forgot about \"Common-Sense\".\nAnd did all types of circuses to solve this."
                    },
                    {
                        "username": "m-Just",
                        "content": "Given a size `n` and two integers `a != b`, we can always construct `n` different arrays of size `n` such that there is a single `a` while the rest are `b`, and clearly they are all valid rotated sorted arrays. In other words, even if `a` exists, it can be at any location; so in the worst case where the input array only contains `b`, an algorithm must access all `n` locations of such array to determine whether `a` exists."
                    },
                    {
                        "username": "exquiro",
                        "content": "Rather than making a new array, why not simply use linear search?"
                    },
                    {
                        "username": "ouromoros",
                        "content": "Consider the following array:\\n[0, 0, 0, 1]\\n\\nAfter rotation, the array could basically be any of the following:\\n1. [1, 0, 0, 0]\\n2. [0, 1, 0, 0]\\n3. [0, 0, 1, 0]\\n4. [0, 0, 0, 1]\\n\\nAnd without checking all of the elements (O(n) opeartion), no algorithm can be sure that it hasn\\'t met one of the above scenarios. \\n\\nEven after checking n-1 elements (which are all 0s), the algorithm cannot determine if the remaining one is the target.\\n\\nSummarized, an array whose elements are all of the same value must take O(n) time to check, no matter what clever trick is used."
                    },
                    {
                        "username": "r_patwari",
                        "content": "[@Mister_CK](/Mister_CK) Not really. Adding elements in the set `new Set(nums)` itself runs at `O(n)`. Thus complexity becomes `O(n)`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only need to know if a certain number is included right? I just made a Set from the array and use Set.has(), so:\n\nvar search = function(nums, target) {\n        let numsSet = new Set(nums);\n        return numsSet.has(target);\n};\n\nIs my whole answer, is that not O(1) complexity?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I agree. I solved this one and it is not a good interview question. The best solution here is to perform a search which decrements right if nums[mid] == nums[left].\\n\\nBasically you perform binary search if you can, and where you can\\'t you just iterate until you either find the pivot/target or can binary search further. It keeps the worst case at O(n)."
                    },
                    {
                        "username": "valree",
                        "content": "I\\'ve just spent half an hour debugging my code only to realize that the stupid test cases are actually looking for a true-false answer not an index where **the question CLEARLY states that we need to return an index...** I kind of suspected this since the outputs were true/false for the test cases but I was sure that someone would have fixed it by now given that this question is at least **6 YEARS OLD!!**\\n\\nI\\'ve been thinking about getting a premium but why would I do that if these people don\\'t care enough to fix a sentence on the question. There are a lot of questions out there where question makes no sense at all or completely incomprehensible with the language they use until you go to the discussion where people literally sit down and try to decipher what they actually mean on multiple topics."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The worst case is linear time which can not be improved.\neg. nums =\n[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1] \nIf I'm wrong, please correct me! There are many annoying testcases. In fact the linear search is not slow for those annoying testcases.\n"
                    },
                    {
                        "username": "marasigana",
                        "content": "Worst case is definitely O(n) because of the duplicates, like you mentioned. Binary search should work in close to O(log n) in the scenarios where there are not many duplicates."
                    },
                    {
                        "username": "kaxuna",
                        "content": "If someone asks this question on interview. They are probably looking for whether you can find an above statement or not more than whether you can bland bs & iterations "
                    },
                    {
                        "username": "Aadil42",
                        "content": "I\\'m stuck on the same test case. What a bitchy test case!!"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "It says this problem is a follow up for Search in Rotated Sorted Array.\\n\\nSearch in Rotated Sorted Array is a hard level question.\\n\\nIt is kinda un-intuitive for a medium level question to be a follow up for a hard question since I am doing all medium level questions first before I do hard level questions.\\n\\nIf this problem is easier than Search in Rotated Sorted Array, then I think Search in Rotated Sorted Array should be the follow up problem for this, not the other way around."
                    },
                    {
                        "username": "GustawB",
                        "content": "[@TheStormBird](/TheStormBird) the question you are replying to was posted 8 years ago"
                    },
                    {
                        "username": "TheStormBird",
                        "content": "Search in Rotated Sorted Array is not a hard level question, neither should it be."
                    },
                    {
                        "username": "aDDyy",
                        "content": "```\nif(nums[mid] == nums[ll] && nums[mid] == nums[ul])\n{\n       ll++;\n       ul--;\n}\n```\nJust remember this edge case if there r duplicates in the array. This edge case will make your work easier BUT yaa remember that in worst case TC will go O(n) & not O(log n)"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@shrutisharma99](/shrutisharma99) okk firstly for that u have to solve its easier version i.e search in rotated sorted array - i & then come to this problem & try to solve it . Here basically its same like the previous one but only diff is that u  have to take care of duplicates so for that u can use the above edge case that i have provided......u can also look at my code : https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/3888532/binarysearch-clean-c-code-valuable-variable-names/\nFor any queries u can DM me on my LinkedIN"
                    },
                    {
                        "username": "shrutisharma99",
                        "content": "can u tell me how u come up with solution\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "qkhhly",
                        "content": "first of all, the array is sorted so we must be able to use this information somehow. the rotated array can be visualized as below. We need to figure out a way to eliminate part of the array. we start with regular binary search, but we have to distinguish between the mid point being case A or case B (shown in figure). after that we can compare target with mid and eliminate part of the array.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813568.png)\\n\\nbut with duplicates, we will have some difficulty because in the following we cannot distinguish case A and case B. if mid == start, then it could be either case A or case B.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813918.png)\\n\\nin this case, we can just ignore start by doing start = start + 1, because we already know target is not nums[mid] (otherwise we would have returned already).\\n\\n#mahoupao"
                    },
                    {
                        "username": "kAc",
                        "content": "In general this problem cannot be solved faster than O(n) in worst case. \\nConsider a much simpler problem: given an array arr, there are two possible cases:\\n1. All elements are 0;\\n2. One element is 1, all other elements are 0.\\n\\nWe want to know which case we are in. Even for this simpler problem it requires O(n) time to solve since we easily construct an adversary to force the algorithm to query all positions. "
                    }
                ]
            },
            {
                "id": 2007614,
                "content": [
                    {
                        "username": "Polokniko",
                        "content": "Forgive me for I have sinned.\n```\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        return target in nums\n```\n92.3% runtime 96.3% memory"
                    },
                    {
                        "username": "trag",
                        "content": "They won\\'t forgive you at the interview tho be aware of it"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@wafsinc](/wafsinc) Average case runtime of Editorial is still much better than the trivial solution. "
                    },
                    {
                        "username": "GD18",
                        "content": "damn you monster lol"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@0xcaffe1ne](/0xcaffe1ne) The \"Best Case Time Complexity\" is always O(1) if, e.g. the target is the first number in nums. The editorial solution does not do any better than the trivial solution."
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Setting the argument about whether this solution would work in an actual interview aside, this is still not optimal since the best case time complexity is $$O(n)$$ compared to the editorial\\'s $$O(\\\\log n)$$ (which was... kind of the whole point of this problem). The only reason that this solution is faster than 92.3% is because Python\\'s `in` keyword calls the magic function `__contains__`, which is most likely implemented in C - and is obviously going to be orders of magnitudes faster than interpreted Python code.  "
                    },
                    {
                        "username": "vivekup3424",
                        "content": "[@jeevanjoyal77](/jeevanjoyal77) Yeah we somtimes tend to overcomplicate things, but this question can be solved optimally using binary search."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "This one is definitely a solution, but here the runtime complexity is O(n), but we have to solve it in O(logn), So try to find the solution using Binary Search."
                    },
                    {
                        "username": "vivek-raj-gupta-2002",
                        "content": "Same for me God !!\\uD83D\\uDE05"
                    },
                    {
                        "username": "jeevanjoyal77",
                        "content": "lol\nI literally forgot about \"Common-Sense\".\nAnd did all types of circuses to solve this."
                    },
                    {
                        "username": "m-Just",
                        "content": "Given a size `n` and two integers `a != b`, we can always construct `n` different arrays of size `n` such that there is a single `a` while the rest are `b`, and clearly they are all valid rotated sorted arrays. In other words, even if `a` exists, it can be at any location; so in the worst case where the input array only contains `b`, an algorithm must access all `n` locations of such array to determine whether `a` exists."
                    },
                    {
                        "username": "exquiro",
                        "content": "Rather than making a new array, why not simply use linear search?"
                    },
                    {
                        "username": "ouromoros",
                        "content": "Consider the following array:\\n[0, 0, 0, 1]\\n\\nAfter rotation, the array could basically be any of the following:\\n1. [1, 0, 0, 0]\\n2. [0, 1, 0, 0]\\n3. [0, 0, 1, 0]\\n4. [0, 0, 0, 1]\\n\\nAnd without checking all of the elements (O(n) opeartion), no algorithm can be sure that it hasn\\'t met one of the above scenarios. \\n\\nEven after checking n-1 elements (which are all 0s), the algorithm cannot determine if the remaining one is the target.\\n\\nSummarized, an array whose elements are all of the same value must take O(n) time to check, no matter what clever trick is used."
                    },
                    {
                        "username": "r_patwari",
                        "content": "[@Mister_CK](/Mister_CK) Not really. Adding elements in the set `new Set(nums)` itself runs at `O(n)`. Thus complexity becomes `O(n)`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only need to know if a certain number is included right? I just made a Set from the array and use Set.has(), so:\n\nvar search = function(nums, target) {\n        let numsSet = new Set(nums);\n        return numsSet.has(target);\n};\n\nIs my whole answer, is that not O(1) complexity?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I agree. I solved this one and it is not a good interview question. The best solution here is to perform a search which decrements right if nums[mid] == nums[left].\\n\\nBasically you perform binary search if you can, and where you can\\'t you just iterate until you either find the pivot/target or can binary search further. It keeps the worst case at O(n)."
                    },
                    {
                        "username": "valree",
                        "content": "I\\'ve just spent half an hour debugging my code only to realize that the stupid test cases are actually looking for a true-false answer not an index where **the question CLEARLY states that we need to return an index...** I kind of suspected this since the outputs were true/false for the test cases but I was sure that someone would have fixed it by now given that this question is at least **6 YEARS OLD!!**\\n\\nI\\'ve been thinking about getting a premium but why would I do that if these people don\\'t care enough to fix a sentence on the question. There are a lot of questions out there where question makes no sense at all or completely incomprehensible with the language they use until you go to the discussion where people literally sit down and try to decipher what they actually mean on multiple topics."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The worst case is linear time which can not be improved.\neg. nums =\n[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1] \nIf I'm wrong, please correct me! There are many annoying testcases. In fact the linear search is not slow for those annoying testcases.\n"
                    },
                    {
                        "username": "marasigana",
                        "content": "Worst case is definitely O(n) because of the duplicates, like you mentioned. Binary search should work in close to O(log n) in the scenarios where there are not many duplicates."
                    },
                    {
                        "username": "kaxuna",
                        "content": "If someone asks this question on interview. They are probably looking for whether you can find an above statement or not more than whether you can bland bs & iterations "
                    },
                    {
                        "username": "Aadil42",
                        "content": "I\\'m stuck on the same test case. What a bitchy test case!!"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "It says this problem is a follow up for Search in Rotated Sorted Array.\\n\\nSearch in Rotated Sorted Array is a hard level question.\\n\\nIt is kinda un-intuitive for a medium level question to be a follow up for a hard question since I am doing all medium level questions first before I do hard level questions.\\n\\nIf this problem is easier than Search in Rotated Sorted Array, then I think Search in Rotated Sorted Array should be the follow up problem for this, not the other way around."
                    },
                    {
                        "username": "GustawB",
                        "content": "[@TheStormBird](/TheStormBird) the question you are replying to was posted 8 years ago"
                    },
                    {
                        "username": "TheStormBird",
                        "content": "Search in Rotated Sorted Array is not a hard level question, neither should it be."
                    },
                    {
                        "username": "aDDyy",
                        "content": "```\nif(nums[mid] == nums[ll] && nums[mid] == nums[ul])\n{\n       ll++;\n       ul--;\n}\n```\nJust remember this edge case if there r duplicates in the array. This edge case will make your work easier BUT yaa remember that in worst case TC will go O(n) & not O(log n)"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@shrutisharma99](/shrutisharma99) okk firstly for that u have to solve its easier version i.e search in rotated sorted array - i & then come to this problem & try to solve it . Here basically its same like the previous one but only diff is that u  have to take care of duplicates so for that u can use the above edge case that i have provided......u can also look at my code : https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/3888532/binarysearch-clean-c-code-valuable-variable-names/\nFor any queries u can DM me on my LinkedIN"
                    },
                    {
                        "username": "shrutisharma99",
                        "content": "can u tell me how u come up with solution\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "qkhhly",
                        "content": "first of all, the array is sorted so we must be able to use this information somehow. the rotated array can be visualized as below. We need to figure out a way to eliminate part of the array. we start with regular binary search, but we have to distinguish between the mid point being case A or case B (shown in figure). after that we can compare target with mid and eliminate part of the array.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813568.png)\\n\\nbut with duplicates, we will have some difficulty because in the following we cannot distinguish case A and case B. if mid == start, then it could be either case A or case B.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813918.png)\\n\\nin this case, we can just ignore start by doing start = start + 1, because we already know target is not nums[mid] (otherwise we would have returned already).\\n\\n#mahoupao"
                    },
                    {
                        "username": "kAc",
                        "content": "In general this problem cannot be solved faster than O(n) in worst case. \\nConsider a much simpler problem: given an array arr, there are two possible cases:\\n1. All elements are 0;\\n2. One element is 1, all other elements are 0.\\n\\nWe want to know which case we are in. Even for this simpler problem it requires O(n) time to solve since we easily construct an adversary to force the algorithm to query all positions. "
                    }
                ]
            },
            {
                "id": 1565702,
                "content": [
                    {
                        "username": "Polokniko",
                        "content": "Forgive me for I have sinned.\n```\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        return target in nums\n```\n92.3% runtime 96.3% memory"
                    },
                    {
                        "username": "trag",
                        "content": "They won\\'t forgive you at the interview tho be aware of it"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@wafsinc](/wafsinc) Average case runtime of Editorial is still much better than the trivial solution. "
                    },
                    {
                        "username": "GD18",
                        "content": "damn you monster lol"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@0xcaffe1ne](/0xcaffe1ne) The \"Best Case Time Complexity\" is always O(1) if, e.g. the target is the first number in nums. The editorial solution does not do any better than the trivial solution."
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Setting the argument about whether this solution would work in an actual interview aside, this is still not optimal since the best case time complexity is $$O(n)$$ compared to the editorial\\'s $$O(\\\\log n)$$ (which was... kind of the whole point of this problem). The only reason that this solution is faster than 92.3% is because Python\\'s `in` keyword calls the magic function `__contains__`, which is most likely implemented in C - and is obviously going to be orders of magnitudes faster than interpreted Python code.  "
                    },
                    {
                        "username": "vivekup3424",
                        "content": "[@jeevanjoyal77](/jeevanjoyal77) Yeah we somtimes tend to overcomplicate things, but this question can be solved optimally using binary search."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "This one is definitely a solution, but here the runtime complexity is O(n), but we have to solve it in O(logn), So try to find the solution using Binary Search."
                    },
                    {
                        "username": "vivek-raj-gupta-2002",
                        "content": "Same for me God !!\\uD83D\\uDE05"
                    },
                    {
                        "username": "jeevanjoyal77",
                        "content": "lol\nI literally forgot about \"Common-Sense\".\nAnd did all types of circuses to solve this."
                    },
                    {
                        "username": "m-Just",
                        "content": "Given a size `n` and two integers `a != b`, we can always construct `n` different arrays of size `n` such that there is a single `a` while the rest are `b`, and clearly they are all valid rotated sorted arrays. In other words, even if `a` exists, it can be at any location; so in the worst case where the input array only contains `b`, an algorithm must access all `n` locations of such array to determine whether `a` exists."
                    },
                    {
                        "username": "exquiro",
                        "content": "Rather than making a new array, why not simply use linear search?"
                    },
                    {
                        "username": "ouromoros",
                        "content": "Consider the following array:\\n[0, 0, 0, 1]\\n\\nAfter rotation, the array could basically be any of the following:\\n1. [1, 0, 0, 0]\\n2. [0, 1, 0, 0]\\n3. [0, 0, 1, 0]\\n4. [0, 0, 0, 1]\\n\\nAnd without checking all of the elements (O(n) opeartion), no algorithm can be sure that it hasn\\'t met one of the above scenarios. \\n\\nEven after checking n-1 elements (which are all 0s), the algorithm cannot determine if the remaining one is the target.\\n\\nSummarized, an array whose elements are all of the same value must take O(n) time to check, no matter what clever trick is used."
                    },
                    {
                        "username": "r_patwari",
                        "content": "[@Mister_CK](/Mister_CK) Not really. Adding elements in the set `new Set(nums)` itself runs at `O(n)`. Thus complexity becomes `O(n)`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only need to know if a certain number is included right? I just made a Set from the array and use Set.has(), so:\n\nvar search = function(nums, target) {\n        let numsSet = new Set(nums);\n        return numsSet.has(target);\n};\n\nIs my whole answer, is that not O(1) complexity?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I agree. I solved this one and it is not a good interview question. The best solution here is to perform a search which decrements right if nums[mid] == nums[left].\\n\\nBasically you perform binary search if you can, and where you can\\'t you just iterate until you either find the pivot/target or can binary search further. It keeps the worst case at O(n)."
                    },
                    {
                        "username": "valree",
                        "content": "I\\'ve just spent half an hour debugging my code only to realize that the stupid test cases are actually looking for a true-false answer not an index where **the question CLEARLY states that we need to return an index...** I kind of suspected this since the outputs were true/false for the test cases but I was sure that someone would have fixed it by now given that this question is at least **6 YEARS OLD!!**\\n\\nI\\'ve been thinking about getting a premium but why would I do that if these people don\\'t care enough to fix a sentence on the question. There are a lot of questions out there where question makes no sense at all or completely incomprehensible with the language they use until you go to the discussion where people literally sit down and try to decipher what they actually mean on multiple topics."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The worst case is linear time which can not be improved.\neg. nums =\n[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1] \nIf I'm wrong, please correct me! There are many annoying testcases. In fact the linear search is not slow for those annoying testcases.\n"
                    },
                    {
                        "username": "marasigana",
                        "content": "Worst case is definitely O(n) because of the duplicates, like you mentioned. Binary search should work in close to O(log n) in the scenarios where there are not many duplicates."
                    },
                    {
                        "username": "kaxuna",
                        "content": "If someone asks this question on interview. They are probably looking for whether you can find an above statement or not more than whether you can bland bs & iterations "
                    },
                    {
                        "username": "Aadil42",
                        "content": "I\\'m stuck on the same test case. What a bitchy test case!!"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "It says this problem is a follow up for Search in Rotated Sorted Array.\\n\\nSearch in Rotated Sorted Array is a hard level question.\\n\\nIt is kinda un-intuitive for a medium level question to be a follow up for a hard question since I am doing all medium level questions first before I do hard level questions.\\n\\nIf this problem is easier than Search in Rotated Sorted Array, then I think Search in Rotated Sorted Array should be the follow up problem for this, not the other way around."
                    },
                    {
                        "username": "GustawB",
                        "content": "[@TheStormBird](/TheStormBird) the question you are replying to was posted 8 years ago"
                    },
                    {
                        "username": "TheStormBird",
                        "content": "Search in Rotated Sorted Array is not a hard level question, neither should it be."
                    },
                    {
                        "username": "aDDyy",
                        "content": "```\nif(nums[mid] == nums[ll] && nums[mid] == nums[ul])\n{\n       ll++;\n       ul--;\n}\n```\nJust remember this edge case if there r duplicates in the array. This edge case will make your work easier BUT yaa remember that in worst case TC will go O(n) & not O(log n)"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@shrutisharma99](/shrutisharma99) okk firstly for that u have to solve its easier version i.e search in rotated sorted array - i & then come to this problem & try to solve it . Here basically its same like the previous one but only diff is that u  have to take care of duplicates so for that u can use the above edge case that i have provided......u can also look at my code : https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/3888532/binarysearch-clean-c-code-valuable-variable-names/\nFor any queries u can DM me on my LinkedIN"
                    },
                    {
                        "username": "shrutisharma99",
                        "content": "can u tell me how u come up with solution\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "qkhhly",
                        "content": "first of all, the array is sorted so we must be able to use this information somehow. the rotated array can be visualized as below. We need to figure out a way to eliminate part of the array. we start with regular binary search, but we have to distinguish between the mid point being case A or case B (shown in figure). after that we can compare target with mid and eliminate part of the array.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813568.png)\\n\\nbut with duplicates, we will have some difficulty because in the following we cannot distinguish case A and case B. if mid == start, then it could be either case A or case B.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813918.png)\\n\\nin this case, we can just ignore start by doing start = start + 1, because we already know target is not nums[mid] (otherwise we would have returned already).\\n\\n#mahoupao"
                    },
                    {
                        "username": "kAc",
                        "content": "In general this problem cannot be solved faster than O(n) in worst case. \\nConsider a much simpler problem: given an array arr, there are two possible cases:\\n1. All elements are 0;\\n2. One element is 1, all other elements are 0.\\n\\nWe want to know which case we are in. Even for this simpler problem it requires O(n) time to solve since we easily construct an adversary to force the algorithm to query all positions. "
                    }
                ]
            },
            {
                "id": 1568087,
                "content": [
                    {
                        "username": "Polokniko",
                        "content": "Forgive me for I have sinned.\n```\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        return target in nums\n```\n92.3% runtime 96.3% memory"
                    },
                    {
                        "username": "trag",
                        "content": "They won\\'t forgive you at the interview tho be aware of it"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@wafsinc](/wafsinc) Average case runtime of Editorial is still much better than the trivial solution. "
                    },
                    {
                        "username": "GD18",
                        "content": "damn you monster lol"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@0xcaffe1ne](/0xcaffe1ne) The \"Best Case Time Complexity\" is always O(1) if, e.g. the target is the first number in nums. The editorial solution does not do any better than the trivial solution."
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Setting the argument about whether this solution would work in an actual interview aside, this is still not optimal since the best case time complexity is $$O(n)$$ compared to the editorial\\'s $$O(\\\\log n)$$ (which was... kind of the whole point of this problem). The only reason that this solution is faster than 92.3% is because Python\\'s `in` keyword calls the magic function `__contains__`, which is most likely implemented in C - and is obviously going to be orders of magnitudes faster than interpreted Python code.  "
                    },
                    {
                        "username": "vivekup3424",
                        "content": "[@jeevanjoyal77](/jeevanjoyal77) Yeah we somtimes tend to overcomplicate things, but this question can be solved optimally using binary search."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "This one is definitely a solution, but here the runtime complexity is O(n), but we have to solve it in O(logn), So try to find the solution using Binary Search."
                    },
                    {
                        "username": "vivek-raj-gupta-2002",
                        "content": "Same for me God !!\\uD83D\\uDE05"
                    },
                    {
                        "username": "jeevanjoyal77",
                        "content": "lol\nI literally forgot about \"Common-Sense\".\nAnd did all types of circuses to solve this."
                    },
                    {
                        "username": "m-Just",
                        "content": "Given a size `n` and two integers `a != b`, we can always construct `n` different arrays of size `n` such that there is a single `a` while the rest are `b`, and clearly they are all valid rotated sorted arrays. In other words, even if `a` exists, it can be at any location; so in the worst case where the input array only contains `b`, an algorithm must access all `n` locations of such array to determine whether `a` exists."
                    },
                    {
                        "username": "exquiro",
                        "content": "Rather than making a new array, why not simply use linear search?"
                    },
                    {
                        "username": "ouromoros",
                        "content": "Consider the following array:\\n[0, 0, 0, 1]\\n\\nAfter rotation, the array could basically be any of the following:\\n1. [1, 0, 0, 0]\\n2. [0, 1, 0, 0]\\n3. [0, 0, 1, 0]\\n4. [0, 0, 0, 1]\\n\\nAnd without checking all of the elements (O(n) opeartion), no algorithm can be sure that it hasn\\'t met one of the above scenarios. \\n\\nEven after checking n-1 elements (which are all 0s), the algorithm cannot determine if the remaining one is the target.\\n\\nSummarized, an array whose elements are all of the same value must take O(n) time to check, no matter what clever trick is used."
                    },
                    {
                        "username": "r_patwari",
                        "content": "[@Mister_CK](/Mister_CK) Not really. Adding elements in the set `new Set(nums)` itself runs at `O(n)`. Thus complexity becomes `O(n)`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only need to know if a certain number is included right? I just made a Set from the array and use Set.has(), so:\n\nvar search = function(nums, target) {\n        let numsSet = new Set(nums);\n        return numsSet.has(target);\n};\n\nIs my whole answer, is that not O(1) complexity?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I agree. I solved this one and it is not a good interview question. The best solution here is to perform a search which decrements right if nums[mid] == nums[left].\\n\\nBasically you perform binary search if you can, and where you can\\'t you just iterate until you either find the pivot/target or can binary search further. It keeps the worst case at O(n)."
                    },
                    {
                        "username": "valree",
                        "content": "I\\'ve just spent half an hour debugging my code only to realize that the stupid test cases are actually looking for a true-false answer not an index where **the question CLEARLY states that we need to return an index...** I kind of suspected this since the outputs were true/false for the test cases but I was sure that someone would have fixed it by now given that this question is at least **6 YEARS OLD!!**\\n\\nI\\'ve been thinking about getting a premium but why would I do that if these people don\\'t care enough to fix a sentence on the question. There are a lot of questions out there where question makes no sense at all or completely incomprehensible with the language they use until you go to the discussion where people literally sit down and try to decipher what they actually mean on multiple topics."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The worst case is linear time which can not be improved.\neg. nums =\n[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1] \nIf I'm wrong, please correct me! There are many annoying testcases. In fact the linear search is not slow for those annoying testcases.\n"
                    },
                    {
                        "username": "marasigana",
                        "content": "Worst case is definitely O(n) because of the duplicates, like you mentioned. Binary search should work in close to O(log n) in the scenarios where there are not many duplicates."
                    },
                    {
                        "username": "kaxuna",
                        "content": "If someone asks this question on interview. They are probably looking for whether you can find an above statement or not more than whether you can bland bs & iterations "
                    },
                    {
                        "username": "Aadil42",
                        "content": "I\\'m stuck on the same test case. What a bitchy test case!!"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "It says this problem is a follow up for Search in Rotated Sorted Array.\\n\\nSearch in Rotated Sorted Array is a hard level question.\\n\\nIt is kinda un-intuitive for a medium level question to be a follow up for a hard question since I am doing all medium level questions first before I do hard level questions.\\n\\nIf this problem is easier than Search in Rotated Sorted Array, then I think Search in Rotated Sorted Array should be the follow up problem for this, not the other way around."
                    },
                    {
                        "username": "GustawB",
                        "content": "[@TheStormBird](/TheStormBird) the question you are replying to was posted 8 years ago"
                    },
                    {
                        "username": "TheStormBird",
                        "content": "Search in Rotated Sorted Array is not a hard level question, neither should it be."
                    },
                    {
                        "username": "aDDyy",
                        "content": "```\nif(nums[mid] == nums[ll] && nums[mid] == nums[ul])\n{\n       ll++;\n       ul--;\n}\n```\nJust remember this edge case if there r duplicates in the array. This edge case will make your work easier BUT yaa remember that in worst case TC will go O(n) & not O(log n)"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@shrutisharma99](/shrutisharma99) okk firstly for that u have to solve its easier version i.e search in rotated sorted array - i & then come to this problem & try to solve it . Here basically its same like the previous one but only diff is that u  have to take care of duplicates so for that u can use the above edge case that i have provided......u can also look at my code : https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/3888532/binarysearch-clean-c-code-valuable-variable-names/\nFor any queries u can DM me on my LinkedIN"
                    },
                    {
                        "username": "shrutisharma99",
                        "content": "can u tell me how u come up with solution\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "qkhhly",
                        "content": "first of all, the array is sorted so we must be able to use this information somehow. the rotated array can be visualized as below. We need to figure out a way to eliminate part of the array. we start with regular binary search, but we have to distinguish between the mid point being case A or case B (shown in figure). after that we can compare target with mid and eliminate part of the array.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813568.png)\\n\\nbut with duplicates, we will have some difficulty because in the following we cannot distinguish case A and case B. if mid == start, then it could be either case A or case B.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813918.png)\\n\\nin this case, we can just ignore start by doing start = start + 1, because we already know target is not nums[mid] (otherwise we would have returned already).\\n\\n#mahoupao"
                    },
                    {
                        "username": "kAc",
                        "content": "In general this problem cannot be solved faster than O(n) in worst case. \\nConsider a much simpler problem: given an array arr, there are two possible cases:\\n1. All elements are 0;\\n2. One element is 1, all other elements are 0.\\n\\nWe want to know which case we are in. Even for this simpler problem it requires O(n) time to solve since we easily construct an adversary to force the algorithm to query all positions. "
                    }
                ]
            },
            {
                "id": 1567017,
                "content": [
                    {
                        "username": "Polokniko",
                        "content": "Forgive me for I have sinned.\n```\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        return target in nums\n```\n92.3% runtime 96.3% memory"
                    },
                    {
                        "username": "trag",
                        "content": "They won\\'t forgive you at the interview tho be aware of it"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@wafsinc](/wafsinc) Average case runtime of Editorial is still much better than the trivial solution. "
                    },
                    {
                        "username": "GD18",
                        "content": "damn you monster lol"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@0xcaffe1ne](/0xcaffe1ne) The \"Best Case Time Complexity\" is always O(1) if, e.g. the target is the first number in nums. The editorial solution does not do any better than the trivial solution."
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Setting the argument about whether this solution would work in an actual interview aside, this is still not optimal since the best case time complexity is $$O(n)$$ compared to the editorial\\'s $$O(\\\\log n)$$ (which was... kind of the whole point of this problem). The only reason that this solution is faster than 92.3% is because Python\\'s `in` keyword calls the magic function `__contains__`, which is most likely implemented in C - and is obviously going to be orders of magnitudes faster than interpreted Python code.  "
                    },
                    {
                        "username": "vivekup3424",
                        "content": "[@jeevanjoyal77](/jeevanjoyal77) Yeah we somtimes tend to overcomplicate things, but this question can be solved optimally using binary search."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "This one is definitely a solution, but here the runtime complexity is O(n), but we have to solve it in O(logn), So try to find the solution using Binary Search."
                    },
                    {
                        "username": "vivek-raj-gupta-2002",
                        "content": "Same for me God !!\\uD83D\\uDE05"
                    },
                    {
                        "username": "jeevanjoyal77",
                        "content": "lol\nI literally forgot about \"Common-Sense\".\nAnd did all types of circuses to solve this."
                    },
                    {
                        "username": "m-Just",
                        "content": "Given a size `n` and two integers `a != b`, we can always construct `n` different arrays of size `n` such that there is a single `a` while the rest are `b`, and clearly they are all valid rotated sorted arrays. In other words, even if `a` exists, it can be at any location; so in the worst case where the input array only contains `b`, an algorithm must access all `n` locations of such array to determine whether `a` exists."
                    },
                    {
                        "username": "exquiro",
                        "content": "Rather than making a new array, why not simply use linear search?"
                    },
                    {
                        "username": "ouromoros",
                        "content": "Consider the following array:\\n[0, 0, 0, 1]\\n\\nAfter rotation, the array could basically be any of the following:\\n1. [1, 0, 0, 0]\\n2. [0, 1, 0, 0]\\n3. [0, 0, 1, 0]\\n4. [0, 0, 0, 1]\\n\\nAnd without checking all of the elements (O(n) opeartion), no algorithm can be sure that it hasn\\'t met one of the above scenarios. \\n\\nEven after checking n-1 elements (which are all 0s), the algorithm cannot determine if the remaining one is the target.\\n\\nSummarized, an array whose elements are all of the same value must take O(n) time to check, no matter what clever trick is used."
                    },
                    {
                        "username": "r_patwari",
                        "content": "[@Mister_CK](/Mister_CK) Not really. Adding elements in the set `new Set(nums)` itself runs at `O(n)`. Thus complexity becomes `O(n)`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only need to know if a certain number is included right? I just made a Set from the array and use Set.has(), so:\n\nvar search = function(nums, target) {\n        let numsSet = new Set(nums);\n        return numsSet.has(target);\n};\n\nIs my whole answer, is that not O(1) complexity?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I agree. I solved this one and it is not a good interview question. The best solution here is to perform a search which decrements right if nums[mid] == nums[left].\\n\\nBasically you perform binary search if you can, and where you can\\'t you just iterate until you either find the pivot/target or can binary search further. It keeps the worst case at O(n)."
                    },
                    {
                        "username": "valree",
                        "content": "I\\'ve just spent half an hour debugging my code only to realize that the stupid test cases are actually looking for a true-false answer not an index where **the question CLEARLY states that we need to return an index...** I kind of suspected this since the outputs were true/false for the test cases but I was sure that someone would have fixed it by now given that this question is at least **6 YEARS OLD!!**\\n\\nI\\'ve been thinking about getting a premium but why would I do that if these people don\\'t care enough to fix a sentence on the question. There are a lot of questions out there where question makes no sense at all or completely incomprehensible with the language they use until you go to the discussion where people literally sit down and try to decipher what they actually mean on multiple topics."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The worst case is linear time which can not be improved.\neg. nums =\n[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1] \nIf I'm wrong, please correct me! There are many annoying testcases. In fact the linear search is not slow for those annoying testcases.\n"
                    },
                    {
                        "username": "marasigana",
                        "content": "Worst case is definitely O(n) because of the duplicates, like you mentioned. Binary search should work in close to O(log n) in the scenarios where there are not many duplicates."
                    },
                    {
                        "username": "kaxuna",
                        "content": "If someone asks this question on interview. They are probably looking for whether you can find an above statement or not more than whether you can bland bs & iterations "
                    },
                    {
                        "username": "Aadil42",
                        "content": "I\\'m stuck on the same test case. What a bitchy test case!!"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "It says this problem is a follow up for Search in Rotated Sorted Array.\\n\\nSearch in Rotated Sorted Array is a hard level question.\\n\\nIt is kinda un-intuitive for a medium level question to be a follow up for a hard question since I am doing all medium level questions first before I do hard level questions.\\n\\nIf this problem is easier than Search in Rotated Sorted Array, then I think Search in Rotated Sorted Array should be the follow up problem for this, not the other way around."
                    },
                    {
                        "username": "GustawB",
                        "content": "[@TheStormBird](/TheStormBird) the question you are replying to was posted 8 years ago"
                    },
                    {
                        "username": "TheStormBird",
                        "content": "Search in Rotated Sorted Array is not a hard level question, neither should it be."
                    },
                    {
                        "username": "aDDyy",
                        "content": "```\nif(nums[mid] == nums[ll] && nums[mid] == nums[ul])\n{\n       ll++;\n       ul--;\n}\n```\nJust remember this edge case if there r duplicates in the array. This edge case will make your work easier BUT yaa remember that in worst case TC will go O(n) & not O(log n)"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@shrutisharma99](/shrutisharma99) okk firstly for that u have to solve its easier version i.e search in rotated sorted array - i & then come to this problem & try to solve it . Here basically its same like the previous one but only diff is that u  have to take care of duplicates so for that u can use the above edge case that i have provided......u can also look at my code : https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/3888532/binarysearch-clean-c-code-valuable-variable-names/\nFor any queries u can DM me on my LinkedIN"
                    },
                    {
                        "username": "shrutisharma99",
                        "content": "can u tell me how u come up with solution\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "qkhhly",
                        "content": "first of all, the array is sorted so we must be able to use this information somehow. the rotated array can be visualized as below. We need to figure out a way to eliminate part of the array. we start with regular binary search, but we have to distinguish between the mid point being case A or case B (shown in figure). after that we can compare target with mid and eliminate part of the array.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813568.png)\\n\\nbut with duplicates, we will have some difficulty because in the following we cannot distinguish case A and case B. if mid == start, then it could be either case A or case B.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813918.png)\\n\\nin this case, we can just ignore start by doing start = start + 1, because we already know target is not nums[mid] (otherwise we would have returned already).\\n\\n#mahoupao"
                    },
                    {
                        "username": "kAc",
                        "content": "In general this problem cannot be solved faster than O(n) in worst case. \\nConsider a much simpler problem: given an array arr, there are two possible cases:\\n1. All elements are 0;\\n2. One element is 1, all other elements are 0.\\n\\nWe want to know which case we are in. Even for this simpler problem it requires O(n) time to solve since we easily construct an adversary to force the algorithm to query all positions. "
                    }
                ]
            },
            {
                "id": 2007640,
                "content": [
                    {
                        "username": "Polokniko",
                        "content": "Forgive me for I have sinned.\n```\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        return target in nums\n```\n92.3% runtime 96.3% memory"
                    },
                    {
                        "username": "trag",
                        "content": "They won\\'t forgive you at the interview tho be aware of it"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@wafsinc](/wafsinc) Average case runtime of Editorial is still much better than the trivial solution. "
                    },
                    {
                        "username": "GD18",
                        "content": "damn you monster lol"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@0xcaffe1ne](/0xcaffe1ne) The \"Best Case Time Complexity\" is always O(1) if, e.g. the target is the first number in nums. The editorial solution does not do any better than the trivial solution."
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Setting the argument about whether this solution would work in an actual interview aside, this is still not optimal since the best case time complexity is $$O(n)$$ compared to the editorial\\'s $$O(\\\\log n)$$ (which was... kind of the whole point of this problem). The only reason that this solution is faster than 92.3% is because Python\\'s `in` keyword calls the magic function `__contains__`, which is most likely implemented in C - and is obviously going to be orders of magnitudes faster than interpreted Python code.  "
                    },
                    {
                        "username": "vivekup3424",
                        "content": "[@jeevanjoyal77](/jeevanjoyal77) Yeah we somtimes tend to overcomplicate things, but this question can be solved optimally using binary search."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "This one is definitely a solution, but here the runtime complexity is O(n), but we have to solve it in O(logn), So try to find the solution using Binary Search."
                    },
                    {
                        "username": "vivek-raj-gupta-2002",
                        "content": "Same for me God !!\\uD83D\\uDE05"
                    },
                    {
                        "username": "jeevanjoyal77",
                        "content": "lol\nI literally forgot about \"Common-Sense\".\nAnd did all types of circuses to solve this."
                    },
                    {
                        "username": "m-Just",
                        "content": "Given a size `n` and two integers `a != b`, we can always construct `n` different arrays of size `n` such that there is a single `a` while the rest are `b`, and clearly they are all valid rotated sorted arrays. In other words, even if `a` exists, it can be at any location; so in the worst case where the input array only contains `b`, an algorithm must access all `n` locations of such array to determine whether `a` exists."
                    },
                    {
                        "username": "exquiro",
                        "content": "Rather than making a new array, why not simply use linear search?"
                    },
                    {
                        "username": "ouromoros",
                        "content": "Consider the following array:\\n[0, 0, 0, 1]\\n\\nAfter rotation, the array could basically be any of the following:\\n1. [1, 0, 0, 0]\\n2. [0, 1, 0, 0]\\n3. [0, 0, 1, 0]\\n4. [0, 0, 0, 1]\\n\\nAnd without checking all of the elements (O(n) opeartion), no algorithm can be sure that it hasn\\'t met one of the above scenarios. \\n\\nEven after checking n-1 elements (which are all 0s), the algorithm cannot determine if the remaining one is the target.\\n\\nSummarized, an array whose elements are all of the same value must take O(n) time to check, no matter what clever trick is used."
                    },
                    {
                        "username": "r_patwari",
                        "content": "[@Mister_CK](/Mister_CK) Not really. Adding elements in the set `new Set(nums)` itself runs at `O(n)`. Thus complexity becomes `O(n)`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only need to know if a certain number is included right? I just made a Set from the array and use Set.has(), so:\n\nvar search = function(nums, target) {\n        let numsSet = new Set(nums);\n        return numsSet.has(target);\n};\n\nIs my whole answer, is that not O(1) complexity?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I agree. I solved this one and it is not a good interview question. The best solution here is to perform a search which decrements right if nums[mid] == nums[left].\\n\\nBasically you perform binary search if you can, and where you can\\'t you just iterate until you either find the pivot/target or can binary search further. It keeps the worst case at O(n)."
                    },
                    {
                        "username": "valree",
                        "content": "I\\'ve just spent half an hour debugging my code only to realize that the stupid test cases are actually looking for a true-false answer not an index where **the question CLEARLY states that we need to return an index...** I kind of suspected this since the outputs were true/false for the test cases but I was sure that someone would have fixed it by now given that this question is at least **6 YEARS OLD!!**\\n\\nI\\'ve been thinking about getting a premium but why would I do that if these people don\\'t care enough to fix a sentence on the question. There are a lot of questions out there where question makes no sense at all or completely incomprehensible with the language they use until you go to the discussion where people literally sit down and try to decipher what they actually mean on multiple topics."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The worst case is linear time which can not be improved.\neg. nums =\n[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1] \nIf I'm wrong, please correct me! There are many annoying testcases. In fact the linear search is not slow for those annoying testcases.\n"
                    },
                    {
                        "username": "marasigana",
                        "content": "Worst case is definitely O(n) because of the duplicates, like you mentioned. Binary search should work in close to O(log n) in the scenarios where there are not many duplicates."
                    },
                    {
                        "username": "kaxuna",
                        "content": "If someone asks this question on interview. They are probably looking for whether you can find an above statement or not more than whether you can bland bs & iterations "
                    },
                    {
                        "username": "Aadil42",
                        "content": "I\\'m stuck on the same test case. What a bitchy test case!!"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "It says this problem is a follow up for Search in Rotated Sorted Array.\\n\\nSearch in Rotated Sorted Array is a hard level question.\\n\\nIt is kinda un-intuitive for a medium level question to be a follow up for a hard question since I am doing all medium level questions first before I do hard level questions.\\n\\nIf this problem is easier than Search in Rotated Sorted Array, then I think Search in Rotated Sorted Array should be the follow up problem for this, not the other way around."
                    },
                    {
                        "username": "GustawB",
                        "content": "[@TheStormBird](/TheStormBird) the question you are replying to was posted 8 years ago"
                    },
                    {
                        "username": "TheStormBird",
                        "content": "Search in Rotated Sorted Array is not a hard level question, neither should it be."
                    },
                    {
                        "username": "aDDyy",
                        "content": "```\nif(nums[mid] == nums[ll] && nums[mid] == nums[ul])\n{\n       ll++;\n       ul--;\n}\n```\nJust remember this edge case if there r duplicates in the array. This edge case will make your work easier BUT yaa remember that in worst case TC will go O(n) & not O(log n)"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@shrutisharma99](/shrutisharma99) okk firstly for that u have to solve its easier version i.e search in rotated sorted array - i & then come to this problem & try to solve it . Here basically its same like the previous one but only diff is that u  have to take care of duplicates so for that u can use the above edge case that i have provided......u can also look at my code : https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/3888532/binarysearch-clean-c-code-valuable-variable-names/\nFor any queries u can DM me on my LinkedIN"
                    },
                    {
                        "username": "shrutisharma99",
                        "content": "can u tell me how u come up with solution\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "qkhhly",
                        "content": "first of all, the array is sorted so we must be able to use this information somehow. the rotated array can be visualized as below. We need to figure out a way to eliminate part of the array. we start with regular binary search, but we have to distinguish between the mid point being case A or case B (shown in figure). after that we can compare target with mid and eliminate part of the array.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813568.png)\\n\\nbut with duplicates, we will have some difficulty because in the following we cannot distinguish case A and case B. if mid == start, then it could be either case A or case B.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813918.png)\\n\\nin this case, we can just ignore start by doing start = start + 1, because we already know target is not nums[mid] (otherwise we would have returned already).\\n\\n#mahoupao"
                    },
                    {
                        "username": "kAc",
                        "content": "In general this problem cannot be solved faster than O(n) in worst case. \\nConsider a much simpler problem: given an array arr, there are two possible cases:\\n1. All elements are 0;\\n2. One element is 1, all other elements are 0.\\n\\nWe want to know which case we are in. Even for this simpler problem it requires O(n) time to solve since we easily construct an adversary to force the algorithm to query all positions. "
                    }
                ]
            },
            {
                "id": 1565095,
                "content": [
                    {
                        "username": "Polokniko",
                        "content": "Forgive me for I have sinned.\n```\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        return target in nums\n```\n92.3% runtime 96.3% memory"
                    },
                    {
                        "username": "trag",
                        "content": "They won\\'t forgive you at the interview tho be aware of it"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@wafsinc](/wafsinc) Average case runtime of Editorial is still much better than the trivial solution. "
                    },
                    {
                        "username": "GD18",
                        "content": "damn you monster lol"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@0xcaffe1ne](/0xcaffe1ne) The \"Best Case Time Complexity\" is always O(1) if, e.g. the target is the first number in nums. The editorial solution does not do any better than the trivial solution."
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Setting the argument about whether this solution would work in an actual interview aside, this is still not optimal since the best case time complexity is $$O(n)$$ compared to the editorial\\'s $$O(\\\\log n)$$ (which was... kind of the whole point of this problem). The only reason that this solution is faster than 92.3% is because Python\\'s `in` keyword calls the magic function `__contains__`, which is most likely implemented in C - and is obviously going to be orders of magnitudes faster than interpreted Python code.  "
                    },
                    {
                        "username": "vivekup3424",
                        "content": "[@jeevanjoyal77](/jeevanjoyal77) Yeah we somtimes tend to overcomplicate things, but this question can be solved optimally using binary search."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "This one is definitely a solution, but here the runtime complexity is O(n), but we have to solve it in O(logn), So try to find the solution using Binary Search."
                    },
                    {
                        "username": "vivek-raj-gupta-2002",
                        "content": "Same for me God !!\\uD83D\\uDE05"
                    },
                    {
                        "username": "jeevanjoyal77",
                        "content": "lol\nI literally forgot about \"Common-Sense\".\nAnd did all types of circuses to solve this."
                    },
                    {
                        "username": "m-Just",
                        "content": "Given a size `n` and two integers `a != b`, we can always construct `n` different arrays of size `n` such that there is a single `a` while the rest are `b`, and clearly they are all valid rotated sorted arrays. In other words, even if `a` exists, it can be at any location; so in the worst case where the input array only contains `b`, an algorithm must access all `n` locations of such array to determine whether `a` exists."
                    },
                    {
                        "username": "exquiro",
                        "content": "Rather than making a new array, why not simply use linear search?"
                    },
                    {
                        "username": "ouromoros",
                        "content": "Consider the following array:\\n[0, 0, 0, 1]\\n\\nAfter rotation, the array could basically be any of the following:\\n1. [1, 0, 0, 0]\\n2. [0, 1, 0, 0]\\n3. [0, 0, 1, 0]\\n4. [0, 0, 0, 1]\\n\\nAnd without checking all of the elements (O(n) opeartion), no algorithm can be sure that it hasn\\'t met one of the above scenarios. \\n\\nEven after checking n-1 elements (which are all 0s), the algorithm cannot determine if the remaining one is the target.\\n\\nSummarized, an array whose elements are all of the same value must take O(n) time to check, no matter what clever trick is used."
                    },
                    {
                        "username": "r_patwari",
                        "content": "[@Mister_CK](/Mister_CK) Not really. Adding elements in the set `new Set(nums)` itself runs at `O(n)`. Thus complexity becomes `O(n)`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only need to know if a certain number is included right? I just made a Set from the array and use Set.has(), so:\n\nvar search = function(nums, target) {\n        let numsSet = new Set(nums);\n        return numsSet.has(target);\n};\n\nIs my whole answer, is that not O(1) complexity?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I agree. I solved this one and it is not a good interview question. The best solution here is to perform a search which decrements right if nums[mid] == nums[left].\\n\\nBasically you perform binary search if you can, and where you can\\'t you just iterate until you either find the pivot/target or can binary search further. It keeps the worst case at O(n)."
                    },
                    {
                        "username": "valree",
                        "content": "I\\'ve just spent half an hour debugging my code only to realize that the stupid test cases are actually looking for a true-false answer not an index where **the question CLEARLY states that we need to return an index...** I kind of suspected this since the outputs were true/false for the test cases but I was sure that someone would have fixed it by now given that this question is at least **6 YEARS OLD!!**\\n\\nI\\'ve been thinking about getting a premium but why would I do that if these people don\\'t care enough to fix a sentence on the question. There are a lot of questions out there where question makes no sense at all or completely incomprehensible with the language they use until you go to the discussion where people literally sit down and try to decipher what they actually mean on multiple topics."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The worst case is linear time which can not be improved.\neg. nums =\n[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1] \nIf I'm wrong, please correct me! There are many annoying testcases. In fact the linear search is not slow for those annoying testcases.\n"
                    },
                    {
                        "username": "marasigana",
                        "content": "Worst case is definitely O(n) because of the duplicates, like you mentioned. Binary search should work in close to O(log n) in the scenarios where there are not many duplicates."
                    },
                    {
                        "username": "kaxuna",
                        "content": "If someone asks this question on interview. They are probably looking for whether you can find an above statement or not more than whether you can bland bs & iterations "
                    },
                    {
                        "username": "Aadil42",
                        "content": "I\\'m stuck on the same test case. What a bitchy test case!!"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "It says this problem is a follow up for Search in Rotated Sorted Array.\\n\\nSearch in Rotated Sorted Array is a hard level question.\\n\\nIt is kinda un-intuitive for a medium level question to be a follow up for a hard question since I am doing all medium level questions first before I do hard level questions.\\n\\nIf this problem is easier than Search in Rotated Sorted Array, then I think Search in Rotated Sorted Array should be the follow up problem for this, not the other way around."
                    },
                    {
                        "username": "GustawB",
                        "content": "[@TheStormBird](/TheStormBird) the question you are replying to was posted 8 years ago"
                    },
                    {
                        "username": "TheStormBird",
                        "content": "Search in Rotated Sorted Array is not a hard level question, neither should it be."
                    },
                    {
                        "username": "aDDyy",
                        "content": "```\nif(nums[mid] == nums[ll] && nums[mid] == nums[ul])\n{\n       ll++;\n       ul--;\n}\n```\nJust remember this edge case if there r duplicates in the array. This edge case will make your work easier BUT yaa remember that in worst case TC will go O(n) & not O(log n)"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@shrutisharma99](/shrutisharma99) okk firstly for that u have to solve its easier version i.e search in rotated sorted array - i & then come to this problem & try to solve it . Here basically its same like the previous one but only diff is that u  have to take care of duplicates so for that u can use the above edge case that i have provided......u can also look at my code : https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/3888532/binarysearch-clean-c-code-valuable-variable-names/\nFor any queries u can DM me on my LinkedIN"
                    },
                    {
                        "username": "shrutisharma99",
                        "content": "can u tell me how u come up with solution\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "qkhhly",
                        "content": "first of all, the array is sorted so we must be able to use this information somehow. the rotated array can be visualized as below. We need to figure out a way to eliminate part of the array. we start with regular binary search, but we have to distinguish between the mid point being case A or case B (shown in figure). after that we can compare target with mid and eliminate part of the array.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813568.png)\\n\\nbut with duplicates, we will have some difficulty because in the following we cannot distinguish case A and case B. if mid == start, then it could be either case A or case B.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813918.png)\\n\\nin this case, we can just ignore start by doing start = start + 1, because we already know target is not nums[mid] (otherwise we would have returned already).\\n\\n#mahoupao"
                    },
                    {
                        "username": "kAc",
                        "content": "In general this problem cannot be solved faster than O(n) in worst case. \\nConsider a much simpler problem: given an array arr, there are two possible cases:\\n1. All elements are 0;\\n2. One element is 1, all other elements are 0.\\n\\nWe want to know which case we are in. Even for this simpler problem it requires O(n) time to solve since we easily construct an adversary to force the algorithm to query all positions. "
                    }
                ]
            },
            {
                "id": 2007681,
                "content": [
                    {
                        "username": "Polokniko",
                        "content": "Forgive me for I have sinned.\n```\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        return target in nums\n```\n92.3% runtime 96.3% memory"
                    },
                    {
                        "username": "trag",
                        "content": "They won\\'t forgive you at the interview tho be aware of it"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@wafsinc](/wafsinc) Average case runtime of Editorial is still much better than the trivial solution. "
                    },
                    {
                        "username": "GD18",
                        "content": "damn you monster lol"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@0xcaffe1ne](/0xcaffe1ne) The \"Best Case Time Complexity\" is always O(1) if, e.g. the target is the first number in nums. The editorial solution does not do any better than the trivial solution."
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Setting the argument about whether this solution would work in an actual interview aside, this is still not optimal since the best case time complexity is $$O(n)$$ compared to the editorial\\'s $$O(\\\\log n)$$ (which was... kind of the whole point of this problem). The only reason that this solution is faster than 92.3% is because Python\\'s `in` keyword calls the magic function `__contains__`, which is most likely implemented in C - and is obviously going to be orders of magnitudes faster than interpreted Python code.  "
                    },
                    {
                        "username": "vivekup3424",
                        "content": "[@jeevanjoyal77](/jeevanjoyal77) Yeah we somtimes tend to overcomplicate things, but this question can be solved optimally using binary search."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "This one is definitely a solution, but here the runtime complexity is O(n), but we have to solve it in O(logn), So try to find the solution using Binary Search."
                    },
                    {
                        "username": "vivek-raj-gupta-2002",
                        "content": "Same for me God !!\\uD83D\\uDE05"
                    },
                    {
                        "username": "jeevanjoyal77",
                        "content": "lol\nI literally forgot about \"Common-Sense\".\nAnd did all types of circuses to solve this."
                    },
                    {
                        "username": "m-Just",
                        "content": "Given a size `n` and two integers `a != b`, we can always construct `n` different arrays of size `n` such that there is a single `a` while the rest are `b`, and clearly they are all valid rotated sorted arrays. In other words, even if `a` exists, it can be at any location; so in the worst case where the input array only contains `b`, an algorithm must access all `n` locations of such array to determine whether `a` exists."
                    },
                    {
                        "username": "exquiro",
                        "content": "Rather than making a new array, why not simply use linear search?"
                    },
                    {
                        "username": "ouromoros",
                        "content": "Consider the following array:\\n[0, 0, 0, 1]\\n\\nAfter rotation, the array could basically be any of the following:\\n1. [1, 0, 0, 0]\\n2. [0, 1, 0, 0]\\n3. [0, 0, 1, 0]\\n4. [0, 0, 0, 1]\\n\\nAnd without checking all of the elements (O(n) opeartion), no algorithm can be sure that it hasn\\'t met one of the above scenarios. \\n\\nEven after checking n-1 elements (which are all 0s), the algorithm cannot determine if the remaining one is the target.\\n\\nSummarized, an array whose elements are all of the same value must take O(n) time to check, no matter what clever trick is used."
                    },
                    {
                        "username": "r_patwari",
                        "content": "[@Mister_CK](/Mister_CK) Not really. Adding elements in the set `new Set(nums)` itself runs at `O(n)`. Thus complexity becomes `O(n)`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only need to know if a certain number is included right? I just made a Set from the array and use Set.has(), so:\n\nvar search = function(nums, target) {\n        let numsSet = new Set(nums);\n        return numsSet.has(target);\n};\n\nIs my whole answer, is that not O(1) complexity?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I agree. I solved this one and it is not a good interview question. The best solution here is to perform a search which decrements right if nums[mid] == nums[left].\\n\\nBasically you perform binary search if you can, and where you can\\'t you just iterate until you either find the pivot/target or can binary search further. It keeps the worst case at O(n)."
                    },
                    {
                        "username": "valree",
                        "content": "I\\'ve just spent half an hour debugging my code only to realize that the stupid test cases are actually looking for a true-false answer not an index where **the question CLEARLY states that we need to return an index...** I kind of suspected this since the outputs were true/false for the test cases but I was sure that someone would have fixed it by now given that this question is at least **6 YEARS OLD!!**\\n\\nI\\'ve been thinking about getting a premium but why would I do that if these people don\\'t care enough to fix a sentence on the question. There are a lot of questions out there where question makes no sense at all or completely incomprehensible with the language they use until you go to the discussion where people literally sit down and try to decipher what they actually mean on multiple topics."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The worst case is linear time which can not be improved.\neg. nums =\n[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1] \nIf I'm wrong, please correct me! There are many annoying testcases. In fact the linear search is not slow for those annoying testcases.\n"
                    },
                    {
                        "username": "marasigana",
                        "content": "Worst case is definitely O(n) because of the duplicates, like you mentioned. Binary search should work in close to O(log n) in the scenarios where there are not many duplicates."
                    },
                    {
                        "username": "kaxuna",
                        "content": "If someone asks this question on interview. They are probably looking for whether you can find an above statement or not more than whether you can bland bs & iterations "
                    },
                    {
                        "username": "Aadil42",
                        "content": "I\\'m stuck on the same test case. What a bitchy test case!!"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "It says this problem is a follow up for Search in Rotated Sorted Array.\\n\\nSearch in Rotated Sorted Array is a hard level question.\\n\\nIt is kinda un-intuitive for a medium level question to be a follow up for a hard question since I am doing all medium level questions first before I do hard level questions.\\n\\nIf this problem is easier than Search in Rotated Sorted Array, then I think Search in Rotated Sorted Array should be the follow up problem for this, not the other way around."
                    },
                    {
                        "username": "GustawB",
                        "content": "[@TheStormBird](/TheStormBird) the question you are replying to was posted 8 years ago"
                    },
                    {
                        "username": "TheStormBird",
                        "content": "Search in Rotated Sorted Array is not a hard level question, neither should it be."
                    },
                    {
                        "username": "aDDyy",
                        "content": "```\nif(nums[mid] == nums[ll] && nums[mid] == nums[ul])\n{\n       ll++;\n       ul--;\n}\n```\nJust remember this edge case if there r duplicates in the array. This edge case will make your work easier BUT yaa remember that in worst case TC will go O(n) & not O(log n)"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@shrutisharma99](/shrutisharma99) okk firstly for that u have to solve its easier version i.e search in rotated sorted array - i & then come to this problem & try to solve it . Here basically its same like the previous one but only diff is that u  have to take care of duplicates so for that u can use the above edge case that i have provided......u can also look at my code : https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/3888532/binarysearch-clean-c-code-valuable-variable-names/\nFor any queries u can DM me on my LinkedIN"
                    },
                    {
                        "username": "shrutisharma99",
                        "content": "can u tell me how u come up with solution\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "qkhhly",
                        "content": "first of all, the array is sorted so we must be able to use this information somehow. the rotated array can be visualized as below. We need to figure out a way to eliminate part of the array. we start with regular binary search, but we have to distinguish between the mid point being case A or case B (shown in figure). after that we can compare target with mid and eliminate part of the array.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813568.png)\\n\\nbut with duplicates, we will have some difficulty because in the following we cannot distinguish case A and case B. if mid == start, then it could be either case A or case B.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813918.png)\\n\\nin this case, we can just ignore start by doing start = start + 1, because we already know target is not nums[mid] (otherwise we would have returned already).\\n\\n#mahoupao"
                    },
                    {
                        "username": "kAc",
                        "content": "In general this problem cannot be solved faster than O(n) in worst case. \\nConsider a much simpler problem: given an array arr, there are two possible cases:\\n1. All elements are 0;\\n2. One element is 1, all other elements are 0.\\n\\nWe want to know which case we are in. Even for this simpler problem it requires O(n) time to solve since we easily construct an adversary to force the algorithm to query all positions. "
                    }
                ]
            },
            {
                "id": 1567113,
                "content": [
                    {
                        "username": "Polokniko",
                        "content": "Forgive me for I have sinned.\n```\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        return target in nums\n```\n92.3% runtime 96.3% memory"
                    },
                    {
                        "username": "trag",
                        "content": "They won\\'t forgive you at the interview tho be aware of it"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@wafsinc](/wafsinc) Average case runtime of Editorial is still much better than the trivial solution. "
                    },
                    {
                        "username": "GD18",
                        "content": "damn you monster lol"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@0xcaffe1ne](/0xcaffe1ne) The \"Best Case Time Complexity\" is always O(1) if, e.g. the target is the first number in nums. The editorial solution does not do any better than the trivial solution."
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Setting the argument about whether this solution would work in an actual interview aside, this is still not optimal since the best case time complexity is $$O(n)$$ compared to the editorial\\'s $$O(\\\\log n)$$ (which was... kind of the whole point of this problem). The only reason that this solution is faster than 92.3% is because Python\\'s `in` keyword calls the magic function `__contains__`, which is most likely implemented in C - and is obviously going to be orders of magnitudes faster than interpreted Python code.  "
                    },
                    {
                        "username": "vivekup3424",
                        "content": "[@jeevanjoyal77](/jeevanjoyal77) Yeah we somtimes tend to overcomplicate things, but this question can be solved optimally using binary search."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "This one is definitely a solution, but here the runtime complexity is O(n), but we have to solve it in O(logn), So try to find the solution using Binary Search."
                    },
                    {
                        "username": "vivek-raj-gupta-2002",
                        "content": "Same for me God !!\\uD83D\\uDE05"
                    },
                    {
                        "username": "jeevanjoyal77",
                        "content": "lol\nI literally forgot about \"Common-Sense\".\nAnd did all types of circuses to solve this."
                    },
                    {
                        "username": "m-Just",
                        "content": "Given a size `n` and two integers `a != b`, we can always construct `n` different arrays of size `n` such that there is a single `a` while the rest are `b`, and clearly they are all valid rotated sorted arrays. In other words, even if `a` exists, it can be at any location; so in the worst case where the input array only contains `b`, an algorithm must access all `n` locations of such array to determine whether `a` exists."
                    },
                    {
                        "username": "exquiro",
                        "content": "Rather than making a new array, why not simply use linear search?"
                    },
                    {
                        "username": "ouromoros",
                        "content": "Consider the following array:\\n[0, 0, 0, 1]\\n\\nAfter rotation, the array could basically be any of the following:\\n1. [1, 0, 0, 0]\\n2. [0, 1, 0, 0]\\n3. [0, 0, 1, 0]\\n4. [0, 0, 0, 1]\\n\\nAnd without checking all of the elements (O(n) opeartion), no algorithm can be sure that it hasn\\'t met one of the above scenarios. \\n\\nEven after checking n-1 elements (which are all 0s), the algorithm cannot determine if the remaining one is the target.\\n\\nSummarized, an array whose elements are all of the same value must take O(n) time to check, no matter what clever trick is used."
                    },
                    {
                        "username": "r_patwari",
                        "content": "[@Mister_CK](/Mister_CK) Not really. Adding elements in the set `new Set(nums)` itself runs at `O(n)`. Thus complexity becomes `O(n)`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only need to know if a certain number is included right? I just made a Set from the array and use Set.has(), so:\n\nvar search = function(nums, target) {\n        let numsSet = new Set(nums);\n        return numsSet.has(target);\n};\n\nIs my whole answer, is that not O(1) complexity?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I agree. I solved this one and it is not a good interview question. The best solution here is to perform a search which decrements right if nums[mid] == nums[left].\\n\\nBasically you perform binary search if you can, and where you can\\'t you just iterate until you either find the pivot/target or can binary search further. It keeps the worst case at O(n)."
                    },
                    {
                        "username": "valree",
                        "content": "I\\'ve just spent half an hour debugging my code only to realize that the stupid test cases are actually looking for a true-false answer not an index where **the question CLEARLY states that we need to return an index...** I kind of suspected this since the outputs were true/false for the test cases but I was sure that someone would have fixed it by now given that this question is at least **6 YEARS OLD!!**\\n\\nI\\'ve been thinking about getting a premium but why would I do that if these people don\\'t care enough to fix a sentence on the question. There are a lot of questions out there where question makes no sense at all or completely incomprehensible with the language they use until you go to the discussion where people literally sit down and try to decipher what they actually mean on multiple topics."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The worst case is linear time which can not be improved.\neg. nums =\n[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1] \nIf I'm wrong, please correct me! There are many annoying testcases. In fact the linear search is not slow for those annoying testcases.\n"
                    },
                    {
                        "username": "marasigana",
                        "content": "Worst case is definitely O(n) because of the duplicates, like you mentioned. Binary search should work in close to O(log n) in the scenarios where there are not many duplicates."
                    },
                    {
                        "username": "kaxuna",
                        "content": "If someone asks this question on interview. They are probably looking for whether you can find an above statement or not more than whether you can bland bs & iterations "
                    },
                    {
                        "username": "Aadil42",
                        "content": "I\\'m stuck on the same test case. What a bitchy test case!!"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "It says this problem is a follow up for Search in Rotated Sorted Array.\\n\\nSearch in Rotated Sorted Array is a hard level question.\\n\\nIt is kinda un-intuitive for a medium level question to be a follow up for a hard question since I am doing all medium level questions first before I do hard level questions.\\n\\nIf this problem is easier than Search in Rotated Sorted Array, then I think Search in Rotated Sorted Array should be the follow up problem for this, not the other way around."
                    },
                    {
                        "username": "GustawB",
                        "content": "[@TheStormBird](/TheStormBird) the question you are replying to was posted 8 years ago"
                    },
                    {
                        "username": "TheStormBird",
                        "content": "Search in Rotated Sorted Array is not a hard level question, neither should it be."
                    },
                    {
                        "username": "aDDyy",
                        "content": "```\nif(nums[mid] == nums[ll] && nums[mid] == nums[ul])\n{\n       ll++;\n       ul--;\n}\n```\nJust remember this edge case if there r duplicates in the array. This edge case will make your work easier BUT yaa remember that in worst case TC will go O(n) & not O(log n)"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@shrutisharma99](/shrutisharma99) okk firstly for that u have to solve its easier version i.e search in rotated sorted array - i & then come to this problem & try to solve it . Here basically its same like the previous one but only diff is that u  have to take care of duplicates so for that u can use the above edge case that i have provided......u can also look at my code : https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/3888532/binarysearch-clean-c-code-valuable-variable-names/\nFor any queries u can DM me on my LinkedIN"
                    },
                    {
                        "username": "shrutisharma99",
                        "content": "can u tell me how u come up with solution\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "qkhhly",
                        "content": "first of all, the array is sorted so we must be able to use this information somehow. the rotated array can be visualized as below. We need to figure out a way to eliminate part of the array. we start with regular binary search, but we have to distinguish between the mid point being case A or case B (shown in figure). after that we can compare target with mid and eliminate part of the array.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813568.png)\\n\\nbut with duplicates, we will have some difficulty because in the following we cannot distinguish case A and case B. if mid == start, then it could be either case A or case B.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813918.png)\\n\\nin this case, we can just ignore start by doing start = start + 1, because we already know target is not nums[mid] (otherwise we would have returned already).\\n\\n#mahoupao"
                    },
                    {
                        "username": "kAc",
                        "content": "In general this problem cannot be solved faster than O(n) in worst case. \\nConsider a much simpler problem: given an array arr, there are two possible cases:\\n1. All elements are 0;\\n2. One element is 1, all other elements are 0.\\n\\nWe want to know which case we are in. Even for this simpler problem it requires O(n) time to solve since we easily construct an adversary to force the algorithm to query all positions. "
                    }
                ]
            },
            {
                "id": 1573439,
                "content": [
                    {
                        "username": "Polokniko",
                        "content": "Forgive me for I have sinned.\n```\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        return target in nums\n```\n92.3% runtime 96.3% memory"
                    },
                    {
                        "username": "trag",
                        "content": "They won\\'t forgive you at the interview tho be aware of it"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@wafsinc](/wafsinc) Average case runtime of Editorial is still much better than the trivial solution. "
                    },
                    {
                        "username": "GD18",
                        "content": "damn you monster lol"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@0xcaffe1ne](/0xcaffe1ne) The \"Best Case Time Complexity\" is always O(1) if, e.g. the target is the first number in nums. The editorial solution does not do any better than the trivial solution."
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Setting the argument about whether this solution would work in an actual interview aside, this is still not optimal since the best case time complexity is $$O(n)$$ compared to the editorial\\'s $$O(\\\\log n)$$ (which was... kind of the whole point of this problem). The only reason that this solution is faster than 92.3% is because Python\\'s `in` keyword calls the magic function `__contains__`, which is most likely implemented in C - and is obviously going to be orders of magnitudes faster than interpreted Python code.  "
                    },
                    {
                        "username": "vivekup3424",
                        "content": "[@jeevanjoyal77](/jeevanjoyal77) Yeah we somtimes tend to overcomplicate things, but this question can be solved optimally using binary search."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "This one is definitely a solution, but here the runtime complexity is O(n), but we have to solve it in O(logn), So try to find the solution using Binary Search."
                    },
                    {
                        "username": "vivek-raj-gupta-2002",
                        "content": "Same for me God !!\\uD83D\\uDE05"
                    },
                    {
                        "username": "jeevanjoyal77",
                        "content": "lol\nI literally forgot about \"Common-Sense\".\nAnd did all types of circuses to solve this."
                    },
                    {
                        "username": "m-Just",
                        "content": "Given a size `n` and two integers `a != b`, we can always construct `n` different arrays of size `n` such that there is a single `a` while the rest are `b`, and clearly they are all valid rotated sorted arrays. In other words, even if `a` exists, it can be at any location; so in the worst case where the input array only contains `b`, an algorithm must access all `n` locations of such array to determine whether `a` exists."
                    },
                    {
                        "username": "exquiro",
                        "content": "Rather than making a new array, why not simply use linear search?"
                    },
                    {
                        "username": "ouromoros",
                        "content": "Consider the following array:\\n[0, 0, 0, 1]\\n\\nAfter rotation, the array could basically be any of the following:\\n1. [1, 0, 0, 0]\\n2. [0, 1, 0, 0]\\n3. [0, 0, 1, 0]\\n4. [0, 0, 0, 1]\\n\\nAnd without checking all of the elements (O(n) opeartion), no algorithm can be sure that it hasn\\'t met one of the above scenarios. \\n\\nEven after checking n-1 elements (which are all 0s), the algorithm cannot determine if the remaining one is the target.\\n\\nSummarized, an array whose elements are all of the same value must take O(n) time to check, no matter what clever trick is used."
                    },
                    {
                        "username": "r_patwari",
                        "content": "[@Mister_CK](/Mister_CK) Not really. Adding elements in the set `new Set(nums)` itself runs at `O(n)`. Thus complexity becomes `O(n)`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only need to know if a certain number is included right? I just made a Set from the array and use Set.has(), so:\n\nvar search = function(nums, target) {\n        let numsSet = new Set(nums);\n        return numsSet.has(target);\n};\n\nIs my whole answer, is that not O(1) complexity?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I agree. I solved this one and it is not a good interview question. The best solution here is to perform a search which decrements right if nums[mid] == nums[left].\\n\\nBasically you perform binary search if you can, and where you can\\'t you just iterate until you either find the pivot/target or can binary search further. It keeps the worst case at O(n)."
                    },
                    {
                        "username": "valree",
                        "content": "I\\'ve just spent half an hour debugging my code only to realize that the stupid test cases are actually looking for a true-false answer not an index where **the question CLEARLY states that we need to return an index...** I kind of suspected this since the outputs were true/false for the test cases but I was sure that someone would have fixed it by now given that this question is at least **6 YEARS OLD!!**\\n\\nI\\'ve been thinking about getting a premium but why would I do that if these people don\\'t care enough to fix a sentence on the question. There are a lot of questions out there where question makes no sense at all or completely incomprehensible with the language they use until you go to the discussion where people literally sit down and try to decipher what they actually mean on multiple topics."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The worst case is linear time which can not be improved.\neg. nums =\n[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1] \nIf I'm wrong, please correct me! There are many annoying testcases. In fact the linear search is not slow for those annoying testcases.\n"
                    },
                    {
                        "username": "marasigana",
                        "content": "Worst case is definitely O(n) because of the duplicates, like you mentioned. Binary search should work in close to O(log n) in the scenarios where there are not many duplicates."
                    },
                    {
                        "username": "kaxuna",
                        "content": "If someone asks this question on interview. They are probably looking for whether you can find an above statement or not more than whether you can bland bs & iterations "
                    },
                    {
                        "username": "Aadil42",
                        "content": "I\\'m stuck on the same test case. What a bitchy test case!!"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "It says this problem is a follow up for Search in Rotated Sorted Array.\\n\\nSearch in Rotated Sorted Array is a hard level question.\\n\\nIt is kinda un-intuitive for a medium level question to be a follow up for a hard question since I am doing all medium level questions first before I do hard level questions.\\n\\nIf this problem is easier than Search in Rotated Sorted Array, then I think Search in Rotated Sorted Array should be the follow up problem for this, not the other way around."
                    },
                    {
                        "username": "GustawB",
                        "content": "[@TheStormBird](/TheStormBird) the question you are replying to was posted 8 years ago"
                    },
                    {
                        "username": "TheStormBird",
                        "content": "Search in Rotated Sorted Array is not a hard level question, neither should it be."
                    },
                    {
                        "username": "aDDyy",
                        "content": "```\nif(nums[mid] == nums[ll] && nums[mid] == nums[ul])\n{\n       ll++;\n       ul--;\n}\n```\nJust remember this edge case if there r duplicates in the array. This edge case will make your work easier BUT yaa remember that in worst case TC will go O(n) & not O(log n)"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@shrutisharma99](/shrutisharma99) okk firstly for that u have to solve its easier version i.e search in rotated sorted array - i & then come to this problem & try to solve it . Here basically its same like the previous one but only diff is that u  have to take care of duplicates so for that u can use the above edge case that i have provided......u can also look at my code : https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/3888532/binarysearch-clean-c-code-valuable-variable-names/\nFor any queries u can DM me on my LinkedIN"
                    },
                    {
                        "username": "shrutisharma99",
                        "content": "can u tell me how u come up with solution\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "qkhhly",
                        "content": "first of all, the array is sorted so we must be able to use this information somehow. the rotated array can be visualized as below. We need to figure out a way to eliminate part of the array. we start with regular binary search, but we have to distinguish between the mid point being case A or case B (shown in figure). after that we can compare target with mid and eliminate part of the array.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813568.png)\\n\\nbut with duplicates, we will have some difficulty because in the following we cannot distinguish case A and case B. if mid == start, then it could be either case A or case B.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813918.png)\\n\\nin this case, we can just ignore start by doing start = start + 1, because we already know target is not nums[mid] (otherwise we would have returned already).\\n\\n#mahoupao"
                    },
                    {
                        "username": "kAc",
                        "content": "In general this problem cannot be solved faster than O(n) in worst case. \\nConsider a much simpler problem: given an array arr, there are two possible cases:\\n1. All elements are 0;\\n2. One element is 1, all other elements are 0.\\n\\nWe want to know which case we are in. Even for this simpler problem it requires O(n) time to solve since we easily construct an adversary to force the algorithm to query all positions. "
                    }
                ]
            },
            {
                "id": 1572048,
                "content": [
                    {
                        "username": "Polokniko",
                        "content": "Forgive me for I have sinned.\n```\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        return target in nums\n```\n92.3% runtime 96.3% memory"
                    },
                    {
                        "username": "trag",
                        "content": "They won\\'t forgive you at the interview tho be aware of it"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@wafsinc](/wafsinc) Average case runtime of Editorial is still much better than the trivial solution. "
                    },
                    {
                        "username": "GD18",
                        "content": "damn you monster lol"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@0xcaffe1ne](/0xcaffe1ne) The \"Best Case Time Complexity\" is always O(1) if, e.g. the target is the first number in nums. The editorial solution does not do any better than the trivial solution."
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Setting the argument about whether this solution would work in an actual interview aside, this is still not optimal since the best case time complexity is $$O(n)$$ compared to the editorial\\'s $$O(\\\\log n)$$ (which was... kind of the whole point of this problem). The only reason that this solution is faster than 92.3% is because Python\\'s `in` keyword calls the magic function `__contains__`, which is most likely implemented in C - and is obviously going to be orders of magnitudes faster than interpreted Python code.  "
                    },
                    {
                        "username": "vivekup3424",
                        "content": "[@jeevanjoyal77](/jeevanjoyal77) Yeah we somtimes tend to overcomplicate things, but this question can be solved optimally using binary search."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "This one is definitely a solution, but here the runtime complexity is O(n), but we have to solve it in O(logn), So try to find the solution using Binary Search."
                    },
                    {
                        "username": "vivek-raj-gupta-2002",
                        "content": "Same for me God !!\\uD83D\\uDE05"
                    },
                    {
                        "username": "jeevanjoyal77",
                        "content": "lol\nI literally forgot about \"Common-Sense\".\nAnd did all types of circuses to solve this."
                    },
                    {
                        "username": "m-Just",
                        "content": "Given a size `n` and two integers `a != b`, we can always construct `n` different arrays of size `n` such that there is a single `a` while the rest are `b`, and clearly they are all valid rotated sorted arrays. In other words, even if `a` exists, it can be at any location; so in the worst case where the input array only contains `b`, an algorithm must access all `n` locations of such array to determine whether `a` exists."
                    },
                    {
                        "username": "exquiro",
                        "content": "Rather than making a new array, why not simply use linear search?"
                    },
                    {
                        "username": "ouromoros",
                        "content": "Consider the following array:\\n[0, 0, 0, 1]\\n\\nAfter rotation, the array could basically be any of the following:\\n1. [1, 0, 0, 0]\\n2. [0, 1, 0, 0]\\n3. [0, 0, 1, 0]\\n4. [0, 0, 0, 1]\\n\\nAnd without checking all of the elements (O(n) opeartion), no algorithm can be sure that it hasn\\'t met one of the above scenarios. \\n\\nEven after checking n-1 elements (which are all 0s), the algorithm cannot determine if the remaining one is the target.\\n\\nSummarized, an array whose elements are all of the same value must take O(n) time to check, no matter what clever trick is used."
                    },
                    {
                        "username": "r_patwari",
                        "content": "[@Mister_CK](/Mister_CK) Not really. Adding elements in the set `new Set(nums)` itself runs at `O(n)`. Thus complexity becomes `O(n)`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only need to know if a certain number is included right? I just made a Set from the array and use Set.has(), so:\n\nvar search = function(nums, target) {\n        let numsSet = new Set(nums);\n        return numsSet.has(target);\n};\n\nIs my whole answer, is that not O(1) complexity?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I agree. I solved this one and it is not a good interview question. The best solution here is to perform a search which decrements right if nums[mid] == nums[left].\\n\\nBasically you perform binary search if you can, and where you can\\'t you just iterate until you either find the pivot/target or can binary search further. It keeps the worst case at O(n)."
                    },
                    {
                        "username": "valree",
                        "content": "I\\'ve just spent half an hour debugging my code only to realize that the stupid test cases are actually looking for a true-false answer not an index where **the question CLEARLY states that we need to return an index...** I kind of suspected this since the outputs were true/false for the test cases but I was sure that someone would have fixed it by now given that this question is at least **6 YEARS OLD!!**\\n\\nI\\'ve been thinking about getting a premium but why would I do that if these people don\\'t care enough to fix a sentence on the question. There are a lot of questions out there where question makes no sense at all or completely incomprehensible with the language they use until you go to the discussion where people literally sit down and try to decipher what they actually mean on multiple topics."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The worst case is linear time which can not be improved.\neg. nums =\n[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1] \nIf I'm wrong, please correct me! There are many annoying testcases. In fact the linear search is not slow for those annoying testcases.\n"
                    },
                    {
                        "username": "marasigana",
                        "content": "Worst case is definitely O(n) because of the duplicates, like you mentioned. Binary search should work in close to O(log n) in the scenarios where there are not many duplicates."
                    },
                    {
                        "username": "kaxuna",
                        "content": "If someone asks this question on interview. They are probably looking for whether you can find an above statement or not more than whether you can bland bs & iterations "
                    },
                    {
                        "username": "Aadil42",
                        "content": "I\\'m stuck on the same test case. What a bitchy test case!!"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "It says this problem is a follow up for Search in Rotated Sorted Array.\\n\\nSearch in Rotated Sorted Array is a hard level question.\\n\\nIt is kinda un-intuitive for a medium level question to be a follow up for a hard question since I am doing all medium level questions first before I do hard level questions.\\n\\nIf this problem is easier than Search in Rotated Sorted Array, then I think Search in Rotated Sorted Array should be the follow up problem for this, not the other way around."
                    },
                    {
                        "username": "GustawB",
                        "content": "[@TheStormBird](/TheStormBird) the question you are replying to was posted 8 years ago"
                    },
                    {
                        "username": "TheStormBird",
                        "content": "Search in Rotated Sorted Array is not a hard level question, neither should it be."
                    },
                    {
                        "username": "aDDyy",
                        "content": "```\nif(nums[mid] == nums[ll] && nums[mid] == nums[ul])\n{\n       ll++;\n       ul--;\n}\n```\nJust remember this edge case if there r duplicates in the array. This edge case will make your work easier BUT yaa remember that in worst case TC will go O(n) & not O(log n)"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@shrutisharma99](/shrutisharma99) okk firstly for that u have to solve its easier version i.e search in rotated sorted array - i & then come to this problem & try to solve it . Here basically its same like the previous one but only diff is that u  have to take care of duplicates so for that u can use the above edge case that i have provided......u can also look at my code : https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/3888532/binarysearch-clean-c-code-valuable-variable-names/\nFor any queries u can DM me on my LinkedIN"
                    },
                    {
                        "username": "shrutisharma99",
                        "content": "can u tell me how u come up with solution\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "qkhhly",
                        "content": "first of all, the array is sorted so we must be able to use this information somehow. the rotated array can be visualized as below. We need to figure out a way to eliminate part of the array. we start with regular binary search, but we have to distinguish between the mid point being case A or case B (shown in figure). after that we can compare target with mid and eliminate part of the array.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813568.png)\\n\\nbut with duplicates, we will have some difficulty because in the following we cannot distinguish case A and case B. if mid == start, then it could be either case A or case B.\\n\\n![image](https://assets.leetcode.com/users/qkhhly/image_1581813918.png)\\n\\nin this case, we can just ignore start by doing start = start + 1, because we already know target is not nums[mid] (otherwise we would have returned already).\\n\\n#mahoupao"
                    },
                    {
                        "username": "kAc",
                        "content": "In general this problem cannot be solved faster than O(n) in worst case. \\nConsider a much simpler problem: given an array arr, there are two possible cases:\\n1. All elements are 0;\\n2. One element is 1, all other elements are 0.\\n\\nWe want to know which case we are in. Even for this simpler problem it requires O(n) time to solve since we easily construct an adversary to force the algorithm to query all positions. "
                    }
                ]
            },
            {
                "id": 2007991,
                "content": [
                    {
                        "username": "koushikjavvaji2004",
                        "content": "if(nums[mid] == nums[low] && nums[mid] == nums[high]){\\n                low++;\\n                high--;\\n            }\\nThis is the best thing to do if there are duplicates."
                    },
                    {
                        "username": "arsalan_jumani",
                        "content": "Consider the example `[0, 0, ..., 0, 1, 0, 0, ..., 0]`, i.e. there is one `1` and the rest are `0`\\'s. This is a rotated sorted array but finding `1` here is just like find `1` in an unsorted array. Looking at values at `O(1)` indices (which are all `0`) cannot tell you if `1` is on the left or right.\\n\\nOf course, linear search is the simplest (and accepted) solution."
                    },
                    {
                        "username": "Xuanzhen-Zhang",
                        "content": "So how is the run time affected? Isn\\'t it still O(logn)?"
                    },
                    {
                        "username": "yaojintham",
                        "content": "o(n), you cannot use binary search to find the highest point or pivot point with duplicates.\\nIf you remove duplicates, you are already doing linear search, so it\\'s still o(n)."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Leetcode forgive me for this :0\\n\\n\\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            if(nums[i] == target)\\n                return 1;\\n        }\\n        return 0;\\n    "
                    },
                    {
                        "username": "andykimchris",
                        "content": "You are forgiven my boy :0"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "#### Description says :\\n`nums` is rotated at an unknown pivot index `k` (`0 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (0-indexed).\\n\\n#### Constraint says :\\n`nums` is guaranteed to be rotated at some pivot.\\n\\n#### But what about the case where `k = 0` ?? "
                    },
                    {
                        "username": "trip1312",
                        "content": "then it\\'s just a sorted array"
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "For your hint think about these two test case\\narr=[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1] target=2\\narr=[1,0,1,1,1] target=0\\nSolve for this two and you will get the solution."
                    },
                    {
                        "username": "shauryasharma96",
                        "content": "I\\'m stuck at testcase1 [1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]"
                    },
                    {
                        "username": "mishra_shashank",
                        "content": "Please Bhagwaan ji mujhe iss solution ke liye maaf karna\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        for(int i=0 ; i<n ; i++){\\n            if(nums[i]==target)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n\\'\\'\\'"
                    },
                    {
                        "username": "boogahead",
                        "content": "I confess using find"
                    },
                    {
                        "username": "Saumyajeet",
                        "content": "class Solution {\npublic:\nint pivot(vector<int>& arr, int n){\n    \n    int s=0;\n    int e=n-1;\n    \n    int mid=s+(e-s)/2;\n    \n    while(s<e){\n        \n        \n        if(arr[mid]>=arr[0]){\n            \n            \n            s=mid+1;\n            \n        }\n        else{\n            \n            e=mid;\n        }\n        \n        mid=s+(e-s)/2;\n        \n        \n        \n    }\n    \n    \n    return s;\n        \n        \n        \n}\nint binarysearch(vector<int>& arr, int s, int e, int value){\n\t\n\tint start = s;\n\t\n\tint end = e;\n\t\n\tint mid = start + (end-start)/2;\n\n    int l;\n\t\n\twhile(start<=end){\n\t\t\n\t\tif(arr[mid] == value){\n\t\t\t\n\t\t\t\n\t\t\tl=arr[mid];\n\t\t}\n\t\tif(arr[mid] <= value){\n\t\t\t\n\t\t\tstart = mid + 1;\n\t\t}\n\t\telse{\n\t\t\t\n\t\t\tend = mid-1;\n\t\t}\n\t\t\n\t\tmid = start + (end-start)/2;\n\t\t\n\t}\n\t\n\treturn l;\n\t\n}\n\n    bool search(vector<int>& arr, int value) {\n\n        int size=arr.size();\n        int k;\n\n        int p=pivot(arr, size);\n        if((value>=arr[p]) && (value<=arr[size-1])){\n\n            k=binarysearch(arr, p, size-1, value);\n        }\n        else{\n\n            k=binarysearch(arr, 0, p, value);\n        }\n\n        return k==value;\n        \n    }\n};\n\ni first use pivot to find pivot element then use binary search based on the value of target , \nnums =[2,5,6,0,0,1,2]  ,  target =0 while performing dry run it is showing true but it is showing false while executing , can anybody suggest me how to improve my code?"
                    },
                    {
                        "username": "nicolahadwen",
                        "content": "I see a lot of modified binary search, but still worst case O(n).\\nJust want to know if it\\'s even possible to do <O(n)"
                    },
                    {
                        "username": "barstow123",
                        "content": "It is fundamentally not possible. You cannot run a search on [1,1,1,1,1,1]."
                    }
                ]
            },
            {
                "id": 1573640,
                "content": [
                    {
                        "username": "koushikjavvaji2004",
                        "content": "if(nums[mid] == nums[low] && nums[mid] == nums[high]){\\n                low++;\\n                high--;\\n            }\\nThis is the best thing to do if there are duplicates."
                    },
                    {
                        "username": "arsalan_jumani",
                        "content": "Consider the example `[0, 0, ..., 0, 1, 0, 0, ..., 0]`, i.e. there is one `1` and the rest are `0`\\'s. This is a rotated sorted array but finding `1` here is just like find `1` in an unsorted array. Looking at values at `O(1)` indices (which are all `0`) cannot tell you if `1` is on the left or right.\\n\\nOf course, linear search is the simplest (and accepted) solution."
                    },
                    {
                        "username": "Xuanzhen-Zhang",
                        "content": "So how is the run time affected? Isn\\'t it still O(logn)?"
                    },
                    {
                        "username": "yaojintham",
                        "content": "o(n), you cannot use binary search to find the highest point or pivot point with duplicates.\\nIf you remove duplicates, you are already doing linear search, so it\\'s still o(n)."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Leetcode forgive me for this :0\\n\\n\\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            if(nums[i] == target)\\n                return 1;\\n        }\\n        return 0;\\n    "
                    },
                    {
                        "username": "andykimchris",
                        "content": "You are forgiven my boy :0"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "#### Description says :\\n`nums` is rotated at an unknown pivot index `k` (`0 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (0-indexed).\\n\\n#### Constraint says :\\n`nums` is guaranteed to be rotated at some pivot.\\n\\n#### But what about the case where `k = 0` ?? "
                    },
                    {
                        "username": "trip1312",
                        "content": "then it\\'s just a sorted array"
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "For your hint think about these two test case\\narr=[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1] target=2\\narr=[1,0,1,1,1] target=0\\nSolve for this two and you will get the solution."
                    },
                    {
                        "username": "shauryasharma96",
                        "content": "I\\'m stuck at testcase1 [1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]"
                    },
                    {
                        "username": "mishra_shashank",
                        "content": "Please Bhagwaan ji mujhe iss solution ke liye maaf karna\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        for(int i=0 ; i<n ; i++){\\n            if(nums[i]==target)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n\\'\\'\\'"
                    },
                    {
                        "username": "boogahead",
                        "content": "I confess using find"
                    },
                    {
                        "username": "Saumyajeet",
                        "content": "class Solution {\npublic:\nint pivot(vector<int>& arr, int n){\n    \n    int s=0;\n    int e=n-1;\n    \n    int mid=s+(e-s)/2;\n    \n    while(s<e){\n        \n        \n        if(arr[mid]>=arr[0]){\n            \n            \n            s=mid+1;\n            \n        }\n        else{\n            \n            e=mid;\n        }\n        \n        mid=s+(e-s)/2;\n        \n        \n        \n    }\n    \n    \n    return s;\n        \n        \n        \n}\nint binarysearch(vector<int>& arr, int s, int e, int value){\n\t\n\tint start = s;\n\t\n\tint end = e;\n\t\n\tint mid = start + (end-start)/2;\n\n    int l;\n\t\n\twhile(start<=end){\n\t\t\n\t\tif(arr[mid] == value){\n\t\t\t\n\t\t\t\n\t\t\tl=arr[mid];\n\t\t}\n\t\tif(arr[mid] <= value){\n\t\t\t\n\t\t\tstart = mid + 1;\n\t\t}\n\t\telse{\n\t\t\t\n\t\t\tend = mid-1;\n\t\t}\n\t\t\n\t\tmid = start + (end-start)/2;\n\t\t\n\t}\n\t\n\treturn l;\n\t\n}\n\n    bool search(vector<int>& arr, int value) {\n\n        int size=arr.size();\n        int k;\n\n        int p=pivot(arr, size);\n        if((value>=arr[p]) && (value<=arr[size-1])){\n\n            k=binarysearch(arr, p, size-1, value);\n        }\n        else{\n\n            k=binarysearch(arr, 0, p, value);\n        }\n\n        return k==value;\n        \n    }\n};\n\ni first use pivot to find pivot element then use binary search based on the value of target , \nnums =[2,5,6,0,0,1,2]  ,  target =0 while performing dry run it is showing true but it is showing false while executing , can anybody suggest me how to improve my code?"
                    },
                    {
                        "username": "nicolahadwen",
                        "content": "I see a lot of modified binary search, but still worst case O(n).\\nJust want to know if it\\'s even possible to do <O(n)"
                    },
                    {
                        "username": "barstow123",
                        "content": "It is fundamentally not possible. You cannot run a search on [1,1,1,1,1,1]."
                    }
                ]
            },
            {
                "id": 1572217,
                "content": [
                    {
                        "username": "koushikjavvaji2004",
                        "content": "if(nums[mid] == nums[low] && nums[mid] == nums[high]){\\n                low++;\\n                high--;\\n            }\\nThis is the best thing to do if there are duplicates."
                    },
                    {
                        "username": "arsalan_jumani",
                        "content": "Consider the example `[0, 0, ..., 0, 1, 0, 0, ..., 0]`, i.e. there is one `1` and the rest are `0`\\'s. This is a rotated sorted array but finding `1` here is just like find `1` in an unsorted array. Looking at values at `O(1)` indices (which are all `0`) cannot tell you if `1` is on the left or right.\\n\\nOf course, linear search is the simplest (and accepted) solution."
                    },
                    {
                        "username": "Xuanzhen-Zhang",
                        "content": "So how is the run time affected? Isn\\'t it still O(logn)?"
                    },
                    {
                        "username": "yaojintham",
                        "content": "o(n), you cannot use binary search to find the highest point or pivot point with duplicates.\\nIf you remove duplicates, you are already doing linear search, so it\\'s still o(n)."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Leetcode forgive me for this :0\\n\\n\\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            if(nums[i] == target)\\n                return 1;\\n        }\\n        return 0;\\n    "
                    },
                    {
                        "username": "andykimchris",
                        "content": "You are forgiven my boy :0"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "#### Description says :\\n`nums` is rotated at an unknown pivot index `k` (`0 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (0-indexed).\\n\\n#### Constraint says :\\n`nums` is guaranteed to be rotated at some pivot.\\n\\n#### But what about the case where `k = 0` ?? "
                    },
                    {
                        "username": "trip1312",
                        "content": "then it\\'s just a sorted array"
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "For your hint think about these two test case\\narr=[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1] target=2\\narr=[1,0,1,1,1] target=0\\nSolve for this two and you will get the solution."
                    },
                    {
                        "username": "shauryasharma96",
                        "content": "I\\'m stuck at testcase1 [1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]"
                    },
                    {
                        "username": "mishra_shashank",
                        "content": "Please Bhagwaan ji mujhe iss solution ke liye maaf karna\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        for(int i=0 ; i<n ; i++){\\n            if(nums[i]==target)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n\\'\\'\\'"
                    },
                    {
                        "username": "boogahead",
                        "content": "I confess using find"
                    },
                    {
                        "username": "Saumyajeet",
                        "content": "class Solution {\npublic:\nint pivot(vector<int>& arr, int n){\n    \n    int s=0;\n    int e=n-1;\n    \n    int mid=s+(e-s)/2;\n    \n    while(s<e){\n        \n        \n        if(arr[mid]>=arr[0]){\n            \n            \n            s=mid+1;\n            \n        }\n        else{\n            \n            e=mid;\n        }\n        \n        mid=s+(e-s)/2;\n        \n        \n        \n    }\n    \n    \n    return s;\n        \n        \n        \n}\nint binarysearch(vector<int>& arr, int s, int e, int value){\n\t\n\tint start = s;\n\t\n\tint end = e;\n\t\n\tint mid = start + (end-start)/2;\n\n    int l;\n\t\n\twhile(start<=end){\n\t\t\n\t\tif(arr[mid] == value){\n\t\t\t\n\t\t\t\n\t\t\tl=arr[mid];\n\t\t}\n\t\tif(arr[mid] <= value){\n\t\t\t\n\t\t\tstart = mid + 1;\n\t\t}\n\t\telse{\n\t\t\t\n\t\t\tend = mid-1;\n\t\t}\n\t\t\n\t\tmid = start + (end-start)/2;\n\t\t\n\t}\n\t\n\treturn l;\n\t\n}\n\n    bool search(vector<int>& arr, int value) {\n\n        int size=arr.size();\n        int k;\n\n        int p=pivot(arr, size);\n        if((value>=arr[p]) && (value<=arr[size-1])){\n\n            k=binarysearch(arr, p, size-1, value);\n        }\n        else{\n\n            k=binarysearch(arr, 0, p, value);\n        }\n\n        return k==value;\n        \n    }\n};\n\ni first use pivot to find pivot element then use binary search based on the value of target , \nnums =[2,5,6,0,0,1,2]  ,  target =0 while performing dry run it is showing true but it is showing false while executing , can anybody suggest me how to improve my code?"
                    },
                    {
                        "username": "nicolahadwen",
                        "content": "I see a lot of modified binary search, but still worst case O(n).\\nJust want to know if it\\'s even possible to do <O(n)"
                    },
                    {
                        "username": "barstow123",
                        "content": "It is fundamentally not possible. You cannot run a search on [1,1,1,1,1,1]."
                    }
                ]
            },
            {
                "id": 2008208,
                "content": [
                    {
                        "username": "koushikjavvaji2004",
                        "content": "if(nums[mid] == nums[low] && nums[mid] == nums[high]){\\n                low++;\\n                high--;\\n            }\\nThis is the best thing to do if there are duplicates."
                    },
                    {
                        "username": "arsalan_jumani",
                        "content": "Consider the example `[0, 0, ..., 0, 1, 0, 0, ..., 0]`, i.e. there is one `1` and the rest are `0`\\'s. This is a rotated sorted array but finding `1` here is just like find `1` in an unsorted array. Looking at values at `O(1)` indices (which are all `0`) cannot tell you if `1` is on the left or right.\\n\\nOf course, linear search is the simplest (and accepted) solution."
                    },
                    {
                        "username": "Xuanzhen-Zhang",
                        "content": "So how is the run time affected? Isn\\'t it still O(logn)?"
                    },
                    {
                        "username": "yaojintham",
                        "content": "o(n), you cannot use binary search to find the highest point or pivot point with duplicates.\\nIf you remove duplicates, you are already doing linear search, so it\\'s still o(n)."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Leetcode forgive me for this :0\\n\\n\\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            if(nums[i] == target)\\n                return 1;\\n        }\\n        return 0;\\n    "
                    },
                    {
                        "username": "andykimchris",
                        "content": "You are forgiven my boy :0"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "#### Description says :\\n`nums` is rotated at an unknown pivot index `k` (`0 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (0-indexed).\\n\\n#### Constraint says :\\n`nums` is guaranteed to be rotated at some pivot.\\n\\n#### But what about the case where `k = 0` ?? "
                    },
                    {
                        "username": "trip1312",
                        "content": "then it\\'s just a sorted array"
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "For your hint think about these two test case\\narr=[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1] target=2\\narr=[1,0,1,1,1] target=0\\nSolve for this two and you will get the solution."
                    },
                    {
                        "username": "shauryasharma96",
                        "content": "I\\'m stuck at testcase1 [1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]"
                    },
                    {
                        "username": "mishra_shashank",
                        "content": "Please Bhagwaan ji mujhe iss solution ke liye maaf karna\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        for(int i=0 ; i<n ; i++){\\n            if(nums[i]==target)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n\\'\\'\\'"
                    },
                    {
                        "username": "boogahead",
                        "content": "I confess using find"
                    },
                    {
                        "username": "Saumyajeet",
                        "content": "class Solution {\npublic:\nint pivot(vector<int>& arr, int n){\n    \n    int s=0;\n    int e=n-1;\n    \n    int mid=s+(e-s)/2;\n    \n    while(s<e){\n        \n        \n        if(arr[mid]>=arr[0]){\n            \n            \n            s=mid+1;\n            \n        }\n        else{\n            \n            e=mid;\n        }\n        \n        mid=s+(e-s)/2;\n        \n        \n        \n    }\n    \n    \n    return s;\n        \n        \n        \n}\nint binarysearch(vector<int>& arr, int s, int e, int value){\n\t\n\tint start = s;\n\t\n\tint end = e;\n\t\n\tint mid = start + (end-start)/2;\n\n    int l;\n\t\n\twhile(start<=end){\n\t\t\n\t\tif(arr[mid] == value){\n\t\t\t\n\t\t\t\n\t\t\tl=arr[mid];\n\t\t}\n\t\tif(arr[mid] <= value){\n\t\t\t\n\t\t\tstart = mid + 1;\n\t\t}\n\t\telse{\n\t\t\t\n\t\t\tend = mid-1;\n\t\t}\n\t\t\n\t\tmid = start + (end-start)/2;\n\t\t\n\t}\n\t\n\treturn l;\n\t\n}\n\n    bool search(vector<int>& arr, int value) {\n\n        int size=arr.size();\n        int k;\n\n        int p=pivot(arr, size);\n        if((value>=arr[p]) && (value<=arr[size-1])){\n\n            k=binarysearch(arr, p, size-1, value);\n        }\n        else{\n\n            k=binarysearch(arr, 0, p, value);\n        }\n\n        return k==value;\n        \n    }\n};\n\ni first use pivot to find pivot element then use binary search based on the value of target , \nnums =[2,5,6,0,0,1,2]  ,  target =0 while performing dry run it is showing true but it is showing false while executing , can anybody suggest me how to improve my code?"
                    },
                    {
                        "username": "nicolahadwen",
                        "content": "I see a lot of modified binary search, but still worst case O(n).\\nJust want to know if it\\'s even possible to do <O(n)"
                    },
                    {
                        "username": "barstow123",
                        "content": "It is fundamentally not possible. You cannot run a search on [1,1,1,1,1,1]."
                    }
                ]
            },
            {
                "id": 2008071,
                "content": [
                    {
                        "username": "koushikjavvaji2004",
                        "content": "if(nums[mid] == nums[low] && nums[mid] == nums[high]){\\n                low++;\\n                high--;\\n            }\\nThis is the best thing to do if there are duplicates."
                    },
                    {
                        "username": "arsalan_jumani",
                        "content": "Consider the example `[0, 0, ..., 0, 1, 0, 0, ..., 0]`, i.e. there is one `1` and the rest are `0`\\'s. This is a rotated sorted array but finding `1` here is just like find `1` in an unsorted array. Looking at values at `O(1)` indices (which are all `0`) cannot tell you if `1` is on the left or right.\\n\\nOf course, linear search is the simplest (and accepted) solution."
                    },
                    {
                        "username": "Xuanzhen-Zhang",
                        "content": "So how is the run time affected? Isn\\'t it still O(logn)?"
                    },
                    {
                        "username": "yaojintham",
                        "content": "o(n), you cannot use binary search to find the highest point or pivot point with duplicates.\\nIf you remove duplicates, you are already doing linear search, so it\\'s still o(n)."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Leetcode forgive me for this :0\\n\\n\\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            if(nums[i] == target)\\n                return 1;\\n        }\\n        return 0;\\n    "
                    },
                    {
                        "username": "andykimchris",
                        "content": "You are forgiven my boy :0"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "#### Description says :\\n`nums` is rotated at an unknown pivot index `k` (`0 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (0-indexed).\\n\\n#### Constraint says :\\n`nums` is guaranteed to be rotated at some pivot.\\n\\n#### But what about the case where `k = 0` ?? "
                    },
                    {
                        "username": "trip1312",
                        "content": "then it\\'s just a sorted array"
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "For your hint think about these two test case\\narr=[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1] target=2\\narr=[1,0,1,1,1] target=0\\nSolve for this two and you will get the solution."
                    },
                    {
                        "username": "shauryasharma96",
                        "content": "I\\'m stuck at testcase1 [1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]"
                    },
                    {
                        "username": "mishra_shashank",
                        "content": "Please Bhagwaan ji mujhe iss solution ke liye maaf karna\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        for(int i=0 ; i<n ; i++){\\n            if(nums[i]==target)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n\\'\\'\\'"
                    },
                    {
                        "username": "boogahead",
                        "content": "I confess using find"
                    },
                    {
                        "username": "Saumyajeet",
                        "content": "class Solution {\npublic:\nint pivot(vector<int>& arr, int n){\n    \n    int s=0;\n    int e=n-1;\n    \n    int mid=s+(e-s)/2;\n    \n    while(s<e){\n        \n        \n        if(arr[mid]>=arr[0]){\n            \n            \n            s=mid+1;\n            \n        }\n        else{\n            \n            e=mid;\n        }\n        \n        mid=s+(e-s)/2;\n        \n        \n        \n    }\n    \n    \n    return s;\n        \n        \n        \n}\nint binarysearch(vector<int>& arr, int s, int e, int value){\n\t\n\tint start = s;\n\t\n\tint end = e;\n\t\n\tint mid = start + (end-start)/2;\n\n    int l;\n\t\n\twhile(start<=end){\n\t\t\n\t\tif(arr[mid] == value){\n\t\t\t\n\t\t\t\n\t\t\tl=arr[mid];\n\t\t}\n\t\tif(arr[mid] <= value){\n\t\t\t\n\t\t\tstart = mid + 1;\n\t\t}\n\t\telse{\n\t\t\t\n\t\t\tend = mid-1;\n\t\t}\n\t\t\n\t\tmid = start + (end-start)/2;\n\t\t\n\t}\n\t\n\treturn l;\n\t\n}\n\n    bool search(vector<int>& arr, int value) {\n\n        int size=arr.size();\n        int k;\n\n        int p=pivot(arr, size);\n        if((value>=arr[p]) && (value<=arr[size-1])){\n\n            k=binarysearch(arr, p, size-1, value);\n        }\n        else{\n\n            k=binarysearch(arr, 0, p, value);\n        }\n\n        return k==value;\n        \n    }\n};\n\ni first use pivot to find pivot element then use binary search based on the value of target , \nnums =[2,5,6,0,0,1,2]  ,  target =0 while performing dry run it is showing true but it is showing false while executing , can anybody suggest me how to improve my code?"
                    },
                    {
                        "username": "nicolahadwen",
                        "content": "I see a lot of modified binary search, but still worst case O(n).\\nJust want to know if it\\'s even possible to do <O(n)"
                    },
                    {
                        "username": "barstow123",
                        "content": "It is fundamentally not possible. You cannot run a search on [1,1,1,1,1,1]."
                    }
                ]
            },
            {
                "id": 2007862,
                "content": [
                    {
                        "username": "koushikjavvaji2004",
                        "content": "if(nums[mid] == nums[low] && nums[mid] == nums[high]){\\n                low++;\\n                high--;\\n            }\\nThis is the best thing to do if there are duplicates."
                    },
                    {
                        "username": "arsalan_jumani",
                        "content": "Consider the example `[0, 0, ..., 0, 1, 0, 0, ..., 0]`, i.e. there is one `1` and the rest are `0`\\'s. This is a rotated sorted array but finding `1` here is just like find `1` in an unsorted array. Looking at values at `O(1)` indices (which are all `0`) cannot tell you if `1` is on the left or right.\\n\\nOf course, linear search is the simplest (and accepted) solution."
                    },
                    {
                        "username": "Xuanzhen-Zhang",
                        "content": "So how is the run time affected? Isn\\'t it still O(logn)?"
                    },
                    {
                        "username": "yaojintham",
                        "content": "o(n), you cannot use binary search to find the highest point or pivot point with duplicates.\\nIf you remove duplicates, you are already doing linear search, so it\\'s still o(n)."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Leetcode forgive me for this :0\\n\\n\\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            if(nums[i] == target)\\n                return 1;\\n        }\\n        return 0;\\n    "
                    },
                    {
                        "username": "andykimchris",
                        "content": "You are forgiven my boy :0"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "#### Description says :\\n`nums` is rotated at an unknown pivot index `k` (`0 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (0-indexed).\\n\\n#### Constraint says :\\n`nums` is guaranteed to be rotated at some pivot.\\n\\n#### But what about the case where `k = 0` ?? "
                    },
                    {
                        "username": "trip1312",
                        "content": "then it\\'s just a sorted array"
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "For your hint think about these two test case\\narr=[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1] target=2\\narr=[1,0,1,1,1] target=0\\nSolve for this two and you will get the solution."
                    },
                    {
                        "username": "shauryasharma96",
                        "content": "I\\'m stuck at testcase1 [1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]"
                    },
                    {
                        "username": "mishra_shashank",
                        "content": "Please Bhagwaan ji mujhe iss solution ke liye maaf karna\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        for(int i=0 ; i<n ; i++){\\n            if(nums[i]==target)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n\\'\\'\\'"
                    },
                    {
                        "username": "boogahead",
                        "content": "I confess using find"
                    },
                    {
                        "username": "Saumyajeet",
                        "content": "class Solution {\npublic:\nint pivot(vector<int>& arr, int n){\n    \n    int s=0;\n    int e=n-1;\n    \n    int mid=s+(e-s)/2;\n    \n    while(s<e){\n        \n        \n        if(arr[mid]>=arr[0]){\n            \n            \n            s=mid+1;\n            \n        }\n        else{\n            \n            e=mid;\n        }\n        \n        mid=s+(e-s)/2;\n        \n        \n        \n    }\n    \n    \n    return s;\n        \n        \n        \n}\nint binarysearch(vector<int>& arr, int s, int e, int value){\n\t\n\tint start = s;\n\t\n\tint end = e;\n\t\n\tint mid = start + (end-start)/2;\n\n    int l;\n\t\n\twhile(start<=end){\n\t\t\n\t\tif(arr[mid] == value){\n\t\t\t\n\t\t\t\n\t\t\tl=arr[mid];\n\t\t}\n\t\tif(arr[mid] <= value){\n\t\t\t\n\t\t\tstart = mid + 1;\n\t\t}\n\t\telse{\n\t\t\t\n\t\t\tend = mid-1;\n\t\t}\n\t\t\n\t\tmid = start + (end-start)/2;\n\t\t\n\t}\n\t\n\treturn l;\n\t\n}\n\n    bool search(vector<int>& arr, int value) {\n\n        int size=arr.size();\n        int k;\n\n        int p=pivot(arr, size);\n        if((value>=arr[p]) && (value<=arr[size-1])){\n\n            k=binarysearch(arr, p, size-1, value);\n        }\n        else{\n\n            k=binarysearch(arr, 0, p, value);\n        }\n\n        return k==value;\n        \n    }\n};\n\ni first use pivot to find pivot element then use binary search based on the value of target , \nnums =[2,5,6,0,0,1,2]  ,  target =0 while performing dry run it is showing true but it is showing false while executing , can anybody suggest me how to improve my code?"
                    },
                    {
                        "username": "nicolahadwen",
                        "content": "I see a lot of modified binary search, but still worst case O(n).\\nJust want to know if it\\'s even possible to do <O(n)"
                    },
                    {
                        "username": "barstow123",
                        "content": "It is fundamentally not possible. You cannot run a search on [1,1,1,1,1,1]."
                    }
                ]
            },
            {
                "id": 2007844,
                "content": [
                    {
                        "username": "koushikjavvaji2004",
                        "content": "if(nums[mid] == nums[low] && nums[mid] == nums[high]){\\n                low++;\\n                high--;\\n            }\\nThis is the best thing to do if there are duplicates."
                    },
                    {
                        "username": "arsalan_jumani",
                        "content": "Consider the example `[0, 0, ..., 0, 1, 0, 0, ..., 0]`, i.e. there is one `1` and the rest are `0`\\'s. This is a rotated sorted array but finding `1` here is just like find `1` in an unsorted array. Looking at values at `O(1)` indices (which are all `0`) cannot tell you if `1` is on the left or right.\\n\\nOf course, linear search is the simplest (and accepted) solution."
                    },
                    {
                        "username": "Xuanzhen-Zhang",
                        "content": "So how is the run time affected? Isn\\'t it still O(logn)?"
                    },
                    {
                        "username": "yaojintham",
                        "content": "o(n), you cannot use binary search to find the highest point or pivot point with duplicates.\\nIf you remove duplicates, you are already doing linear search, so it\\'s still o(n)."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Leetcode forgive me for this :0\\n\\n\\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            if(nums[i] == target)\\n                return 1;\\n        }\\n        return 0;\\n    "
                    },
                    {
                        "username": "andykimchris",
                        "content": "You are forgiven my boy :0"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "#### Description says :\\n`nums` is rotated at an unknown pivot index `k` (`0 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (0-indexed).\\n\\n#### Constraint says :\\n`nums` is guaranteed to be rotated at some pivot.\\n\\n#### But what about the case where `k = 0` ?? "
                    },
                    {
                        "username": "trip1312",
                        "content": "then it\\'s just a sorted array"
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "For your hint think about these two test case\\narr=[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1] target=2\\narr=[1,0,1,1,1] target=0\\nSolve for this two and you will get the solution."
                    },
                    {
                        "username": "shauryasharma96",
                        "content": "I\\'m stuck at testcase1 [1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]"
                    },
                    {
                        "username": "mishra_shashank",
                        "content": "Please Bhagwaan ji mujhe iss solution ke liye maaf karna\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        for(int i=0 ; i<n ; i++){\\n            if(nums[i]==target)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n\\'\\'\\'"
                    },
                    {
                        "username": "boogahead",
                        "content": "I confess using find"
                    },
                    {
                        "username": "Saumyajeet",
                        "content": "class Solution {\npublic:\nint pivot(vector<int>& arr, int n){\n    \n    int s=0;\n    int e=n-1;\n    \n    int mid=s+(e-s)/2;\n    \n    while(s<e){\n        \n        \n        if(arr[mid]>=arr[0]){\n            \n            \n            s=mid+1;\n            \n        }\n        else{\n            \n            e=mid;\n        }\n        \n        mid=s+(e-s)/2;\n        \n        \n        \n    }\n    \n    \n    return s;\n        \n        \n        \n}\nint binarysearch(vector<int>& arr, int s, int e, int value){\n\t\n\tint start = s;\n\t\n\tint end = e;\n\t\n\tint mid = start + (end-start)/2;\n\n    int l;\n\t\n\twhile(start<=end){\n\t\t\n\t\tif(arr[mid] == value){\n\t\t\t\n\t\t\t\n\t\t\tl=arr[mid];\n\t\t}\n\t\tif(arr[mid] <= value){\n\t\t\t\n\t\t\tstart = mid + 1;\n\t\t}\n\t\telse{\n\t\t\t\n\t\t\tend = mid-1;\n\t\t}\n\t\t\n\t\tmid = start + (end-start)/2;\n\t\t\n\t}\n\t\n\treturn l;\n\t\n}\n\n    bool search(vector<int>& arr, int value) {\n\n        int size=arr.size();\n        int k;\n\n        int p=pivot(arr, size);\n        if((value>=arr[p]) && (value<=arr[size-1])){\n\n            k=binarysearch(arr, p, size-1, value);\n        }\n        else{\n\n            k=binarysearch(arr, 0, p, value);\n        }\n\n        return k==value;\n        \n    }\n};\n\ni first use pivot to find pivot element then use binary search based on the value of target , \nnums =[2,5,6,0,0,1,2]  ,  target =0 while performing dry run it is showing true but it is showing false while executing , can anybody suggest me how to improve my code?"
                    },
                    {
                        "username": "nicolahadwen",
                        "content": "I see a lot of modified binary search, but still worst case O(n).\\nJust want to know if it\\'s even possible to do <O(n)"
                    },
                    {
                        "username": "barstow123",
                        "content": "It is fundamentally not possible. You cannot run a search on [1,1,1,1,1,1]."
                    }
                ]
            },
            {
                "id": 2007610,
                "content": [
                    {
                        "username": "koushikjavvaji2004",
                        "content": "if(nums[mid] == nums[low] && nums[mid] == nums[high]){\\n                low++;\\n                high--;\\n            }\\nThis is the best thing to do if there are duplicates."
                    },
                    {
                        "username": "arsalan_jumani",
                        "content": "Consider the example `[0, 0, ..., 0, 1, 0, 0, ..., 0]`, i.e. there is one `1` and the rest are `0`\\'s. This is a rotated sorted array but finding `1` here is just like find `1` in an unsorted array. Looking at values at `O(1)` indices (which are all `0`) cannot tell you if `1` is on the left or right.\\n\\nOf course, linear search is the simplest (and accepted) solution."
                    },
                    {
                        "username": "Xuanzhen-Zhang",
                        "content": "So how is the run time affected? Isn\\'t it still O(logn)?"
                    },
                    {
                        "username": "yaojintham",
                        "content": "o(n), you cannot use binary search to find the highest point or pivot point with duplicates.\\nIf you remove duplicates, you are already doing linear search, so it\\'s still o(n)."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Leetcode forgive me for this :0\\n\\n\\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            if(nums[i] == target)\\n                return 1;\\n        }\\n        return 0;\\n    "
                    },
                    {
                        "username": "andykimchris",
                        "content": "You are forgiven my boy :0"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "#### Description says :\\n`nums` is rotated at an unknown pivot index `k` (`0 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (0-indexed).\\n\\n#### Constraint says :\\n`nums` is guaranteed to be rotated at some pivot.\\n\\n#### But what about the case where `k = 0` ?? "
                    },
                    {
                        "username": "trip1312",
                        "content": "then it\\'s just a sorted array"
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "For your hint think about these two test case\\narr=[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1] target=2\\narr=[1,0,1,1,1] target=0\\nSolve for this two and you will get the solution."
                    },
                    {
                        "username": "shauryasharma96",
                        "content": "I\\'m stuck at testcase1 [1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]"
                    },
                    {
                        "username": "mishra_shashank",
                        "content": "Please Bhagwaan ji mujhe iss solution ke liye maaf karna\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        for(int i=0 ; i<n ; i++){\\n            if(nums[i]==target)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n\\'\\'\\'"
                    },
                    {
                        "username": "boogahead",
                        "content": "I confess using find"
                    },
                    {
                        "username": "Saumyajeet",
                        "content": "class Solution {\npublic:\nint pivot(vector<int>& arr, int n){\n    \n    int s=0;\n    int e=n-1;\n    \n    int mid=s+(e-s)/2;\n    \n    while(s<e){\n        \n        \n        if(arr[mid]>=arr[0]){\n            \n            \n            s=mid+1;\n            \n        }\n        else{\n            \n            e=mid;\n        }\n        \n        mid=s+(e-s)/2;\n        \n        \n        \n    }\n    \n    \n    return s;\n        \n        \n        \n}\nint binarysearch(vector<int>& arr, int s, int e, int value){\n\t\n\tint start = s;\n\t\n\tint end = e;\n\t\n\tint mid = start + (end-start)/2;\n\n    int l;\n\t\n\twhile(start<=end){\n\t\t\n\t\tif(arr[mid] == value){\n\t\t\t\n\t\t\t\n\t\t\tl=arr[mid];\n\t\t}\n\t\tif(arr[mid] <= value){\n\t\t\t\n\t\t\tstart = mid + 1;\n\t\t}\n\t\telse{\n\t\t\t\n\t\t\tend = mid-1;\n\t\t}\n\t\t\n\t\tmid = start + (end-start)/2;\n\t\t\n\t}\n\t\n\treturn l;\n\t\n}\n\n    bool search(vector<int>& arr, int value) {\n\n        int size=arr.size();\n        int k;\n\n        int p=pivot(arr, size);\n        if((value>=arr[p]) && (value<=arr[size-1])){\n\n            k=binarysearch(arr, p, size-1, value);\n        }\n        else{\n\n            k=binarysearch(arr, 0, p, value);\n        }\n\n        return k==value;\n        \n    }\n};\n\ni first use pivot to find pivot element then use binary search based on the value of target , \nnums =[2,5,6,0,0,1,2]  ,  target =0 while performing dry run it is showing true but it is showing false while executing , can anybody suggest me how to improve my code?"
                    },
                    {
                        "username": "nicolahadwen",
                        "content": "I see a lot of modified binary search, but still worst case O(n).\\nJust want to know if it\\'s even possible to do <O(n)"
                    },
                    {
                        "username": "barstow123",
                        "content": "It is fundamentally not possible. You cannot run a search on [1,1,1,1,1,1]."
                    }
                ]
            },
            {
                "id": 1905939,
                "content": [
                    {
                        "username": "koushikjavvaji2004",
                        "content": "if(nums[mid] == nums[low] && nums[mid] == nums[high]){\\n                low++;\\n                high--;\\n            }\\nThis is the best thing to do if there are duplicates."
                    },
                    {
                        "username": "arsalan_jumani",
                        "content": "Consider the example `[0, 0, ..., 0, 1, 0, 0, ..., 0]`, i.e. there is one `1` and the rest are `0`\\'s. This is a rotated sorted array but finding `1` here is just like find `1` in an unsorted array. Looking at values at `O(1)` indices (which are all `0`) cannot tell you if `1` is on the left or right.\\n\\nOf course, linear search is the simplest (and accepted) solution."
                    },
                    {
                        "username": "Xuanzhen-Zhang",
                        "content": "So how is the run time affected? Isn\\'t it still O(logn)?"
                    },
                    {
                        "username": "yaojintham",
                        "content": "o(n), you cannot use binary search to find the highest point or pivot point with duplicates.\\nIf you remove duplicates, you are already doing linear search, so it\\'s still o(n)."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Leetcode forgive me for this :0\\n\\n\\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            if(nums[i] == target)\\n                return 1;\\n        }\\n        return 0;\\n    "
                    },
                    {
                        "username": "andykimchris",
                        "content": "You are forgiven my boy :0"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "#### Description says :\\n`nums` is rotated at an unknown pivot index `k` (`0 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (0-indexed).\\n\\n#### Constraint says :\\n`nums` is guaranteed to be rotated at some pivot.\\n\\n#### But what about the case where `k = 0` ?? "
                    },
                    {
                        "username": "trip1312",
                        "content": "then it\\'s just a sorted array"
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "For your hint think about these two test case\\narr=[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1] target=2\\narr=[1,0,1,1,1] target=0\\nSolve for this two and you will get the solution."
                    },
                    {
                        "username": "shauryasharma96",
                        "content": "I\\'m stuck at testcase1 [1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]"
                    },
                    {
                        "username": "mishra_shashank",
                        "content": "Please Bhagwaan ji mujhe iss solution ke liye maaf karna\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        for(int i=0 ; i<n ; i++){\\n            if(nums[i]==target)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n\\'\\'\\'"
                    },
                    {
                        "username": "boogahead",
                        "content": "I confess using find"
                    },
                    {
                        "username": "Saumyajeet",
                        "content": "class Solution {\npublic:\nint pivot(vector<int>& arr, int n){\n    \n    int s=0;\n    int e=n-1;\n    \n    int mid=s+(e-s)/2;\n    \n    while(s<e){\n        \n        \n        if(arr[mid]>=arr[0]){\n            \n            \n            s=mid+1;\n            \n        }\n        else{\n            \n            e=mid;\n        }\n        \n        mid=s+(e-s)/2;\n        \n        \n        \n    }\n    \n    \n    return s;\n        \n        \n        \n}\nint binarysearch(vector<int>& arr, int s, int e, int value){\n\t\n\tint start = s;\n\t\n\tint end = e;\n\t\n\tint mid = start + (end-start)/2;\n\n    int l;\n\t\n\twhile(start<=end){\n\t\t\n\t\tif(arr[mid] == value){\n\t\t\t\n\t\t\t\n\t\t\tl=arr[mid];\n\t\t}\n\t\tif(arr[mid] <= value){\n\t\t\t\n\t\t\tstart = mid + 1;\n\t\t}\n\t\telse{\n\t\t\t\n\t\t\tend = mid-1;\n\t\t}\n\t\t\n\t\tmid = start + (end-start)/2;\n\t\t\n\t}\n\t\n\treturn l;\n\t\n}\n\n    bool search(vector<int>& arr, int value) {\n\n        int size=arr.size();\n        int k;\n\n        int p=pivot(arr, size);\n        if((value>=arr[p]) && (value<=arr[size-1])){\n\n            k=binarysearch(arr, p, size-1, value);\n        }\n        else{\n\n            k=binarysearch(arr, 0, p, value);\n        }\n\n        return k==value;\n        \n    }\n};\n\ni first use pivot to find pivot element then use binary search based on the value of target , \nnums =[2,5,6,0,0,1,2]  ,  target =0 while performing dry run it is showing true but it is showing false while executing , can anybody suggest me how to improve my code?"
                    },
                    {
                        "username": "nicolahadwen",
                        "content": "I see a lot of modified binary search, but still worst case O(n).\\nJust want to know if it\\'s even possible to do <O(n)"
                    },
                    {
                        "username": "barstow123",
                        "content": "It is fundamentally not possible. You cannot run a search on [1,1,1,1,1,1]."
                    }
                ]
            },
            {
                "id": 1573960,
                "content": [
                    {
                        "username": "koushikjavvaji2004",
                        "content": "if(nums[mid] == nums[low] && nums[mid] == nums[high]){\\n                low++;\\n                high--;\\n            }\\nThis is the best thing to do if there are duplicates."
                    },
                    {
                        "username": "arsalan_jumani",
                        "content": "Consider the example `[0, 0, ..., 0, 1, 0, 0, ..., 0]`, i.e. there is one `1` and the rest are `0`\\'s. This is a rotated sorted array but finding `1` here is just like find `1` in an unsorted array. Looking at values at `O(1)` indices (which are all `0`) cannot tell you if `1` is on the left or right.\\n\\nOf course, linear search is the simplest (and accepted) solution."
                    },
                    {
                        "username": "Xuanzhen-Zhang",
                        "content": "So how is the run time affected? Isn\\'t it still O(logn)?"
                    },
                    {
                        "username": "yaojintham",
                        "content": "o(n), you cannot use binary search to find the highest point or pivot point with duplicates.\\nIf you remove duplicates, you are already doing linear search, so it\\'s still o(n)."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Leetcode forgive me for this :0\\n\\n\\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            if(nums[i] == target)\\n                return 1;\\n        }\\n        return 0;\\n    "
                    },
                    {
                        "username": "andykimchris",
                        "content": "You are forgiven my boy :0"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "#### Description says :\\n`nums` is rotated at an unknown pivot index `k` (`0 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (0-indexed).\\n\\n#### Constraint says :\\n`nums` is guaranteed to be rotated at some pivot.\\n\\n#### But what about the case where `k = 0` ?? "
                    },
                    {
                        "username": "trip1312",
                        "content": "then it\\'s just a sorted array"
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "For your hint think about these two test case\\narr=[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1] target=2\\narr=[1,0,1,1,1] target=0\\nSolve for this two and you will get the solution."
                    },
                    {
                        "username": "shauryasharma96",
                        "content": "I\\'m stuck at testcase1 [1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]"
                    },
                    {
                        "username": "mishra_shashank",
                        "content": "Please Bhagwaan ji mujhe iss solution ke liye maaf karna\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        for(int i=0 ; i<n ; i++){\\n            if(nums[i]==target)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n\\'\\'\\'"
                    },
                    {
                        "username": "boogahead",
                        "content": "I confess using find"
                    },
                    {
                        "username": "Saumyajeet",
                        "content": "class Solution {\npublic:\nint pivot(vector<int>& arr, int n){\n    \n    int s=0;\n    int e=n-1;\n    \n    int mid=s+(e-s)/2;\n    \n    while(s<e){\n        \n        \n        if(arr[mid]>=arr[0]){\n            \n            \n            s=mid+1;\n            \n        }\n        else{\n            \n            e=mid;\n        }\n        \n        mid=s+(e-s)/2;\n        \n        \n        \n    }\n    \n    \n    return s;\n        \n        \n        \n}\nint binarysearch(vector<int>& arr, int s, int e, int value){\n\t\n\tint start = s;\n\t\n\tint end = e;\n\t\n\tint mid = start + (end-start)/2;\n\n    int l;\n\t\n\twhile(start<=end){\n\t\t\n\t\tif(arr[mid] == value){\n\t\t\t\n\t\t\t\n\t\t\tl=arr[mid];\n\t\t}\n\t\tif(arr[mid] <= value){\n\t\t\t\n\t\t\tstart = mid + 1;\n\t\t}\n\t\telse{\n\t\t\t\n\t\t\tend = mid-1;\n\t\t}\n\t\t\n\t\tmid = start + (end-start)/2;\n\t\t\n\t}\n\t\n\treturn l;\n\t\n}\n\n    bool search(vector<int>& arr, int value) {\n\n        int size=arr.size();\n        int k;\n\n        int p=pivot(arr, size);\n        if((value>=arr[p]) && (value<=arr[size-1])){\n\n            k=binarysearch(arr, p, size-1, value);\n        }\n        else{\n\n            k=binarysearch(arr, 0, p, value);\n        }\n\n        return k==value;\n        \n    }\n};\n\ni first use pivot to find pivot element then use binary search based on the value of target , \nnums =[2,5,6,0,0,1,2]  ,  target =0 while performing dry run it is showing true but it is showing false while executing , can anybody suggest me how to improve my code?"
                    },
                    {
                        "username": "nicolahadwen",
                        "content": "I see a lot of modified binary search, but still worst case O(n).\\nJust want to know if it\\'s even possible to do <O(n)"
                    },
                    {
                        "username": "barstow123",
                        "content": "It is fundamentally not possible. You cannot run a search on [1,1,1,1,1,1]."
                    }
                ]
            },
            {
                "id": 1574949,
                "content": [
                    {
                        "username": "gqian3",
                        "content": "What\\'s the point of this problem if one simple for loop (worst case: O(n)) can solve it with better performance/space than most of the fancy alg?"
                    },
                    {
                        "username": "whisly",
                        "content": "it says \"If target is found in the array return its index, otherwise, return -1.\"\\n\\nHowever, the solution and the test cases just return True or False"
                    },
                    {
                        "username": "Dab07",
                        "content": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int i = 0;\\n        int j = nums.length - 1;\\n\\n        int b = 0;\\n        for (int k = 1; k < nums.length; ++k) {\\n            if (nums[k - 1] > nums[k]) {\\n                b = k;\\n                break;\\n            }\\n        }\\n\\n\\n        while (i <= j) {\\n            int mid = i + (j - i) / 2;\\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n            if (mid <= b) {\\n                if (nums[i] <= target && nums[mid] <= target) {\\n                    j = mid - 1;\\n                } else {\\n                    i = mid + 1;\\n                }\\n            } else {\\n                if (nums[j] >= target && nums[mid] <= target) {\\n                    i = mid + 1;\\n                } else {\\n                    j = mid - 1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n> 255 / 280 testcases passed\\nMy code if failing at this testcase\\n\\n` nums = [1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]` \\n`target = 2`\\n\\n<h1>Can anyone help me out where I am doing mistake?</h1>\\n"
                    },
                    {
                        "username": "Ezaidi",
                        "content": "Sorting nums[] and then simply applying binary search beats 83.3% in runtime,though the space complexity is bad. Any suggestions or reasons ? "
                    },
                    {
                        "username": "ayush_aicoder",
                        "content": "Same Code worked in both the rotated search questions I had used Binary Search Approach"
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "what is the error in my code ? it is failing edge case of  1,0,1,1,1\\n\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length-1;\\n\\n        while(low<high){\\n            int mid = (low + high)/2;\\n\\n            if(nums[mid] == target){\\n                return true;\\n            }\\n\\n            if(nums[low]== nums[mid] && nums[mid] == nums[high]){\\n                low++;\\n                high--;\\n               \\n            }\\n\\n            if(nums[low] <= nums[mid]){\\n                if(nums[low] <= target && target < nums[mid]){\\n                    high = mid -1;\\n                }\\n                else{\\n                    low = mid +1;\\n                }\\n            }\\n            else{\\n                if(nums[mid] <= target && target < nums[high]){\\n                    low = mid +1;\\n                }\\n                else{\\n                    high = mid -1;\\n                }\\n            }\\n\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@anshgandhi21](/anshgandhi21) No worries at all.  "
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "[@andykimchris](/andykimchris)  Thank you ! helped a lot"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Here\\'s your problem man\\nwhile(low<high)\\nIt should be while(low<=high)\\nYou\\'re not giving your algorithm the chance to check the mid if low and right are the same. \\n\\nThen after that check at mid == target is false break out of the loop\\nif (low == high) {\\n            break;\\n        }"
                    },
                    {
                        "username": "bborcic",
                        "content": "It\\'s a bad taste joke to emphasize <b>rotated</b> and insist on its <b>guarantee</b> when rotation is defined in such a way that the absence of rotation counts as a rotation and some test case exploits it. It\\'s even worse when the array size is allowed to be such that a meaningful rotation can\\'t even exist."
                    },
                    {
                        "username": "prixxx",
                        "content": "needs tighter constraints and better testcases , a simple sort and scan works."
                    },
                    {
                        "username": "andykimchris",
                        "content": "But can you solve within the constraints? That\\'s what makes it interesting. "
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution {\\n    public boolean search(int[] nums, int target) {\\n        // ====== Approach 1 ===========\\n        // Linear search time complexity O(n)\\n\\n    //     for(int i=0;i<nums.length;i++){\\n    //         if(nums[i]==target){\\n    //             return true;\\n    //         }\\n    //     }\\n    // return false;\\n    // }\\n\\n\\n\\n\\n    // ======== Applying Binary Search ===========\\n    // ================Time Complexity O(log n)=======\\n    int low=0;\\n    int high=nums.length-1;\\n    while(low<=high){\\n        int mid=(low+high)/2;\\n        // If target is at middle index\\n          if(nums[mid]==target){\\n            return true;\\n        }\\n \\n         if (nums[low] == nums[mid] && nums[mid] == nums[high]) {\\n                low = low + 1;\\n                high = high - 1;\\n                continue;\\n            }\\n      \\n        if(nums[low]<=nums[mid]){\\n            // This means the left part is sorted \\n            \\n            //Here there are two cases possible \\n                // 1.The target is in sorted part \\n                // 2.The target is not in sorted part\\n\\n\\n                //This means the target is in sorted part\\n                if(target<=nums[mid] && target>=nums[low]) {\\n                    high=mid-1;\\n                }\\n                else{\\n                    low=mid+1;\\n                }\\n        }\\n        else{\\n            // nums[high]>=nums[mid]\\n            // This means the right part is sorted \\n             //Here there are two cases possible \\n                // 1.The target is in sorted part \\n                // 2.The target is not in sorted part\\n\\n\\n                //This means the target is in sorted part\\n                if(target>=nums[mid] && target<=nums[high]) {\\n                   low=mid+1;\\n                }\\n                else{\\n                    high=mid-1;\\n                }\\n        }\\n\\n\\n\\n    }\\n    return false;\\n    }\\n}\\n\\n\\nJava Solution with explaination \\n"
                    },
                    {
                        "username": "priestess_of_light",
                        "content": "Seems like in practice for this problem simple linear search gives better results than binary search. The worst case complexity is O(n) still. Linear search beats 100% in C++, about 94 in python3, about 87 in python. No built-in functions, just a cycle"
                    }
                ]
            },
            {
                "id": 1574874,
                "content": [
                    {
                        "username": "gqian3",
                        "content": "What\\'s the point of this problem if one simple for loop (worst case: O(n)) can solve it with better performance/space than most of the fancy alg?"
                    },
                    {
                        "username": "whisly",
                        "content": "it says \"If target is found in the array return its index, otherwise, return -1.\"\\n\\nHowever, the solution and the test cases just return True or False"
                    },
                    {
                        "username": "Dab07",
                        "content": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int i = 0;\\n        int j = nums.length - 1;\\n\\n        int b = 0;\\n        for (int k = 1; k < nums.length; ++k) {\\n            if (nums[k - 1] > nums[k]) {\\n                b = k;\\n                break;\\n            }\\n        }\\n\\n\\n        while (i <= j) {\\n            int mid = i + (j - i) / 2;\\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n            if (mid <= b) {\\n                if (nums[i] <= target && nums[mid] <= target) {\\n                    j = mid - 1;\\n                } else {\\n                    i = mid + 1;\\n                }\\n            } else {\\n                if (nums[j] >= target && nums[mid] <= target) {\\n                    i = mid + 1;\\n                } else {\\n                    j = mid - 1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n> 255 / 280 testcases passed\\nMy code if failing at this testcase\\n\\n` nums = [1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]` \\n`target = 2`\\n\\n<h1>Can anyone help me out where I am doing mistake?</h1>\\n"
                    },
                    {
                        "username": "Ezaidi",
                        "content": "Sorting nums[] and then simply applying binary search beats 83.3% in runtime,though the space complexity is bad. Any suggestions or reasons ? "
                    },
                    {
                        "username": "ayush_aicoder",
                        "content": "Same Code worked in both the rotated search questions I had used Binary Search Approach"
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "what is the error in my code ? it is failing edge case of  1,0,1,1,1\\n\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length-1;\\n\\n        while(low<high){\\n            int mid = (low + high)/2;\\n\\n            if(nums[mid] == target){\\n                return true;\\n            }\\n\\n            if(nums[low]== nums[mid] && nums[mid] == nums[high]){\\n                low++;\\n                high--;\\n               \\n            }\\n\\n            if(nums[low] <= nums[mid]){\\n                if(nums[low] <= target && target < nums[mid]){\\n                    high = mid -1;\\n                }\\n                else{\\n                    low = mid +1;\\n                }\\n            }\\n            else{\\n                if(nums[mid] <= target && target < nums[high]){\\n                    low = mid +1;\\n                }\\n                else{\\n                    high = mid -1;\\n                }\\n            }\\n\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@anshgandhi21](/anshgandhi21) No worries at all.  "
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "[@andykimchris](/andykimchris)  Thank you ! helped a lot"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Here\\'s your problem man\\nwhile(low<high)\\nIt should be while(low<=high)\\nYou\\'re not giving your algorithm the chance to check the mid if low and right are the same. \\n\\nThen after that check at mid == target is false break out of the loop\\nif (low == high) {\\n            break;\\n        }"
                    },
                    {
                        "username": "bborcic",
                        "content": "It\\'s a bad taste joke to emphasize <b>rotated</b> and insist on its <b>guarantee</b> when rotation is defined in such a way that the absence of rotation counts as a rotation and some test case exploits it. It\\'s even worse when the array size is allowed to be such that a meaningful rotation can\\'t even exist."
                    },
                    {
                        "username": "prixxx",
                        "content": "needs tighter constraints and better testcases , a simple sort and scan works."
                    },
                    {
                        "username": "andykimchris",
                        "content": "But can you solve within the constraints? That\\'s what makes it interesting. "
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution {\\n    public boolean search(int[] nums, int target) {\\n        // ====== Approach 1 ===========\\n        // Linear search time complexity O(n)\\n\\n    //     for(int i=0;i<nums.length;i++){\\n    //         if(nums[i]==target){\\n    //             return true;\\n    //         }\\n    //     }\\n    // return false;\\n    // }\\n\\n\\n\\n\\n    // ======== Applying Binary Search ===========\\n    // ================Time Complexity O(log n)=======\\n    int low=0;\\n    int high=nums.length-1;\\n    while(low<=high){\\n        int mid=(low+high)/2;\\n        // If target is at middle index\\n          if(nums[mid]==target){\\n            return true;\\n        }\\n \\n         if (nums[low] == nums[mid] && nums[mid] == nums[high]) {\\n                low = low + 1;\\n                high = high - 1;\\n                continue;\\n            }\\n      \\n        if(nums[low]<=nums[mid]){\\n            // This means the left part is sorted \\n            \\n            //Here there are two cases possible \\n                // 1.The target is in sorted part \\n                // 2.The target is not in sorted part\\n\\n\\n                //This means the target is in sorted part\\n                if(target<=nums[mid] && target>=nums[low]) {\\n                    high=mid-1;\\n                }\\n                else{\\n                    low=mid+1;\\n                }\\n        }\\n        else{\\n            // nums[high]>=nums[mid]\\n            // This means the right part is sorted \\n             //Here there are two cases possible \\n                // 1.The target is in sorted part \\n                // 2.The target is not in sorted part\\n\\n\\n                //This means the target is in sorted part\\n                if(target>=nums[mid] && target<=nums[high]) {\\n                   low=mid+1;\\n                }\\n                else{\\n                    high=mid-1;\\n                }\\n        }\\n\\n\\n\\n    }\\n    return false;\\n    }\\n}\\n\\n\\nJava Solution with explaination \\n"
                    },
                    {
                        "username": "priestess_of_light",
                        "content": "Seems like in practice for this problem simple linear search gives better results than binary search. The worst case complexity is O(n) still. Linear search beats 100% in C++, about 94 in python3, about 87 in python. No built-in functions, just a cycle"
                    }
                ]
            },
            {
                "id": 2059629,
                "content": [
                    {
                        "username": "gqian3",
                        "content": "What\\'s the point of this problem if one simple for loop (worst case: O(n)) can solve it with better performance/space than most of the fancy alg?"
                    },
                    {
                        "username": "whisly",
                        "content": "it says \"If target is found in the array return its index, otherwise, return -1.\"\\n\\nHowever, the solution and the test cases just return True or False"
                    },
                    {
                        "username": "Dab07",
                        "content": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int i = 0;\\n        int j = nums.length - 1;\\n\\n        int b = 0;\\n        for (int k = 1; k < nums.length; ++k) {\\n            if (nums[k - 1] > nums[k]) {\\n                b = k;\\n                break;\\n            }\\n        }\\n\\n\\n        while (i <= j) {\\n            int mid = i + (j - i) / 2;\\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n            if (mid <= b) {\\n                if (nums[i] <= target && nums[mid] <= target) {\\n                    j = mid - 1;\\n                } else {\\n                    i = mid + 1;\\n                }\\n            } else {\\n                if (nums[j] >= target && nums[mid] <= target) {\\n                    i = mid + 1;\\n                } else {\\n                    j = mid - 1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n> 255 / 280 testcases passed\\nMy code if failing at this testcase\\n\\n` nums = [1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]` \\n`target = 2`\\n\\n<h1>Can anyone help me out where I am doing mistake?</h1>\\n"
                    },
                    {
                        "username": "Ezaidi",
                        "content": "Sorting nums[] and then simply applying binary search beats 83.3% in runtime,though the space complexity is bad. Any suggestions or reasons ? "
                    },
                    {
                        "username": "ayush_aicoder",
                        "content": "Same Code worked in both the rotated search questions I had used Binary Search Approach"
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "what is the error in my code ? it is failing edge case of  1,0,1,1,1\\n\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length-1;\\n\\n        while(low<high){\\n            int mid = (low + high)/2;\\n\\n            if(nums[mid] == target){\\n                return true;\\n            }\\n\\n            if(nums[low]== nums[mid] && nums[mid] == nums[high]){\\n                low++;\\n                high--;\\n               \\n            }\\n\\n            if(nums[low] <= nums[mid]){\\n                if(nums[low] <= target && target < nums[mid]){\\n                    high = mid -1;\\n                }\\n                else{\\n                    low = mid +1;\\n                }\\n            }\\n            else{\\n                if(nums[mid] <= target && target < nums[high]){\\n                    low = mid +1;\\n                }\\n                else{\\n                    high = mid -1;\\n                }\\n            }\\n\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@anshgandhi21](/anshgandhi21) No worries at all.  "
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "[@andykimchris](/andykimchris)  Thank you ! helped a lot"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Here\\'s your problem man\\nwhile(low<high)\\nIt should be while(low<=high)\\nYou\\'re not giving your algorithm the chance to check the mid if low and right are the same. \\n\\nThen after that check at mid == target is false break out of the loop\\nif (low == high) {\\n            break;\\n        }"
                    },
                    {
                        "username": "bborcic",
                        "content": "It\\'s a bad taste joke to emphasize <b>rotated</b> and insist on its <b>guarantee</b> when rotation is defined in such a way that the absence of rotation counts as a rotation and some test case exploits it. It\\'s even worse when the array size is allowed to be such that a meaningful rotation can\\'t even exist."
                    },
                    {
                        "username": "prixxx",
                        "content": "needs tighter constraints and better testcases , a simple sort and scan works."
                    },
                    {
                        "username": "andykimchris",
                        "content": "But can you solve within the constraints? That\\'s what makes it interesting. "
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution {\\n    public boolean search(int[] nums, int target) {\\n        // ====== Approach 1 ===========\\n        // Linear search time complexity O(n)\\n\\n    //     for(int i=0;i<nums.length;i++){\\n    //         if(nums[i]==target){\\n    //             return true;\\n    //         }\\n    //     }\\n    // return false;\\n    // }\\n\\n\\n\\n\\n    // ======== Applying Binary Search ===========\\n    // ================Time Complexity O(log n)=======\\n    int low=0;\\n    int high=nums.length-1;\\n    while(low<=high){\\n        int mid=(low+high)/2;\\n        // If target is at middle index\\n          if(nums[mid]==target){\\n            return true;\\n        }\\n \\n         if (nums[low] == nums[mid] && nums[mid] == nums[high]) {\\n                low = low + 1;\\n                high = high - 1;\\n                continue;\\n            }\\n      \\n        if(nums[low]<=nums[mid]){\\n            // This means the left part is sorted \\n            \\n            //Here there are two cases possible \\n                // 1.The target is in sorted part \\n                // 2.The target is not in sorted part\\n\\n\\n                //This means the target is in sorted part\\n                if(target<=nums[mid] && target>=nums[low]) {\\n                    high=mid-1;\\n                }\\n                else{\\n                    low=mid+1;\\n                }\\n        }\\n        else{\\n            // nums[high]>=nums[mid]\\n            // This means the right part is sorted \\n             //Here there are two cases possible \\n                // 1.The target is in sorted part \\n                // 2.The target is not in sorted part\\n\\n\\n                //This means the target is in sorted part\\n                if(target>=nums[mid] && target<=nums[high]) {\\n                   low=mid+1;\\n                }\\n                else{\\n                    high=mid-1;\\n                }\\n        }\\n\\n\\n\\n    }\\n    return false;\\n    }\\n}\\n\\n\\nJava Solution with explaination \\n"
                    },
                    {
                        "username": "priestess_of_light",
                        "content": "Seems like in practice for this problem simple linear search gives better results than binary search. The worst case complexity is O(n) still. Linear search beats 100% in C++, about 94 in python3, about 87 in python. No built-in functions, just a cycle"
                    }
                ]
            },
            {
                "id": 2047151,
                "content": [
                    {
                        "username": "gqian3",
                        "content": "What\\'s the point of this problem if one simple for loop (worst case: O(n)) can solve it with better performance/space than most of the fancy alg?"
                    },
                    {
                        "username": "whisly",
                        "content": "it says \"If target is found in the array return its index, otherwise, return -1.\"\\n\\nHowever, the solution and the test cases just return True or False"
                    },
                    {
                        "username": "Dab07",
                        "content": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int i = 0;\\n        int j = nums.length - 1;\\n\\n        int b = 0;\\n        for (int k = 1; k < nums.length; ++k) {\\n            if (nums[k - 1] > nums[k]) {\\n                b = k;\\n                break;\\n            }\\n        }\\n\\n\\n        while (i <= j) {\\n            int mid = i + (j - i) / 2;\\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n            if (mid <= b) {\\n                if (nums[i] <= target && nums[mid] <= target) {\\n                    j = mid - 1;\\n                } else {\\n                    i = mid + 1;\\n                }\\n            } else {\\n                if (nums[j] >= target && nums[mid] <= target) {\\n                    i = mid + 1;\\n                } else {\\n                    j = mid - 1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n> 255 / 280 testcases passed\\nMy code if failing at this testcase\\n\\n` nums = [1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]` \\n`target = 2`\\n\\n<h1>Can anyone help me out where I am doing mistake?</h1>\\n"
                    },
                    {
                        "username": "Ezaidi",
                        "content": "Sorting nums[] and then simply applying binary search beats 83.3% in runtime,though the space complexity is bad. Any suggestions or reasons ? "
                    },
                    {
                        "username": "ayush_aicoder",
                        "content": "Same Code worked in both the rotated search questions I had used Binary Search Approach"
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "what is the error in my code ? it is failing edge case of  1,0,1,1,1\\n\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length-1;\\n\\n        while(low<high){\\n            int mid = (low + high)/2;\\n\\n            if(nums[mid] == target){\\n                return true;\\n            }\\n\\n            if(nums[low]== nums[mid] && nums[mid] == nums[high]){\\n                low++;\\n                high--;\\n               \\n            }\\n\\n            if(nums[low] <= nums[mid]){\\n                if(nums[low] <= target && target < nums[mid]){\\n                    high = mid -1;\\n                }\\n                else{\\n                    low = mid +1;\\n                }\\n            }\\n            else{\\n                if(nums[mid] <= target && target < nums[high]){\\n                    low = mid +1;\\n                }\\n                else{\\n                    high = mid -1;\\n                }\\n            }\\n\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@anshgandhi21](/anshgandhi21) No worries at all.  "
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "[@andykimchris](/andykimchris)  Thank you ! helped a lot"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Here\\'s your problem man\\nwhile(low<high)\\nIt should be while(low<=high)\\nYou\\'re not giving your algorithm the chance to check the mid if low and right are the same. \\n\\nThen after that check at mid == target is false break out of the loop\\nif (low == high) {\\n            break;\\n        }"
                    },
                    {
                        "username": "bborcic",
                        "content": "It\\'s a bad taste joke to emphasize <b>rotated</b> and insist on its <b>guarantee</b> when rotation is defined in such a way that the absence of rotation counts as a rotation and some test case exploits it. It\\'s even worse when the array size is allowed to be such that a meaningful rotation can\\'t even exist."
                    },
                    {
                        "username": "prixxx",
                        "content": "needs tighter constraints and better testcases , a simple sort and scan works."
                    },
                    {
                        "username": "andykimchris",
                        "content": "But can you solve within the constraints? That\\'s what makes it interesting. "
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution {\\n    public boolean search(int[] nums, int target) {\\n        // ====== Approach 1 ===========\\n        // Linear search time complexity O(n)\\n\\n    //     for(int i=0;i<nums.length;i++){\\n    //         if(nums[i]==target){\\n    //             return true;\\n    //         }\\n    //     }\\n    // return false;\\n    // }\\n\\n\\n\\n\\n    // ======== Applying Binary Search ===========\\n    // ================Time Complexity O(log n)=======\\n    int low=0;\\n    int high=nums.length-1;\\n    while(low<=high){\\n        int mid=(low+high)/2;\\n        // If target is at middle index\\n          if(nums[mid]==target){\\n            return true;\\n        }\\n \\n         if (nums[low] == nums[mid] && nums[mid] == nums[high]) {\\n                low = low + 1;\\n                high = high - 1;\\n                continue;\\n            }\\n      \\n        if(nums[low]<=nums[mid]){\\n            // This means the left part is sorted \\n            \\n            //Here there are two cases possible \\n                // 1.The target is in sorted part \\n                // 2.The target is not in sorted part\\n\\n\\n                //This means the target is in sorted part\\n                if(target<=nums[mid] && target>=nums[low]) {\\n                    high=mid-1;\\n                }\\n                else{\\n                    low=mid+1;\\n                }\\n        }\\n        else{\\n            // nums[high]>=nums[mid]\\n            // This means the right part is sorted \\n             //Here there are two cases possible \\n                // 1.The target is in sorted part \\n                // 2.The target is not in sorted part\\n\\n\\n                //This means the target is in sorted part\\n                if(target>=nums[mid] && target<=nums[high]) {\\n                   low=mid+1;\\n                }\\n                else{\\n                    high=mid-1;\\n                }\\n        }\\n\\n\\n\\n    }\\n    return false;\\n    }\\n}\\n\\n\\nJava Solution with explaination \\n"
                    },
                    {
                        "username": "priestess_of_light",
                        "content": "Seems like in practice for this problem simple linear search gives better results than binary search. The worst case complexity is O(n) still. Linear search beats 100% in C++, about 94 in python3, about 87 in python. No built-in functions, just a cycle"
                    }
                ]
            },
            {
                "id": 2046720,
                "content": [
                    {
                        "username": "gqian3",
                        "content": "What\\'s the point of this problem if one simple for loop (worst case: O(n)) can solve it with better performance/space than most of the fancy alg?"
                    },
                    {
                        "username": "whisly",
                        "content": "it says \"If target is found in the array return its index, otherwise, return -1.\"\\n\\nHowever, the solution and the test cases just return True or False"
                    },
                    {
                        "username": "Dab07",
                        "content": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int i = 0;\\n        int j = nums.length - 1;\\n\\n        int b = 0;\\n        for (int k = 1; k < nums.length; ++k) {\\n            if (nums[k - 1] > nums[k]) {\\n                b = k;\\n                break;\\n            }\\n        }\\n\\n\\n        while (i <= j) {\\n            int mid = i + (j - i) / 2;\\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n            if (mid <= b) {\\n                if (nums[i] <= target && nums[mid] <= target) {\\n                    j = mid - 1;\\n                } else {\\n                    i = mid + 1;\\n                }\\n            } else {\\n                if (nums[j] >= target && nums[mid] <= target) {\\n                    i = mid + 1;\\n                } else {\\n                    j = mid - 1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n> 255 / 280 testcases passed\\nMy code if failing at this testcase\\n\\n` nums = [1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]` \\n`target = 2`\\n\\n<h1>Can anyone help me out where I am doing mistake?</h1>\\n"
                    },
                    {
                        "username": "Ezaidi",
                        "content": "Sorting nums[] and then simply applying binary search beats 83.3% in runtime,though the space complexity is bad. Any suggestions or reasons ? "
                    },
                    {
                        "username": "ayush_aicoder",
                        "content": "Same Code worked in both the rotated search questions I had used Binary Search Approach"
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "what is the error in my code ? it is failing edge case of  1,0,1,1,1\\n\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length-1;\\n\\n        while(low<high){\\n            int mid = (low + high)/2;\\n\\n            if(nums[mid] == target){\\n                return true;\\n            }\\n\\n            if(nums[low]== nums[mid] && nums[mid] == nums[high]){\\n                low++;\\n                high--;\\n               \\n            }\\n\\n            if(nums[low] <= nums[mid]){\\n                if(nums[low] <= target && target < nums[mid]){\\n                    high = mid -1;\\n                }\\n                else{\\n                    low = mid +1;\\n                }\\n            }\\n            else{\\n                if(nums[mid] <= target && target < nums[high]){\\n                    low = mid +1;\\n                }\\n                else{\\n                    high = mid -1;\\n                }\\n            }\\n\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@anshgandhi21](/anshgandhi21) No worries at all.  "
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "[@andykimchris](/andykimchris)  Thank you ! helped a lot"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Here\\'s your problem man\\nwhile(low<high)\\nIt should be while(low<=high)\\nYou\\'re not giving your algorithm the chance to check the mid if low and right are the same. \\n\\nThen after that check at mid == target is false break out of the loop\\nif (low == high) {\\n            break;\\n        }"
                    },
                    {
                        "username": "bborcic",
                        "content": "It\\'s a bad taste joke to emphasize <b>rotated</b> and insist on its <b>guarantee</b> when rotation is defined in such a way that the absence of rotation counts as a rotation and some test case exploits it. It\\'s even worse when the array size is allowed to be such that a meaningful rotation can\\'t even exist."
                    },
                    {
                        "username": "prixxx",
                        "content": "needs tighter constraints and better testcases , a simple sort and scan works."
                    },
                    {
                        "username": "andykimchris",
                        "content": "But can you solve within the constraints? That\\'s what makes it interesting. "
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution {\\n    public boolean search(int[] nums, int target) {\\n        // ====== Approach 1 ===========\\n        // Linear search time complexity O(n)\\n\\n    //     for(int i=0;i<nums.length;i++){\\n    //         if(nums[i]==target){\\n    //             return true;\\n    //         }\\n    //     }\\n    // return false;\\n    // }\\n\\n\\n\\n\\n    // ======== Applying Binary Search ===========\\n    // ================Time Complexity O(log n)=======\\n    int low=0;\\n    int high=nums.length-1;\\n    while(low<=high){\\n        int mid=(low+high)/2;\\n        // If target is at middle index\\n          if(nums[mid]==target){\\n            return true;\\n        }\\n \\n         if (nums[low] == nums[mid] && nums[mid] == nums[high]) {\\n                low = low + 1;\\n                high = high - 1;\\n                continue;\\n            }\\n      \\n        if(nums[low]<=nums[mid]){\\n            // This means the left part is sorted \\n            \\n            //Here there are two cases possible \\n                // 1.The target is in sorted part \\n                // 2.The target is not in sorted part\\n\\n\\n                //This means the target is in sorted part\\n                if(target<=nums[mid] && target>=nums[low]) {\\n                    high=mid-1;\\n                }\\n                else{\\n                    low=mid+1;\\n                }\\n        }\\n        else{\\n            // nums[high]>=nums[mid]\\n            // This means the right part is sorted \\n             //Here there are two cases possible \\n                // 1.The target is in sorted part \\n                // 2.The target is not in sorted part\\n\\n\\n                //This means the target is in sorted part\\n                if(target>=nums[mid] && target<=nums[high]) {\\n                   low=mid+1;\\n                }\\n                else{\\n                    high=mid-1;\\n                }\\n        }\\n\\n\\n\\n    }\\n    return false;\\n    }\\n}\\n\\n\\nJava Solution with explaination \\n"
                    },
                    {
                        "username": "priestess_of_light",
                        "content": "Seems like in practice for this problem simple linear search gives better results than binary search. The worst case complexity is O(n) still. Linear search beats 100% in C++, about 94 in python3, about 87 in python. No built-in functions, just a cycle"
                    }
                ]
            },
            {
                "id": 2044496,
                "content": [
                    {
                        "username": "gqian3",
                        "content": "What\\'s the point of this problem if one simple for loop (worst case: O(n)) can solve it with better performance/space than most of the fancy alg?"
                    },
                    {
                        "username": "whisly",
                        "content": "it says \"If target is found in the array return its index, otherwise, return -1.\"\\n\\nHowever, the solution and the test cases just return True or False"
                    },
                    {
                        "username": "Dab07",
                        "content": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int i = 0;\\n        int j = nums.length - 1;\\n\\n        int b = 0;\\n        for (int k = 1; k < nums.length; ++k) {\\n            if (nums[k - 1] > nums[k]) {\\n                b = k;\\n                break;\\n            }\\n        }\\n\\n\\n        while (i <= j) {\\n            int mid = i + (j - i) / 2;\\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n            if (mid <= b) {\\n                if (nums[i] <= target && nums[mid] <= target) {\\n                    j = mid - 1;\\n                } else {\\n                    i = mid + 1;\\n                }\\n            } else {\\n                if (nums[j] >= target && nums[mid] <= target) {\\n                    i = mid + 1;\\n                } else {\\n                    j = mid - 1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n> 255 / 280 testcases passed\\nMy code if failing at this testcase\\n\\n` nums = [1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]` \\n`target = 2`\\n\\n<h1>Can anyone help me out where I am doing mistake?</h1>\\n"
                    },
                    {
                        "username": "Ezaidi",
                        "content": "Sorting nums[] and then simply applying binary search beats 83.3% in runtime,though the space complexity is bad. Any suggestions or reasons ? "
                    },
                    {
                        "username": "ayush_aicoder",
                        "content": "Same Code worked in both the rotated search questions I had used Binary Search Approach"
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "what is the error in my code ? it is failing edge case of  1,0,1,1,1\\n\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length-1;\\n\\n        while(low<high){\\n            int mid = (low + high)/2;\\n\\n            if(nums[mid] == target){\\n                return true;\\n            }\\n\\n            if(nums[low]== nums[mid] && nums[mid] == nums[high]){\\n                low++;\\n                high--;\\n               \\n            }\\n\\n            if(nums[low] <= nums[mid]){\\n                if(nums[low] <= target && target < nums[mid]){\\n                    high = mid -1;\\n                }\\n                else{\\n                    low = mid +1;\\n                }\\n            }\\n            else{\\n                if(nums[mid] <= target && target < nums[high]){\\n                    low = mid +1;\\n                }\\n                else{\\n                    high = mid -1;\\n                }\\n            }\\n\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@anshgandhi21](/anshgandhi21) No worries at all.  "
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "[@andykimchris](/andykimchris)  Thank you ! helped a lot"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Here\\'s your problem man\\nwhile(low<high)\\nIt should be while(low<=high)\\nYou\\'re not giving your algorithm the chance to check the mid if low and right are the same. \\n\\nThen after that check at mid == target is false break out of the loop\\nif (low == high) {\\n            break;\\n        }"
                    },
                    {
                        "username": "bborcic",
                        "content": "It\\'s a bad taste joke to emphasize <b>rotated</b> and insist on its <b>guarantee</b> when rotation is defined in such a way that the absence of rotation counts as a rotation and some test case exploits it. It\\'s even worse when the array size is allowed to be such that a meaningful rotation can\\'t even exist."
                    },
                    {
                        "username": "prixxx",
                        "content": "needs tighter constraints and better testcases , a simple sort and scan works."
                    },
                    {
                        "username": "andykimchris",
                        "content": "But can you solve within the constraints? That\\'s what makes it interesting. "
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution {\\n    public boolean search(int[] nums, int target) {\\n        // ====== Approach 1 ===========\\n        // Linear search time complexity O(n)\\n\\n    //     for(int i=0;i<nums.length;i++){\\n    //         if(nums[i]==target){\\n    //             return true;\\n    //         }\\n    //     }\\n    // return false;\\n    // }\\n\\n\\n\\n\\n    // ======== Applying Binary Search ===========\\n    // ================Time Complexity O(log n)=======\\n    int low=0;\\n    int high=nums.length-1;\\n    while(low<=high){\\n        int mid=(low+high)/2;\\n        // If target is at middle index\\n          if(nums[mid]==target){\\n            return true;\\n        }\\n \\n         if (nums[low] == nums[mid] && nums[mid] == nums[high]) {\\n                low = low + 1;\\n                high = high - 1;\\n                continue;\\n            }\\n      \\n        if(nums[low]<=nums[mid]){\\n            // This means the left part is sorted \\n            \\n            //Here there are two cases possible \\n                // 1.The target is in sorted part \\n                // 2.The target is not in sorted part\\n\\n\\n                //This means the target is in sorted part\\n                if(target<=nums[mid] && target>=nums[low]) {\\n                    high=mid-1;\\n                }\\n                else{\\n                    low=mid+1;\\n                }\\n        }\\n        else{\\n            // nums[high]>=nums[mid]\\n            // This means the right part is sorted \\n             //Here there are two cases possible \\n                // 1.The target is in sorted part \\n                // 2.The target is not in sorted part\\n\\n\\n                //This means the target is in sorted part\\n                if(target>=nums[mid] && target<=nums[high]) {\\n                   low=mid+1;\\n                }\\n                else{\\n                    high=mid-1;\\n                }\\n        }\\n\\n\\n\\n    }\\n    return false;\\n    }\\n}\\n\\n\\nJava Solution with explaination \\n"
                    },
                    {
                        "username": "priestess_of_light",
                        "content": "Seems like in practice for this problem simple linear search gives better results than binary search. The worst case complexity is O(n) still. Linear search beats 100% in C++, about 94 in python3, about 87 in python. No built-in functions, just a cycle"
                    }
                ]
            },
            {
                "id": 2044445,
                "content": [
                    {
                        "username": "gqian3",
                        "content": "What\\'s the point of this problem if one simple for loop (worst case: O(n)) can solve it with better performance/space than most of the fancy alg?"
                    },
                    {
                        "username": "whisly",
                        "content": "it says \"If target is found in the array return its index, otherwise, return -1.\"\\n\\nHowever, the solution and the test cases just return True or False"
                    },
                    {
                        "username": "Dab07",
                        "content": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int i = 0;\\n        int j = nums.length - 1;\\n\\n        int b = 0;\\n        for (int k = 1; k < nums.length; ++k) {\\n            if (nums[k - 1] > nums[k]) {\\n                b = k;\\n                break;\\n            }\\n        }\\n\\n\\n        while (i <= j) {\\n            int mid = i + (j - i) / 2;\\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n            if (mid <= b) {\\n                if (nums[i] <= target && nums[mid] <= target) {\\n                    j = mid - 1;\\n                } else {\\n                    i = mid + 1;\\n                }\\n            } else {\\n                if (nums[j] >= target && nums[mid] <= target) {\\n                    i = mid + 1;\\n                } else {\\n                    j = mid - 1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n> 255 / 280 testcases passed\\nMy code if failing at this testcase\\n\\n` nums = [1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]` \\n`target = 2`\\n\\n<h1>Can anyone help me out where I am doing mistake?</h1>\\n"
                    },
                    {
                        "username": "Ezaidi",
                        "content": "Sorting nums[] and then simply applying binary search beats 83.3% in runtime,though the space complexity is bad. Any suggestions or reasons ? "
                    },
                    {
                        "username": "ayush_aicoder",
                        "content": "Same Code worked in both the rotated search questions I had used Binary Search Approach"
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "what is the error in my code ? it is failing edge case of  1,0,1,1,1\\n\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length-1;\\n\\n        while(low<high){\\n            int mid = (low + high)/2;\\n\\n            if(nums[mid] == target){\\n                return true;\\n            }\\n\\n            if(nums[low]== nums[mid] && nums[mid] == nums[high]){\\n                low++;\\n                high--;\\n               \\n            }\\n\\n            if(nums[low] <= nums[mid]){\\n                if(nums[low] <= target && target < nums[mid]){\\n                    high = mid -1;\\n                }\\n                else{\\n                    low = mid +1;\\n                }\\n            }\\n            else{\\n                if(nums[mid] <= target && target < nums[high]){\\n                    low = mid +1;\\n                }\\n                else{\\n                    high = mid -1;\\n                }\\n            }\\n\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@anshgandhi21](/anshgandhi21) No worries at all.  "
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "[@andykimchris](/andykimchris)  Thank you ! helped a lot"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Here\\'s your problem man\\nwhile(low<high)\\nIt should be while(low<=high)\\nYou\\'re not giving your algorithm the chance to check the mid if low and right are the same. \\n\\nThen after that check at mid == target is false break out of the loop\\nif (low == high) {\\n            break;\\n        }"
                    },
                    {
                        "username": "bborcic",
                        "content": "It\\'s a bad taste joke to emphasize <b>rotated</b> and insist on its <b>guarantee</b> when rotation is defined in such a way that the absence of rotation counts as a rotation and some test case exploits it. It\\'s even worse when the array size is allowed to be such that a meaningful rotation can\\'t even exist."
                    },
                    {
                        "username": "prixxx",
                        "content": "needs tighter constraints and better testcases , a simple sort and scan works."
                    },
                    {
                        "username": "andykimchris",
                        "content": "But can you solve within the constraints? That\\'s what makes it interesting. "
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution {\\n    public boolean search(int[] nums, int target) {\\n        // ====== Approach 1 ===========\\n        // Linear search time complexity O(n)\\n\\n    //     for(int i=0;i<nums.length;i++){\\n    //         if(nums[i]==target){\\n    //             return true;\\n    //         }\\n    //     }\\n    // return false;\\n    // }\\n\\n\\n\\n\\n    // ======== Applying Binary Search ===========\\n    // ================Time Complexity O(log n)=======\\n    int low=0;\\n    int high=nums.length-1;\\n    while(low<=high){\\n        int mid=(low+high)/2;\\n        // If target is at middle index\\n          if(nums[mid]==target){\\n            return true;\\n        }\\n \\n         if (nums[low] == nums[mid] && nums[mid] == nums[high]) {\\n                low = low + 1;\\n                high = high - 1;\\n                continue;\\n            }\\n      \\n        if(nums[low]<=nums[mid]){\\n            // This means the left part is sorted \\n            \\n            //Here there are two cases possible \\n                // 1.The target is in sorted part \\n                // 2.The target is not in sorted part\\n\\n\\n                //This means the target is in sorted part\\n                if(target<=nums[mid] && target>=nums[low]) {\\n                    high=mid-1;\\n                }\\n                else{\\n                    low=mid+1;\\n                }\\n        }\\n        else{\\n            // nums[high]>=nums[mid]\\n            // This means the right part is sorted \\n             //Here there are two cases possible \\n                // 1.The target is in sorted part \\n                // 2.The target is not in sorted part\\n\\n\\n                //This means the target is in sorted part\\n                if(target>=nums[mid] && target<=nums[high]) {\\n                   low=mid+1;\\n                }\\n                else{\\n                    high=mid-1;\\n                }\\n        }\\n\\n\\n\\n    }\\n    return false;\\n    }\\n}\\n\\n\\nJava Solution with explaination \\n"
                    },
                    {
                        "username": "priestess_of_light",
                        "content": "Seems like in practice for this problem simple linear search gives better results than binary search. The worst case complexity is O(n) still. Linear search beats 100% in C++, about 94 in python3, about 87 in python. No built-in functions, just a cycle"
                    }
                ]
            },
            {
                "id": 2034901,
                "content": [
                    {
                        "username": "gqian3",
                        "content": "What\\'s the point of this problem if one simple for loop (worst case: O(n)) can solve it with better performance/space than most of the fancy alg?"
                    },
                    {
                        "username": "whisly",
                        "content": "it says \"If target is found in the array return its index, otherwise, return -1.\"\\n\\nHowever, the solution and the test cases just return True or False"
                    },
                    {
                        "username": "Dab07",
                        "content": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int i = 0;\\n        int j = nums.length - 1;\\n\\n        int b = 0;\\n        for (int k = 1; k < nums.length; ++k) {\\n            if (nums[k - 1] > nums[k]) {\\n                b = k;\\n                break;\\n            }\\n        }\\n\\n\\n        while (i <= j) {\\n            int mid = i + (j - i) / 2;\\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n            if (mid <= b) {\\n                if (nums[i] <= target && nums[mid] <= target) {\\n                    j = mid - 1;\\n                } else {\\n                    i = mid + 1;\\n                }\\n            } else {\\n                if (nums[j] >= target && nums[mid] <= target) {\\n                    i = mid + 1;\\n                } else {\\n                    j = mid - 1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n> 255 / 280 testcases passed\\nMy code if failing at this testcase\\n\\n` nums = [1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]` \\n`target = 2`\\n\\n<h1>Can anyone help me out where I am doing mistake?</h1>\\n"
                    },
                    {
                        "username": "Ezaidi",
                        "content": "Sorting nums[] and then simply applying binary search beats 83.3% in runtime,though the space complexity is bad. Any suggestions or reasons ? "
                    },
                    {
                        "username": "ayush_aicoder",
                        "content": "Same Code worked in both the rotated search questions I had used Binary Search Approach"
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "what is the error in my code ? it is failing edge case of  1,0,1,1,1\\n\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length-1;\\n\\n        while(low<high){\\n            int mid = (low + high)/2;\\n\\n            if(nums[mid] == target){\\n                return true;\\n            }\\n\\n            if(nums[low]== nums[mid] && nums[mid] == nums[high]){\\n                low++;\\n                high--;\\n               \\n            }\\n\\n            if(nums[low] <= nums[mid]){\\n                if(nums[low] <= target && target < nums[mid]){\\n                    high = mid -1;\\n                }\\n                else{\\n                    low = mid +1;\\n                }\\n            }\\n            else{\\n                if(nums[mid] <= target && target < nums[high]){\\n                    low = mid +1;\\n                }\\n                else{\\n                    high = mid -1;\\n                }\\n            }\\n\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@anshgandhi21](/anshgandhi21) No worries at all.  "
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "[@andykimchris](/andykimchris)  Thank you ! helped a lot"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Here\\'s your problem man\\nwhile(low<high)\\nIt should be while(low<=high)\\nYou\\'re not giving your algorithm the chance to check the mid if low and right are the same. \\n\\nThen after that check at mid == target is false break out of the loop\\nif (low == high) {\\n            break;\\n        }"
                    },
                    {
                        "username": "bborcic",
                        "content": "It\\'s a bad taste joke to emphasize <b>rotated</b> and insist on its <b>guarantee</b> when rotation is defined in such a way that the absence of rotation counts as a rotation and some test case exploits it. It\\'s even worse when the array size is allowed to be such that a meaningful rotation can\\'t even exist."
                    },
                    {
                        "username": "prixxx",
                        "content": "needs tighter constraints and better testcases , a simple sort and scan works."
                    },
                    {
                        "username": "andykimchris",
                        "content": "But can you solve within the constraints? That\\'s what makes it interesting. "
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution {\\n    public boolean search(int[] nums, int target) {\\n        // ====== Approach 1 ===========\\n        // Linear search time complexity O(n)\\n\\n    //     for(int i=0;i<nums.length;i++){\\n    //         if(nums[i]==target){\\n    //             return true;\\n    //         }\\n    //     }\\n    // return false;\\n    // }\\n\\n\\n\\n\\n    // ======== Applying Binary Search ===========\\n    // ================Time Complexity O(log n)=======\\n    int low=0;\\n    int high=nums.length-1;\\n    while(low<=high){\\n        int mid=(low+high)/2;\\n        // If target is at middle index\\n          if(nums[mid]==target){\\n            return true;\\n        }\\n \\n         if (nums[low] == nums[mid] && nums[mid] == nums[high]) {\\n                low = low + 1;\\n                high = high - 1;\\n                continue;\\n            }\\n      \\n        if(nums[low]<=nums[mid]){\\n            // This means the left part is sorted \\n            \\n            //Here there are two cases possible \\n                // 1.The target is in sorted part \\n                // 2.The target is not in sorted part\\n\\n\\n                //This means the target is in sorted part\\n                if(target<=nums[mid] && target>=nums[low]) {\\n                    high=mid-1;\\n                }\\n                else{\\n                    low=mid+1;\\n                }\\n        }\\n        else{\\n            // nums[high]>=nums[mid]\\n            // This means the right part is sorted \\n             //Here there are two cases possible \\n                // 1.The target is in sorted part \\n                // 2.The target is not in sorted part\\n\\n\\n                //This means the target is in sorted part\\n                if(target>=nums[mid] && target<=nums[high]) {\\n                   low=mid+1;\\n                }\\n                else{\\n                    high=mid-1;\\n                }\\n        }\\n\\n\\n\\n    }\\n    return false;\\n    }\\n}\\n\\n\\nJava Solution with explaination \\n"
                    },
                    {
                        "username": "priestess_of_light",
                        "content": "Seems like in practice for this problem simple linear search gives better results than binary search. The worst case complexity is O(n) still. Linear search beats 100% in C++, about 94 in python3, about 87 in python. No built-in functions, just a cycle"
                    }
                ]
            },
            {
                "id": 2019348,
                "content": [
                    {
                        "username": "gqian3",
                        "content": "What\\'s the point of this problem if one simple for loop (worst case: O(n)) can solve it with better performance/space than most of the fancy alg?"
                    },
                    {
                        "username": "whisly",
                        "content": "it says \"If target is found in the array return its index, otherwise, return -1.\"\\n\\nHowever, the solution and the test cases just return True or False"
                    },
                    {
                        "username": "Dab07",
                        "content": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int i = 0;\\n        int j = nums.length - 1;\\n\\n        int b = 0;\\n        for (int k = 1; k < nums.length; ++k) {\\n            if (nums[k - 1] > nums[k]) {\\n                b = k;\\n                break;\\n            }\\n        }\\n\\n\\n        while (i <= j) {\\n            int mid = i + (j - i) / 2;\\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n            if (mid <= b) {\\n                if (nums[i] <= target && nums[mid] <= target) {\\n                    j = mid - 1;\\n                } else {\\n                    i = mid + 1;\\n                }\\n            } else {\\n                if (nums[j] >= target && nums[mid] <= target) {\\n                    i = mid + 1;\\n                } else {\\n                    j = mid - 1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n> 255 / 280 testcases passed\\nMy code if failing at this testcase\\n\\n` nums = [1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]` \\n`target = 2`\\n\\n<h1>Can anyone help me out where I am doing mistake?</h1>\\n"
                    },
                    {
                        "username": "Ezaidi",
                        "content": "Sorting nums[] and then simply applying binary search beats 83.3% in runtime,though the space complexity is bad. Any suggestions or reasons ? "
                    },
                    {
                        "username": "ayush_aicoder",
                        "content": "Same Code worked in both the rotated search questions I had used Binary Search Approach"
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "what is the error in my code ? it is failing edge case of  1,0,1,1,1\\n\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length-1;\\n\\n        while(low<high){\\n            int mid = (low + high)/2;\\n\\n            if(nums[mid] == target){\\n                return true;\\n            }\\n\\n            if(nums[low]== nums[mid] && nums[mid] == nums[high]){\\n                low++;\\n                high--;\\n               \\n            }\\n\\n            if(nums[low] <= nums[mid]){\\n                if(nums[low] <= target && target < nums[mid]){\\n                    high = mid -1;\\n                }\\n                else{\\n                    low = mid +1;\\n                }\\n            }\\n            else{\\n                if(nums[mid] <= target && target < nums[high]){\\n                    low = mid +1;\\n                }\\n                else{\\n                    high = mid -1;\\n                }\\n            }\\n\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@anshgandhi21](/anshgandhi21) No worries at all.  "
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "[@andykimchris](/andykimchris)  Thank you ! helped a lot"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Here\\'s your problem man\\nwhile(low<high)\\nIt should be while(low<=high)\\nYou\\'re not giving your algorithm the chance to check the mid if low and right are the same. \\n\\nThen after that check at mid == target is false break out of the loop\\nif (low == high) {\\n            break;\\n        }"
                    },
                    {
                        "username": "bborcic",
                        "content": "It\\'s a bad taste joke to emphasize <b>rotated</b> and insist on its <b>guarantee</b> when rotation is defined in such a way that the absence of rotation counts as a rotation and some test case exploits it. It\\'s even worse when the array size is allowed to be such that a meaningful rotation can\\'t even exist."
                    },
                    {
                        "username": "prixxx",
                        "content": "needs tighter constraints and better testcases , a simple sort and scan works."
                    },
                    {
                        "username": "andykimchris",
                        "content": "But can you solve within the constraints? That\\'s what makes it interesting. "
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution {\\n    public boolean search(int[] nums, int target) {\\n        // ====== Approach 1 ===========\\n        // Linear search time complexity O(n)\\n\\n    //     for(int i=0;i<nums.length;i++){\\n    //         if(nums[i]==target){\\n    //             return true;\\n    //         }\\n    //     }\\n    // return false;\\n    // }\\n\\n\\n\\n\\n    // ======== Applying Binary Search ===========\\n    // ================Time Complexity O(log n)=======\\n    int low=0;\\n    int high=nums.length-1;\\n    while(low<=high){\\n        int mid=(low+high)/2;\\n        // If target is at middle index\\n          if(nums[mid]==target){\\n            return true;\\n        }\\n \\n         if (nums[low] == nums[mid] && nums[mid] == nums[high]) {\\n                low = low + 1;\\n                high = high - 1;\\n                continue;\\n            }\\n      \\n        if(nums[low]<=nums[mid]){\\n            // This means the left part is sorted \\n            \\n            //Here there are two cases possible \\n                // 1.The target is in sorted part \\n                // 2.The target is not in sorted part\\n\\n\\n                //This means the target is in sorted part\\n                if(target<=nums[mid] && target>=nums[low]) {\\n                    high=mid-1;\\n                }\\n                else{\\n                    low=mid+1;\\n                }\\n        }\\n        else{\\n            // nums[high]>=nums[mid]\\n            // This means the right part is sorted \\n             //Here there are two cases possible \\n                // 1.The target is in sorted part \\n                // 2.The target is not in sorted part\\n\\n\\n                //This means the target is in sorted part\\n                if(target>=nums[mid] && target<=nums[high]) {\\n                   low=mid+1;\\n                }\\n                else{\\n                    high=mid-1;\\n                }\\n        }\\n\\n\\n\\n    }\\n    return false;\\n    }\\n}\\n\\n\\nJava Solution with explaination \\n"
                    },
                    {
                        "username": "priestess_of_light",
                        "content": "Seems like in practice for this problem simple linear search gives better results than binary search. The worst case complexity is O(n) still. Linear search beats 100% in C++, about 94 in python3, about 87 in python. No built-in functions, just a cycle"
                    }
                ]
            },
            {
                "id": 2008747,
                "content": [
                    {
                        "username": "gqian3",
                        "content": "What\\'s the point of this problem if one simple for loop (worst case: O(n)) can solve it with better performance/space than most of the fancy alg?"
                    },
                    {
                        "username": "whisly",
                        "content": "it says \"If target is found in the array return its index, otherwise, return -1.\"\\n\\nHowever, the solution and the test cases just return True or False"
                    },
                    {
                        "username": "Dab07",
                        "content": "```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int i = 0;\\n        int j = nums.length - 1;\\n\\n        int b = 0;\\n        for (int k = 1; k < nums.length; ++k) {\\n            if (nums[k - 1] > nums[k]) {\\n                b = k;\\n                break;\\n            }\\n        }\\n\\n\\n        while (i <= j) {\\n            int mid = i + (j - i) / 2;\\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n            if (mid <= b) {\\n                if (nums[i] <= target && nums[mid] <= target) {\\n                    j = mid - 1;\\n                } else {\\n                    i = mid + 1;\\n                }\\n            } else {\\n                if (nums[j] >= target && nums[mid] <= target) {\\n                    i = mid + 1;\\n                } else {\\n                    j = mid - 1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n> 255 / 280 testcases passed\\nMy code if failing at this testcase\\n\\n` nums = [1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]` \\n`target = 2`\\n\\n<h1>Can anyone help me out where I am doing mistake?</h1>\\n"
                    },
                    {
                        "username": "Ezaidi",
                        "content": "Sorting nums[] and then simply applying binary search beats 83.3% in runtime,though the space complexity is bad. Any suggestions or reasons ? "
                    },
                    {
                        "username": "ayush_aicoder",
                        "content": "Same Code worked in both the rotated search questions I had used Binary Search Approach"
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "what is the error in my code ? it is failing edge case of  1,0,1,1,1\\n\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length-1;\\n\\n        while(low<high){\\n            int mid = (low + high)/2;\\n\\n            if(nums[mid] == target){\\n                return true;\\n            }\\n\\n            if(nums[low]== nums[mid] && nums[mid] == nums[high]){\\n                low++;\\n                high--;\\n               \\n            }\\n\\n            if(nums[low] <= nums[mid]){\\n                if(nums[low] <= target && target < nums[mid]){\\n                    high = mid -1;\\n                }\\n                else{\\n                    low = mid +1;\\n                }\\n            }\\n            else{\\n                if(nums[mid] <= target && target < nums[high]){\\n                    low = mid +1;\\n                }\\n                else{\\n                    high = mid -1;\\n                }\\n            }\\n\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@anshgandhi21](/anshgandhi21) No worries at all.  "
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "[@andykimchris](/andykimchris)  Thank you ! helped a lot"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Here\\'s your problem man\\nwhile(low<high)\\nIt should be while(low<=high)\\nYou\\'re not giving your algorithm the chance to check the mid if low and right are the same. \\n\\nThen after that check at mid == target is false break out of the loop\\nif (low == high) {\\n            break;\\n        }"
                    },
                    {
                        "username": "bborcic",
                        "content": "It\\'s a bad taste joke to emphasize <b>rotated</b> and insist on its <b>guarantee</b> when rotation is defined in such a way that the absence of rotation counts as a rotation and some test case exploits it. It\\'s even worse when the array size is allowed to be such that a meaningful rotation can\\'t even exist."
                    },
                    {
                        "username": "prixxx",
                        "content": "needs tighter constraints and better testcases , a simple sort and scan works."
                    },
                    {
                        "username": "andykimchris",
                        "content": "But can you solve within the constraints? That\\'s what makes it interesting. "
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution {\\n    public boolean search(int[] nums, int target) {\\n        // ====== Approach 1 ===========\\n        // Linear search time complexity O(n)\\n\\n    //     for(int i=0;i<nums.length;i++){\\n    //         if(nums[i]==target){\\n    //             return true;\\n    //         }\\n    //     }\\n    // return false;\\n    // }\\n\\n\\n\\n\\n    // ======== Applying Binary Search ===========\\n    // ================Time Complexity O(log n)=======\\n    int low=0;\\n    int high=nums.length-1;\\n    while(low<=high){\\n        int mid=(low+high)/2;\\n        // If target is at middle index\\n          if(nums[mid]==target){\\n            return true;\\n        }\\n \\n         if (nums[low] == nums[mid] && nums[mid] == nums[high]) {\\n                low = low + 1;\\n                high = high - 1;\\n                continue;\\n            }\\n      \\n        if(nums[low]<=nums[mid]){\\n            // This means the left part is sorted \\n            \\n            //Here there are two cases possible \\n                // 1.The target is in sorted part \\n                // 2.The target is not in sorted part\\n\\n\\n                //This means the target is in sorted part\\n                if(target<=nums[mid] && target>=nums[low]) {\\n                    high=mid-1;\\n                }\\n                else{\\n                    low=mid+1;\\n                }\\n        }\\n        else{\\n            // nums[high]>=nums[mid]\\n            // This means the right part is sorted \\n             //Here there are two cases possible \\n                // 1.The target is in sorted part \\n                // 2.The target is not in sorted part\\n\\n\\n                //This means the target is in sorted part\\n                if(target>=nums[mid] && target<=nums[high]) {\\n                   low=mid+1;\\n                }\\n                else{\\n                    high=mid-1;\\n                }\\n        }\\n\\n\\n\\n    }\\n    return false;\\n    }\\n}\\n\\n\\nJava Solution with explaination \\n"
                    },
                    {
                        "username": "priestess_of_light",
                        "content": "Seems like in practice for this problem simple linear search gives better results than binary search. The worst case complexity is O(n) still. Linear search beats 100% in C++, about 94 in python3, about 87 in python. No built-in functions, just a cycle"
                    }
                ]
            },
            {
                "id": 2008347,
                "content": [
                    {
                        "username": "QuarantinedSoul",
                        "content": "`Linear search FTW.`"
                    },
                    {
                        "username": "lethal-bot",
                        "content": "giving you a heads up  check your code for  `nums = [1,0,1,1,1]`  `target = 0`. "
                    },
                    {
                        "username": "gangadharkr27",
                        "content": "how to handle in case of dublicates"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Was trying to figure out a O[log(n)] solution and was troubled with some cases where the first and last numbers were equal.\n\nPeeked at the editorial and realized that O(n) solution is acceptable for the worst cases. I proceeded to delete the troubling equal numbers from the start, then applied binary search."
                    },
                    {
                        "username": "SG-C",
                        "content": "if you solved `Search in Rotated Sorted Array` then this is a Piece of cake."
                    },
                    {
                        "username": "SG-C",
                        "content": "[@dikshawali](/dikshawali) Basic concept is same."
                    },
                    {
                        "username": "dikshawali",
                        "content": "how that? prev solution isnt working for duplicates."
                    },
                    {
                        "username": "bagririshav01",
                        "content": "its very easy for an medium level question\\njust a linear search ans its the answer\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "If O(n) is the worst case runtime, why does this question exist? What part of programming knowledge is it testing?\nJust check if target exist in nums, there is no clever trick that still won't use O(n) runtime unless you're handling extremely large test cases. \nI just run a linear solution 100% memory 100% time.\nOr what am I missing here?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Question description says: You must decrease the overall operation steps as much as possible."
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "its not even worth it to do binary search , in real world scenario i\\'d just do linear search with these test cases.."
                    },
                    {
                        "username": "benhhack",
                        "content": "The specification stats that `nums` is guaranteed to be rotated at some pivot, however, test case 268 provides a `nums` array with no pivot."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Can we do this question by using an hashset . We will initialise an hashset then add all the elements into it and then we will check wether the hashset contains the element or not."
                    },
                    {
                        "username": "Srikanth_Sri",
                        "content": "we can do, but the time and space complexity will be O(n) \\nwhich is not acceptable in interviews, it would be brute force approch"
                    }
                ]
            },
            {
                "id": 2008226,
                "content": [
                    {
                        "username": "QuarantinedSoul",
                        "content": "`Linear search FTW.`"
                    },
                    {
                        "username": "lethal-bot",
                        "content": "giving you a heads up  check your code for  `nums = [1,0,1,1,1]`  `target = 0`. "
                    },
                    {
                        "username": "gangadharkr27",
                        "content": "how to handle in case of dublicates"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Was trying to figure out a O[log(n)] solution and was troubled with some cases where the first and last numbers were equal.\n\nPeeked at the editorial and realized that O(n) solution is acceptable for the worst cases. I proceeded to delete the troubling equal numbers from the start, then applied binary search."
                    },
                    {
                        "username": "SG-C",
                        "content": "if you solved `Search in Rotated Sorted Array` then this is a Piece of cake."
                    },
                    {
                        "username": "SG-C",
                        "content": "[@dikshawali](/dikshawali) Basic concept is same."
                    },
                    {
                        "username": "dikshawali",
                        "content": "how that? prev solution isnt working for duplicates."
                    },
                    {
                        "username": "bagririshav01",
                        "content": "its very easy for an medium level question\\njust a linear search ans its the answer\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "If O(n) is the worst case runtime, why does this question exist? What part of programming knowledge is it testing?\nJust check if target exist in nums, there is no clever trick that still won't use O(n) runtime unless you're handling extremely large test cases. \nI just run a linear solution 100% memory 100% time.\nOr what am I missing here?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Question description says: You must decrease the overall operation steps as much as possible."
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "its not even worth it to do binary search , in real world scenario i\\'d just do linear search with these test cases.."
                    },
                    {
                        "username": "benhhack",
                        "content": "The specification stats that `nums` is guaranteed to be rotated at some pivot, however, test case 268 provides a `nums` array with no pivot."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Can we do this question by using an hashset . We will initialise an hashset then add all the elements into it and then we will check wether the hashset contains the element or not."
                    },
                    {
                        "username": "Srikanth_Sri",
                        "content": "we can do, but the time and space complexity will be O(n) \\nwhich is not acceptable in interviews, it would be brute force approch"
                    }
                ]
            },
            {
                "id": 2008189,
                "content": [
                    {
                        "username": "QuarantinedSoul",
                        "content": "`Linear search FTW.`"
                    },
                    {
                        "username": "lethal-bot",
                        "content": "giving you a heads up  check your code for  `nums = [1,0,1,1,1]`  `target = 0`. "
                    },
                    {
                        "username": "gangadharkr27",
                        "content": "how to handle in case of dublicates"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Was trying to figure out a O[log(n)] solution and was troubled with some cases where the first and last numbers were equal.\n\nPeeked at the editorial and realized that O(n) solution is acceptable for the worst cases. I proceeded to delete the troubling equal numbers from the start, then applied binary search."
                    },
                    {
                        "username": "SG-C",
                        "content": "if you solved `Search in Rotated Sorted Array` then this is a Piece of cake."
                    },
                    {
                        "username": "SG-C",
                        "content": "[@dikshawali](/dikshawali) Basic concept is same."
                    },
                    {
                        "username": "dikshawali",
                        "content": "how that? prev solution isnt working for duplicates."
                    },
                    {
                        "username": "bagririshav01",
                        "content": "its very easy for an medium level question\\njust a linear search ans its the answer\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "If O(n) is the worst case runtime, why does this question exist? What part of programming knowledge is it testing?\nJust check if target exist in nums, there is no clever trick that still won't use O(n) runtime unless you're handling extremely large test cases. \nI just run a linear solution 100% memory 100% time.\nOr what am I missing here?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Question description says: You must decrease the overall operation steps as much as possible."
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "its not even worth it to do binary search , in real world scenario i\\'d just do linear search with these test cases.."
                    },
                    {
                        "username": "benhhack",
                        "content": "The specification stats that `nums` is guaranteed to be rotated at some pivot, however, test case 268 provides a `nums` array with no pivot."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Can we do this question by using an hashset . We will initialise an hashset then add all the elements into it and then we will check wether the hashset contains the element or not."
                    },
                    {
                        "username": "Srikanth_Sri",
                        "content": "we can do, but the time and space complexity will be O(n) \\nwhich is not acceptable in interviews, it would be brute force approch"
                    }
                ]
            },
            {
                "id": 2008135,
                "content": [
                    {
                        "username": "QuarantinedSoul",
                        "content": "`Linear search FTW.`"
                    },
                    {
                        "username": "lethal-bot",
                        "content": "giving you a heads up  check your code for  `nums = [1,0,1,1,1]`  `target = 0`. "
                    },
                    {
                        "username": "gangadharkr27",
                        "content": "how to handle in case of dublicates"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Was trying to figure out a O[log(n)] solution and was troubled with some cases where the first and last numbers were equal.\n\nPeeked at the editorial and realized that O(n) solution is acceptable for the worst cases. I proceeded to delete the troubling equal numbers from the start, then applied binary search."
                    },
                    {
                        "username": "SG-C",
                        "content": "if you solved `Search in Rotated Sorted Array` then this is a Piece of cake."
                    },
                    {
                        "username": "SG-C",
                        "content": "[@dikshawali](/dikshawali) Basic concept is same."
                    },
                    {
                        "username": "dikshawali",
                        "content": "how that? prev solution isnt working for duplicates."
                    },
                    {
                        "username": "bagririshav01",
                        "content": "its very easy for an medium level question\\njust a linear search ans its the answer\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "If O(n) is the worst case runtime, why does this question exist? What part of programming knowledge is it testing?\nJust check if target exist in nums, there is no clever trick that still won't use O(n) runtime unless you're handling extremely large test cases. \nI just run a linear solution 100% memory 100% time.\nOr what am I missing here?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Question description says: You must decrease the overall operation steps as much as possible."
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "its not even worth it to do binary search , in real world scenario i\\'d just do linear search with these test cases.."
                    },
                    {
                        "username": "benhhack",
                        "content": "The specification stats that `nums` is guaranteed to be rotated at some pivot, however, test case 268 provides a `nums` array with no pivot."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Can we do this question by using an hashset . We will initialise an hashset then add all the elements into it and then we will check wether the hashset contains the element or not."
                    },
                    {
                        "username": "Srikanth_Sri",
                        "content": "we can do, but the time and space complexity will be O(n) \\nwhich is not acceptable in interviews, it would be brute force approch"
                    }
                ]
            },
            {
                "id": 2008090,
                "content": [
                    {
                        "username": "QuarantinedSoul",
                        "content": "`Linear search FTW.`"
                    },
                    {
                        "username": "lethal-bot",
                        "content": "giving you a heads up  check your code for  `nums = [1,0,1,1,1]`  `target = 0`. "
                    },
                    {
                        "username": "gangadharkr27",
                        "content": "how to handle in case of dublicates"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Was trying to figure out a O[log(n)] solution and was troubled with some cases where the first and last numbers were equal.\n\nPeeked at the editorial and realized that O(n) solution is acceptable for the worst cases. I proceeded to delete the troubling equal numbers from the start, then applied binary search."
                    },
                    {
                        "username": "SG-C",
                        "content": "if you solved `Search in Rotated Sorted Array` then this is a Piece of cake."
                    },
                    {
                        "username": "SG-C",
                        "content": "[@dikshawali](/dikshawali) Basic concept is same."
                    },
                    {
                        "username": "dikshawali",
                        "content": "how that? prev solution isnt working for duplicates."
                    },
                    {
                        "username": "bagririshav01",
                        "content": "its very easy for an medium level question\\njust a linear search ans its the answer\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "If O(n) is the worst case runtime, why does this question exist? What part of programming knowledge is it testing?\nJust check if target exist in nums, there is no clever trick that still won't use O(n) runtime unless you're handling extremely large test cases. \nI just run a linear solution 100% memory 100% time.\nOr what am I missing here?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Question description says: You must decrease the overall operation steps as much as possible."
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "its not even worth it to do binary search , in real world scenario i\\'d just do linear search with these test cases.."
                    },
                    {
                        "username": "benhhack",
                        "content": "The specification stats that `nums` is guaranteed to be rotated at some pivot, however, test case 268 provides a `nums` array with no pivot."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Can we do this question by using an hashset . We will initialise an hashset then add all the elements into it and then we will check wether the hashset contains the element or not."
                    },
                    {
                        "username": "Srikanth_Sri",
                        "content": "we can do, but the time and space complexity will be O(n) \\nwhich is not acceptable in interviews, it would be brute force approch"
                    }
                ]
            },
            {
                "id": 2008062,
                "content": [
                    {
                        "username": "QuarantinedSoul",
                        "content": "`Linear search FTW.`"
                    },
                    {
                        "username": "lethal-bot",
                        "content": "giving you a heads up  check your code for  `nums = [1,0,1,1,1]`  `target = 0`. "
                    },
                    {
                        "username": "gangadharkr27",
                        "content": "how to handle in case of dublicates"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Was trying to figure out a O[log(n)] solution and was troubled with some cases where the first and last numbers were equal.\n\nPeeked at the editorial and realized that O(n) solution is acceptable for the worst cases. I proceeded to delete the troubling equal numbers from the start, then applied binary search."
                    },
                    {
                        "username": "SG-C",
                        "content": "if you solved `Search in Rotated Sorted Array` then this is a Piece of cake."
                    },
                    {
                        "username": "SG-C",
                        "content": "[@dikshawali](/dikshawali) Basic concept is same."
                    },
                    {
                        "username": "dikshawali",
                        "content": "how that? prev solution isnt working for duplicates."
                    },
                    {
                        "username": "bagririshav01",
                        "content": "its very easy for an medium level question\\njust a linear search ans its the answer\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "If O(n) is the worst case runtime, why does this question exist? What part of programming knowledge is it testing?\nJust check if target exist in nums, there is no clever trick that still won't use O(n) runtime unless you're handling extremely large test cases. \nI just run a linear solution 100% memory 100% time.\nOr what am I missing here?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Question description says: You must decrease the overall operation steps as much as possible."
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "its not even worth it to do binary search , in real world scenario i\\'d just do linear search with these test cases.."
                    },
                    {
                        "username": "benhhack",
                        "content": "The specification stats that `nums` is guaranteed to be rotated at some pivot, however, test case 268 provides a `nums` array with no pivot."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Can we do this question by using an hashset . We will initialise an hashset then add all the elements into it and then we will check wether the hashset contains the element or not."
                    },
                    {
                        "username": "Srikanth_Sri",
                        "content": "we can do, but the time and space complexity will be O(n) \\nwhich is not acceptable in interviews, it would be brute force approch"
                    }
                ]
            },
            {
                "id": 2008036,
                "content": [
                    {
                        "username": "QuarantinedSoul",
                        "content": "`Linear search FTW.`"
                    },
                    {
                        "username": "lethal-bot",
                        "content": "giving you a heads up  check your code for  `nums = [1,0,1,1,1]`  `target = 0`. "
                    },
                    {
                        "username": "gangadharkr27",
                        "content": "how to handle in case of dublicates"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Was trying to figure out a O[log(n)] solution and was troubled with some cases where the first and last numbers were equal.\n\nPeeked at the editorial and realized that O(n) solution is acceptable for the worst cases. I proceeded to delete the troubling equal numbers from the start, then applied binary search."
                    },
                    {
                        "username": "SG-C",
                        "content": "if you solved `Search in Rotated Sorted Array` then this is a Piece of cake."
                    },
                    {
                        "username": "SG-C",
                        "content": "[@dikshawali](/dikshawali) Basic concept is same."
                    },
                    {
                        "username": "dikshawali",
                        "content": "how that? prev solution isnt working for duplicates."
                    },
                    {
                        "username": "bagririshav01",
                        "content": "its very easy for an medium level question\\njust a linear search ans its the answer\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "If O(n) is the worst case runtime, why does this question exist? What part of programming knowledge is it testing?\nJust check if target exist in nums, there is no clever trick that still won't use O(n) runtime unless you're handling extremely large test cases. \nI just run a linear solution 100% memory 100% time.\nOr what am I missing here?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Question description says: You must decrease the overall operation steps as much as possible."
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "its not even worth it to do binary search , in real world scenario i\\'d just do linear search with these test cases.."
                    },
                    {
                        "username": "benhhack",
                        "content": "The specification stats that `nums` is guaranteed to be rotated at some pivot, however, test case 268 provides a `nums` array with no pivot."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Can we do this question by using an hashset . We will initialise an hashset then add all the elements into it and then we will check wether the hashset contains the element or not."
                    },
                    {
                        "username": "Srikanth_Sri",
                        "content": "we can do, but the time and space complexity will be O(n) \\nwhich is not acceptable in interviews, it would be brute force approch"
                    }
                ]
            },
            {
                "id": 2008029,
                "content": [
                    {
                        "username": "QuarantinedSoul",
                        "content": "`Linear search FTW.`"
                    },
                    {
                        "username": "lethal-bot",
                        "content": "giving you a heads up  check your code for  `nums = [1,0,1,1,1]`  `target = 0`. "
                    },
                    {
                        "username": "gangadharkr27",
                        "content": "how to handle in case of dublicates"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Was trying to figure out a O[log(n)] solution and was troubled with some cases where the first and last numbers were equal.\n\nPeeked at the editorial and realized that O(n) solution is acceptable for the worst cases. I proceeded to delete the troubling equal numbers from the start, then applied binary search."
                    },
                    {
                        "username": "SG-C",
                        "content": "if you solved `Search in Rotated Sorted Array` then this is a Piece of cake."
                    },
                    {
                        "username": "SG-C",
                        "content": "[@dikshawali](/dikshawali) Basic concept is same."
                    },
                    {
                        "username": "dikshawali",
                        "content": "how that? prev solution isnt working for duplicates."
                    },
                    {
                        "username": "bagririshav01",
                        "content": "its very easy for an medium level question\\njust a linear search ans its the answer\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "If O(n) is the worst case runtime, why does this question exist? What part of programming knowledge is it testing?\nJust check if target exist in nums, there is no clever trick that still won't use O(n) runtime unless you're handling extremely large test cases. \nI just run a linear solution 100% memory 100% time.\nOr what am I missing here?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Question description says: You must decrease the overall operation steps as much as possible."
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "its not even worth it to do binary search , in real world scenario i\\'d just do linear search with these test cases.."
                    },
                    {
                        "username": "benhhack",
                        "content": "The specification stats that `nums` is guaranteed to be rotated at some pivot, however, test case 268 provides a `nums` array with no pivot."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Can we do this question by using an hashset . We will initialise an hashset then add all the elements into it and then we will check wether the hashset contains the element or not."
                    },
                    {
                        "username": "Srikanth_Sri",
                        "content": "we can do, but the time and space complexity will be O(n) \\nwhich is not acceptable in interviews, it would be brute force approch"
                    }
                ]
            },
            {
                "id": 2007990,
                "content": [
                    {
                        "username": "QuarantinedSoul",
                        "content": "`Linear search FTW.`"
                    },
                    {
                        "username": "lethal-bot",
                        "content": "giving you a heads up  check your code for  `nums = [1,0,1,1,1]`  `target = 0`. "
                    },
                    {
                        "username": "gangadharkr27",
                        "content": "how to handle in case of dublicates"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Was trying to figure out a O[log(n)] solution and was troubled with some cases where the first and last numbers were equal.\n\nPeeked at the editorial and realized that O(n) solution is acceptable for the worst cases. I proceeded to delete the troubling equal numbers from the start, then applied binary search."
                    },
                    {
                        "username": "SG-C",
                        "content": "if you solved `Search in Rotated Sorted Array` then this is a Piece of cake."
                    },
                    {
                        "username": "SG-C",
                        "content": "[@dikshawali](/dikshawali) Basic concept is same."
                    },
                    {
                        "username": "dikshawali",
                        "content": "how that? prev solution isnt working for duplicates."
                    },
                    {
                        "username": "bagririshav01",
                        "content": "its very easy for an medium level question\\njust a linear search ans its the answer\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "If O(n) is the worst case runtime, why does this question exist? What part of programming knowledge is it testing?\nJust check if target exist in nums, there is no clever trick that still won't use O(n) runtime unless you're handling extremely large test cases. \nI just run a linear solution 100% memory 100% time.\nOr what am I missing here?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Question description says: You must decrease the overall operation steps as much as possible."
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "its not even worth it to do binary search , in real world scenario i\\'d just do linear search with these test cases.."
                    },
                    {
                        "username": "benhhack",
                        "content": "The specification stats that `nums` is guaranteed to be rotated at some pivot, however, test case 268 provides a `nums` array with no pivot."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Can we do this question by using an hashset . We will initialise an hashset then add all the elements into it and then we will check wether the hashset contains the element or not."
                    },
                    {
                        "username": "Srikanth_Sri",
                        "content": "we can do, but the time and space complexity will be O(n) \\nwhich is not acceptable in interviews, it would be brute force approch"
                    }
                ]
            },
            {
                "id": 2007987,
                "content": [
                    {
                        "username": "QuarantinedSoul",
                        "content": "`Linear search FTW.`"
                    },
                    {
                        "username": "lethal-bot",
                        "content": "giving you a heads up  check your code for  `nums = [1,0,1,1,1]`  `target = 0`. "
                    },
                    {
                        "username": "gangadharkr27",
                        "content": "how to handle in case of dublicates"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Was trying to figure out a O[log(n)] solution and was troubled with some cases where the first and last numbers were equal.\n\nPeeked at the editorial and realized that O(n) solution is acceptable for the worst cases. I proceeded to delete the troubling equal numbers from the start, then applied binary search."
                    },
                    {
                        "username": "SG-C",
                        "content": "if you solved `Search in Rotated Sorted Array` then this is a Piece of cake."
                    },
                    {
                        "username": "SG-C",
                        "content": "[@dikshawali](/dikshawali) Basic concept is same."
                    },
                    {
                        "username": "dikshawali",
                        "content": "how that? prev solution isnt working for duplicates."
                    },
                    {
                        "username": "bagririshav01",
                        "content": "its very easy for an medium level question\\njust a linear search ans its the answer\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "If O(n) is the worst case runtime, why does this question exist? What part of programming knowledge is it testing?\nJust check if target exist in nums, there is no clever trick that still won't use O(n) runtime unless you're handling extremely large test cases. \nI just run a linear solution 100% memory 100% time.\nOr what am I missing here?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Question description says: You must decrease the overall operation steps as much as possible."
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "its not even worth it to do binary search , in real world scenario i\\'d just do linear search with these test cases.."
                    },
                    {
                        "username": "benhhack",
                        "content": "The specification stats that `nums` is guaranteed to be rotated at some pivot, however, test case 268 provides a `nums` array with no pivot."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Can we do this question by using an hashset . We will initialise an hashset then add all the elements into it and then we will check wether the hashset contains the element or not."
                    },
                    {
                        "username": "Srikanth_Sri",
                        "content": "we can do, but the time and space complexity will be O(n) \\nwhich is not acceptable in interviews, it would be brute force approch"
                    }
                ]
            },
            {
                "id": 2007979,
                "content": [
                    {
                        "username": "raaven_4321",
                        "content": "Linear search 100% faster for this problem xD"
                    },
                    {
                        "username": "andrew99154",
                        "content": "It should be a hard question"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "consider this test case also  arr=[1,0,1,1,1] and target=0 ."
                    },
                    {
                        "username": "tabishnaqvi1311",
                        "content": "Somebody explain, i used the same approach to solve part 1 of this question and it worked???\\n\\n1. Found pivot index recursively\\n2. applied binary search on `left` part and `right` part\\n3. `return left || right`"
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "what  wrong in this code\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]\\ni  am stuck on this test case \\n \\nclass Solution {\\npublic:\\n   int calans(vector<int>&nums)\\n   {\\n      int start=0;\\n      int end=nums.size()-1;\\n      int mid=start+(end-start)/2;\\n      while(start<=end)\\n      {\\n          if(nums[mid]>nums[0])\\n          {\\n            start=mid+1;\\n          } \\n           else\\n            end=mid-1;\\n          mid=start+(end-start)/2;   \\n      } \\n      return start;\\n}\\n    bool search(vector<int>& nums, int target)\\n    {     \\n       if(nums[0]==target)\\n        return true;  \\n      int  pivot=calans(nums);\\n      cout<<pivot;\\n      int start=0,end=0;\\n      int n=nums.size()-1;\\n     if(nums[pivot]>=target && target<=nums[n])\\n      {\\n        start=pivot;\\n        end=n;\\n      }\\n     else\\n      {\\n        start=0;\\n        end=pivot;\\n      } \\n      cout<<\"\\\\n\"<<end;\\n     int mid=start+(end-start)/2;\\n     cout<<\" \"<<mid;\\n      while(start<end)\\n      {\\n          if(nums[mid]==target)\\n           return true;\\n          if(nums[mid]<target)\\n            start=mid+1;\\n           else\\n            end=mid;\\n          mid=start+(end-start)/2;   \\n      } \\n      return false;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "user5693U",
                        "content": "Linear search works here , with it beating 100% in time "
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "Don't rush your brain with more toughts.\nFirst find where the rotation occur and assume it X.\nthen assume we have 2 arrays  one Array from 0-(X-1) and another from X-Array.length-1.\nthen if the target is grater then X and grater then last element then perform Binary search on First Array,\nElse perform Binary search on 2nd Array\n"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Problem is solved when you see,\n`nums is guaranteed to be rotated at some pivot.`\n`Hint` - Find pivot and check where your mid exist, `right of pivot` or `left of pivot`"
                    },
                    {
                        "username": "santanusen",
                        "content": "Linear search beats 100% in C++."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Percentile of the solutions lesser than yours is pretty inconsistent. You submit the exact same code in an interval of just 20 seconds and the percentile could differ significantly."
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "I wont do binarysearch to search in just 5000 things"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Mah man !"
                    }
                ]
            },
            {
                "id": 2007976,
                "content": [
                    {
                        "username": "raaven_4321",
                        "content": "Linear search 100% faster for this problem xD"
                    },
                    {
                        "username": "andrew99154",
                        "content": "It should be a hard question"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "consider this test case also  arr=[1,0,1,1,1] and target=0 ."
                    },
                    {
                        "username": "tabishnaqvi1311",
                        "content": "Somebody explain, i used the same approach to solve part 1 of this question and it worked???\\n\\n1. Found pivot index recursively\\n2. applied binary search on `left` part and `right` part\\n3. `return left || right`"
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "what  wrong in this code\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]\\ni  am stuck on this test case \\n \\nclass Solution {\\npublic:\\n   int calans(vector<int>&nums)\\n   {\\n      int start=0;\\n      int end=nums.size()-1;\\n      int mid=start+(end-start)/2;\\n      while(start<=end)\\n      {\\n          if(nums[mid]>nums[0])\\n          {\\n            start=mid+1;\\n          } \\n           else\\n            end=mid-1;\\n          mid=start+(end-start)/2;   \\n      } \\n      return start;\\n}\\n    bool search(vector<int>& nums, int target)\\n    {     \\n       if(nums[0]==target)\\n        return true;  \\n      int  pivot=calans(nums);\\n      cout<<pivot;\\n      int start=0,end=0;\\n      int n=nums.size()-1;\\n     if(nums[pivot]>=target && target<=nums[n])\\n      {\\n        start=pivot;\\n        end=n;\\n      }\\n     else\\n      {\\n        start=0;\\n        end=pivot;\\n      } \\n      cout<<\"\\\\n\"<<end;\\n     int mid=start+(end-start)/2;\\n     cout<<\" \"<<mid;\\n      while(start<end)\\n      {\\n          if(nums[mid]==target)\\n           return true;\\n          if(nums[mid]<target)\\n            start=mid+1;\\n           else\\n            end=mid;\\n          mid=start+(end-start)/2;   \\n      } \\n      return false;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "user5693U",
                        "content": "Linear search works here , with it beating 100% in time "
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "Don't rush your brain with more toughts.\nFirst find where the rotation occur and assume it X.\nthen assume we have 2 arrays  one Array from 0-(X-1) and another from X-Array.length-1.\nthen if the target is grater then X and grater then last element then perform Binary search on First Array,\nElse perform Binary search on 2nd Array\n"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Problem is solved when you see,\n`nums is guaranteed to be rotated at some pivot.`\n`Hint` - Find pivot and check where your mid exist, `right of pivot` or `left of pivot`"
                    },
                    {
                        "username": "santanusen",
                        "content": "Linear search beats 100% in C++."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Percentile of the solutions lesser than yours is pretty inconsistent. You submit the exact same code in an interval of just 20 seconds and the percentile could differ significantly."
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "I wont do binarysearch to search in just 5000 things"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Mah man !"
                    }
                ]
            },
            {
                "id": 2007945,
                "content": [
                    {
                        "username": "raaven_4321",
                        "content": "Linear search 100% faster for this problem xD"
                    },
                    {
                        "username": "andrew99154",
                        "content": "It should be a hard question"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "consider this test case also  arr=[1,0,1,1,1] and target=0 ."
                    },
                    {
                        "username": "tabishnaqvi1311",
                        "content": "Somebody explain, i used the same approach to solve part 1 of this question and it worked???\\n\\n1. Found pivot index recursively\\n2. applied binary search on `left` part and `right` part\\n3. `return left || right`"
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "what  wrong in this code\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]\\ni  am stuck on this test case \\n \\nclass Solution {\\npublic:\\n   int calans(vector<int>&nums)\\n   {\\n      int start=0;\\n      int end=nums.size()-1;\\n      int mid=start+(end-start)/2;\\n      while(start<=end)\\n      {\\n          if(nums[mid]>nums[0])\\n          {\\n            start=mid+1;\\n          } \\n           else\\n            end=mid-1;\\n          mid=start+(end-start)/2;   \\n      } \\n      return start;\\n}\\n    bool search(vector<int>& nums, int target)\\n    {     \\n       if(nums[0]==target)\\n        return true;  \\n      int  pivot=calans(nums);\\n      cout<<pivot;\\n      int start=0,end=0;\\n      int n=nums.size()-1;\\n     if(nums[pivot]>=target && target<=nums[n])\\n      {\\n        start=pivot;\\n        end=n;\\n      }\\n     else\\n      {\\n        start=0;\\n        end=pivot;\\n      } \\n      cout<<\"\\\\n\"<<end;\\n     int mid=start+(end-start)/2;\\n     cout<<\" \"<<mid;\\n      while(start<end)\\n      {\\n          if(nums[mid]==target)\\n           return true;\\n          if(nums[mid]<target)\\n            start=mid+1;\\n           else\\n            end=mid;\\n          mid=start+(end-start)/2;   \\n      } \\n      return false;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "user5693U",
                        "content": "Linear search works here , with it beating 100% in time "
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "Don't rush your brain with more toughts.\nFirst find where the rotation occur and assume it X.\nthen assume we have 2 arrays  one Array from 0-(X-1) and another from X-Array.length-1.\nthen if the target is grater then X and grater then last element then perform Binary search on First Array,\nElse perform Binary search on 2nd Array\n"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Problem is solved when you see,\n`nums is guaranteed to be rotated at some pivot.`\n`Hint` - Find pivot and check where your mid exist, `right of pivot` or `left of pivot`"
                    },
                    {
                        "username": "santanusen",
                        "content": "Linear search beats 100% in C++."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Percentile of the solutions lesser than yours is pretty inconsistent. You submit the exact same code in an interval of just 20 seconds and the percentile could differ significantly."
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "I wont do binarysearch to search in just 5000 things"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Mah man !"
                    }
                ]
            },
            {
                "id": 2007925,
                "content": [
                    {
                        "username": "raaven_4321",
                        "content": "Linear search 100% faster for this problem xD"
                    },
                    {
                        "username": "andrew99154",
                        "content": "It should be a hard question"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "consider this test case also  arr=[1,0,1,1,1] and target=0 ."
                    },
                    {
                        "username": "tabishnaqvi1311",
                        "content": "Somebody explain, i used the same approach to solve part 1 of this question and it worked???\\n\\n1. Found pivot index recursively\\n2. applied binary search on `left` part and `right` part\\n3. `return left || right`"
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "what  wrong in this code\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]\\ni  am stuck on this test case \\n \\nclass Solution {\\npublic:\\n   int calans(vector<int>&nums)\\n   {\\n      int start=0;\\n      int end=nums.size()-1;\\n      int mid=start+(end-start)/2;\\n      while(start<=end)\\n      {\\n          if(nums[mid]>nums[0])\\n          {\\n            start=mid+1;\\n          } \\n           else\\n            end=mid-1;\\n          mid=start+(end-start)/2;   \\n      } \\n      return start;\\n}\\n    bool search(vector<int>& nums, int target)\\n    {     \\n       if(nums[0]==target)\\n        return true;  \\n      int  pivot=calans(nums);\\n      cout<<pivot;\\n      int start=0,end=0;\\n      int n=nums.size()-1;\\n     if(nums[pivot]>=target && target<=nums[n])\\n      {\\n        start=pivot;\\n        end=n;\\n      }\\n     else\\n      {\\n        start=0;\\n        end=pivot;\\n      } \\n      cout<<\"\\\\n\"<<end;\\n     int mid=start+(end-start)/2;\\n     cout<<\" \"<<mid;\\n      while(start<end)\\n      {\\n          if(nums[mid]==target)\\n           return true;\\n          if(nums[mid]<target)\\n            start=mid+1;\\n           else\\n            end=mid;\\n          mid=start+(end-start)/2;   \\n      } \\n      return false;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "user5693U",
                        "content": "Linear search works here , with it beating 100% in time "
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "Don't rush your brain with more toughts.\nFirst find where the rotation occur and assume it X.\nthen assume we have 2 arrays  one Array from 0-(X-1) and another from X-Array.length-1.\nthen if the target is grater then X and grater then last element then perform Binary search on First Array,\nElse perform Binary search on 2nd Array\n"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Problem is solved when you see,\n`nums is guaranteed to be rotated at some pivot.`\n`Hint` - Find pivot and check where your mid exist, `right of pivot` or `left of pivot`"
                    },
                    {
                        "username": "santanusen",
                        "content": "Linear search beats 100% in C++."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Percentile of the solutions lesser than yours is pretty inconsistent. You submit the exact same code in an interval of just 20 seconds and the percentile could differ significantly."
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "I wont do binarysearch to search in just 5000 things"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Mah man !"
                    }
                ]
            },
            {
                "id": 2007880,
                "content": [
                    {
                        "username": "raaven_4321",
                        "content": "Linear search 100% faster for this problem xD"
                    },
                    {
                        "username": "andrew99154",
                        "content": "It should be a hard question"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "consider this test case also  arr=[1,0,1,1,1] and target=0 ."
                    },
                    {
                        "username": "tabishnaqvi1311",
                        "content": "Somebody explain, i used the same approach to solve part 1 of this question and it worked???\\n\\n1. Found pivot index recursively\\n2. applied binary search on `left` part and `right` part\\n3. `return left || right`"
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "what  wrong in this code\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]\\ni  am stuck on this test case \\n \\nclass Solution {\\npublic:\\n   int calans(vector<int>&nums)\\n   {\\n      int start=0;\\n      int end=nums.size()-1;\\n      int mid=start+(end-start)/2;\\n      while(start<=end)\\n      {\\n          if(nums[mid]>nums[0])\\n          {\\n            start=mid+1;\\n          } \\n           else\\n            end=mid-1;\\n          mid=start+(end-start)/2;   \\n      } \\n      return start;\\n}\\n    bool search(vector<int>& nums, int target)\\n    {     \\n       if(nums[0]==target)\\n        return true;  \\n      int  pivot=calans(nums);\\n      cout<<pivot;\\n      int start=0,end=0;\\n      int n=nums.size()-1;\\n     if(nums[pivot]>=target && target<=nums[n])\\n      {\\n        start=pivot;\\n        end=n;\\n      }\\n     else\\n      {\\n        start=0;\\n        end=pivot;\\n      } \\n      cout<<\"\\\\n\"<<end;\\n     int mid=start+(end-start)/2;\\n     cout<<\" \"<<mid;\\n      while(start<end)\\n      {\\n          if(nums[mid]==target)\\n           return true;\\n          if(nums[mid]<target)\\n            start=mid+1;\\n           else\\n            end=mid;\\n          mid=start+(end-start)/2;   \\n      } \\n      return false;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "user5693U",
                        "content": "Linear search works here , with it beating 100% in time "
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "Don't rush your brain with more toughts.\nFirst find where the rotation occur and assume it X.\nthen assume we have 2 arrays  one Array from 0-(X-1) and another from X-Array.length-1.\nthen if the target is grater then X and grater then last element then perform Binary search on First Array,\nElse perform Binary search on 2nd Array\n"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Problem is solved when you see,\n`nums is guaranteed to be rotated at some pivot.`\n`Hint` - Find pivot and check where your mid exist, `right of pivot` or `left of pivot`"
                    },
                    {
                        "username": "santanusen",
                        "content": "Linear search beats 100% in C++."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Percentile of the solutions lesser than yours is pretty inconsistent. You submit the exact same code in an interval of just 20 seconds and the percentile could differ significantly."
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "I wont do binarysearch to search in just 5000 things"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Mah man !"
                    }
                ]
            },
            {
                "id": 2007867,
                "content": [
                    {
                        "username": "raaven_4321",
                        "content": "Linear search 100% faster for this problem xD"
                    },
                    {
                        "username": "andrew99154",
                        "content": "It should be a hard question"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "consider this test case also  arr=[1,0,1,1,1] and target=0 ."
                    },
                    {
                        "username": "tabishnaqvi1311",
                        "content": "Somebody explain, i used the same approach to solve part 1 of this question and it worked???\\n\\n1. Found pivot index recursively\\n2. applied binary search on `left` part and `right` part\\n3. `return left || right`"
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "what  wrong in this code\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]\\ni  am stuck on this test case \\n \\nclass Solution {\\npublic:\\n   int calans(vector<int>&nums)\\n   {\\n      int start=0;\\n      int end=nums.size()-1;\\n      int mid=start+(end-start)/2;\\n      while(start<=end)\\n      {\\n          if(nums[mid]>nums[0])\\n          {\\n            start=mid+1;\\n          } \\n           else\\n            end=mid-1;\\n          mid=start+(end-start)/2;   \\n      } \\n      return start;\\n}\\n    bool search(vector<int>& nums, int target)\\n    {     \\n       if(nums[0]==target)\\n        return true;  \\n      int  pivot=calans(nums);\\n      cout<<pivot;\\n      int start=0,end=0;\\n      int n=nums.size()-1;\\n     if(nums[pivot]>=target && target<=nums[n])\\n      {\\n        start=pivot;\\n        end=n;\\n      }\\n     else\\n      {\\n        start=0;\\n        end=pivot;\\n      } \\n      cout<<\"\\\\n\"<<end;\\n     int mid=start+(end-start)/2;\\n     cout<<\" \"<<mid;\\n      while(start<end)\\n      {\\n          if(nums[mid]==target)\\n           return true;\\n          if(nums[mid]<target)\\n            start=mid+1;\\n           else\\n            end=mid;\\n          mid=start+(end-start)/2;   \\n      } \\n      return false;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "user5693U",
                        "content": "Linear search works here , with it beating 100% in time "
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "Don't rush your brain with more toughts.\nFirst find where the rotation occur and assume it X.\nthen assume we have 2 arrays  one Array from 0-(X-1) and another from X-Array.length-1.\nthen if the target is grater then X and grater then last element then perform Binary search on First Array,\nElse perform Binary search on 2nd Array\n"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Problem is solved when you see,\n`nums is guaranteed to be rotated at some pivot.`\n`Hint` - Find pivot and check where your mid exist, `right of pivot` or `left of pivot`"
                    },
                    {
                        "username": "santanusen",
                        "content": "Linear search beats 100% in C++."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Percentile of the solutions lesser than yours is pretty inconsistent. You submit the exact same code in an interval of just 20 seconds and the percentile could differ significantly."
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "I wont do binarysearch to search in just 5000 things"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Mah man !"
                    }
                ]
            },
            {
                "id": 2007831,
                "content": [
                    {
                        "username": "raaven_4321",
                        "content": "Linear search 100% faster for this problem xD"
                    },
                    {
                        "username": "andrew99154",
                        "content": "It should be a hard question"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "consider this test case also  arr=[1,0,1,1,1] and target=0 ."
                    },
                    {
                        "username": "tabishnaqvi1311",
                        "content": "Somebody explain, i used the same approach to solve part 1 of this question and it worked???\\n\\n1. Found pivot index recursively\\n2. applied binary search on `left` part and `right` part\\n3. `return left || right`"
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "what  wrong in this code\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]\\ni  am stuck on this test case \\n \\nclass Solution {\\npublic:\\n   int calans(vector<int>&nums)\\n   {\\n      int start=0;\\n      int end=nums.size()-1;\\n      int mid=start+(end-start)/2;\\n      while(start<=end)\\n      {\\n          if(nums[mid]>nums[0])\\n          {\\n            start=mid+1;\\n          } \\n           else\\n            end=mid-1;\\n          mid=start+(end-start)/2;   \\n      } \\n      return start;\\n}\\n    bool search(vector<int>& nums, int target)\\n    {     \\n       if(nums[0]==target)\\n        return true;  \\n      int  pivot=calans(nums);\\n      cout<<pivot;\\n      int start=0,end=0;\\n      int n=nums.size()-1;\\n     if(nums[pivot]>=target && target<=nums[n])\\n      {\\n        start=pivot;\\n        end=n;\\n      }\\n     else\\n      {\\n        start=0;\\n        end=pivot;\\n      } \\n      cout<<\"\\\\n\"<<end;\\n     int mid=start+(end-start)/2;\\n     cout<<\" \"<<mid;\\n      while(start<end)\\n      {\\n          if(nums[mid]==target)\\n           return true;\\n          if(nums[mid]<target)\\n            start=mid+1;\\n           else\\n            end=mid;\\n          mid=start+(end-start)/2;   \\n      } \\n      return false;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "user5693U",
                        "content": "Linear search works here , with it beating 100% in time "
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "Don't rush your brain with more toughts.\nFirst find where the rotation occur and assume it X.\nthen assume we have 2 arrays  one Array from 0-(X-1) and another from X-Array.length-1.\nthen if the target is grater then X and grater then last element then perform Binary search on First Array,\nElse perform Binary search on 2nd Array\n"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Problem is solved when you see,\n`nums is guaranteed to be rotated at some pivot.`\n`Hint` - Find pivot and check where your mid exist, `right of pivot` or `left of pivot`"
                    },
                    {
                        "username": "santanusen",
                        "content": "Linear search beats 100% in C++."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Percentile of the solutions lesser than yours is pretty inconsistent. You submit the exact same code in an interval of just 20 seconds and the percentile could differ significantly."
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "I wont do binarysearch to search in just 5000 things"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Mah man !"
                    }
                ]
            },
            {
                "id": 2007812,
                "content": [
                    {
                        "username": "raaven_4321",
                        "content": "Linear search 100% faster for this problem xD"
                    },
                    {
                        "username": "andrew99154",
                        "content": "It should be a hard question"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "consider this test case also  arr=[1,0,1,1,1] and target=0 ."
                    },
                    {
                        "username": "tabishnaqvi1311",
                        "content": "Somebody explain, i used the same approach to solve part 1 of this question and it worked???\\n\\n1. Found pivot index recursively\\n2. applied binary search on `left` part and `right` part\\n3. `return left || right`"
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "what  wrong in this code\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]\\ni  am stuck on this test case \\n \\nclass Solution {\\npublic:\\n   int calans(vector<int>&nums)\\n   {\\n      int start=0;\\n      int end=nums.size()-1;\\n      int mid=start+(end-start)/2;\\n      while(start<=end)\\n      {\\n          if(nums[mid]>nums[0])\\n          {\\n            start=mid+1;\\n          } \\n           else\\n            end=mid-1;\\n          mid=start+(end-start)/2;   \\n      } \\n      return start;\\n}\\n    bool search(vector<int>& nums, int target)\\n    {     \\n       if(nums[0]==target)\\n        return true;  \\n      int  pivot=calans(nums);\\n      cout<<pivot;\\n      int start=0,end=0;\\n      int n=nums.size()-1;\\n     if(nums[pivot]>=target && target<=nums[n])\\n      {\\n        start=pivot;\\n        end=n;\\n      }\\n     else\\n      {\\n        start=0;\\n        end=pivot;\\n      } \\n      cout<<\"\\\\n\"<<end;\\n     int mid=start+(end-start)/2;\\n     cout<<\" \"<<mid;\\n      while(start<end)\\n      {\\n          if(nums[mid]==target)\\n           return true;\\n          if(nums[mid]<target)\\n            start=mid+1;\\n           else\\n            end=mid;\\n          mid=start+(end-start)/2;   \\n      } \\n      return false;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "user5693U",
                        "content": "Linear search works here , with it beating 100% in time "
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "Don't rush your brain with more toughts.\nFirst find where the rotation occur and assume it X.\nthen assume we have 2 arrays  one Array from 0-(X-1) and another from X-Array.length-1.\nthen if the target is grater then X and grater then last element then perform Binary search on First Array,\nElse perform Binary search on 2nd Array\n"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Problem is solved when you see,\n`nums is guaranteed to be rotated at some pivot.`\n`Hint` - Find pivot and check where your mid exist, `right of pivot` or `left of pivot`"
                    },
                    {
                        "username": "santanusen",
                        "content": "Linear search beats 100% in C++."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Percentile of the solutions lesser than yours is pretty inconsistent. You submit the exact same code in an interval of just 20 seconds and the percentile could differ significantly."
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "I wont do binarysearch to search in just 5000 things"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Mah man !"
                    }
                ]
            },
            {
                "id": 2007805,
                "content": [
                    {
                        "username": "raaven_4321",
                        "content": "Linear search 100% faster for this problem xD"
                    },
                    {
                        "username": "andrew99154",
                        "content": "It should be a hard question"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "consider this test case also  arr=[1,0,1,1,1] and target=0 ."
                    },
                    {
                        "username": "tabishnaqvi1311",
                        "content": "Somebody explain, i used the same approach to solve part 1 of this question and it worked???\\n\\n1. Found pivot index recursively\\n2. applied binary search on `left` part and `right` part\\n3. `return left || right`"
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "what  wrong in this code\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]\\ni  am stuck on this test case \\n \\nclass Solution {\\npublic:\\n   int calans(vector<int>&nums)\\n   {\\n      int start=0;\\n      int end=nums.size()-1;\\n      int mid=start+(end-start)/2;\\n      while(start<=end)\\n      {\\n          if(nums[mid]>nums[0])\\n          {\\n            start=mid+1;\\n          } \\n           else\\n            end=mid-1;\\n          mid=start+(end-start)/2;   \\n      } \\n      return start;\\n}\\n    bool search(vector<int>& nums, int target)\\n    {     \\n       if(nums[0]==target)\\n        return true;  \\n      int  pivot=calans(nums);\\n      cout<<pivot;\\n      int start=0,end=0;\\n      int n=nums.size()-1;\\n     if(nums[pivot]>=target && target<=nums[n])\\n      {\\n        start=pivot;\\n        end=n;\\n      }\\n     else\\n      {\\n        start=0;\\n        end=pivot;\\n      } \\n      cout<<\"\\\\n\"<<end;\\n     int mid=start+(end-start)/2;\\n     cout<<\" \"<<mid;\\n      while(start<end)\\n      {\\n          if(nums[mid]==target)\\n           return true;\\n          if(nums[mid]<target)\\n            start=mid+1;\\n           else\\n            end=mid;\\n          mid=start+(end-start)/2;   \\n      } \\n      return false;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "user5693U",
                        "content": "Linear search works here , with it beating 100% in time "
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "Don't rush your brain with more toughts.\nFirst find where the rotation occur and assume it X.\nthen assume we have 2 arrays  one Array from 0-(X-1) and another from X-Array.length-1.\nthen if the target is grater then X and grater then last element then perform Binary search on First Array,\nElse perform Binary search on 2nd Array\n"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Problem is solved when you see,\n`nums is guaranteed to be rotated at some pivot.`\n`Hint` - Find pivot and check where your mid exist, `right of pivot` or `left of pivot`"
                    },
                    {
                        "username": "santanusen",
                        "content": "Linear search beats 100% in C++."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Percentile of the solutions lesser than yours is pretty inconsistent. You submit the exact same code in an interval of just 20 seconds and the percentile could differ significantly."
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "I wont do binarysearch to search in just 5000 things"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Mah man !"
                    }
                ]
            },
            {
                "id": 2007799,
                "content": [
                    {
                        "username": "raaven_4321",
                        "content": "Linear search 100% faster for this problem xD"
                    },
                    {
                        "username": "andrew99154",
                        "content": "It should be a hard question"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "consider this test case also  arr=[1,0,1,1,1] and target=0 ."
                    },
                    {
                        "username": "tabishnaqvi1311",
                        "content": "Somebody explain, i used the same approach to solve part 1 of this question and it worked???\\n\\n1. Found pivot index recursively\\n2. applied binary search on `left` part and `right` part\\n3. `return left || right`"
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "what  wrong in this code\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]\\ni  am stuck on this test case \\n \\nclass Solution {\\npublic:\\n   int calans(vector<int>&nums)\\n   {\\n      int start=0;\\n      int end=nums.size()-1;\\n      int mid=start+(end-start)/2;\\n      while(start<=end)\\n      {\\n          if(nums[mid]>nums[0])\\n          {\\n            start=mid+1;\\n          } \\n           else\\n            end=mid-1;\\n          mid=start+(end-start)/2;   \\n      } \\n      return start;\\n}\\n    bool search(vector<int>& nums, int target)\\n    {     \\n       if(nums[0]==target)\\n        return true;  \\n      int  pivot=calans(nums);\\n      cout<<pivot;\\n      int start=0,end=0;\\n      int n=nums.size()-1;\\n     if(nums[pivot]>=target && target<=nums[n])\\n      {\\n        start=pivot;\\n        end=n;\\n      }\\n     else\\n      {\\n        start=0;\\n        end=pivot;\\n      } \\n      cout<<\"\\\\n\"<<end;\\n     int mid=start+(end-start)/2;\\n     cout<<\" \"<<mid;\\n      while(start<end)\\n      {\\n          if(nums[mid]==target)\\n           return true;\\n          if(nums[mid]<target)\\n            start=mid+1;\\n           else\\n            end=mid;\\n          mid=start+(end-start)/2;   \\n      } \\n      return false;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "user5693U",
                        "content": "Linear search works here , with it beating 100% in time "
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "Don't rush your brain with more toughts.\nFirst find where the rotation occur and assume it X.\nthen assume we have 2 arrays  one Array from 0-(X-1) and another from X-Array.length-1.\nthen if the target is grater then X and grater then last element then perform Binary search on First Array,\nElse perform Binary search on 2nd Array\n"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Problem is solved when you see,\n`nums is guaranteed to be rotated at some pivot.`\n`Hint` - Find pivot and check where your mid exist, `right of pivot` or `left of pivot`"
                    },
                    {
                        "username": "santanusen",
                        "content": "Linear search beats 100% in C++."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Percentile of the solutions lesser than yours is pretty inconsistent. You submit the exact same code in an interval of just 20 seconds and the percentile could differ significantly."
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "I wont do binarysearch to search in just 5000 things"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Mah man !"
                    }
                ]
            },
            {
                "id": 2007742,
                "content": [
                    {
                        "username": "ag_ressive",
                        "content": "Linear Traversal (O(n)) enters the chat."
                    },
                    {
                        "username": "avinash-25",
                        "content": "we have to sort array before searching?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "A simple linear search seems to run faster than binary search. To see why consider the test case ``nums[lo] == nums[mid]``: Since ``lo`` and ``mid`` may be on opposite sides of the ``pivot`` index, this gives us no information on how to adjust the boundaries and you have no choice but to increment ``lo``. In a worst case scenario (all elements the same) this would devolve into a O(n) run time except that instead of just comparing the element to the target, we are doing a new set of boundary calculations.\\n\\nIf you wish to do a binary search anyway then there are two boundary conditions to consider: 1. ``nums[lo] <= nums[mid]`` and 2. ``nums[lo] <= target``. If only one of these conditions is true then ``mid`` and ``target`` are on opposite sides of the ``pivot`` and we can use that information to reduce the search range."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Scratched my head so bad to figure out how to implement Binary Search to find the pivot index just to prove myself that this must be possible and I am not dumb. Eventually, I am, after reading the comments. I took \"Try harder than you cry\" too seriously."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Exclude all trailing elements in `nums` which equal `nums[0]`, then use Tuesday's code..."
                    },
                    {
                        "username": "tr1ten",
                        "content": "Spend hours just to realize there is no logn solution -_-"
                    },
                    {
                        "username": "isusel",
                        "content": "This is ridiculous when you write some tricky binary search, and your solution is 7ms and \"beats 53.92% of users with C++\", but then you check the 0ms and it is a straight linear bruteforce. I know, there are test cases that are not suitable for a binary search (e.g. {1,1,1,1,1,2,1}).\\n\\nBut shouldn\\'t the TC encourage a logarithmic (on average) solution instead of 2-lines-of-code linear search? "
                    },
                    {
                        "username": "psionl0",
                        "content": "It depends on whether you want to improve your binary search skills or just tick off the daily problem."
                    },
                    {
                        "username": "BatMe",
                        "content": "See, if you\\'re stuck just do one thing, if [mid, start and end] all are equal then increment/Decrement Start/End value until they are not equal rest the previous logic(BS on Rotated Sorted Array) works here as well.  Open reply if you wanna see the code of this statement. "
                    },
                    {
                        "username": "BatMe",
                        "content": "if(nums[mid]==nums[start] && nums[mid]==nums[end]){\\n    start++;\\n    end--;\\n   continue;\\n}"
                    },
                    {
                        "username": "gg_vanek",
                        "content": "> \"nums is guaranteed to be rotated at some pivot.\"\n> testcase 254: nums = [1, 3], target = 1\n> testcase 263: nums = [1, 3], target = 3"
                    },
                    {
                        "username": "ig_rocker",
                        "content": "This problem cannot be solved faster than O(N) in the worst case scenario.\\nBasically, For this problem, we can use the same approach as we are doing for the Sorted Rotated Array having unique elements & enhance some changes which will fit for the edge cases like [1,1,1,1,1,1,0,1].\\n\\nHint: Try to shrink the start & end point when you are not able to find which side is sorted."
                    }
                ]
            },
            {
                "id": 2007704,
                "content": [
                    {
                        "username": "ag_ressive",
                        "content": "Linear Traversal (O(n)) enters the chat."
                    },
                    {
                        "username": "avinash-25",
                        "content": "we have to sort array before searching?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "A simple linear search seems to run faster than binary search. To see why consider the test case ``nums[lo] == nums[mid]``: Since ``lo`` and ``mid`` may be on opposite sides of the ``pivot`` index, this gives us no information on how to adjust the boundaries and you have no choice but to increment ``lo``. In a worst case scenario (all elements the same) this would devolve into a O(n) run time except that instead of just comparing the element to the target, we are doing a new set of boundary calculations.\\n\\nIf you wish to do a binary search anyway then there are two boundary conditions to consider: 1. ``nums[lo] <= nums[mid]`` and 2. ``nums[lo] <= target``. If only one of these conditions is true then ``mid`` and ``target`` are on opposite sides of the ``pivot`` and we can use that information to reduce the search range."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Scratched my head so bad to figure out how to implement Binary Search to find the pivot index just to prove myself that this must be possible and I am not dumb. Eventually, I am, after reading the comments. I took \"Try harder than you cry\" too seriously."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Exclude all trailing elements in `nums` which equal `nums[0]`, then use Tuesday's code..."
                    },
                    {
                        "username": "tr1ten",
                        "content": "Spend hours just to realize there is no logn solution -_-"
                    },
                    {
                        "username": "isusel",
                        "content": "This is ridiculous when you write some tricky binary search, and your solution is 7ms and \"beats 53.92% of users with C++\", but then you check the 0ms and it is a straight linear bruteforce. I know, there are test cases that are not suitable for a binary search (e.g. {1,1,1,1,1,2,1}).\\n\\nBut shouldn\\'t the TC encourage a logarithmic (on average) solution instead of 2-lines-of-code linear search? "
                    },
                    {
                        "username": "psionl0",
                        "content": "It depends on whether you want to improve your binary search skills or just tick off the daily problem."
                    },
                    {
                        "username": "BatMe",
                        "content": "See, if you\\'re stuck just do one thing, if [mid, start and end] all are equal then increment/Decrement Start/End value until they are not equal rest the previous logic(BS on Rotated Sorted Array) works here as well.  Open reply if you wanna see the code of this statement. "
                    },
                    {
                        "username": "BatMe",
                        "content": "if(nums[mid]==nums[start] && nums[mid]==nums[end]){\\n    start++;\\n    end--;\\n   continue;\\n}"
                    },
                    {
                        "username": "gg_vanek",
                        "content": "> \"nums is guaranteed to be rotated at some pivot.\"\n> testcase 254: nums = [1, 3], target = 1\n> testcase 263: nums = [1, 3], target = 3"
                    },
                    {
                        "username": "ig_rocker",
                        "content": "This problem cannot be solved faster than O(N) in the worst case scenario.\\nBasically, For this problem, we can use the same approach as we are doing for the Sorted Rotated Array having unique elements & enhance some changes which will fit for the edge cases like [1,1,1,1,1,1,0,1].\\n\\nHint: Try to shrink the start & end point when you are not able to find which side is sorted."
                    }
                ]
            },
            {
                "id": 2007698,
                "content": [
                    {
                        "username": "ag_ressive",
                        "content": "Linear Traversal (O(n)) enters the chat."
                    },
                    {
                        "username": "avinash-25",
                        "content": "we have to sort array before searching?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "A simple linear search seems to run faster than binary search. To see why consider the test case ``nums[lo] == nums[mid]``: Since ``lo`` and ``mid`` may be on opposite sides of the ``pivot`` index, this gives us no information on how to adjust the boundaries and you have no choice but to increment ``lo``. In a worst case scenario (all elements the same) this would devolve into a O(n) run time except that instead of just comparing the element to the target, we are doing a new set of boundary calculations.\\n\\nIf you wish to do a binary search anyway then there are two boundary conditions to consider: 1. ``nums[lo] <= nums[mid]`` and 2. ``nums[lo] <= target``. If only one of these conditions is true then ``mid`` and ``target`` are on opposite sides of the ``pivot`` and we can use that information to reduce the search range."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Scratched my head so bad to figure out how to implement Binary Search to find the pivot index just to prove myself that this must be possible and I am not dumb. Eventually, I am, after reading the comments. I took \"Try harder than you cry\" too seriously."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Exclude all trailing elements in `nums` which equal `nums[0]`, then use Tuesday's code..."
                    },
                    {
                        "username": "tr1ten",
                        "content": "Spend hours just to realize there is no logn solution -_-"
                    },
                    {
                        "username": "isusel",
                        "content": "This is ridiculous when you write some tricky binary search, and your solution is 7ms and \"beats 53.92% of users with C++\", but then you check the 0ms and it is a straight linear bruteforce. I know, there are test cases that are not suitable for a binary search (e.g. {1,1,1,1,1,2,1}).\\n\\nBut shouldn\\'t the TC encourage a logarithmic (on average) solution instead of 2-lines-of-code linear search? "
                    },
                    {
                        "username": "psionl0",
                        "content": "It depends on whether you want to improve your binary search skills or just tick off the daily problem."
                    },
                    {
                        "username": "BatMe",
                        "content": "See, if you\\'re stuck just do one thing, if [mid, start and end] all are equal then increment/Decrement Start/End value until they are not equal rest the previous logic(BS on Rotated Sorted Array) works here as well.  Open reply if you wanna see the code of this statement. "
                    },
                    {
                        "username": "BatMe",
                        "content": "if(nums[mid]==nums[start] && nums[mid]==nums[end]){\\n    start++;\\n    end--;\\n   continue;\\n}"
                    },
                    {
                        "username": "gg_vanek",
                        "content": "> \"nums is guaranteed to be rotated at some pivot.\"\n> testcase 254: nums = [1, 3], target = 1\n> testcase 263: nums = [1, 3], target = 3"
                    },
                    {
                        "username": "ig_rocker",
                        "content": "This problem cannot be solved faster than O(N) in the worst case scenario.\\nBasically, For this problem, we can use the same approach as we are doing for the Sorted Rotated Array having unique elements & enhance some changes which will fit for the edge cases like [1,1,1,1,1,1,0,1].\\n\\nHint: Try to shrink the start & end point when you are not able to find which side is sorted."
                    }
                ]
            },
            {
                "id": 2007659,
                "content": [
                    {
                        "username": "ag_ressive",
                        "content": "Linear Traversal (O(n)) enters the chat."
                    },
                    {
                        "username": "avinash-25",
                        "content": "we have to sort array before searching?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "A simple linear search seems to run faster than binary search. To see why consider the test case ``nums[lo] == nums[mid]``: Since ``lo`` and ``mid`` may be on opposite sides of the ``pivot`` index, this gives us no information on how to adjust the boundaries and you have no choice but to increment ``lo``. In a worst case scenario (all elements the same) this would devolve into a O(n) run time except that instead of just comparing the element to the target, we are doing a new set of boundary calculations.\\n\\nIf you wish to do a binary search anyway then there are two boundary conditions to consider: 1. ``nums[lo] <= nums[mid]`` and 2. ``nums[lo] <= target``. If only one of these conditions is true then ``mid`` and ``target`` are on opposite sides of the ``pivot`` and we can use that information to reduce the search range."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Scratched my head so bad to figure out how to implement Binary Search to find the pivot index just to prove myself that this must be possible and I am not dumb. Eventually, I am, after reading the comments. I took \"Try harder than you cry\" too seriously."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Exclude all trailing elements in `nums` which equal `nums[0]`, then use Tuesday's code..."
                    },
                    {
                        "username": "tr1ten",
                        "content": "Spend hours just to realize there is no logn solution -_-"
                    },
                    {
                        "username": "isusel",
                        "content": "This is ridiculous when you write some tricky binary search, and your solution is 7ms and \"beats 53.92% of users with C++\", but then you check the 0ms and it is a straight linear bruteforce. I know, there are test cases that are not suitable for a binary search (e.g. {1,1,1,1,1,2,1}).\\n\\nBut shouldn\\'t the TC encourage a logarithmic (on average) solution instead of 2-lines-of-code linear search? "
                    },
                    {
                        "username": "psionl0",
                        "content": "It depends on whether you want to improve your binary search skills or just tick off the daily problem."
                    },
                    {
                        "username": "BatMe",
                        "content": "See, if you\\'re stuck just do one thing, if [mid, start and end] all are equal then increment/Decrement Start/End value until they are not equal rest the previous logic(BS on Rotated Sorted Array) works here as well.  Open reply if you wanna see the code of this statement. "
                    },
                    {
                        "username": "BatMe",
                        "content": "if(nums[mid]==nums[start] && nums[mid]==nums[end]){\\n    start++;\\n    end--;\\n   continue;\\n}"
                    },
                    {
                        "username": "gg_vanek",
                        "content": "> \"nums is guaranteed to be rotated at some pivot.\"\n> testcase 254: nums = [1, 3], target = 1\n> testcase 263: nums = [1, 3], target = 3"
                    },
                    {
                        "username": "ig_rocker",
                        "content": "This problem cannot be solved faster than O(N) in the worst case scenario.\\nBasically, For this problem, we can use the same approach as we are doing for the Sorted Rotated Array having unique elements & enhance some changes which will fit for the edge cases like [1,1,1,1,1,1,0,1].\\n\\nHint: Try to shrink the start & end point when you are not able to find which side is sorted."
                    }
                ]
            },
            {
                "id": 2007658,
                "content": [
                    {
                        "username": "ag_ressive",
                        "content": "Linear Traversal (O(n)) enters the chat."
                    },
                    {
                        "username": "avinash-25",
                        "content": "we have to sort array before searching?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "A simple linear search seems to run faster than binary search. To see why consider the test case ``nums[lo] == nums[mid]``: Since ``lo`` and ``mid`` may be on opposite sides of the ``pivot`` index, this gives us no information on how to adjust the boundaries and you have no choice but to increment ``lo``. In a worst case scenario (all elements the same) this would devolve into a O(n) run time except that instead of just comparing the element to the target, we are doing a new set of boundary calculations.\\n\\nIf you wish to do a binary search anyway then there are two boundary conditions to consider: 1. ``nums[lo] <= nums[mid]`` and 2. ``nums[lo] <= target``. If only one of these conditions is true then ``mid`` and ``target`` are on opposite sides of the ``pivot`` and we can use that information to reduce the search range."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Scratched my head so bad to figure out how to implement Binary Search to find the pivot index just to prove myself that this must be possible and I am not dumb. Eventually, I am, after reading the comments. I took \"Try harder than you cry\" too seriously."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Exclude all trailing elements in `nums` which equal `nums[0]`, then use Tuesday's code..."
                    },
                    {
                        "username": "tr1ten",
                        "content": "Spend hours just to realize there is no logn solution -_-"
                    },
                    {
                        "username": "isusel",
                        "content": "This is ridiculous when you write some tricky binary search, and your solution is 7ms and \"beats 53.92% of users with C++\", but then you check the 0ms and it is a straight linear bruteforce. I know, there are test cases that are not suitable for a binary search (e.g. {1,1,1,1,1,2,1}).\\n\\nBut shouldn\\'t the TC encourage a logarithmic (on average) solution instead of 2-lines-of-code linear search? "
                    },
                    {
                        "username": "psionl0",
                        "content": "It depends on whether you want to improve your binary search skills or just tick off the daily problem."
                    },
                    {
                        "username": "BatMe",
                        "content": "See, if you\\'re stuck just do one thing, if [mid, start and end] all are equal then increment/Decrement Start/End value until they are not equal rest the previous logic(BS on Rotated Sorted Array) works here as well.  Open reply if you wanna see the code of this statement. "
                    },
                    {
                        "username": "BatMe",
                        "content": "if(nums[mid]==nums[start] && nums[mid]==nums[end]){\\n    start++;\\n    end--;\\n   continue;\\n}"
                    },
                    {
                        "username": "gg_vanek",
                        "content": "> \"nums is guaranteed to be rotated at some pivot.\"\n> testcase 254: nums = [1, 3], target = 1\n> testcase 263: nums = [1, 3], target = 3"
                    },
                    {
                        "username": "ig_rocker",
                        "content": "This problem cannot be solved faster than O(N) in the worst case scenario.\\nBasically, For this problem, we can use the same approach as we are doing for the Sorted Rotated Array having unique elements & enhance some changes which will fit for the edge cases like [1,1,1,1,1,1,0,1].\\n\\nHint: Try to shrink the start & end point when you are not able to find which side is sorted."
                    }
                ]
            },
            {
                "id": 2007634,
                "content": [
                    {
                        "username": "ag_ressive",
                        "content": "Linear Traversal (O(n)) enters the chat."
                    },
                    {
                        "username": "avinash-25",
                        "content": "we have to sort array before searching?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "A simple linear search seems to run faster than binary search. To see why consider the test case ``nums[lo] == nums[mid]``: Since ``lo`` and ``mid`` may be on opposite sides of the ``pivot`` index, this gives us no information on how to adjust the boundaries and you have no choice but to increment ``lo``. In a worst case scenario (all elements the same) this would devolve into a O(n) run time except that instead of just comparing the element to the target, we are doing a new set of boundary calculations.\\n\\nIf you wish to do a binary search anyway then there are two boundary conditions to consider: 1. ``nums[lo] <= nums[mid]`` and 2. ``nums[lo] <= target``. If only one of these conditions is true then ``mid`` and ``target`` are on opposite sides of the ``pivot`` and we can use that information to reduce the search range."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Scratched my head so bad to figure out how to implement Binary Search to find the pivot index just to prove myself that this must be possible and I am not dumb. Eventually, I am, after reading the comments. I took \"Try harder than you cry\" too seriously."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Exclude all trailing elements in `nums` which equal `nums[0]`, then use Tuesday's code..."
                    },
                    {
                        "username": "tr1ten",
                        "content": "Spend hours just to realize there is no logn solution -_-"
                    },
                    {
                        "username": "isusel",
                        "content": "This is ridiculous when you write some tricky binary search, and your solution is 7ms and \"beats 53.92% of users with C++\", but then you check the 0ms and it is a straight linear bruteforce. I know, there are test cases that are not suitable for a binary search (e.g. {1,1,1,1,1,2,1}).\\n\\nBut shouldn\\'t the TC encourage a logarithmic (on average) solution instead of 2-lines-of-code linear search? "
                    },
                    {
                        "username": "psionl0",
                        "content": "It depends on whether you want to improve your binary search skills or just tick off the daily problem."
                    },
                    {
                        "username": "BatMe",
                        "content": "See, if you\\'re stuck just do one thing, if [mid, start and end] all are equal then increment/Decrement Start/End value until they are not equal rest the previous logic(BS on Rotated Sorted Array) works here as well.  Open reply if you wanna see the code of this statement. "
                    },
                    {
                        "username": "BatMe",
                        "content": "if(nums[mid]==nums[start] && nums[mid]==nums[end]){\\n    start++;\\n    end--;\\n   continue;\\n}"
                    },
                    {
                        "username": "gg_vanek",
                        "content": "> \"nums is guaranteed to be rotated at some pivot.\"\n> testcase 254: nums = [1, 3], target = 1\n> testcase 263: nums = [1, 3], target = 3"
                    },
                    {
                        "username": "ig_rocker",
                        "content": "This problem cannot be solved faster than O(N) in the worst case scenario.\\nBasically, For this problem, we can use the same approach as we are doing for the Sorted Rotated Array having unique elements & enhance some changes which will fit for the edge cases like [1,1,1,1,1,1,0,1].\\n\\nHint: Try to shrink the start & end point when you are not able to find which side is sorted."
                    }
                ]
            },
            {
                "id": 2007577,
                "content": [
                    {
                        "username": "ag_ressive",
                        "content": "Linear Traversal (O(n)) enters the chat."
                    },
                    {
                        "username": "avinash-25",
                        "content": "we have to sort array before searching?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "A simple linear search seems to run faster than binary search. To see why consider the test case ``nums[lo] == nums[mid]``: Since ``lo`` and ``mid`` may be on opposite sides of the ``pivot`` index, this gives us no information on how to adjust the boundaries and you have no choice but to increment ``lo``. In a worst case scenario (all elements the same) this would devolve into a O(n) run time except that instead of just comparing the element to the target, we are doing a new set of boundary calculations.\\n\\nIf you wish to do a binary search anyway then there are two boundary conditions to consider: 1. ``nums[lo] <= nums[mid]`` and 2. ``nums[lo] <= target``. If only one of these conditions is true then ``mid`` and ``target`` are on opposite sides of the ``pivot`` and we can use that information to reduce the search range."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Scratched my head so bad to figure out how to implement Binary Search to find the pivot index just to prove myself that this must be possible and I am not dumb. Eventually, I am, after reading the comments. I took \"Try harder than you cry\" too seriously."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Exclude all trailing elements in `nums` which equal `nums[0]`, then use Tuesday's code..."
                    },
                    {
                        "username": "tr1ten",
                        "content": "Spend hours just to realize there is no logn solution -_-"
                    },
                    {
                        "username": "isusel",
                        "content": "This is ridiculous when you write some tricky binary search, and your solution is 7ms and \"beats 53.92% of users with C++\", but then you check the 0ms and it is a straight linear bruteforce. I know, there are test cases that are not suitable for a binary search (e.g. {1,1,1,1,1,2,1}).\\n\\nBut shouldn\\'t the TC encourage a logarithmic (on average) solution instead of 2-lines-of-code linear search? "
                    },
                    {
                        "username": "psionl0",
                        "content": "It depends on whether you want to improve your binary search skills or just tick off the daily problem."
                    },
                    {
                        "username": "BatMe",
                        "content": "See, if you\\'re stuck just do one thing, if [mid, start and end] all are equal then increment/Decrement Start/End value until they are not equal rest the previous logic(BS on Rotated Sorted Array) works here as well.  Open reply if you wanna see the code of this statement. "
                    },
                    {
                        "username": "BatMe",
                        "content": "if(nums[mid]==nums[start] && nums[mid]==nums[end]){\\n    start++;\\n    end--;\\n   continue;\\n}"
                    },
                    {
                        "username": "gg_vanek",
                        "content": "> \"nums is guaranteed to be rotated at some pivot.\"\n> testcase 254: nums = [1, 3], target = 1\n> testcase 263: nums = [1, 3], target = 3"
                    },
                    {
                        "username": "ig_rocker",
                        "content": "This problem cannot be solved faster than O(N) in the worst case scenario.\\nBasically, For this problem, we can use the same approach as we are doing for the Sorted Rotated Array having unique elements & enhance some changes which will fit for the edge cases like [1,1,1,1,1,1,0,1].\\n\\nHint: Try to shrink the start & end point when you are not able to find which side is sorted."
                    }
                ]
            },
            {
                "id": 2007137,
                "content": [
                    {
                        "username": "ag_ressive",
                        "content": "Linear Traversal (O(n)) enters the chat."
                    },
                    {
                        "username": "avinash-25",
                        "content": "we have to sort array before searching?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "A simple linear search seems to run faster than binary search. To see why consider the test case ``nums[lo] == nums[mid]``: Since ``lo`` and ``mid`` may be on opposite sides of the ``pivot`` index, this gives us no information on how to adjust the boundaries and you have no choice but to increment ``lo``. In a worst case scenario (all elements the same) this would devolve into a O(n) run time except that instead of just comparing the element to the target, we are doing a new set of boundary calculations.\\n\\nIf you wish to do a binary search anyway then there are two boundary conditions to consider: 1. ``nums[lo] <= nums[mid]`` and 2. ``nums[lo] <= target``. If only one of these conditions is true then ``mid`` and ``target`` are on opposite sides of the ``pivot`` and we can use that information to reduce the search range."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Scratched my head so bad to figure out how to implement Binary Search to find the pivot index just to prove myself that this must be possible and I am not dumb. Eventually, I am, after reading the comments. I took \"Try harder than you cry\" too seriously."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Exclude all trailing elements in `nums` which equal `nums[0]`, then use Tuesday's code..."
                    },
                    {
                        "username": "tr1ten",
                        "content": "Spend hours just to realize there is no logn solution -_-"
                    },
                    {
                        "username": "isusel",
                        "content": "This is ridiculous when you write some tricky binary search, and your solution is 7ms and \"beats 53.92% of users with C++\", but then you check the 0ms and it is a straight linear bruteforce. I know, there are test cases that are not suitable for a binary search (e.g. {1,1,1,1,1,2,1}).\\n\\nBut shouldn\\'t the TC encourage a logarithmic (on average) solution instead of 2-lines-of-code linear search? "
                    },
                    {
                        "username": "psionl0",
                        "content": "It depends on whether you want to improve your binary search skills or just tick off the daily problem."
                    },
                    {
                        "username": "BatMe",
                        "content": "See, if you\\'re stuck just do one thing, if [mid, start and end] all are equal then increment/Decrement Start/End value until they are not equal rest the previous logic(BS on Rotated Sorted Array) works here as well.  Open reply if you wanna see the code of this statement. "
                    },
                    {
                        "username": "BatMe",
                        "content": "if(nums[mid]==nums[start] && nums[mid]==nums[end]){\\n    start++;\\n    end--;\\n   continue;\\n}"
                    },
                    {
                        "username": "gg_vanek",
                        "content": "> \"nums is guaranteed to be rotated at some pivot.\"\n> testcase 254: nums = [1, 3], target = 1\n> testcase 263: nums = [1, 3], target = 3"
                    },
                    {
                        "username": "ig_rocker",
                        "content": "This problem cannot be solved faster than O(N) in the worst case scenario.\\nBasically, For this problem, we can use the same approach as we are doing for the Sorted Rotated Array having unique elements & enhance some changes which will fit for the edge cases like [1,1,1,1,1,1,0,1].\\n\\nHint: Try to shrink the start & end point when you are not able to find which side is sorted."
                    }
                ]
            },
            {
                "id": 2004504,
                "content": [
                    {
                        "username": "ag_ressive",
                        "content": "Linear Traversal (O(n)) enters the chat."
                    },
                    {
                        "username": "avinash-25",
                        "content": "we have to sort array before searching?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "A simple linear search seems to run faster than binary search. To see why consider the test case ``nums[lo] == nums[mid]``: Since ``lo`` and ``mid`` may be on opposite sides of the ``pivot`` index, this gives us no information on how to adjust the boundaries and you have no choice but to increment ``lo``. In a worst case scenario (all elements the same) this would devolve into a O(n) run time except that instead of just comparing the element to the target, we are doing a new set of boundary calculations.\\n\\nIf you wish to do a binary search anyway then there are two boundary conditions to consider: 1. ``nums[lo] <= nums[mid]`` and 2. ``nums[lo] <= target``. If only one of these conditions is true then ``mid`` and ``target`` are on opposite sides of the ``pivot`` and we can use that information to reduce the search range."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Scratched my head so bad to figure out how to implement Binary Search to find the pivot index just to prove myself that this must be possible and I am not dumb. Eventually, I am, after reading the comments. I took \"Try harder than you cry\" too seriously."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Exclude all trailing elements in `nums` which equal `nums[0]`, then use Tuesday's code..."
                    },
                    {
                        "username": "tr1ten",
                        "content": "Spend hours just to realize there is no logn solution -_-"
                    },
                    {
                        "username": "isusel",
                        "content": "This is ridiculous when you write some tricky binary search, and your solution is 7ms and \"beats 53.92% of users with C++\", but then you check the 0ms and it is a straight linear bruteforce. I know, there are test cases that are not suitable for a binary search (e.g. {1,1,1,1,1,2,1}).\\n\\nBut shouldn\\'t the TC encourage a logarithmic (on average) solution instead of 2-lines-of-code linear search? "
                    },
                    {
                        "username": "psionl0",
                        "content": "It depends on whether you want to improve your binary search skills or just tick off the daily problem."
                    },
                    {
                        "username": "BatMe",
                        "content": "See, if you\\'re stuck just do one thing, if [mid, start and end] all are equal then increment/Decrement Start/End value until they are not equal rest the previous logic(BS on Rotated Sorted Array) works here as well.  Open reply if you wanna see the code of this statement. "
                    },
                    {
                        "username": "BatMe",
                        "content": "if(nums[mid]==nums[start] && nums[mid]==nums[end]){\\n    start++;\\n    end--;\\n   continue;\\n}"
                    },
                    {
                        "username": "gg_vanek",
                        "content": "> \"nums is guaranteed to be rotated at some pivot.\"\n> testcase 254: nums = [1, 3], target = 1\n> testcase 263: nums = [1, 3], target = 3"
                    },
                    {
                        "username": "ig_rocker",
                        "content": "This problem cannot be solved faster than O(N) in the worst case scenario.\\nBasically, For this problem, we can use the same approach as we are doing for the Sorted Rotated Array having unique elements & enhance some changes which will fit for the edge cases like [1,1,1,1,1,1,0,1].\\n\\nHint: Try to shrink the start & end point when you are not able to find which side is sorted."
                    }
                ]
            },
            {
                "id": 1952581,
                "content": [
                    {
                        "username": "ag_ressive",
                        "content": "Linear Traversal (O(n)) enters the chat."
                    },
                    {
                        "username": "avinash-25",
                        "content": "we have to sort array before searching?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "A simple linear search seems to run faster than binary search. To see why consider the test case ``nums[lo] == nums[mid]``: Since ``lo`` and ``mid`` may be on opposite sides of the ``pivot`` index, this gives us no information on how to adjust the boundaries and you have no choice but to increment ``lo``. In a worst case scenario (all elements the same) this would devolve into a O(n) run time except that instead of just comparing the element to the target, we are doing a new set of boundary calculations.\\n\\nIf you wish to do a binary search anyway then there are two boundary conditions to consider: 1. ``nums[lo] <= nums[mid]`` and 2. ``nums[lo] <= target``. If only one of these conditions is true then ``mid`` and ``target`` are on opposite sides of the ``pivot`` and we can use that information to reduce the search range."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Scratched my head so bad to figure out how to implement Binary Search to find the pivot index just to prove myself that this must be possible and I am not dumb. Eventually, I am, after reading the comments. I took \"Try harder than you cry\" too seriously."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Exclude all trailing elements in `nums` which equal `nums[0]`, then use Tuesday's code..."
                    },
                    {
                        "username": "tr1ten",
                        "content": "Spend hours just to realize there is no logn solution -_-"
                    },
                    {
                        "username": "isusel",
                        "content": "This is ridiculous when you write some tricky binary search, and your solution is 7ms and \"beats 53.92% of users with C++\", but then you check the 0ms and it is a straight linear bruteforce. I know, there are test cases that are not suitable for a binary search (e.g. {1,1,1,1,1,2,1}).\\n\\nBut shouldn\\'t the TC encourage a logarithmic (on average) solution instead of 2-lines-of-code linear search? "
                    },
                    {
                        "username": "psionl0",
                        "content": "It depends on whether you want to improve your binary search skills or just tick off the daily problem."
                    },
                    {
                        "username": "BatMe",
                        "content": "See, if you\\'re stuck just do one thing, if [mid, start and end] all are equal then increment/Decrement Start/End value until they are not equal rest the previous logic(BS on Rotated Sorted Array) works here as well.  Open reply if you wanna see the code of this statement. "
                    },
                    {
                        "username": "BatMe",
                        "content": "if(nums[mid]==nums[start] && nums[mid]==nums[end]){\\n    start++;\\n    end--;\\n   continue;\\n}"
                    },
                    {
                        "username": "gg_vanek",
                        "content": "> \"nums is guaranteed to be rotated at some pivot.\"\n> testcase 254: nums = [1, 3], target = 1\n> testcase 263: nums = [1, 3], target = 3"
                    },
                    {
                        "username": "ig_rocker",
                        "content": "This problem cannot be solved faster than O(N) in the worst case scenario.\\nBasically, For this problem, we can use the same approach as we are doing for the Sorted Rotated Array having unique elements & enhance some changes which will fit for the edge cases like [1,1,1,1,1,1,0,1].\\n\\nHint: Try to shrink the start & end point when you are not able to find which side is sorted."
                    }
                ]
            },
            {
                "id": 1950355,
                "content": [
                    {
                        "username": "shrey802",
                        "content": "I just did a linear search that\\'s it! I feel it\\'s the same question like search in rotated sorted array only the difference is return true or false instead of index."
                    },
                    {
                        "username": "BatMe",
                        "content": "You need to think of applying Binary search this is why the question is rated medium\\n"
                    },
                    {
                        "username": "saisysubarashi",
                        "content": "me too. i feel like my solution was wrong but it was accepted :|"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "I tried to solve this using binary search recursively and the code is working but iam unable to find the time complexity of this solution.\\nI request leetcode community to explain the complexity of this solution.\\n______________________________________________\\n______________________________________________\\nbool solve(int l,int h,vector<int>& nums, int k) {\\n    while(l<=h){\\n        int mid=l+(h-l)/2;\\n        if(nums[mid]==k)return 1;\\n        return solve(l,mid-1,nums,k) || solve(mid+1,h,nums,k);\\n    }return 0;\\n}\\n    bool search(vector<int>& nums, int target) {\\n        return solve(0,nums.size()-1,nums,target);\\n    }"
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "trid to solve this problem by using binary search algorithm but only three condition satisfied then used set and now all test passed ."
                    },
                    {
                        "username": "Asliddin70",
                        "content": "why this problem is in medium category it is by far the easiest I have ever solved with one line js code"
                    },
                    {
                        "username": "harryharanr",
                        "content": "Can we assume the largest number in the array is not duplicated?"
                    },
                    {
                        "username": "coffeeCoder69",
                        "content": "\\u2757\\u2757\\u2757   **Can anyone tell me what is wrong in this logic?**  \\u2757\\u2757\\u2757\\n\\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int n = nums.length;\\n        if(n<3)\\n        {\\n            for(int i = 0;i<n;i++)\\n            {\\n                if(target==nums[i])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        int pivot = findPivotIndex(nums);\\n        if(pivot==n-1)\\n        {\\n            return normalBinarySearch(nums, target, 0,n-1);\\n        }\\n        boolean res = normalBinarySearch(nums, target, 0,pivot);\\n        if(!res)\\n        {\\n            res = normalBinarySearch(nums, target, pivot+1,n-1);\\n        }\\n        return res;\\n    }\\n    public static int findPivotIndex(int[] nums)\\n    {\\n        int l = 0;\\n        int n = nums.length;\\n        int r = n-1;\\n        \\n        while(l<=r)\\n        {\\n            int mid = l+(r-l)/2;\\n            //base case\\n            if(nums[mid]>nums[(mid+1)%n])\\n            {\\n                return mid;\\n            }\\n            //base case\\n            else if(nums[mid]<nums[(mid-1)%n])\\n            {\\n                return (mid-1)%n;\\n            }\\n            //addressing 3 equal\\n            if(nums[l] == nums[mid] && nums[mid] == nums[r])\\n            {\\n                if(nums[l]>nums[(l+1)%n])\\n                {\\n                    return l;\\n                }\\n                l = (l+1)%n;\\n                if(nums[r]<nums[(r+n-1)%n])\\n                {\\n                    return r;\\n                }\\n                r = (r+n-1)%n;\\n            }\\n            //addressing 2 equal\\n            if(nums[l] == nums[mid] && nums[mid] < nums[r])\\n            {\\n                l = (mid+1)%n;\\n            } \\n            else if(nums[l] > nums[mid] && nums[mid] == nums[r])\\n            {\\n                r = (mid+n-1)%n;\\n            }\\n            //no equal normal conditions\\n            if(nums[mid]>nums[l])\\n            {\\n                l = (mid+1)%n;\\n            } \\n            else if(nums[mid]<nums[r])\\n            {\\n                r = (mid+n-1)%n;\\n            }\\n        }\\n        return -1;\\n    }\\n    public static boolean normalBinarySearch(int[] nums, int target, int l, int r)\\n    {\\n        int n = nums.length;\\n        while(l<=r)\\n        {\\n            int mid = l+(r-l)/2;\\n            if(target==nums[mid])\\n            {\\n                return true;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                r = mid-1;\\n            } \\n            else \\n            {\\n                l = mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shivaprashad2003",
                        "content": "complexity doesnt matter in this ?\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Thecodermachine",
                        "content": "see this problem is to search the element in rotated sorted array and most importantly it contain duplicates element we can do by using concept of simple binary search without using the concept of pivot element   "
                    }
                ]
            },
            {
                "id": 1891192,
                "content": [
                    {
                        "username": "shrey802",
                        "content": "I just did a linear search that\\'s it! I feel it\\'s the same question like search in rotated sorted array only the difference is return true or false instead of index."
                    },
                    {
                        "username": "BatMe",
                        "content": "You need to think of applying Binary search this is why the question is rated medium\\n"
                    },
                    {
                        "username": "saisysubarashi",
                        "content": "me too. i feel like my solution was wrong but it was accepted :|"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "I tried to solve this using binary search recursively and the code is working but iam unable to find the time complexity of this solution.\\nI request leetcode community to explain the complexity of this solution.\\n______________________________________________\\n______________________________________________\\nbool solve(int l,int h,vector<int>& nums, int k) {\\n    while(l<=h){\\n        int mid=l+(h-l)/2;\\n        if(nums[mid]==k)return 1;\\n        return solve(l,mid-1,nums,k) || solve(mid+1,h,nums,k);\\n    }return 0;\\n}\\n    bool search(vector<int>& nums, int target) {\\n        return solve(0,nums.size()-1,nums,target);\\n    }"
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "trid to solve this problem by using binary search algorithm but only three condition satisfied then used set and now all test passed ."
                    },
                    {
                        "username": "Asliddin70",
                        "content": "why this problem is in medium category it is by far the easiest I have ever solved with one line js code"
                    },
                    {
                        "username": "harryharanr",
                        "content": "Can we assume the largest number in the array is not duplicated?"
                    },
                    {
                        "username": "coffeeCoder69",
                        "content": "\\u2757\\u2757\\u2757   **Can anyone tell me what is wrong in this logic?**  \\u2757\\u2757\\u2757\\n\\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int n = nums.length;\\n        if(n<3)\\n        {\\n            for(int i = 0;i<n;i++)\\n            {\\n                if(target==nums[i])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        int pivot = findPivotIndex(nums);\\n        if(pivot==n-1)\\n        {\\n            return normalBinarySearch(nums, target, 0,n-1);\\n        }\\n        boolean res = normalBinarySearch(nums, target, 0,pivot);\\n        if(!res)\\n        {\\n            res = normalBinarySearch(nums, target, pivot+1,n-1);\\n        }\\n        return res;\\n    }\\n    public static int findPivotIndex(int[] nums)\\n    {\\n        int l = 0;\\n        int n = nums.length;\\n        int r = n-1;\\n        \\n        while(l<=r)\\n        {\\n            int mid = l+(r-l)/2;\\n            //base case\\n            if(nums[mid]>nums[(mid+1)%n])\\n            {\\n                return mid;\\n            }\\n            //base case\\n            else if(nums[mid]<nums[(mid-1)%n])\\n            {\\n                return (mid-1)%n;\\n            }\\n            //addressing 3 equal\\n            if(nums[l] == nums[mid] && nums[mid] == nums[r])\\n            {\\n                if(nums[l]>nums[(l+1)%n])\\n                {\\n                    return l;\\n                }\\n                l = (l+1)%n;\\n                if(nums[r]<nums[(r+n-1)%n])\\n                {\\n                    return r;\\n                }\\n                r = (r+n-1)%n;\\n            }\\n            //addressing 2 equal\\n            if(nums[l] == nums[mid] && nums[mid] < nums[r])\\n            {\\n                l = (mid+1)%n;\\n            } \\n            else if(nums[l] > nums[mid] && nums[mid] == nums[r])\\n            {\\n                r = (mid+n-1)%n;\\n            }\\n            //no equal normal conditions\\n            if(nums[mid]>nums[l])\\n            {\\n                l = (mid+1)%n;\\n            } \\n            else if(nums[mid]<nums[r])\\n            {\\n                r = (mid+n-1)%n;\\n            }\\n        }\\n        return -1;\\n    }\\n    public static boolean normalBinarySearch(int[] nums, int target, int l, int r)\\n    {\\n        int n = nums.length;\\n        while(l<=r)\\n        {\\n            int mid = l+(r-l)/2;\\n            if(target==nums[mid])\\n            {\\n                return true;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                r = mid-1;\\n            } \\n            else \\n            {\\n                l = mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shivaprashad2003",
                        "content": "complexity doesnt matter in this ?\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Thecodermachine",
                        "content": "see this problem is to search the element in rotated sorted array and most importantly it contain duplicates element we can do by using concept of simple binary search without using the concept of pivot element   "
                    }
                ]
            },
            {
                "id": 1852709,
                "content": [
                    {
                        "username": "shrey802",
                        "content": "I just did a linear search that\\'s it! I feel it\\'s the same question like search in rotated sorted array only the difference is return true or false instead of index."
                    },
                    {
                        "username": "BatMe",
                        "content": "You need to think of applying Binary search this is why the question is rated medium\\n"
                    },
                    {
                        "username": "saisysubarashi",
                        "content": "me too. i feel like my solution was wrong but it was accepted :|"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "I tried to solve this using binary search recursively and the code is working but iam unable to find the time complexity of this solution.\\nI request leetcode community to explain the complexity of this solution.\\n______________________________________________\\n______________________________________________\\nbool solve(int l,int h,vector<int>& nums, int k) {\\n    while(l<=h){\\n        int mid=l+(h-l)/2;\\n        if(nums[mid]==k)return 1;\\n        return solve(l,mid-1,nums,k) || solve(mid+1,h,nums,k);\\n    }return 0;\\n}\\n    bool search(vector<int>& nums, int target) {\\n        return solve(0,nums.size()-1,nums,target);\\n    }"
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "trid to solve this problem by using binary search algorithm but only three condition satisfied then used set and now all test passed ."
                    },
                    {
                        "username": "Asliddin70",
                        "content": "why this problem is in medium category it is by far the easiest I have ever solved with one line js code"
                    },
                    {
                        "username": "harryharanr",
                        "content": "Can we assume the largest number in the array is not duplicated?"
                    },
                    {
                        "username": "coffeeCoder69",
                        "content": "\\u2757\\u2757\\u2757   **Can anyone tell me what is wrong in this logic?**  \\u2757\\u2757\\u2757\\n\\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int n = nums.length;\\n        if(n<3)\\n        {\\n            for(int i = 0;i<n;i++)\\n            {\\n                if(target==nums[i])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        int pivot = findPivotIndex(nums);\\n        if(pivot==n-1)\\n        {\\n            return normalBinarySearch(nums, target, 0,n-1);\\n        }\\n        boolean res = normalBinarySearch(nums, target, 0,pivot);\\n        if(!res)\\n        {\\n            res = normalBinarySearch(nums, target, pivot+1,n-1);\\n        }\\n        return res;\\n    }\\n    public static int findPivotIndex(int[] nums)\\n    {\\n        int l = 0;\\n        int n = nums.length;\\n        int r = n-1;\\n        \\n        while(l<=r)\\n        {\\n            int mid = l+(r-l)/2;\\n            //base case\\n            if(nums[mid]>nums[(mid+1)%n])\\n            {\\n                return mid;\\n            }\\n            //base case\\n            else if(nums[mid]<nums[(mid-1)%n])\\n            {\\n                return (mid-1)%n;\\n            }\\n            //addressing 3 equal\\n            if(nums[l] == nums[mid] && nums[mid] == nums[r])\\n            {\\n                if(nums[l]>nums[(l+1)%n])\\n                {\\n                    return l;\\n                }\\n                l = (l+1)%n;\\n                if(nums[r]<nums[(r+n-1)%n])\\n                {\\n                    return r;\\n                }\\n                r = (r+n-1)%n;\\n            }\\n            //addressing 2 equal\\n            if(nums[l] == nums[mid] && nums[mid] < nums[r])\\n            {\\n                l = (mid+1)%n;\\n            } \\n            else if(nums[l] > nums[mid] && nums[mid] == nums[r])\\n            {\\n                r = (mid+n-1)%n;\\n            }\\n            //no equal normal conditions\\n            if(nums[mid]>nums[l])\\n            {\\n                l = (mid+1)%n;\\n            } \\n            else if(nums[mid]<nums[r])\\n            {\\n                r = (mid+n-1)%n;\\n            }\\n        }\\n        return -1;\\n    }\\n    public static boolean normalBinarySearch(int[] nums, int target, int l, int r)\\n    {\\n        int n = nums.length;\\n        while(l<=r)\\n        {\\n            int mid = l+(r-l)/2;\\n            if(target==nums[mid])\\n            {\\n                return true;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                r = mid-1;\\n            } \\n            else \\n            {\\n                l = mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shivaprashad2003",
                        "content": "complexity doesnt matter in this ?\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Thecodermachine",
                        "content": "see this problem is to search the element in rotated sorted array and most importantly it contain duplicates element we can do by using concept of simple binary search without using the concept of pivot element   "
                    }
                ]
            },
            {
                "id": 1815179,
                "content": [
                    {
                        "username": "shrey802",
                        "content": "I just did a linear search that\\'s it! I feel it\\'s the same question like search in rotated sorted array only the difference is return true or false instead of index."
                    },
                    {
                        "username": "BatMe",
                        "content": "You need to think of applying Binary search this is why the question is rated medium\\n"
                    },
                    {
                        "username": "saisysubarashi",
                        "content": "me too. i feel like my solution was wrong but it was accepted :|"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "I tried to solve this using binary search recursively and the code is working but iam unable to find the time complexity of this solution.\\nI request leetcode community to explain the complexity of this solution.\\n______________________________________________\\n______________________________________________\\nbool solve(int l,int h,vector<int>& nums, int k) {\\n    while(l<=h){\\n        int mid=l+(h-l)/2;\\n        if(nums[mid]==k)return 1;\\n        return solve(l,mid-1,nums,k) || solve(mid+1,h,nums,k);\\n    }return 0;\\n}\\n    bool search(vector<int>& nums, int target) {\\n        return solve(0,nums.size()-1,nums,target);\\n    }"
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "trid to solve this problem by using binary search algorithm but only three condition satisfied then used set and now all test passed ."
                    },
                    {
                        "username": "Asliddin70",
                        "content": "why this problem is in medium category it is by far the easiest I have ever solved with one line js code"
                    },
                    {
                        "username": "harryharanr",
                        "content": "Can we assume the largest number in the array is not duplicated?"
                    },
                    {
                        "username": "coffeeCoder69",
                        "content": "\\u2757\\u2757\\u2757   **Can anyone tell me what is wrong in this logic?**  \\u2757\\u2757\\u2757\\n\\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int n = nums.length;\\n        if(n<3)\\n        {\\n            for(int i = 0;i<n;i++)\\n            {\\n                if(target==nums[i])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        int pivot = findPivotIndex(nums);\\n        if(pivot==n-1)\\n        {\\n            return normalBinarySearch(nums, target, 0,n-1);\\n        }\\n        boolean res = normalBinarySearch(nums, target, 0,pivot);\\n        if(!res)\\n        {\\n            res = normalBinarySearch(nums, target, pivot+1,n-1);\\n        }\\n        return res;\\n    }\\n    public static int findPivotIndex(int[] nums)\\n    {\\n        int l = 0;\\n        int n = nums.length;\\n        int r = n-1;\\n        \\n        while(l<=r)\\n        {\\n            int mid = l+(r-l)/2;\\n            //base case\\n            if(nums[mid]>nums[(mid+1)%n])\\n            {\\n                return mid;\\n            }\\n            //base case\\n            else if(nums[mid]<nums[(mid-1)%n])\\n            {\\n                return (mid-1)%n;\\n            }\\n            //addressing 3 equal\\n            if(nums[l] == nums[mid] && nums[mid] == nums[r])\\n            {\\n                if(nums[l]>nums[(l+1)%n])\\n                {\\n                    return l;\\n                }\\n                l = (l+1)%n;\\n                if(nums[r]<nums[(r+n-1)%n])\\n                {\\n                    return r;\\n                }\\n                r = (r+n-1)%n;\\n            }\\n            //addressing 2 equal\\n            if(nums[l] == nums[mid] && nums[mid] < nums[r])\\n            {\\n                l = (mid+1)%n;\\n            } \\n            else if(nums[l] > nums[mid] && nums[mid] == nums[r])\\n            {\\n                r = (mid+n-1)%n;\\n            }\\n            //no equal normal conditions\\n            if(nums[mid]>nums[l])\\n            {\\n                l = (mid+1)%n;\\n            } \\n            else if(nums[mid]<nums[r])\\n            {\\n                r = (mid+n-1)%n;\\n            }\\n        }\\n        return -1;\\n    }\\n    public static boolean normalBinarySearch(int[] nums, int target, int l, int r)\\n    {\\n        int n = nums.length;\\n        while(l<=r)\\n        {\\n            int mid = l+(r-l)/2;\\n            if(target==nums[mid])\\n            {\\n                return true;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                r = mid-1;\\n            } \\n            else \\n            {\\n                l = mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shivaprashad2003",
                        "content": "complexity doesnt matter in this ?\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Thecodermachine",
                        "content": "see this problem is to search the element in rotated sorted array and most importantly it contain duplicates element we can do by using concept of simple binary search without using the concept of pivot element   "
                    }
                ]
            },
            {
                "id": 1793284,
                "content": [
                    {
                        "username": "shrey802",
                        "content": "I just did a linear search that\\'s it! I feel it\\'s the same question like search in rotated sorted array only the difference is return true or false instead of index."
                    },
                    {
                        "username": "BatMe",
                        "content": "You need to think of applying Binary search this is why the question is rated medium\\n"
                    },
                    {
                        "username": "saisysubarashi",
                        "content": "me too. i feel like my solution was wrong but it was accepted :|"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "I tried to solve this using binary search recursively and the code is working but iam unable to find the time complexity of this solution.\\nI request leetcode community to explain the complexity of this solution.\\n______________________________________________\\n______________________________________________\\nbool solve(int l,int h,vector<int>& nums, int k) {\\n    while(l<=h){\\n        int mid=l+(h-l)/2;\\n        if(nums[mid]==k)return 1;\\n        return solve(l,mid-1,nums,k) || solve(mid+1,h,nums,k);\\n    }return 0;\\n}\\n    bool search(vector<int>& nums, int target) {\\n        return solve(0,nums.size()-1,nums,target);\\n    }"
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "trid to solve this problem by using binary search algorithm but only three condition satisfied then used set and now all test passed ."
                    },
                    {
                        "username": "Asliddin70",
                        "content": "why this problem is in medium category it is by far the easiest I have ever solved with one line js code"
                    },
                    {
                        "username": "harryharanr",
                        "content": "Can we assume the largest number in the array is not duplicated?"
                    },
                    {
                        "username": "coffeeCoder69",
                        "content": "\\u2757\\u2757\\u2757   **Can anyone tell me what is wrong in this logic?**  \\u2757\\u2757\\u2757\\n\\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int n = nums.length;\\n        if(n<3)\\n        {\\n            for(int i = 0;i<n;i++)\\n            {\\n                if(target==nums[i])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        int pivot = findPivotIndex(nums);\\n        if(pivot==n-1)\\n        {\\n            return normalBinarySearch(nums, target, 0,n-1);\\n        }\\n        boolean res = normalBinarySearch(nums, target, 0,pivot);\\n        if(!res)\\n        {\\n            res = normalBinarySearch(nums, target, pivot+1,n-1);\\n        }\\n        return res;\\n    }\\n    public static int findPivotIndex(int[] nums)\\n    {\\n        int l = 0;\\n        int n = nums.length;\\n        int r = n-1;\\n        \\n        while(l<=r)\\n        {\\n            int mid = l+(r-l)/2;\\n            //base case\\n            if(nums[mid]>nums[(mid+1)%n])\\n            {\\n                return mid;\\n            }\\n            //base case\\n            else if(nums[mid]<nums[(mid-1)%n])\\n            {\\n                return (mid-1)%n;\\n            }\\n            //addressing 3 equal\\n            if(nums[l] == nums[mid] && nums[mid] == nums[r])\\n            {\\n                if(nums[l]>nums[(l+1)%n])\\n                {\\n                    return l;\\n                }\\n                l = (l+1)%n;\\n                if(nums[r]<nums[(r+n-1)%n])\\n                {\\n                    return r;\\n                }\\n                r = (r+n-1)%n;\\n            }\\n            //addressing 2 equal\\n            if(nums[l] == nums[mid] && nums[mid] < nums[r])\\n            {\\n                l = (mid+1)%n;\\n            } \\n            else if(nums[l] > nums[mid] && nums[mid] == nums[r])\\n            {\\n                r = (mid+n-1)%n;\\n            }\\n            //no equal normal conditions\\n            if(nums[mid]>nums[l])\\n            {\\n                l = (mid+1)%n;\\n            } \\n            else if(nums[mid]<nums[r])\\n            {\\n                r = (mid+n-1)%n;\\n            }\\n        }\\n        return -1;\\n    }\\n    public static boolean normalBinarySearch(int[] nums, int target, int l, int r)\\n    {\\n        int n = nums.length;\\n        while(l<=r)\\n        {\\n            int mid = l+(r-l)/2;\\n            if(target==nums[mid])\\n            {\\n                return true;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                r = mid-1;\\n            } \\n            else \\n            {\\n                l = mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shivaprashad2003",
                        "content": "complexity doesnt matter in this ?\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Thecodermachine",
                        "content": "see this problem is to search the element in rotated sorted array and most importantly it contain duplicates element we can do by using concept of simple binary search without using the concept of pivot element   "
                    }
                ]
            },
            {
                "id": 1758104,
                "content": [
                    {
                        "username": "shrey802",
                        "content": "I just did a linear search that\\'s it! I feel it\\'s the same question like search in rotated sorted array only the difference is return true or false instead of index."
                    },
                    {
                        "username": "BatMe",
                        "content": "You need to think of applying Binary search this is why the question is rated medium\\n"
                    },
                    {
                        "username": "saisysubarashi",
                        "content": "me too. i feel like my solution was wrong but it was accepted :|"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "I tried to solve this using binary search recursively and the code is working but iam unable to find the time complexity of this solution.\\nI request leetcode community to explain the complexity of this solution.\\n______________________________________________\\n______________________________________________\\nbool solve(int l,int h,vector<int>& nums, int k) {\\n    while(l<=h){\\n        int mid=l+(h-l)/2;\\n        if(nums[mid]==k)return 1;\\n        return solve(l,mid-1,nums,k) || solve(mid+1,h,nums,k);\\n    }return 0;\\n}\\n    bool search(vector<int>& nums, int target) {\\n        return solve(0,nums.size()-1,nums,target);\\n    }"
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "trid to solve this problem by using binary search algorithm but only three condition satisfied then used set and now all test passed ."
                    },
                    {
                        "username": "Asliddin70",
                        "content": "why this problem is in medium category it is by far the easiest I have ever solved with one line js code"
                    },
                    {
                        "username": "harryharanr",
                        "content": "Can we assume the largest number in the array is not duplicated?"
                    },
                    {
                        "username": "coffeeCoder69",
                        "content": "\\u2757\\u2757\\u2757   **Can anyone tell me what is wrong in this logic?**  \\u2757\\u2757\\u2757\\n\\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int n = nums.length;\\n        if(n<3)\\n        {\\n            for(int i = 0;i<n;i++)\\n            {\\n                if(target==nums[i])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        int pivot = findPivotIndex(nums);\\n        if(pivot==n-1)\\n        {\\n            return normalBinarySearch(nums, target, 0,n-1);\\n        }\\n        boolean res = normalBinarySearch(nums, target, 0,pivot);\\n        if(!res)\\n        {\\n            res = normalBinarySearch(nums, target, pivot+1,n-1);\\n        }\\n        return res;\\n    }\\n    public static int findPivotIndex(int[] nums)\\n    {\\n        int l = 0;\\n        int n = nums.length;\\n        int r = n-1;\\n        \\n        while(l<=r)\\n        {\\n            int mid = l+(r-l)/2;\\n            //base case\\n            if(nums[mid]>nums[(mid+1)%n])\\n            {\\n                return mid;\\n            }\\n            //base case\\n            else if(nums[mid]<nums[(mid-1)%n])\\n            {\\n                return (mid-1)%n;\\n            }\\n            //addressing 3 equal\\n            if(nums[l] == nums[mid] && nums[mid] == nums[r])\\n            {\\n                if(nums[l]>nums[(l+1)%n])\\n                {\\n                    return l;\\n                }\\n                l = (l+1)%n;\\n                if(nums[r]<nums[(r+n-1)%n])\\n                {\\n                    return r;\\n                }\\n                r = (r+n-1)%n;\\n            }\\n            //addressing 2 equal\\n            if(nums[l] == nums[mid] && nums[mid] < nums[r])\\n            {\\n                l = (mid+1)%n;\\n            } \\n            else if(nums[l] > nums[mid] && nums[mid] == nums[r])\\n            {\\n                r = (mid+n-1)%n;\\n            }\\n            //no equal normal conditions\\n            if(nums[mid]>nums[l])\\n            {\\n                l = (mid+1)%n;\\n            } \\n            else if(nums[mid]<nums[r])\\n            {\\n                r = (mid+n-1)%n;\\n            }\\n        }\\n        return -1;\\n    }\\n    public static boolean normalBinarySearch(int[] nums, int target, int l, int r)\\n    {\\n        int n = nums.length;\\n        while(l<=r)\\n        {\\n            int mid = l+(r-l)/2;\\n            if(target==nums[mid])\\n            {\\n                return true;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                r = mid-1;\\n            } \\n            else \\n            {\\n                l = mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shivaprashad2003",
                        "content": "complexity doesnt matter in this ?\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Thecodermachine",
                        "content": "see this problem is to search the element in rotated sorted array and most importantly it contain duplicates element we can do by using concept of simple binary search without using the concept of pivot element   "
                    }
                ]
            },
            {
                "id": 1754139,
                "content": [
                    {
                        "username": "shrey802",
                        "content": "I just did a linear search that\\'s it! I feel it\\'s the same question like search in rotated sorted array only the difference is return true or false instead of index."
                    },
                    {
                        "username": "BatMe",
                        "content": "You need to think of applying Binary search this is why the question is rated medium\\n"
                    },
                    {
                        "username": "saisysubarashi",
                        "content": "me too. i feel like my solution was wrong but it was accepted :|"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "I tried to solve this using binary search recursively and the code is working but iam unable to find the time complexity of this solution.\\nI request leetcode community to explain the complexity of this solution.\\n______________________________________________\\n______________________________________________\\nbool solve(int l,int h,vector<int>& nums, int k) {\\n    while(l<=h){\\n        int mid=l+(h-l)/2;\\n        if(nums[mid]==k)return 1;\\n        return solve(l,mid-1,nums,k) || solve(mid+1,h,nums,k);\\n    }return 0;\\n}\\n    bool search(vector<int>& nums, int target) {\\n        return solve(0,nums.size()-1,nums,target);\\n    }"
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "trid to solve this problem by using binary search algorithm but only three condition satisfied then used set and now all test passed ."
                    },
                    {
                        "username": "Asliddin70",
                        "content": "why this problem is in medium category it is by far the easiest I have ever solved with one line js code"
                    },
                    {
                        "username": "harryharanr",
                        "content": "Can we assume the largest number in the array is not duplicated?"
                    },
                    {
                        "username": "coffeeCoder69",
                        "content": "\\u2757\\u2757\\u2757   **Can anyone tell me what is wrong in this logic?**  \\u2757\\u2757\\u2757\\n\\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int n = nums.length;\\n        if(n<3)\\n        {\\n            for(int i = 0;i<n;i++)\\n            {\\n                if(target==nums[i])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        int pivot = findPivotIndex(nums);\\n        if(pivot==n-1)\\n        {\\n            return normalBinarySearch(nums, target, 0,n-1);\\n        }\\n        boolean res = normalBinarySearch(nums, target, 0,pivot);\\n        if(!res)\\n        {\\n            res = normalBinarySearch(nums, target, pivot+1,n-1);\\n        }\\n        return res;\\n    }\\n    public static int findPivotIndex(int[] nums)\\n    {\\n        int l = 0;\\n        int n = nums.length;\\n        int r = n-1;\\n        \\n        while(l<=r)\\n        {\\n            int mid = l+(r-l)/2;\\n            //base case\\n            if(nums[mid]>nums[(mid+1)%n])\\n            {\\n                return mid;\\n            }\\n            //base case\\n            else if(nums[mid]<nums[(mid-1)%n])\\n            {\\n                return (mid-1)%n;\\n            }\\n            //addressing 3 equal\\n            if(nums[l] == nums[mid] && nums[mid] == nums[r])\\n            {\\n                if(nums[l]>nums[(l+1)%n])\\n                {\\n                    return l;\\n                }\\n                l = (l+1)%n;\\n                if(nums[r]<nums[(r+n-1)%n])\\n                {\\n                    return r;\\n                }\\n                r = (r+n-1)%n;\\n            }\\n            //addressing 2 equal\\n            if(nums[l] == nums[mid] && nums[mid] < nums[r])\\n            {\\n                l = (mid+1)%n;\\n            } \\n            else if(nums[l] > nums[mid] && nums[mid] == nums[r])\\n            {\\n                r = (mid+n-1)%n;\\n            }\\n            //no equal normal conditions\\n            if(nums[mid]>nums[l])\\n            {\\n                l = (mid+1)%n;\\n            } \\n            else if(nums[mid]<nums[r])\\n            {\\n                r = (mid+n-1)%n;\\n            }\\n        }\\n        return -1;\\n    }\\n    public static boolean normalBinarySearch(int[] nums, int target, int l, int r)\\n    {\\n        int n = nums.length;\\n        while(l<=r)\\n        {\\n            int mid = l+(r-l)/2;\\n            if(target==nums[mid])\\n            {\\n                return true;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                r = mid-1;\\n            } \\n            else \\n            {\\n                l = mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shivaprashad2003",
                        "content": "complexity doesnt matter in this ?\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Thecodermachine",
                        "content": "see this problem is to search the element in rotated sorted array and most importantly it contain duplicates element we can do by using concept of simple binary search without using the concept of pivot element   "
                    }
                ]
            },
            {
                "id": 1748714,
                "content": [
                    {
                        "username": "shrey802",
                        "content": "I just did a linear search that\\'s it! I feel it\\'s the same question like search in rotated sorted array only the difference is return true or false instead of index."
                    },
                    {
                        "username": "BatMe",
                        "content": "You need to think of applying Binary search this is why the question is rated medium\\n"
                    },
                    {
                        "username": "saisysubarashi",
                        "content": "me too. i feel like my solution was wrong but it was accepted :|"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "I tried to solve this using binary search recursively and the code is working but iam unable to find the time complexity of this solution.\\nI request leetcode community to explain the complexity of this solution.\\n______________________________________________\\n______________________________________________\\nbool solve(int l,int h,vector<int>& nums, int k) {\\n    while(l<=h){\\n        int mid=l+(h-l)/2;\\n        if(nums[mid]==k)return 1;\\n        return solve(l,mid-1,nums,k) || solve(mid+1,h,nums,k);\\n    }return 0;\\n}\\n    bool search(vector<int>& nums, int target) {\\n        return solve(0,nums.size()-1,nums,target);\\n    }"
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "trid to solve this problem by using binary search algorithm but only three condition satisfied then used set and now all test passed ."
                    },
                    {
                        "username": "Asliddin70",
                        "content": "why this problem is in medium category it is by far the easiest I have ever solved with one line js code"
                    },
                    {
                        "username": "harryharanr",
                        "content": "Can we assume the largest number in the array is not duplicated?"
                    },
                    {
                        "username": "coffeeCoder69",
                        "content": "\\u2757\\u2757\\u2757   **Can anyone tell me what is wrong in this logic?**  \\u2757\\u2757\\u2757\\n\\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int n = nums.length;\\n        if(n<3)\\n        {\\n            for(int i = 0;i<n;i++)\\n            {\\n                if(target==nums[i])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        int pivot = findPivotIndex(nums);\\n        if(pivot==n-1)\\n        {\\n            return normalBinarySearch(nums, target, 0,n-1);\\n        }\\n        boolean res = normalBinarySearch(nums, target, 0,pivot);\\n        if(!res)\\n        {\\n            res = normalBinarySearch(nums, target, pivot+1,n-1);\\n        }\\n        return res;\\n    }\\n    public static int findPivotIndex(int[] nums)\\n    {\\n        int l = 0;\\n        int n = nums.length;\\n        int r = n-1;\\n        \\n        while(l<=r)\\n        {\\n            int mid = l+(r-l)/2;\\n            //base case\\n            if(nums[mid]>nums[(mid+1)%n])\\n            {\\n                return mid;\\n            }\\n            //base case\\n            else if(nums[mid]<nums[(mid-1)%n])\\n            {\\n                return (mid-1)%n;\\n            }\\n            //addressing 3 equal\\n            if(nums[l] == nums[mid] && nums[mid] == nums[r])\\n            {\\n                if(nums[l]>nums[(l+1)%n])\\n                {\\n                    return l;\\n                }\\n                l = (l+1)%n;\\n                if(nums[r]<nums[(r+n-1)%n])\\n                {\\n                    return r;\\n                }\\n                r = (r+n-1)%n;\\n            }\\n            //addressing 2 equal\\n            if(nums[l] == nums[mid] && nums[mid] < nums[r])\\n            {\\n                l = (mid+1)%n;\\n            } \\n            else if(nums[l] > nums[mid] && nums[mid] == nums[r])\\n            {\\n                r = (mid+n-1)%n;\\n            }\\n            //no equal normal conditions\\n            if(nums[mid]>nums[l])\\n            {\\n                l = (mid+1)%n;\\n            } \\n            else if(nums[mid]<nums[r])\\n            {\\n                r = (mid+n-1)%n;\\n            }\\n        }\\n        return -1;\\n    }\\n    public static boolean normalBinarySearch(int[] nums, int target, int l, int r)\\n    {\\n        int n = nums.length;\\n        while(l<=r)\\n        {\\n            int mid = l+(r-l)/2;\\n            if(target==nums[mid])\\n            {\\n                return true;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                r = mid-1;\\n            } \\n            else \\n            {\\n                l = mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shivaprashad2003",
                        "content": "complexity doesnt matter in this ?\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Thecodermachine",
                        "content": "see this problem is to search the element in rotated sorted array and most importantly it contain duplicates element we can do by using concept of simple binary search without using the concept of pivot element   "
                    }
                ]
            },
            {
                "id": 1733544,
                "content": [
                    {
                        "username": "shrey802",
                        "content": "I just did a linear search that\\'s it! I feel it\\'s the same question like search in rotated sorted array only the difference is return true or false instead of index."
                    },
                    {
                        "username": "BatMe",
                        "content": "You need to think of applying Binary search this is why the question is rated medium\\n"
                    },
                    {
                        "username": "saisysubarashi",
                        "content": "me too. i feel like my solution was wrong but it was accepted :|"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "I tried to solve this using binary search recursively and the code is working but iam unable to find the time complexity of this solution.\\nI request leetcode community to explain the complexity of this solution.\\n______________________________________________\\n______________________________________________\\nbool solve(int l,int h,vector<int>& nums, int k) {\\n    while(l<=h){\\n        int mid=l+(h-l)/2;\\n        if(nums[mid]==k)return 1;\\n        return solve(l,mid-1,nums,k) || solve(mid+1,h,nums,k);\\n    }return 0;\\n}\\n    bool search(vector<int>& nums, int target) {\\n        return solve(0,nums.size()-1,nums,target);\\n    }"
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "trid to solve this problem by using binary search algorithm but only three condition satisfied then used set and now all test passed ."
                    },
                    {
                        "username": "Asliddin70",
                        "content": "why this problem is in medium category it is by far the easiest I have ever solved with one line js code"
                    },
                    {
                        "username": "harryharanr",
                        "content": "Can we assume the largest number in the array is not duplicated?"
                    },
                    {
                        "username": "coffeeCoder69",
                        "content": "\\u2757\\u2757\\u2757   **Can anyone tell me what is wrong in this logic?**  \\u2757\\u2757\\u2757\\n\\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int n = nums.length;\\n        if(n<3)\\n        {\\n            for(int i = 0;i<n;i++)\\n            {\\n                if(target==nums[i])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        int pivot = findPivotIndex(nums);\\n        if(pivot==n-1)\\n        {\\n            return normalBinarySearch(nums, target, 0,n-1);\\n        }\\n        boolean res = normalBinarySearch(nums, target, 0,pivot);\\n        if(!res)\\n        {\\n            res = normalBinarySearch(nums, target, pivot+1,n-1);\\n        }\\n        return res;\\n    }\\n    public static int findPivotIndex(int[] nums)\\n    {\\n        int l = 0;\\n        int n = nums.length;\\n        int r = n-1;\\n        \\n        while(l<=r)\\n        {\\n            int mid = l+(r-l)/2;\\n            //base case\\n            if(nums[mid]>nums[(mid+1)%n])\\n            {\\n                return mid;\\n            }\\n            //base case\\n            else if(nums[mid]<nums[(mid-1)%n])\\n            {\\n                return (mid-1)%n;\\n            }\\n            //addressing 3 equal\\n            if(nums[l] == nums[mid] && nums[mid] == nums[r])\\n            {\\n                if(nums[l]>nums[(l+1)%n])\\n                {\\n                    return l;\\n                }\\n                l = (l+1)%n;\\n                if(nums[r]<nums[(r+n-1)%n])\\n                {\\n                    return r;\\n                }\\n                r = (r+n-1)%n;\\n            }\\n            //addressing 2 equal\\n            if(nums[l] == nums[mid] && nums[mid] < nums[r])\\n            {\\n                l = (mid+1)%n;\\n            } \\n            else if(nums[l] > nums[mid] && nums[mid] == nums[r])\\n            {\\n                r = (mid+n-1)%n;\\n            }\\n            //no equal normal conditions\\n            if(nums[mid]>nums[l])\\n            {\\n                l = (mid+1)%n;\\n            } \\n            else if(nums[mid]<nums[r])\\n            {\\n                r = (mid+n-1)%n;\\n            }\\n        }\\n        return -1;\\n    }\\n    public static boolean normalBinarySearch(int[] nums, int target, int l, int r)\\n    {\\n        int n = nums.length;\\n        while(l<=r)\\n        {\\n            int mid = l+(r-l)/2;\\n            if(target==nums[mid])\\n            {\\n                return true;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                r = mid-1;\\n            } \\n            else \\n            {\\n                l = mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shivaprashad2003",
                        "content": "complexity doesnt matter in this ?\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Thecodermachine",
                        "content": "see this problem is to search the element in rotated sorted array and most importantly it contain duplicates element we can do by using concept of simple binary search without using the concept of pivot element   "
                    }
                ]
            },
            {
                "id": 1729508,
                "content": [
                    {
                        "username": "shrey802",
                        "content": "I just did a linear search that\\'s it! I feel it\\'s the same question like search in rotated sorted array only the difference is return true or false instead of index."
                    },
                    {
                        "username": "BatMe",
                        "content": "You need to think of applying Binary search this is why the question is rated medium\\n"
                    },
                    {
                        "username": "saisysubarashi",
                        "content": "me too. i feel like my solution was wrong but it was accepted :|"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "I tried to solve this using binary search recursively and the code is working but iam unable to find the time complexity of this solution.\\nI request leetcode community to explain the complexity of this solution.\\n______________________________________________\\n______________________________________________\\nbool solve(int l,int h,vector<int>& nums, int k) {\\n    while(l<=h){\\n        int mid=l+(h-l)/2;\\n        if(nums[mid]==k)return 1;\\n        return solve(l,mid-1,nums,k) || solve(mid+1,h,nums,k);\\n    }return 0;\\n}\\n    bool search(vector<int>& nums, int target) {\\n        return solve(0,nums.size()-1,nums,target);\\n    }"
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "trid to solve this problem by using binary search algorithm but only three condition satisfied then used set and now all test passed ."
                    },
                    {
                        "username": "Asliddin70",
                        "content": "why this problem is in medium category it is by far the easiest I have ever solved with one line js code"
                    },
                    {
                        "username": "harryharanr",
                        "content": "Can we assume the largest number in the array is not duplicated?"
                    },
                    {
                        "username": "coffeeCoder69",
                        "content": "\\u2757\\u2757\\u2757   **Can anyone tell me what is wrong in this logic?**  \\u2757\\u2757\\u2757\\n\\n```\\nclass Solution {\\n    public boolean search(int[] nums, int target) {\\n        int n = nums.length;\\n        if(n<3)\\n        {\\n            for(int i = 0;i<n;i++)\\n            {\\n                if(target==nums[i])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        int pivot = findPivotIndex(nums);\\n        if(pivot==n-1)\\n        {\\n            return normalBinarySearch(nums, target, 0,n-1);\\n        }\\n        boolean res = normalBinarySearch(nums, target, 0,pivot);\\n        if(!res)\\n        {\\n            res = normalBinarySearch(nums, target, pivot+1,n-1);\\n        }\\n        return res;\\n    }\\n    public static int findPivotIndex(int[] nums)\\n    {\\n        int l = 0;\\n        int n = nums.length;\\n        int r = n-1;\\n        \\n        while(l<=r)\\n        {\\n            int mid = l+(r-l)/2;\\n            //base case\\n            if(nums[mid]>nums[(mid+1)%n])\\n            {\\n                return mid;\\n            }\\n            //base case\\n            else if(nums[mid]<nums[(mid-1)%n])\\n            {\\n                return (mid-1)%n;\\n            }\\n            //addressing 3 equal\\n            if(nums[l] == nums[mid] && nums[mid] == nums[r])\\n            {\\n                if(nums[l]>nums[(l+1)%n])\\n                {\\n                    return l;\\n                }\\n                l = (l+1)%n;\\n                if(nums[r]<nums[(r+n-1)%n])\\n                {\\n                    return r;\\n                }\\n                r = (r+n-1)%n;\\n            }\\n            //addressing 2 equal\\n            if(nums[l] == nums[mid] && nums[mid] < nums[r])\\n            {\\n                l = (mid+1)%n;\\n            } \\n            else if(nums[l] > nums[mid] && nums[mid] == nums[r])\\n            {\\n                r = (mid+n-1)%n;\\n            }\\n            //no equal normal conditions\\n            if(nums[mid]>nums[l])\\n            {\\n                l = (mid+1)%n;\\n            } \\n            else if(nums[mid]<nums[r])\\n            {\\n                r = (mid+n-1)%n;\\n            }\\n        }\\n        return -1;\\n    }\\n    public static boolean normalBinarySearch(int[] nums, int target, int l, int r)\\n    {\\n        int n = nums.length;\\n        while(l<=r)\\n        {\\n            int mid = l+(r-l)/2;\\n            if(target==nums[mid])\\n            {\\n                return true;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                r = mid-1;\\n            } \\n            else \\n            {\\n                l = mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shivaprashad2003",
                        "content": "complexity doesnt matter in this ?\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Thecodermachine",
                        "content": "see this problem is to search the element in rotated sorted array and most importantly it contain duplicates element we can do by using concept of simple binary search without using the concept of pivot element   "
                    }
                ]
            }
        ]
    }
]