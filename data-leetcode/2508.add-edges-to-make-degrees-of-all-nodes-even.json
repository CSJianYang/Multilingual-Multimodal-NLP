[
    {
        "title": "Add Edges to Make Degrees of All Nodes Even",
        "question_content": "There is an undirected graph consisting of n nodes numbered from 1 to n. You are given the integer n and a 2D array edges where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi. The graph can be disconnected.\nYou can add at most two additional edges (possibly none) to this graph so that there are no repeated edges and no self-loops.\nReturn true if it is possible to make the degree of each node in the graph even, otherwise return false.\nThe degree of a node is the number of edges connected to it.\n&nbsp;\nExample 1:\n\nInput: n = 5, edges = [[1,2],[2,3],[3,4],[4,2],[1,4],[2,5]]\nOutput: true\nExplanation: The above diagram shows a valid way of adding an edge.\nEvery node in the resulting graph is connected to an even number of edges.\n\nExample 2:\n\nInput: n = 4, edges = [[1,2],[3,4]]\nOutput: true\nExplanation: The above diagram shows a valid way of adding two edges.\nExample 3:\n\nInput: n = 4, edges = [[1,2],[1,3],[1,4]]\nOutput: false\nExplanation: It is not possible to obtain a valid graph with adding at most 2 edges.\n&nbsp;\nConstraints:\n\n\t3 <= n <= 105\n\t2 <= edges.length <= 105\n\tedges[i].length == 2\n\t1 <= ai, bi <= n\n\tai != bi\n\tThere are no repeated edges.",
        "solutions": [
            {
                "id": 2923720,
                "title": "python-stright-forward-with-explanation",
                "content": "# **Intuition**\\nThe number of odd degree node must be even: 0,2,4,...\\n`if odd.size() == 0, return True`\\n`if odd.size() == 2, TODO`\\n`if odd.size() == 4, TODO`\\n`if odd.size() > 4, return false`\\n<br>\\n\\n# **Explanation**\\n`find the mapping G` where `G[i]` is the neighbour set of node `i`.\\nFind out the list of nodes with odd degree.\\n\\nIn case if we have 2 odds:\\noption1:  \\nwe can link them together,\\nif they are not neighbour.\\n\\noption2: \\nwe can link both them to node `i`,\\nif node `i` is not neighbour of either of them.\\n\\notherwise return false.\\n\\nIn case if we have 4 odds `a,b,c,d`\\noption1:  We can link `(a,b)` and `(c,d)`\\noption2:  We can link `(a,c)` and `(b,d)`\\noption3:  We can link `(a,d)` and `(c,b)`\\notherwise return false.\\n<br>\\n\\n# **Complexity**\\nTime `O(edges)`\\nSpace `O(edges)`\\n<br>\\n\\n\\n**Python**\\n```py\\n    def isPossible(self, n, edges):\\n        G = [set() for i in range(n)]\\n        for i,j in edges:\\n            G[i-1].add(j-1)\\n            G[j-1].add(i-1)\\n        odd = [i for i in range(n) if len(G[i]) % 2]\\n\\n        def f(a,b):\\n            return a not in G[b]\\n\\n        if len(odd) == 2:\\n            a, b = odd\\n            return any(f(a,i) and f(b,i) for i in range(n))\\n\\n        if len(odd) == 4:\\n            a,b,c,d = odd\\n            return  f(a,b) and f(c,d) or \\\\\\n                    f(a,c) and f(b,d) or \\\\\\n                    f(a,d) and f(c,b)\\n        return len(odd) == 0\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def isPossible(self, n, edges):\\n        G = [set() for i in range(n)]\\n        for i,j in edges:\\n            G[i-1].add(j-1)\\n            G[j-1].add(i-1)\\n        odd = [i for i in range(n) if len(G[i]) % 2]\\n\\n        def f(a,b):\\n            return a not in G[b]\\n\\n        if len(odd) == 2:\\n            a, b = odd\\n            return any(f(a,i) and f(b,i) for i in range(n))\\n\\n        if len(odd) == 4:\\n            a,b,c,d = odd\\n            return  f(a,b) and f(c,d) or \\\\\\n                    f(a,c) and f(b,d) or \\\\\\n                    f(a,d) and f(c,b)\\n        return len(odd) == 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2923531,
                "title": "adjacency-list-of-hashsets",
                "content": "We convert `edges` to an adjacency list. We use a hash set so we can check for duplicates later.\\n\\nThen, we collect all nodes with odd degree into `odd`. There can be zero, two or four odd nodes that we can potentially make even.\\n\\nIf we have two odd nodes, we can connect them to each other, or to some other node if it does not produce duplicate edges.\\n\\nFor four odd nodes, we can only connect them between themselves.\\n\\n**C++**\\n```cpp\\nbool isPossible(int n, vector<vector<int>>& edges) {\\n    vector<unordered_set<int>> al(n + 1);\\n    vector<int> odd;    \\n    for (auto &e : edges) {\\n        al[e[0]].insert(e[1]);\\n        al[e[1]].insert(e[0]);\\n    }\\n    for (int i = 1; i <= n; ++i)\\n        if (al[i].size() % 2 == 1)\\n            odd.push_back(i);\\n    if (odd.size() == 2)\\n        for (int i = 1; i <= n; ++i)\\n            if (al[odd[0]].count(i) == 0 && al[odd[1]].count(i) == 0)\\n                return true;\\n    if (odd.size() == 4)\\n        return (al[odd[0]].count(odd[1]) == 0 && al[odd[2]].count(odd[3]) == 0)\\n            || (al[odd[0]].count(odd[2]) == 0 && al[odd[1]].count(odd[3]) == 0)\\n            || (al[odd[0]].count(odd[3]) == 0 && al[odd[1]].count(odd[2]) == 0);\\n    return odd.size() == 0;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nbool isPossible(int n, vector<vector<int>>& edges) {\\n    vector<unordered_set<int>> al(n + 1);\\n    vector<int> odd;    \\n    for (auto &e : edges) {\\n        al[e[0]].insert(e[1]);\\n        al[e[1]].insert(e[0]);\\n    }\\n    for (int i = 1; i <= n; ++i)\\n        if (al[i].size() % 2 == 1)\\n            odd.push_back(i);\\n    if (odd.size() == 2)\\n        for (int i = 1; i <= n; ++i)\\n            if (al[odd[0]].count(i) == 0 && al[odd[1]].count(i) == 0)\\n                return true;\\n    if (odd.size() == 4)\\n        return (al[odd[0]].count(odd[1]) == 0 && al[odd[2]].count(odd[3]) == 0)\\n            || (al[odd[0]].count(odd[2]) == 0 && al[odd[1]].count(odd[3]) == 0)\\n            || (al[odd[0]].count(odd[3]) == 0 && al[odd[1]].count(odd[2]) == 0);\\n    return odd.size() == 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2923490,
                "title": "easy-idea-with-picture-adjacency-list-with-hashset-c",
                "content": "##### Please upvote if you like the post \\uD83D\\uDE0A\\n\\nThe idea is very simple we have to add atmost 2 edges so the question should have atmost 4 points with odd degrees if it is more we can directly return false;\\n\\n* if the number of points with odd degree is odd then also we can never reach the answer as some of the other edge will become odd \\n* hence the points with odd degrees should be even that gives two cases and they would be \\n\\n![image](https://assets.leetcode.com/users/images/0ed5d37d-79e4-44eb-bcfd-c3a7d10c70bf_1671335787.109381.png)\\n\\nhence the code would be :- \\n\\nshort version :- \\n\\n```c++\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<unordered_set<int>> adj(n + 1);\\n        for(vector<int>& e : edges){\\n            adj[e[0]].insert(e[1]);\\n            adj[e[1]].insert(e[0]);\\n        }\\n        vector<int> odds;\\n        for(int i = 0; i <= n ; i++){\\n            if(adj[i].size() & 1){\\n                odds.push_back(i);\\n            } \\n        }\\n        if(odds.size() == 0) return true;\\n        if(odds.size() > 4 or odds.size() % 2 != 0) return false;\\n        if(odds.size() == 4){\\n            int a = odds[0] , b = odds[1] , c = odds[2] , d = odds[3];\\n            return (adj[a].find(d) == adj[a].end() and f2= adj[b].find(c) == adj[b].end()) or  (adj[a].find(b) == adj[a].end() and f4= adj[c].find(d) == adj[c].end()) or (f3 = adj[a].find(c) == adj[a].end() and f4= adj[b].find(d) == adj[b].end())\\n        }else{\\n            int a = odds[0] , b = odds[1]; \\n            bool flag = adj[a].find(b) == adj[a].end();\\n            if(flag) return true;\\n            for(int i = 1; i <= n ;i++){\\n                if(a != i and b != i and adj[a].find(i) == adj[a].end() and adj[b].find(i) == adj[b].end()) return true;\\n            }\\n            return false;\\n        }\\n    }\\n};\\n```\\n\\n`Time complexity : O(n)`\\n`Space complexity: O(n2) [for full connected graph adjaceny matrix would go n2]`\\n\\nExplained code :- \\n\\n```c++\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<unordered_set<int>> adj(n + 1);\\n        for(vector<int>& e : edges){\\n            adj[e[0]].insert(e[1]);\\n            adj[e[1]].insert(e[0]);\\n        }\\n        vector<int> odds;\\n        for(int i = 0; i <= n ; i++){\\n            if(adj[i].size() & 1){\\n                odds.push_back(i);\\n            } \\n        }\\n        // if no odd edges return true\\n        if(odds.size() == 0) return true;\\n        // if odd edges are grteater than 4 or not 2 or 4 it will be always be impossible to make \\n        if(odds.size() > 4 or odds.size() % 2 != 0) return false;\\n        // case 1 : if size is 4\\n        if(odds.size() == 4){\\n            // check for a --- d and c -- b if both are not present we can join them\\n            int a = odds[0] , b = odds[1] , c = odds[2] , d = odds[3];\\n            bool f1 = adj[a].find(d) == adj[a].end() , f2= adj[b].find(c) == adj[b].end();\\n            if(f1 and f2) return true;\\n            // similar check for a -- b and c -- d\\n            bool f3 = adj[a].find(b) == adj[a].end() , f4= adj[c].find(d) == adj[c].end();\\n            if(f3 and f4) return true;\\n            // check for a -- c  and b -- d\\n             f3 = adj[a].find(c) == adj[a].end() , f4= adj[b].find(d) == adj[b].end();\\n            if(f3 and f4) return true;\\n            // if not possible return \\n            return false;\\n        }else{\\n            int a = odds[0] , b = odds[1]; \\n            // if there is no edge between them we cann add so return true\\n            bool flag = adj[a].find(b) == adj[a].end();\\n            if(flag) return true;\\n            // else wee will find a node for which bith a  , b are not neighbours if such thing\\n            // exists we can make a path through that node \\n            for(int i = 1; i <= n ;i++){\\n                if(a != i and b != i and adj[a].find(i) == adj[a].end() and adj[b].find(i) == adj[b].end()) return true;\\n            }\\n            return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<unordered_set<int>> adj(n + 1);\\n        for(vector<int>& e : edges){\\n            adj[e[0]].insert(e[1]);\\n            adj[e[1]].insert(e[0]);\\n        }\\n        vector<int> odds;\\n        for(int i = 0; i <= n ; i++){\\n            if(adj[i].size() & 1){\\n                odds.push_back(i);\\n            } \\n        }\\n        if(odds.size() == 0) return true;\\n        if(odds.size() > 4 or odds.size() % 2 != 0) return false;\\n        if(odds.size() == 4){\\n            int a = odds[0] , b = odds[1] , c = odds[2] , d = odds[3];\\n            return (adj[a].find(d) == adj[a].end() and f2= adj[b].find(c) == adj[b].end()) or  (adj[a].find(b) == adj[a].end() and f4= adj[c].find(d) == adj[c].end()) or (f3 = adj[a].find(c) == adj[a].end() and f4= adj[b].find(d) == adj[b].end())\\n        }else{\\n            int a = odds[0] , b = odds[1]; \\n            bool flag = adj[a].find(b) == adj[a].end();\\n            if(flag) return true;\\n            for(int i = 1; i <= n ;i++){\\n                if(a != i and b != i and adj[a].find(i) == adj[a].end() and adj[b].find(i) == adj[b].end()) return true;\\n            }\\n            return false;\\n        }\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<unordered_set<int>> adj(n + 1);\\n        for(vector<int>& e : edges){\\n            adj[e[0]].insert(e[1]);\\n            adj[e[1]].insert(e[0]);\\n        }\\n        vector<int> odds;\\n        for(int i = 0; i <= n ; i++){\\n            if(adj[i].size() & 1){\\n                odds.push_back(i);\\n            } \\n        }\\n        // if no odd edges return true\\n        if(odds.size() == 0) return true;\\n        // if odd edges are grteater than 4 or not 2 or 4 it will be always be impossible to make \\n        if(odds.size() > 4 or odds.size() % 2 != 0) return false;\\n        // case 1 : if size is 4\\n        if(odds.size() == 4){\\n            // check for a --- d and c -- b if both are not present we can join them\\n            int a = odds[0] , b = odds[1] , c = odds[2] , d = odds[3];\\n            bool f1 = adj[a].find(d) == adj[a].end() , f2= adj[b].find(c) == adj[b].end();\\n            if(f1 and f2) return true;\\n            // similar check for a -- b and c -- d\\n            bool f3 = adj[a].find(b) == adj[a].end() , f4= adj[c].find(d) == adj[c].end();\\n            if(f3 and f4) return true;\\n            // check for a -- c  and b -- d\\n             f3 = adj[a].find(c) == adj[a].end() , f4= adj[b].find(d) == adj[b].end();\\n            if(f3 and f4) return true;\\n            // if not possible return \\n            return false;\\n        }else{\\n            int a = odds[0] , b = odds[1]; \\n            // if there is no edge between them we cann add so return true\\n            bool flag = adj[a].find(b) == adj[a].end();\\n            if(flag) return true;\\n            // else wee will find a node for which bith a  , b are not neighbours if such thing\\n            // exists we can make a path through that node \\n            for(int i = 1; i <= n ;i++){\\n                if(a != i and b != i and adj[a].find(i) == adj[a].end() and adj[b].find(i) == adj[b].end()) return true;\\n            }\\n            return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923492,
                "title": "degree-count-and-case-analysis",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet us count the degree of all the nodes first. Now let\\'s analyse the following cases:\\n<ul>\\n    <li> <b>Every node has an even degree</b>: We don\\'t need to add any extra edges here and we can return true.</li>\\n    <li> <b> One(Odd number) node has odd degree:</b> We can\\'t make the degree of each node with two edges. A single edge using this node will create one node with odd degree and one node with even degree.</li>\\n<li><b>Two nodes have odd degree:</b> We can use one edge to connect the two nodes to make their degree even. But what if they are already connected ? In this case we can find another node that has no edge with either of them and connect that node with both of them. As a result every node will have even degree.\\n<li><b>Four nodes have odd degree:</b> We can try all possible combinations(there can be three ways) to add two edges between them and see if it\\'s possible to satisfy the condition.\\n<li><b>Other cases:</b> It is not possible to make all the degree even with just two edges anymore.\\n</ul>\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int>degree(n+1);\\n        map<pair<int,int>,bool>hasEdge;\\n        for(auto&e:edges){\\n            int u = e[0];\\n            int v = e[1];\\n            degree[u]++;\\n            degree[v]++;\\n            hasEdge[{u,v}]= 1;\\n            hasEdge[{v,u}]= 1;\\n        }\\n        vector<int>odd;\\n        for(int i=1;i<=n;i++){\\n            if(degree[i]%2) odd.push_back(i);\\n        }\\n        if(odd.size()%2 || odd.size()>4) return false;\\n        if(odd.size()==0) return true;\\n        if(odd.size()==2){\\n            int a = odd[0];\\n            int b = odd[1];\\n            if(hasEdge[{a,b}]){\\n                for(int i=1;i<=n;i++){\\n                    if(i==a || i==b)continue;\\n                    if(!hasEdge[{i,a}] && !hasEdge[{i,b}]) return true;\\n                }\\n                return false;\\n            }else return true;\\n        }\\n        else if(odd.size()==4){\\n            int a = odd[0];\\n            int b = odd[1];\\n            int c = odd[2];\\n            int d = odd[3];\\n            if(!hasEdge[{a,b}] && !hasEdge[{c,d}]) return true;\\n            if(!hasEdge[{a,c}] && !hasEdge[{b,d}]) return true;\\n            if(!hasEdge[{a,d}] && !hasEdge[{c,b}]) return true;\\n            return false;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int>degree(n+1);\\n        map<pair<int,int>,bool>hasEdge;\\n        for(auto&e:edges){\\n            int u = e[0];\\n            int v = e[1];\\n            degree[u]++;\\n            degree[v]++;\\n            hasEdge[{u,v}]= 1;\\n            hasEdge[{v,u}]= 1;\\n        }\\n        vector<int>odd;\\n        for(int i=1;i<=n;i++){\\n            if(degree[i]%2) odd.push_back(i);\\n        }\\n        if(odd.size()%2 || odd.size()>4) return false;\\n        if(odd.size()==0) return true;\\n        if(odd.size()==2){\\n            int a = odd[0];\\n            int b = odd[1];\\n            if(hasEdge[{a,b}]){\\n                for(int i=1;i<=n;i++){\\n                    if(i==a || i==b)continue;\\n                    if(!hasEdge[{i,a}] && !hasEdge[{i,b}]) return true;\\n                }\\n                return false;\\n            }else return true;\\n        }\\n        else if(odd.size()==4){\\n            int a = odd[0];\\n            int b = odd[1];\\n            int c = odd[2];\\n            int d = odd[3];\\n            if(!hasEdge[{a,b}] && !hasEdge[{c,d}]) return true;\\n            if(!hasEdge[{a,c}] && !hasEdge[{b,d}]) return true;\\n            if(!hasEdge[{a,d}] && !hasEdge[{c,b}]) return true;\\n            return false;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923496,
                "title": "python-consider-2-4-odd-vertices-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs the calculation of degree of each vertex followed by considering several cases for additional edges. Time complexity is linear: **O(N)**. Space complexity is linear: **O(N)**. \\n****\\n\\n**Comment.** It is obvious that the only cases when the solution exists are either 0, 2 or 4 vertices of odd degree:\\n1. Zero is trivial.\\n2. For 2 vertices, we check that both of them can be connected to a third one (or to each other) with which neither of them share an edge.\\n3. For 4 vertices, we check three possible cases of connecting vertices to each other (we can\\'t connect them to other vertices, because we can only use 2 additional edges).\\n\\n**Python.**\\n```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        \\n        G = defaultdict(set)\\n        for i,j in edges:\\n            G[i-1].add(j-1)\\n            G[j-1].add(i-1)\\n        \\n        odd = [i for i in range(n) if len(G[i]) % 2]\\n        \\n        print(odd)\\n        \\n        if len(odd) == 2:\\n            j, k = odd\\n            return not all(j in G[i] or k in G[i] for i in range(n))        \\n        \\n        if len(odd) == 4:\\n            i, j, k, l = odd\\n            return not (i in G[j] or k in G[l]) or \\\\\\n                   not (i in G[k] or j in G[l]) or \\\\\\n                   not (i in G[l] or j in G[k])\\n        \\n        return not len(odd)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        \\n        G = defaultdict(set)\\n        for i,j in edges:\\n            G[i-1].add(j-1)\\n            G[j-1].add(i-1)\\n        \\n        odd = [i for i in range(n) if len(G[i]) % 2]\\n        \\n        print(odd)\\n        \\n        if len(odd) == 2:\\n            j, k = odd\\n            return not all(j in G[i] or k in G[i] for i in range(n))        \\n        \\n        if len(odd) == 4:\\n            i, j, k, l = odd\\n            return not (i in G[j] or k in G[l]) or \\\\\\n                   not (i in G[k] or j in G[l]) or \\\\\\n                   not (i in G[l] or j in G[k])\\n        \\n        return not len(odd)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932216,
                "title": "using-list-of-hashsets-and-different-cases-analysis",
                "content": "**Here we can get 3 conditions as at most 2 nodes is mentioned in the question**\\n1. if all even degree nodes are present **count(odd degree nodes)=0**\\n2. if **count(odd degree nodes)=2** *as we can add 1 or 2 edges*\\n3. if **count(odd degree nodes)=4** *we can add 2 edges*\\n\\n  Let us suppose **count(odd degree nodes)=2** we can have *2 conditions*\\n1.  ***if odd degree nodes are not indivually connected with one edge we can connect it*** \\n2.  ***if odd degree nodes are individually connected then we will find one common node from where both nodes are not connected which will collectively make all degree of nodes as even***\\n![image](https://assets.leetcode.com/users/images/5d3db08f-0ad0-4b9a-af7d-4de59ea07bad_1671539098.4992461.jpeg)\\nhere in the above graph *we can see nodes(1,2) are not connected with (4,5,6) so we can connect two nodes with any of the (4,5,6)nodes to increase the degree count by 2 which will result in adding two edges and overall degree count of all nodes will remain even*\\n**this can be one of the result**\\n![image](https://assets.leetcode.com/users/images/ef2a0f43-25da-49ee-89f0-87e76c382f5c_1671539369.900372.jpeg)\\n\\nLet us suppose **count(odd degree nodes)=4** we can have *3 conditions*\\n**!(a,b)** *means in a\\'s set b is not present and b\\'s set a is not present*\\n1. **!(1,2) & !(3,4)** should hold true, we can draw an edge btween 1-2 & 3-4\\n2. **!(1,3) & !(2,4)** should hold true, we can draw an edge btween 1-3 & 2-4\\n3. **!(1,4) & !(2,3)** should hold true, we can draw an edge btween 1-4 & 2-3\\n\\n##### *Below is the implemented code*\\n```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        //storing adj list in list of hashsets\\n        List<Set<Integer>> l=new ArrayList<>();\\n        int degree[]=new int[n+1];\\n        for(int i=0;i<n+1;i++){\\n            l.add(new HashSet<>());\\n        }\\n        //storing the adj list and counting the degree\\n        for(List<Integer> x:edges){\\n            l.get(x.get(0)).add(x.get(1));\\n            l.get(x.get(1)).add(x.get(0));\\n            degree[x.get(0)]++;\\n            degree[x.get(1)]++;\\n        }\\n        //for storing odd degrees nodes\\n        List<Integer> odd=new ArrayList<>();\\n        for(int i=1;i<n+1;i++){\\n            if(degree[i]%2==1){\\n                odd.add(i);\\n            }\\n        }\\n     // if allnodes degrees are even\\n        if(odd.size()==0)return true;\\n     // if number of odd degree nodes are 2 then we arise 2 cond  \\n        if(odd.size()==2){\\n            Set<Integer> s1=l.get(odd.get(0));\\n            Set<Integer> s2=l.get(odd.get(1));\\n            //if two nodes individually not connected\\n             if(!s1.contains(odd.get(1))){\\n                 return true;\\n             }\\n            //if two nodes are individually connected but can connect with some other even nodes and make all even degree\\n            else{\\n                for(int i=1;i<n+1;i++){\\n                    if(!s1.contains(i) && !s2.contains(i)){\\n                        return true;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        //if degree of odd nodes are 4 then we can get 4 cond and manually check it\\n        if(odd.size()==4){\\n            Set<Integer> s1=l.get(odd.get(0));//1\\n            Set<Integer> s2=l.get(odd.get(1));//2\\n            Set<Integer> s3=l.get(odd.get(2));//3\\n            Set<Integer> s4=l.get(odd.get(3));//4\\n            \\n            //first cond !(1,2) && !(3,4)\\n            if(!s1.contains(odd.get(1)) && !s2.contains(odd.get(0)) && !s3.contains(odd.get(3)) && !s4.contains(odd.get(2))){\\n                return true;\\n            }\\n            //second cond !(1,3) && !(2,4)\\n            else if(!s1.contains(odd.get(2)) && !s3.contains(odd.get(0)) && !s2.contains(odd.get(3)) && !s4.contains(odd.get(1))){\\n                return true;\\n            }\\n            //third cond second cond !(1,4) && !(2,3)\\n            else if(!s1.contains(odd.get(3)) && !s4.contains(odd.get(0)) && !s3.contains(odd.get(1)) && !s2.contains(odd.get(2))){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n```\\n*TC~ O(E+V)*\\n*SC~O(V)*\\n#####  please upvote if u like my solution",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        //storing adj list in list of hashsets\\n        List<Set<Integer>> l=new ArrayList<>();\\n        int degree[]=new int[n+1];\\n        for(int i=0;i<n+1;i++){\\n            l.add(new HashSet<>());\\n        }\\n        //storing the adj list and counting the degree\\n        for(List<Integer> x:edges){\\n            l.get(x.get(0)).add(x.get(1));\\n            l.get(x.get(1)).add(x.get(0));\\n            degree[x.get(0)]++;\\n            degree[x.get(1)]++;\\n        }\\n        //for storing odd degrees nodes\\n        List<Integer> odd=new ArrayList<>();\\n        for(int i=1;i<n+1;i++){\\n            if(degree[i]%2==1){\\n                odd.add(i);\\n            }\\n        }\\n     // if allnodes degrees are even\\n        if(odd.size()==0)return true;\\n     // if number of odd degree nodes are 2 then we arise 2 cond  \\n        if(odd.size()==2){\\n            Set<Integer> s1=l.get(odd.get(0));\\n            Set<Integer> s2=l.get(odd.get(1));\\n            //if two nodes individually not connected\\n             if(!s1.contains(odd.get(1))){\\n                 return true;\\n             }\\n            //if two nodes are individually connected but can connect with some other even nodes and make all even degree\\n            else{\\n                for(int i=1;i<n+1;i++){\\n                    if(!s1.contains(i) && !s2.contains(i)){\\n                        return true;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        //if degree of odd nodes are 4 then we can get 4 cond and manually check it\\n        if(odd.size()==4){\\n            Set<Integer> s1=l.get(odd.get(0));//1\\n            Set<Integer> s2=l.get(odd.get(1));//2\\n            Set<Integer> s3=l.get(odd.get(2));//3\\n            Set<Integer> s4=l.get(odd.get(3));//4\\n            \\n            //first cond !(1,2) && !(3,4)\\n            if(!s1.contains(odd.get(1)) && !s2.contains(odd.get(0)) && !s3.contains(odd.get(3)) && !s4.contains(odd.get(2))){\\n                return true;\\n            }\\n            //second cond !(1,3) && !(2,4)\\n            else if(!s1.contains(odd.get(2)) && !s3.contains(odd.get(0)) && !s2.contains(odd.get(3)) && !s4.contains(odd.get(1))){\\n                return true;\\n            }\\n            //third cond second cond !(1,4) && !(2,3)\\n            else if(!s1.contains(odd.get(3)) && !s4.contains(odd.get(0)) && !s3.contains(odd.get(1)) && !s2.contains(odd.get(2))){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923681,
                "title": "java-with-simple-explanations",
                "content": "# Intuition\\nThere are only 3 legic cases to dig up into. \\nCase-1: when all vertices of even deg => true\\nCase-2: when 2 vertices of odd degree\\nCase-3: when 4 vertices of odd degree\\n\\n# Approach\\nWhen 2 vertices of odd degree - 2 cases when we can fix the degree to even: if for those 2 vertices u, v we can connect them with an edge or we can connect both of them with an edge to some vertex `w`\\n\\nWhen 4 vertices of odd degree . Then consider all combinations of 2-pairs of vertices (a,b,c,d). There are 3 combinations:\\n<(a,b),(c,d)> , <(a,c), (b,d)>, <(a, d), (b, c)>. If there is at least one such combination such that each pair is not connected then we can fix them by connecting them with 2 edges.\\n\\nFor all other cases return false.\\n# Complexity\\n- Time complexity:\\nO(E) \\n\\n- Space complexity:\\nO(E)\\n# Code\\n```\\nclass Solution {\\n   \\n    List<Set<Integer>> adjList;\\n    \\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        adjList = new ArrayList<>();\\n        List<Integer> odds = new ArrayList<>();\\n        for(int i = 1; i<=n; i++) {\\n            adjList.add(new HashSet<>());\\n        }\\n        for(List<Integer> edge: edges) {\\n            int x = edge.get(0) - 1, y = edge.get(1) - 1;\\n            adjList.get(x).add(y);\\n            adjList.get(y).add(x);\\n        }\\n        int cntOdd = 0;\\n        for(int i = 0; i< n; i++) {\\n            if(adjList.get(i).size() % 2 == 1) {\\n                cntOdd ++;\\n                odds.add(i);\\n            }\\n        }\\n        if(cntOdd == 0)\\n            return true;\\n        else if(cntOdd == 2) {\\n            Integer u = odds.get(0), v = odds.get(1);\\n            for(int k = 0; k<n; k++) {\\n                if(!adjList.get(k).contains(u) && !adjList.get(k).contains(v)) {\\n                    return true;\\n                }\\n            }\\n        } else if(cntOdd == 4) {\\n            int a = odds.get(0), b = odds.get(1), c = odds.get(2), d = odds.get(3);\\n            if((!adjList.get(a).contains(b) && !adjList.get(c).contains(d))\\n               || (!adjList.get(b).contains(c) && !adjList.get(a).contains(d))\\n               || (!adjList.get(a).contains(c) && !adjList.get(b).contains(d))\\n              ) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   \\n    List<Set<Integer>> adjList;\\n    \\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        adjList = new ArrayList<>();\\n        List<Integer> odds = new ArrayList<>();\\n        for(int i = 1; i<=n; i++) {\\n            adjList.add(new HashSet<>());\\n        }\\n        for(List<Integer> edge: edges) {\\n            int x = edge.get(0) - 1, y = edge.get(1) - 1;\\n            adjList.get(x).add(y);\\n            adjList.get(y).add(x);\\n        }\\n        int cntOdd = 0;\\n        for(int i = 0; i< n; i++) {\\n            if(adjList.get(i).size() % 2 == 1) {\\n                cntOdd ++;\\n                odds.add(i);\\n            }\\n        }\\n        if(cntOdd == 0)\\n            return true;\\n        else if(cntOdd == 2) {\\n            Integer u = odds.get(0), v = odds.get(1);\\n            for(int k = 0; k<n; k++) {\\n                if(!adjList.get(k).contains(u) && !adjList.get(k).contains(v)) {\\n                    return true;\\n                }\\n            }\\n        } else if(cntOdd == 4) {\\n            int a = odds.get(0), b = odds.get(1), c = odds.get(2), d = odds.get(3);\\n            if((!adjList.get(a).contains(b) && !adjList.get(c).contains(d))\\n               || (!adjList.get(b).contains(c) && !adjList.get(a).contains(d))\\n               || (!adjList.get(a).contains(c) && !adjList.get(b).contains(d))\\n              ) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923476,
                "title": "simple-to-understand-java-solution-with-comments",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind number of edges of each node in the graph. Now we can add atmost 2 edges. Now there can be following cases:\\n\\noddEdges==0 then return true\\n\\noddEdges>4 no ans possible\\n\\noddEdges==1 ||oddEdges==3 no ans possible because edges will connect 2 nodes\\n\\noddEdges==4 then we have to combine these 4 only and try all possible combinations\\n\\noddEdges==2 then either join the 2 nodes with odd edges or join one  node with even edge with 2 nodes with odd edge\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        // number of edges of each node\\n        int[] noe=new int[n+1];\\n        \\n        // make a graph\\n        List<List<Integer>> graph=new ArrayList<>();\\n        for(int i=0;i<=n;i++) graph.add(new ArrayList<>());\\n        for(List<Integer> c:edges){\\n            int x=c.get(0);\\n            int y=c.get(1);\\n            graph.get(x).add(y);\\n            graph.get(y).add(x);\\n            noe[x]++;\\n            noe[y]++;\\n        }\\n        \\n        // nodes with number of odd edges will be in the list\\n        List<Integer> list=new ArrayList<>();\\n        \\n        for(int i=0;i<noe.length;i++){ \\n            if(noe[i]%2==1){\\n                list.add(i);\\n            }\\n        }\\n        \\n        int odd=list.size();   \\n        \\n        //no odds\\n        if(odd==0) return true;\\n        else if(odd>4||odd==1||odd==3) return false; // we can\\'t get ans with these conditions because edges will connect 2 nodes\\n        else if(odd==4){ // if odd is 4 then we have to try out every possible combination\\n            int node1=list.get(0);\\n            int node2=list.get(1);\\n            int node3=list.get(2);\\n            int node4=list.get(3);\\n            if(checkIfLegal(graph,node1,node2) && checkIfLegal(graph,node3,node4)) return true;\\n            if(checkIfLegal(graph,node1,node3) && checkIfLegal(graph,node2,node4)) return true;\\n            if(checkIfLegal(graph,node1,node4) && checkIfLegal(graph,node2,node3)) return true;\\n        }else if(odd==2){ // if odd is 2 there are 2 conditions either join the 2 nodes with odd edges or join one node with even edge with 2 nodes with odd edge\\n            int x=list.get(0);\\n            int y=list.get(1);\\n            if(checkIfLegal(graph,y,x)) return true;\\n            for(int i=1;i<noe.length;i++){\\n                if(i==x||i==y) continue;\\n                if(checkIfLegal(graph,i,x) && checkIfLegal(graph,i,y)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    // will check if there is not a repeated edge or self loop\\n    public boolean checkIfLegal(List<List<Integer>> graph,int x,int y){\\n        for(int val:graph.get(x)) if(val==y) return false;\\n        return true;\\n    }\\n    \\n}\\n```\\n**Please Upvote if u like this solution**\\n\\n",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        // number of edges of each node\\n        int[] noe=new int[n+1];\\n        \\n        // make a graph\\n        List<List<Integer>> graph=new ArrayList<>();\\n        for(int i=0;i<=n;i++) graph.add(new ArrayList<>());\\n        for(List<Integer> c:edges){\\n            int x=c.get(0);\\n            int y=c.get(1);\\n            graph.get(x).add(y);\\n            graph.get(y).add(x);\\n            noe[x]++;\\n            noe[y]++;\\n        }\\n        \\n        // nodes with number of odd edges will be in the list\\n        List<Integer> list=new ArrayList<>();\\n        \\n        for(int i=0;i<noe.length;i++){ \\n            if(noe[i]%2==1){\\n                list.add(i);\\n            }\\n        }\\n        \\n        int odd=list.size();   \\n        \\n        //no odds\\n        if(odd==0) return true;\\n        else if(odd>4||odd==1||odd==3) return false; // we can\\'t get ans with these conditions because edges will connect 2 nodes\\n        else if(odd==4){ // if odd is 4 then we have to try out every possible combination\\n            int node1=list.get(0);\\n            int node2=list.get(1);\\n            int node3=list.get(2);\\n            int node4=list.get(3);\\n            if(checkIfLegal(graph,node1,node2) && checkIfLegal(graph,node3,node4)) return true;\\n            if(checkIfLegal(graph,node1,node3) && checkIfLegal(graph,node2,node4)) return true;\\n            if(checkIfLegal(graph,node1,node4) && checkIfLegal(graph,node2,node3)) return true;\\n        }else if(odd==2){ // if odd is 2 there are 2 conditions either join the 2 nodes with odd edges or join one node with even edge with 2 nodes with odd edge\\n            int x=list.get(0);\\n            int y=list.get(1);\\n            if(checkIfLegal(graph,y,x)) return true;\\n            for(int i=1;i<noe.length;i++){\\n                if(i==x||i==y) continue;\\n                if(checkIfLegal(graph,i,x) && checkIfLegal(graph,i,y)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    // will check if there is not a repeated edge or self loop\\n    public boolean checkIfLegal(List<List<Integer>> graph,int x,int y){\\n        for(int val:graph.get(x)) if(val==y) return false;\\n        return true;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923535,
                "title": "count-degree",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<set<int>> g(n+1);\\n        vector<int> vis(n+1, 0);\\n        vector<int> odd;\\n        for(auto e: edges){\\n            g[e[0]].insert(e[1]);  g[e[1]].insert(e[0]);\\n        }\\n        for(int i = 1; i <= n; ++i){\\n            if(g[i].size()%2) odd.push_back(i);\\n        }\\n        if(odd.size() == 0) return true;\\n        if(odd.size() > 4 || odd.size()%2 == 1) return false;\\n        if(odd.size() == 2) {\\n            if(g[odd[0]].find(odd[1]) == g[odd[0]].end() ) return true;\\n            else if(g[odd[0]].size() < n-1 && g[odd[1]].size() < n-1) return true;\\n            else return false;\\n        }\\n        int count = 0;\\n        for(int i = 0; i < odd.size(); ++i){\\n            for(int j = 0; j < odd.size(); ++j){\\n                if(i != j && g[odd[j]].find(odd[i]) == g[odd[j]].end() && vis[odd[i]] == 0 && vis[odd[j]] == 0){ \\n                    vis[odd[j]] = 1; vis[odd[i]] = 1; count++;\\n                    break;\\n                }\\n            }\\n        }\\n        if(count == 2) return true;\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<set<int>> g(n+1);\\n        vector<int> vis(n+1, 0);\\n        vector<int> odd;\\n        for(auto e: edges){\\n            g[e[0]].insert(e[1]);  g[e[1]].insert(e[0]);\\n        }\\n        for(int i = 1; i <= n; ++i){\\n            if(g[i].size()%2) odd.push_back(i);\\n        }\\n        if(odd.size() == 0) return true;\\n        if(odd.size() > 4 || odd.size()%2 == 1) return false;\\n        if(odd.size() == 2) {\\n            if(g[odd[0]].find(odd[1]) == g[odd[0]].end() ) return true;\\n            else if(g[odd[0]].size() < n-1 && g[odd[1]].size() < n-1) return true;\\n            else return false;\\n        }\\n        int count = 0;\\n        for(int i = 0; i < odd.size(); ++i){\\n            for(int j = 0; j < odd.size(); ++j){\\n                if(i != j && g[odd[j]].find(odd[i]) == g[odd[j]].end() && vis[odd[i]] == 0 && vis[odd[j]] == 0){ \\n                    vis[odd[j]] = 1; vis[odd[i]] = 1; count++;\\n                    break;\\n                }\\n            }\\n        }\\n        if(count == 2) return true;\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923512,
                "title": "python3-enumerate-all-possible-cases-for-2-and-4-odd-degree-nodes-in-the-graph",
                "content": "**Observation**\\nThe key is to note that we can add **at most** two additional edges (possibly none) to the graph.\\n\\n**Implementation**\\nStep 1: Build the graph by going through all edges.\\nStep 2: Find every node with an odd degree.\\nStep 3: Consider each of the case where the number of the nodes with an odd degree is 0, 1, 2, 3, 4, and > 4.\\n\\n**Solution**\\n```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        graph = defaultdict(set)\\n        for a, b in edges:\\n            graph[a].add(b)\\n            graph[b].add(a)\\n        odds = [a for a in graph if len(graph[a]) % 2 == 1]\\n        if not odds:\\n            return True\\n        elif len(odds) > 4 or len(odds) == 1 or len(odds) == 3:\\n            return False\\n        elif len(odds) == 2:\\n            a, b = odds[0], odds[1]\\n            if a not in graph[b]:\\n                return True\\n            for i in range(1, n + 1):\\n                if i not in graph[a] and i not in graph[b]:\\n                    return True\\n            return False\\n        else:\\n            a, b, c, d = odds[0], odds[1], odds[2], odds[3]\\n            if a not in graph[b] and c not in graph[d]:\\n                return True\\n            if a not in graph[c] and b not in graph[d]:\\n                return True\\n            if a not in graph[d] and b not in graph[c]:\\n                return True\\n            return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        graph = defaultdict(set)\\n        for a, b in edges:\\n            graph[a].add(b)\\n            graph[b].add(a)\\n        odds = [a for a in graph if len(graph[a]) % 2 == 1]\\n        if not odds:\\n            return True\\n        elif len(odds) > 4 or len(odds) == 1 or len(odds) == 3:\\n            return False\\n        elif len(odds) == 2:\\n            a, b = odds[0], odds[1]\\n            if a not in graph[b]:\\n                return True\\n            for i in range(1, n + 1):\\n                if i not in graph[a] and i not in graph[b]:\\n                    return True\\n            return False\\n        else:\\n            a, b, c, d = odds[0], odds[1], odds[2], odds[3]\\n            if a not in graph[b] and c not in graph[d]:\\n                return True\\n            if a not in graph[c] and b not in graph[d]:\\n                return True\\n            if a not in graph[d] and b not in graph[c]:\\n                return True\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927397,
                "title": "python-3-14-lines-w-analysis-t-m-1647-ms-55-9-mb-100-100",
                "content": "Here\\'s the analysis:\\n\\n- Applying one edge fixes exactly two odd edges. Therefore the only fixable graphs are those with either two or four odd nodes.\\n\\n- A graph with anything other than zero, two, or four odd nodes cannot be fixed; the answer in those cases is `False`.\\n- Case 0: Obviously`True`.\\n- Case 2: Suppose the nodes are *a* and *b*. i) If there\\'s no edge between *a* and *b*, we connect them with an edge and return `True` ii) If there is an edgebetween *a* and *b* already, then we seek a node that does not share an edge with either *a* or *b*. If one exists, we return `True`.\\n- Case 4: Added edges each must connect a pair of the four odd nodes, which can happen if and only if there exist such a pairing. There are three pairings to check.\\n- If we exhaust the above possibilities, we return`False`.\\n```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n\\n        dic = defaultdict(set)                      # <\\u2013\\u2013 Build the graph       \\n                                                    # \\n        for p,q in edges:                           # \\n            dic[p].add(q)                           # \\n            dic[q].add(p)                           # \\n        \\n        oddNodes = [node for node in dic            # <\\u2013\\u2013 Determine the odd nodes\\n                        if len(dic[node])%2]        #\\n       \\n        m = len(oddNodes)\\n\\n        if m == 0: return True                      # <\\u2013\\u2013 Case 0\\n     \\n        if m == 2:                                  # <\\u2013\\u2013 Case 2\\n\\n            a,b = oddNodes \\n\\n            return (not {a} & dic[b] or             # <\\u2013\\u2013 Case 2i\\n              not all({a,b} & dic[i]for i in dic))  # <\\u2013\\u2013 Case 2ii\\n  \\n        if m == 4:                                  # <\\u2013\\u2013 Case 4\\n            a, b, c, d = oddNodes\\n            \\n            if (not(a in dic[b] or c in dic[d]) or  # <\\u2013\\u2013 Find the pairings, if possible \\n                not(a in dic[c] or b in dic[d]) or\\n                not(a in dic[d] or b in dic[c])):\\n                return True\\n\\n        return False                                # <\\u2013\\u2013 If nothing works, return False\\n\\n```\\n[https://leetcode.com/problems/add-edges-to-make-degrees-of-all-nodes-even/submissions/861921730/](http://)\\n\\n- Python 3   ||   14 lines,  w/ analysis   ||   T/M: 1647 ms / 55.9 MB (100/100)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n\\n        dic = defaultdict(set)                      # <\\u2013\\u2013 Build the graph       \\n                                                    # \\n        for p,q in edges:                           # \\n            dic[p].add(q)                           # \\n            dic[q].add(p)                           # \\n        \\n        oddNodes = [node for node in dic            # <\\u2013\\u2013 Determine the odd nodes\\n                        if len(dic[node])%2]        #\\n       \\n        m = len(oddNodes)\\n\\n        if m == 0: return True                      # <\\u2013\\u2013 Case 0\\n     \\n        if m == 2:                                  # <\\u2013\\u2013 Case 2\\n\\n            a,b = oddNodes \\n\\n            return (not {a} & dic[b] or             # <\\u2013\\u2013 Case 2i\\n              not all({a,b} & dic[i]for i in dic))  # <\\u2013\\u2013 Case 2ii\\n  \\n        if m == 4:                                  # <\\u2013\\u2013 Case 4\\n            a, b, c, d = oddNodes\\n            \\n            if (not(a in dic[b] or c in dic[d]) or  # <\\u2013\\u2013 Find the pairings, if possible \\n                not(a in dic[c] or b in dic[d]) or\\n                not(a in dic[d] or b in dic[c])):\\n                return True\\n\\n        return False                                # <\\u2013\\u2013 If nothing works, return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923769,
                "title": "c-hashing-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        map<vector<int> , int> edge_exist;\\n        map<int,int> indegree;\\n        for(auto p:edges){\\n            edge_exist[{p[0], p[1]}]++;\\n            edge_exist[{p[1], p[0]}]++;\\n            indegree[p[0]]++;\\n            indegree[p[1]]++;\\n        }\\n        vector<int> odd;\\n        for(auto p:indegree){\\n            if(p.second%2){\\n                odd.push_back(p.first);\\n            }\\n        }\\n        if(odd.size()> 4 || odd.size()==1 ||odd.size()==3)return false;\\n        \\n        sort(odd.begin(), odd.end());\\n        if(odd.size()==2){\\n            if(edge_exist.find({odd[0],odd[1]})==edge_exist.end()) return true;\\n            if(n>2) {\\n                if(indegree[odd[0]]!=(n-1) and indegree[odd[1]]!=(n-1)) return true;\\n            }\\n            return false;\\n        }\\n        if(odd.size()==4){\\n            if(edge_exist.find({odd[0],odd[1]})==edge_exist.end() &&\\n                edge_exist.find({odd[2],odd[3]})==edge_exist.end()) return true;\\n\\n            if(edge_exist.find({odd[0],odd[2]})==edge_exist.end() &&\\n                edge_exist.find({odd[1],odd[3]})==edge_exist.end()) return true;\\n\\n            if(edge_exist.find({odd[0],odd[3]})==edge_exist.end() &&\\n                edge_exist.find({odd[1],odd[2]})==edge_exist.end()) return true;\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        map<vector<int> , int> edge_exist;\\n        map<int,int> indegree;\\n        for(auto p:edges){\\n            edge_exist[{p[0], p[1]}]++;\\n            edge_exist[{p[1], p[0]}]++;\\n            indegree[p[0]]++;\\n            indegree[p[1]]++;\\n        }\\n        vector<int> odd;\\n        for(auto p:indegree){\\n            if(p.second%2){\\n                odd.push_back(p.first);\\n            }\\n        }\\n        if(odd.size()> 4 || odd.size()==1 ||odd.size()==3)return false;\\n        \\n        sort(odd.begin(), odd.end());\\n        if(odd.size()==2){\\n            if(edge_exist.find({odd[0],odd[1]})==edge_exist.end()) return true;\\n            if(n>2) {\\n                if(indegree[odd[0]]!=(n-1) and indegree[odd[1]]!=(n-1)) return true;\\n            }\\n            return false;\\n        }\\n        if(odd.size()==4){\\n            if(edge_exist.find({odd[0],odd[1]})==edge_exist.end() &&\\n                edge_exist.find({odd[2],odd[3]})==edge_exist.end()) return true;\\n\\n            if(edge_exist.find({odd[0],odd[2]})==edge_exist.end() &&\\n                edge_exist.find({odd[1],odd[3]})==edge_exist.end()) return true;\\n\\n            if(edge_exist.find({odd[0],odd[3]})==edge_exist.end() &&\\n                edge_exist.find({odd[1],odd[2]})==edge_exist.end()) return true;\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613203,
                "title": "most-simple-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<unordered_set<int>> v(n+1);\\n        for(auto &i: edges){\\n            v[i[0]].insert(i[1]);\\n            v[i[1]].insert(i[0]);\\n        }\\n        vector<int> v1;\\n        for(int i = 1; i <= n; i++){\\n            if(v[i].size()&1){\\n                v1.push_back(i);\\n            }\\n        }\\n        if(v1.size() == 0)return true;\\n        else if(v1.size()==2){\\n            for(int i = 1; i <= n; i++){\\n                if(v[v1[0]].count(i)==0&&v[v1[1]].count(i)==0)return true;\\n            }\\n            if(v[v1[0]].count(v1[1]) == 0)return true;\\n        }\\n        else if(v1.size() == 4){\\n            if((v[v1[0]].count(v1[1]) == 0 && v[v1[2]].count(v1[3]) == 0)||\\n               (v[v1[0]].count(v1[2]) == 0 && v[v1[1]].count(v1[3]) == 0)||\\n               (v[v1[0]].count(v1[3]) == 0 && v[v1[2]].count(v1[1]) == 0)\\n            )return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<unordered_set<int>> v(n+1);\\n        for(auto &i: edges){\\n            v[i[0]].insert(i[1]);\\n            v[i[1]].insert(i[0]);\\n        }\\n        vector<int> v1;\\n        for(int i = 1; i <= n; i++){\\n            if(v[i].size()&1){\\n                v1.push_back(i);\\n            }\\n        }\\n        if(v1.size() == 0)return true;\\n        else if(v1.size()==2){\\n            for(int i = 1; i <= n; i++){\\n                if(v[v1[0]].count(i)==0&&v[v1[1]].count(i)==0)return true;\\n            }\\n            if(v[v1[0]].count(v1[1]) == 0)return true;\\n        }\\n        else if(v1.size() == 4){\\n            if((v[v1[0]].count(v1[1]) == 0 && v[v1[2]].count(v1[3]) == 0)||\\n               (v[v1[0]].count(v1[2]) == 0 && v[v1[1]].count(v1[3]) == 0)||\\n               (v[v1[0]].count(v1[3]) == 0 && v[v1[2]].count(v1[1]) == 0)\\n            )return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2934697,
                "title": "c-set-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) \\n    {\\n        vector<unordered_set<int>> g(n+1);\\n        vector<int> odd;\\n        for(auto &e:edges)\\n        {\\n            g[e[0]].insert(e[1]);\\n            g[e[1]].insert(e[0]);\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(g[i].size()%2==1)\\n                odd.push_back(i);\\n        }\\n        if(odd.size()==2)\\n        {\\n            for(int i=1;i<=n;i++)\\n            {\\n                if(g[odd[0]].count(i)==0&&g[odd[1]].count(i)==0)\\n                    return true;\\n            }\\n        }\\n        if(odd.size()==4)\\n        {\\n            return (g[odd[0]].count(odd[1])==0&&g[odd[2]].count(odd[3])==0) \\n                || (g[odd[0]].count(odd[2])==0&&g[odd[1]].count(odd[3])==0) \\n                || (g[odd[0]].count(odd[3])==0&&g[odd[1]].count(odd[2])==0);\\n        }\\n        return odd.size()==0;\\n    }\\n};\\n```\\nIf you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Graph",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) \\n    {\\n        vector<unordered_set<int>> g(n+1);\\n        vector<int> odd;\\n        for(auto &e:edges)\\n        {\\n            g[e[0]].insert(e[1]);\\n            g[e[1]].insert(e[0]);\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(g[i].size()%2==1)\\n                odd.push_back(i);\\n        }\\n        if(odd.size()==2)\\n        {\\n            for(int i=1;i<=n;i++)\\n            {\\n                if(g[odd[0]].count(i)==0&&g[odd[1]].count(i)==0)\\n                    return true;\\n            }\\n        }\\n        if(odd.size()==4)\\n        {\\n            return (g[odd[0]].count(odd[1])==0&&g[odd[2]].count(odd[3])==0) \\n                || (g[odd[0]].count(odd[2])==0&&g[odd[1]].count(odd[3])==0) \\n                || (g[odd[0]].count(odd[3])==0&&g[odd[1]].count(odd[2])==0);\\n        }\\n        return odd.size()==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923663,
                "title": "c-java-python3-3-cases-for-true",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/af6e415cd101768ea8743ea9e4d22d788c9461c3) for solutions of weekly 324. \\n\\n**Intuition**\\nThere are 3 cases where it is possible to get all even degrees with at most two more edges; \\n1) The nodes already have all even degrees; \\n2) There are two nodes with odd degrees, for which as long it is possible as there is a node not connecting to either of them; \\n3) There are four nodes with odd degrees, for which they can be separated into two groups not connecting to each other. \\n**Implementation**\\n**C++**\\n```\\nclass Solution {\\npublic: \\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<unordered_set<int>> graph(n); \\n        for (auto& e : edges) {\\n            graph[e[0]-1].insert(e[1]-1); \\n            graph[e[1]-1].insert(e[0]-1); \\n        }\\n        vector<long> odd; \\n        for (int i = 0; i < n; ++i) \\n            if (graph[i].size() & 1) odd.push_back(i); \\n        return odd.size() == 0 \\n            || odd.size() == 2 && any_of(graph.begin(), graph.end(), [&](auto& g) { return !g.count(odd[0]) && !g.count(odd[1]); })\\n            || odd.size() == 4 && (!graph[odd[0]].count(odd[1]) && !graph[odd[2]].count(odd[3]) || !graph[odd[0]].count(odd[2]) && !graph[odd[1]].count(odd[3]) || !graph[odd[0]].count(odd[3]) && !graph[odd[1]].count(odd[2]));\\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n\\tpublic boolean isPossible(int n, List<List<Integer>> edges) {\\n\\t\\tHashSet<Integer>[] graph = new HashSet[n]; \\n        for (int i = 0; i < n; ++i) graph[i] = new HashSet(); \\n\\t\\tfor (var e : edges) {\\n            graph[e.get(0)-1].add(e.get(1)-1); \\n            graph[e.get(1)-1].add(e.get(0)-1); \\n\\t\\t}\\n\\t\\tList<Integer> odd = new ArrayList(); \\n\\t\\tfor (int i = 0; i < n; ++i) \\n\\t\\t\\tif (graph[i].size() % 2 == 1) odd.add(i); \\n\\t\\tif (odd.size() == 2) {\\n\\t\\t\\tfor (int i = 0; i < n; ++i) \\n\\t\\t\\t\\tif (!graph[i].contains(odd.get(0)) && !graph[i].contains(odd.get(1))) return true; \\n\\t\\t\\treturn false; \\n\\t\\t}\\n\\t\\tif (odd.size() == 4) \\n\\t\\t\\treturn !graph[odd.get(0)].contains(odd.get(1)) && !graph[odd.get(2)].contains(odd.get(3)) \\n                || !graph[odd.get(0)].contains(odd.get(2)) && !graph[odd.get(1)].contains(odd.get(3)) \\n                || !graph[odd.get(0)].contains(odd.get(3)) && !graph[odd.get(1)].contains(odd.get(2)); \\n\\t\\treturn odd.size() == 0; \\n\\t}\\n}\\n```\\n**Python3**\\n```\\nclass Solution: \\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool: \\n        graph = [set() for _ in range(n)]\\n        for u, v in edges: \\n            graph[u-1].add(v-1)\\n            graph[v-1].add(u-1)\\n        odd = [i for i, x in enumerate(graph) if len(x)&1]\\n        return len(odd) == 0 or len(odd) == 2 and any(odd[0] not in graph[x] and odd[1] not in graph[x] for x in range(n)) or len(odd) == 4 and (odd[0] not in graph[odd[1]] and odd[2] not in graph[odd[3]] or odd[0] not in graph[odd[2]] and odd[1] not in graph[odd[3]] or odd[0] not in graph[odd[3]] and odd[1] not in graph[odd[2]])\\n```\\n**Complexity**\\nTime `O(N)`\\nSpace `O(N)`",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<unordered_set<int>> graph(n); \\n        for (auto& e : edges) {\\n            graph[e[0]-1].insert(e[1]-1); \\n            graph[e[1]-1].insert(e[0]-1); \\n        }\\n        vector<long> odd; \\n        for (int i = 0; i < n; ++i) \\n            if (graph[i].size() & 1) odd.push_back(i); \\n        return odd.size() == 0 \\n            || odd.size() == 2 && any_of(graph.begin(), graph.end(), [&](auto& g) { return !g.count(odd[0]) && !g.count(odd[1]); })\\n            || odd.size() == 4 && (!graph[odd[0]].count(odd[1]) && !graph[odd[2]].count(odd[3]) || !graph[odd[0]].count(odd[2]) && !graph[odd[1]].count(odd[3]) || !graph[odd[0]].count(odd[3]) && !graph[odd[1]].count(odd[2]));\\n    }\\n};\\n```\n```\\nclass Solution {\\n\\tpublic boolean isPossible(int n, List<List<Integer>> edges) {\\n\\t\\tHashSet<Integer>[] graph = new HashSet[n]; \\n        for (int i = 0; i < n; ++i) graph[i] = new HashSet(); \\n\\t\\tfor (var e : edges) {\\n            graph[e.get(0)-1].add(e.get(1)-1); \\n            graph[e.get(1)-1].add(e.get(0)-1); \\n\\t\\t}\\n\\t\\tList<Integer> odd = new ArrayList(); \\n\\t\\tfor (int i = 0; i < n; ++i) \\n\\t\\t\\tif (graph[i].size() % 2 == 1) odd.add(i); \\n\\t\\tif (odd.size() == 2) {\\n\\t\\t\\tfor (int i = 0; i < n; ++i) \\n\\t\\t\\t\\tif (!graph[i].contains(odd.get(0)) && !graph[i].contains(odd.get(1))) return true; \\n\\t\\t\\treturn false; \\n\\t\\t}\\n\\t\\tif (odd.size() == 4) \\n\\t\\t\\treturn !graph[odd.get(0)].contains(odd.get(1)) && !graph[odd.get(2)].contains(odd.get(3)) \\n                || !graph[odd.get(0)].contains(odd.get(2)) && !graph[odd.get(1)].contains(odd.get(3)) \\n                || !graph[odd.get(0)].contains(odd.get(3)) && !graph[odd.get(1)].contains(odd.get(2)); \\n\\t\\treturn odd.size() == 0; \\n\\t}\\n}\\n```\n```\\nclass Solution: \\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool: \\n        graph = [set() for _ in range(n)]\\n        for u, v in edges: \\n            graph[u-1].add(v-1)\\n            graph[v-1].add(u-1)\\n        odd = [i for i, x in enumerate(graph) if len(x)&1]\\n        return len(odd) == 0 or len(odd) == 2 and any(odd[0] not in graph[x] and odd[1] not in graph[x] for x in range(n)) or len(odd) == 4 and (odd[0] not in graph[odd[1]] and odd[2] not in graph[odd[3]] or odd[0] not in graph[odd[2]] and odd[1] not in graph[odd[3]] or odd[0] not in graph[odd[3]] and odd[1] not in graph[odd[2]])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923491,
                "title": "find-odd-degree-nodes-and-try-connecting-them",
                "content": "First of all, we check the degree of each node, and collect the odd-degree ones.  If we can connect these odd-degree nodes to each other in 1-to-1 manner, then all nodes become even-degree.  There are a few scenarios:\\n1. The number of odd-degree nodes is `0`\\n\\t- already good; return true\\n2. The number of odd-degree nodes is odd\\n\\t- can\\'t do without self-edge; return false\\n3. The number of odd-degree Nodes is `> 4`\\n\\t- need more than 2 edges; return false\\n4. The number of odd-degree Nodes is `2` or `4`\\n\\t- try making edges between the nodes\\n\\nIn addition, there is a special case when the number of odd-degree nodes is `2`.  If both nodes are already connected, which means we cannot make edge between them, we need to check if any other node can be used as a relay.  If yes, then it is still good.\\n\\n\\n```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        g = [set() for _ in range(n)]\\n        for a, b in edges:\\n            g[a-1].add(b-1)\\n            g[b-1].add(a-1)\\n\\n        cd = []  # odd-degree candidates\\n        for i in range(n):\\n            if len(g[i]) & 1:\\n                cd.append(i)\\n        if len(cd) == 0:\\n            return True\\n        if len(cd) & 1:\\n            return False\\n        if len(cd) > 4:\\n            return False\\n        \\n        if len(cd) == 2:\\n            a = cd[0]\\n            b = cd[1]\\n            if a not in g[b]:\\n                return True\\n            for i in range(n):\\n                if i in g[a] or i in g[b]:\\n                    continue\\n                return True\\n            return False\\n        \\n        # len(cd) == 4\\n        a = cd[0]\\n        b = cd[1]\\n        c = cd[2]\\n        d = cd[3]\\n        if a not in g[b] and c not in g[d]:\\n            return True\\n        if a not in g[c] and b not in g[d]:\\n            return True\\n        if a not in g[d] and b not in g[c]:\\n            return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        g = [set() for _ in range(n)]\\n        for a, b in edges:\\n            g[a-1].add(b-1)\\n            g[b-1].add(a-1)\\n\\n        cd = []  # odd-degree candidates\\n        for i in range(n):\\n            if len(g[i]) & 1:\\n                cd.append(i)\\n        if len(cd) == 0:\\n            return True\\n        if len(cd) & 1:\\n            return False\\n        if len(cd) > 4:\\n            return False\\n        \\n        if len(cd) == 2:\\n            a = cd[0]\\n            b = cd[1]\\n            if a not in g[b]:\\n                return True\\n            for i in range(n):\\n                if i in g[a] or i in g[b]:\\n                    continue\\n                return True\\n            return False\\n        \\n        # len(cd) == 4\\n        a = cd[0]\\n        b = cd[1]\\n        c = cd[2]\\n        d = cd[3]\\n        if a not in g[b] and c not in g[d]:\\n            return True\\n        if a not in g[c] and b not in g[d]:\\n            return True\\n        if a not in g[d] and b not in g[c]:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925428,
                "title": "c-solution-code-with-comments-well-structured-code",
                "content": "**Note*** Node having odd number of edges : Odd Node.\\n**Note*** Node having even number of edges : Even Node.\\n\\n# Intuition\\nThere are some key points for this problem : \\n1. We have **at max 2** additional edges to make all the odd nodes into even nodes or else return false.\\n2. One edge can convert **2 odd nodes** into even nodes.\\n3. It means at max we can convert only **4 odd nodes** into even(as we are having only 2 additional edges).\\n4. An even node can be placed between 2 odd nodes to make them even(this process will require **2 additional edges**).\\n5. Last but not the least, graph having **1 or 3 or more than 4** odd nodes will always answer in false.\\n\\n# Approach\\n1. Make the Graph.\\n2. Classify the odd and even nodes.\\n3. Find the answer on the basis of the above intuition.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isPossible(int n, vector<vector<int>>& edges) { \\n        vector<int> odds, even;\\n        map<int, map<int, int>> g;\\n        // Making the graph //\\n        for(auto edge : edges){\\n            g[edge[0]][edge[1]] = g[edge[1]][edge[0]] = 1;\\n        }\\n        // Finding the nodes having odd & even edges //\\n        for(int i=1;i<=n;i++){\\n            if( (g[i].size())&1 ) odds.push_back(i);\\n            else even.push_back(i);\\n        }\\n        int size = odds.size();\\n\\n        // If we have 1 or 3 odd nodes then answer will be false //\\n        if( size == 1 || size == 3 ) return false;\\n        else if( size == 2 ){\\n            // Finding an even node that can be placed between 2 odd nodes //\\n            for(auto &e_n : even){\\n                if( g[e_n][odds[0]] == 0 && g[e_n][odds[1]] == 0 ) return true;\\n            }\\n            // Or if the 2 odd nodes can connect with each other //\\n            return g[odds[0]][odds[1]] == 0;\\n        }\\n        else if( size == 4 ){\\n            // 1st node with 2nd node && 3rd node with 4th node //\\n            if( g[odds[0]][odds[1]] == 0 && g[odds[2]][odds[3]] == 0 ) return true;\\n            \\n            // 1st node with 3rd node && 2nd node with 4th node //\\n            else if( g[odds[0]][odds[2]] == 0 && g[odds[1]][odds[3]] == 0 ) return true;\\n            \\n            // 1st node with 4th node && 2nd node with 3rd node //\\n            else if( g[odds[0]][odds[3]] == 0 && g[odds[1]][odds[2]] == 0 ) return true;\\n        }\\n\\n        // If the graph doest not contain any odd node //\\n        return size == 0;\\n    }\\n};\\n```\\n\\n**Please upvote the solution if you like it\\uD83D\\uDE0A.**\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isPossible(int n, vector<vector<int>>& edges) { \\n        vector<int> odds, even;\\n        map<int, map<int, int>> g;\\n        // Making the graph //\\n        for(auto edge : edges){\\n            g[edge[0]][edge[1]] = g[edge[1]][edge[0]] = 1;\\n        }\\n        // Finding the nodes having odd & even edges //\\n        for(int i=1;i<=n;i++){\\n            if( (g[i].size())&1 ) odds.push_back(i);\\n            else even.push_back(i);\\n        }\\n        int size = odds.size();\\n\\n        // If we have 1 or 3 odd nodes then answer will be false //\\n        if( size == 1 || size == 3 ) return false;\\n        else if( size == 2 ){\\n            // Finding an even node that can be placed between 2 odd nodes //\\n            for(auto &e_n : even){\\n                if( g[e_n][odds[0]] == 0 && g[e_n][odds[1]] == 0 ) return true;\\n            }\\n            // Or if the 2 odd nodes can connect with each other //\\n            return g[odds[0]][odds[1]] == 0;\\n        }\\n        else if( size == 4 ){\\n            // 1st node with 2nd node && 3rd node with 4th node //\\n            if( g[odds[0]][odds[1]] == 0 && g[odds[2]][odds[3]] == 0 ) return true;\\n            \\n            // 1st node with 3rd node && 2nd node with 4th node //\\n            else if( g[odds[0]][odds[2]] == 0 && g[odds[1]][odds[3]] == 0 ) return true;\\n            \\n            // 1st node with 4th node && 2nd node with 3rd node //\\n            else if( g[odds[0]][odds[3]] == 0 && g[odds[1]][odds[2]] == 0 ) return true;\\n        }\\n\\n        // If the graph doest not contain any odd node //\\n        return size == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924315,
                "title": "including-the-corner-cases-you-missed",
                "content": "# Intuition\\n- We can draw maximum of 2 edges, and with 1 edge we can connect 2 nodes. So the maximum no. of nodes we can connect is 4.\\n\\n- The degree of a node is the no. of edges (or no.of nodes it is connected to)\\n\\n- If the no. of odd nodes (Nodes with odd degree) is odd, then we can\\'t possibly connect all of them.\\n\\n- If the no. of odd nodes is more than 4 then in order to connect them all, we need more than 2 edges, but it is not allowed.\\n\\n**Conclusion:**\\n\\n    Let n be the total odd nodes(nodes with odd degree)\\n1. If n is 0, there is no such node with odd degree, so we return true\\n2. if n is odd, we return false (Because there will always be a left over node)\\n3. If n>4, we return false (Because we would need more than 2 edges to connect them, which is not allowed)\\n4. We need to check for n=2 and n=4\\n\\n# Approach\\n- We Store the nodes with odd degree\\n- If the size off the vector (which we created in Step-1) is 0, then we return true. Since all nodes already has even no. of degree\\n- If the size off the vector (which we created in Step-1) is odd or more than 4, we return false\\n- If the size is 2, there are 2 cases in this :\\n\\n    **Case 1 :** If the 2 nodes are not already connected, then we can    connect them. And the degree of them will now be even\\n    **Case 2 :** If the 2 nodes are already connected, we find the node which is not connected to either of them, If such node is found, return true else return false\\n- If the size is 4, there are 3 such cases in which different types of edges will be created. We wil check for each of the edge, whether they are already connected or not. If they are not then we return true since we can connect them else we return false\\n\\n# Complexity\\n- Time complexity: O(n * k)\\n\\n    n = no. of nodes\\n    k = maximum no. of nodes connected to a node\\n\\n- Space complexity: O(n+1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // To check whether the node v1 and v2 are connected or not\\n    bool isPresent(int v1, int v2, vector<int> adj[]){\\n        for(int neighbour:adj[v1]){\\n            if(neighbour == v2)\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> outDegree(n+1);     // To store the degree\\n        vector<int> adj[n+1];       // Adjacent List\\n        \\n        for(vector<int> edge:edges){\\n            outDegree[edge[0]]++;\\n            outDegree[edge[1]]++;\\n            \\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        int count = 0;\\n        \\n        for(int i=1 ; i<=n ; i++){\\n            if(outDegree[i]%2 != 0)\\n                count++;\\n        }\\n        \\n        vector<int> oddOutDegree;   // To store the nodes with odd degree\\n        \\n        for(int i=1 ; i<=n ; i++){\\n            if(outDegree[i]%2 != 0)\\n                oddOutDegree.push_back(i);\\n        }\\n        \\n        int size = oddOutDegree.size();\\n        \\n        // Base Case\\n        if(size == 0)\\n        return true;\\n\\n        // Base Case\\n        if(size%2!=0 || size>4)\\n            return false;\\n        \\n        if(size == 2){\\n            int v1 = oddOutDegree[0];   // Node-1\\n            int v2 = oddOutDegree[1];   // Node-2\\n            bool flag = true;\\n\\n            // To check whether the nodes are already connected\\n            for(int neighbour:adj[v1]){\\n                if(neighbour == v2){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            // Not Connected, so return true because we can connect them\\n            if(flag)\\n            return true;\\n\\n            // To find a node which is not connected to either of the nodes\\n            for(int i=1 ; i<=n ; i++){\\n                if(i!=v1 && i!=v2 && !isPresent(i, v1, adj) && !isPresent(i, v2, adj))\\n                return true;\\n            }\\n\\n            // No such node exists which can be connected to these nodes, so we return false\\n            return false;\\n        }\\n\\n        int a = oddOutDegree[0];    \\n        int b = oddOutDegree[1];\\n        int c = oddOutDegree[2];\\n        int d = oddOutDegree[3];\\n\\n        // If the nodes of the edges are already not connected\\n        if(!isPresent(a, b, adj) && !isPresent(c, d, adj))\\n        return true;\\n\\n        if(!isPresent(a, c, adj) && !isPresent(b, d, adj))\\n        return true;\\n\\n        if(!isPresent(a, d, adj) && !isPresent(b, c, adj))\\n        return true;\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // To check whether the node v1 and v2 are connected or not\\n    bool isPresent(int v1, int v2, vector<int> adj[]){\\n        for(int neighbour:adj[v1]){\\n            if(neighbour == v2)\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> outDegree(n+1);     // To store the degree\\n        vector<int> adj[n+1];       // Adjacent List\\n        \\n        for(vector<int> edge:edges){\\n            outDegree[edge[0]]++;\\n            outDegree[edge[1]]++;\\n            \\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        int count = 0;\\n        \\n        for(int i=1 ; i<=n ; i++){\\n            if(outDegree[i]%2 != 0)\\n                count++;\\n        }\\n        \\n        vector<int> oddOutDegree;   // To store the nodes with odd degree\\n        \\n        for(int i=1 ; i<=n ; i++){\\n            if(outDegree[i]%2 != 0)\\n                oddOutDegree.push_back(i);\\n        }\\n        \\n        int size = oddOutDegree.size();\\n        \\n        // Base Case\\n        if(size == 0)\\n        return true;\\n\\n        // Base Case\\n        if(size%2!=0 || size>4)\\n            return false;\\n        \\n        if(size == 2){\\n            int v1 = oddOutDegree[0];   // Node-1\\n            int v2 = oddOutDegree[1];   // Node-2\\n            bool flag = true;\\n\\n            // To check whether the nodes are already connected\\n            for(int neighbour:adj[v1]){\\n                if(neighbour == v2){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            // Not Connected, so return true because we can connect them\\n            if(flag)\\n            return true;\\n\\n            // To find a node which is not connected to either of the nodes\\n            for(int i=1 ; i<=n ; i++){\\n                if(i!=v1 && i!=v2 && !isPresent(i, v1, adj) && !isPresent(i, v2, adj))\\n                return true;\\n            }\\n\\n            // No such node exists which can be connected to these nodes, so we return false\\n            return false;\\n        }\\n\\n        int a = oddOutDegree[0];    \\n        int b = oddOutDegree[1];\\n        int c = oddOutDegree[2];\\n        int d = oddOutDegree[3];\\n\\n        // If the nodes of the edges are already not connected\\n        if(!isPresent(a, b, adj) && !isPresent(c, d, adj))\\n        return true;\\n\\n        if(!isPresent(a, c, adj) && !isPresent(b, d, adj))\\n        return true;\\n\\n        if(!isPresent(a, d, adj) && !isPresent(b, c, adj))\\n        return true;\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923765,
                "title": "java-simple-logic-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. If there are only 2 or 4 odd edges it is possible to make all the nodes have even degree, else, return false\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. For case 1: Where there are 2 odd degree nodes, check if there exists edge between them. If No, we can add edge between them and return true, else, try to find an even degree node so that there is no connection with these odd nodes and use two edges to join even degree node to each odd degree nodes.\\n\\n2. In case of 4 odd degree nodes, form 2 pairs and check if there already exists an edge between them.\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(Edges.length)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edgesList) {\\n        Set<Pair<Integer,Integer>> edges = new HashSet<>();\\n        int[] degree = new int[n+1];\\n        \\n        for(List<Integer> edge : edgesList) {\\n            edges.add(new Pair(edge.get(0), edge.get(1)));\\n            edges.add(new Pair(edge.get(1), edge.get(0)));\\n            \\n            degree[edge.get(0)]++;\\n            degree[edge.get(1)]++;\\n        }\\n        \\n        List<Integer> oddNodes = new ArrayList<>();\\n        for(int i = 1;i<=n;i++) {\\n            if(degree[i]%2 == 1) oddNodes.add(i);\\n        }\\n        \\n        int m = oddNodes.size();\\n\\n        if(m == 0) return true;\\n        if(m == 1 || m > 4 || m == 3) return false;\\n        \\n        int a = oddNodes.get(0), b = oddNodes.get(1);\\n        if(m == 2) {\\n            if(!edges.contains(new Pair(a, b))) return true;\\n            for(int i = 1;i<=n;i++) {\\n                // Find even degree node as a bridge node\\n                if(!edges.contains(new Pair(a, i)) && !edges.contains(new Pair(i, b))) return true;\\n            }\\n            \\n            return false;\\n        }\\n        int c = oddNodes.get(2), d = oddNodes.get(3);\\n        if ((!edges.contains(new Pair(a,b)) && !edges.contains(new Pair(c,d))) ||\\n            (!edges.contains(new Pair(a,c)) && !edges.contains(new Pair(b,d))) ||\\n            (!edges.contains(new Pair(a,d)) && !edges.contains(new Pair(b,c)))) return true;\\n            \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edgesList) {\\n        Set<Pair<Integer,Integer>> edges = new HashSet<>();\\n        int[] degree = new int[n+1];\\n        \\n        for(List<Integer> edge : edgesList) {\\n            edges.add(new Pair(edge.get(0), edge.get(1)));\\n            edges.add(new Pair(edge.get(1), edge.get(0)));\\n            \\n            degree[edge.get(0)]++;\\n            degree[edge.get(1)]++;\\n        }\\n        \\n        List<Integer> oddNodes = new ArrayList<>();\\n        for(int i = 1;i<=n;i++) {\\n            if(degree[i]%2 == 1) oddNodes.add(i);\\n        }\\n        \\n        int m = oddNodes.size();\\n\\n        if(m == 0) return true;\\n        if(m == 1 || m > 4 || m == 3) return false;\\n        \\n        int a = oddNodes.get(0), b = oddNodes.get(1);\\n        if(m == 2) {\\n            if(!edges.contains(new Pair(a, b))) return true;\\n            for(int i = 1;i<=n;i++) {\\n                // Find even degree node as a bridge node\\n                if(!edges.contains(new Pair(a, i)) && !edges.contains(new Pair(i, b))) return true;\\n            }\\n            \\n            return false;\\n        }\\n        int c = oddNodes.get(2), d = oddNodes.get(3);\\n        if ((!edges.contains(new Pair(a,b)) && !edges.contains(new Pair(c,d))) ||\\n            (!edges.contains(new Pair(a,c)) && !edges.contains(new Pair(b,d))) ||\\n            (!edges.contains(new Pair(a,d)) && !edges.contains(new Pair(b,c)))) return true;\\n            \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923715,
                "title": "build-graph",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(n)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(n)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool noEdge(vector<unordered_set<int>>& graph, int a, int b) {\\n         return a != b && graph[a].find(b) == graph[a].end();\\n    }\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> degree(n + 1, 0);\\n        vector<unordered_set<int>> graph(n + 1);\\n        for(vector<int>& edge: edges) {\\n            degree[edge[0]]++;\\n            graph[edge[0]].insert(edge[1]);\\n            degree[edge[1]]++;\\n            graph[edge[1]].insert(edge[0]);\\n        }\\n        int odd = 0;\\n        vector<int> are;\\n        for(int i = 1; i <= n; i++) {\\n            if(degree[i] & 1) {\\n                if(degree[i] == n - 1)\\n                    return false;\\n                odd++;\\n                are.push_back(i);\\n            }\\n        }\\n        switch(odd) {\\n            case 0:\\n                return true;\\n            case 2:\\n                if(noEdge(graph, are[0], are[1]))\\n                    return true;\\n                for(int i = 1; i <= n; i++)\\n                    if(noEdge(graph, are[0], i) && noEdge(graph, are[1], i))\\n                        return true;\\n                break;\\n            case 4:\\n                return (noEdge(graph, are[0], are[1]) && noEdge(graph, are[2], are[3])) ||\\n                    (noEdge(graph, are[0], are[3]) && noEdge(graph, are[1], are[2])) ||\\n                    (noEdge(graph, are[0], are[2]) && noEdge(graph, are[1], are[3]));\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool noEdge(vector<unordered_set<int>>& graph, int a, int b) {\\n         return a != b && graph[a].find(b) == graph[a].end();\\n    }\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> degree(n + 1, 0);\\n        vector<unordered_set<int>> graph(n + 1);\\n        for(vector<int>& edge: edges) {\\n            degree[edge[0]]++;\\n            graph[edge[0]].insert(edge[1]);\\n            degree[edge[1]]++;\\n            graph[edge[1]].insert(edge[0]);\\n        }\\n        int odd = 0;\\n        vector<int> are;\\n        for(int i = 1; i <= n; i++) {\\n            if(degree[i] & 1) {\\n                if(degree[i] == n - 1)\\n                    return false;\\n                odd++;\\n                are.push_back(i);\\n            }\\n        }\\n        switch(odd) {\\n            case 0:\\n                return true;\\n            case 2:\\n                if(noEdge(graph, are[0], are[1]))\\n                    return true;\\n                for(int i = 1; i <= n; i++)\\n                    if(noEdge(graph, are[0], i) && noEdge(graph, are[1], i))\\n                        return true;\\n                break;\\n            case 4:\\n                return (noEdge(graph, are[0], are[1]) && noEdge(graph, are[2], are[3])) ||\\n                    (noEdge(graph, are[0], are[3]) && noEdge(graph, are[1], are[2])) ||\\n                    (noEdge(graph, are[0], are[2]) && noEdge(graph, are[1], are[3]));\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923507,
                "title": "cpp-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<unordered_set<int>> graph(n);\\n        vector<int> deg(n);\\n        for(auto edge:edges) {\\n            graph[edge[0] - 1].insert(edge[1] - 1);\\n            graph[edge[1] - 1].insert(edge[0] - 1);\\n            deg[edge[0]-1]++;\\n            deg[edge[1]-1]++;\\n        }\\n        vector<int> nodes;\\n        for(int i = 0; i < n; i += 1) {\\n            if(deg[i]&1) nodes.push_back(i);\\n        }\\n        if(nodes.size() == 0) return true;\\n        if(nodes.size() % 2 == 1 || nodes.size() > 4) return false;\\n        if(nodes.size() == 2) {\\n            if(!graph[nodes[0]].count(nodes[1])) return true;\\n            unordered_set<int> st;\\n            for(auto it: graph[nodes[0]]) st.insert(it);\\n            for(auto it:graph[nodes[1]]) st.insert(it);\\n            if(st.size() == n) return false;\\n            return true;\\n        }\\n        bool flag = false;\\n        int maxcnt = 0;\\n        vector<int> u2;\\n        for(int x: nodes) {\\n            int cnt = 0;\\n            vector<int> e;\\n            for(int y:nodes){\\n                if(graph[x].count(y)) {\\n                    cnt++;\\n                    e.push_back(y);\\n                    flag = true;\\n                }\\n            }\\n            if(cnt > maxcnt) {\\n                u2 = e;\\n                maxcnt = cnt;\\n            }\\n        }\\n        if(!flag || maxcnt == 1) return true;\\n        if(maxcnt == 3) return false;\\n        if(graph[u2[0]].count(u2[1])) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<unordered_set<int>> graph(n);\\n        vector<int> deg(n);\\n        for(auto edge:edges) {\\n            graph[edge[0] - 1].insert(edge[1] - 1);\\n            graph[edge[1] - 1].insert(edge[0] - 1);\\n            deg[edge[0]-1]++;\\n            deg[edge[1]-1]++;\\n        }\\n        vector<int> nodes;\\n        for(int i = 0; i < n; i += 1) {\\n            if(deg[i]&1) nodes.push_back(i);\\n        }\\n        if(nodes.size() == 0) return true;\\n        if(nodes.size() % 2 == 1 || nodes.size() > 4) return false;\\n        if(nodes.size() == 2) {\\n            if(!graph[nodes[0]].count(nodes[1])) return true;\\n            unordered_set<int> st;\\n            for(auto it: graph[nodes[0]]) st.insert(it);\\n            for(auto it:graph[nodes[1]]) st.insert(it);\\n            if(st.size() == n) return false;\\n            return true;\\n        }\\n        bool flag = false;\\n        int maxcnt = 0;\\n        vector<int> u2;\\n        for(int x: nodes) {\\n            int cnt = 0;\\n            vector<int> e;\\n            for(int y:nodes){\\n                if(graph[x].count(y)) {\\n                    cnt++;\\n                    e.push_back(y);\\n                    flag = true;\\n                }\\n            }\\n            if(cnt > maxcnt) {\\n                u2 = e;\\n                maxcnt = cnt;\\n            }\\n        }\\n        if(!flag || maxcnt == 1) return true;\\n        if(maxcnt == 3) return false;\\n        if(graph[u2[0]].count(u2[1])) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992809,
                "title": "c-using-degree-mathematics",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) \\n    {\\n        vector<int>degree(n+1,0),oddnode,evennode;\\n        map<pair<int,int>,bool>edgeexist;\\n        int i;\\n        for(i=0;i<edges.size();i++)\\n        {\\n            degree[edges[i][0]]++;\\n            degree[edges[i][1]]++;\\n            edgeexist[{edges[i][0],edges[i][1]}]=true;\\n            edgeexist[{edges[i][1],edges[i][0]}]=true;\\n        }\\n        for(i=0;i<=n;i++)\\n        {\\n            if(degree[i]%2==1)\\n            {\\n                oddnode.push_back(i);\\n                continue;\\n            }\\n            evennode.push_back(i);\\n        }\\n        if(oddnode.size()==0)\\n        {\\n            return true;\\n        }\\n        if(oddnode.size()%2==1)\\n        {\\n            return false;\\n        }\\n        if(oddnode.size()>4)\\n        {\\n            return false;\\n        }\\n        if(oddnode.size()==2)\\n        {\\n            if(!edgeexist[{oddnode[0],oddnode[1]}])\\n            {\\n                return true;\\n            }\\n            for(i=1;i<evennode.size();i++)\\n            {\\n                if(!edgeexist[{evennode[i],oddnode[0]}] && !edgeexist[{evennode[i],oddnode[1]}])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        if(oddnode.size()==4)\\n        {\\n            if(!edgeexist[{oddnode[0],oddnode[1]}] && !edgeexist[{oddnode[2],oddnode[3]}])\\n            {\\n                return true;\\n            }\\n            if(!edgeexist[{oddnode[0],oddnode[2]}] && !edgeexist[{oddnode[1],oddnode[3]}])\\n            {\\n                return true;\\n            }\\n            if(!edgeexist[{oddnode[0],oddnode[3]}] && !edgeexist[{oddnode[1],oddnode[2]}])\\n            {\\n                return true;\\n            }\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) \\n    {\\n        vector<int>degree(n+1,0),oddnode,evennode;\\n        map<pair<int,int>,bool>edgeexist;\\n        int i;\\n        for(i=0;i<edges.size();i++)\\n        {\\n            degree[edges[i][0]]++;\\n            degree[edges[i][1]]++;\\n            edgeexist[{edges[i][0],edges[i][1]}]=true;\\n            edgeexist[{edges[i][1],edges[i][0]}]=true;\\n        }\\n        for(i=0;i<=n;i++)\\n        {\\n            if(degree[i]%2==1)\\n            {\\n                oddnode.push_back(i);\\n                continue;\\n            }\\n            evennode.push_back(i);\\n        }\\n        if(oddnode.size()==0)\\n        {\\n            return true;\\n        }\\n        if(oddnode.size()%2==1)\\n        {\\n            return false;\\n        }\\n        if(oddnode.size()>4)\\n        {\\n            return false;\\n        }\\n        if(oddnode.size()==2)\\n        {\\n            if(!edgeexist[{oddnode[0],oddnode[1]}])\\n            {\\n                return true;\\n            }\\n            for(i=1;i<evennode.size();i++)\\n            {\\n                if(!edgeexist[{evennode[i],oddnode[0]}] && !edgeexist[{evennode[i],oddnode[1]}])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        if(oddnode.size()==4)\\n        {\\n            if(!edgeexist[{oddnode[0],oddnode[1]}] && !edgeexist[{oddnode[2],oddnode[3]}])\\n            {\\n                return true;\\n            }\\n            if(!edgeexist[{oddnode[0],oddnode[2]}] && !edgeexist[{oddnode[1],oddnode[3]}])\\n            {\\n                return true;\\n            }\\n            if(!edgeexist[{oddnode[0],oddnode[3]}] && !edgeexist[{oddnode[1],oddnode[2]}])\\n            {\\n                return true;\\n            }\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2988713,
                "title": "c-783ms-o-m-n-graph-theory-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe begin by analyzing the problem from the standpoint of degrees of vertices. We can add up to two edges that do not already exist in the graph. Each edge that we add will add 1 to the degrees of its two vertices, making an odd degree even, and making an even degree odd. \\n\\nImmediately, we can eliminate some situations that make it impossible for us to solve the problem. If the number of vertices with odd degree is not 0, 2, or 4, then adding two edges -- which makes at most 4 vertices change from odd to even -- will not be enough to make all the vertices even.\\n\\nSo, what do we need to do in each of these cases? Well, with 0 odd-degree vertices, we don\\'t need to add any edges because all the degrees are already even, so we just return true. With 4 odd-degree vertices, each edge is going to need to flip two odd vertices to become even vertices, and there\\'s no other way to do this. So, we need to check if there\\'s a way to pair the 4 vertices up such that both pairs did not previously have an edge, and if so, we return true and otherwise return false.\\n\\nThe 2-odd case is a bit harder. One possibility that\\'s quite simple is just adding an edge between the two odd vertices, and if this is possible then we add just this one edge and solve the problem. However, even if we can\\'t do this [because of an existing edge] we can still find a solution, by connecting both odd vertices to an existing even vertex that they were not previously connected to. The even vertex then stays even since there are 2 new edges added, and the odd vertices both flip to even.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe do just what we said above -- first, we find all the odd vertices, and then based on the number of odd vertices, we determine if a solution is possible. We store our graph in a vector of unordered sets so that we can check if a vertex is connected to another vertex in constant time while also being able to efficiently look at the vertices adjacent to a given vertex. So, we iterate through all of the edges and build up the vector of unordered sets.\\n\\nWe then go through the sets and find how many have odd size, and which ones they are. If we have 0 odd sizes, then we return true. Otherwise, if there are not 2 or 4 odd vertices then we return false.\\n\\nIn the 2-odd case, we begin by checking if the two vertices already have an edge and if they don\\'t, we can immediately return true. Otherwise, we iterate through the rest of the vertices and try and find one that does not have an edge to either of the odd vertices, by iterating from 0 to n and skipping the odd vertices themselves.\\n\\nIn the 4-odd case, we find the four odd vertices and see which pairs already have edges. We then try pairings defined by putting the first odd vertex with the second, third, and fourth odd vertices, and if any of these three pairings succeed, we return true and otherwise return false.\\n\\n# Complexity\\n\\nFor analyzing the complexity, let $$m$$ be the number of edges and $$n$$ be the number of vertices.\\n\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe have to go through all of the edges in an initial pass and do a constant-time operation on each, so this is $$O(m)$$. We then iterate over all vertices to find the odd ones and potentially have to solve by iterating over all vertices again in the 2-odd case, which is an $$O(n)$$ step so the total is $$O(m + n)$$.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe store $$n$$ sets in a vector, which, when totaled, have cumulative size in $$O(m)$$. All other memory is constant space other than the vector of odd-size vertices, which also has max length $$n$$. The total space is $$O(m + n)$$ as a result.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        // create a set for each vertex storing all adjacent vertices\\n        vector<unordered_set<int>> adj;\\n        // initialize\\n        for(int i = 0; i < n; ++i) {\\n            unordered_set<int> s = {};\\n            adj.push_back(s);\\n        }\\n        // add each edge to the two corresponding sets\\n        for(vector<int> q : edges) {\\n            adj[q[0] - 1].insert(q[1] - 1);\\n            adj[q[1] - 1].insert(q[0] - 1);\\n        }\\n        // find all odd degree vertices\\n        vector<int> odd;\\n        for(int i = 0; i < n; ++i) {\\n            if(adj[i].size() % 2 == 1) {\\n                odd.push_back(i);\\n            }\\n        }\\n        // no odd vertices means all are even, so we are done\\n        if(odd.size() == 0) return true;\\n        // 2 odd vertex case\\n        if(odd.size() == 2) {\\n            // check if we can just directly add an edge\\n            if(adj[odd[0]].count(odd[1]) == 0) return true;\\n            // otherwise try all possibilities for a third vertex\\n            for(int i = 0; i < n; ++i) {\\n                if(i != odd[0] && i != odd[1]\\n                    && adj[odd[0]].count(i) == 0\\n                    && adj[odd[1]].count(i) == 0) \\n                    return true;\\n            }\\n        }\\n        // 4-odd case\\n        if(odd.size() == 4) {\\n            // store adjacencies of each pair in a matrix\\n            bool mat[4][4];\\n            // find whether each pair of odd vertices already has an edge\\n            for(int i = 0; i < 4; ++i) {\\n                for(int j = 0; j < 4; ++j) {\\n                    mat[i][j] = adj[odd[i]].count(odd[j]) == 0;\\n                }\\n            }\\n            // try all possible pairings and return true if one succeeds\\n            if(mat[0][1] && mat[2][3]) return true;\\n            if(mat[0][2] && mat[1][3]) return true;\\n            if(mat[0][3] && mat[1][2]) return true;\\n        }\\n        // not 0, 2, or 4 odd so we can\\'t solve this, or we failed the check for 2 odd or 4 odds\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        // create a set for each vertex storing all adjacent vertices\\n        vector<unordered_set<int>> adj;\\n        // initialize\\n        for(int i = 0; i < n; ++i) {\\n            unordered_set<int> s = {};\\n            adj.push_back(s);\\n        }\\n        // add each edge to the two corresponding sets\\n        for(vector<int> q : edges) {\\n            adj[q[0] - 1].insert(q[1] - 1);\\n            adj[q[1] - 1].insert(q[0] - 1);\\n        }\\n        // find all odd degree vertices\\n        vector<int> odd;\\n        for(int i = 0; i < n; ++i) {\\n            if(adj[i].size() % 2 == 1) {\\n                odd.push_back(i);\\n            }\\n        }\\n        // no odd vertices means all are even, so we are done\\n        if(odd.size() == 0) return true;\\n        // 2 odd vertex case\\n        if(odd.size() == 2) {\\n            // check if we can just directly add an edge\\n            if(adj[odd[0]].count(odd[1]) == 0) return true;\\n            // otherwise try all possibilities for a third vertex\\n            for(int i = 0; i < n; ++i) {\\n                if(i != odd[0] && i != odd[1]\\n                    && adj[odd[0]].count(i) == 0\\n                    && adj[odd[1]].count(i) == 0) \\n                    return true;\\n            }\\n        }\\n        // 4-odd case\\n        if(odd.size() == 4) {\\n            // store adjacencies of each pair in a matrix\\n            bool mat[4][4];\\n            // find whether each pair of odd vertices already has an edge\\n            for(int i = 0; i < 4; ++i) {\\n                for(int j = 0; j < 4; ++j) {\\n                    mat[i][j] = adj[odd[i]].count(odd[j]) == 0;\\n                }\\n            }\\n            // try all possible pairings and return true if one succeeds\\n            if(mat[0][1] && mat[2][3]) return true;\\n            if(mat[0][2] && mat[1][3]) return true;\\n            if(mat[0][3] && mat[1][2]) return true;\\n        }\\n        // not 0, 2, or 4 odd so we can\\'t solve this, or we failed the check for 2 odd or 4 odds\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2982681,
                "title": "80-faster-easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- 80% faster easy to understand  -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<unordered_set<int>> v(n+1);\\n        for(auto &i: edges){\\n            v[i[0]].insert(i[1]);\\n            v[i[1]].insert(i[0]);\\n        }\\n        vector<int> o;\\n        for(int i = 1; i<=n; i++){\\n            if(v[i].size()%2==1){\\n                o.push_back(i);\\n            }\\n        }\\n        if(o.size()==2){\\n            for(int i = 1; i <= n; i++){\\n                if(v[o[0]].count(i)==0&&v[o[1]].count(i)==0)return true;\\n            }\\n        }\\n        if(o.size()==4){\\n            return (\\n                (v[o[0]].count(o[1])==0&&v[o[2]].count(o[3])==0)\\n            ||  (v[o[0]].count(o[2])==0&&v[o[1]].count(o[3])==0)\\n            ||  (v[o[0]].count(o[3])==0&&v[o[1]].count(o[2])==0)\\n            );\\n        }\\n        return o.size()==0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<unordered_set<int>> v(n+1);\\n        for(auto &i: edges){\\n            v[i[0]].insert(i[1]);\\n            v[i[1]].insert(i[0]);\\n        }\\n        vector<int> o;\\n        for(int i = 1; i<=n; i++){\\n            if(v[i].size()%2==1){\\n                o.push_back(i);\\n            }\\n        }\\n        if(o.size()==2){\\n            for(int i = 1; i <= n; i++){\\n                if(v[o[0]].count(i)==0&&v[o[1]].count(i)==0)return true;\\n            }\\n        }\\n        if(o.size()==4){\\n            return (\\n                (v[o[0]].count(o[1])==0&&v[o[2]].count(o[3])==0)\\n            ||  (v[o[0]].count(o[2])==0&&v[o[1]].count(o[3])==0)\\n            ||  (v[o[0]].count(o[3])==0&&v[o[1]].count(o[2])==0)\\n            );\\n        }\\n        return o.size()==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2982680,
                "title": "80-faster-easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- 80% faster easy to understand  -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<unordered_set<int>> v(n+1);\\n        for(auto &i: edges){\\n            v[i[0]].insert(i[1]);\\n            v[i[1]].insert(i[0]);\\n        }\\n        vector<int> o;\\n        for(int i = 1; i<=n; i++){\\n            if(v[i].size()%2==1){\\n                o.push_back(i);\\n            }\\n        }\\n        if(o.size()==2){\\n            for(int i = 1; i <= n; i++){\\n                if(v[o[0]].count(i)==0&&v[o[1]].count(i)==0)return true;\\n            }\\n        }\\n        if(o.size()==4){\\n            return (\\n                (v[o[0]].count(o[1])==0&&v[o[2]].count(o[3])==0)\\n            ||  (v[o[0]].count(o[2])==0&&v[o[1]].count(o[3])==0)\\n            ||  (v[o[0]].count(o[3])==0&&v[o[1]].count(o[2])==0)\\n            );\\n        }\\n        return o.size()==0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<unordered_set<int>> v(n+1);\\n        for(auto &i: edges){\\n            v[i[0]].insert(i[1]);\\n            v[i[1]].insert(i[0]);\\n        }\\n        vector<int> o;\\n        for(int i = 1; i<=n; i++){\\n            if(v[i].size()%2==1){\\n                o.push_back(i);\\n            }\\n        }\\n        if(o.size()==2){\\n            for(int i = 1; i <= n; i++){\\n                if(v[o[0]].count(i)==0&&v[o[1]].count(i)==0)return true;\\n            }\\n        }\\n        if(o.size()==4){\\n            return (\\n                (v[o[0]].count(o[1])==0&&v[o[2]].count(o[3])==0)\\n            ||  (v[o[0]].count(o[2])==0&&v[o[1]].count(o[3])==0)\\n            ||  (v[o[0]].count(o[3])==0&&v[o[1]].count(o[2])==0)\\n            );\\n        }\\n        return o.size()==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936024,
                "title": "check-for-2-4-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        unordered_set<int> adj[n + 1];\\n        for(auto e : edges) adj[e[0]].insert(e[1]), adj[e[1]].insert(e[0]);\\n        \\n        vector<int> odd, evn;\\n        for(int i=1; i<=n; i++) {\\n            if(adj[i].size() % 2) odd.push_back(i);\\n            else evn.push_back(i);\\n        }\\n        \\n        if(!odd.size()) return true;\\n        if(odd.size() > 4 || odd.size() % 2) return false;\\n\\n        if(odd.size() == 2) {\\n            if(adj[odd[0]].find(odd[1]) == adj[odd[0]].end()) return true;\\n            else {\\n                for(int i : evn) {\\n                    if(adj[i].find(odd[0]) == adj[i].end() && adj[i].find(odd[1]) == adj[i].end()) return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        // odd.size() = 4\\n        unordered_set<int> sOdd(odd.begin(), odd.end()), used;\\n        for(int i : odd) {\\n            for(int j : sOdd) {\\n                if(used.find(i) != used.end() || used.find(j) != used.end()) break;\\n                if(i == j) continue;\\n                if(adj[i].find(j) == adj[i].end()) {\\n                    sOdd.erase(i), sOdd.erase(j);\\n                    used.insert(i), used.insert(j);\\n                    break;\\n                }\\n            }\\n        }\\n        if(!sOdd.size()) return true;\\n        return false; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        unordered_set<int> adj[n + 1];\\n        for(auto e : edges) adj[e[0]].insert(e[1]), adj[e[1]].insert(e[0]);\\n        \\n        vector<int> odd, evn;\\n        for(int i=1; i<=n; i++) {\\n            if(adj[i].size() % 2) odd.push_back(i);\\n            else evn.push_back(i);\\n        }\\n        \\n        if(!odd.size()) return true;\\n        if(odd.size() > 4 || odd.size() % 2) return false;\\n\\n        if(odd.size() == 2) {\\n            if(adj[odd[0]].find(odd[1]) == adj[odd[0]].end()) return true;\\n            else {\\n                for(int i : evn) {\\n                    if(adj[i].find(odd[0]) == adj[i].end() && adj[i].find(odd[1]) == adj[i].end()) return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        // odd.size() = 4\\n        unordered_set<int> sOdd(odd.begin(), odd.end()), used;\\n        for(int i : odd) {\\n            for(int j : sOdd) {\\n                if(used.find(i) != used.end() || used.find(j) != used.end()) break;\\n                if(i == j) continue;\\n                if(adj[i].find(j) == adj[i].end()) {\\n                    sOdd.erase(i), sOdd.erase(j);\\n                    used.insert(i), used.insert(j);\\n                    break;\\n                }\\n            }\\n        }\\n        if(!sOdd.size()) return true;\\n        return false; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2926604,
                "title": "case-by-case-python-solution",
                "content": "# Intuition\\nProblem is only solvable if odd nodes are 2 or 4. Note that it is impossible for there to be 1 or 3 odd nodes, since sum(degrees) %2 == 0\\n\\n# Approach\\nWith 2 odds, they can either connect to each other or to some other vertex that neither is connected to\\n\\nWith 4 odds, there must be two separate pairs of vertices that are unconnected.\\n\\n# Complexity\\n- Time complexity:\\nO(n) since the longest loop is making the graph\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n(note: was updated from previous incorrect solution)\\n```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        neighbors = [set() for _ in range(n)]\\n        for edge in edges:\\n            a, b = edge\\n            a -=1\\n            b -=1\\n            neighbors[a].add(b)\\n            neighbors[b].add(a)\\n        oddDegreesNodes = [i for i in range(n) if (len(neighbors[i]) % 2 == 1)]\\n        numOdd = len(oddDegreesNodes)\\n        if numOdd == 0:\\n            return True\\n        elif numOdd == 4:\\n            # Only possible if there are two pairs of vertices which are not connected\\n            o1, o2, o3, o4 = oddDegreesNodes\\n            return (o1 not in neighbors[o2] and o3 not in neighbors[o4]) or (o1 not in neighbors[o3] and o2 not in neighbors[o4]) or (o1 not in neighbors[o4] and o2 not in neighbors[o3])\\n        elif numOdd == 2:\\n            # Only possible if both not connected or both connected but there is another node to connect to\\n            o1, o2 = oddDegreesNodes\\n            if o1 not in neighbors[o2]:\\n                 # Case 1: Not connected\\n                return True\\n            # Case 2\\n            bothConnectedTo = neighbors[o1] | neighbors[o2]\\n            # Oops, no other node to connect to!\\n            return len(bothConnectedTo) != n\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        neighbors = [set() for _ in range(n)]\\n        for edge in edges:\\n            a, b = edge\\n            a -=1\\n            b -=1\\n            neighbors[a].add(b)\\n            neighbors[b].add(a)\\n        oddDegreesNodes = [i for i in range(n) if (len(neighbors[i]) % 2 == 1)]\\n        numOdd = len(oddDegreesNodes)\\n        if numOdd == 0:\\n            return True\\n        elif numOdd == 4:\\n            # Only possible if there are two pairs of vertices which are not connected\\n            o1, o2, o3, o4 = oddDegreesNodes\\n            return (o1 not in neighbors[o2] and o3 not in neighbors[o4]) or (o1 not in neighbors[o3] and o2 not in neighbors[o4]) or (o1 not in neighbors[o4] and o2 not in neighbors[o3])\\n        elif numOdd == 2:\\n            # Only possible if both not connected or both connected but there is another node to connect to\\n            o1, o2 = oddDegreesNodes\\n            if o1 not in neighbors[o2]:\\n                 # Case 1: Not connected\\n                return True\\n            # Case 2\\n            bothConnectedTo = neighbors[o1] | neighbors[o2]\\n            # Oops, no other node to connect to!\\n            return len(bothConnectedTo) != n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925593,
                "title": "c-easy-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges)\\n    {\\n        map<int,map<int,int>>mpp;\\n        vector<int>cnt(n+1,0);\\n        for(auto it: edges)\\n        {\\n            int a = it[0];\\n            int b = it[1];\\n            mpp[a][b] = 1;\\n            mpp[b][a] = 1;\\n            cnt[a]++;\\n            cnt[b]++;\\n        };\\n        int c= 0;\\n        vector<int>temp;\\n        for(int i = 1;i<=n;i++)\\n        {\\n            if(cnt[i]%2==1)\\n            {\\n                c++;\\n                temp.push_back(i);\\n            }\\n        }\\n      \\n        if(c==0 )\\n        {\\n            return true;\\n        }\\n        else if(c==2)\\n        {\\n          int a = temp[0];\\n            int b = temp[1];\\n            if(mpp[a][b]==1)\\n            {\\n               for(int i  =1;i<=n;i++)\\n               {\\n                   if(cnt[i]%2==0 && mpp[a][i]==0 && mpp[b][i]==0)\\n                   {\\n                       return true;\\n                   }\\n               }\\n                return false;\\n            }\\n            else\\n            return true;\\n        }\\n        else if(c==4)\\n        {\\n            int a  =  temp[0];\\n            for(int i = 1;i<4;i++)\\n            {\\n               int b = temp[i];\\n                if(mpp[a][b]==0)\\n                {\\n                    vector<int>pp;\\n                    for(int k = 1;k<4;k++)\\n                    {\\n                         if(k==i)\\n                             continue;\\n                        else\\n                        pp.push_back(temp[k]);\\n                    }\\n                   int c = pp[0];\\n                    int d = pp[1];\\n                    if(mpp[c][d]==0)\\n                    {\\n                    \\n                        return true;\\n                    }\\n                }\\n            }\\n            return false;\\n        }\\n        else\\n            return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges)\\n    {\\n        map<int,map<int,int>>mpp;\\n        vector<int>cnt(n+1,0);\\n        for(auto it: edges)\\n        {\\n            int a = it[0];\\n            int b = it[1];\\n            mpp[a][b] = 1;\\n            mpp[b][a] = 1;\\n            cnt[a]++;\\n            cnt[b]++;\\n        };\\n        int c= 0;\\n        vector<int>temp;\\n        for(int i = 1;i<=n;i++)\\n        {\\n            if(cnt[i]%2==1)\\n            {\\n                c++;\\n                temp.push_back(i);\\n            }\\n        }\\n      \\n        if(c==0 )\\n        {\\n            return true;\\n        }\\n        else if(c==2)\\n        {\\n          int a = temp[0];\\n            int b = temp[1];\\n            if(mpp[a][b]==1)\\n            {\\n               for(int i  =1;i<=n;i++)\\n               {\\n                   if(cnt[i]%2==0 && mpp[a][i]==0 && mpp[b][i]==0)\\n                   {\\n                       return true;\\n                   }\\n               }\\n                return false;\\n            }\\n            else\\n            return true;\\n        }\\n        else if(c==4)\\n        {\\n            int a  =  temp[0];\\n            for(int i = 1;i<4;i++)\\n            {\\n               int b = temp[i];\\n                if(mpp[a][b]==0)\\n                {\\n                    vector<int>pp;\\n                    for(int k = 1;k<4;k++)\\n                    {\\n                         if(k==i)\\n                             continue;\\n                        else\\n                        pp.push_back(temp[k]);\\n                    }\\n                   int c = pp[0];\\n                    int d = pp[1];\\n                    if(mpp[c][d]==0)\\n                    {\\n                    \\n                        return true;\\n                    }\\n                }\\n            }\\n            return false;\\n        }\\n        else\\n            return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925160,
                "title": "simple-rust-solution",
                "content": "Try to connect nodes with odd degrees.\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn is_possible(n: i32, edges: Vec<Vec<i32>>) -> bool {\\n        let n = n as usize;\\n        let mut odd_degree = vec![false; n];\\n        let mut edge_set = std::collections::HashSet::new();\\n\\n        for edge in edges.iter() {\\n            let a = edge[0] as usize - 1;\\n            let b = edge[1] as usize - 1;\\n            odd_degree[a] = !odd_degree[a];\\n            odd_degree[b] = !odd_degree[b];\\n            edge_set.insert((a, b));\\n            edge_set.insert((b, a));\\n        }\\n\\n        let odd_nodes: Vec<_> = (0..n).filter(|&i| odd_degree[i]).collect();\\n\\n        match odd_nodes.len() {\\n            0 => true,\\n            2 => {\\n                let a = odd_nodes[0];\\n                let b = odd_nodes[1];\\n                if edge_set.contains(&(a, b)) {\\n                    for i in 0..n {\\n                        if !odd_degree[i] && i != a && i != b && !edge_set.contains(&(a, i)) && !edge_set.contains(&(b, i)) {\\n                            return true\\n                        }\\n                    }\\n                    false\\n                } else {\\n                    true\\n                }\\n            },\\n            4 => {\\n                let a = odd_nodes[0];\\n                let b = odd_nodes[1];\\n                let c = odd_nodes[2];\\n                let d = odd_nodes[3];\\n\\n                let test_nodes = |s, t, u, v| !edge_set.contains(&(s, t)) && !edge_set.contains(&(u, v));\\n\\n                test_nodes(a, b, c, d) || test_nodes(a, c, b, d) || test_nodes(a, d, b, c)\\n            },\\n            _ => false,\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn is_possible(n: i32, edges: Vec<Vec<i32>>) -> bool {\\n        let n = n as usize;\\n        let mut odd_degree = vec![false; n];\\n        let mut edge_set = std::collections::HashSet::new();\\n\\n        for edge in edges.iter() {\\n            let a = edge[0] as usize - 1;\\n            let b = edge[1] as usize - 1;\\n            odd_degree[a] = !odd_degree[a];\\n            odd_degree[b] = !odd_degree[b];\\n            edge_set.insert((a, b));\\n            edge_set.insert((b, a));\\n        }\\n\\n        let odd_nodes: Vec<_> = (0..n).filter(|&i| odd_degree[i]).collect();\\n\\n        match odd_nodes.len() {\\n            0 => true,\\n            2 => {\\n                let a = odd_nodes[0];\\n                let b = odd_nodes[1];\\n                if edge_set.contains(&(a, b)) {\\n                    for i in 0..n {\\n                        if !odd_degree[i] && i != a && i != b && !edge_set.contains(&(a, i)) && !edge_set.contains(&(b, i)) {\\n                            return true\\n                        }\\n                    }\\n                    false\\n                } else {\\n                    true\\n                }\\n            },\\n            4 => {\\n                let a = odd_nodes[0];\\n                let b = odd_nodes[1];\\n                let c = odd_nodes[2];\\n                let d = odd_nodes[3];\\n\\n                let test_nodes = |s, t, u, v| !edge_set.contains(&(s, t)) && !edge_set.contains(&(u, v));\\n\\n                test_nodes(a, b, c, d) || test_nodes(a, c, b, d) || test_nodes(a, d, b, c)\\n            },\\n            _ => false,\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2924481,
                "title": "c-bitmask-and-recursion-solution-with-configurable-no-of-edges",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to consider odd indeg nodes and combine them. Sometime, it is possible that edge b/w them already exists. In that case, add edge b/w them and some common even indeg node.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind all nodes with indeg as odd\\ncheck edge can be added directly or indirectly\\nUse mask to track edge created or nodes connected\\nIf 2 * 2 = 4 < odd nodes then return false. This value is configurable in my code\\n\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nbool can_add_edge_directly(int source, int dest, vector<set<int>>& edgeset) {\\n    return edgeset[source].find(dest) == edgeset[source].end(); // check if source <-> dest can be added\\n}\\n\\nbool can_add_edge_indirectly(int source, int dest, vector<set<int>>& edgeset) {\\n    for(int i = 1; i < edgeset.size(); i++ ) { // find an even indeg node and check if both source & dest can be added\\n        if(edgeset[i].size() % 2) continue;\\n        bool source_absent = edgeset[i].find(source) == edgeset[i].end();\\n        bool dest_absent = edgeset[i].find(dest) == edgeset[i].end();\\n        if(source_absent and dest_absent) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n\\nclass Solution {\\npublic:\\n    bool solve(int mask,int i, vector<int>& odd_indeg, vector<set<int>>& edgeset) {\\n        if(mask == (1 << odd_indeg.size()) - 1) { // 11, 1111 is the desired state. Note: - 1 or 111 case will never come\\n            return true;\\n        }\\n        if(i == odd_indeg.size()) { // array exhausted -> not possible\\n            return false;\\n        }\\n        if(mask & (1 << i)) { // already considered -> move to next\\n            return solve(mask, i + 1, odd_indeg, edgeset);\\n        }\\n        for(int j = i + 1; j < odd_indeg.size(); j++) {\\n            if(!(mask & (1 << j)) ) {\\n                bool direct_add = can_add_edge_directly(odd_indeg[i], odd_indeg[j], edgeset);\\n                bool indirect_add = can_add_edge_indirectly(odd_indeg[i], odd_indeg[j], edgeset);\\n                if(direct_add || indirect_add) {\\n                    if(solve(mask | (1 << i) | (1 << j), i + 1, odd_indeg, edgeset)) {\\n                        return true;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<set<int>> edgeset(n + 1); // set helps us to search faster\\n        for(auto e : edges) {\\n            edgeset[e[0]].insert(e[1]);\\n            edgeset[e[1]].insert(e[0]);\\n        }\\n        vector<int> odd_indeg;\\n        for(int i = 1; i <= n; i++) {\\n            if(edgeset[i].size() % 2) {\\n                odd_indeg.push_back(i);\\n            }\\n        }\\n        // 2 * 2 = 4 is configurable, if someone asks for atmost 3, then we can change it to 3 * 2 = 6\\n        if(2 * 2 < odd_indeg.size())    return false; \\n        return solve(0, 0, odd_indeg, edgeset);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool can_add_edge_directly(int source, int dest, vector<set<int>>& edgeset) {\\n    return edgeset[source].find(dest) == edgeset[source].end(); // check if source <-> dest can be added\\n}\\n\\nbool can_add_edge_indirectly(int source, int dest, vector<set<int>>& edgeset) {\\n    for(int i = 1; i < edgeset.size(); i++ ) { // find an even indeg node and check if both source & dest can be added\\n        if(edgeset[i].size() % 2) continue;\\n        bool source_absent = edgeset[i].find(source) == edgeset[i].end();\\n        bool dest_absent = edgeset[i].find(dest) == edgeset[i].end();\\n        if(source_absent and dest_absent) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n\\nclass Solution {\\npublic:\\n    bool solve(int mask,int i, vector<int>& odd_indeg, vector<set<int>>& edgeset) {\\n        if(mask == (1 << odd_indeg.size()) - 1) { // 11, 1111 is the desired state. Note: - 1 or 111 case will never come\\n            return true;\\n        }\\n        if(i == odd_indeg.size()) { // array exhausted -> not possible\\n            return false;\\n        }\\n        if(mask & (1 << i)) { // already considered -> move to next\\n            return solve(mask, i + 1, odd_indeg, edgeset);\\n        }\\n        for(int j = i + 1; j < odd_indeg.size(); j++) {\\n            if(!(mask & (1 << j)) ) {\\n                bool direct_add = can_add_edge_directly(odd_indeg[i], odd_indeg[j], edgeset);\\n                bool indirect_add = can_add_edge_indirectly(odd_indeg[i], odd_indeg[j], edgeset);\\n                if(direct_add || indirect_add) {\\n                    if(solve(mask | (1 << i) | (1 << j), i + 1, odd_indeg, edgeset)) {\\n                        return true;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<set<int>> edgeset(n + 1); // set helps us to search faster\\n        for(auto e : edges) {\\n            edgeset[e[0]].insert(e[1]);\\n            edgeset[e[1]].insert(e[0]);\\n        }\\n        vector<int> odd_indeg;\\n        for(int i = 1; i <= n; i++) {\\n            if(edgeset[i].size() % 2) {\\n                odd_indeg.push_back(i);\\n            }\\n        }\\n        // 2 * 2 = 4 is configurable, if someone asks for atmost 3, then we can change it to 3 * 2 = 6\\n        if(2 * 2 < odd_indeg.size())    return false; \\n        return solve(0, 0, odd_indeg, edgeset);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924473,
                "title": "simple-and-obvious-solution-with-comments",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {boolean}\\n */\\nvar isPossible = function(n, edges) {\\n  const graph = new Map()\\n  const odd = []\\n    \\n  // Making graph [{node: Set(...edges)}, ...]\\n  for (let edge of edges) { \\n    const [from,to] = edge    \\n    // Connect first node with second in a graph\\n    if (graph.has(from)) {\\n      graph.get(from).add(to)\\n    } else {\\n      const set = new Set([to])\\n      graph.set(from,  set)\\n    }\\n    // Connect second node with first in a graph\\n    if (graph.has(to)) {\\n      graph.get(to).add(from)\\n    } else {\\n      const set = new Set([from])\\n      graph.set(to,  set)\\n    }\\n  }\\n\\n  // Find all edges with odd length\\n  for (let [key,value] of graph) {\\n    if (value.size % 2 !== 0) {\\n      odd.push(key)\\n    }\\n  }\\n\\n  if (odd.length === 4) {\\n    // Check if 2 nodes havent edges between each other\\n    const [a,b,c,] = [graph.get(odd[0]),graph.get(odd[1]),graph.get(odd[2])]\\n    if ( !a.has(odd[1]) && !c.has(odd[3]) // AB CD\\n      || !a.has(odd[2]) && !b.has(odd[3]) // AC BD\\n      || !a.has(odd[3]) && !c.has(odd[1])) //AD CB\\n    {       \\n        return true\\n    }\\n  }\\n\\n  if (odd.length === 2) {\\n    const a = graph.get(odd[0])\\n    // Check if 1st node hasn\\'t edge between 2nd node\\n    if (!a.has(odd[1])) return true\\n\\n    // Also if nodes two node has edges between each other\\n    // we need to find in graph node which hasn\\'t edge \\n    // beteween 1st and 2nd node\\n    for (let [_, currentEdges] of graph) {\\n      if (!currentEdges.has(odd[0]) && !currentEdges.has(odd[1])) {\\n        return true\\n      }\\n    }\\n  }\\n\\n  // Otherwise return false :)\\n  return odd.length === 0\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Graph"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {boolean}\\n */\\nvar isPossible = function(n, edges) {\\n  const graph = new Map()\\n  const odd = []\\n    \\n  // Making graph [{node: Set(...edges)}, ...]\\n  for (let edge of edges) { \\n    const [from,to] = edge    \\n    // Connect first node with second in a graph\\n    if (graph.has(from)) {\\n      graph.get(from).add(to)\\n    } else {\\n      const set = new Set([to])\\n      graph.set(from,  set)\\n    }\\n    // Connect second node with first in a graph\\n    if (graph.has(to)) {\\n      graph.get(to).add(from)\\n    } else {\\n      const set = new Set([from])\\n      graph.set(to,  set)\\n    }\\n  }\\n\\n  // Find all edges with odd length\\n  for (let [key,value] of graph) {\\n    if (value.size % 2 !== 0) {\\n      odd.push(key)\\n    }\\n  }\\n\\n  if (odd.length === 4) {\\n    // Check if 2 nodes havent edges between each other\\n    const [a,b,c,] = [graph.get(odd[0]),graph.get(odd[1]),graph.get(odd[2])]\\n    if ( !a.has(odd[1]) && !c.has(odd[3]) // AB CD\\n      || !a.has(odd[2]) && !b.has(odd[3]) // AC BD\\n      || !a.has(odd[3]) && !c.has(odd[1])) //AD CB\\n    {       \\n        return true\\n    }\\n  }\\n\\n  if (odd.length === 2) {\\n    const a = graph.get(odd[0])\\n    // Check if 1st node hasn\\'t edge between 2nd node\\n    if (!a.has(odd[1])) return true\\n\\n    // Also if nodes two node has edges between each other\\n    // we need to find in graph node which hasn\\'t edge \\n    // beteween 1st and 2nd node\\n    for (let [_, currentEdges] of graph) {\\n      if (!currentEdges.has(odd[0]) && !currentEdges.has(odd[1])) {\\n        return true\\n      }\\n    }\\n  }\\n\\n  // Otherwise return false :)\\n  return odd.length === 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2924034,
                "title": "simplest-method-brute-force-observation-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we can add at max 2 edges, we can affect the degree of at max 4 nodes. So if there are more than 4 nodes with odd degree the answer will always be `false`. Otherwise, 4 being a very small number we could just add the required edges in a brute force manner and check.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet the number of nodes with odd length be `m`.\\nThere will be `5` cases: \\n- if `m == 0`: trivial case, `true`.\\n- if `m` is odd: always `false`. Adding an edge always affects 2 nodes at a time. So we can only fix even number of nodes.\\n- if `m == 2`: There are two possibilites. Either we add an edge between those two nodes. Or, we pick a third good node and add 2 edges to it, one through each of the bad nodes. Both these alternatives are only possible when both the bad nodes have a degree less than the total nubmer of edges - 1 so checking for that is sufficient.\\n- if `m == 4`: There are multiple arrangements for making the graph good. In total there are at max 16 possibilities of adding edges which is small number so we just simulate it and check.\\n- if `m > 4`: always `false`\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(16 * ((n * (n - 1)) / 2))** worst case, when if have a complete graph and exactly 4 nodes with odd degree.(Highly unlikely though) \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(N)** for storing the degree of each node.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> deg(n + 1, 0); \\n        vector<int> odd_deg_nodes; \\n        for (auto &edge : edges) {\\n            deg[edge[0]]++; \\n            deg[edge[1]]++;\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            if (deg[i] & 1) {\\n                odd_deg_nodes.push_back(i); \\n            }\\n        }\\n        int m = odd_deg_nodes.size(); \\n        if (m % 2) {\\n            return false; \\n        } else if (m <= 4) {\\n            if (m == 2) {\\n                return (deg[odd_deg_nodes[0]] < n - 1 && deg[odd_deg_nodes[1]] < n - 1);\\n            } else {\\n                bool possible = true; \\n                int count = 0; \\n                for (int i = 0; i < m - 1; i++) {\\n                    if (deg[odd_deg_nodes[i]] % 2 == 0) {\\n                        continue; \\n                    }\\n                    for (int j = i + 1; j < m; j++) {\\n                        if (deg[odd_deg_nodes[i]] % 2 == 0 || deg[odd_deg_nodes[j]] % 2 == 0) {\\n                            continue; \\n                        }\\n                        \\n                        bool found = edgePresent(odd_deg_nodes[i], odd_deg_nodes[j], edges); // check if that edge is already present\\n                        // if not present and we can still add edges then add it\\n                        if (!found && count < 2) {\\n                            deg[odd_deg_nodes[i]]++; \\n                            deg[odd_deg_nodes[j]]++; \\n                            count++; \\n                        }\\n                    }\\n                }\\n                for (int i = 1; i <= n; i++) {\\n                    possible &= (deg[i] % 2 == 0);\\n                }\\n                return possible; \\n            }\\n        } else {\\n            return false; \\n        }\\n    }\\nprivate: \\n    bool edgePresent (int u, int v, vector<vector<int>> &edges) {\\n        vector<int> new_edge_1 = {u, v}, new_edge_2 = {v, u}; \\n        \\n        for (auto &edge : edges) {\\n            if ((new_edge_1 == edge) || (new_edge_2 == edge)) {\\n                return true;\\n            }\\n        }\\n        return false; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> deg(n + 1, 0); \\n        vector<int> odd_deg_nodes; \\n        for (auto &edge : edges) {\\n            deg[edge[0]]++; \\n            deg[edge[1]]++;\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            if (deg[i] & 1) {\\n                odd_deg_nodes.push_back(i); \\n            }\\n        }\\n        int m = odd_deg_nodes.size(); \\n        if (m % 2) {\\n            return false; \\n        } else if (m <= 4) {\\n            if (m == 2) {\\n                return (deg[odd_deg_nodes[0]] < n - 1 && deg[odd_deg_nodes[1]] < n - 1);\\n            } else {\\n                bool possible = true; \\n                int count = 0; \\n                for (int i = 0; i < m - 1; i++) {\\n                    if (deg[odd_deg_nodes[i]] % 2 == 0) {\\n                        continue; \\n                    }\\n                    for (int j = i + 1; j < m; j++) {\\n                        if (deg[odd_deg_nodes[i]] % 2 == 0 || deg[odd_deg_nodes[j]] % 2 == 0) {\\n                            continue; \\n                        }\\n                        \\n                        bool found = edgePresent(odd_deg_nodes[i], odd_deg_nodes[j], edges); // check if that edge is already present\\n                        // if not present and we can still add edges then add it\\n                        if (!found && count < 2) {\\n                            deg[odd_deg_nodes[i]]++; \\n                            deg[odd_deg_nodes[j]]++; \\n                            count++; \\n                        }\\n                    }\\n                }\\n                for (int i = 1; i <= n; i++) {\\n                    possible &= (deg[i] % 2 == 0);\\n                }\\n                return possible; \\n            }\\n        } else {\\n            return false; \\n        }\\n    }\\nprivate: \\n    bool edgePresent (int u, int v, vector<vector<int>> &edges) {\\n        vector<int> new_edge_1 = {u, v}, new_edge_2 = {v, u}; \\n        \\n        for (auto &edge : edges) {\\n            if ((new_edge_1 == edge) || (new_edge_2 == edge)) {\\n                return true;\\n            }\\n        }\\n        return false; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924011,
                "title": "cpp-brute-force-greet",
                "content": "\\nAnswer can be true or false.So there are only two cases.\\nCase1:True\\nJust calculate how many nodes are  odd-degree.\\n1.If odd == 0,It is already \"fixed\".\\n2.If odd == 2, and the two odd vertices are v,u - then we can \"fix\" them by either connecting them if they are not connected, or by finding another vertex w such that w is even-degree-node and then add the two edges(v,w),(u,w).\\n3.If odd == 4, the only way to \"fix\" them is by connecting them to each other, in 2 groups of 2: each edge on two different vertices.\\nCase2.False\\nIn all other case ,It is not possible to obtain a valid graph with adding at most 2 edges.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isConnected(int s,int d,vector<int>adj[],int n)\\n{\\n    \\n    for(int i=0;i<adj[s].size();i++){\\n        if(adj[s][i]==d)return true;\\n    }\\n     return false;\\n    \\n}\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        \\n\\n        vector<int>adj[n+1];\\n\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int odd=0;\\n        vector<int>odd_v;\\n        for(int i=0;i<=n;i++){\\n           // cout<<adj[i].size()<<\"\\\\n\";\\n            if((adj[i].size())%2==1){\\n                odd++;\\n                odd_v.push_back(i);\\n            }\\n        }\\n        //cout<<odd<<\"\\\\n\";\\n        if (odd == 0) {\\n        return true;\\n    } else if (odd == 2) {\\n        int a = odd_v[0];\\n        int b = odd_v[1];\\n        int n1=adj[a].size();int n2=adj[b].size();\\n            //if(n1!=n-1&&n2!=n-1)return true;\\n        //M#1-by connecting both the odd-degree-node\\n            if(!isConnected(a,b,adj,n))\\n                return true;\\n        //M#2-by finding one another even-degree-node to which  both the odd-degree-nodes are not already connected\\n            for (int i = 1; i <= n; ++i) {\\n                unordered_set<int>s;// set to check if two nodes can be connected (Efficiently)\\n                for(auto it:adj[i]){\\n                s.insert(it);\\n                }\\n                if (i != a && i != b && s.find(a) == s.end() \\n                    && s.find(b) == s.end()) {\\n                    return true;\\n                }\\n            }\\n                return false;\\n        \\n    } else if (odd == 4) {\\n        int a = odd_v[0];\\n        int b = odd_v[1];\\n        int c = odd_v[2];\\n        int d = odd_v[3];\\n        if ((!isConnected(a,b,adj,n) && !isConnected(c,d,adj,n)) ||\\n            (!isConnected(a,c,adj,n) && !isConnected(b,d,adj,n)) ||\\n            (!isConnected(a,d,adj,n) && !isConnected(b,c,adj,n))) {\\n            \\n           return true;\\n        }\\n        return false;\\n    } else {\\n        return false;\\n    }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isConnected(int s,int d,vector<int>adj[],int n)\\n{\\n    \\n    for(int i=0;i<adj[s].size();i++){\\n        if(adj[s][i]==d)return true;\\n    }\\n     return false;\\n    \\n}\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        \\n\\n        vector<int>adj[n+1];\\n\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int odd=0;\\n        vector<int>odd_v;\\n        for(int i=0;i<=n;i++){\\n           // cout<<adj[i].size()<<\"\\\\n\";\\n            if((adj[i].size())%2==1){\\n                odd++;\\n                odd_v.push_back(i);\\n            }\\n        }\\n        //cout<<odd<<\"\\\\n\";\\n        if (odd == 0) {\\n        return true;\\n    } else if (odd == 2) {\\n        int a = odd_v[0];\\n        int b = odd_v[1];\\n        int n1=adj[a].size();int n2=adj[b].size();\\n            //if(n1!=n-1&&n2!=n-1)return true;\\n        //M#1-by connecting both the odd-degree-node\\n            if(!isConnected(a,b,adj,n))\\n                return true;\\n        //M#2-by finding one another even-degree-node to which  both the odd-degree-nodes are not already connected\\n            for (int i = 1; i <= n; ++i) {\\n                unordered_set<int>s;// set to check if two nodes can be connected (Efficiently)\\n                for(auto it:adj[i]){\\n                s.insert(it);\\n                }\\n                if (i != a && i != b && s.find(a) == s.end() \\n                    && s.find(b) == s.end()) {\\n                    return true;\\n                }\\n            }\\n                return false;\\n        \\n    } else if (odd == 4) {\\n        int a = odd_v[0];\\n        int b = odd_v[1];\\n        int c = odd_v[2];\\n        int d = odd_v[3];\\n        if ((!isConnected(a,b,adj,n) && !isConnected(c,d,adj,n)) ||\\n            (!isConnected(a,c,adj,n) && !isConnected(b,d,adj,n)) ||\\n            (!isConnected(a,d,adj,n) && !isConnected(b,c,adj,n))) {\\n            \\n           return true;\\n        }\\n        return false;\\n    } else {\\n        return false;\\n    }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2923675,
                "title": "java-intutive-solution-find-nodes-with-odd-degree-first",
                "content": "```Java\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        int[] degree = new int[n + 1];\\n        HashSet<Integer>[] g = new HashSet[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            g[i] = new HashSet<>();\\n        }\\n        for (List<Integer> e : edges) {\\n            int a = e.get(0);\\n            int b = e.get(1);\\n            g[a].add(b);\\n            g[b].add(a);\\n            degree[a]++;\\n            degree[b]++;\\n        }\\n        ArrayList<Integer> nodes = new ArrayList<>();\\n        for (int i = 1; i <= n; i++) {\\n            if ( (degree[i] % 2) != 0) {\\n                nodes.add(i);\\n            }\\n        }\\n        \\n        if (nodes.size() == 0) {\\n            return true;\\n        } else if (nodes.size() == 2) {\\n            int a = nodes.get(0);\\n            int b = nodes.get(1);\\n            // connect a and b directly\\n            if (!g[a].contains(b)) return true;\\n            // connect a and b throw another node.  Donot forget this case.\\n            for (int i = 1; i <= n; i++) {\\n                if (i == a) continue;\\n                if (i == b) continue;\\n                if (!g[a].contains(i) && !g[b].contains(i)) return true;\\n            }\\n            return false;\\n        } else if (nodes.size() == 4) {\\n            int a = nodes.get(0);\\n            int b = nodes.get(1);\\n            int c = nodes.get(2);\\n            int d = nodes.get(3);\\n            if (!g[a].contains(b) && !g[c].contains(d)) return true;\\n            if (!g[a].contains(c) && !g[b].contains(d)) return true;\\n            if (!g[a].contains(d) && !g[b].contains(c)) return true;\\n            return false;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Java\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        int[] degree = new int[n + 1];\\n        HashSet<Integer>[] g = new HashSet[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            g[i] = new HashSet<>();\\n        }\\n        for (List<Integer> e : edges) {\\n            int a = e.get(0);\\n            int b = e.get(1);\\n            g[a].add(b);\\n            g[b].add(a);\\n            degree[a]++;\\n            degree[b]++;\\n        }\\n        ArrayList<Integer> nodes = new ArrayList<>();\\n        for (int i = 1; i <= n; i++) {\\n            if ( (degree[i] % 2) != 0) {\\n                nodes.add(i);\\n            }\\n        }\\n        \\n        if (nodes.size() == 0) {\\n            return true;\\n        } else if (nodes.size() == 2) {\\n            int a = nodes.get(0);\\n            int b = nodes.get(1);\\n            // connect a and b directly\\n            if (!g[a].contains(b)) return true;\\n            // connect a and b throw another node.  Donot forget this case.\\n            for (int i = 1; i <= n; i++) {\\n                if (i == a) continue;\\n                if (i == b) continue;\\n                if (!g[a].contains(i) && !g[b].contains(i)) return true;\\n            }\\n            return false;\\n        } else if (nodes.size() == 4) {\\n            int a = nodes.get(0);\\n            int b = nodes.get(1);\\n            int c = nodes.get(2);\\n            int d = nodes.get(3);\\n            if (!g[a].contains(b) && !g[c].contains(d)) return true;\\n            if (!g[a].contains(c) && !g[b].contains(d)) return true;\\n            if (!g[a].contains(d) && !g[b].contains(c)) return true;\\n            return false;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923654,
                "title": "super-easy-to-understand",
                "content": "# Intuition\\nCalculate in-degree of each node\\n\\n# Approach\\nTry to match the possible pairs\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        List<Set<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i <= n; i++) {\\n            graph.add(new HashSet<>());\\n        }\\n        for (List<Integer> edge : edges) {\\n            int node1 = edge.get(0);\\n            int node2 = edge.get(1);\\n            graph.get(node1).add(node2);\\n            graph.get(node2).add(node1);\\n        }\\n        Set<Integer> oddNodes = new HashSet<>();\\n        int odds = 0;\\n        for (int i = 1 ; i <= n; i++) {\\n            if (graph.get(i).size() % 2 == 1) {\\n                odds++;\\n                oddNodes.add(i);\\n            }\\n        }\\n        if (odds > 4 || odds == 1) {\\n            return false;\\n        }\\n        if (odds == 0) {\\n            return true;\\n        }\\n        if (odds == 2) {\\n            List<Integer> list = new ArrayList<>(oddNodes);\\n            int node1 = list.get(0);\\n            int node2 = list.get(1);\\n            if (!graph.get(node1).contains(node2)) {\\n                return true;\\n            }\\n            Set<Integer> common = new HashSet<>();\\n            common.addAll(graph.get(node1));\\n            common.addAll(graph.get(node2));\\n            return common.size() < n;\\n        }\\n        if (odds == 3) {\\n            List<Integer> list = new ArrayList<>(oddNodes);\\n            int node1 = list.get(0);\\n            int node2 = list.get(1);\\n            int node3 = list.get(2);\\n            return goodToConnectThree(node1, node2, node3, graph) ||\\n                    goodToConnectThree(node1, node3, node2, graph) ||\\n                    goodToConnectThree(node2, node3, node1, graph);\\n        }\\n        if (odds == 4) {\\n            List<Integer> list = new ArrayList<>(oddNodes);\\n            int node1 = list.get(0);\\n            int node2 = list.get(1);\\n            int node3 = list.get(2);\\n            int node4 = list.get(3);\\n            return (goodToConnect(node1, node2, graph) && goodToConnect(node3, node4, graph)) ||\\n                    (goodToConnect(node1, node3, graph) && goodToConnect(node2, node4, graph)) ||\\n                    (goodToConnect(node1, node4, graph) && goodToConnect(node2, node3, graph));\\n        }\\n        return false;\\n    }\\n    \\n    private boolean goodToConnectThree(int l, int r, int m, List<Set<Integer>> graph) {\\n        return !graph.get(l).contains(m) && !graph.get(r).contains(m);\\n    }\\n    \\n    private boolean goodToConnect(int l, int r, List<Set<Integer>> graph) {\\n        return !graph.get(l).contains(r);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        List<Set<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i <= n; i++) {\\n            graph.add(new HashSet<>());\\n        }\\n        for (List<Integer> edge : edges) {\\n            int node1 = edge.get(0);\\n            int node2 = edge.get(1);\\n            graph.get(node1).add(node2);\\n            graph.get(node2).add(node1);\\n        }\\n        Set<Integer> oddNodes = new HashSet<>();\\n        int odds = 0;\\n        for (int i = 1 ; i <= n; i++) {\\n            if (graph.get(i).size() % 2 == 1) {\\n                odds++;\\n                oddNodes.add(i);\\n            }\\n        }\\n        if (odds > 4 || odds == 1) {\\n            return false;\\n        }\\n        if (odds == 0) {\\n            return true;\\n        }\\n        if (odds == 2) {\\n            List<Integer> list = new ArrayList<>(oddNodes);\\n            int node1 = list.get(0);\\n            int node2 = list.get(1);\\n            if (!graph.get(node1).contains(node2)) {\\n                return true;\\n            }\\n            Set<Integer> common = new HashSet<>();\\n            common.addAll(graph.get(node1));\\n            common.addAll(graph.get(node2));\\n            return common.size() < n;\\n        }\\n        if (odds == 3) {\\n            List<Integer> list = new ArrayList<>(oddNodes);\\n            int node1 = list.get(0);\\n            int node2 = list.get(1);\\n            int node3 = list.get(2);\\n            return goodToConnectThree(node1, node2, node3, graph) ||\\n                    goodToConnectThree(node1, node3, node2, graph) ||\\n                    goodToConnectThree(node2, node3, node1, graph);\\n        }\\n        if (odds == 4) {\\n            List<Integer> list = new ArrayList<>(oddNodes);\\n            int node1 = list.get(0);\\n            int node2 = list.get(1);\\n            int node3 = list.get(2);\\n            int node4 = list.get(3);\\n            return (goodToConnect(node1, node2, graph) && goodToConnect(node3, node4, graph)) ||\\n                    (goodToConnect(node1, node3, graph) && goodToConnect(node2, node4, graph)) ||\\n                    (goodToConnect(node1, node4, graph) && goodToConnect(node2, node3, graph));\\n        }\\n        return false;\\n    }\\n    \\n    private boolean goodToConnectThree(int l, int r, int m, List<Set<Integer>> graph) {\\n        return !graph.get(l).contains(m) && !graph.get(r).contains(m);\\n    }\\n    \\n    private boolean goodToConnect(int l, int r, List<Set<Integer>> graph) {\\n        return !graph.get(l).contains(r);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923651,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        unordered_map <int,int> ump;\\n        vector <int> oddNode;\\n        vector <vector<int>> matrix(n+1);\\n        for(auto &it:edges){\\n            ump[it[0]]++;\\n            ump[it[1]]++;\\n            matrix[it[1]].push_back(it[0]);\\n            matrix[it[0]].push_back(it[1]);\\n        }\\n        int odd = 0;\\n        for(auto &it:ump){\\n            if(it.second % 2){\\n                odd++;\\n                oddNode.push_back(it.first);\\n            }\\n        }\\n        if(!odd)\\n            return true;\\n        else if(odd == 2){\\n            int a = oddNode[0];\\n            int b = oddNode[1];\\n            for(int i=1;i<n;i++){\\n                vector<int>::iterator it;\\n                it = find(matrix[i].begin(),matrix[i].end(),a);\\n                bool f1 = it != matrix[i].end();\\n                it = find(matrix[i].begin(),matrix[i].end(),b);\\n                bool f2 = it != matrix[i].end();\\n                if(!f1 && !f2)\\n                    return true;\\n            }\\n            return false;\\n        }\\n        else if(odd == 4){\\n            int a = oddNode[0];\\n            int b = oddNode[1];\\n            int c = oddNode[2];\\n            int d = oddNode[3];\\n            vector<int>::iterator it;\\n            it = find(matrix[a].begin(),matrix[a].end(),b);\\n            bool f1 = it != matrix[a].end();\\n            it = find(matrix[c].begin(),matrix[c].end(),d);\\n            bool f2 = it != matrix[c].end();\\n            it = find(matrix[a].begin(),matrix[a].end(),c);\\n            bool f3 = it != matrix[a].end();\\n            it = find(matrix[b].begin(),matrix[b].end(),d);\\n            bool f4 = it != matrix[b].end();\\n            it = find(matrix[a].begin(),matrix[a].end(),d);\\n            bool f5 = it != matrix[a].end();\\n            it = find(matrix[b].begin(),matrix[b].end(),c);\\n            bool f6 = it != matrix[b].end();\\n            if((!f1 && !f2) || (!f3 && !f4) || (!f5 && !f6))\\n                return true;\\n            return false;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Graph",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        unordered_map <int,int> ump;\\n        vector <int> oddNode;\\n        vector <vector<int>> matrix(n+1);\\n        for(auto &it:edges){\\n            ump[it[0]]++;\\n            ump[it[1]]++;\\n            matrix[it[1]].push_back(it[0]);\\n            matrix[it[0]].push_back(it[1]);\\n        }\\n        int odd = 0;\\n        for(auto &it:ump){\\n            if(it.second % 2){\\n                odd++;\\n                oddNode.push_back(it.first);\\n            }\\n        }\\n        if(!odd)\\n            return true;\\n        else if(odd == 2){\\n            int a = oddNode[0];\\n            int b = oddNode[1];\\n            for(int i=1;i<n;i++){\\n                vector<int>::iterator it;\\n                it = find(matrix[i].begin(),matrix[i].end(),a);\\n                bool f1 = it != matrix[i].end();\\n                it = find(matrix[i].begin(),matrix[i].end(),b);\\n                bool f2 = it != matrix[i].end();\\n                if(!f1 && !f2)\\n                    return true;\\n            }\\n            return false;\\n        }\\n        else if(odd == 4){\\n            int a = oddNode[0];\\n            int b = oddNode[1];\\n            int c = oddNode[2];\\n            int d = oddNode[3];\\n            vector<int>::iterator it;\\n            it = find(matrix[a].begin(),matrix[a].end(),b);\\n            bool f1 = it != matrix[a].end();\\n            it = find(matrix[c].begin(),matrix[c].end(),d);\\n            bool f2 = it != matrix[c].end();\\n            it = find(matrix[a].begin(),matrix[a].end(),c);\\n            bool f3 = it != matrix[a].end();\\n            it = find(matrix[b].begin(),matrix[b].end(),d);\\n            bool f4 = it != matrix[b].end();\\n            it = find(matrix[a].begin(),matrix[a].end(),d);\\n            bool f5 = it != matrix[a].end();\\n            it = find(matrix[b].begin(),matrix[b].end(),c);\\n            bool f6 = it != matrix[b].end();\\n            if((!f1 && !f2) || (!f3 && !f4) || (!f5 && !f6))\\n                return true;\\n            return false;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923631,
                "title": "c-matching-odd-degree-nodes-o-nlogn-explained",
                "content": "# Approach\\nConsidering the following conditions one by one:\\n- If $0$ nodes having odd degree: PASS\\n- If odd nodes having odd degree: FAIL\\n- If exactly $2$ nodes having odd degree:\\n    - If they have no directed edge between them: PASS\\n    - If existing any other node which has no directed edge toward those $2$ nodes: PASS\\n    - Otherwise: FAIL\\n- If exactly $4$ nodes having odd degree:\\n    - Divided into $2$ groups, for each group if they all have no directed edge between them: PASS\\n    - Otherwise: FAIL\\n\\n# Complexity\\n- Time complexity: $O(n\\\\log{n})$\\n- Space complexity: $O(n)$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool noDirectedEdge(int u, int v, vector<vector<int>>& G) {\\n        int index = lower_bound(G[u].begin(), G[u].end(), v) - G[u].begin();\\n        return index >= G[u].size() || G[u][index] != v;\\n    }\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> G(n+1);\\n        for ( auto& e : edges ) {\\n            G[e[0]].emplace_back(e[1]);\\n            G[e[1]].emplace_back(e[0]);\\n        }\\n        vector<int> odd;\\n        for ( int i=1; i<=n; ++i ) {\\n            int deg = G[i].size();\\n            if ( n%2 == 0 && deg == n-1 ) return false;\\n            if ( deg&1 ) odd.emplace_back(i);\\n        }\\n        if ( odd.size() == 0 ) return true;\\n        if ( odd.size() != 2 && odd.size() != 4 ) return false;\\n        for ( int i=0; i<odd.size(); ++i ) {\\n            sort(G[odd[i]].begin(), G[odd[i]].end());\\n        }\\n        if ( odd.size() == 2 ) {\\n            if ( noDirectedEdge(odd[0], odd[1], G) ) return true;\\n            for ( int i=1; i<=n; ++i ) {\\n                if ( i == odd[0] || i == odd[1] ) continue;\\n                if ( noDirectedEdge(odd[0], i, G) && noDirectedEdge(odd[1], i, G) ) {\\n                    return true;\\n                }\\n            }\\n        } else {\\n            if ( noDirectedEdge(odd[0], odd[1], G) && noDirectedEdge(odd[2], odd[3], G) ) return true;\\n            if ( noDirectedEdge(odd[0], odd[2], G) && noDirectedEdge(odd[1], odd[3], G) ) return true;\\n            if ( noDirectedEdge(odd[0], odd[3], G) && noDirectedEdge(odd[1], odd[2], G) ) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool noDirectedEdge(int u, int v, vector<vector<int>>& G) {\\n        int index = lower_bound(G[u].begin(), G[u].end(), v) - G[u].begin();\\n        return index >= G[u].size() || G[u][index] != v;\\n    }\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> G(n+1);\\n        for ( auto& e : edges ) {\\n            G[e[0]].emplace_back(e[1]);\\n            G[e[1]].emplace_back(e[0]);\\n        }\\n        vector<int> odd;\\n        for ( int i=1; i<=n; ++i ) {\\n            int deg = G[i].size();\\n            if ( n%2 == 0 && deg == n-1 ) return false;\\n            if ( deg&1 ) odd.emplace_back(i);\\n        }\\n        if ( odd.size() == 0 ) return true;\\n        if ( odd.size() != 2 && odd.size() != 4 ) return false;\\n        for ( int i=0; i<odd.size(); ++i ) {\\n            sort(G[odd[i]].begin(), G[odd[i]].end());\\n        }\\n        if ( odd.size() == 2 ) {\\n            if ( noDirectedEdge(odd[0], odd[1], G) ) return true;\\n            for ( int i=1; i<=n; ++i ) {\\n                if ( i == odd[0] || i == odd[1] ) continue;\\n                if ( noDirectedEdge(odd[0], i, G) && noDirectedEdge(odd[1], i, G) ) {\\n                    return true;\\n                }\\n            }\\n        } else {\\n            if ( noDirectedEdge(odd[0], odd[1], G) && noDirectedEdge(odd[2], odd[3], G) ) return true;\\n            if ( noDirectedEdge(odd[0], odd[2], G) && noDirectedEdge(odd[1], odd[3], G) ) return true;\\n            if ( noDirectedEdge(odd[0], odd[3], G) && noDirectedEdge(odd[1], odd[2], G) ) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923599,
                "title": "java-solution-count-nodes-with-odd-degree-cases-explained",
                "content": "Case 0. If no. of odd degree vertices = 0 then return true\\n\\ncase 1. If no. of odd degree vertices = 2, then we can either connect them if they are not connected or we can find another vertex x, so that there is no egde [a,x] and [b,x] present in the graph.\\n\\nCase 2. If no. of odd degree vertices = 4, then we can only connect them in groups of two as given in testcase 2\\n\\n![image.png](https://assets.leetcode.com/users/images/b2c349ea-ff40-44e0-88d6-105f01a7e5e8_1671337090.2658932.png)\\n\\n```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        ArrayList<Integer>[] a = new ArrayList[n+1];\\n        \\n        for(int i=0;i<=n;i++)\\n        {\\n            a[i] = new ArrayList<Integer>();\\n        }\\n        \\n        for(List<Integer> list : edges)\\n        {\\n            a[list.get(0)].add(list.get(1));\\n            a[list.get(1)].add(list.get(0));\\n        }\\n    \\n        int j=0;\\n        ArrayList<Integer> Oddlist = new ArrayList<>();\\n        for(ArrayList<Integer> temp:a)\\n        {\\n            if(temp.size()%2==1)\\n            Oddlist.add(j);\\n            j++;\\n        }\\n        \\n        if(Oddlist.size()==0)\\n            return true;\\n        else if(Oddlist.size()==2)\\n        {\\n            int[] t = new int[n+1];\\n            \\n            int a1 = Oddlist.get(0);\\n            int b1 = Oddlist.get(1);\\n            \\n            for(int x:a[a1])\\n                t[x]++;\\n            for(int x:a[b1])\\n                t[x]++;\\n            \\n            for(int i=1;i<=n;i++)\\n            {\\n                if(t[i]==0)\\n                    return true;\\n            }\\n            return false;\\n        }\\n        else if(Oddlist.size()==4)\\n        {\\n            int[] t = new int[n+1];\\n            \\n            int a1 = Oddlist.get(0);\\n            int b1 = Oddlist.get(1);\\n            int c1 = Oddlist.get(2);\\n            int d1 = Oddlist.get(3);\\n            \\n            if(!a[a1].contains(b1) && !a[c1].contains(d1))\\n                return true;\\n            if(!a[a1].contains(c1) && !a[b1].contains(d1))\\n                return true;\\n            if(!a[a1].contains(d1) && !a[b1].contains(c1))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        ArrayList<Integer>[] a = new ArrayList[n+1];\\n        \\n        for(int i=0;i<=n;i++)\\n        {\\n            a[i] = new ArrayList<Integer>();\\n        }\\n        \\n        for(List<Integer> list : edges)\\n        {\\n            a[list.get(0)].add(list.get(1));\\n            a[list.get(1)].add(list.get(0));\\n        }\\n    \\n        int j=0;\\n        ArrayList<Integer> Oddlist = new ArrayList<>();\\n        for(ArrayList<Integer> temp:a)\\n        {\\n            if(temp.size()%2==1)\\n            Oddlist.add(j);\\n            j++;\\n        }\\n        \\n        if(Oddlist.size()==0)\\n            return true;\\n        else if(Oddlist.size()==2)\\n        {\\n            int[] t = new int[n+1];\\n            \\n            int a1 = Oddlist.get(0);\\n            int b1 = Oddlist.get(1);\\n            \\n            for(int x:a[a1])\\n                t[x]++;\\n            for(int x:a[b1])\\n                t[x]++;\\n            \\n            for(int i=1;i<=n;i++)\\n            {\\n                if(t[i]==0)\\n                    return true;\\n            }\\n            return false;\\n        }\\n        else if(Oddlist.size()==4)\\n        {\\n            int[] t = new int[n+1];\\n            \\n            int a1 = Oddlist.get(0);\\n            int b1 = Oddlist.get(1);\\n            int c1 = Oddlist.get(2);\\n            int d1 = Oddlist.get(3);\\n            \\n            if(!a[a1].contains(b1) && !a[c1].contains(d1))\\n                return true;\\n            if(!a[a1].contains(c1) && !a[b1].contains(d1))\\n                return true;\\n            if(!a[a1].contains(d1) && !a[b1].contains(c1))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923574,
                "title": "hrt-codesignal-test-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI actually encountered this problem on HRT online OA\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are only 3 cases to return true:\\n1. All nodes are even\\n2. 2 nodes are odd, find a free node or between themselves and link them up\\n3. 4 nodes are odd, Link the 4 of them up\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(V+E)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(E)\\n# Code\\n```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        graph = [set() for i in range(n)]\\n        for a, b in edges:\\n            graph[a-1].add(b-1)\\n            graph[b-1].add(a-1)\\n        \\n        odd = 0\\n        oddVertices = []\\n        for i in range(n):\\n            if len(graph[i]) % 2 == 1:\\n                odd += 1\\n                oddVertices.append(i)\\n        if odd == 0:\\n            return True\\n        elif odd == 2:\\n            a, b = oddVertices\\n            for i in range(n):\\n                if i not in graph[a] and i not in graph[b]:\\n                    return True\\n        elif odd == 4:\\n            a, b, c, d = oddVertices\\n            if (b not in graph[a] and d not in graph[c]) or (c not in graph[a] and d not in graph[b]) or (d not in graph[a] and c not in graph[b]):\\n                return True\\n        return False\\n                \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        graph = [set() for i in range(n)]\\n        for a, b in edges:\\n            graph[a-1].add(b-1)\\n            graph[b-1].add(a-1)\\n        \\n        odd = 0\\n        oddVertices = []\\n        for i in range(n):\\n            if len(graph[i]) % 2 == 1:\\n                odd += 1\\n                oddVertices.append(i)\\n        if odd == 0:\\n            return True\\n        elif odd == 2:\\n            a, b = oddVertices\\n            for i in range(n):\\n                if i not in graph[a] and i not in graph[b]:\\n                    return True\\n        elif odd == 4:\\n            a, b, c, d = oddVertices\\n            if (b not in graph[a] and d not in graph[c]) or (c not in graph[a] and d not in graph[b]) or (d not in graph[a] and c not in graph[b]):\\n                return True\\n        return False\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923521,
                "title": "c-brute-force-solution-explained-fully-commented-o-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust check each possible option, which is limited as you can only add two edges at most.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> deg(n+1); // check the degree for each node\\n        vector<unordered_set<int>> connected(n+1); // set to check if two nodes can be connected\\n        for (vector<int>& edge: edges) {\\n            deg[edge[0]]++;\\n            deg[edge[1]]++;\\n            connected[edge[0]].insert(edge[1]);\\n            connected[edge[1]].insert(edge[0]);\\n        }\\n        \\n        // keep an array of the nodes with odd degrees\\n        vector<int> odd;\\n        for (int i = 0; i < deg.size(); ++i) {\\n            if (deg[i] % 2 != 0) {\\n                odd.push_back(i);\\n            }\\n        }\\n        \\n        // if no node with odd degree\\n        if (odd.size() == 0) {\\n            return true;\\n        }\\n        \\n        // if more than 4 odd nodes or odd number of odd nodes, not possible to solve with 2 edges.\\n        if (odd.size() > 4 || odd.size() % 2 != 0) {\\n            return false;\\n        }\\n        \\n        // check for 2 odd nodes\\n        if (odd.size() == 2) {\\n            // check if they can connect within themselves, so they can\\'t already have an edge between themselves\\n            if (connected[odd[0]].find(odd[1]) == connected[odd[0]].end()) { \\n                return true;\\n            }\\n            \\n            // find a third common node to connect to, both have to connect to same node to maintain evenness of the other node,\\n            // so they can\\'t already have an edge with that respective third node.\\n            for (int i = 1; i <= n; ++i) {\\n                if (i != odd[0] && i != odd[1] && connected[i].find(odd[1]) == connected[i].end() \\n                    && connected[i].find(odd[0]) == connected[i].end()) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        // can connect within themselves\\n        vector<array<int, 4>> choices = {{0,1,2,3},{0,2,1,3},{0,3,1,2}}; // only possible way to connect 4 nodes\\n        if (odd.size() == 4) {\\n            for (auto& choice : choices) {\\n                auto [i,j,k,m] = choice;\\n                // check that there isn\\'t already an edge between each pair\\n                if (connected[odd[i]].find(odd[j]) == connected[odd[i]].end() && connected[odd[k]].find(odd[m]) == connected[odd[k]].end()) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> deg(n+1); // check the degree for each node\\n        vector<unordered_set<int>> connected(n+1); // set to check if two nodes can be connected\\n        for (vector<int>& edge: edges) {\\n            deg[edge[0]]++;\\n            deg[edge[1]]++;\\n            connected[edge[0]].insert(edge[1]);\\n            connected[edge[1]].insert(edge[0]);\\n        }\\n        \\n        // keep an array of the nodes with odd degrees\\n        vector<int> odd;\\n        for (int i = 0; i < deg.size(); ++i) {\\n            if (deg[i] % 2 != 0) {\\n                odd.push_back(i);\\n            }\\n        }\\n        \\n        // if no node with odd degree\\n        if (odd.size() == 0) {\\n            return true;\\n        }\\n        \\n        // if more than 4 odd nodes or odd number of odd nodes, not possible to solve with 2 edges.\\n        if (odd.size() > 4 || odd.size() % 2 != 0) {\\n            return false;\\n        }\\n        \\n        // check for 2 odd nodes\\n        if (odd.size() == 2) {\\n            // check if they can connect within themselves, so they can\\'t already have an edge between themselves\\n            if (connected[odd[0]].find(odd[1]) == connected[odd[0]].end()) { \\n                return true;\\n            }\\n            \\n            // find a third common node to connect to, both have to connect to same node to maintain evenness of the other node,\\n            // so they can\\'t already have an edge with that respective third node.\\n            for (int i = 1; i <= n; ++i) {\\n                if (i != odd[0] && i != odd[1] && connected[i].find(odd[1]) == connected[i].end() \\n                    && connected[i].find(odd[0]) == connected[i].end()) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        // can connect within themselves\\n        vector<array<int, 4>> choices = {{0,1,2,3},{0,2,1,3},{0,3,1,2}}; // only possible way to connect 4 nodes\\n        if (odd.size() == 4) {\\n            for (auto& choice : choices) {\\n                auto [i,j,k,m] = choice;\\n                // check that there isn\\'t already an edge between each pair\\n                if (connected[odd[i]].find(odd[j]) == connected[odd[i]].end() && connected[odd[k]].find(odd[m]) == connected[odd[k]].end()) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983650,
                "title": "easy-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        int[] indegree = new int[n+1];\\n        \\n        ArrayList<HashSet<Integer>> adj = new ArrayList<>();\\n        \\n        for(int i = 0; i <= n; i++){\\n            adj.add(new HashSet<>());\\n        }\\n        \\n        for(int i = 0; i < edges.size(); i++){\\n            int u = edges.get(i).get(0);\\n            int v = edges.get(i).get(1);\\n\\n            indegree[u]++;\\n            indegree[v]++;  \\n            adj.get(u).add(v);\\n            adj.get(v).add(u);\\n            \\n        }\\n        \\n        ArrayList<Integer> lst = new ArrayList<>();\\n        \\n        for(int i = 1; i <= n; i++){\\n            if(indegree[i]%2 != 0){\\n                lst.add(i);\\n            }\\n        }\\n        \\n        if(lst.size() > 4 || lst.size() % 2 != 0) return false;\\n        \\n        int cnt = lst.size();\\n        \\n        if(cnt == 0) return true;\\n        else if(cnt == 2){\\n            int a = lst.get(0);\\n            int b = lst.get(1);\\n            \\n            if(!adj.get(a).contains(b) && !adj.get(b).contains(a)){\\n                return true;\\n            }\\n            \\n            for(int i = 1; i <= n; i++){\\n                if(!adj.get(a).contains(i) && !adj.get(b).contains(i) && a != i && b != i){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        else{\\n            int a = lst.get(0);\\n            int b = lst.get(1);\\n            int c = lst.get(2);\\n            int d = lst.get(3);\\n            \\n            if(!adj.get(a).contains(b) && !adj.get(c).contains(d)){\\n                return true;\\n            }\\n            else if(!adj.get(a).contains(c) && !adj.get(b).contains(d)){\\n                return true;\\n            }\\n            else if(!adj.get(a).contains(d) && !adj.get(c).contains(b)){\\n                return true;\\n            }\\n            else return false;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        int[] indegree = new int[n+1];\\n        \\n        ArrayList<HashSet<Integer>> adj = new ArrayList<>();\\n        \\n        for(int i = 0; i <= n; i++){\\n            adj.add(new HashSet<>());\\n        }\\n        \\n        for(int i = 0; i < edges.size(); i++){\\n            int u = edges.get(i).get(0);\\n            int v = edges.get(i).get(1);\\n\\n            indegree[u]++;\\n            indegree[v]++;  \\n            adj.get(u).add(v);\\n            adj.get(v).add(u);\\n            \\n        }\\n        \\n        ArrayList<Integer> lst = new ArrayList<>();\\n        \\n        for(int i = 1; i <= n; i++){\\n            if(indegree[i]%2 != 0){\\n                lst.add(i);\\n            }\\n        }\\n        \\n        if(lst.size() > 4 || lst.size() % 2 != 0) return false;\\n        \\n        int cnt = lst.size();\\n        \\n        if(cnt == 0) return true;\\n        else if(cnt == 2){\\n            int a = lst.get(0);\\n            int b = lst.get(1);\\n            \\n            if(!adj.get(a).contains(b) && !adj.get(b).contains(a)){\\n                return true;\\n            }\\n            \\n            for(int i = 1; i <= n; i++){\\n                if(!adj.get(a).contains(i) && !adj.get(b).contains(i) && a != i && b != i){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        else{\\n            int a = lst.get(0);\\n            int b = lst.get(1);\\n            int c = lst.get(2);\\n            int d = lst.get(3);\\n            \\n            if(!adj.get(a).contains(b) && !adj.get(c).contains(d)){\\n                return true;\\n            }\\n            else if(!adj.get(a).contains(c) && !adj.get(b).contains(d)){\\n                return true;\\n            }\\n            else if(!adj.get(a).contains(d) && !adj.get(c).contains(b)){\\n                return true;\\n            }\\n            else return false;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962894,
                "title": "updated-code-well-commented-eulerian-path",
                "content": "An Eulerian path is a path in a graph that visits every edge exactly once. In other words, it\\'s a sequence of vertices and edges that starts at one vertex, traverses all the edges in the graph exactly once, and ends at another vertex.\\n\\nAn Eulerian circuit is a special case of an Eulerian path where the path is a cycle, meaning it starts and ends at the same vertex.\\n\\nHere are a few key points about Eulerian paths and circuits:\\n\\n****Eulerian Path:**\\n**\\nAn Eulerian path exists in a graph if and only if there are exactly zero or two vertices with odd degrees.\\nIf there are zero vertices with odd degrees, the Eulerian path is an Eulerian circuit (cycle).\\nIf there are two vertices with odd degrees, the Eulerian path starts at one of them and ends at the other.\\n****Eulerian Circuit:**\\n**\\nAn Eulerian circuit exists in a graph if and only if all vertices have even degrees.\\nAn Eulerian circuit is a closed path that visits all edges and vertices of the graph.\\nEulerian paths and circuits have applications in various fields, such as graph theory, network analysis, and transportation planning. They are named after the Swiss mathematician Leonhard Euler, who introduced the concept and solved the famous \"Seven Bridges of K\\xF6nigsberg\" problem, which is considered one of the starting points of graph theory.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<unordered_set<int>> v(n + 1);  // Create adjacency set for each vertex\\n        for (auto &i : edges) {\\n            v[i[0]].insert(i[1]);\\n            v[i[1]].insert(i[0]);\\n        }\\n\\n        vector<int> v1;  // To store vertices with odd degrees\\n        for (int i = 1; i <= n; i++) {\\n            if (v[i].size() & 1) {\\n                v1.push_back(i);\\n            }\\n        }\\n\\n        if (v1.size() == 0) return true;  // Eulerian circuit condition\\n        else if (v1.size() == 2) {\\n            // Check if non-adjacent nodes are present\\n            for (int i = 1; i <= n; i++) {\\n                if (v[v1[0]].count(i) == 0 && v[v1[1]].count(i) == 0) {\\n                    return true;  // Eulerian path condition\\n                }\\n            }\\n            // Check if the two odd-degree nodes are not adjacent\\n            if (v[v1[0]].count(v1[1]) == 0) return true;  // Eulerian path condition\\n        } else if (v1.size() == 4) {\\n            // Check all possible combinations of non-adjacent pairs\\n            if ((v[v1[0]].count(v1[1]) == 0 && v[v1[2]].count(v1[3]) == 0) ||\\n                (v[v1[0]].count(v1[2]) == 0 && v[v1[1]].count(v1[3]) == 0) ||\\n                (v[v1[0]].count(v1[3]) == 0 && v[v1[2]].count(v1[1]) == 0)\\n            ) return true;  // Eulerian path condition\\n        }\\n\\n        return false;  // None of the conditions are satisfied\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<unordered_set<int>> v(n + 1);  // Create adjacency set for each vertex\\n        for (auto &i : edges) {\\n            v[i[0]].insert(i[1]);\\n            v[i[1]].insert(i[0]);\\n        }\\n\\n        vector<int> v1;  // To store vertices with odd degrees\\n        for (int i = 1; i <= n; i++) {\\n            if (v[i].size() & 1) {\\n                v1.push_back(i);\\n            }\\n        }\\n\\n        if (v1.size() == 0) return true;  // Eulerian circuit condition\\n        else if (v1.size() == 2) {\\n            // Check if non-adjacent nodes are present\\n            for (int i = 1; i <= n; i++) {\\n                if (v[v1[0]].count(i) == 0 && v[v1[1]].count(i) == 0) {\\n                    return true;  // Eulerian path condition\\n                }\\n            }\\n            // Check if the two odd-degree nodes are not adjacent\\n            if (v[v1[0]].count(v1[1]) == 0) return true;  // Eulerian path condition\\n        } else if (v1.size() == 4) {\\n            // Check all possible combinations of non-adjacent pairs\\n            if ((v[v1[0]].count(v1[1]) == 0 && v[v1[2]].count(v1[3]) == 0) ||\\n                (v[v1[0]].count(v1[2]) == 0 && v[v1[1]].count(v1[3]) == 0) ||\\n                (v[v1[0]].count(v1[3]) == 0 && v[v1[2]].count(v1[1]) == 0)\\n            ) return true;  // Eulerian path condition\\n        }\\n\\n        return false;  // None of the conditions are satisfied\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688617,
                "title": "vector-of-set-as-adjacency-list-with-conditions",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<set<int>>adj(n+1);\\n        vector<int>ct(n+1,0);\\n        for(int i=0;i<edges.size();i++){\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            adj[u].insert(v);\\n            adj[v].insert(u);\\n            ct[u]++;\\n            ct[v]++;\\n        }\\n        vector<int>unev;\\n        int unnodes=0;\\n        for(int i=1;i<ct.size();i++){\\n            if(ct[i]%2!=0){\\n                unnodes++;\\n                unev.push_back(i);\\n            }\\n        }\\n        if(unnodes%2!=0 || unnodes>4)return false;\\n        else if(unnodes==0)return true;\\n        else if(unnodes==2){\\n            int u=unev[0];\\n            int v=unev[1];\\n            /*vector<int>::iterator it;\\n            it=find(adj[v].begin(),adj[v].end(),u);\\n            if(it!=adj[v].end())return false;\\n            return true;*/\\n            if(adj[u].find(v)==adj[u].end())return true;\\n            for(int i=1;i<=n;i++){\\n                if(i==u || i==v)continue;\\n                if(adj[i].find(v)==adj[i].end()&&adj[i].find(u)==adj[i].end()){\\n                    return true;\\n                    break;\\n                }\\n            }\\n        }\\n        else{\\n            int a=unev[0];\\n            int b=unev[1];\\n            int c=unev[2];\\n            int d=unev[3];\\n            if((adj[a].find(b)==adj[a].end() && adj[c].find(d)==adj[c].end())||(adj[a].find(c)==adj[a].end() && adj[b].find(d)==adj[b].end())||(adj[a].find(d)==adj[a].end() && adj[b].find(c)==adj[b].end()))return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<set<int>>adj(n+1);\\n        vector<int>ct(n+1,0);\\n        for(int i=0;i<edges.size();i++){\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            adj[u].insert(v);\\n            adj[v].insert(u);\\n            ct[u]++;\\n            ct[v]++;\\n        }\\n        vector<int>unev;\\n        int unnodes=0;\\n        for(int i=1;i<ct.size();i++){\\n            if(ct[i]%2!=0){\\n                unnodes++;\\n                unev.push_back(i);\\n            }\\n        }\\n        if(unnodes%2!=0 || unnodes>4)return false;\\n        else if(unnodes==0)return true;\\n        else if(unnodes==2){\\n            int u=unev[0];\\n            int v=unev[1];\\n            /*vector<int>::iterator it;\\n            it=find(adj[v].begin(),adj[v].end(),u);\\n            if(it!=adj[v].end())return false;\\n            return true;*/\\n            if(adj[u].find(v)==adj[u].end())return true;\\n            for(int i=1;i<=n;i++){\\n                if(i==u || i==v)continue;\\n                if(adj[i].find(v)==adj[i].end()&&adj[i].find(u)==adj[i].end()){\\n                    return true;\\n                    break;\\n                }\\n            }\\n        }\\n        else{\\n            int a=unev[0];\\n            int b=unev[1];\\n            int c=unev[2];\\n            int d=unev[3];\\n            if((adj[a].find(b)==adj[a].end() && adj[c].find(d)==adj[c].end())||(adj[a].find(c)==adj[a].end() && adj[b].find(d)==adj[b].end())||(adj[a].find(d)==adj[a].end() && adj[b].find(c)==adj[b].end()))return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639535,
                "title": "straightforward-ruby-solution-with-explanation-100-100",
                "content": "# Intuition\\nAny vertices with an odd number of connections must connect to each, or each connect to the same vertex.  Check these possibilities.\\n\\n# Approach\\n1. Turn edges into a hash that gives a set of all connections to a given vertex.  This makes lookup much quicker.\\n2. Find the vertices with an odd number of connections.\\n3. If zero, return true.  If more than four, you won\\'t be able to connect them, so return false.  Note that there will always be an even number of vertices with odd connecitons.\\n\\nWe now have two cases left: either two or four vertices with an odd number of connections.  Let\\'s start with 2.\\n\\n4. If the two vertices aren\\'t currently connected, we can connect them and return true.\\n5. If they *are* already connected, we can still connect them through another vertex that isn\\'t connect to either one.  Return true if any vertex is not connected to either, false otherwise.\\n\\n6. If there are four vertices with odd connections, we have to connect them to each other.  Check if any of the combinations are possible.  Return false if no.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\ndef is_possible(n, edges)\\n    connections = Hash.new { |h,k| h[k] = Set[] }\\n    edges.each do |edge|\\n        a,b = edge\\n        connections[a].add(b)\\n        connections[b].add(a)\\n    end\\n\\n    odds = connections.keys.select { |k| connections[k].size % 2 != 0 }\\n\\n    return true if odds.length == 0\\n    return false if odds.length > 4\\n\\n    if odds.length == 2\\n        a,b = odds\\n        return true unless connections[a].include?(b)\\n\\n        cons = connections[a] + connections[b]\\n        return (1..n).any? { |i| !cons.include?(i)}\\n    end\\n\\n    a,b,c,d = odds\\n    return true unless connections[a].include?(b) || connections[c].include?(d)\\n    return true unless connections[a].include?(c) || connections[b].include?(d)\\n    return true unless connections[a].include?(d) || connections[b].include?(c)\\n\\n    false\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef is_possible(n, edges)\\n    connections = Hash.new { |h,k| h[k] = Set[] }\\n    edges.each do |edge|\\n        a,b = edge\\n        connections[a].add(b)\\n        connections[b].add(a)\\n    end\\n\\n    odds = connections.keys.select { |k| connections[k].size % 2 != 0 }\\n\\n    return true if odds.length == 0\\n    return false if odds.length > 4\\n\\n    if odds.length == 2\\n        a,b = odds\\n        return true unless connections[a].include?(b)\\n\\n        cons = connections[a] + connections[b]\\n        return (1..n).any? { |i| !cons.include?(i)}\\n    end\\n\\n    a,b,c,d = odds\\n    return true unless connections[a].include?(b) || connections[c].include?(d)\\n    return true unless connections[a].include?(c) || connections[b].include?(d)\\n    return true unless connections[a].include?(d) || connections[b].include?(c)\\n\\n    false\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3535575,
                "title": "graph-basic-concept-solution-cpp",
                "content": "# Intuition and Approach\\n* TRICKS:\\n* * if graph contain 0 odd degree nodes return 1.\\n* * no of odd degree nodes is not 0 or not 2 or not 4: return 0.\\n* make a list of n nodes with value 0 and count how many odd degree nodes connect to each node in graph.\\n* * if no of odd degree node is 2:\\n* * * if you found any node(including odd degree nodes) which do not have any edge from odd degree node return true \\n* * * else return false. \\n* * if no of odd degree nodes is 4: \\n* * * if u found any odd degree node that connects all other 3 odd degree node then return false.\\n* * * if u found cycle of 3 nodes in odd degree nodes return false.\\n* * * else return true. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int>de(n,0);\\n        vector<int>con[n];\\n        for(int i=0;i<edges.size();i++){\\n            de[edges[i][0]-1]++;\\n            de[edges[i][1]-1]++;\\n            con[edges[i][0]-1].push_back(edges[i][1]-1);\\n            con[edges[i][1]-1].push_back(edges[i][0]-1);\\n        }\\n        vector<int>odd;\\n        for(int i=0;i<n;i++){\\n            if(de[i]%2){\\n                odd.push_back(i);\\n            }\\n        }\\n        if(odd.size()==0)return true;\\n        if(odd.size()!=2 && odd.size()!=4)return false;\\n        if(odd.size()==2){\\n            vector<int>li(n,0);\\n            for(int i:con[odd[0]])li[i]++;\\n            for(int i:con[odd[1]])li[i]++;\\n            for(int i=0;i<n;i++){\\n                if(li[i]==0)return true;\\n            }\\n        }\\n        else{\\n            vector<int>li(n,0);\\n            for(int i:con[odd[0]])li[i]++;\\n            for(int i:con[odd[1]])li[i]++;\\n            for(int i:con[odd[2]])li[i]++;\\n            for(int i:con[odd[3]])li[i]++;\\n            vector<int>countr={0,0,0,0};\\n            countr[li[odd[0]]]++;\\n            countr[li[odd[1]]]++;\\n            countr[li[odd[2]]]++;\\n            countr[li[odd[3]]]++;\\n            if(countr[3])return 0;\\n            if(countr[2]==3 && countr[0]==1)return 0;\\n            return 1;\\n        }\\n        return false;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int>de(n,0);\\n        vector<int>con[n];\\n        for(int i=0;i<edges.size();i++){\\n            de[edges[i][0]-1]++;\\n            de[edges[i][1]-1]++;\\n            con[edges[i][0]-1].push_back(edges[i][1]-1);\\n            con[edges[i][1]-1].push_back(edges[i][0]-1);\\n        }\\n        vector<int>odd;\\n        for(int i=0;i<n;i++){\\n            if(de[i]%2){\\n                odd.push_back(i);\\n            }\\n        }\\n        if(odd.size()==0)return true;\\n        if(odd.size()!=2 && odd.size()!=4)return false;\\n        if(odd.size()==2){\\n            vector<int>li(n,0);\\n            for(int i:con[odd[0]])li[i]++;\\n            for(int i:con[odd[1]])li[i]++;\\n            for(int i=0;i<n;i++){\\n                if(li[i]==0)return true;\\n            }\\n        }\\n        else{\\n            vector<int>li(n,0);\\n            for(int i:con[odd[0]])li[i]++;\\n            for(int i:con[odd[1]])li[i]++;\\n            for(int i:con[odd[2]])li[i]++;\\n            for(int i:con[odd[3]])li[i]++;\\n            vector<int>countr={0,0,0,0};\\n            countr[li[odd[0]]]++;\\n            countr[li[odd[1]]]++;\\n            countr[li[odd[2]]]++;\\n            countr[li[odd[3]]]++;\\n            if(countr[3])return 0;\\n            if(countr[2]==3 && countr[0]==1)return 0;\\n            return 1;\\n        }\\n        return false;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448432,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isPossible(self, n, edges):\\n        d1 = defaultdict(set)\\n\\n        for i,j in edges:\\n            d1[i-1].add(j-1)\\n            d1[j-1].add(i-1)\\n\\n        odd = [i for i in range(n) if len(d1[i])%2 == 1]\\n\\n        def f(a,b):\\n            return a not in d1[b]\\n\\n        if len(odd) == 2:\\n            j,k = odd\\n            return any(f(j,i)and f(k,i) for i in range(n))\\n\\n        if len(odd) == 4:\\n            i,j,k,l = odd\\n            return f(i,j) and f(k,l) or f(i,k) and f(j,l) or f(i,l) and f(j,k)\\n\\n        return len(odd) == 0\\n\\n\\n        \\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPossible(self, n, edges):\\n        d1 = defaultdict(set)\\n\\n        for i,j in edges:\\n            d1[i-1].add(j-1)\\n            d1[j-1].add(i-1)\\n\\n        odd = [i for i in range(n) if len(d1[i])%2 == 1]\\n\\n        def f(a,b):\\n            return a not in d1[b]\\n\\n        if len(odd) == 2:\\n            j,k = odd\\n            return any(f(j,i)and f(k,i) for i in range(n))\\n\\n        if len(odd) == 4:\\n            i,j,k,l = odd\\n            return f(i,j) and f(k,l) or f(i,k) and f(j,l) or f(i,l) and f(j,k)\\n\\n        return len(odd) == 0\\n\\n\\n        \\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443839,
                "title": "python-constructive-explained",
                "content": "Reference: odd nodes means - node having odd no of edges.\\nThere are only 3 cases for returning True.\\nLets first discuss cases for False :\\n1) When odd no of nodes are odd , here clearly we are always left with 1 edge.\\n2) When no of odd nodes are>4.Here we will always need >3 edges which we aren\\'t allowed.\\n\\nSo there are only 3 valid cases (True) :\\n 1) When no of odd nodes are 0 -> Here directly return True. \\n 2) When we have 2 odd nodes-\\n    Here we have 2 subcases.\\n\\t1) Try to merge both of them i.e. both of them are not neighbours of each other.\\n\\t2) Try to find a node with even parity which is not neighbour of both of these nodes.\\n3) Finally when odd nodes are 4.\\n    Here we can just try to create combinations of all of them and check if both pairs of nodes are not neighbours of each other.\\n\\t\\nOtherwise return False\\n\\t\\nTime Complexity - O(N)\\n\\nCode:\\n\\n```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        edges=set([(min(u,v),max(u,v)) for u,v in edges])\\n        graph=defaultdict(lambda: set())\\n        degree=[0]*(n+1)\\n        for u,v in edges:\\n            degree[u]+=1\\n            degree[v]+=1\\n            graph[u].add(v)\\n            graph[v].add(u)\\n        odd=0\\n        odds,evens=[],set()\\n        for i in range(1,n+1):\\n            if degree[i]%2==1:\\n                odd+=1\\n                odds.append(i)\\n            else:\\n                evens.add(i)\\n        if odd==0:\\n            return True\\n        if odd>4 or odd%2==1:\\n            return False\\n        if odd==2:\\n            if (odds[0],odds[1]) not in edges:\\n                return True\\n            okay=evens-(graph[odds[0]].union(graph[odds[1]]))\\n            if len(okay)>0:\\n                return True\\n            return False\\n        flag=False\\n        for i in range(4):\\n            if flag: break\\n            for j in range(i+1,4):\\n                f_edge=(odds[i],odds[j])\\n                odds2=odds[:i]+odds[i+1:j]+odds[j+1:]\\n                s_edge=(odds2[0],odds2[1])\\n                if (f_edge not in edges and s_edge not in edges):\\n                    flag=True\\n                    break\\n        return flag\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        edges=set([(min(u,v),max(u,v)) for u,v in edges])\\n        graph=defaultdict(lambda: set())\\n        degree=[0]*(n+1)\\n        for u,v in edges:\\n            degree[u]+=1\\n            degree[v]+=1\\n            graph[u].add(v)\\n            graph[v].add(u)\\n        odd=0\\n        odds,evens=[],set()\\n        for i in range(1,n+1):\\n            if degree[i]%2==1:\\n                odd+=1\\n                odds.append(i)\\n            else:\\n                evens.add(i)\\n        if odd==0:\\n            return True\\n        if odd>4 or odd%2==1:\\n            return False\\n        if odd==2:\\n            if (odds[0],odds[1]) not in edges:\\n                return True\\n            okay=evens-(graph[odds[0]].union(graph[odds[1]]))\\n            if len(okay)>0:\\n                return True\\n            return False\\n        flag=False\\n        for i in range(4):\\n            if flag: break\\n            for j in range(i+1,4):\\n                f_edge=(odds[i],odds[j])\\n                odds2=odds[:i]+odds[i+1:j]+odds[j+1:]\\n                s_edge=(odds2[0],odds2[1])\\n                if (f_edge not in edges and s_edge not in edges):\\n                    flag=True\\n                    break\\n        return flag\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415557,
                "title": "python-3-solution-with-in-line-comments",
                "content": "# Intuition\\nMain observations:\\n1. We have to add edges to nodes with odd degrees\\n2. If we have more than 4 such nodes, we would need more than 2 edges, so it doesn\\'t work\\n3. If we have an uneven number of odd nodes, adding an edge will give another node an odd degree, so it doesn\\'t work\\n4. Thus, if there\\'s a solution, we must have 0, 2, or 4 nodes with odd degrees\\n\\n# Approach\\nBuild an adjacency dictionary to quickly lookup if nodes are connected.\\n\\nIf there are no nodes with odd degrees, we\\'re done.\\n\\nIf there are 4 nodes with odd degrees, we try to connect them to each other. If this works, we\\'re done. Otherwise, we don\\'t have enough edges to connect them to other nodes, so it doesn\\'t work.\\n\\nIf there a 2 nodes with odd degrees, we try to connect them to each other. If this doesn\\'t work, we find a node from the rest of the graph (with even degree) and try to connect both nodes to it. If this works, all nodes will have an even degree. If it doesn\\'t, we return False.\\n\\n\\n# Code\\n```\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        # First, build an adjacency matrix.\\n        # This way we can quickly check if a connection\\n        # already exists between vertices.\\n        adjacency = defaultdict(set)\\n        for a, b in edges:\\n            adjacency[a].add(b)\\n            adjacency[b].add(a)\\n\\n        # Get a list of all odd edges\\n        odd = []\\n        for v, e in adjacency.items():\\n            if len(e) % 2 != 0:\\n                odd.append(v)\\n\\n        # If we have more than 4 odd edges\\n        # we would need more than 2 edges.\\n        # If it\\'s an uneven number, it\\'s\\n        # also impossible.\\n        if len(odd) > 4 or len(odd) in {1, 3}:\\n            return False\\n\\n        # Case 1: We have no odd degrees. We don\\'t have\\n        # to do anything.\\n        if not odd:\\n            return True\\n\\n        # Case 2: We have 4 odd degrees. In this case,\\n        # we have to connect them with each other.\\n        # For this, we check if they are not connected\\n        # with each other, yet, in all possible combinations.\\n        # If that\\'s the case, we can connect them, and\\n        # can return True.\\n        if len(odd) == 4:\\n            a, b, c, d = odd\\n            # a-b and c-d\\n            if a not in adjacency[b] and c not in adjacency[d]:\\n                return True\\n            # a-c and b-d\\n            if a not in adjacency[c] and b not in adjacency[d]:\\n                return True\\n            # a-d and b-c\\n            if a not in adjacency[d] and b not in adjacency[c]:\\n                return True\\n            \\n            # Otherwise, it does not work.\\n            return False\\n\\n        # Case 3: We have 2 odd degrees. There are two possibilities:\\n        # If we can connect them with each other, we do it an are done.\\n        # Otherwise, we try to find a vertex from the full graph where\\n        # we can connect both two. That vertex will remain even (because\\n        # we connect both vertices), and our odd vertices will become even.\\n        if len(odd) == 2:\\n            a, b = odd\\n            # If we can just connect them, we\\'re good\\n            if a not in adjacency[b]:\\n                return True\\n            # Otherwise, find an even vertex that we can connect\\n            # both to.\\n            for i in range(1, n+1):\\n                if i not in adjacency[a] and i not in adjacency[b]:\\n                    return True\\n\\n            return False\\n\\n        # Just in case\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        # First, build an adjacency matrix.\\n        # This way we can quickly check if a connection\\n        # already exists between vertices.\\n        adjacency = defaultdict(set)\\n        for a, b in edges:\\n            adjacency[a].add(b)\\n            adjacency[b].add(a)\\n\\n        # Get a list of all odd edges\\n        odd = []\\n        for v, e in adjacency.items():\\n            if len(e) % 2 != 0:\\n                odd.append(v)\\n\\n        # If we have more than 4 odd edges\\n        # we would need more than 2 edges.\\n        # If it\\'s an uneven number, it\\'s\\n        # also impossible.\\n        if len(odd) > 4 or len(odd) in {1, 3}:\\n            return False\\n\\n        # Case 1: We have no odd degrees. We don\\'t have\\n        # to do anything.\\n        if not odd:\\n            return True\\n\\n        # Case 2: We have 4 odd degrees. In this case,\\n        # we have to connect them with each other.\\n        # For this, we check if they are not connected\\n        # with each other, yet, in all possible combinations.\\n        # If that\\'s the case, we can connect them, and\\n        # can return True.\\n        if len(odd) == 4:\\n            a, b, c, d = odd\\n            # a-b and c-d\\n            if a not in adjacency[b] and c not in adjacency[d]:\\n                return True\\n            # a-c and b-d\\n            if a not in adjacency[c] and b not in adjacency[d]:\\n                return True\\n            # a-d and b-c\\n            if a not in adjacency[d] and b not in adjacency[c]:\\n                return True\\n            \\n            # Otherwise, it does not work.\\n            return False\\n\\n        # Case 3: We have 2 odd degrees. There are two possibilities:\\n        # If we can connect them with each other, we do it an are done.\\n        # Otherwise, we try to find a vertex from the full graph where\\n        # we can connect both two. That vertex will remain even (because\\n        # we connect both vertices), and our odd vertices will become even.\\n        if len(odd) == 2:\\n            a, b = odd\\n            # If we can just connect them, we\\'re good\\n            if a not in adjacency[b]:\\n                return True\\n            # Otherwise, find an even vertex that we can connect\\n            # both to.\\n            for i in range(1, n+1):\\n                if i not in adjacency[a] and i not in adjacency[b]:\\n                    return True\\n\\n            return False\\n\\n        # Just in case\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249098,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool check(int a,int b,int c,int d,map<int,vector<int>> &mpp)\\n    {\\n        for(int ele:mpp[a])\\n        {\\n            if(ele==b)\\n                return true;\\n        }\\n        for(int ele:mpp[c])\\n        {\\n            if(ele==d)\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool isPossible(int n, vector<vector<int>>& edges) \\n    {\\n        vector<int> degree(n+1,0);\\n        \\n        for(vector<int> e:edges)\\n        {\\n            degree[e[0]]++;\\n            degree[e[1]]++;\\n        }\\n        \\n        map<int,vector<int>> mpp;\\n        \\n        for(vector<int> e:edges)\\n        {\\n            mpp[e[0]].push_back(e[1]);\\n            mpp[e[1]].push_back(e[0]);\\n        }\\n        \\n        vector<int> all;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            if(degree[i]%2==1)// odd\\n            {\\n                all.push_back(i);\\n            }\\n        }\\n        \\n        if(all.size()==0)\\n        {\\n            return true;\\n        }\\n        else if(all.size()==2)\\n        {\\n            for(int i=1;i<=n;i++)\\n            {\\n        \\n                bool a=true;\\n                for(int ele:mpp[i])\\n                {\\n                    if(ele==all[0] || ele==all[1])\\n                    {\\n                        a=false;\\n                        break;\\n                    }\\n                }\\n                if(a)\\n                    return true;\\n\\n            }\\n            return false;\\n        }\\n        else if(all.size()==4)\\n        {\\n            int a=all[0];\\n            int b=all[1];\\n            int c=all[2];\\n            int d=all[3];\\n            \\n            if( (check(a,b,c,d,mpp) && check(a,c,b,d,mpp) && check(a,d,b,c,mpp))==false )\\n                return true;\\n            return false;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(int a,int b,int c,int d,map<int,vector<int>> &mpp)\\n    {\\n        for(int ele:mpp[a])\\n        {\\n            if(ele==b)\\n                return true;\\n        }\\n        for(int ele:mpp[c])\\n        {\\n            if(ele==d)\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool isPossible(int n, vector<vector<int>>& edges) \\n    {\\n        vector<int> degree(n+1,0);\\n        \\n        for(vector<int> e:edges)\\n        {\\n            degree[e[0]]++;\\n            degree[e[1]]++;\\n        }\\n        \\n        map<int,vector<int>> mpp;\\n        \\n        for(vector<int> e:edges)\\n        {\\n            mpp[e[0]].push_back(e[1]);\\n            mpp[e[1]].push_back(e[0]);\\n        }\\n        \\n        vector<int> all;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            if(degree[i]%2==1)// odd\\n            {\\n                all.push_back(i);\\n            }\\n        }\\n        \\n        if(all.size()==0)\\n        {\\n            return true;\\n        }\\n        else if(all.size()==2)\\n        {\\n            for(int i=1;i<=n;i++)\\n            {\\n        \\n                bool a=true;\\n                for(int ele:mpp[i])\\n                {\\n                    if(ele==all[0] || ele==all[1])\\n                    {\\n                        a=false;\\n                        break;\\n                    }\\n                }\\n                if(a)\\n                    return true;\\n\\n            }\\n            return false;\\n        }\\n        else if(all.size()==4)\\n        {\\n            int a=all[0];\\n            int b=all[1];\\n            int c=all[2];\\n            int d=all[3];\\n            \\n            if( (check(a,b,c,d,mpp) && check(a,c,b,d,mpp) && check(a,d,b,c,mpp))==false )\\n                return true;\\n            return false;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229265,
                "title": "key-idea-fully-explained-python",
                "content": "Because the problem is limited to **two edges** you can manually handle all cases.\\n```\\nif the number of odd nodes is odd: return false\\nif the number of odd nodes > 4: return False\\n\\nconnect (one odd node) to (odd number of odd nodes)\\nso [(1)(1) = 1 edge], [(1)(3) = 3 edges], ...\\n\\nconnect (one even node) to (even number of odd nodes)\\nso [(1)(2) = 2 edges], [(1)(4) = 4 edges], ...\\n```\\n**Time: O(n)\\nSpace: O(len(edges))**\\n```\\ndef isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n    graph = defaultdict(set)\\n    for a,b in edges:\\n        graph[a].add(b); graph[b].add(a)\\n    \\n    oddNodes = [i for i in range(1, n+1) if len(graph[i])%2]\\n    if len(oddNodes) == 0: return True\\n    if len(oddNodes) not in [2,4]: return False\\n    \\n    if len(oddNodes) == 2:\\n        a,b = oddNodes\\n        return any([not graph[i]&set(oddNodes) for i in range(1, n+1)])\\n    \\n    valid = lambda x: return x[1] not in graph[x[0]]\\n    a,b,c,d = oddNodes\\n    return valid(a,b)&valid(c,d) | valid(a,c)&valid(b,d) | valid(a,d)&valid(b,c)        \\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Graph"
                ],
                "code": "```\\nif the number of odd nodes is odd: return false\\nif the number of odd nodes > 4: return False\\n\\nconnect (one odd node) to (odd number of odd nodes)\\nso [(1)(1) = 1 edge], [(1)(3) = 3 edges], ...\\n\\nconnect (one even node) to (even number of odd nodes)\\nso [(1)(2) = 2 edges], [(1)(4) = 4 edges], ...\\n```\n```\\ndef isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n    graph = defaultdict(set)\\n    for a,b in edges:\\n        graph[a].add(b); graph[b].add(a)\\n    \\n    oddNodes = [i for i in range(1, n+1) if len(graph[i])%2]\\n    if len(oddNodes) == 0: return True\\n    if len(oddNodes) not in [2,4]: return False\\n    \\n    if len(oddNodes) == 2:\\n        a,b = oddNodes\\n        return any([not graph[i]&set(oddNodes) for i in range(1, n+1)])\\n    \\n    valid = lambda x: return x[1] not in graph[x[0]]\\n    a,b,c,d = oddNodes\\n    return valid(a,b)&valid(c,d) | valid(a,c)&valid(b,d) | valid(a,d)&valid(b,c)        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3173657,
                "title": "easy-python-solution-o-n-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEach vertex should have even degrees after adding atmost 2 edges.\\nTherefore, total number of vertices with odd degrees can be either 0 or 2 or 4.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind those vertices with odd degree, if 0 return True (No additional edge required).\\nIf 2 check if they can be connected (no connection b/w them exists) or check if they can be connected with any other vertex (with even degree).\\nIf 4 check if any combination among them is not currently present.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        curr_edges = set()\\n        degree = defaultdict(int) \\n        for e in edges:\\n            degree[e[0]]+=1\\n            degree[e[1]]+=1\\n            curr_edges.add(tuple(e))\\n            curr_edges.add(tuple(e[::-1]))\\n        nodes = []                          # nodes with odd degree\\n        for k in list(degree.keys()):\\n            if degree[k]%2!=0:\\n                nodes.append(k)\\n                \\n        if len(nodes)==0: return True\\n        if len(nodes)==2 and tuple([nodes[0],nodes[1]]) not in curr_edges: return True\\n        elif len(nodes)==2:         # check if connection with any other node is possible.\\n            for i in range(1,n+1): \\n                if i not in nodes and tuple([nodes[0],i]) not in curr_edges and tuple([i,nodes[1]]) not in curr_edges:\\n                    return True\\n            return False\\n\\n        # Finally check if any combination of connection among the 4 is possible.\\n        if len(nodes)==4 and ((tuple([nodes[0],nodes[1]]) not in curr_edges and tuple([nodes[2],nodes[3]]) not in curr_edges) or (tuple([nodes[0],nodes[2]]) not in curr_edges and tuple([nodes[1],nodes[3]]) not in curr_edges) or (tuple([nodes[0],nodes[3]]) not in curr_edges and tuple([nodes[2],nodes[1]]) not in curr_edges)):\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        curr_edges = set()\\n        degree = defaultdict(int) \\n        for e in edges:\\n            degree[e[0]]+=1\\n            degree[e[1]]+=1\\n            curr_edges.add(tuple(e))\\n            curr_edges.add(tuple(e[::-1]))\\n        nodes = []                          # nodes with odd degree\\n        for k in list(degree.keys()):\\n            if degree[k]%2!=0:\\n                nodes.append(k)\\n                \\n        if len(nodes)==0: return True\\n        if len(nodes)==2 and tuple([nodes[0],nodes[1]]) not in curr_edges: return True\\n        elif len(nodes)==2:         # check if connection with any other node is possible.\\n            for i in range(1,n+1): \\n                if i not in nodes and tuple([nodes[0],i]) not in curr_edges and tuple([i,nodes[1]]) not in curr_edges:\\n                    return True\\n            return False\\n\\n        # Finally check if any combination of connection among the 4 is possible.\\n        if len(nodes)==4 and ((tuple([nodes[0],nodes[1]]) not in curr_edges and tuple([nodes[2],nodes[3]]) not in curr_edges) or (tuple([nodes[0],nodes[2]]) not in curr_edges and tuple([nodes[1],nodes[3]]) not in curr_edges) or (tuple([nodes[0],nodes[3]]) not in curr_edges and tuple([nodes[2],nodes[1]]) not in curr_edges)):\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166114,
                "title": "python-video-walkthrough",
                "content": "[Click Here For Video Walkthrough](https://youtu.be/oREWVUAOpIw)\\n```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        def areConnected(u,v): return u in N[v]\\n        N = defaultdict(set)        \\n        for u,v in edges: _,_ = N[u].add(v), N[v].add(u)\\n        O = [u for u in N if len(N[u]) % 2 == 1]\\n        if len(O) == 0: return True\\n        if len(O) > 4: return False\\n        if len(O) == 2:\\n            u,v = O\\n            if not areConnected(u,v): return True\\n            return any(not areConnected(u,w) and not areConnected(v,w) for w in range(1,n+1))            \\n        if len(O) == 4: \\n            u,v,w,x = O\\n            if not areConnected(u,v) and not areConnected(w,x): return True\\n            if not areConnected(u,w) and not areConnected(v,x): return True\\n            if not areConnected(u,x) and not areConnected(v,w): return True\\n            return False\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        def areConnected(u,v): return u in N[v]\\n        N = defaultdict(set)        \\n        for u,v in edges: _,_ = N[u].add(v), N[v].add(u)\\n        O = [u for u in N if len(N[u]) % 2 == 1]\\n        if len(O) == 0: return True\\n        if len(O) > 4: return False\\n        if len(O) == 2:\\n            u,v = O\\n            if not areConnected(u,v): return True\\n            return any(not areConnected(u,w) and not areConnected(v,w) for w in range(1,n+1))            \\n        if len(O) == 4: \\n            u,v,w,x = O\\n            if not areConnected(u,v) and not areConnected(w,x): return True\\n            if not areConnected(u,w) and not areConnected(v,x): return True\\n            if not areConnected(u,x) and not areConnected(v,w): return True\\n            return False\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3155527,
                "title": "easy-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    public Map<Integer, Set<Integer>> buildGraph(int n, List<List<Integer>> edges){\\n\\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\\n\\n        for(int i = 1; i <= n; i++){\\n            graph.put(i, new HashSet<Integer>());\\n        }\\n\\n        for(List<Integer> edge: edges){\\n            Set<Integer> nodeOneEdges = graph.get(edge.get(0));\\n            Set<Integer> nodeTwoEdges = graph.get(edge.get(1));\\n\\n            nodeOneEdges.add(edge.get(1));\\n            nodeTwoEdges.add(edge.get(0));\\n        }\\n\\n        return graph;\\n    }\\n\\n    public List<Integer> getOddNodes(int n, Map<Integer, Set<Integer>> graph){\\n\\n        List<Integer> oddNodes = new ArrayList<>();\\n\\n        for(int node = 1; node <= n; node++){\\n            Set<Integer> edgesToNode = graph.get(node);\\n\\n            if(edgesToNode.size() % 2 == 1){\\n                oddNodes.add(node);\\n            }\\n        }\\n\\n        return oddNodes;\\n    }\\n\\n    public List<Integer> getEvenNodes(int n, List<Integer> oddNodes){\\n        \\n        List<Integer> evenNodes = new ArrayList<>();\\n\\n        for(int node = 1; node <= n; node ++){\\n            if(!oddNodes.contains(node)){\\n                evenNodes.add(node);\\n            }\\n        }\\n\\n        return evenNodes;\\n    }\\n\\n    public boolean checkCasesIfPossible(List<Integer> oddNodes, List<Integer> evenNodes, Map<Integer, Set<Integer>> graph){\\n        boolean canMakeEven = false;\\n        int oddNodesSize = oddNodes.size();\\n\\n        if(oddNodesSize == 0){\\n            canMakeEven = true;\\n        }\\n\\n        if(oddNodesSize == 2){\\n            int nodeOne = oddNodes.get(0);\\n            int nodeTwo = oddNodes.get(1);\\n            Set<Integer> nodeOneConnections = graph.get(nodeOne);\\n            \\n            if(!nodeOneConnections.contains(nodeTwo)){\\n                canMakeEven = true;\\n            }\\n\\n            for(int evenNode: evenNodes){\\n                Set<Integer> evenNodeEdges = graph.get(evenNode);\\n\\n                if(!evenNodeEdges.contains(nodeOne) && !evenNodeEdges.contains(nodeTwo)){\\n                    canMakeEven = true;\\n                }\\n            }\\n        }\\n\\n        if(oddNodesSize == 4){\\n\\n            int nodeOne = oddNodes.get(0);\\n            int nodeTwo = oddNodes.get(1);\\n            int nodeThree = oddNodes.get(2);\\n            int nodeFour = oddNodes.get(3);\\n\\n            Set<Integer> nodeOneEdges = graph.get(nodeOne);\\n            Set<Integer> nodeTwoEdges = graph.get(nodeTwo);\\n            Set<Integer> nodeThreeEdges = graph.get(nodeThree);\\n            Set<Integer> nodeFourEdges = graph.get(nodeFour);\\n\\n            // ((1,2), (3,4)), ((1,3), (2,4)), ((1,4), (2,3)) \\n            if(!nodeOneEdges.contains(nodeTwo) && !nodeThreeEdges.contains(nodeFour)){\\n                canMakeEven = true;\\n            }\\n\\n            if(!nodeOneEdges.contains(nodeThree) && !nodeTwoEdges.contains(nodeFour)){\\n                canMakeEven = true;\\n            }\\n\\n            if(!nodeOneEdges.contains(nodeFour) && !nodeTwoEdges.contains(nodeThree)){\\n                canMakeEven = true;\\n            }\\n        }\\n\\n        return canMakeEven;\\n    }\\n\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n\\n        Map<Integer, Set<Integer>> graph = buildGraph(n, edges);\\n\\n        List<Integer> oddNodes = getOddNodes(n, graph);\\n        List<Integer> evenNodes = getEvenNodes(n, oddNodes);\\n\\n        return checkCasesIfPossible(oddNodes, evenNodes, graph);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public Map<Integer, Set<Integer>> buildGraph(int n, List<List<Integer>> edges){\\n\\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\\n\\n        for(int i = 1; i <= n; i++){\\n            graph.put(i, new HashSet<Integer>());\\n        }\\n\\n        for(List<Integer> edge: edges){\\n            Set<Integer> nodeOneEdges = graph.get(edge.get(0));\\n            Set<Integer> nodeTwoEdges = graph.get(edge.get(1));\\n\\n            nodeOneEdges.add(edge.get(1));\\n            nodeTwoEdges.add(edge.get(0));\\n        }\\n\\n        return graph;\\n    }\\n\\n    public List<Integer> getOddNodes(int n, Map<Integer, Set<Integer>> graph){\\n\\n        List<Integer> oddNodes = new ArrayList<>();\\n\\n        for(int node = 1; node <= n; node++){\\n            Set<Integer> edgesToNode = graph.get(node);\\n\\n            if(edgesToNode.size() % 2 == 1){\\n                oddNodes.add(node);\\n            }\\n        }\\n\\n        return oddNodes;\\n    }\\n\\n    public List<Integer> getEvenNodes(int n, List<Integer> oddNodes){\\n        \\n        List<Integer> evenNodes = new ArrayList<>();\\n\\n        for(int node = 1; node <= n; node ++){\\n            if(!oddNodes.contains(node)){\\n                evenNodes.add(node);\\n            }\\n        }\\n\\n        return evenNodes;\\n    }\\n\\n    public boolean checkCasesIfPossible(List<Integer> oddNodes, List<Integer> evenNodes, Map<Integer, Set<Integer>> graph){\\n        boolean canMakeEven = false;\\n        int oddNodesSize = oddNodes.size();\\n\\n        if(oddNodesSize == 0){\\n            canMakeEven = true;\\n        }\\n\\n        if(oddNodesSize == 2){\\n            int nodeOne = oddNodes.get(0);\\n            int nodeTwo = oddNodes.get(1);\\n            Set<Integer> nodeOneConnections = graph.get(nodeOne);\\n            \\n            if(!nodeOneConnections.contains(nodeTwo)){\\n                canMakeEven = true;\\n            }\\n\\n            for(int evenNode: evenNodes){\\n                Set<Integer> evenNodeEdges = graph.get(evenNode);\\n\\n                if(!evenNodeEdges.contains(nodeOne) && !evenNodeEdges.contains(nodeTwo)){\\n                    canMakeEven = true;\\n                }\\n            }\\n        }\\n\\n        if(oddNodesSize == 4){\\n\\n            int nodeOne = oddNodes.get(0);\\n            int nodeTwo = oddNodes.get(1);\\n            int nodeThree = oddNodes.get(2);\\n            int nodeFour = oddNodes.get(3);\\n\\n            Set<Integer> nodeOneEdges = graph.get(nodeOne);\\n            Set<Integer> nodeTwoEdges = graph.get(nodeTwo);\\n            Set<Integer> nodeThreeEdges = graph.get(nodeThree);\\n            Set<Integer> nodeFourEdges = graph.get(nodeFour);\\n\\n            // ((1,2), (3,4)), ((1,3), (2,4)), ((1,4), (2,3)) \\n            if(!nodeOneEdges.contains(nodeTwo) && !nodeThreeEdges.contains(nodeFour)){\\n                canMakeEven = true;\\n            }\\n\\n            if(!nodeOneEdges.contains(nodeThree) && !nodeTwoEdges.contains(nodeFour)){\\n                canMakeEven = true;\\n            }\\n\\n            if(!nodeOneEdges.contains(nodeFour) && !nodeTwoEdges.contains(nodeThree)){\\n                canMakeEven = true;\\n            }\\n        }\\n\\n        return canMakeEven;\\n    }\\n\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n\\n        Map<Integer, Set<Integer>> graph = buildGraph(n, edges);\\n\\n        List<Integer> oddNodes = getOddNodes(n, graph);\\n        List<Integer> evenNodes = getEvenNodes(n, oddNodes);\\n\\n        return checkCasesIfPossible(oddNodes, evenNodes, graph);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135660,
                "title": "easy-java-solution-without-hashing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        for(int i=0; i<=n; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i=0; i<edges.size(); i++){\\n            int u = edges.get(i).get(0);\\n            int v = edges.get(i).get(1);\\n            adj.get(u).add(v);\\n            adj.get(v).add(u);\\n        }\\n\\n        ArrayList<Integer> oddDeg = new ArrayList<>();\\n        for(int i=0; i<adj.size(); i++){\\n            if(adj.get(i).size()%2==0) continue;\\n            oddDeg.add(i);\\n        }\\n        int size = oddDeg.size();\\n        if(size>4 || size==1 || size==3) return false;\\n        if(size==0) return true;\\n        else if(size==2){\\n            int u = oddDeg.get(0); int v = oddDeg.get(1);\\n            if(!adj.get(u).contains(v)) return true;\\n            for(int i=1; i<=n; i++){\\n                if(i==u || i==v) continue;\\n                if(!adj.get(i).contains(u) && !adj.get(i).contains(v)) return true;\\n            }\\n            return false;\\n        }    \\n\\n        for(int i=0; i<4; i++){\\n            int u=oddDeg.get(i);\\n            for(int j=0; j<4; j++){\\n                if(j==i) continue;\\n                int v = oddDeg.get(j);\\n                if(!adj.get(u).contains(v)){\\n                    for(int k=0; k<4; k++){\\n                        if(k==i || k==j) continue;\\n                        int s = oddDeg.get(k);\\n                        for(int l=0; l<4; l++){\\n                            if(l==i || l==j || l==k) continue;\\n                            int t = oddDeg.get(l);\\n                            if(!adj.get(s).contains(t)) return true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        for(int i=0; i<=n; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i=0; i<edges.size(); i++){\\n            int u = edges.get(i).get(0);\\n            int v = edges.get(i).get(1);\\n            adj.get(u).add(v);\\n            adj.get(v).add(u);\\n        }\\n\\n        ArrayList<Integer> oddDeg = new ArrayList<>();\\n        for(int i=0; i<adj.size(); i++){\\n            if(adj.get(i).size()%2==0) continue;\\n            oddDeg.add(i);\\n        }\\n        int size = oddDeg.size();\\n        if(size>4 || size==1 || size==3) return false;\\n        if(size==0) return true;\\n        else if(size==2){\\n            int u = oddDeg.get(0); int v = oddDeg.get(1);\\n            if(!adj.get(u).contains(v)) return true;\\n            for(int i=1; i<=n; i++){\\n                if(i==u || i==v) continue;\\n                if(!adj.get(i).contains(u) && !adj.get(i).contains(v)) return true;\\n            }\\n            return false;\\n        }    \\n\\n        for(int i=0; i<4; i++){\\n            int u=oddDeg.get(i);\\n            for(int j=0; j<4; j++){\\n                if(j==i) continue;\\n                int v = oddDeg.get(j);\\n                if(!adj.get(u).contains(v)){\\n                    for(int k=0; k<4; k++){\\n                        if(k==i || k==j) continue;\\n                        int s = oddDeg.get(k);\\n                        for(int l=0; l<4; l++){\\n                            if(l==i || l==j || l==k) continue;\\n                            int t = oddDeg.get(l);\\n                            if(!adj.get(s).contains(t)) return true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135412,
                "title": "best-simple-solution",
                "content": "\\n```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        // number of edges of each node\\n        int[] noe=new int[n+1];\\n        \\n        // make a graph\\n        List<List<Integer>> graph=new ArrayList<>();\\n        for(int i=0;i<=n;i++) graph.add(new ArrayList<>());\\n        for(List<Integer> c:edges){\\n            int x=c.get(0);\\n            int y=c.get(1);\\n            graph.get(x).add(y);\\n            graph.get(y).add(x);\\n            noe[x]++;\\n            noe[y]++;\\n        }\\n        \\n        // nodes with number of odd edges will be in the list\\n        List<Integer> list=new ArrayList<>();\\n        \\n        for(int i=0;i<noe.length;i++){ \\n            if(noe[i]%2==1){\\n                list.add(i);\\n            }\\n        }\\n        \\n        int odd=list.size();   \\n        \\n        //no odds\\n        if(odd==0) return true;\\n        else if(odd>4||odd==1||odd==3) return false; // we can\\'t get ans with these conditions because edges will connect 2 nodes\\n        else if(odd==4){ // if odd is 4 then we have to try out every possible combination\\n            int node1=list.get(0);\\n            int node2=list.get(1);\\n            int node3=list.get(2);\\n            int node4=list.get(3);\\n            if(checkIfLegal(graph,node1,node2) && checkIfLegal(graph,node3,node4)) return true;\\n            if(checkIfLegal(graph,node1,node3) && checkIfLegal(graph,node2,node4)) return true;\\n            if(checkIfLegal(graph,node1,node4) && checkIfLegal(graph,node2,node3)) return true;\\n        }else if(odd==2){ // if odd is 2 there are 2 conditions either join the 2 nodes with odd edges or join one node with even edge with 2 nodes with odd edge\\n            int x=list.get(0);\\n            int y=list.get(1);\\n            if(checkIfLegal(graph,y,x)) return true;\\n            for(int i=1;i<noe.length;i++){\\n                if(i==x||i==y) continue;\\n                if(checkIfLegal(graph,i,x) && checkIfLegal(graph,i,y)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    // will check if there is not a repeated edge or self loop\\n    public boolean checkIfLegal(List<List<Integer>> graph,int x,int y){\\n        for(int val:graph.get(x)) if(val==y) return false;\\n        return true;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        // number of edges of each node\\n        int[] noe=new int[n+1];\\n        \\n        // make a graph\\n        List<List<Integer>> graph=new ArrayList<>();\\n        for(int i=0;i<=n;i++) graph.add(new ArrayList<>());\\n        for(List<Integer> c:edges){\\n            int x=c.get(0);\\n            int y=c.get(1);\\n            graph.get(x).add(y);\\n            graph.get(y).add(x);\\n            noe[x]++;\\n            noe[y]++;\\n        }\\n        \\n        // nodes with number of odd edges will be in the list\\n        List<Integer> list=new ArrayList<>();\\n        \\n        for(int i=0;i<noe.length;i++){ \\n            if(noe[i]%2==1){\\n                list.add(i);\\n            }\\n        }\\n        \\n        int odd=list.size();   \\n        \\n        //no odds\\n        if(odd==0) return true;\\n        else if(odd>4||odd==1||odd==3) return false; // we can\\'t get ans with these conditions because edges will connect 2 nodes\\n        else if(odd==4){ // if odd is 4 then we have to try out every possible combination\\n            int node1=list.get(0);\\n            int node2=list.get(1);\\n            int node3=list.get(2);\\n            int node4=list.get(3);\\n            if(checkIfLegal(graph,node1,node2) && checkIfLegal(graph,node3,node4)) return true;\\n            if(checkIfLegal(graph,node1,node3) && checkIfLegal(graph,node2,node4)) return true;\\n            if(checkIfLegal(graph,node1,node4) && checkIfLegal(graph,node2,node3)) return true;\\n        }else if(odd==2){ // if odd is 2 there are 2 conditions either join the 2 nodes with odd edges or join one node with even edge with 2 nodes with odd edge\\n            int x=list.get(0);\\n            int y=list.get(1);\\n            if(checkIfLegal(graph,y,x)) return true;\\n            for(int i=1;i<noe.length;i++){\\n                if(i==x||i==y) continue;\\n                if(checkIfLegal(graph,i,x) && checkIfLegal(graph,i,y)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    // will check if there is not a repeated edge or self loop\\n    public boolean checkIfLegal(List<List<Integer>> graph,int x,int y){\\n        for(int val:graph.get(x)) if(val==y) return false;\\n        return true;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3122746,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<unordered_set<int>> v(n+1);\\n        for(auto &i: edges){\\n            v[i[0]].insert(i[1]);\\n            v[i[1]].insert(i[0]);\\n        }\\n        vector<int> o;\\n        for(int i = 1; i<=n; i++){\\n            if(v[i].size()%2==1){\\n                o.push_back(i);\\n            }\\n        }\\n        if(o.size()==2){\\n            for(int i = 1; i <= n; i++){\\n                if(v[o[0]].count(i)==0&&v[o[1]].count(i)==0)return true;\\n            }\\n        }\\n        if(o.size()==4){\\n            return (\\n                (v[o[0]].count(o[1])==0&&v[o[2]].count(o[3])==0)\\n            ||  (v[o[0]].count(o[2])==0&&v[o[1]].count(o[3])==0)\\n            ||  (v[o[0]].count(o[3])==0&&v[o[1]].count(o[2])==0)\\n            );\\n        }\\n        return o.size()==0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<unordered_set<int>> v(n+1);\\n        for(auto &i: edges){\\n            v[i[0]].insert(i[1]);\\n            v[i[1]].insert(i[0]);\\n        }\\n        vector<int> o;\\n        for(int i = 1; i<=n; i++){\\n            if(v[i].size()%2==1){\\n                o.push_back(i);\\n            }\\n        }\\n        if(o.size()==2){\\n            for(int i = 1; i <= n; i++){\\n                if(v[o[0]].count(i)==0&&v[o[1]].count(i)==0)return true;\\n            }\\n        }\\n        if(o.size()==4){\\n            return (\\n                (v[o[0]].count(o[1])==0&&v[o[2]].count(o[3])==0)\\n            ||  (v[o[0]].count(o[2])==0&&v[o[1]].count(o[3])==0)\\n            ||  (v[o[0]].count(o[3])==0&&v[o[1]].count(o[2])==0)\\n            );\\n        }\\n        return o.size()==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091191,
                "title": "c-hashmap-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<unordered_map<int, int>> e(n + 1);\\n        for(vector<int> edge: edges) {\\n            e[edge[0]][edge[1]] += 1;\\n            e[edge[1]][edge[0]] += 1;\\n        }\\n\\n        queue<int> q;\\n        for(int i = 1; i <= n; i++) {\\n            if(e[i].size() & 1) q.push(i);\\n            if(q.size() > 4) return false;\\n        }\\n\\n        if(q.size() == 0) return true;\\n        \\n        else if(q.size() == 2) {\\n            int n1 = q.front(); q.pop();\\n            int n2 = q.front(); q.pop();\\n            if(!e[n1][n2]) return true;\\n\\n            for(int i = 1; i <= n; i++) {\\n                if(i == n1 || i == n2) continue;\\n                if(!e[n1][i] && !e[n2][i]) return true;\\n            }\\n        } \\n        \\n        else if(q.size() == 4) {\\n            int n1 = q.front(); q.pop();\\n            int n2 = q.front(); q.pop();\\n            int n3 = q.front(); q.pop();\\n            int n4 = q.front(); q.pop();\\n            return (!e[n1][n2] && !e[n3][n4]) || (!e[n1][n3] && !e[n2][n4]) || (!e[n1][n4] && !e[n2][n3]);\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<unordered_map<int, int>> e(n + 1);\\n        for(vector<int> edge: edges) {\\n            e[edge[0]][edge[1]] += 1;\\n            e[edge[1]][edge[0]] += 1;\\n        }\\n\\n        queue<int> q;\\n        for(int i = 1; i <= n; i++) {\\n            if(e[i].size() & 1) q.push(i);\\n            if(q.size() > 4) return false;\\n        }\\n\\n        if(q.size() == 0) return true;\\n        \\n        else if(q.size() == 2) {\\n            int n1 = q.front(); q.pop();\\n            int n2 = q.front(); q.pop();\\n            if(!e[n1][n2]) return true;\\n\\n            for(int i = 1; i <= n; i++) {\\n                if(i == n1 || i == n2) continue;\\n                if(!e[n1][i] && !e[n2][i]) return true;\\n            }\\n        } \\n        \\n        else if(q.size() == 4) {\\n            int n1 = q.front(); q.pop();\\n            int n2 = q.front(); q.pop();\\n            int n3 = q.front(); q.pop();\\n            int n4 = q.front(); q.pop();\\n            return (!e[n1][n2] && !e[n3][n4]) || (!e[n1][n3] && !e[n2][n4]) || (!e[n1][n4] && !e[n2][n3]);\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087423,
                "title": "case-by-case",
                "content": "I swear this ran on the first attempt. :D\\n\\n# Code\\n```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        for edge in edges:\\n            edge[0] -= 1\\n            edge[1] -=1\\n\\n        degree = [0]*n\\n        for edge in edges:\\n            degree[edge[0]] += 1\\n            degree[edge[1]] += 1\\n\\n        neighbors = [set() for _ in range(n)]\\n        for edge in edges:\\n            neighbors[edge[0]].add(edge[1])\\n            neighbors[edge[1]].add(edge[0])\\n        \\n        have_odd_degree = [k for k in range(n) if degree[k] % 2]\\n        assert len(have_odd_degree) % 2 == 0\\n        if len(have_odd_degree) == 0:\\n            return True\\n        if len(have_odd_degree) == 2:\\n            node1, node2 = have_odd_degree\\n            if node1 not in neighbors[node2]:\\n                assert node2 not in neighbors[node1]\\n                return True\\n            if len(neighbors[node1] | neighbors[node2]) == n:\\n                return False\\n            else:\\n                return True\\n        if len(have_odd_degree) == 4:\\n            node1, node2, node3, node4 = have_odd_degree\\n            if node2 not in neighbors[node1] and node4 not in neighbors[node3]:\\n                return True\\n            if node3 not in neighbors[node1] and node4 not in neighbors[node2]:\\n                return True\\n            if node4 not in neighbors[node1] and node3 not in neighbors[node2]:\\n                return True\\n\\n            return False\\n\\n        assert len(have_odd_degree) >= 6\\n        return False",
                "solutionTags": [
                    "Python3"
                ],
                "code": "I swear this ran on the first attempt. :D\\n\\n# Code\\n```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        for edge in edges:\\n            edge[0] -= 1\\n            edge[1] -=1\\n\\n        degree = [0]*n\\n        for edge in edges:\\n            degree[edge[0]] += 1\\n            degree[edge[1]] += 1\\n\\n        neighbors = [set() for _ in range(n)]\\n        for edge in edges:\\n            neighbors[edge[0]].add(edge[1])\\n            neighbors[edge[1]].add(edge[0])\\n        \\n        have_odd_degree = [k for k in range(n) if degree[k] % 2]\\n        assert len(have_odd_degree) % 2 == 0\\n        if len(have_odd_degree) == 0:\\n            return True\\n        if len(have_odd_degree) == 2:\\n            node1, node2 = have_odd_degree\\n            if node1 not in neighbors[node2]:\\n                assert node2 not in neighbors[node1]\\n                return True\\n            if len(neighbors[node1] | neighbors[node2]) == n:\\n                return False\\n            else:\\n                return True\\n        if len(have_odd_degree) == 4:\\n            node1, node2, node3, node4 = have_odd_degree\\n            if node2 not in neighbors[node1] and node4 not in neighbors[node3]:\\n                return True\\n            if node3 not in neighbors[node1] and node4 not in neighbors[node2]:\\n                return True\\n            if node4 not in neighbors[node1] and node3 not in neighbors[node2]:\\n                return True\\n\\n            return False\\n\\n        assert len(have_odd_degree) >= 6\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 3062328,
                "title": "c-98-faster-contrary-thinking-each-case-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n**Contrary Thinking** ---- What can we get from deleting 0/1/2 edges from an evenly connected graph?\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n- **0 edge deleted.** Every node is even-degree. Check directly.\\n- **1 edge deleted.** There are **two odd-degree nodes** and they are not connected to each other.\\n- **2 edges deleted.** There are two cases.\\n    - **2 edges sharing a node.** There are **two odd-degree nodes**, and an even-degree node that is not connected to either of the odd-degree nodes.\\n    - **2 edges not sharing a node.** There are **four odd-degree nodes**; namely $n_1,n_2,n_3,n_4$. There are only three possibilities of the deleted edges: $\\\\{(n_1,n_2),(n_3,n_4)\\\\}$ or $\\\\{(n_1,n_3),(n_2,n_4)\\\\}$ or $\\\\{(n_1,n_4),(n_3,n_2)\\\\}$.\\n\\n# Complexity\\n- Time complexity: $O({\\\\rm edges.size()})$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O({\\\\rm edges.size()})$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isConnected(vector<vector<int>>& el,int n1,int n2){\\n        return find(el[n1].begin(),el[n1].end(),n2)!=el[n1].end();\\n    }\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> el(n);\\n        for(auto& e:edges){\\n            el[e[0]-1].push_back(e[1]-1);\\n            el[e[1]-1].push_back(e[0]-1);\\n        }\\n        vector<int> odd_node;\\n        for(int i=0;i<n;++i) if(el[i].size()%2) odd_node.push_back(i);\\n        if(odd_node.size()==0) return true;//0 edge deleted\\n        if(odd_node.size()==2){\\n            int n1(odd_node[0]),n2(odd_node[1]);\\n            if(!isConnected(el,n1,n2)){//1 edge deleted\\n                return true;\\n            }else{//2 edge deleted sharing one node\\n                int node_dis_n1_n2;\\n                for(node_dis_n1_n2=0;node_dis_n1_n2<n;++node_dis_n1_n2)\\n                    if(node_dis_n1_n2!=n1&&node_dis_n1_n2!=n2&&!isConnected(el,node_dis_n1_n2,n1)&&!isConnected(el,node_dis_n1_n2,n2))\\n                        break;\\n                return node_dis_n1_n2!=n;\\n            }\\n        }\\n        if(odd_node.size()==4){//2 edge deleted not sharing one node\\n            int n1(odd_node[0]),n2(odd_node[1]),n3(odd_node[2]),n4(odd_node[3]);\\n            return (!isConnected(el,n1,n2)&&!isConnected(el,n3,n4))||\\n                    (!isConnected(el,n1,n3)&&!isConnected(el,n2,n4))||\\n                    (!isConnected(el,n1,n4)&&!isConnected(el,n2,n3));\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isConnected(vector<vector<int>>& el,int n1,int n2){\\n        return find(el[n1].begin(),el[n1].end(),n2)!=el[n1].end();\\n    }\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> el(n);\\n        for(auto& e:edges){\\n            el[e[0]-1].push_back(e[1]-1);\\n            el[e[1]-1].push_back(e[0]-1);\\n        }\\n        vector<int> odd_node;\\n        for(int i=0;i<n;++i) if(el[i].size()%2) odd_node.push_back(i);\\n        if(odd_node.size()==0) return true;//0 edge deleted\\n        if(odd_node.size()==2){\\n            int n1(odd_node[0]),n2(odd_node[1]);\\n            if(!isConnected(el,n1,n2)){//1 edge deleted\\n                return true;\\n            }else{//2 edge deleted sharing one node\\n                int node_dis_n1_n2;\\n                for(node_dis_n1_n2=0;node_dis_n1_n2<n;++node_dis_n1_n2)\\n                    if(node_dis_n1_n2!=n1&&node_dis_n1_n2!=n2&&!isConnected(el,node_dis_n1_n2,n1)&&!isConnected(el,node_dis_n1_n2,n2))\\n                        break;\\n                return node_dis_n1_n2!=n;\\n            }\\n        }\\n        if(odd_node.size()==4){//2 edge deleted not sharing one node\\n            int n1(odd_node[0]),n2(odd_node[1]),n3(odd_node[2]),n4(odd_node[3]);\\n            return (!isConnected(el,n1,n2)&&!isConnected(el,n3,n4))||\\n                    (!isConnected(el,n1,n3)&&!isConnected(el,n2,n4))||\\n                    (!isConnected(el,n1,n4)&&!isConnected(el,n2,n3));\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033028,
                "title": "c-case-by-case",
                "content": "# Intuition\\ncollect all nodes with odd degrees, then if the collection is with size =:\\n1. size = 0, pass\\n2. size = odd number, no way\\n3. size = 2, check if they can be connected, otherwise check if there is a common node for both nodes to connect\\n4. size = 4, check if they could construct two disjoint pairs and could be connected\\n5. size > 4, no way\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> cnt(n + 1);\\n        vector<unordered_set<int>> graph(n + 1);\\n        for (auto& edge : edges) {\\n            ++cnt[edge[0]];\\n            ++cnt[edge[1]];\\n            graph[edge[0]].insert(edge[1]);\\n            graph[edge[1]].insert(edge[0]);\\n        }\\n        vector<int> toResolve;\\n        for (int i = 1; i <= n; ++i) {\\n            if (cnt[i] & 1) {\\n                toResolve.push_back(i);\\n            }\\n        }\\n        if (toResolve.empty()) {\\n            return true;\\n        }\\n        if (toResolve.size() > 4) {\\n            return false;\\n        }\\n        if (toResolve.size() & 1) {\\n            return false;\\n        }\\n        if (toResolve.size() == 2) {\\n            if (!graph[toResolve[0]].count(toResolve[1])) {\\n                return true;\\n            }\\n            for (int i = 1; i <= n; ++i) {\\n                if (i != toResolve[0] && i != toResolve[1]) {\\n                    if (!graph[i].count(toResolve[0]) && !graph[i].count(toResolve[1])) {\\n                        return true;\\n                    }\\n                }\\n            }\\n            return false;\\n        }\\n        for (int i = 0; i < 4; ++i) {\\n            for (int j = i + 1; j < 4; ++j) {\\n                if (!graph[toResolve[i]].count(toResolve[j])) {\\n                    int first = -1, second = -1;\\n                    for (int k = 0; k < 4; ++k) {\\n                        if (k != i && k != j) {\\n                            if (first == -1) {\\n                                first = k;\\n                            } else {\\n                                second = k;\\n                            }\\n                        }\\n                    }\\n                    if (!graph[toResolve[first]].count(toResolve[second])) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> cnt(n + 1);\\n        vector<unordered_set<int>> graph(n + 1);\\n        for (auto& edge : edges) {\\n            ++cnt[edge[0]];\\n            ++cnt[edge[1]];\\n            graph[edge[0]].insert(edge[1]);\\n            graph[edge[1]].insert(edge[0]);\\n        }\\n        vector<int> toResolve;\\n        for (int i = 1; i <= n; ++i) {\\n            if (cnt[i] & 1) {\\n                toResolve.push_back(i);\\n            }\\n        }\\n        if (toResolve.empty()) {\\n            return true;\\n        }\\n        if (toResolve.size() > 4) {\\n            return false;\\n        }\\n        if (toResolve.size() & 1) {\\n            return false;\\n        }\\n        if (toResolve.size() == 2) {\\n            if (!graph[toResolve[0]].count(toResolve[1])) {\\n                return true;\\n            }\\n            for (int i = 1; i <= n; ++i) {\\n                if (i != toResolve[0] && i != toResolve[1]) {\\n                    if (!graph[i].count(toResolve[0]) && !graph[i].count(toResolve[1])) {\\n                        return true;\\n                    }\\n                }\\n            }\\n            return false;\\n        }\\n        for (int i = 0; i < 4; ++i) {\\n            for (int j = i + 1; j < 4; ++j) {\\n                if (!graph[toResolve[i]].count(toResolve[j])) {\\n                    int first = -1, second = -1;\\n                    for (int k = 0; k < 4; ++k) {\\n                        if (k != i && k != j) {\\n                            if (first == -1) {\\n                                first = k;\\n                            } else {\\n                                second = k;\\n                            }\\n                        }\\n                    }\\n                    if (!graph[toResolve[first]].count(toResolve[second])) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012772,
                "title": "simplest-intuitive-approach-with-linear-time-clean-code-with-comments",
                "content": "# Complexity\\n- Time complexity: O(M) + O(N) [Edges ITeration + Iterating Adj list]\\n- Checking operation is totally O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N+M) [Adj list takes this much]\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        unordered_set<int> adj[n+1];\\n        \\n        for(auto e : edges){\\n            int u = e[0];\\n            int v = e[1];\\n\\n            adj[u].insert(v);\\n            adj[v].insert(u);\\n\\n        }\\n\\n        vector<int> oddDegVer;\\n        for(int i=1; i<=n; i++){\\n            if(adj[i].size()%2 != 0){\\n                oddDegVer.push_back(i);\\n            }\\n        }\\n\\n        int sz = oddDegVer.size();\\n        if( sz == 0){\\n            return true; // its all good already\\n        }\\n        else if( sz == 2){\\n            /*\\n            IMP EDGE CASE :\\n            when its 2, dont just check with those 2 nodes itself\\n            As We use only 1 edge in that case but we can use 2 at most\\n            As there is a possibility here U - V are already connected\\n            then there can be a third node X\\n            U-X V-X will make U and V as even deg also X is already even now +2 makes it to remain even again\\n            */\\n            int node1 = oddDegVer[0];\\n            int node2 = oddDegVer[1];\\n            if(adj[node1].count(node2) == 0){\\n                return true; // not ADJ Node1 and node2 \\n            }\\n            for(int i=1; i<=n; i++){\\n                if(i!=node1 && 1!=node2){\\n                    if(adj[node1].count(i) == 0 && adj[node2].count(i)==0){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        else if(sz == 4){\\n            int node1 = oddDegVer[0];\\n            int node2 = oddDegVer[1];\\n            int node3 = oddDegVer[2];\\n            int node4 = oddDegVer[3];\\n            /*\\n            these are the possible pairs which we are trying to accomodate\\n            node 1 - node2 node3-node4 or node1-node3 node2-node4 or node1-node4 node2-node3\\n            thats it all others are duplicates\\n            */\\n            if((adj[node1].count(node2)==0 && adj[node3].count(node4)==0) \\n            || (adj[node1].count(node3)==0 && adj[node2].count(node4)==0)\\n            || (adj[node1].count(node4)==0 && adj[node2].count(node3)==0)){\\n                return true;\\n            }\\n        }\\n        return false; //orelse anyways its fails to connect such way\\n\\n    }\\n};\\n\\n/*\\n0 odd\\n2 odd and not adj\\nas no parallel edges or self loops\\n\\n4 odd and 2 pair of not adj\\n\\nno need to check beyond 4 as its not possible connect with 2 edges atmost\\n\\nno need to check for odd no of odd deg nodes , why?\\nBcoz we need to connect with someone. So It indeed makes that as Odd.\\nSo Not Possible\\n\\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        unordered_set<int> adj[n+1];\\n        \\n        for(auto e : edges){\\n            int u = e[0];\\n            int v = e[1];\\n\\n            adj[u].insert(v);\\n            adj[v].insert(u);\\n\\n        }\\n\\n        vector<int> oddDegVer;\\n        for(int i=1; i<=n; i++){\\n            if(adj[i].size()%2 != 0){\\n                oddDegVer.push_back(i);\\n            }\\n        }\\n\\n        int sz = oddDegVer.size();\\n        if( sz == 0){\\n            return true; // its all good already\\n        }\\n        else if( sz == 2){\\n            /*\\n            IMP EDGE CASE :\\n            when its 2, dont just check with those 2 nodes itself\\n            As We use only 1 edge in that case but we can use 2 at most\\n            As there is a possibility here U - V are already connected\\n            then there can be a third node X\\n            U-X V-X will make U and V as even deg also X is already even now +2 makes it to remain even again\\n            */\\n            int node1 = oddDegVer[0];\\n            int node2 = oddDegVer[1];\\n            if(adj[node1].count(node2) == 0){\\n                return true; // not ADJ Node1 and node2 \\n            }\\n            for(int i=1; i<=n; i++){\\n                if(i!=node1 && 1!=node2){\\n                    if(adj[node1].count(i) == 0 && adj[node2].count(i)==0){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        else if(sz == 4){\\n            int node1 = oddDegVer[0];\\n            int node2 = oddDegVer[1];\\n            int node3 = oddDegVer[2];\\n            int node4 = oddDegVer[3];\\n            /*\\n            these are the possible pairs which we are trying to accomodate\\n            node 1 - node2 node3-node4 or node1-node3 node2-node4 or node1-node4 node2-node3\\n            thats it all others are duplicates\\n            */\\n            if((adj[node1].count(node2)==0 && adj[node3].count(node4)==0) \\n            || (adj[node1].count(node3)==0 && adj[node2].count(node4)==0)\\n            || (adj[node1].count(node4)==0 && adj[node2].count(node3)==0)){\\n                return true;\\n            }\\n        }\\n        return false; //orelse anyways its fails to connect such way\\n\\n    }\\n};\\n\\n/*\\n0 odd\\n2 odd and not adj\\nas no parallel edges or self loops\\n\\n4 odd and 2 pair of not adj\\n\\nno need to check beyond 4 as its not possible connect with 2 edges atmost\\n\\nno need to check for odd no of odd deg nodes , why?\\nBcoz we need to connect with someone. So It indeed makes that as Odd.\\nSo Not Possible\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3002974,
                "title": "java-implementation",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        HashMap<Integer,ArrayList<Integer>> map = new HashMap<>();\\n        for(int i = 1;i<=n;i++) map.put(i,new ArrayList<Integer>());\\n        long e = (long)n;\\n        ArrayList<Integer> x = new ArrayList<>();\\n        e = e*(e-1)/2;\\n        for(List<Integer> al:edges){\\n            int a = al.get(0);\\n            int b = al.get(1);\\n            map.get(a).add(b);\\n            map.get(b).add(a);\\n        }\\n        int odd = 0;\\n        int z = 0;\\n        for(int i = 1;i<=n;i++){\\n            int t = map.get(i).size();\\n            if(t%2 != 0){\\n                odd++;\\n                x.add(i);\\n            }\\n            if(t == 0) z++;\\n            if(t == n-1 && t%2 != 0) return false; \\n        }\\n        // System.out.println(map);\\n        // System.out.println(x);\\n        if(odd == 0) return true;\\n        if(odd == 2){\\n            int a = x.get(0);\\n            int b = x.get(1);\\n            ArrayList<Integer> y = map.get(a);\\n            for(int i = 0;i<y.size();i++){\\n                if(y.get(i) == b) return find2(a,b,map);\\n            }\\n            return true;\\n        }\\n        if(odd == 4){\\n            int a = x.get(0);\\n            int b = x.get(1);\\n            int c = x.get(2);\\n            int d = x.get(3);\\n            if(find(a,b,c,d,map) || find(a,c,b,d,map) || find(a,d,b,c,map)) return true;\\n        }\\n        return false;\\n    }\\n    boolean find2(int a, int b, HashMap<Integer, ArrayList<Integer>> map){\\n        for(int i = 1;i<=map.size();i++){\\n            if(i == a || i == b) continue;\\n            int f = 0;\\n            for(int it:map.get(i)){\\n                if(it == a || it == b){\\n                    f = 1;\\n                    break;\\n                }\\n            }\\n            if(f == 0) return true;\\n        }\\n        return false;\\n    }\\n    boolean find(int a, int b, int c ,int d, HashMap<Integer, ArrayList<Integer>> map){\\n         ArrayList<Integer> y = map.get(a);\\n            for(int i = 0;i<y.size();i++){\\n                if(y.get(i) == b) return false;\\n            }\\n            y = map.get(c);\\n            for(int i = 0;i<y.size();i++){\\n                if(y.get(i) == d) return false;\\n            }\\n            return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        HashMap<Integer,ArrayList<Integer>> map = new HashMap<>();\\n        for(int i = 1;i<=n;i++) map.put(i,new ArrayList<Integer>());\\n        long e = (long)n;\\n        ArrayList<Integer> x = new ArrayList<>();\\n        e = e*(e-1)/2;\\n        for(List<Integer> al:edges){\\n            int a = al.get(0);\\n            int b = al.get(1);\\n            map.get(a).add(b);\\n            map.get(b).add(a);\\n        }\\n        int odd = 0;\\n        int z = 0;\\n        for(int i = 1;i<=n;i++){\\n            int t = map.get(i).size();\\n            if(t%2 != 0){\\n                odd++;\\n                x.add(i);\\n            }\\n            if(t == 0) z++;\\n            if(t == n-1 && t%2 != 0) return false; \\n        }\\n        // System.out.println(map);\\n        // System.out.println(x);\\n        if(odd == 0) return true;\\n        if(odd == 2){\\n            int a = x.get(0);\\n            int b = x.get(1);\\n            ArrayList<Integer> y = map.get(a);\\n            for(int i = 0;i<y.size();i++){\\n                if(y.get(i) == b) return find2(a,b,map);\\n            }\\n            return true;\\n        }\\n        if(odd == 4){\\n            int a = x.get(0);\\n            int b = x.get(1);\\n            int c = x.get(2);\\n            int d = x.get(3);\\n            if(find(a,b,c,d,map) || find(a,c,b,d,map) || find(a,d,b,c,map)) return true;\\n        }\\n        return false;\\n    }\\n    boolean find2(int a, int b, HashMap<Integer, ArrayList<Integer>> map){\\n        for(int i = 1;i<=map.size();i++){\\n            if(i == a || i == b) continue;\\n            int f = 0;\\n            for(int it:map.get(i)){\\n                if(it == a || it == b){\\n                    f = 1;\\n                    break;\\n                }\\n            }\\n            if(f == 0) return true;\\n        }\\n        return false;\\n    }\\n    boolean find(int a, int b, int c ,int d, HashMap<Integer, ArrayList<Integer>> map){\\n         ArrayList<Integer> y = map.get(a);\\n            for(int i = 0;i<y.size();i++){\\n                if(y.get(i) == b) return false;\\n            }\\n            y = map.get(c);\\n            for(int i = 0;i<y.size();i++){\\n                if(y.get(i) == d) return false;\\n            }\\n            return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2982217,
                "title": "c-sol",
                "content": "```\\nconst int N = 1e5 + 10;\\nint in[N];\\nset<int> g[N];\\n\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        for(int i = 0; i <= n; i++) { \\n            in[i] = 0; \\n            g[i].clear();\\n        }\\n        \\n        for(vector<int>& e : edges) {\\n            in[e[0]]++;\\n            in[e[1]]++;\\n            g[e[0]].insert(e[1]);\\n            g[e[1]].insert(e[0]);\\n        }\\n        \\n        vector<int> nodes;\\n        for(int i = 1; i <= n; i++) {\\n            if(in[i] % 2 == 1) {\\n                nodes.push_back(i);\\n            }\\n        }\\n        \\n        if(nodes.size() == 0) {\\n            return true;\\n        }\\n        \\n        if(nodes.size() > 4 || nodes.size() == 1 || nodes.size() == 3){\\n            return false;\\n        }   \\n        \\n        if(nodes.size() == 2) {\\n            if(g[nodes[0]].find(nodes[1]) == g[nodes[0]].end()) {\\n                return true;\\n            }\\n            for(int i = 1; i <= n; i++) {\\n                if(i == nodes[0] || i == nodes[1]) {\\n                    continue;\\n                }\\n                if(g[i].find(nodes[0]) == g[i].end() && g[i].find(nodes[1]) == g[i].end()) {\\n                    return true;\\n                }\\n            }\\n        } else {\\n            do {\\n                int u = nodes[0], v = nodes[1], x = nodes[2], y = nodes[3];\\n                if(g[u].find(v) == g[u].end() && g[x].find(y) == g[x].end()) {\\n                    return true;\\n                }\\n            } while (std::next_permutation(nodes.begin(), nodes.end()));\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int N = 1e5 + 10;\\nint in[N];\\nset<int> g[N];\\n\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        for(int i = 0; i <= n; i++) { \\n            in[i] = 0; \\n            g[i].clear();\\n        }\\n        \\n        for(vector<int>& e : edges) {\\n            in[e[0]]++;\\n            in[e[1]]++;\\n            g[e[0]].insert(e[1]);\\n            g[e[1]].insert(e[0]);\\n        }\\n        \\n        vector<int> nodes;\\n        for(int i = 1; i <= n; i++) {\\n            if(in[i] % 2 == 1) {\\n                nodes.push_back(i);\\n            }\\n        }\\n        \\n        if(nodes.size() == 0) {\\n            return true;\\n        }\\n        \\n        if(nodes.size() > 4 || nodes.size() == 1 || nodes.size() == 3){\\n            return false;\\n        }   \\n        \\n        if(nodes.size() == 2) {\\n            if(g[nodes[0]].find(nodes[1]) == g[nodes[0]].end()) {\\n                return true;\\n            }\\n            for(int i = 1; i <= n; i++) {\\n                if(i == nodes[0] || i == nodes[1]) {\\n                    continue;\\n                }\\n                if(g[i].find(nodes[0]) == g[i].end() && g[i].find(nodes[1]) == g[i].end()) {\\n                    return true;\\n                }\\n            }\\n        } else {\\n            do {\\n                int u = nodes[0], v = nodes[1], x = nodes[2], y = nodes[3];\\n                if(g[u].find(v) == g[u].end() && g[x].find(y) == g[x].end()) {\\n                    return true;\\n                }\\n            } while (std::next_permutation(nodes.begin(), nodes.end()));\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2980372,
                "title": "o-n-solution-in-c-well-commented-code",
                "content": "```\\nclass Solution {\\n    vector<int> odd;\\n    vector<set<int>> adj;\\npublic:\\n    bool isPossible(int n, const vector<vector<int>>& edges) {\\n        adj = vector<set<int>>(n);\\n        for(vector<int> edge: edges) {\\n            int a = edge[0]-1, b = edge[1]-1;\\n            adj[a].insert(b);\\n            adj[b].insert(a);\\n        }\\n        for(int i=0; i<n; i++) {\\n            // Inserting all the nodes with odd degree in a array\\n            if(((int)adj[i].size()) & 1) {\\n                odd.push_back(i);\\n            }\\n        }\\n        \\n        int O = odd.size();\\n        if(O == 0) { // every node has even degree\\n            return true;\\n        } else if(O == 2) { // two nodes has even degree\\n            if(adj[odd[0]].find(odd[1]) == adj[odd[0]].end()) return true; // nodes are not connected to each other\\n            for(int i=0; i<n; i++) {\\n                if(i != odd[0] && i != odd[1] && adj[i].find(odd[0]) == adj[i].end() && adj[i].find(odd[1]) == adj[i].end()) {\\n                    // node i has even degree, and is not connected to odd[0] and odd[1] nodes.\\n                    return true;\\n                }\\n            }\\n        } else if(O == 4) { // four nodes has even degree\\n            // finding all the permutations of 4 nodes having odd degree and \\n            // lets the permutation be {a, b, c, d} and if we can join a to b and b to c then return true.\\n            sort(odd.begin(), odd.end());\\n            do {\\n                int a = odd[0], b = odd[1], c = odd[2], d = odd[3];\\n                if(adj[a].find(b) == adj[a].end() && adj[c].find(d) == adj[c].end())\\n                    return true;\\n            } while(next_permutation(odd.begin(), odd.end()));\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> odd;\\n    vector<set<int>> adj;\\npublic:\\n    bool isPossible(int n, const vector<vector<int>>& edges) {\\n        adj = vector<set<int>>(n);\\n        for(vector<int> edge: edges) {\\n            int a = edge[0]-1, b = edge[1]-1;\\n            adj[a].insert(b);\\n            adj[b].insert(a);\\n        }\\n        for(int i=0; i<n; i++) {\\n            // Inserting all the nodes with odd degree in a array\\n            if(((int)adj[i].size()) & 1) {\\n                odd.push_back(i);\\n            }\\n        }\\n        \\n        int O = odd.size();\\n        if(O == 0) { // every node has even degree\\n            return true;\\n        } else if(O == 2) { // two nodes has even degree\\n            if(adj[odd[0]].find(odd[1]) == adj[odd[0]].end()) return true; // nodes are not connected to each other\\n            for(int i=0; i<n; i++) {\\n                if(i != odd[0] && i != odd[1] && adj[i].find(odd[0]) == adj[i].end() && adj[i].find(odd[1]) == adj[i].end()) {\\n                    // node i has even degree, and is not connected to odd[0] and odd[1] nodes.\\n                    return true;\\n                }\\n            }\\n        } else if(O == 4) { // four nodes has even degree\\n            // finding all the permutations of 4 nodes having odd degree and \\n            // lets the permutation be {a, b, c, d} and if we can join a to b and b to c then return true.\\n            sort(odd.begin(), odd.end());\\n            do {\\n                int a = odd[0], b = odd[1], c = odd[2], d = odd[3];\\n                if(adj[a].find(b) == adj[a].end() && adj[c].find(d) == adj[c].end())\\n                    return true;\\n            } while(next_permutation(odd.begin(), odd.end()));\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972288,
                "title": "decission-tree-depending-on-how-many-odd-degree-nodes",
                "content": "# Approach\\n`numOdd` is the number of nodes with odd degree. Depending on its value there are diffent answers. The code below is self-explanatory\\n\\n# Code\\n```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        out = [set() for _ in range(n+1)]\\n        for a, b in edges:\\n            out[a].add(b)\\n            out[b].add(a)\\n        isOdd = [len(s) % 2 for s in out]\\n        odd = [i for i, v in enumerate(isOdd) if v]\\n        def joinTwo(a, b):\\n            for v in range(1, n+1):\\n                if v not in out[a] and v not in out[b]:\\n                    return True\\n            return False\\n        \\n        numOdd = len(odd)\\n        if numOdd == 0:\\n            return True\\n        if numOdd > 4 or numOdd % 2 == 1:\\n            return False\\n        if numOdd == 2:\\n            if odd[0] not in out[odd[1]]:    # it means vice versa too\\n                return True\\n            return joinTwo(odd[0], odd[1])\\n        if numOdd == 4: # last possibility\\n            if odd[1] not in out[odd[0]] and odd[3] not in out[odd[2]]:\\n                return True\\n            if odd[2] not in out[odd[0]] and odd[1] not in out[odd[3]]:\\n                return True\\n            if odd[3] not in out[odd[0]] and odd[1] not in out[odd[2]]:\\n                return True\\n        return(False)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        out = [set() for _ in range(n+1)]\\n        for a, b in edges:\\n            out[a].add(b)\\n            out[b].add(a)\\n        isOdd = [len(s) % 2 for s in out]\\n        odd = [i for i, v in enumerate(isOdd) if v]\\n        def joinTwo(a, b):\\n            for v in range(1, n+1):\\n                if v not in out[a] and v not in out[b]:\\n                    return True\\n            return False\\n        \\n        numOdd = len(odd)\\n        if numOdd == 0:\\n            return True\\n        if numOdd > 4 or numOdd % 2 == 1:\\n            return False\\n        if numOdd == 2:\\n            if odd[0] not in out[odd[1]]:    # it means vice versa too\\n                return True\\n            return joinTwo(odd[0], odd[1])\\n        if numOdd == 4: # last possibility\\n            if odd[1] not in out[odd[0]] and odd[3] not in out[odd[2]]:\\n                return True\\n            if odd[2] not in out[odd[0]] and odd[1] not in out[odd[3]]:\\n                return True\\n            if odd[3] not in out[odd[0]] and odd[1] not in out[odd[2]]:\\n                return True\\n        return(False)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954776,
                "title": "java-simple-easy-with-explanation",
                "content": "```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<n+1;i++){\\n            adj.add(new ArrayList<>()); /*As the number of nodes is n and the nodes are numbered \\n\\t\\t\\t                              from 1 to n so I took an adjacency list of list which \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  has n+1 empty list inserted so that we can add the edges \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  corresponding to the node number.*/\\n        }\\n        for(List<Integer> li:edges){\\n            adj.get(li.get(0)).add(li.get(1));\\n            adj.get(li.get(1)).add(li.get(0)); /* As it\\'s an undirected graph so we have to add \\n\\t\\t\\t                                      the connected nodes in both ways from u->v \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  and v->u. */\\n        }\\n        List<Integer> odvertex=new ArrayList<>();\\n        for(int i=0;i<adj.size();i++){\\n            if(adj.get(i).size()%2!=0)\\n                odvertex.add(i);   /*Storing all the nodes that have odd degrees.*/\\n        }\\n\\t\\t/*Now just think for a moment that in question it\\'s given we can insert atmost 2 edges to \\n\\t\\t  the graph that means we can insert 0/1/2 edges.  If we are not inserting any edge to the \\n\\t\\t  graph that means all the nodes have even degree. If we are inserting 1 edge to the graph \\n\\t\\t  that means there must be two nodes that have odd degrees, Now some might also think if \\n\\t\\t  there are two nodes that have odd degrees so we can directly connect an edge between \\n\\t\\t  them without traversing the adjacency list but think of a case if there is an edge between \\n\\t\\t  them already and they have odd degrees also, so in that case if there exists a node that \\n\\t\\t  has even degree and that doesn\\'t contain both the nodes having odd degrees then we can \\n\\t\\t  let the node that has even degrees to connect with the two nodes having odd degrees \\n\\t\\t  so the even degree in nodes is maintained. Similarly if we are inserting 2 edges to the \\n\\t\\t  graph that means there must be four nodes that have odd degrees. So, If it has no nodes \\n\\t\\t  that have odd degrees then we return true. If it has 2 nodes that have odd degrees then \\n\\t\\t  we have to insert edge to make the degree even so i traversed the whole adjacency list \\n\\t\\t  and searched if there exists a node which doesn\\'t contain both the nodes that have odd \\n\\t\\t  degrees and if found then we return true. If it has 4 nodes that have odd degrees then \\n\\t\\t  we have to take the nodes in pairs and there can be 3 possible pairs i.e \\n\\t\\t  (1. (a,b) & (c,d) , 2. (a,c) & (b,d) , 3. (a,d) & (b,c)) \\n\\t\\t  and if one of the pair is possible then we return true.*/\\n        if(odvertex.size()==0)\\n            return true;\\n        else if(odvertex.size()==2){\\n            int u=odvertex.get(0);int v=odvertex.get(1);\\n            for(int i=1;i<adj.size();i++){\\n                if(!adj.get(i).contains(u) && !adj.get(i).contains(v))\\n                    return true;\\n            }\\n        }\\n        else if(odvertex.size()==4){\\n            int u=odvertex.get(0);int v=odvertex.get(1); int w=odvertex.get(2); int x=odvertex.get(3);\\n            if((!adj.get(u).contains(v) && !adj.get(w).contains(x)) || (!adj.get(u).contains(w) && !adj.get(v).contains(x)) || (!adj.get(u).contains(x) && !adj.get(v).contains(w)))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n**I recommend everyone to see the 3 examples given in the question for better understanding.**\\n\\n**IF YOU LIKED THE APPROACH PLEASE UPVOTE \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F**",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<n+1;i++){\\n            adj.add(new ArrayList<>()); /*As the number of nodes is n and the nodes are numbered \\n\\t\\t\\t                              from 1 to n so I took an adjacency list of list which \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  has n+1 empty list inserted so that we can add the edges \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  corresponding to the node number.*/\\n        }\\n        for(List<Integer> li:edges){\\n            adj.get(li.get(0)).add(li.get(1));\\n            adj.get(li.get(1)).add(li.get(0)); /* As it\\'s an undirected graph so we have to add \\n\\t\\t\\t                                      the connected nodes in both ways from u->v \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  and v->u. */\\n        }\\n        List<Integer> odvertex=new ArrayList<>();\\n        for(int i=0;i<adj.size();i++){\\n            if(adj.get(i).size()%2!=0)\\n                odvertex.add(i);   /*Storing all the nodes that have odd degrees.*/\\n        }\\n\\t\\t/*Now just think for a moment that in question it\\'s given we can insert atmost 2 edges to \\n\\t\\t  the graph that means we can insert 0/1/2 edges.  If we are not inserting any edge to the \\n\\t\\t  graph that means all the nodes have even degree. If we are inserting 1 edge to the graph \\n\\t\\t  that means there must be two nodes that have odd degrees, Now some might also think if \\n\\t\\t  there are two nodes that have odd degrees so we can directly connect an edge between \\n\\t\\t  them without traversing the adjacency list but think of a case if there is an edge between \\n\\t\\t  them already and they have odd degrees also, so in that case if there exists a node that \\n\\t\\t  has even degree and that doesn\\'t contain both the nodes having odd degrees then we can \\n\\t\\t  let the node that has even degrees to connect with the two nodes having odd degrees \\n\\t\\t  so the even degree in nodes is maintained. Similarly if we are inserting 2 edges to the \\n\\t\\t  graph that means there must be four nodes that have odd degrees. So, If it has no nodes \\n\\t\\t  that have odd degrees then we return true. If it has 2 nodes that have odd degrees then \\n\\t\\t  we have to insert edge to make the degree even so i traversed the whole adjacency list \\n\\t\\t  and searched if there exists a node which doesn\\'t contain both the nodes that have odd \\n\\t\\t  degrees and if found then we return true. If it has 4 nodes that have odd degrees then \\n\\t\\t  we have to take the nodes in pairs and there can be 3 possible pairs i.e \\n\\t\\t  (1. (a,b) & (c,d) , 2. (a,c) & (b,d) , 3. (a,d) & (b,c)) \\n\\t\\t  and if one of the pair is possible then we return true.*/\\n        if(odvertex.size()==0)\\n            return true;\\n        else if(odvertex.size()==2){\\n            int u=odvertex.get(0);int v=odvertex.get(1);\\n            for(int i=1;i<adj.size();i++){\\n                if(!adj.get(i).contains(u) && !adj.get(i).contains(v))\\n                    return true;\\n            }\\n        }\\n        else if(odvertex.size()==4){\\n            int u=odvertex.get(0);int v=odvertex.get(1); int w=odvertex.get(2); int x=odvertex.get(3);\\n            if((!adj.get(u).contains(v) && !adj.get(w).contains(x)) || (!adj.get(u).contains(w) && !adj.get(v).contains(x)) || (!adj.get(u).contains(x) && !adj.get(v).contains(w)))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950958,
                "title": "simple-and-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int>inorder(n,0);\\n        map<pair<int,int>,bool>um;\\n        int a,b,c,d;\\n        for(auto it:edges)\\n        {\\n            a=it[0]-1;b=it[1]-1;\\n            inorder[a]++;\\n            inorder[b]++;\\n            um[{a,b}]=true;\\n            um[{b,a}]=true;\\n        }\\n\\n        int x=0;\\n        vector<int>odd;\\n        for(int i=0;i<n;++i)\\n        {\\n            if(inorder[i]%2!=0)\\n                {odd.push_back(i);}\\n        }\\n        int os=odd.size();\\n        if(os==0)return true;\\n        if(os%2!=0 or os>4)return false;\\n        if(os==2)\\n        {\\n            a=odd[0];b=odd[1];\\n            if(!um[{a,b}])return true;\\n            else {\\n                for(int i=0;i<n;++i)\\n                if(!um[{i,a}] and !um[{i,b}])\\n                return true;\\n            }\\n        }\\n        else if(os==4)\\n        {\\n            a=odd[0];b=odd[1];c=odd[2];d=odd[3];\\n\\n            if(!um[{a,b}] and !um[{c,d}])return true;\\n            if(!um[{a,c}] and !um[{b,d}])return true;\\n            if(!um[{a,d}] and !um[{b,c}])return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int>inorder(n,0);\\n        map<pair<int,int>,bool>um;\\n        int a,b,c,d;\\n        for(auto it:edges)\\n        {\\n            a=it[0]-1;b=it[1]-1;\\n            inorder[a]++;\\n            inorder[b]++;\\n            um[{a,b}]=true;\\n            um[{b,a}]=true;\\n        }\\n\\n        int x=0;\\n        vector<int>odd;\\n        for(int i=0;i<n;++i)\\n        {\\n            if(inorder[i]%2!=0)\\n                {odd.push_back(i);}\\n        }\\n        int os=odd.size();\\n        if(os==0)return true;\\n        if(os%2!=0 or os>4)return false;\\n        if(os==2)\\n        {\\n            a=odd[0];b=odd[1];\\n            if(!um[{a,b}])return true;\\n            else {\\n                for(int i=0;i<n;++i)\\n                if(!um[{i,a}] and !um[{i,b}])\\n                return true;\\n            }\\n        }\\n        else if(os==4)\\n        {\\n            a=odd[0];b=odd[1];c=odd[2];d=odd[3];\\n\\n            if(!um[{a,b}] and !um[{c,d}])return true;\\n            if(!um[{a,c}] and !um[{b,d}])return true;\\n            if(!um[{a,d}] and !um[{b,c}])return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945133,
                "title": "c-faster-then-100-self-explanatory-code",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    set<int> Adj[100001];\\n     bool solve(int a, int b , int  c, int d)\\n    {\\n        bool ans1 = true, ans2 = true;\\n        for(auto &x : Adj[a])if(x == b)ans1 = false;\\n        for(auto &x : Adj[c])if(x == d)ans2 = false;\\n        return ans1 & ans2;\\n    }\\n    bool solve(int a, int b, int n)\\n    {\\n        bool ans1 = true;\\n        if(Adj[a].find(b) == Adj[a].end())return true;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(((int)Adj[i].size()&1) == 0)\\n            {\\n                if(Adj[i].find(a) == Adj[i].end() && Adj[i].find(b) == Adj[i].end())return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> Indegree(n+1, 0);\\n        for(auto &x : edges)\\n        {\\n            Adj[x[0]].insert(x[1]);\\n            Adj[x[1]].insert(x[0]);\\n            Indegree[x[0]]++;\\n            Indegree[x[1]]++;\\n        }\\n        \\n        vector<int> odd;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(Indegree[i]&1)\\n            {\\n                odd.push_back(i);\\n            }\\n        }\\n        if(odd.size()  == 0)return true;\\n        if(odd.size() > 4 || odd.size()&1)return false;\\n        if(odd.size() == 2)\\n        {\\n            int x = odd[0], y = odd[1];\\n            return solve(x, y, n);\\n        }\\n        else\\n        {\\n           int a = odd[0], b = odd[1], c = odd[2], d = odd[3];\\n           if(solve(a,b,c,d) || solve(a,c,b,d) || solve(a,d,b,c))return true;\\n           return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<int> Adj[100001];\\n     bool solve(int a, int b , int  c, int d)\\n    {\\n        bool ans1 = true, ans2 = true;\\n        for(auto &x : Adj[a])if(x == b)ans1 = false;\\n        for(auto &x : Adj[c])if(x == d)ans2 = false;\\n        return ans1 & ans2;\\n    }\\n    bool solve(int a, int b, int n)\\n    {\\n        bool ans1 = true;\\n        if(Adj[a].find(b) == Adj[a].end())return true;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(((int)Adj[i].size()&1) == 0)\\n            {\\n                if(Adj[i].find(a) == Adj[i].end() && Adj[i].find(b) == Adj[i].end())return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> Indegree(n+1, 0);\\n        for(auto &x : edges)\\n        {\\n            Adj[x[0]].insert(x[1]);\\n            Adj[x[1]].insert(x[0]);\\n            Indegree[x[0]]++;\\n            Indegree[x[1]]++;\\n        }\\n        \\n        vector<int> odd;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(Indegree[i]&1)\\n            {\\n                odd.push_back(i);\\n            }\\n        }\\n        if(odd.size()  == 0)return true;\\n        if(odd.size() > 4 || odd.size()&1)return false;\\n        if(odd.size() == 2)\\n        {\\n            int x = odd[0], y = odd[1];\\n            return solve(x, y, n);\\n        }\\n        else\\n        {\\n           int a = odd[0], b = odd[1], c = odd[2], d = odd[3];\\n           if(solve(a,b,c,d) || solve(a,c,b,d) || solve(a,d,b,c))return true;\\n           return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943572,
                "title": "graph-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        unordered_map<int, vector<int>> adjList;\\n        for(auto& edge: edges){\\n            adjList[edge[0]].emplace_back(edge[1]);\\n            adjList[edge[1]].emplace_back(edge[0]);\\n        }\\n        int count = 0;\\n        vector<int> nodes;\\n        for(int i=1; i<=n; i++){\\n            if (adjList[i].size() % 2 != 0){\\n                count++;\\n                nodes.push_back(i);\\n            }\\n            \\n            if (count > 4){\\n                break;\\n            }\\n        }\\n        if (count == 2){\\n            for(int i=1; i<=n; i++){\\n                if (find(adjList[i].begin(), adjList[i].end(), nodes[0]) == adjList[i].end() && find(adjList[i].begin(), adjList[i].end(), nodes[1]) == adjList[i].end()){\\n                    return true;\\n                }\\n                \\n            }\\n        }\\n        if (count == 4){\\n            vector<pair<int, int>> posEdge;\\n            for(int i=0; i<4; i++){\\n                for(int j=i+1; j<4; j++){\\n                    bool flag = true;\\n                    for(int nxt: adjList[nodes[i]]){\\n                        if (nxt == nodes[j]){\\n                            flag = false;\\n                            break;\\n                        }\\n                    }\\n                    if (flag){\\n                        posEdge.push_back({nodes[i], nodes[j]});\\n                    }\\n                }\\n            }\\n            for(int i=0; i<posEdge.size(); i++){\\n                for(int j=i+1; j<posEdge.size(); j++){\\n                    if (posEdge[i].first != posEdge[j].first && posEdge[i].second != posEdge[j].second && posEdge[i].first != posEdge[j].second && posEdge[i].second != posEdge[j].first){\\n                        return true;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return count == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        unordered_map<int, vector<int>> adjList;\\n        for(auto& edge: edges){\\n            adjList[edge[0]].emplace_back(edge[1]);\\n            adjList[edge[1]].emplace_back(edge[0]);\\n        }\\n        int count = 0;\\n        vector<int> nodes;\\n        for(int i=1; i<=n; i++){\\n            if (adjList[i].size() % 2 != 0){\\n                count++;\\n                nodes.push_back(i);\\n            }\\n            \\n            if (count > 4){\\n                break;\\n            }\\n        }\\n        if (count == 2){\\n            for(int i=1; i<=n; i++){\\n                if (find(adjList[i].begin(), adjList[i].end(), nodes[0]) == adjList[i].end() && find(adjList[i].begin(), adjList[i].end(), nodes[1]) == adjList[i].end()){\\n                    return true;\\n                }\\n                \\n            }\\n        }\\n        if (count == 4){\\n            vector<pair<int, int>> posEdge;\\n            for(int i=0; i<4; i++){\\n                for(int j=i+1; j<4; j++){\\n                    bool flag = true;\\n                    for(int nxt: adjList[nodes[i]]){\\n                        if (nxt == nodes[j]){\\n                            flag = false;\\n                            break;\\n                        }\\n                    }\\n                    if (flag){\\n                        posEdge.push_back({nodes[i], nodes[j]});\\n                    }\\n                }\\n            }\\n            for(int i=0; i<posEdge.size(); i++){\\n                for(int j=i+1; j<posEdge.size(); j++){\\n                    if (posEdge[i].first != posEdge[j].first && posEdge[i].second != posEdge[j].second && posEdge[i].first != posEdge[j].second && posEdge[i].second != posEdge[j].first){\\n                        return true;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return count == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937253,
                "title": "python-simple-bruteforce-o-v-e",
                "content": "# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        G = defaultdict(set)\\n        for v, w in edges:\\n            G[v].add(w)\\n            G[w].add(v)\\n        odds = set()\\n        for v in range(1, n+1):\\n            if len(G[v])%2:\\n                odds.add(v)\\n        if len(odds) > 4: return False\\n        if len(odds) == 0: return True\\n        odds = list(odds)\\n        print(odds)\\n        wholeset = set(range(1,n+1))\\n        if len(odds) == 2:\\n            v, w = odds\\n            if w in G[v]:\\n                if wholeset - (G[v] | G[w]):\\n                    return True\\n                return False\\n            return True\\n        v = odds.pop()\\n        for w in odds:\\n            if w in G[v]:\\n                continue\\n            x, y = list(set(odds) - set([v,w]))\\n            if y not in G[x]:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        G = defaultdict(set)\\n        for v, w in edges:\\n            G[v].add(w)\\n            G[w].add(v)\\n        odds = set()\\n        for v in range(1, n+1):\\n            if len(G[v])%2:\\n                odds.add(v)\\n        if len(odds) > 4: return False\\n        if len(odds) == 0: return True\\n        odds = list(odds)\\n        print(odds)\\n        wholeset = set(range(1,n+1))\\n        if len(odds) == 2:\\n            v, w = odds\\n            if w in G[v]:\\n                if wholeset - (G[v] | G[w]):\\n                    return True\\n                return False\\n            return True\\n        v = odds.pop()\\n        for w in odds:\\n            if w in G[v]:\\n                continue\\n            x, y = list(set(odds) - set([v,w]))\\n            if y not in G[x]:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936541,
                "title": "simple-logic",
                "content": "```\\nclass Solution {\\n    unordered_set<string> st;\\npublic:\\n    string g(int a,int b){\\n        if(a>b)\\n            swap(a,b);\\n        return to_string(a)+\",\"+to_string(b);\\n    }\\n    \\n    bool isPossible(int n, vector<vector<int>>& a) {\\n        vector<int> deg(n+2,0);\\n        vector<int> p;\\n        for(auto ed:a){\\n            if(ed[0]>ed[1])\\n                swap(ed[1],ed[0]);\\n            string s=to_string(ed[0])+\",\"+to_string(ed[1]);\\n            st.insert(s);\\n            deg[ed[1]]++;\\n            deg[ed[0]]++;\\n        }\\n        \\n        int cnt=0;\\n        for(int i=1;i<=n;i++){\\n            if(deg[i]&1){\\n                cnt++;\\n                p.push_back(i);\\n            }\\n            if(cnt>4)\\n                return 0;\\n        }\\n        \\n        if(cnt==0)\\n            return 1;\\n        \\n        if(cnt>4 or cnt==1 or cnt==3)\\n            return 0;\\n        \\n        if(cnt==2){\\n            if(st.find(g(p[0],p[1]))==st.end())\\n                return 1;\\n            for(int i=1;i<=n;i++){\\n                if(i!=p[0] or i!=p[1]){\\n                    if(st.find(g(p[0],i))==st.end() and st.find(g(p[1],i))==st.end())\\n                        return 1;\\n                }\\n            }\\n            return 0;\\n        }\\n        sort(p.begin(),p.end());\\n        \\n        // (0,1) (2,3)\\n        if(st.find(g(p[0],p[1]))==st.end() and st.find(g(p[2],p[3]))==st.end()){\\n            return 1;\\n        }\\n        // (0,2) (1,3)\\n        if(st.find(g(p[0],p[2]))==st.end() and st.find(g(p[1],p[3]))==st.end()){\\n            return 1;\\n        }\\n        \\n        // (0,3) (1,2)\\n        if(st.find(g(p[0],p[3]))==st.end() and st.find(g(p[1],p[2]))==st.end()){\\n            return 1;\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    unordered_set<string> st;\\npublic:\\n    string g(int a,int b){\\n        if(a>b)\\n            swap(a,b);\\n        return to_string(a)+\",\"+to_string(b);\\n    }\\n    \\n    bool isPossible(int n, vector<vector<int>>& a) {\\n        vector<int> deg(n+2,0);\\n        vector<int> p;\\n        for(auto ed:a){\\n            if(ed[0]>ed[1])\\n                swap(ed[1],ed[0]);\\n            string s=to_string(ed[0])+\",\"+to_string(ed[1]);\\n            st.insert(s);\\n            deg[ed[1]]++;\\n            deg[ed[0]]++;\\n        }\\n        \\n        int cnt=0;\\n        for(int i=1;i<=n;i++){\\n            if(deg[i]&1){\\n                cnt++;\\n                p.push_back(i);\\n            }\\n            if(cnt>4)\\n                return 0;\\n        }\\n        \\n        if(cnt==0)\\n            return 1;\\n        \\n        if(cnt>4 or cnt==1 or cnt==3)\\n            return 0;\\n        \\n        if(cnt==2){\\n            if(st.find(g(p[0],p[1]))==st.end())\\n                return 1;\\n            for(int i=1;i<=n;i++){\\n                if(i!=p[0] or i!=p[1]){\\n                    if(st.find(g(p[0],i))==st.end() and st.find(g(p[1],i))==st.end())\\n                        return 1;\\n                }\\n            }\\n            return 0;\\n        }\\n        sort(p.begin(),p.end());\\n        \\n        // (0,1) (2,3)\\n        if(st.find(g(p[0],p[1]))==st.end() and st.find(g(p[2],p[3]))==st.end()){\\n            return 1;\\n        }\\n        // (0,2) (1,3)\\n        if(st.find(g(p[0],p[2]))==st.end() and st.find(g(p[1],p[3]))==st.end()){\\n            return 1;\\n        }\\n        \\n        // (0,3) (1,2)\\n        if(st.find(g(p[0],p[3]))==st.end() and st.find(g(p[1],p[2]))==st.end()){\\n            return 1;\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2935258,
                "title": "c-simple-and-pass-all-tc",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& ed) {\\n        vector<set<int>>adj(n+1);\\n        vector<int>vis(n+1,0);\\n        vector<int>odd;\\n        for(auto it : ed){\\n            adj[it[0]].insert(it[1]);\\n            adj[it[1]].insert(it[0]);\\n        }\\n        for(int i=1;i<=n;i++){\\n            if(adj[i].size()%2) odd.push_back(i);\\n        }\\n        if(odd.size() == 0) return true;\\n        if(odd.size()>4 || odd.size()%2 == 1) return false;\\n        if(odd.size() == 2){\\n            if(adj[odd[0]].find(odd[1]) == adj[odd[0]].end()) return true;\\n            else{\\n                for(int i=1;i<=n;i++){\\n                    if(adj[odd[0]].find(i) == adj[odd[0]].end()\\n                       && adj[odd[1]].find(i)==adj[odd[1]].end()) \\n                        return true;\\n                }\\n                return false;   \\n          }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<odd.size();i++){\\n            for(int j=odd.size()-1;j>=0;j--){\\n                if(j!=i && adj[odd[j]].find(odd[i]) == adj[odd[j]].end() \\n                   && vis[odd[i]] == 0 && vis[odd[j]]==0){\\n                    //cout<<odd[i]<<\" \"<<odd[j]<<endl;\\n                    vis[odd[i]] = 1;\\n                    vis[odd[j]] = 1;\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n        }\\n        //cout<<cnt;\\n        if(cnt == 2) return true;\\n        return false; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& ed) {\\n        vector<set<int>>adj(n+1);\\n        vector<int>vis(n+1,0);\\n        vector<int>odd;\\n        for(auto it : ed){\\n            adj[it[0]].insert(it[1]);\\n            adj[it[1]].insert(it[0]);\\n        }\\n        for(int i=1;i<=n;i++){\\n            if(adj[i].size()%2) odd.push_back(i);\\n        }\\n        if(odd.size() == 0) return true;\\n        if(odd.size()>4 || odd.size()%2 == 1) return false;\\n        if(odd.size() == 2){\\n            if(adj[odd[0]].find(odd[1]) == adj[odd[0]].end()) return true;\\n            else{\\n                for(int i=1;i<=n;i++){\\n                    if(adj[odd[0]].find(i) == adj[odd[0]].end()\\n                       && adj[odd[1]].find(i)==adj[odd[1]].end()) \\n                        return true;\\n                }\\n                return false;   \\n          }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<odd.size();i++){\\n            for(int j=odd.size()-1;j>=0;j--){\\n                if(j!=i && adj[odd[j]].find(odd[i]) == adj[odd[j]].end() \\n                   && vis[odd[i]] == 0 && vis[odd[j]]==0){\\n                    //cout<<odd[i]<<\" \"<<odd[j]<<endl;\\n                    vis[odd[i]] = 1;\\n                    vis[odd[j]] = 1;\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n        }\\n        //cout<<cnt;\\n        if(cnt == 2) return true;\\n        return false; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2934664,
                "title": "java-javascript-with-picture-explanations",
                "content": "##### First, we need to collect all nodes with odd degrees.\\n<br>\\n\\n### The Key point is \"**at most two additional edges**\".\\n##### So only nodes with up to 4 odd edges are allowed, if over than 4, that means it\\'s impossible to realize to make degrees of all nodes even.\\n\\n<br>\\n\\n##### Now, the subproblem is limited to only 4 nodes. Is there any possibility that the odd node\\'s count equals 1 or 3?\\n#### The answer is NOT\\uFF01\\n##### Because no matter how we add edges or don\\'t do anything, there always remains ONE node that is odd edges.\\n\\n<br>\\n<br>\\n\\n---\\n\\n#### OK now, we just need to consider 2 and 4 nodes situations.\\n<br>\\n\\n### Case 1 : Two odd nodes\\nWe need to check if these 2 nodes can link to the other same nodes. (even edges)\\nOR\\nthese 2 nodes can link to each other, if there is it, return true.\\n<br>\\n<img src=\"https://assets.leetcode.com/users/images/ca4c7598-3e2a-4c02-8316-816149810bfc_1671603896.1864123.png\" width=\"600px\" height=\"auto\"/>\\n\\n<br>\\n<br>\\n\\n---\\n### Case 2 : Four odd nodes\\nTry to link each other, if there exists one case is no duplicate edges and can be linked, return true\\n<br>\\n<img src=\"https://assets.leetcode.com/users/images/6d9d6155-ad5c-47af-8fed-ab4b6278650e_1671604522.859619.png\" width=\"600px\" height=\"auto\"/>\\n\\n<br>\\n<br>\\n\\n---\\n### Edge Case : Two nodes Flase\\n<img src=\"https://assets.leetcode.com/users/images/7a6610db-d807-4fdb-8d4d-97f83159f085_1671606115.7832847.png\" width=\"600px\" height=\"auto\"/>\\n\\n\\n<br>\\n<br>\\n\\n---\\n### Java\\n```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        // build undirected graph\\n        Set<Integer>[] adj = new HashSet[n + 1];\\n        for(int i = 1; i <= n; i++){\\n            adj[i] = new HashSet<>();\\n        }\\n        for(List<Integer> e: edges){\\n            adj[e.get(0)].add(e.get(1));\\n            adj[e.get(1)].add(e.get(0));\\n        }\\n        \\n        // collect odd edges node\\n        List<Integer> odd = new ArrayList<>();\\n        for(int i = 1; i <= n; i++){\\n            if(adj[i].size() % 2 == 1)\\n                odd.add(i);\\n            // if odd nodes are over than 4, \\n            // that means it\\'s impossible to realize to make degrees of all Nodes even\\n            if(odd.size() > 4)\\n                return false;\\n        }\\n        \\n        // Case 1\\n        if(odd.size() == 2){\\n            int n1 = odd.get(0), n2 = odd.get(1);\\n            for(int i = 1; i <= n; i++){\\n                if(!adj[n1].contains(i) && !adj[n2].contains(i))\\n                    return true;\\n            }\\n        }\\n        \\n        // Case 2\\n        if(odd.size() == 4){\\n            int n1 = odd.get(0), n2 = odd.get(1), n3 = odd.get(2), n4 = odd.get(3);\\n            return (!adj[n1].contains(n2) && !adj[n3].contains(n4))\\n                || (!adj[n1].contains(n3) && !adj[n2].contains(n4))\\n                || (!adj[n1].contains(n4) && !adj[n2].contains(n3));\\n        }\\n        \\n        // other cases, if anyone is true, return false.\\n        // other cases: \\n        // odd count == 1 || odd count == 3 || odd count\\n        return odd.size() == 0;\\n    }\\n}\\n```\\n\\n### JavaScript\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {boolean}\\n */\\nvar isPossible = function(n, edges) {\\n    // build undirected graph\\n    const adj = new Array(n + 1).fill().map(() => new Set());\\n    for(const [e1, e2] of edges){\\n        adj[e1].add(e2);\\n        adj[e2].add(e1);\\n    }\\n    \\n    // collect odd edge nodes\\n    let odd = new Set();\\n    for(let i = 1; i <= n; i++){\\n        if(adj[i].size % 2 === 1)\\n            odd.add(i);\\n        // if odd nodes are over than 4, \\n        // that means it\\'s impossible to realize to make degrees of all Nodes even\\n        if(odd.size > 4)\\n            return false;\\n    }\\n    \\n    // Case 1\\n    if(odd.size === 2){\\n        const [n1, n2] = [...odd];\\n        for(let i = 1; i <= n; i++){\\n            if(!adj[n1].has(i) && !adj[n2].has(i))\\n                return true;\\n        }\\n    }\\n    \\n    // Case 2\\n    if(odd.size === 4){\\n        const [n1, n2, n3, n4] = [...odd];\\n        const res =  (!adj[n1].has(n2) && !adj[n3].has(n4))\\n            || (!adj[n1].has(n3) && !adj[n2].has(n4))\\n            || (!adj[n1].has(n4) && !adj[n2].has(n3));\\n        return res;\\n    }\\n    \\n    // other cases, if anyone is true, return false.\\n    // other cases: \\n    // odd count == 1 || odd count == 3 || odd count\\n    return odd.size === 0;\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        // build undirected graph\\n        Set<Integer>[] adj = new HashSet[n + 1];\\n        for(int i = 1; i <= n; i++){\\n            adj[i] = new HashSet<>();\\n        }\\n        for(List<Integer> e: edges){\\n            adj[e.get(0)].add(e.get(1));\\n            adj[e.get(1)].add(e.get(0));\\n        }\\n        \\n        // collect odd edges node\\n        List<Integer> odd = new ArrayList<>();\\n        for(int i = 1; i <= n; i++){\\n            if(adj[i].size() % 2 == 1)\\n                odd.add(i);\\n            // if odd nodes are over than 4, \\n            // that means it\\'s impossible to realize to make degrees of all Nodes even\\n            if(odd.size() > 4)\\n                return false;\\n        }\\n        \\n        // Case 1\\n        if(odd.size() == 2){\\n            int n1 = odd.get(0), n2 = odd.get(1);\\n            for(int i = 1; i <= n; i++){\\n                if(!adj[n1].contains(i) && !adj[n2].contains(i))\\n                    return true;\\n            }\\n        }\\n        \\n        // Case 2\\n        if(odd.size() == 4){\\n            int n1 = odd.get(0), n2 = odd.get(1), n3 = odd.get(2), n4 = odd.get(3);\\n            return (!adj[n1].contains(n2) && !adj[n3].contains(n4))\\n                || (!adj[n1].contains(n3) && !adj[n2].contains(n4))\\n                || (!adj[n1].contains(n4) && !adj[n2].contains(n3));\\n        }\\n        \\n        // other cases, if anyone is true, return false.\\n        // other cases: \\n        // odd count == 1 || odd count == 3 || odd count\\n        return odd.size() == 0;\\n    }\\n}\\n```\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {boolean}\\n */\\nvar isPossible = function(n, edges) {\\n    // build undirected graph\\n    const adj = new Array(n + 1).fill().map(() => new Set());\\n    for(const [e1, e2] of edges){\\n        adj[e1].add(e2);\\n        adj[e2].add(e1);\\n    }\\n    \\n    // collect odd edge nodes\\n    let odd = new Set();\\n    for(let i = 1; i <= n; i++){\\n        if(adj[i].size % 2 === 1)\\n            odd.add(i);\\n        // if odd nodes are over than 4, \\n        // that means it\\'s impossible to realize to make degrees of all Nodes even\\n        if(odd.size > 4)\\n            return false;\\n    }\\n    \\n    // Case 1\\n    if(odd.size === 2){\\n        const [n1, n2] = [...odd];\\n        for(let i = 1; i <= n; i++){\\n            if(!adj[n1].has(i) && !adj[n2].has(i))\\n                return true;\\n        }\\n    }\\n    \\n    // Case 2\\n    if(odd.size === 4){\\n        const [n1, n2, n3, n4] = [...odd];\\n        const res =  (!adj[n1].has(n2) && !adj[n3].has(n4))\\n            || (!adj[n1].has(n3) && !adj[n2].has(n4))\\n            || (!adj[n1].has(n4) && !adj[n2].has(n3));\\n        return res;\\n    }\\n    \\n    // other cases, if anyone is true, return false.\\n    // other cases: \\n    // odd count == 1 || odd count == 3 || odd count\\n    return odd.size === 0;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933325,
                "title": "java-using-indegrees-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first intuition related to the problem I had was that there are 4 cases. \\n\\n1-vertex (solution not possible)\\n2-vertex - A case we need to handle\\n3- not possible\\n4 - Need to handle\\n5+ - Not possible\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        // in degress array \\n        // 2 vertex - 1 connect them - use vertex that they both dont have a connection with;\\n        // 1 vertex - not possible \\n        // 3 vertex - not possible\\n        // 4 vertex - possible if can make 2 pairs\\n        // 5 + vertex - not possible\\n        int l = edges.size();\\n        int [] in = new int[n+1];\\n        HashSet<Integer> [] graph = new HashSet[n+1];\\n        for(int i = 0;i<=n;i++)graph[i] = new HashSet<>();\\n        // boolean [][] graph = new boolean[n+1][n+1];\\n        for(List<Integer> a:edges){\\n            int first = a.get(0);\\n            int second = a.get(1);\\n            in[first]+=1;\\n            in[second]+=1;\\n            graph[first].add(second);\\n            graph[second].add(first);\\n        }\\n\\n        int count = 0;\\n        List<Integer> odds = new ArrayList<>();\\n        for(int i = 1;i<=n;i++){\\n            if(in[i]%2!=0){\\n                odds.add(i);\\n                count++;\\n            }\\n        }\\n        if(count==0)return true;\\n        if(count%2!=0 || count>=5)return false;\\n        if(count==2){\\n            int first = odds.get(0);\\n            int second = odds.get(1);\\n            if(!graph[first].contains(second))return true;\\n            HashSet<Integer> firsts = new HashSet<>();\\n            HashSet<Integer> seconds = new HashSet<>();\\n            for(int i = 1;i<=n;i++){\\n                if(!graph[first].contains(i) && !graph[second].contains(i) && i!=first && i!=second)return true;\\n            }\\n            return false;\\n        }else{\\n            int first = odds.get(0),second = odds.get(1),third = odds.get(2),fourth = odds.get(3);\\n            if(!graph[first].contains(second) && !graph[third].contains(fourth))return true;\\n            if(!graph[first].contains(third) && !graph[second].contains(fourth))return true;\\n            if(!graph[first].contains(fourth) && !graph[second].contains(third))return true;\\n            return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        // in degress array \\n        // 2 vertex - 1 connect them - use vertex that they both dont have a connection with;\\n        // 1 vertex - not possible \\n        // 3 vertex - not possible\\n        // 4 vertex - possible if can make 2 pairs\\n        // 5 + vertex - not possible\\n        int l = edges.size();\\n        int [] in = new int[n+1];\\n        HashSet<Integer> [] graph = new HashSet[n+1];\\n        for(int i = 0;i<=n;i++)graph[i] = new HashSet<>();\\n        // boolean [][] graph = new boolean[n+1][n+1];\\n        for(List<Integer> a:edges){\\n            int first = a.get(0);\\n            int second = a.get(1);\\n            in[first]+=1;\\n            in[second]+=1;\\n            graph[first].add(second);\\n            graph[second].add(first);\\n        }\\n\\n        int count = 0;\\n        List<Integer> odds = new ArrayList<>();\\n        for(int i = 1;i<=n;i++){\\n            if(in[i]%2!=0){\\n                odds.add(i);\\n                count++;\\n            }\\n        }\\n        if(count==0)return true;\\n        if(count%2!=0 || count>=5)return false;\\n        if(count==2){\\n            int first = odds.get(0);\\n            int second = odds.get(1);\\n            if(!graph[first].contains(second))return true;\\n            HashSet<Integer> firsts = new HashSet<>();\\n            HashSet<Integer> seconds = new HashSet<>();\\n            for(int i = 1;i<=n;i++){\\n                if(!graph[first].contains(i) && !graph[second].contains(i) && i!=first && i!=second)return true;\\n            }\\n            return false;\\n        }else{\\n            int first = odds.get(0),second = odds.get(1),third = odds.get(2),fourth = odds.get(3);\\n            if(!graph[first].contains(second) && !graph[third].contains(fourth))return true;\\n            if(!graph[first].contains(third) && !graph[second].contains(fourth))return true;\\n            if(!graph[first].contains(fourth) && !graph[second].contains(third))return true;\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933016,
                "title": "c-beats-98-easy-solution-o-n-graph-traversal",
                "content": "# Intuition\\nWe have to make degrees of all nodes even. So just count the nodes with odd degrees and try to add edges to make them even.\\n__Note: We can add at max two edges. So maximum number of nodes with odd degrees should not be more than 4.\\nNote: When we add edge between two nodes, their degree changes from odd to even and vice versa. So if we cannot add only one edge to node with even degree.__\\n\\n# Approach\\n__1.  Traverse the graph and store the nodes with odd degrees.\\n2.  if count of nodes with odd degrees is greater than 4 or odd (i.e 1 or 3) return false.__\\n - if count of odd degree nodes are greater than 4, we cannot make the degree even by adding at most 2 edges.\\n- if there is only 1 node with odd degree, we can not add edge to it because it will make the degree of other node odd.\\n- if the count of odd degree node is 3, we can add an edge between 2 nodes to make their degree even, but again one node will be left and we cannot make its degree even.\\n   \\n__3. Now, if count of odd degree nodes is 2.__\\n- check if they are not connected to each other, we can add edge between them to make degrees even, so return true.\\n- else , find any node n, which is not connected to any of the two nodes, so we can add two edges to make their degree even, so return true.\\n- otherwise return false.\\n   \\n__4. if count of odd degree nodes is 4.__\\n- In this case, we cannot use any node with even degrees, because we can add atmost 2 edges, so we must have to add these 2 edges to the 4 nodes with odd degrees.\\n- check all possible connections. i.e.\\n- if we can connect\\n     1. 1-2 and 3-4\\n     2. __or__ 1-3 and 2-4\\n     3. __or__ 1-4 and 2-3\\nreturn true.\\nelse return false.\\n\\n__5. Last case no nodes with odd degrees, return true.__\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n+1];\\n        int sz=edges.size();\\n        //adjacency matrix to store graph\\n        for(int i=0;i<sz;i++) {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        //store nodes with odd degrees\\n        vector<int> odd;\\n        for(int i=1;i<=n;i++) {\\n            if(adj[i].size()%2!=0) odd.push_back(i);\\n        }\\n        sz=odd.size();\\n        if(sz!=0 && sz!=2 && sz!=4) return false;\\n        if(sz==2) {\\n            int node1 = odd[0], node2 = odd[1];\\n            //if not connected, we can add edge, so return true.\\n            if(!isConnected(node1,node2,adj)) return true;\\n\\n            //find a node which is not an adjacent of node1 and node2\\n            int node = findNode(node1, node2, adj,n);\\n            //if found a node, return true.\\n            return (node!=-1);\\n        } else if(sz==4) {\\n            int node1 = odd[0], node2 = odd[1], node3 = odd[2], node4 = odd[3];\\n            //check all possible ways to add edge\\n            return ((!isConnected(node1,node2,adj)&&!isConnected(node3,node4,adj)) || \\n              (!isConnected(node1,node3,adj)&&!isConnected(node2,node4,adj)) ||\\n              (!isConnected(node1,node4,adj)&&!isConnected(node2,node3,adj)));\\n        } else {\\n            return true;\\n        }\\n    }\\n    bool isConnected(int node1, int node2, vector<int> adj[]) {\\n        for(auto i:adj[node1]) {\\n            if(i==node2) return true;\\n        }\\n        return false;\\n    }\\n    int findNode(int node1, int node2, vector<int> adj[], int n) {\\n        vector<int> vis(n+1,0);\\n        vis[node1]=1;\\n        vis[node2]=1;\\n        for(auto i:adj[node1]) {\\n            vis[i]=1;\\n        }\\n        for(auto i:adj[node2]) {\\n            vis[i]=1;\\n        }\\n        int node=-1;\\n        for(int i=1;i<=n;i++) {\\n            if(vis[i]==0) return i;\\n        }\\n        return node;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n+1];\\n        int sz=edges.size();\\n        //adjacency matrix to store graph\\n        for(int i=0;i<sz;i++) {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        //store nodes with odd degrees\\n        vector<int> odd;\\n        for(int i=1;i<=n;i++) {\\n            if(adj[i].size()%2!=0) odd.push_back(i);\\n        }\\n        sz=odd.size();\\n        if(sz!=0 && sz!=2 && sz!=4) return false;\\n        if(sz==2) {\\n            int node1 = odd[0], node2 = odd[1];\\n            //if not connected, we can add edge, so return true.\\n            if(!isConnected(node1,node2,adj)) return true;\\n\\n            //find a node which is not an adjacent of node1 and node2\\n            int node = findNode(node1, node2, adj,n);\\n            //if found a node, return true.\\n            return (node!=-1);\\n        } else if(sz==4) {\\n            int node1 = odd[0], node2 = odd[1], node3 = odd[2], node4 = odd[3];\\n            //check all possible ways to add edge\\n            return ((!isConnected(node1,node2,adj)&&!isConnected(node3,node4,adj)) || \\n              (!isConnected(node1,node3,adj)&&!isConnected(node2,node4,adj)) ||\\n              (!isConnected(node1,node4,adj)&&!isConnected(node2,node3,adj)));\\n        } else {\\n            return true;\\n        }\\n    }\\n    bool isConnected(int node1, int node2, vector<int> adj[]) {\\n        for(auto i:adj[node1]) {\\n            if(i==node2) return true;\\n        }\\n        return false;\\n    }\\n    int findNode(int node1, int node2, vector<int> adj[], int n) {\\n        vector<int> vis(n+1,0);\\n        vis[node1]=1;\\n        vis[node2]=1;\\n        for(auto i:adj[node1]) {\\n            vis[i]=1;\\n        }\\n        for(auto i:adj[node2]) {\\n            vis[i]=1;\\n        }\\n        int node=-1;\\n        for(int i=1;i<=n;i++) {\\n            if(vis[i]==0) return i;\\n        }\\n        return node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932272,
                "title": "golang-using-hashmap",
                "content": "\\n# Code\\n```\\nfunc isPossible(n int, edges [][]int) bool {\\n\\n    odds, even := make([]int, 0), make([]int, 0)\\n\\tg := make(map[int]map[int]int)\\n\\tfor _, edge := range edges {\\n\\t\\tif _, ok := g[edge[0]]; !ok {\\n\\t\\t\\tg[edge[0]] = make(map[int]int)\\n\\t\\t}\\n\\t\\tif _, ok := g[edge[1]]; !ok {\\n\\t\\t\\tg[edge[1]] = make(map[int]int)\\n\\t\\t}\\n\\t\\tg[edge[0]][edge[1]] = 1\\n\\t\\tg[edge[1]][edge[0]] = 1\\n\\t}\\n\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tif len(g[i])%2 == 1 {\\n\\t\\t\\todds = append(odds, i)\\n\\t\\t} else {\\n\\t\\t\\teven = append(even, i)\\n\\t\\t}\\n    }\\n    size := len(odds)\\n\\tswitch {\\n\\tcase size == 1 || size == 3:\\n\\t\\treturn false\\n\\tcase size == 2:\\n\\t\\tfor _, e_n := range even {\\n\\t\\t\\tif g[e_n][odds[0]] == 0 && g[e_n][odds[1]] == 0 {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn g[odds[0]][odds[1]] == 0\\n\\tcase size == 4:\\n\\tswitch {\\n\\tcase g[odds[0]][odds[1]] == 0 && g[odds[2]][odds[3]] == 0:\\n\\t\\treturn true\\n\\tcase g[odds[0]][odds[2]] == 0 && g[odds[1]][odds[3]] == 0:\\n\\t\\treturn true\\n\\tcase g[odds[0]][odds[3]] == 0 && g[odds[1]][odds[2]] == 0:\\n\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn size == 0\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Hash Table"
                ],
                "code": "```\\nfunc isPossible(n int, edges [][]int) bool {\\n\\n    odds, even := make([]int, 0), make([]int, 0)\\n\\tg := make(map[int]map[int]int)\\n\\tfor _, edge := range edges {\\n\\t\\tif _, ok := g[edge[0]]; !ok {\\n\\t\\t\\tg[edge[0]] = make(map[int]int)\\n\\t\\t}\\n\\t\\tif _, ok := g[edge[1]]; !ok {\\n\\t\\t\\tg[edge[1]] = make(map[int]int)\\n\\t\\t}\\n\\t\\tg[edge[0]][edge[1]] = 1\\n\\t\\tg[edge[1]][edge[0]] = 1\\n\\t}\\n\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tif len(g[i])%2 == 1 {\\n\\t\\t\\todds = append(odds, i)\\n\\t\\t} else {\\n\\t\\t\\teven = append(even, i)\\n\\t\\t}\\n    }\\n    size := len(odds)\\n\\tswitch {\\n\\tcase size == 1 || size == 3:\\n\\t\\treturn false\\n\\tcase size == 2:\\n\\t\\tfor _, e_n := range even {\\n\\t\\t\\tif g[e_n][odds[0]] == 0 && g[e_n][odds[1]] == 0 {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn g[odds[0]][odds[1]] == 0\\n\\tcase size == 4:\\n\\tswitch {\\n\\tcase g[odds[0]][odds[1]] == 0 && g[odds[2]][odds[3]] == 0:\\n\\t\\treturn true\\n\\tcase g[odds[0]][odds[2]] == 0 && g[odds[1]][odds[3]] == 0:\\n\\t\\treturn true\\n\\tcase g[odds[0]][odds[3]] == 0 && g[odds[1]][odds[2]] == 0:\\n\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn size == 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2931444,
                "title": "c-0-2-4-solution",
                "content": "# Observation\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1.] If number of nodes with odd degree greater than 4 or odd\\nAns:- So the answer will be false becoz we can only add max two edge\\n\\n2.] If number of nodes with odd degree equal to 4\\nAns:- Let\\'s say that nodes are a,b,c,d so answer will true if ans only if there two pairs which dosen\\'t have any edge eg( (a,b),(c,d) => so here a and b can have edge but a and c ,a and d dosen\\'t have any edge ) like that ( (a,c),(b,d)) ( (a,d),(c,b)).\\n\\n3.] If number of nodes with odd degree 0\\nAns:- answer is always true\\n\\n4.] If number of nodes with odd degree equal to 2\\nAns:-let\\'s says that nodes are a,b if inorder of a or b is equal to n-1 i.e. we can not add any edge further se answer will be false, if there is no edge between them so answer will be true, or if some edge which dosen\\'t have any edge with a and b present anser will be true \\n\\n\\n# Complexity\\n- Time complexity: O(N) Where N is number of nodes\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(2N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSafe(vector<int> &v, set<vector<int>> &s, vector<int> adj[], int n){\\n        if(s.find({v[0],v[1]})==s.end()){\\n            if(s.find({v[2],v[3]})==s.end()){\\n                return true;\\n            }\\n        }\\n        if(s.find({v[0],v[2]})==s.end()){\\n            if(s.find({v[1],v[3]})==s.end()){\\n                return true;\\n            }\\n        }\\n        if(s.find({v[1],v[2]})==s.end()){\\n            if(s.find({v[0],v[3]})==s.end()){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool isPossible(int n, vector<vector<int>>& ed) {\\n        vector<int> inor(n,0);\\n        set<vector<int>> s;\\n        vector<int> adj[n];\\n        for(auto x:ed){\\n            inor[x[0]-1]++;\\n            inor[x[1]-1]++;\\n            adj[x[0]-1].push_back(x[1]-1);\\n            adj[x[1]-1].push_back(x[0]-1);\\n            s.insert({(x[0]-1),(x[1]-1)});\\n            s.insert({(x[1]-1),(x[0]-1)});\\n        }\\n        \\n        vector<int> v;\\n        \\n        for(int i=0;i<n;i++){\\n            if(inor[i]%2!=0){\\n                v.push_back(i);\\n            }\\n        }\\n\\n        if(v.size()>4 || v.size()%2==1){\\n            return false;\\n        }\\n        if(v.size()==0){\\n            return true;\\n        }\\n        if(v.size()==2){\\n            if(inor[v[0]]==n-1 || inor[v[1]]==n-1){\\n                return false;\\n            }\\n            if(s.find({v[0],v[1]})==s.end()){\\n                return true;\\n            }\\n            for(int i=0;i<n;i++){\\n                if(i!=v[0] && i!=v[1] && inor[i]<n-2 && s.find({i,v[0]})==s.end() && s.find({i,v[1]})==s.end()){\\n                    return true;\\n                }\\n            }\\n        }\\n        if(v.size()==4){\\n            if(isSafe(v,s,adj,n)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n//code by sachin\\n```\\n**Upvote if solution was helpful**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSafe(vector<int> &v, set<vector<int>> &s, vector<int> adj[], int n){\\n        if(s.find({v[0],v[1]})==s.end()){\\n            if(s.find({v[2],v[3]})==s.end()){\\n                return true;\\n            }\\n        }\\n        if(s.find({v[0],v[2]})==s.end()){\\n            if(s.find({v[1],v[3]})==s.end()){\\n                return true;\\n            }\\n        }\\n        if(s.find({v[1],v[2]})==s.end()){\\n            if(s.find({v[0],v[3]})==s.end()){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool isPossible(int n, vector<vector<int>>& ed) {\\n        vector<int> inor(n,0);\\n        set<vector<int>> s;\\n        vector<int> adj[n];\\n        for(auto x:ed){\\n            inor[x[0]-1]++;\\n            inor[x[1]-1]++;\\n            adj[x[0]-1].push_back(x[1]-1);\\n            adj[x[1]-1].push_back(x[0]-1);\\n            s.insert({(x[0]-1),(x[1]-1)});\\n            s.insert({(x[1]-1),(x[0]-1)});\\n        }\\n        \\n        vector<int> v;\\n        \\n        for(int i=0;i<n;i++){\\n            if(inor[i]%2!=0){\\n                v.push_back(i);\\n            }\\n        }\\n\\n        if(v.size()>4 || v.size()%2==1){\\n            return false;\\n        }\\n        if(v.size()==0){\\n            return true;\\n        }\\n        if(v.size()==2){\\n            if(inor[v[0]]==n-1 || inor[v[1]]==n-1){\\n                return false;\\n            }\\n            if(s.find({v[0],v[1]})==s.end()){\\n                return true;\\n            }\\n            for(int i=0;i<n;i++){\\n                if(i!=v[0] && i!=v[1] && inor[i]<n-2 && s.find({i,v[0]})==s.end() && s.find({i,v[1]})==s.end()){\\n                    return true;\\n                }\\n            }\\n        }\\n        if(v.size()==4){\\n            if(isSafe(v,s,adj,n)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n//code by sachin\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930820,
                "title": "logical-answer-effective-one-better-than-98-more-than-just-code",
                "content": "# Intuition\\n- **Fundamentals**\\n    1. Each edge contribute degree one to each vertices\\n    2. by adding one edge to one node we add degree+1\\n- We just need to count the number of nodes and if odd nodes is even and less less than equal to 4 then answer may be true else false.\\n\\n\\n# Approach\\nwe will the odd nodes in an array/vector \\n    1. if no of nodes==4 \\n    - we will select two nodes pair then check if there exist any two nodes such that both nodes in the pair are not connected then the answer will be True else false \\n    - there will be three pair only 4c2/2 \\n    2.if no of nodes are 2 \\n        - then of both of the odd nodes are not connected then answer will be true \\n        - else there exist a node such that both odd nodes are not connected with it then answer will be true .\\n# Complexity\\n- Time complexity:\\n $$O(V+E)$$\\n\\n- Space complexity:\\nAdd your space complexity here, e.g. $$O(E+V)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) \\n    {\\n        int count=0;\\n        vector<int>adj[n+1];\\n        for(auto &it:edges)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int>node;\\n        int nodenum=-1;\\n        for(auto &it:adj)\\n        {\\n            //..for debugging purpose...... \\n            // cout<<it.size()<<\"\\\\n\";\\n            // for(auto &ip:it)\\n            // {\\n            //     cout<<ip<<\" \";\\n            // }\\n            // cout<<\"\\\\n\";\\n            //.............................\\n            nodenum++;\\n            if (it.size()%2!=0 && it.size()!=0)\\n            {\\n                node.push_back(nodenum);\\n                count++;\\n            }\\n        //if there is complete node and has odd degree then it,s always        false,since we cannot add new node to make it even.\\n            if (it.size()==n-1 && it.size()%2!=0)\\n            {\\n                return 0;\\n            }\\n        }\\n        // cout<<count<<\"\\\\n\";\\n        // if(count==0 || count==2 || count==4)\\n        // {\\n        //     return 1;\\n        // }\\n        if (count==0)return 1;\\n        else if(count==2)\\n        {\\n            if ((find(adj[node[0]].begin(),adj[node[0]].end(),node[1]))==adj[node[0]].end())\\n            {\\n                return 1;\\n            }\\n            unordered_map<int,int>mp;\\n            for(auto &it:adj[node[0]])\\n            {\\n                mp[it]++;\\n            }\\n            for(auto &it:adj[node[1]])\\n            {\\n                mp[it]++; \\n            }\\n            for(int i=1;i<=n;i++)\\n            {\\n                if (i==node[0] || i==node[1])\\n                {\\n                    continue;\\n                }\\n                else if (mp[i]==0)\\n                {\\n                    return 1;\\n                }\\n            }\\n            return 0;\\n        }\\n        else if (count==4)\\n        {\\n            //let say pair are (a,b) ans (c,d) checking if\\n            //if there is a edge between nodes in pair.\\n            bool ans=(find(adj[node[0]].begin(),adj[node[0]].end(),node[2])==adj[node[0]].end())&& (find(adj[node[1]].begin(),adj[node[1]].end(),node[3])==adj[node[1]].end());\\n            ans|=(find(adj[node[0]].begin(),adj[node[0]].end(),node[3])==adj[node[0]].end())&& (find(adj[node[1]].begin(),adj[node[1]].end(),node[2])==adj[node[1]].end());\\n            ans|=(find(adj[node[0]].begin(),adj[node[0]].end(),node[1])==adj[node[0]].end())&& (find(adj[node[2]].begin(),adj[node[2]].end(),node[3])==adj[node[2]].end());\\n            return ans;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) \\n    {\\n        int count=0;\\n        vector<int>adj[n+1];\\n        for(auto &it:edges)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int>node;\\n        int nodenum=-1;\\n        for(auto &it:adj)\\n        {\\n            //..for debugging purpose...... \\n            // cout<<it.size()<<\"\\\\n\";\\n            // for(auto &ip:it)\\n            // {\\n            //     cout<<ip<<\" \";\\n            // }\\n            // cout<<\"\\\\n\";\\n            //.............................\\n            nodenum++;\\n            if (it.size()%2!=0 && it.size()!=0)\\n            {\\n                node.push_back(nodenum);\\n                count++;\\n            }\\n        //if there is complete node and has odd degree then it,s always        false,since we cannot add new node to make it even.\\n            if (it.size()==n-1 && it.size()%2!=0)\\n            {\\n                return 0;\\n            }\\n        }\\n        // cout<<count<<\"\\\\n\";\\n        // if(count==0 || count==2 || count==4)\\n        // {\\n        //     return 1;\\n        // }\\n        if (count==0)return 1;\\n        else if(count==2)\\n        {\\n            if ((find(adj[node[0]].begin(),adj[node[0]].end(),node[1]))==adj[node[0]].end())\\n            {\\n                return 1;\\n            }\\n            unordered_map<int,int>mp;\\n            for(auto &it:adj[node[0]])\\n            {\\n                mp[it]++;\\n            }\\n            for(auto &it:adj[node[1]])\\n            {\\n                mp[it]++; \\n            }\\n            for(int i=1;i<=n;i++)\\n            {\\n                if (i==node[0] || i==node[1])\\n                {\\n                    continue;\\n                }\\n                else if (mp[i]==0)\\n                {\\n                    return 1;\\n                }\\n            }\\n            return 0;\\n        }\\n        else if (count==4)\\n        {\\n            //let say pair are (a,b) ans (c,d) checking if\\n            //if there is a edge between nodes in pair.\\n            bool ans=(find(adj[node[0]].begin(),adj[node[0]].end(),node[2])==adj[node[0]].end())&& (find(adj[node[1]].begin(),adj[node[1]].end(),node[3])==adj[node[1]].end());\\n            ans|=(find(adj[node[0]].begin(),adj[node[0]].end(),node[3])==adj[node[0]].end())&& (find(adj[node[1]].begin(),adj[node[1]].end(),node[2])==adj[node[1]].end());\\n            ans|=(find(adj[node[0]].begin(),adj[node[0]].end(),node[1])==adj[node[0]].end())&& (find(adj[node[2]].begin(),adj[node[2]].end(),node[3])==adj[node[2]].end());\\n            return ans;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2930669,
                "title": "c-vector-of-sets-compare-odd-degree",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<set<int>>g(n);\\n        for(auto&i:edges){\\n            g[i[0]-1].insert(i[1]-1);\\n            g[i[1]-1].insert(i[0]-1);            \\n        }\\n        vector<int>odd;\\n        for(int i=0;i<n;++i)if(size(g[i])%2)odd.push_back(i);\\n        int sz=size(odd);\\n        cout<<sz<<\" \";\\n        if(sz==0) return true;\\n        else if(sz==2){\\n            for(auto&i:g)\\n                if(!i.count(odd[0])&&!i.count(odd[1])) return true;\\n            return false;\\n        }\\n        else if(sz==4) return (!g[odd[0]].count(odd[1]) && !g[odd[2]].count(odd[3]) ||\\n                               !g[odd[0]].count(odd[2]) && !g[odd[1]].count(odd[3]) ||\\n                               !g[odd[0]].count(odd[3]) && !g[odd[1]].count(odd[2]));\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<set<int>>g(n);\\n        for(auto&i:edges){\\n            g[i[0]-1].insert(i[1]-1);\\n            g[i[1]-1].insert(i[0]-1);            \\n        }\\n        vector<int>odd;\\n        for(int i=0;i<n;++i)if(size(g[i])%2)odd.push_back(i);\\n        int sz=size(odd);\\n        cout<<sz<<\" \";\\n        if(sz==0) return true;\\n        else if(sz==2){\\n            for(auto&i:g)\\n                if(!i.count(odd[0])&&!i.count(odd[1])) return true;\\n            return false;\\n        }\\n        else if(sz==4) return (!g[odd[0]].count(odd[1]) && !g[odd[2]].count(odd[3]) ||\\n                               !g[odd[0]].count(odd[2]) && !g[odd[1]].count(odd[3]) ||\\n                               !g[odd[0]].count(odd[3]) && !g[odd[1]].count(odd[2]));\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2930213,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn is_possible(n: i32, edges: Vec<Vec<i32>>) -> bool {\\n        fn check_legal(adj: &[Vec<usize>], a: usize, b: usize) -> bool {\\n            for &val in adj[a].iter() {\\n                if val == b {\\n                    return false;\\n                }\\n            }\\n            for &val in adj[b].iter() {\\n                if val == a {\\n                    return false;\\n                }\\n            }\\n            true\\n        }\\n\\n        let mut adj = vec![vec![]; n as usize + 1];\\n        let mut node_degree = vec![0; n as usize + 1];\\n\\n        for c in edges.iter() {\\n            let x = c[0] as usize;\\n            let y = c[1] as usize;\\n            adj[x].push(y);\\n            adj[y].push(x);\\n            node_degree[x] += 1;\\n            node_degree[y] += 1;\\n        }\\n\\n        let mut odd_list = vec![];\\n        for (i, &item) in node_degree.iter().enumerate().take(n as usize + 1) {\\n            if item % 2 == 1 {\\n                odd_list.push(i);\\n            }\\n        }\\n\\n        if odd_list.is_empty() {\\n            return true;\\n        } else if odd_list.len() == 2 {\\n            let a = odd_list[0];\\n            let b = odd_list[1];\\n            if check_legal(&adj, a, b) {\\n                return true;\\n            }\\n            for i in 1..=n as usize {\\n                if i == a || i == b {\\n                    continue;\\n                }\\n                if check_legal(&adj, i, a) && check_legal(&adj, i, b) {\\n                    return true;\\n                }\\n            }\\n        } else if odd_list.len() == 4 {\\n            let n1 = odd_list[0];\\n            let n2 = odd_list[1];\\n            let n3 = odd_list[2];\\n            let n4 = odd_list[3];\\n            if check_legal(&adj, n1, n2) && check_legal(&adj, n3, n4) {\\n                return true;\\n            }\\n            if check_legal(&adj, n2, n3) && check_legal(&adj, n1, n4) {\\n                return true;\\n            }\\n            if check_legal(&adj, n1, n3) && check_legal(&adj, n2, n4) {\\n                return true;\\n            }\\n        }\\n        false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn is_possible(n: i32, edges: Vec<Vec<i32>>) -> bool {\\n        fn check_legal(adj: &[Vec<usize>], a: usize, b: usize) -> bool {\\n            for &val in adj[a].iter() {\\n                if val == b {\\n                    return false;\\n                }\\n            }\\n            for &val in adj[b].iter() {\\n                if val == a {\\n                    return false;\\n                }\\n            }\\n            true\\n        }\\n\\n        let mut adj = vec![vec![]; n as usize + 1];\\n        let mut node_degree = vec![0; n as usize + 1];\\n\\n        for c in edges.iter() {\\n            let x = c[0] as usize;\\n            let y = c[1] as usize;\\n            adj[x].push(y);\\n            adj[y].push(x);\\n            node_degree[x] += 1;\\n            node_degree[y] += 1;\\n        }\\n\\n        let mut odd_list = vec![];\\n        for (i, &item) in node_degree.iter().enumerate().take(n as usize + 1) {\\n            if item % 2 == 1 {\\n                odd_list.push(i);\\n            }\\n        }\\n\\n        if odd_list.is_empty() {\\n            return true;\\n        } else if odd_list.len() == 2 {\\n            let a = odd_list[0];\\n            let b = odd_list[1];\\n            if check_legal(&adj, a, b) {\\n                return true;\\n            }\\n            for i in 1..=n as usize {\\n                if i == a || i == b {\\n                    continue;\\n                }\\n                if check_legal(&adj, i, a) && check_legal(&adj, i, b) {\\n                    return true;\\n                }\\n            }\\n        } else if odd_list.len() == 4 {\\n            let n1 = odd_list[0];\\n            let n2 = odd_list[1];\\n            let n3 = odd_list[2];\\n            let n4 = odd_list[3];\\n            if check_legal(&adj, n1, n2) && check_legal(&adj, n3, n4) {\\n                return true;\\n            }\\n            if check_legal(&adj, n2, n3) && check_legal(&adj, n1, n4) {\\n                return true;\\n            }\\n            if check_legal(&adj, n1, n3) && check_legal(&adj, n2, n4) {\\n                return true;\\n            }\\n        }\\n        false\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2930120,
                "title": "observations",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We can add at most two edges which can contributes at most 4 degrees.\\n2. if there are nodes with odd degrees, we add one edge for it will makes its degree even.\\n3. Problem requires no repeated edge for neighbours, so we have to check paris to make sure they dont already have edge between them.\\n\\n\\n### Situations\\n1. if all nodes have even degree, we just return true\\n2. if there is more than 5 nodes with odd degree, we just return false (cannot use at most 2 edges to contribute to more than 4 degrees)\\n3. it is impossible there exist just one odd node(!!!!)\\n\\n\\nSo, we just check 2 odd-degree nodes and 4 odd-degree nodes.\\n\\n#### 2 odd-degree nodes\\nif 2 nodes with odd degrees, there will be two situations\\n\\n- connect node a and node b directly if they are not neighbors\\n\\n![image.png](https://assets.leetcode.com/users/images/024887e7-3671-4661-874c-7cf57baef469_1671495384.0969968.png)\\n\\n\\n\\n- Find node c which is not neighbour of a and b, connect a<->c and b<->c\\n\\n![image.png](https://assets.leetcode.com/users/images/aed3a8b2-5e8f-44a4-8c46-d855e9cb65c7_1671495264.8224058.png)\\n\\n\\n#### 4 odd-degree nodes\\n\\nif there are 4 nodes with odd degrees, it means **we can only add edges among these nodes**, because all degrees should be assign to those nodes exclusively.\\n\\nSo only when there exist two pairs which are not neighbours nodes, there will be possible.\\n\\n![image.png](https://assets.leetcode.com/users/images/666f9907-fd0d-49aa-a6b3-99b8c04f6d31_1671495694.424625.png)\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        // 1 ~ n\\n        vector<unordered_set<int>> G(n + 1);\\n        for (auto &edge: edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            G[u].insert(v);\\n            G[v].insert(u);\\n        }\\n\\n        auto isNeighbour = [&](int a, int b) {\\n            // since it is undirected graph, we dont have to check b->a\\n            return G[a].count(b);\\n        };\\n\\n        // now, check how many node with odd degree\\n        vector<int> odds;\\n        for (int i = 1; i <= n; i++) {\\n            if (G[i].size() % 2 != 0) {\\n                odds.push_back(i);\\n            }\\n        }\\n\\n        // if there are 2 nodes with odd degree, we can add an edge between the two nodes\\n        // u <-> v\\n        if (odds.size() == 2) {            \\n            // can add edge a<->b\\n            int a = odds[0], b = odds[1];\\n            if (!isNeighbour(a, b)) {\\n                return true;\\n            }\\n\\n            // there exists node i where a and b are not its neighbour\\n            for (int c = 1; c <= n; c++) {\\n                if (c != a && c != b && !isNeighbour(c, a) && !isNeighbour(c, b)) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n\\n        if (odds.size() == 4) {\\n            int a = odds[0], b = odds[1], c = odds[2], d = odds[3];\\n            // we can connect (a <-> b) & (c <-> d),   (a <-> c) & (b <-> d), (a <-> d) & (c <-> b)\\n            // if these nodes are not neighbour, since we cannot add repeated edges.\\n            if ((!isNeighbour(a, b) && !isNeighbour(c, d))\\n            ||  (!isNeighbour(a, c) && !isNeighbour(b, d))\\n            ||  (!isNeighbour(a, d) && !isNeighbour(b, c))) {\\n                return true;\\n            }\\n            return false;\\n        }\\n\\n        return odds.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        // 1 ~ n\\n        vector<unordered_set<int>> G(n + 1);\\n        for (auto &edge: edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            G[u].insert(v);\\n            G[v].insert(u);\\n        }\\n\\n        auto isNeighbour = [&](int a, int b) {\\n            // since it is undirected graph, we dont have to check b->a\\n            return G[a].count(b);\\n        };\\n\\n        // now, check how many node with odd degree\\n        vector<int> odds;\\n        for (int i = 1; i <= n; i++) {\\n            if (G[i].size() % 2 != 0) {\\n                odds.push_back(i);\\n            }\\n        }\\n\\n        // if there are 2 nodes with odd degree, we can add an edge between the two nodes\\n        // u <-> v\\n        if (odds.size() == 2) {            \\n            // can add edge a<->b\\n            int a = odds[0], b = odds[1];\\n            if (!isNeighbour(a, b)) {\\n                return true;\\n            }\\n\\n            // there exists node i where a and b are not its neighbour\\n            for (int c = 1; c <= n; c++) {\\n                if (c != a && c != b && !isNeighbour(c, a) && !isNeighbour(c, b)) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n\\n        if (odds.size() == 4) {\\n            int a = odds[0], b = odds[1], c = odds[2], d = odds[3];\\n            // we can connect (a <-> b) & (c <-> d),   (a <-> c) & (b <-> d), (a <-> d) & (c <-> b)\\n            // if these nodes are not neighbour, since we cannot add repeated edges.\\n            if ((!isNeighbour(a, b) && !isNeighbour(c, d))\\n            ||  (!isNeighbour(a, c) && !isNeighbour(b, d))\\n            ||  (!isNeighbour(a, d) && !isNeighbour(b, c))) {\\n                return true;\\n            }\\n            return false;\\n        }\\n\\n        return odds.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929731,
                "title": "time-o-n-len-edges-memory-o-n-n-description",
                "content": "# Intuition\\n\\nThe idea is to find all nodes with odd count of edges and try to understand if these nodes can have even count of edges by adding 0-2 edges. So, all nodes should have even count of edges after changes.\\n\\n# Algorithm\\n\\n1. Arrange a set for each node with connected nodes (`sets` array).\\n2. Find all nodes with odd count of edges (`oddSets` array)\\n3. Check the length of `oddSets` array\\n    - the length is 0, there is nothing to fix, all the nodes have even count of edges\\n    - the length is 2, try to find out if we can connect them to each other by adding 1 edge or if we can connect both of them to some other node by adding 2 edges\\n    - the length is 4, we have 3 combinations for 4 nodes by 2 nodes to check. Do the same as for length 2 case (see above) for each pair. So, we try to connect 1 with 2 node and 3 with 4 node, then 1 with 3 and 2 with 4, then 1 with 4 and 2 wth 3. (Agree, looks ugly)\\n4. There is a function `tryConnet` which find out if we can add 1 or 2 edges and connect provided nodes\\n    - if nodes doesn\\'t have a common edge, we can connect them with 1 new edge\\n    - if nodes have a common edge, we try to find the other node which doesn\\'t have common edges with both of them\\n    - return the count of edges we need to connect provided nodes (I see 10 for impossible case) as a function resul\\n5. We know how many edges we need to solve it and compares to 2.\\n\\n*Note 1:*\\nIf there are more then 4 nodes with odd count of edges we cannot make these nodes have even count of edges with adding only 2 nodes. Not enough edges.\\n*Note 2:*\\nIf there are odd numbers of nodes with odd count of edges we cannot do that too. One node will always have an odd count of endges.\\n\\n# Complexity\\n- Time complexity: O(n + len(edges))\\n\\n- Space complexity: O(n*n)\\n\\n# Code\\n```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        sets = [set() for _ in range(n)]\\n        for edge in edges:\\n            sets[edge[0] - 1].add(edge[1] - 1)\\n            sets[edge[1] - 1].add(edge[0] - 1)\\n        oddSets = []\\n        for i, s in enumerate(sets):\\n            if len(s) % 2 == 1:\\n                oddSets.append([i, s])\\n        if len(oddSets) == 0:\\n            return True\\n        elif len(oddSets) == 2:\\n            return self.tryConnet(oddSets[0], oddSets[1], sets) <= 2\\n        elif len(oddSets) == 4:\\n            return (self.tryConnet(oddSets[0], oddSets[1], sets) + self.tryConnet(oddSets[2], oddSets[3],\\n                                                                                  sets) <= 2) or (\\n                    self.tryConnet(oddSets[0], oddSets[2], sets) + self.tryConnet(oddSets[1], oddSets[3],\\n                                                                                  sets) <= 2) or (\\n                    self.tryConnet(oddSets[0], oddSets[3], sets) + self.tryConnet(oddSets[1], oddSets[2], sets) <= 2)\\n        else:\\n            return False\\n\\n    def tryConnet(self, oddSet1: [], oddSet2: [], sets: []) -> int:\\n        if oddSet1[0] not in oddSet2[1]:\\n            return 1\\n        for i, s in enumerate(sets):\\n            if oddSet1[0] == i or oddSet2[0] == i:\\n                continue\\n            if oddSet1[0] not in s and oddSet2[0] not in s:\\n                return 2\\n        return 10\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        sets = [set() for _ in range(n)]\\n        for edge in edges:\\n            sets[edge[0] - 1].add(edge[1] - 1)\\n            sets[edge[1] - 1].add(edge[0] - 1)\\n        oddSets = []\\n        for i, s in enumerate(sets):\\n            if len(s) % 2 == 1:\\n                oddSets.append([i, s])\\n        if len(oddSets) == 0:\\n            return True\\n        elif len(oddSets) == 2:\\n            return self.tryConnet(oddSets[0], oddSets[1], sets) <= 2\\n        elif len(oddSets) == 4:\\n            return (self.tryConnet(oddSets[0], oddSets[1], sets) + self.tryConnet(oddSets[2], oddSets[3],\\n                                                                                  sets) <= 2) or (\\n                    self.tryConnet(oddSets[0], oddSets[2], sets) + self.tryConnet(oddSets[1], oddSets[3],\\n                                                                                  sets) <= 2) or (\\n                    self.tryConnet(oddSets[0], oddSets[3], sets) + self.tryConnet(oddSets[1], oddSets[2], sets) <= 2)\\n        else:\\n            return False\\n\\n    def tryConnet(self, oddSet1: [], oddSet2: [], sets: []) -> int:\\n        if oddSet1[0] not in oddSet2[1]:\\n            return 1\\n        for i, s in enumerate(sets):\\n            if oddSet1[0] == i or oddSet2[0] == i:\\n                continue\\n            if oddSet1[0] not in s and oddSet2[0] not in s:\\n                return 2\\n        return 10\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929482,
                "title": "simple-c-graph-solution-with-detailed-explanation",
                "content": "# Intuition\\nThe main observation is that we have been given at most two edges we can add. So for ans = true how many max odd nodes we can fix? 4 right, since one edges contributes to 2 odd fixes hence two edges will contribute 4 odd fixes. (under best case)\\n\\nNumber of nodes with Odd degree that can be made even:\\n0, 2, 4.\\n\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo we solve for each case individually.\\n\\n1. if its 0 then all nodes are with even degree hence ans = true.\\n2. if its 2, then two sub cases arise, \\n    if both the odd nodes are not connected we can join them directly and make their degree even hence true.\\n    if both are already connected with each other, we need to find other third node (out of all n) which is not connected with both and make their degree even. if it can be found then ans = true, else false.\\n3. if its 4, then since we can find other third node (as it will cost more than 2 edges) so we just check if any of the combination of all four we can connect with each other, if so ans = true, else false.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*logN) can be reduced to O(N) using maps.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool hasEdge(set<pair<int,int>> &connected, int node1, int node2){\\n        if(connected.find({node1, node2}) == connected.end()) return false;            \\n        else return true;\\n    }\\n\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        set<pair<int,int>> connected;\\n        vector<int> degree(n+1, 0);\\n        for(auto edge: edges){\\n            int node1 = edge[0], node2 = edge[1];\\n            degree[node1]++, degree[node2]++;\\n            connected.insert({node1, node2});\\n            connected.insert({node2, node1});\\n        }\\n\\n        vector<int> oddDegNodes;\\n        for(int i=1;i<n+1;i++){\\n            if(degree[i] % 2 != 0) \\n                oddDegNodes.push_back(i);\\n        }\\n        \\n        //cases: 0,2,4\\n        int oddNodes = oddDegNodes.size();\\n        if(oddNodes == 0) return true;\\n        else if(oddNodes == 2){\\n            int node1 = oddDegNodes[0];\\n            int node2 = oddDegNodes[1];\\n            if(!hasEdge(connected, node1, node2)) \\n                return true;\\n\\n            //find a even degree node which is not connected with both of them:\\n            for(int i=1;i<n+1;i++){\\n                if(i == node1 or i == node2) continue;\\n                else if(!hasEdge(connected, i, node1) and !hasEdge(connected, i, node2)) return true;\\n            }\\n\\n            return false;\\n        }\\n        else if(oddNodes == 4){\\n            int a = oddDegNodes[0];\\n            int b = oddDegNodes[1];\\n            int c = oddDegNodes[2];\\n            int d = oddDegNodes[3];\\n\\n            //try connecting all fours with each other in all combinations:\\n            bool op1 = !hasEdge(connected, a, b) and !hasEdge(connected, c, d);\\n            bool op2 = !hasEdge(connected, a, c) and !hasEdge(connected, b, d);\\n            bool op3 = !hasEdge(connected, a, d) and !hasEdge(connected, b, c);\\n\\n            return op1 or op2 or op3;\\n        }\\n        else return false;\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool hasEdge(set<pair<int,int>> &connected, int node1, int node2){\\n        if(connected.find({node1, node2}) == connected.end()) return false;            \\n        else return true;\\n    }\\n\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        set<pair<int,int>> connected;\\n        vector<int> degree(n+1, 0);\\n        for(auto edge: edges){\\n            int node1 = edge[0], node2 = edge[1];\\n            degree[node1]++, degree[node2]++;\\n            connected.insert({node1, node2});\\n            connected.insert({node2, node1});\\n        }\\n\\n        vector<int> oddDegNodes;\\n        for(int i=1;i<n+1;i++){\\n            if(degree[i] % 2 != 0) \\n                oddDegNodes.push_back(i);\\n        }\\n        \\n        //cases: 0,2,4\\n        int oddNodes = oddDegNodes.size();\\n        if(oddNodes == 0) return true;\\n        else if(oddNodes == 2){\\n            int node1 = oddDegNodes[0];\\n            int node2 = oddDegNodes[1];\\n            if(!hasEdge(connected, node1, node2)) \\n                return true;\\n\\n            //find a even degree node which is not connected with both of them:\\n            for(int i=1;i<n+1;i++){\\n                if(i == node1 or i == node2) continue;\\n                else if(!hasEdge(connected, i, node1) and !hasEdge(connected, i, node2)) return true;\\n            }\\n\\n            return false;\\n        }\\n        else if(oddNodes == 4){\\n            int a = oddDegNodes[0];\\n            int b = oddDegNodes[1];\\n            int c = oddDegNodes[2];\\n            int d = oddDegNodes[3];\\n\\n            //try connecting all fours with each other in all combinations:\\n            bool op1 = !hasEdge(connected, a, b) and !hasEdge(connected, c, d);\\n            bool op2 = !hasEdge(connected, a, c) and !hasEdge(connected, b, d);\\n            bool op3 = !hasEdge(connected, a, d) and !hasEdge(connected, b, c);\\n\\n            return op1 or op2 or op3;\\n        }\\n        else return false;\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929474,
                "title": "c-solution-clean-code-all-cases-handled",
                "content": "\\n\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        //1 based indexing, adj list\\n        vector<unordered_set<int>> adj(n+1);\\n        \\n        for (auto x : edges){\\n            int u = x[0];\\n            int v = x[1];\\n            adj[u].insert(v);\\n            adj[v].insert(u);\\n        }\\n        \\n        int ctr = 0;\\n        \\n        //storing the nodes with odd degree\\n        vector<int> v;\\n        for (int i=1 ; i<=n ; i++){\\n            if (adj[i].size()%2 != 0){\\n                v.push_back(i);\\n            }\\n        }\\n        \\n        //no. of odd degree nodes can\\'t be more than 4\\n        if (v.size() > 4) return false;\\n        \\n        unordered_set<int> s;\\n        for (int i=0 ; i<v.size() ; i++){\\n            for (int j=i+1 ; j<v.size() ; j++){\\n                if (s.find(v[i])==s.end() and s.find(v[j])==s.end() and adj[v[i]].find(v[j]) == adj[v[i]].end()){\\n                    s.insert(v[i]);\\n                    s.insert(v[j]);\\n                    ctr++;\\n                }\\n            }\\n        }\\n        \\n        //special case\\n        if (v.size() == 2){\\n            if (s.size() == 0){\\n                for (int i=1 ; i<=n ; i++){\\n                    if (i!=v[0] and i!=v[1] and adj[v[0]].find(i) == adj[v[0]].end() and adj[v[1]].find(i) == adj[v[1]].end()){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if (v.size() == s.size()) return true;\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "\\n\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        //1 based indexing, adj list\\n        vector<unordered_set<int>> adj(n+1);\\n        \\n        for (auto x : edges){\\n            int u = x[0];\\n            int v = x[1];\\n            adj[u].insert(v);\\n            adj[v].insert(u);\\n        }\\n        \\n        int ctr = 0;\\n        \\n        //storing the nodes with odd degree\\n        vector<int> v;\\n        for (int i=1 ; i<=n ; i++){\\n            if (adj[i].size()%2 != 0){\\n                v.push_back(i);\\n            }\\n        }\\n        \\n        //no. of odd degree nodes can\\'t be more than 4\\n        if (v.size() > 4) return false;\\n        \\n        unordered_set<int> s;\\n        for (int i=0 ; i<v.size() ; i++){\\n            for (int j=i+1 ; j<v.size() ; j++){\\n                if (s.find(v[i])==s.end() and s.find(v[j])==s.end() and adj[v[i]].find(v[j]) == adj[v[i]].end()){\\n                    s.insert(v[i]);\\n                    s.insert(v[j]);\\n                    ctr++;\\n                }\\n            }\\n        }\\n        \\n        //special case\\n        if (v.size() == 2){\\n            if (s.size() == 0){\\n                for (int i=1 ; i<=n ; i++){\\n                    if (i!=v[0] and i!=v[1] and adj[v[0]].find(i) == adj[v[0]].end() and adj[v[1]].find(i) == adj[v[1]].end()){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if (v.size() == s.size()) return true;\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2928654,
                "title": "simple-fully-commented-used-very-beginner-s-friendly-language-to-explain",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(max(N , E)) , N = no. of nodes , E = no. of edges\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(max(N , E)) [comparision b/w \"odd\" vector and \"adj\"]\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// just commented sol of @votrubac in my way \\narticle link : \"https://leetcode.com/problems/add-edges-to-make-degrees-of-all-nodes-even/solutions/2923531/adjacency-list-of-hashsets/?orderBy=most_votes\" \\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n\\n        /*\\n        here we have used \"unordered_set\" inside \"vector\"\\n        so that i can use \"count()\" method\\n        */\\n        vector<unordered_set<int>> adj(n+1);\\n        for(auto e:edges){\\n            adj[e[0]].insert(e[1]);\\n            adj[e[1]].insert(e[0]);\\n        }\\n\\n        // storing all odd nodes\\n        vector<int> odd;\\n        for(int i=0; i<n+1; i++){\\n            if(adj[i].size()%2) odd.push_back(i);\\n        }\\n\\n        // if there is no odd degree node\\n        if(odd.size() == 0) return true;\\n\\n        /*\\n        if there is 2 odd degree node then\\n        - option 1 : \\n        connect both of them if they are not connected already\\n\\n        - option 2 : \\n        find any node to which both of then is not\\n        connected directly and connect both of them to that\\n        node\\n        */\\n        if(odd.size() == 2){\\n            for(int i=1; i<n+1; i++){\\n\\n                // \"adj[odd[0]].count(i) == 0\" is equivelent to \"!adj[odd[0]].count(i)\"\\n                if(!adj[odd[0]].count(i) &&\\n                         !adj[odd[1]].count(i)){\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        /*\\n        if there are 4 odd degree node then\\n        check all the below cases if any case is possible\\n        then true otherwise false\\n        */\\n        if(odd.size() == 4){\\n            return (!adj[odd[0]].count(odd[1]) && !adj[odd[2]].count(odd[3])) ||\\n             (!adj[odd[0]].count(odd[2]) && !adj[odd[1]].count(odd[3])) ||\\n             (!adj[odd[0]].count(odd[3]) && !adj[odd[1]].count(odd[2]));\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\n// just commented sol of @votrubac in my way \\narticle link : \"https://leetcode.com/problems/add-edges-to-make-degrees-of-all-nodes-even/solutions/2923531/adjacency-list-of-hashsets/?orderBy=most_votes\" \\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n\\n        /*\\n        here we have used \"unordered_set\" inside \"vector\"\\n        so that i can use \"count()\" method\\n        */\\n        vector<unordered_set<int>> adj(n+1);\\n        for(auto e:edges){\\n            adj[e[0]].insert(e[1]);\\n            adj[e[1]].insert(e[0]);\\n        }\\n\\n        // storing all odd nodes\\n        vector<int> odd;\\n        for(int i=0; i<n+1; i++){\\n            if(adj[i].size()%2) odd.push_back(i);\\n        }\\n\\n        // if there is no odd degree node\\n        if(odd.size() == 0) return true;\\n\\n        /*\\n        if there is 2 odd degree node then\\n        - option 1 : \\n        connect both of them if they are not connected already\\n\\n        - option 2 : \\n        find any node to which both of then is not\\n        connected directly and connect both of them to that\\n        node\\n        */\\n        if(odd.size() == 2){\\n            for(int i=1; i<n+1; i++){\\n\\n                // \"adj[odd[0]].count(i) == 0\" is equivelent to \"!adj[odd[0]].count(i)\"\\n                if(!adj[odd[0]].count(i) &&\\n                         !adj[odd[1]].count(i)){\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        /*\\n        if there are 4 odd degree node then\\n        check all the below cases if any case is possible\\n        then true otherwise false\\n        */\\n        if(odd.size() == 4){\\n            return (!adj[odd[0]].count(odd[1]) && !adj[odd[2]].count(odd[3])) ||\\n             (!adj[odd[0]].count(odd[2]) && !adj[odd[1]].count(odd[3])) ||\\n             (!adj[odd[0]].count(odd[3]) && !adj[odd[1]].count(odd[2]));\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928548,
                "title": "add-edges-to-make-degrees-of-all-nodes-even-first-solution-post-hope-it-helps",
                "content": "# Intuition\\nSum of Two odd numbers is even. So try to connect odd degree edges with the other odd degree edge and how the addition of extra edges do not disturb the pre-existing even degree edges.\\n\\n# Approach\\nDivide the problem in Smaller Problems.\\n\\n1. Draw graph from the given edges.\\n2. Find deg of each node.\\n3. Store Each odd deg node in a Vector or List.\\n4. Now there can be 5 cases \\n    1. There is no odd degree edge than return true.\\n    2. There is **only one odd degree edge** or number of **odd degree edge is greater than 4** than return false. We can see that **more than 4 edges require greater than 2 edges** which is out of constraints to this problem and one odd degree to any even degree create the even degree to odd as **odd + even = odd**.\\n    3. There is **2 odd degree edge**. In this case **either one can combine the edges with each other** or **combine the 2 with one of the rest to which both of them are not connected to**.\\n   4. There are **3 odd degree edge**. In this case there is **only one possibility is to make a pair of two and connect to the other one**.\\n   5. Last case if there are **4 odd degree edges**. The **only way to connect is to make two-two pair** meaning out of four connect one two with each other and the other two with each other respectively.\\n\\n\\n**Else in all other cases return false.**\\n\\n\\n\\n# Complexity\\n- Time complexity: O(nlog(n)) *connect method + isPossible*.\\n\\n- Space complexity: O(n) in worst case which can be reduced in this solution by return false if the vector size becomes greater than 4.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool connect(vector<int>& oddDegEdges, unordered_map<int, vector<int>>& adj) {\\n        if(oddDegEdges.size() == 2) {\\n            if(find(adj[oddDegEdges[0]].begin(), adj[oddDegEdges[0]].end(), oddDegEdges[1]) == adj[oddDegEdges[0]].end()) {\\n                return true;\\n            }\\n\\n            for(auto edge: adj) {\\n                auto f = find(edge.second.begin(), edge.second.end(), oddDegEdges[0]);\\n                auto s = find(edge.second.begin(), edge.second.end(), oddDegEdges[1]);\\n\\n                if(f == edge.second.end() and s == edge.second.end()) {\\n                    return true;\\n                }\\n            }\\n\\n            return false;            \\n        }\\n        else if(oddDegEdges.size() == 3) {\\n            int f = oddDegEdges[0];\\n            int s = oddDegEdges[1];\\n            int t = oddDegEdges[2];\\n            \\n            if(find(adj[f].begin(), adj[f].end(), s) == adj[f].end() and find(adj[f].begin(), adj[f].end(), t) == adj[f].end()) {\\n                return true;\\n            }\\n            if(find(adj[s].begin(), adj[s].end(), f) == adj[s].end() and find(adj[s].begin(), adj[s].end(), t) == adj[f].end()) {\\n                return true;\\n            }\\n            if(find(adj[t].begin(), adj[t].end(), f) == adj[t].end() and find(adj[t].begin(), adj[t].end(), s) == adj[f].end()) {\\n                return true;\\n            }\\n            \\n            \\n            return false;\\n        }\\n        else {\\n            int ft = oddDegEdges[0];\\n            int sd = oddDegEdges[1];\\n            int td = oddDegEdges[2];\\n            int fh = oddDegEdges[3];\\n            \\n            if(find(adj[ft].begin(), adj[ft].end(), sd) == adj[ft].end() and find(adj[td].begin(), adj[td].end(), fh) == adj[td].end()) {\\n                return true;\\n            }\\n            \\n            if(find(adj[ft].begin(), adj[ft].end(), td) == adj[ft].end() and find(adj[sd].begin(), adj[sd].end(), fh) == adj[sd].end()) {\\n                return true;\\n            }\\n            \\n            if(find(adj[ft].begin(), adj[ft].end(), fh) == adj[ft].end() and find(adj[sd].begin(), adj[sd].end(), td) == adj[sd].end()) {\\n                return true;\\n            }\\n            \\n            return false;\\n        }\\n    }\\n    \\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        unordered_map<int, vector<int>> adj;\\n        unordered_map<int, int> deg;\\n        \\n        for(int i=0; i<edges.size(); i++) {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n            \\n            deg[edges[i][0]]++;\\n            deg[edges[i][1]]++;\\n        }\\n        \\n        vector<int> oddDegEdges;\\n        \\n        for(auto x: deg) {\\n            if(x.second % 2 != 0) {\\n                oddDegEdges.push_back(x.first);\\n            }\\n        }  \\n        \\n        if(oddDegEdges.size() == 0){\\n            return true;\\n        }\\n        \\n        if(oddDegEdges.size() == 1 or oddDegEdges.size() > 4) {\\n            return false;\\n        } \\n        else if(oddDegEdges.size() == 2) {\\n            if(connect(oddDegEdges, adj)) {\\n                return true;\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n        else if(oddDegEdges.size() == 3) {\\n            if(connect(oddDegEdges, adj)) {\\n                return true;\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n        else {\\n            if(connect(oddDegEdges, adj)) {\\n                return true;\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool connect(vector<int>& oddDegEdges, unordered_map<int, vector<int>>& adj) {\\n        if(oddDegEdges.size() == 2) {\\n            if(find(adj[oddDegEdges[0]].begin(), adj[oddDegEdges[0]].end(), oddDegEdges[1]) == adj[oddDegEdges[0]].end()) {\\n                return true;\\n            }\\n\\n            for(auto edge: adj) {\\n                auto f = find(edge.second.begin(), edge.second.end(), oddDegEdges[0]);\\n                auto s = find(edge.second.begin(), edge.second.end(), oddDegEdges[1]);\\n\\n                if(f == edge.second.end() and s == edge.second.end()) {\\n                    return true;\\n                }\\n            }\\n\\n            return false;            \\n        }\\n        else if(oddDegEdges.size() == 3) {\\n            int f = oddDegEdges[0];\\n            int s = oddDegEdges[1];\\n            int t = oddDegEdges[2];\\n            \\n            if(find(adj[f].begin(), adj[f].end(), s) == adj[f].end() and find(adj[f].begin(), adj[f].end(), t) == adj[f].end()) {\\n                return true;\\n            }\\n            if(find(adj[s].begin(), adj[s].end(), f) == adj[s].end() and find(adj[s].begin(), adj[s].end(), t) == adj[f].end()) {\\n                return true;\\n            }\\n            if(find(adj[t].begin(), adj[t].end(), f) == adj[t].end() and find(adj[t].begin(), adj[t].end(), s) == adj[f].end()) {\\n                return true;\\n            }\\n            \\n            \\n            return false;\\n        }\\n        else {\\n            int ft = oddDegEdges[0];\\n            int sd = oddDegEdges[1];\\n            int td = oddDegEdges[2];\\n            int fh = oddDegEdges[3];\\n            \\n            if(find(adj[ft].begin(), adj[ft].end(), sd) == adj[ft].end() and find(adj[td].begin(), adj[td].end(), fh) == adj[td].end()) {\\n                return true;\\n            }\\n            \\n            if(find(adj[ft].begin(), adj[ft].end(), td) == adj[ft].end() and find(adj[sd].begin(), adj[sd].end(), fh) == adj[sd].end()) {\\n                return true;\\n            }\\n            \\n            if(find(adj[ft].begin(), adj[ft].end(), fh) == adj[ft].end() and find(adj[sd].begin(), adj[sd].end(), td) == adj[sd].end()) {\\n                return true;\\n            }\\n            \\n            return false;\\n        }\\n    }\\n    \\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        unordered_map<int, vector<int>> adj;\\n        unordered_map<int, int> deg;\\n        \\n        for(int i=0; i<edges.size(); i++) {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n            \\n            deg[edges[i][0]]++;\\n            deg[edges[i][1]]++;\\n        }\\n        \\n        vector<int> oddDegEdges;\\n        \\n        for(auto x: deg) {\\n            if(x.second % 2 != 0) {\\n                oddDegEdges.push_back(x.first);\\n            }\\n        }  \\n        \\n        if(oddDegEdges.size() == 0){\\n            return true;\\n        }\\n        \\n        if(oddDegEdges.size() == 1 or oddDegEdges.size() > 4) {\\n            return false;\\n        } \\n        else if(oddDegEdges.size() == 2) {\\n            if(connect(oddDegEdges, adj)) {\\n                return true;\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n        else if(oddDegEdges.size() == 3) {\\n            if(connect(oddDegEdges, adj)) {\\n                return true;\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n        else {\\n            if(connect(oddDegEdges, adj)) {\\n                return true;\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928043,
                "title": "c-checking-for-all-cases-of-2-and-4-odd-degree-nodes",
                "content": "With some observation it is quite clear that there are 4 cases for this question :-\\n1) If degree of all the nodes present are even\\n2) if degree of 2 nodes are odd.\\n3) if degree of 4 nodes are odd\\n4) if number of odd degree nodes is greater than 4 then it is not possible to make it even by adding 2 edges\\n\\nCase 1 - Answer is always true.\\nCase 2 - There are 3 subcases for this case. They are -\\n\\n\\ta) when both the odd degree nodes are not neighbours (mentioned in question there shouldn\\'t be  any repeated edges) of each other its possible to add an edge between a and b.\\n\\tb) when they are neighbours to each other we have to find a even degree node which isn\\'t a      neighbour of both of them and connect them with it by adding two edges, so even degree node           remains even and with addition of single edge the both odd degree becomes even.\\n\\tc) if both the above cases fails then answer is always false.\\n\\t\\nCase 3 - There are 2 subcases for this case. They are -\\n\\n\\ta) when all four or atleast two odd degree nodes are not neighbours of each other then it is possible to connect them with the help of 2 edges making them  even.\\n\\tb) if the above subcase fails then it is not possible to make it even.\\n\\t\\nCase 4 - Answer is always false.\\n\\nC++\\n```\\nclass Solution {\\n    // checks if there is a edge between a and b\\n    bool check(vector<vector<int>> &g, int a, int b) {\\n        for(auto it : g[a]) {\\n            if(it == b) return 0;\\n        }\\n        return 1;\\n    }\\n    // checks if there is a edge between either node and a or node and b\\n    // i.e node-----a or node-----b\\n    bool check(vector<vector<int>> &g, int a, int b, int node) {\\n        for(auto it : g[node]) {\\n            if(it == a || it == b) return 0;\\n        }\\n        return 1;\\n    }\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> deg(n + 1);\\n        vector<vector<int>> g(n + 1);\\n        for(auto &edge : edges) {\\n            // degree of each node\\n            deg[edge[0]]++;\\n            deg[edge[1]]++;\\n            // making graph matrix for given edges\\n            g[edge[0]].push_back(edge[1]);\\n            g[edge[1]].push_back(edge[0]);\\n        }\\n        vector<int> odd, even;\\n        for(int i = 1; i <= n; ++i) {\\n            if(deg[i] % 2) odd.push_back(i); //odd degree nodes\\n            else even.push_back(i); // even degree nodes\\n        }\\n        if(odd.size() == 0) return 1;\\n        if(odd.size() == 2) {\\n            //Checks if we can connect the both odd degree nodes\\n            if(check(g, odd[0], odd[1])) return 1;\\n            // checks if we can connect both odd degree nodes to any of the even degree nodes\\n            for(auto node : even) {\\n                if(check(g, odd[0], odd[1], node)) return 1;\\n            }\\n        }\\n        if(odd.size() == 4) {\\n            // checks if there exists a way to add two edge between all the 4 odd degree nodes\\n            if((check(g, odd[0], odd[1]) && check(g, odd[2], odd[3])) || (check(g, odd[0], odd[2]) && check(g, odd[1], odd[3])) || (check(g, odd[0], odd[3]) && check(g, odd[2], odd[1]))) return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\nSC - O(n + m) (graph matrix) + O(n) (degree vector) + O(n) (odd + even degree vector)\\nTC - O(n + m) + O(n) + (2 * O(m) || 4 * O(m))\\nn - nodes, m = edges\\n\\nPlease upvote if it helps.",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    // checks if there is a edge between a and b\\n    bool check(vector<vector<int>> &g, int a, int b) {\\n        for(auto it : g[a]) {\\n            if(it == b) return 0;\\n        }\\n        return 1;\\n    }\\n    // checks if there is a edge between either node and a or node and b\\n    // i.e node-----a or node-----b\\n    bool check(vector<vector<int>> &g, int a, int b, int node) {\\n        for(auto it : g[node]) {\\n            if(it == a || it == b) return 0;\\n        }\\n        return 1;\\n    }\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> deg(n + 1);\\n        vector<vector<int>> g(n + 1);\\n        for(auto &edge : edges) {\\n            // degree of each node\\n            deg[edge[0]]++;\\n            deg[edge[1]]++;\\n            // making graph matrix for given edges\\n            g[edge[0]].push_back(edge[1]);\\n            g[edge[1]].push_back(edge[0]);\\n        }\\n        vector<int> odd, even;\\n        for(int i = 1; i <= n; ++i) {\\n            if(deg[i] % 2) odd.push_back(i); //odd degree nodes\\n            else even.push_back(i); // even degree nodes\\n        }\\n        if(odd.size() == 0) return 1;\\n        if(odd.size() == 2) {\\n            //Checks if we can connect the both odd degree nodes\\n            if(check(g, odd[0], odd[1])) return 1;\\n            // checks if we can connect both odd degree nodes to any of the even degree nodes\\n            for(auto node : even) {\\n                if(check(g, odd[0], odd[1], node)) return 1;\\n            }\\n        }\\n        if(odd.size() == 4) {\\n            // checks if there exists a way to add two edge between all the 4 odd degree nodes\\n            if((check(g, odd[0], odd[1]) && check(g, odd[2], odd[3])) || (check(g, odd[0], odd[2]) && check(g, odd[1], odd[3])) || (check(g, odd[0], odd[3]) && check(g, odd[2], odd[1]))) return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927829,
                "title": "very-simple-explanation-with-visualization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing hashing of edges and simple graph properties\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn this sum, we can see that we are allowed to add new at most 2 edges in the graph. That means, we can at most make 4 vertices with odd degree as even degree by adding 2 edges between them.\\nSo basically firstly, we have to calculate the degree of each vertex in the graph.\\nAfter we calculate the degree of each vertex, we need to calculate the number of vertices in the graph having odd degree and also we find the vertices having odd degree in the seperate vector \"nodes\".\\n\\nNow we know that if we have odd number of vertices having odd degrees then we can never make the degree of all the vertices even in the graph. **( This is one of the concept we will be using )**\\nAlso previously we discussed that we can never satisfy the condition if more than 4 vertices have odd degree. **( Due the constraint of adding only 2 more new edges in the graph )**\\n\\nSo we come the conclusion that we can only handle situations where the graph contains only 0 or 2 or 4 vertices with odd degrees.\\nSo if graph contains 0 vertices with odd degree, we don\\'t need to perform any operation because graph already satisfies the required condition.\\nSuppose the graph contains 2 vertices with odd degree.So in this case we can think that we can simply return true because we can draw 1 edge connecting both the vertices having odd degree.But that is not the case always because it is possible that there is already an edge existing between them like this -\\n\\n![Screenshot (435).png](https://assets.leetcode.com/users/images/24a3920c-36e7-4ac0-8085-2a8512204987_1671438832.844358.png)\\n( In above graph bothe nodes 1 and 11 have odd degree and we can\\'t make them even by drawing edges between them as it is already existing )\\nSo here we see that still we can make this graph even degree if we had some node x in the graph already with even degree. In such case, we would have made an edge between 1,x and x,11. This would have not changed even the evenness of node x and would have made degree of 1 and 11 also even.\\nFor eg - \\n \\n![Screenshot (436).png](https://assets.leetcode.com/users/images/c1535916-7217-42ba-9ac7-34268c0de630_1671439388.9025428.png)\\nHere we can see that the blue edges can be drawn between the 1 to y and 11 to y making 1 and 11 even degree and also maintaing the even ness of node y.\\nSo basically we need to chack that there exist some node with even degree in the graph.\\nSo if there exists then return true else return false.\\n\\nNow in the case of 4 vertices with odd degree. we cannot have such case because we need to make 4 vertices even means we have to utilise the two edges to join directly. We cannot have the case as that of the 2 vertices because in case of 2 vertices we had one extra choice of adding edge.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> degree(n+1,0);\\n        map<pair<int,int>,int> m;\\n\\n        for(int i=0;i<edges.size();i++){\\n            degree[edges[i][0]]++;\\n            degree[edges[i][1]]++;\\n            m[{edges[i][0],edges[i][1]}]++;\\n            m[{edges[i][1],edges[i][0]}]++;\\n        }\\n        int odds=0;\\n        vector<int> nodes;\\n        for(int i=1;i<=n;i++){\\n            if(degree[i]%2){\\n                odds++;\\n                nodes.push_back(i);\\n            }\\n        }\\n        if(odds>4 || odds%2){\\n            return false;\\n        }\\n        else{\\n            if(nodes.size()==0){\\n                return true;\\n            }\\n            else if(nodes.size()==2){\\n                if(m[{nodes[0],nodes[1]}]){\\n                    for(int i=1;i<=n;i++){\\n                        if(i!=nodes[0] && i!=nodes[1] && m[{nodes[0],i}]==0 && m[{nodes[1],i}]==0){\\n                            return true;\\n                        }\\n                    }\\n                    return false;\\n                }\\n                else{\\n                    return true;\\n                }\\n            }\\n            else{\\n                if(m[{nodes[0],nodes[1]}]==0 && m[{nodes[2],nodes[3]}]==0){\\n                    return true;\\n                }\\n                else if(m[{nodes[0],nodes[2]}]==0 && m[{nodes[1],nodes[3]}]==0){\\n                    return true;\\n                }\\n                else if(m[{nodes[0],nodes[3]}]==0 && m[{nodes[1],nodes[2]}]==0){\\n                    return true;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> degree(n+1,0);\\n        map<pair<int,int>,int> m;\\n\\n        for(int i=0;i<edges.size();i++){\\n            degree[edges[i][0]]++;\\n            degree[edges[i][1]]++;\\n            m[{edges[i][0],edges[i][1]}]++;\\n            m[{edges[i][1],edges[i][0]}]++;\\n        }\\n        int odds=0;\\n        vector<int> nodes;\\n        for(int i=1;i<=n;i++){\\n            if(degree[i]%2){\\n                odds++;\\n                nodes.push_back(i);\\n            }\\n        }\\n        if(odds>4 || odds%2){\\n            return false;\\n        }\\n        else{\\n            if(nodes.size()==0){\\n                return true;\\n            }\\n            else if(nodes.size()==2){\\n                if(m[{nodes[0],nodes[1]}]){\\n                    for(int i=1;i<=n;i++){\\n                        if(i!=nodes[0] && i!=nodes[1] && m[{nodes[0],i}]==0 && m[{nodes[1],i}]==0){\\n                            return true;\\n                        }\\n                    }\\n                    return false;\\n                }\\n                else{\\n                    return true;\\n                }\\n            }\\n            else{\\n                if(m[{nodes[0],nodes[1]}]==0 && m[{nodes[2],nodes[3]}]==0){\\n                    return true;\\n                }\\n                else if(m[{nodes[0],nodes[2]}]==0 && m[{nodes[1],nodes[3]}]==0){\\n                    return true;\\n                }\\n                else if(m[{nodes[0],nodes[3]}]==0 && m[{nodes[1],nodes[2]}]==0){\\n                    return true;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927657,
                "title": "c-easy-understanding-adjacency-list-of-sets",
                "content": "\\n* Find all the nodes which have odd degree.\\n* For more than 4 nodes we can\\'t make all nodes even degree with 2 edges.\\n* Now , there can be 0 , 2 or 4 nodes with odd degrees.(odd number of nodes can\\'t be possible).\\n* For 0 nodes all nodes have even degrees.\\n* For 2 nodes a, b: \\n\\t* We can add one edge if edge between that two nodes a--b doesn\\'t exist.\\n\\t* We can add two edges if for a node there don\\'t exists edges from the node to both nodes a,b.\\n* For 4 nodes a,b,c,d : \\n\\t* We just have to check we we can add edges a-b,c-d or a-c,b-d or a-d,b-c. if those edges dosn\\'t exist in graph we can add them.\\n\\t* For checking edge exist or not we can make adjacency list of sets.\\n\\n**Time : O(n)\\nSpace : O(n)**\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges){\\n        vector<unordered_set<int> > adj(n+1);\\n        for(auto &ele:edges){\\n            int u = ele[0],v = ele[1];\\n            adj[u].insert(v);\\n            adj[v].insert(u);\\n        }\\n        vector<int> odds;\\n        for(int i=1;i<=n;i++){\\n            if(adj[i].size()&1){\\n                odds.push_back(i);\\n            }\\n        }\\n        if(odds.size()==0) return true;\\n        else if(odds.size()==2){\\n            int a = odds[0],b = odds[1];\\n            // check if a-b exist or not;\\n            if(!adj[a].count(b) || !adj[b].count(a)){\\n                return true;\\n            }\\n            // check if there exists a node from which we can add edges a-node , b-node;\\n            for(int i=1;i<=n;i++){\\n                if(!adj[i].count(a) and !adj[i].count(b)){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        else if(odds.size()==4){\\n            int a = odds[0],b = odds[1],c = odds[2],d = odds[3];\\n            // check if we can add edges a-b,c-d, a-c,b-d or a-d,b-c;\\n            if((!adj[a].count(b) and !adj[c].count(d)) or (!adj[a].count(c) and !adj[b].count(d)) or (!adj[a].count(d) and !adj[b].count(c))) return true;\\n            return false;\\n        }\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges){\\n        vector<unordered_set<int> > adj(n+1);\\n        for(auto &ele:edges){\\n            int u = ele[0],v = ele[1];\\n            adj[u].insert(v);\\n            adj[v].insert(u);\\n        }\\n        vector<int> odds;\\n        for(int i=1;i<=n;i++){\\n            if(adj[i].size()&1){\\n                odds.push_back(i);\\n            }\\n        }\\n        if(odds.size()==0) return true;\\n        else if(odds.size()==2){\\n            int a = odds[0],b = odds[1];\\n            // check if a-b exist or not;\\n            if(!adj[a].count(b) || !adj[b].count(a)){\\n                return true;\\n            }\\n            // check if there exists a node from which we can add edges a-node , b-node;\\n            for(int i=1;i<=n;i++){\\n                if(!adj[i].count(a) and !adj[i].count(b)){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        else if(odds.size()==4){\\n            int a = odds[0],b = odds[1],c = odds[2],d = odds[3];\\n            // check if we can add edges a-b,c-d, a-c,b-d or a-d,b-c;\\n            if((!adj[a].count(b) and !adj[c].count(d)) or (!adj[a].count(c) and !adj[b].count(d)) or (!adj[a].count(d) and !adj[b].count(c))) return true;\\n            return false;\\n        }\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927376,
                "title": "easy-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& e) \\n    {\\n        \\n        vector<int>deg(n+1,0);\\n        map<pair<int,int>,int>mp;\\n       for(int i=0;i<e.size();i++)\\n       {\\n           deg[e[i][0]]++;\\n           deg[e[i][1]]++;\\n           mp[{e[i][0],e[i][1]}]++;\\n           mp[{e[i][1],e[i][0]}]++;\\n       }\\n\\n       int odd=0;\\n       vector<int>v; \\n       for(int i=1;i<=n;i++)\\n       if(deg[i]%2)\\n       odd++,v.push_back(i);\\n\\n        if(odd==0)\\n        return true;\\n        if(odd==2)\\n        {\\n            if(deg[v[0]]==n-1||deg[v[1]]==n-1)\\n            return false;\\n\\n            return true;\\n        }\\n\\n        if(odd==4)\\n        {\\n            int dp[3][4]={{1,2,3,4},{1,3,2,4},{1,4,2,3}};\\n\\n            for(int i=0;i<3;i++)\\n            {\\n            if(!mp[{v[dp[i][0]-1],v[dp[i][1]-1]}]&&!mp[{v[dp[i][2]-1],v[dp[i][3]-1]}])\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n\\n        return false;\\n\\n        \\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& e) \\n    {\\n        \\n        vector<int>deg(n+1,0);\\n        map<pair<int,int>,int>mp;\\n       for(int i=0;i<e.size();i++)\\n       {\\n           deg[e[i][0]]++;\\n           deg[e[i][1]]++;\\n           mp[{e[i][0],e[i][1]}]++;\\n           mp[{e[i][1],e[i][0]}]++;\\n       }\\n\\n       int odd=0;\\n       vector<int>v; \\n       for(int i=1;i<=n;i++)\\n       if(deg[i]%2)\\n       odd++,v.push_back(i);\\n\\n        if(odd==0)\\n        return true;\\n        if(odd==2)\\n        {\\n            if(deg[v[0]]==n-1||deg[v[1]]==n-1)\\n            return false;\\n\\n            return true;\\n        }\\n\\n        if(odd==4)\\n        {\\n            int dp[3][4]={{1,2,3,4},{1,3,2,4},{1,4,2,3}};\\n\\n            for(int i=0;i<3;i++)\\n            {\\n            if(!mp[{v[dp[i][0]-1],v[dp[i][1]-1]}]&&!mp[{v[dp[i][2]-1],v[dp[i][3]-1]}])\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n\\n        return false;\\n\\n        \\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2926406,
                "title": "c-explanation-with-diagram-made-it-easy-simple-learning",
                "content": "# Intuition\\nDeduce the number of odd degree nodes. Then produce answer on the basis of suitable conditions for 2 and 4 odd nodes. \\n\\n# Approach\\nWe will build the graph and create a list of nodes with odd degree.\\n- If the number of odd nodes exceeds 4 then it won\\'t be possible to connect them using only 2 edges[as per the constraints given in problem]\\n- If the number of nodes is odd i.e. 1 or 3, then it wont be possible for us to establish a connection satifsying the given criteria i.e. all nodes should have even degree.\\n- Check point no. 4 in below image for count equals 2 and 4\\n\\n![rsz_12508.jpg](https://assets.leetcode.com/users/images/3f357e23-530d-4c7d-8c04-ed496bc10f4c_1671390998.8412478.jpeg)\\n\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$ \\n\\n- Space complexity:\\n $$O(n)$$\\n\\n\\uD83D\\uDE4F Please show some support if you liked this explanation\\nHappy coding \\uD83D\\uDE07\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,unordered_set<int>> g;\\n        for(auto& e : edges){\\n            g[e[0]].insert(e[1]);\\n            g[e[1]].insert(e[0]);\\n        }\\n\\n        vector<int> odd;\\n        for(int i = 1; i<=n && odd.size() < 5; i++){\\n            if(g[i].size() % 2 == 1){\\n                odd.push_back(i);\\n            }\\n        }\\n\\n        if(odd.size() == 0)     // no odd degree nodes found at all\\n            return true;\\n        if(odd.size()%2 == 1 || odd.size() > 4){    // eliminate 1,3 and >4\\n            return false;\\n        }\\n\\n        if(odd.size() == 2){\\n            int a = odd[0];\\n            int b = odd[1];\\n            bool cond1 = (g[a].find(b) == g[a].end()); \\n            if(cond1){\\n                return true;\\n            }\\n\\n            bool cond2 = false;\\n            for(int i = 1; i<=n ; i++){\\n                // create a---c---b when c is not connected to any of the 2 nodes.\\n                if(i!=a && i!=b && g[a].find(i)==g[a].end() && g[b].find(i)==g[b].end()){\\n                    cond2 = true;\\n                    break;\\n                }\\n            }\\n            return cond2;\\n        }\\n\\n        if(odd.size() == 4){\\n            int a = odd[0];\\n            int b = odd[1];\\n            int c = odd[2];\\n            int d = odd[3];\\n\\n            // check a--b and c--d\\n            bool cond1 = (g[a].find(b) == g[a].end() && g[c].find(d) == g[c].end());\\n            if(cond1)   return true;\\n\\n            // check a--c and b--d\\n            bool cond2 = (g[a].find(c) == g[a].end() && g[b].find(d) == g[b].end());\\n            if(cond2)   return true;\\n\\n            // check a--d and b--c\\n            bool cond3 = (g[a].find(d) == g[a].end() && g[b].find(c) == g[b].end());\\n            if(cond3)   return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,unordered_set<int>> g;\\n        for(auto& e : edges){\\n            g[e[0]].insert(e[1]);\\n            g[e[1]].insert(e[0]);\\n        }\\n\\n        vector<int> odd;\\n        for(int i = 1; i<=n && odd.size() < 5; i++){\\n            if(g[i].size() % 2 == 1){\\n                odd.push_back(i);\\n            }\\n        }\\n\\n        if(odd.size() == 0)     // no odd degree nodes found at all\\n            return true;\\n        if(odd.size()%2 == 1 || odd.size() > 4){    // eliminate 1,3 and >4\\n            return false;\\n        }\\n\\n        if(odd.size() == 2){\\n            int a = odd[0];\\n            int b = odd[1];\\n            bool cond1 = (g[a].find(b) == g[a].end()); \\n            if(cond1){\\n                return true;\\n            }\\n\\n            bool cond2 = false;\\n            for(int i = 1; i<=n ; i++){\\n                // create a---c---b when c is not connected to any of the 2 nodes.\\n                if(i!=a && i!=b && g[a].find(i)==g[a].end() && g[b].find(i)==g[b].end()){\\n                    cond2 = true;\\n                    break;\\n                }\\n            }\\n            return cond2;\\n        }\\n\\n        if(odd.size() == 4){\\n            int a = odd[0];\\n            int b = odd[1];\\n            int c = odd[2];\\n            int d = odd[3];\\n\\n            // check a--b and c--d\\n            bool cond1 = (g[a].find(b) == g[a].end() && g[c].find(d) == g[c].end());\\n            if(cond1)   return true;\\n\\n            // check a--c and b--d\\n            bool cond2 = (g[a].find(c) == g[a].end() && g[b].find(d) == g[b].end());\\n            if(cond2)   return true;\\n\\n            // check a--d and b--c\\n            bool cond3 = (g[a].find(d) == g[a].end() && g[b].find(c) == g[b].end());\\n            if(cond3)   return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925881,
                "title": "python3-dictionary-of-sets-permutations-of-4-items",
                "content": "We prepare a dictionary of sets `g`, where `g[i]` is set of the notes connected with the node `i`.\\n\\nWe have to inspect nodes with odd number of edges. We store them in the array `odds`.\\n\\nWe have to return `True` only if we have `zero`, `2` or `4` item in the array `odds`.\\n\\nWe check if it is possible to add at most 2 edges and return `True`.\\n\\n\\n# Code\\n```\\nfrom itertools import permutations\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        g={i:set() for i in range(1,n+1)}\\n        for a,b in edges:\\n            g[a].add(b)\\n            g[b].add(a)\\n        odds=[i for i in range(1,n+1) if len(g[i])%2]\\n        if not odds: return True\\n        if 4<len(odds): return False\\n        if any(len(g[i])==n-1 for i in odds): return False\\n        if len(odds)==2:\\n            if g[odds[0]] not in g[odds[1]]:\\n                return True\\n            else:\\n                if len(g[odds[0]].union(g[odds[1]])) < n:\\n                    return True\\n                else:\\n                    return False\\n        elif len(odds)==4:\\n            for a,b,c,d in permutations(odds):\\n                if (a not in g[b]) and (c not in g[d]): return True\\n                if (a not in g[c]) and (b not in g[d]): return True\\n                if (a not in g[d]) and (b not in g[c]): return True\\n        return False       \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom itertools import permutations\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        g={i:set() for i in range(1,n+1)}\\n        for a,b in edges:\\n            g[a].add(b)\\n            g[b].add(a)\\n        odds=[i for i in range(1,n+1) if len(g[i])%2]\\n        if not odds: return True\\n        if 4<len(odds): return False\\n        if any(len(g[i])==n-1 for i in odds): return False\\n        if len(odds)==2:\\n            if g[odds[0]] not in g[odds[1]]:\\n                return True\\n            else:\\n                if len(g[odds[0]].union(g[odds[1]])) < n:\\n                    return True\\n                else:\\n                    return False\\n        elif len(odds)==4:\\n            for a,b,c,d in permutations(odds):\\n                if (a not in g[b]) and (c not in g[d]): return True\\n                if (a not in g[c]) and (b not in g[d]): return True\\n                if (a not in g[d]) and (b not in g[c]): return True\\n        return False       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925812,
                "title": "simple-solution-adjacency-list-of-hashset-java",
                "content": "```\\nclass Solution\\n{\\n    public boolean isPossible(int n, List<List<Integer>> edges) \\n    {\\n        HashSet<Integer>[] graph = new HashSet[n+1];\\n        for(int i = 0;i<n+1;i++) graph[i] = new HashSet<>();\\n        int[]deg = new int[n+1];\\n        for(List<Integer> ele : edges){\\n            deg[ele.get(0)]++;\\n            deg[ele.get(1)]++;\\n            graph[ele.get(0)].add(ele.get(1));\\n            graph[ele.get(1)].add(ele.get(0));\\n        }\\n        \\n        HashSet<Integer> oddDeg = new HashSet<>();\\n        HashSet<Integer> evenDeg = new HashSet<>();\\n        for(int i = 1;i<deg.length;i++) {\\n            if(deg[i]%2 == 1) oddDeg.add(i);\\n            else evenDeg.add(i);\\n        }\\n        int itr = 2;\\n        while(itr-- > 0)\\n        {\\n            int first = -1;\\n            for(int ele : oddDeg){\\n                first = ele;\\n                break;\\n            }\\n            if(first == -1) break;\\n            \\n            oddDeg.remove(first);\\n            int second = -1;\\n\\n            for(int ele : oddDeg)\\n            {\\n                if(!graph[first].contains(ele)){\\n                    second = ele;\\n                    oddDeg.remove(second);\\n                    evenDeg.add(first);\\n                    evenDeg.add(second);\\n                    break;\\n                }\\n            }\\n\\n            if(second == -1)\\n            {\\n                for(int ele : evenDeg)\\n                {\\n                    if(!graph[first].contains(ele)){\\n                        second = ele;\\n                        oddDeg.add(second);\\n                        evenDeg.add(first);\\n                        break;\\n                    }\\n                }\\n            }\\n            if(second == -1)\\n            {\\n                oddDeg.add(first);\\n            }\\n            // System.out.println(oddDeg.toString());\\n            // System.out.println(evenDeg.toString());\\n        }\\n        return oddDeg.size() == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution\\n{\\n    public boolean isPossible(int n, List<List<Integer>> edges) \\n    {\\n        HashSet<Integer>[] graph = new HashSet[n+1];\\n        for(int i = 0;i<n+1;i++) graph[i] = new HashSet<>();\\n        int[]deg = new int[n+1];\\n        for(List<Integer> ele : edges){\\n            deg[ele.get(0)]++;\\n            deg[ele.get(1)]++;\\n            graph[ele.get(0)].add(ele.get(1));\\n            graph[ele.get(1)].add(ele.get(0));\\n        }\\n        \\n        HashSet<Integer> oddDeg = new HashSet<>();\\n        HashSet<Integer> evenDeg = new HashSet<>();\\n        for(int i = 1;i<deg.length;i++) {\\n            if(deg[i]%2 == 1) oddDeg.add(i);\\n            else evenDeg.add(i);\\n        }\\n        int itr = 2;\\n        while(itr-- > 0)\\n        {\\n            int first = -1;\\n            for(int ele : oddDeg){\\n                first = ele;\\n                break;\\n            }\\n            if(first == -1) break;\\n            \\n            oddDeg.remove(first);\\n            int second = -1;\\n\\n            for(int ele : oddDeg)\\n            {\\n                if(!graph[first].contains(ele)){\\n                    second = ele;\\n                    oddDeg.remove(second);\\n                    evenDeg.add(first);\\n                    evenDeg.add(second);\\n                    break;\\n                }\\n            }\\n\\n            if(second == -1)\\n            {\\n                for(int ele : evenDeg)\\n                {\\n                    if(!graph[first].contains(ele)){\\n                        second = ele;\\n                        oddDeg.add(second);\\n                        evenDeg.add(first);\\n                        break;\\n                    }\\n                }\\n            }\\n            if(second == -1)\\n            {\\n                oddDeg.add(first);\\n            }\\n            // System.out.println(oddDeg.toString());\\n            // System.out.println(evenDeg.toString());\\n        }\\n        return oddDeg.size() == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925772,
                "title": "python-3-rule-based-approach",
                "content": "```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        \\n        deg = [0] * n\\n        g = defaultdict(set)\\n        \\n        for a, b in edges:\\n            a -= 1\\n            b -= 1\\n            g[a].add(b)\\n            g[b].add(a)\\n            deg[a] += 1\\n            deg[b] += 1\\n        \\n        \\n        cnt = []\\n        for i in range(n):\\n            if deg[i] % 2 == 0: continue\\n            if len(g[i]) < n - 1:\\n                cnt.append(i)\\n                # can\\'t add two edges with number of nodes > 4\\n                if len(cnt) > 4: return False\\n            else:\\n                return False\\n        \\n        # can\\'t add two edges with odd number of nodes\\n        if len(cnt) % 2: return False\\n        # if four nodes, then must be a way to connect pairwise within these nodes\\n        if len(cnt) == 4:\\n            for i in range(len(cnt)):\\n                for j in range(i):\\n                    if cnt[i] not in g[cnt[j]]:\\n                        k, v = [x for x in range(4) if x != i and x != j]\\n                        if cnt[k] not in g[cnt[v]]: return True\\n            return False\\n        \\n        return True",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        \\n        deg = [0] * n\\n        g = defaultdict(set)\\n        \\n        for a, b in edges:\\n            a -= 1\\n            b -= 1\\n            g[a].add(b)\\n            g[b].add(a)\\n            deg[a] += 1\\n            deg[b] += 1\\n        \\n        \\n        cnt = []\\n        for i in range(n):\\n            if deg[i] % 2 == 0: continue\\n            if len(g[i]) < n - 1:\\n                cnt.append(i)\\n                # can\\'t add two edges with number of nodes > 4\\n                if len(cnt) > 4: return False\\n            else:\\n                return False\\n        \\n        # can\\'t add two edges with odd number of nodes\\n        if len(cnt) % 2: return False\\n        # if four nodes, then must be a way to connect pairwise within these nodes\\n        if len(cnt) == 4:\\n            for i in range(len(cnt)):\\n                for j in range(i):\\n                    if cnt[i] not in g[cnt[j]]:\\n                        k, v = [x for x in range(4) if x != i and x != j]\\n                        if cnt[k] not in g[cnt[v]]: return True\\n            return False\\n        \\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 2925768,
                "title": "c-explanation-readable-code-hash-map-set",
                "content": "# Intuition\\nTry all possible combination\\n\\n# Approach\\nUse `unordered_map<int, unordered_set<int>>` to represent the graph\\nTwo vertex are possible to add a new edge if they are not connected yet (cannot find in the adjacent set).\\nThere are only three possible scenario s.t. is possible to add at most 2 edges:\\n- 0 odd vertex => always true\\n- 2 odd vertex\\n    - try to find any vertex that has not connect to these 2 odd vertex yet\\n- 4 odd vertex\\n    - try all three grouping combination (two groups to link edge)\\n        - e.g. n0 link to n1 and n2 link to n3;\\n        - (n0, n2) + (n1, n3)\\n        - (n0, n3) + (n1, n2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, unordered_set<int>> graph;\\n    vector<int> nodes; // the odd vertex\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        for(const auto& edge: edges) {\\n            graph[edge[0]].insert(edge[1]);\\n            graph[edge[1]].insert(edge[0]);\\n        }\\n        for (const auto& [k, v]: graph) { \\n            // add odd vertex into `nodes`\\n            if ((int) v.size() % 2) {\\n                nodes.push_back(k);\\n            }\\n        }\\n        int cnt = (int) nodes.size();\\n        if (cnt == 2) {\\n            int n0 = nodes[0], n1 = nodes[1];\\n            for (int i = 1; i <= n; i++) {\\n                // find any vertex that have not connect to these two odd vertexes yet\\n                if (noEdge(i, n0) && noEdge(i, n1)) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        if (cnt == 4) {\\n            int n0 = nodes[0], n1 = nodes[1], n2 = nodes[2], n3 = nodes[3];\\n            // try all three grouping combination e.g. n0<->n1 + n2<->n3\\n            return (noEdge(n0, n1) && noEdge(n2, n3)) || \\n                   (noEdge(n0, n2) && noEdge(n1, n3)) || \\n                   (noEdge(n0, n3) && noEdge(n1, n2));\\n        }\\n        return cnt == 0;\\n    }\\n    bool noEdge(int i, int j) {\\n        return !graph[i].count(j);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, unordered_set<int>> graph;\\n    vector<int> nodes; // the odd vertex\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        for(const auto& edge: edges) {\\n            graph[edge[0]].insert(edge[1]);\\n            graph[edge[1]].insert(edge[0]);\\n        }\\n        for (const auto& [k, v]: graph) { \\n            // add odd vertex into `nodes`\\n            if ((int) v.size() % 2) {\\n                nodes.push_back(k);\\n            }\\n        }\\n        int cnt = (int) nodes.size();\\n        if (cnt == 2) {\\n            int n0 = nodes[0], n1 = nodes[1];\\n            for (int i = 1; i <= n; i++) {\\n                // find any vertex that have not connect to these two odd vertexes yet\\n                if (noEdge(i, n0) && noEdge(i, n1)) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        if (cnt == 4) {\\n            int n0 = nodes[0], n1 = nodes[1], n2 = nodes[2], n3 = nodes[3];\\n            // try all three grouping combination e.g. n0<->n1 + n2<->n3\\n            return (noEdge(n0, n1) && noEdge(n2, n3)) || \\n                   (noEdge(n0, n2) && noEdge(n1, n3)) || \\n                   (noEdge(n0, n3) && noEdge(n1, n2));\\n        }\\n        return cnt == 0;\\n    }\\n    bool noEdge(int i, int j) {\\n        return !graph[i].count(j);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925665,
                "title": "easy-code-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& ed) {\\n        vector<int> adj[n];\\n        for(auto it :ed ){\\n            adj[it[0]-1].push_back(it[1]-1);\\n            adj[it[1]-1].push_back(it[0]-1);\\n        }\\n        vector<int> st;\\n        int zero = 0;\\n        for(int i =0;i <n;i++){\\n            if( adj[i].size()%2 !=0 ){\\n                if(adj[i].size() != n-1)\\n                {\\n                    st.push_back(i);\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n     \\n        }\\n        \\n        if(st.size() == 0)return true;\\n\\n        if(st.size() == 2){\\n            int a = st[0],b = st[1];\\n            if(find(adj[a].begin(),adj[a].end(),b) != adj[a].end()){\\n                for(int i = 0;i<n;i++){\\n                    if(find(adj[i].begin(),adj[i].end(),a) == adj[i].end() && find(adj[i].begin(),adj[i].end(),b) == adj[i].end()){\\n                        return true;\\n                    }\\n                }\\n                return false;\\n            }\\n            return true;\\n        }\\n\\n        if(st.size() == 4){\\n            int count = 2;\\n            unordered_map<int,bool> vis;\\n            for(int i = 0;i<4;i++){\\n                for(int j = i+1;j<4;j++){\\n                    if(!vis[st[i]] && !vis[st[j]] && find( adj[st[i]].begin(),adj[st[i]].end(),st[j]) == adj[st[i]].end()){\\n                        vis[st[i]] = true;\\n                        vis[st[j]] = true;\\n                        count--;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(count == 0)return true;\\n            return false;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& ed) {\\n        vector<int> adj[n];\\n        for(auto it :ed ){\\n            adj[it[0]-1].push_back(it[1]-1);\\n            adj[it[1]-1].push_back(it[0]-1);\\n        }\\n        vector<int> st;\\n        int zero = 0;\\n        for(int i =0;i <n;i++){\\n            if( adj[i].size()%2 !=0 ){\\n                if(adj[i].size() != n-1)\\n                {\\n                    st.push_back(i);\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n     \\n        }\\n        \\n        if(st.size() == 0)return true;\\n\\n        if(st.size() == 2){\\n            int a = st[0],b = st[1];\\n            if(find(adj[a].begin(),adj[a].end(),b) != adj[a].end()){\\n                for(int i = 0;i<n;i++){\\n                    if(find(adj[i].begin(),adj[i].end(),a) == adj[i].end() && find(adj[i].begin(),adj[i].end(),b) == adj[i].end()){\\n                        return true;\\n                    }\\n                }\\n                return false;\\n            }\\n            return true;\\n        }\\n\\n        if(st.size() == 4){\\n            int count = 2;\\n            unordered_map<int,bool> vis;\\n            for(int i = 0;i<4;i++){\\n                for(int j = i+1;j<4;j++){\\n                    if(!vis[st[i]] && !vis[st[j]] && find( adj[st[i]].begin(),adj[st[i]].end(),st[j]) == adj[st[i]].end()){\\n                        vis[st[i]] = true;\\n                        vis[st[j]] = true;\\n                        count--;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(count == 0)return true;\\n            return false;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925550,
                "title": "c-check-conditions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have several coditions to check. Firts of all evident ones:\\n\\n1. If we have no odd nodes we can return `true` immediately\\n2. If we have too many (more than 4) odd nodes, return `false`\\n3. If we have odd number of odd nodes (1 or 3), return `false`\\n\\nIf we have **2** odd nodes (`a` and `b`) we can try:\\n\\n1. Connect them with an edge if they are not connected and return `true`\\n2. If `a` and `b` connected, we can try to find node `c` which is not connected with both `a` and `b` then add `a - c` and `b - c` edges.\\n\\nIf none of the way is possible, return `false`\\n\\nIf we have **4** odd nodes (`a`, `b`, `c` and `d`) we can check these three possible connections:\\n\\n1. `a - b`, `c - d`\\n2. `a - c`, `b - d`\\n3. `a - d`, `b - c`\\n\\nIf none of these connections is possible, return `false` \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBuild graph as adjacency list and check the conditions\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n``O(n)``\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n``O(n)``\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool IsPossible(int n, IList<IList<int>> edges) {\\n        Dictionary<int, HashSet<int>> graph = Enumerable\\n            .Range(1, n)\\n            .ToDictionary(index => index, index => new HashSet<int>());\\n\\n        foreach (var edge in edges) {\\n            int e1 = edge[0];\\n            int e2 = edge[1]; \\n\\n            graph[e1].Add(e2);\\n            graph[e2].Add(e1);\\n        }   \\n\\n        int[] odds = graph\\n          .Where(pair => pair.Value.Count % 2 != 0)\\n          .Select(pair => pair.Key)\\n          .ToArray();\\n\\n        if (odds.Length == 0)\\n           return true;\\n        if (odds.Length > 4 || odds.Length % 2 != 0)\\n           return false;\\n\\n        if (odds.Length == 2) {\\n            int aa = odds[0];\\n            int bb = odds[1];\\n\\n            if (!graph[aa].Contains(bb))\\n                return true;\\n\\n            return graph\\n                .Where(pair => pair.Key != aa && pair.Key != bb)\\n                .Any(pair => !pair.Value.Contains(aa) && !pair.Value.Contains(bb));\\n        }\\n           \\n        int a = odds[0];\\n        int b = odds[1];\\n        int c = odds[2];\\n        int d = odds[3];\\n\\n        return !graph[a].Contains(b) && !graph[c].Contains(d) ||\\n               !graph[a].Contains(c) && !graph[b].Contains(d) ||\\n               !graph[a].Contains(d) && !graph[b].Contains(c);    \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsPossible(int n, IList<IList<int>> edges) {\\n        Dictionary<int, HashSet<int>> graph = Enumerable\\n            .Range(1, n)\\n            .ToDictionary(index => index, index => new HashSet<int>());\\n\\n        foreach (var edge in edges) {\\n            int e1 = edge[0];\\n            int e2 = edge[1]; \\n\\n            graph[e1].Add(e2);\\n            graph[e2].Add(e1);\\n        }   \\n\\n        int[] odds = graph\\n          .Where(pair => pair.Value.Count % 2 != 0)\\n          .Select(pair => pair.Key)\\n          .ToArray();\\n\\n        if (odds.Length == 0)\\n           return true;\\n        if (odds.Length > 4 || odds.Length % 2 != 0)\\n           return false;\\n\\n        if (odds.Length == 2) {\\n            int aa = odds[0];\\n            int bb = odds[1];\\n\\n            if (!graph[aa].Contains(bb))\\n                return true;\\n\\n            return graph\\n                .Where(pair => pair.Key != aa && pair.Key != bb)\\n                .Any(pair => !pair.Value.Contains(aa) && !pair.Value.Contains(bb));\\n        }\\n           \\n        int a = odds[0];\\n        int b = odds[1];\\n        int c = odds[2];\\n        int d = odds[3];\\n\\n        return !graph[a].Contains(b) && !graph[c].Contains(d) ||\\n               !graph[a].Contains(c) && !graph[b].Contains(d) ||\\n               !graph[a].Contains(d) && !graph[b].Contains(c);    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925308,
                "title": "c-adjacency-list-3-cases-0-2-4-odd-degree-nodes",
                "content": "***one mans\\'s bug is another man\\'s feature***\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<unordered_set<int>>store(n+1);\\n        vector<int>odd_degree;\\n        for(auto &edge:edges){\\n            store[edge[0]].insert(edge[1]);\\n            store[edge[1]].insert(edge[0]);\\n        }\\n        for(int i=0;i<store.size();i++){\\n            if(store[i].size()&1)odd_degree.push_back(i);\\n        }if(odd_degree.size()>4||odd_degree.size()%2==1)return false;\\n        if(odd_degree.size()==0)return true;\\n        else if(odd_degree.size()==2){\\n            if(store[odd_degree[0]].find(odd_degree[1])==store[odd_degree[0]].end())return true;\\n            for(int i=1;i<=n;i++){\\n                if(store[odd_degree[0]].find(i)==store[odd_degree[0]].end()){\\n                    if(store[odd_degree[1]].find(i)==store[odd_degree[1]].end()){\\n                        if(i!=odd_degree[0]&&i!=odd_degree[1])return true;\\n                    }\\n                }\\n            }return false;\\n        }else{\\n            if(store[odd_degree[0]].find(odd_degree[1])==store[odd_degree[0]].end()){\\n                if(store[odd_degree[2]].find(odd_degree[3])==store[odd_degree[2]].end())return true;\\n            }\\n            if(store[odd_degree[0]].find(odd_degree[3])==store[odd_degree[0]].end()){\\n                if(store[odd_degree[2]].find(odd_degree[1])==store[odd_degree[2]].end())return true;\\n            }\\n            if(store[odd_degree[0]].find(odd_degree[2])==store[odd_degree[0]].end()){\\n                if(store[odd_degree[1]].find(odd_degree[3])==store[odd_degree[1]].end())return true;\\n            }return false;\\n        }\\n    }\\n};\\n```\\nlogik:\\n1. make a vector store of sets (as sets have average lookup time o(1))\\n2. for each edge in edges put edge[1] in store[edge[0]] in vice versa\\n3. make a vector to collect all the nodes having odd number of connections\\n4. now if the vector has size 0 then already even , vector has size 2 then there are two ways to connect and if vector has size 4 then there are 3 ways to connect with atmost 2 new connections if anything else then return false\\n5. in case of 2 odd degree nodes either directly connect these nodes or pick a node not present in the adjacency list of both of the nodes and then connect both nodes to this node\\n6. in case of 4 either connect 1st to 2nd, 1st to 3rd, 1st to 4th and connect the remaining two nodes with an edge, if this is possible then return true else return false;",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<unordered_set<int>>store(n+1);\\n        vector<int>odd_degree;\\n        for(auto &edge:edges){\\n            store[edge[0]].insert(edge[1]);\\n            store[edge[1]].insert(edge[0]);\\n        }\\n        for(int i=0;i<store.size();i++){\\n            if(store[i].size()&1)odd_degree.push_back(i);\\n        }if(odd_degree.size()>4||odd_degree.size()%2==1)return false;\\n        if(odd_degree.size()==0)return true;\\n        else if(odd_degree.size()==2){\\n            if(store[odd_degree[0]].find(odd_degree[1])==store[odd_degree[0]].end())return true;\\n            for(int i=1;i<=n;i++){\\n                if(store[odd_degree[0]].find(i)==store[odd_degree[0]].end()){\\n                    if(store[odd_degree[1]].find(i)==store[odd_degree[1]].end()){\\n                        if(i!=odd_degree[0]&&i!=odd_degree[1])return true;\\n                    }\\n                }\\n            }return false;\\n        }else{\\n            if(store[odd_degree[0]].find(odd_degree[1])==store[odd_degree[0]].end()){\\n                if(store[odd_degree[2]].find(odd_degree[3])==store[odd_degree[2]].end())return true;\\n            }\\n            if(store[odd_degree[0]].find(odd_degree[3])==store[odd_degree[0]].end()){\\n                if(store[odd_degree[2]].find(odd_degree[1])==store[odd_degree[2]].end())return true;\\n            }\\n            if(store[odd_degree[0]].find(odd_degree[2])==store[odd_degree[0]].end()){\\n                if(store[odd_degree[1]].find(odd_degree[3])==store[odd_degree[1]].end())return true;\\n            }return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925294,
                "title": "c-rust-solution-easy-to-read",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn order to make the graph with degree even at all nodes:\\n1) When we have nodes of odd degree, the number of these nodes must be 2 or 4.\\n2) When the number is 4, they have to be connected by two edges.\\n3) When the number is 2, they either be connected a one edge directly, or be connected to a third node.\\n  \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//C++\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        set<pair<int, int>> s;\\n        vector<int> degree(n + 1, 0);\\n        \\n        for (auto &e: edges) {\\n            degree[e[0]] += 1;\\n            degree[e[1]] += 1;\\n            int x = min(e[0], e[1]), y  = max(e[0], e[1]);\\n            s.insert({x, y});\\n        }\\n        \\n        vector<int> data;\\n        for (int u = 1; u <= n; ++u) {\\n            if (degree[u] % 2 != 0) data.push_back(u);\\n        }\\n        if (data.size() == 0) return true;\\n        \\n        if (data.size() == 4) {\\n            sort(data.begin(), data.end());\\n            \\n            if (s.find({data[0], data[1]}) == s.end() && s.find({data[2], data[3]}) == s.end()) return true;\\n            if (s.find({data[0], data[2]}) == s.end() && s.find({data[1], data[3]}) == s.end()) return true;\\n            if (s.find({data[0], data[3]}) == s.end() && s.find({data[1], data[2]}) == s.end()) return true;\\n            return false;\\n        }\\n        \\n        if (data.size() == 2) {\\n            sort(data.begin(), data.end());\\n            if (s.find({data[0], data[1]}) == s.end()) return true;\\n            for (int u = 1; u <= n; ++u) {\\n                if (u == data[0] || u == data[1]) continue;\\n                int x = min(u, data[0]), y  = max(u, data[0]);\\n                int i = min(u, data[1]), j  = max(u, data[1]);\\n                if (s.find({x, y}) == s.end() && s.find({i, j}) == s.end()) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n```\\n\\n~~~\\n//Rust\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn is_possible(n: i32, edges: Vec<Vec<i32>>) -> bool {\\n        let mut s = HashSet::new();\\n        let n = n as usize;\\n        let mut degree = vec![0; n + 1];\\n        \\n        for e in edges {\\n            let (u, v) = (e[0] as usize, e[1] as usize);\\n            degree[u] += 1;\\n            degree[v] += 1;\\n            let (x, y) = (u.min(v), u.max(v));\\n            s.insert((x, y));\\n        }\\n        \\n        let mut data = vec![];\\n        for u in 1 ..= n {\\n            if degree[u] % 2 != 0 { data.push(u); }\\n        }\\n        if data.len() == 0 { return true }\\n        \\n        if data.len() == 4 {\\n            data.sort();\\n            if s.contains(&(data[0], data[1])) == false && s.contains(&(data[2], data[3])) == false { return true }\\n            if s.contains(&(data[0], data[2])) == false && s.contains(&(data[1], data[3])) == false { return true }\\n            if s.contains(&(data[0], data[3])) == false && s.contains(&(data[1], data[2])) == false { return true }\\n            return false;\\n        }\\n        \\n        if data.len() == 2 {\\n            data.sort();\\n            if s.contains(&(data[0], data[1])) == false { return true }\\n            for u in 1 ..= n {\\n                if u == data[0] || u == data[1] { continue }\\n                let (x, y) = (u.min(data[0]), u.max(data[0]));\\n                let (i, j) = (u.min(data[1]), u.max(data[1]));\\n                if s.contains(&(x, y)) == false && s.contains(&(i, j)) == false { return true }\\n            }\\n        }\\n        \\n        false\\n    }\\n}\\n~~~",
                "solutionTags": [
                    "C++",
                    "Rust"
                ],
                "code": "```\\n//C++\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        set<pair<int, int>> s;\\n        vector<int> degree(n + 1, 0);\\n        \\n        for (auto &e: edges) {\\n            degree[e[0]] += 1;\\n            degree[e[1]] += 1;\\n            int x = min(e[0], e[1]), y  = max(e[0], e[1]);\\n            s.insert({x, y});\\n        }\\n        \\n        vector<int> data;\\n        for (int u = 1; u <= n; ++u) {\\n            if (degree[u] % 2 != 0) data.push_back(u);\\n        }\\n        if (data.size() == 0) return true;\\n        \\n        if (data.size() == 4) {\\n            sort(data.begin(), data.end());\\n            \\n            if (s.find({data[0], data[1]}) == s.end() && s.find({data[2], data[3]}) == s.end()) return true;\\n            if (s.find({data[0], data[2]}) == s.end() && s.find({data[1], data[3]}) == s.end()) return true;\\n            if (s.find({data[0], data[3]}) == s.end() && s.find({data[1], data[2]}) == s.end()) return true;\\n            return false;\\n        }\\n        \\n        if (data.size() == 2) {\\n            sort(data.begin(), data.end());\\n            if (s.find({data[0], data[1]}) == s.end()) return true;\\n            for (int u = 1; u <= n; ++u) {\\n                if (u == data[0] || u == data[1]) continue;\\n                int x = min(u, data[0]), y  = max(u, data[0]);\\n                int i = min(u, data[1]), j  = max(u, data[1]);\\n                if (s.find({x, y}) == s.end() && s.find({i, j}) == s.end()) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925252,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {boolean}\\n */\\nvar isPossible = function(n, edges) {\\n    let res = false;\\n    let indegree = [];\\n    for(let i=0; i<n; i++){\\n        indegree[i] = [];\\n    }\\n    // count the indegree of every num\\n    for(let i=0; i<edges.length; i++){\\n        let e1 = edges[i][0];\\n        let e2 = edges[i][1];\\n\\n        indegree[e1-1].push(e2-1);\\n        indegree[e2-1].push(e1-1);\\n    }\\n    // find all nodes having odd indegree\\n    let count = 0;\\n    let arr = [];\\n    for(let i=0; i<n; i++){\\n        if(indegree[i].length % 2 !== 0){\\n            count ++;\\n            arr.push(i);\\n        }\\n    }\\n    // only need to judge 0 2 4\\n    if(count < 5 && count >= 1){\\n        if(count === 2){\\n            let e1 = arr[0];\\n            let e2 = arr[1];\\n            if(indegree[e1].indexOf(e2) === -1){\\n                res = true;\\n            }else if(indegree[e1].length < n-1 && indegree[e2].length < n-1){\\n                // need to search 1 even node to connect both 2 odd node\\n                for(let i=0; i<n; i++){\\n                    if(indegree[i].length % 2 === 0 && indegree[i].indexOf(e1) === -1 && indegree[i].indexOf(e2) === -1){\\n                        res = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }else if(count === 4){\\n            let e1 = arr[0];\\n            let e2 = arr[1];\\n            let e3 = arr[2];\\n            let e4 = arr[3];\\n            if(indegree[e1].indexOf(e2) === -1 && indegree[e3].indexOf(e4) === -1){\\n                res = true;\\n            }else if(indegree[e1].indexOf(e3) === -1 && indegree[e2].indexOf(e4) === -1){\\n                res = true;\\n            }else if(indegree[e1].indexOf(e4) === -1 && indegree[e2].indexOf(e3) === -1){\\n                res = true;\\n            }\\n        }\\n    }else if(count === 0){\\n        res = true;\\n    }\\n\\n    return res;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Graph"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {boolean}\\n */\\nvar isPossible = function(n, edges) {\\n    let res = false;\\n    let indegree = [];\\n    for(let i=0; i<n; i++){\\n        indegree[i] = [];\\n    }\\n    // count the indegree of every num\\n    for(let i=0; i<edges.length; i++){\\n        let e1 = edges[i][0];\\n        let e2 = edges[i][1];\\n\\n        indegree[e1-1].push(e2-1);\\n        indegree[e2-1].push(e1-1);\\n    }\\n    // find all nodes having odd indegree\\n    let count = 0;\\n    let arr = [];\\n    for(let i=0; i<n; i++){\\n        if(indegree[i].length % 2 !== 0){\\n            count ++;\\n            arr.push(i);\\n        }\\n    }\\n    // only need to judge 0 2 4\\n    if(count < 5 && count >= 1){\\n        if(count === 2){\\n            let e1 = arr[0];\\n            let e2 = arr[1];\\n            if(indegree[e1].indexOf(e2) === -1){\\n                res = true;\\n            }else if(indegree[e1].length < n-1 && indegree[e2].length < n-1){\\n                // need to search 1 even node to connect both 2 odd node\\n                for(let i=0; i<n; i++){\\n                    if(indegree[i].length % 2 === 0 && indegree[i].indexOf(e1) === -1 && indegree[i].indexOf(e2) === -1){\\n                        res = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }else if(count === 4){\\n            let e1 = arr[0];\\n            let e2 = arr[1];\\n            let e3 = arr[2];\\n            let e4 = arr[3];\\n            if(indegree[e1].indexOf(e2) === -1 && indegree[e3].indexOf(e4) === -1){\\n                res = true;\\n            }else if(indegree[e1].indexOf(e3) === -1 && indegree[e2].indexOf(e4) === -1){\\n                res = true;\\n            }else if(indegree[e1].indexOf(e4) === -1 && indegree[e2].indexOf(e3) === -1){\\n                res = true;\\n            }\\n        }\\n    }else if(count === 0){\\n        res = true;\\n    }\\n\\n    return res;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2925209,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    private static boolean solve(int n, List<Set<Integer>> graph) {\\n        List<Integer> nodes = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            if (graph.get(i).size() % 2 == 1) {\\n                nodes.add(i);\\n            }\\n        }\\n        int x = nodes.size(), count = 0;\\n        if (x == 0)\\n            return true;\\n        if (x > 4 || x == 1)\\n            return false;\\n\\n        if (x == 2) {\\n            int node1 = nodes.get(0);\\n            int node2 = nodes.get(1);\\n            for (int i = 0; i < n; i++) {\\n                if (!graph.get(i).contains(node1) && !graph.get(i).contains(node2))\\n                    return true;\\n            }\\n            return false;\\n        }\\n        for (int i = 0; i < x; i++) {\\n            for (int j = 0; j < x; j++) {\\n                if (i != j) {\\n                    int node1 = nodes.get(i);\\n                    int node2 = nodes.get(j);\\n                    if (graph.get(node1).size() % 2 != 0 && graph.get(node2).size() % 2 != 0) {\\n                        if (graph.get(node1).contains(node2))\\n                            continue;\\n                        graph.get(node1).add(node2);\\n                        graph.get(node2).add(node1);\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        if (count > 2)\\n            return false;\\n        for (int i = 0; i < n; i++) {\\n            if (graph.get(i).size() % 2 == 1)\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        List<Set<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++)\\n            graph.add(new HashSet<>());\\n        for (List<Integer> edge : edges) {\\n            int start = edge.get(0) - 1, end = edge.get(1) - 1;\\n            graph.get(start).add(end);\\n            graph.get(end).add(start);\\n        }\\n        return solve(n, graph);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static boolean solve(int n, List<Set<Integer>> graph) {\\n        List<Integer> nodes = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            if (graph.get(i).size() % 2 == 1) {\\n                nodes.add(i);\\n            }\\n        }\\n        int x = nodes.size(), count = 0;\\n        if (x == 0)\\n            return true;\\n        if (x > 4 || x == 1)\\n            return false;\\n\\n        if (x == 2) {\\n            int node1 = nodes.get(0);\\n            int node2 = nodes.get(1);\\n            for (int i = 0; i < n; i++) {\\n                if (!graph.get(i).contains(node1) && !graph.get(i).contains(node2))\\n                    return true;\\n            }\\n            return false;\\n        }\\n        for (int i = 0; i < x; i++) {\\n            for (int j = 0; j < x; j++) {\\n                if (i != j) {\\n                    int node1 = nodes.get(i);\\n                    int node2 = nodes.get(j);\\n                    if (graph.get(node1).size() % 2 != 0 && graph.get(node2).size() % 2 != 0) {\\n                        if (graph.get(node1).contains(node2))\\n                            continue;\\n                        graph.get(node1).add(node2);\\n                        graph.get(node2).add(node1);\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        if (count > 2)\\n            return false;\\n        for (int i = 0; i < n; i++) {\\n            if (graph.get(i).size() % 2 == 1)\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        List<Set<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++)\\n            graph.add(new HashSet<>());\\n        for (List<Integer> edge : edges) {\\n            int start = edge.get(0) - 1, end = edge.get(1) - 1;\\n            graph.get(start).add(end);\\n            graph.get(end).add(start);\\n        }\\n        return solve(n, graph);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925181,
                "title": "c-explained-all-edge-cases",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int k, vector<vector<int>>& edges) {\\n        int n=edges.size();\\n        \\n        //make a map of edges corresponding to each vertex\\n        unordered_map<int,unordered_set<int>> mp;\\n        for(int i=0;i<n;i++){\\n            mp[edges[i][0]].insert(edges[i][1]);\\n            mp[edges[i][1]].insert(edges[i][0]);\\n        }\\n        \\n        //count the no of vertex having odd degree\\n        int count=0;\\n        unordered_map<int,unordered_set<int>>::iterator itr;\\n        for(itr=mp.begin();itr!=mp.end();itr++){\\n            if((itr->second.size())%2)\\n                count++;\\n        }\\n        \\n        // since we add add atmost 2 edges, so we need to take care of only 2 cases when count=2 or count=4\\n        if(count>4 || count%2)\\n            return 0;\\n        if(count==0)\\n            return 1;\\n        \\n        // collect the vertices having odd degree\\n        vector<int> ans;\\n        for(itr=mp.begin();itr!=mp.end();itr++){\\n            if((itr->second.size())%2)\\n                ans.push_back(itr->first);\\n        }\\n        \\n        //for count=4, we can have only 3 following possibilities to add edges\\n        // [0->1 (2->3) ... 0->2 (1->3) ... 0->3 (2->1)]\\n        \\n        if(count==4){\\n            if(mp[ans[0]].find(ans[1])==mp[ans[0]].end() && mp[ans[2]].find(ans[3])==mp[ans[2]].end())\\n                return 1;\\n            if(mp[ans[0]].find(ans[2])==mp[ans[0]].end() && mp[ans[1]].find(ans[3])==mp[ans[1]].end())\\n                return 1;\\n            if(mp[ans[0]].find(ans[3])==mp[ans[0]].end() && mp[ans[2]].find(ans[1])==mp[ans[2]].end())\\n                return 1;\\n        }\\n        \\n        // for count=2, either we can add direct edge bw them\\n        if(count==2 && mp[ans[0]].find(ans[1])==mp[ans[0]].end())\\n            return 1;\\n        \\n        // or we need to consider one more vertex which is not connected to any of these deprecated vertices. Connect the deprecated vertices to that selected vertex, which results in increase of degree of deprecated vertices by 1 and the selected vertex by 2.\\n        if(count==2){\\n            for(itr=mp.begin();itr!=mp.end();itr++){\\n                if(itr->first==ans[0] || itr->first==ans[1])\\n                    continue;\\n                if((itr->second.find(ans[0])==itr->second.end()) && \\n                (itr->second.find(ans[1])==itr->second.end()))\\n                    return true;\\n            }\\n        }\\n        \\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int k, vector<vector<int>>& edges) {\\n        int n=edges.size();\\n        \\n        //make a map of edges corresponding to each vertex\\n        unordered_map<int,unordered_set<int>> mp;\\n        for(int i=0;i<n;i++){\\n            mp[edges[i][0]].insert(edges[i][1]);\\n            mp[edges[i][1]].insert(edges[i][0]);\\n        }\\n        \\n        //count the no of vertex having odd degree\\n        int count=0;\\n        unordered_map<int,unordered_set<int>>::iterator itr;\\n        for(itr=mp.begin();itr!=mp.end();itr++){\\n            if((itr->second.size())%2)\\n                count++;\\n        }\\n        \\n        // since we add add atmost 2 edges, so we need to take care of only 2 cases when count=2 or count=4\\n        if(count>4 || count%2)\\n            return 0;\\n        if(count==0)\\n            return 1;\\n        \\n        // collect the vertices having odd degree\\n        vector<int> ans;\\n        for(itr=mp.begin();itr!=mp.end();itr++){\\n            if((itr->second.size())%2)\\n                ans.push_back(itr->first);\\n        }\\n        \\n        //for count=4, we can have only 3 following possibilities to add edges\\n        // [0->1 (2->3) ... 0->2 (1->3) ... 0->3 (2->1)]\\n        \\n        if(count==4){\\n            if(mp[ans[0]].find(ans[1])==mp[ans[0]].end() && mp[ans[2]].find(ans[3])==mp[ans[2]].end())\\n                return 1;\\n            if(mp[ans[0]].find(ans[2])==mp[ans[0]].end() && mp[ans[1]].find(ans[3])==mp[ans[1]].end())\\n                return 1;\\n            if(mp[ans[0]].find(ans[3])==mp[ans[0]].end() && mp[ans[2]].find(ans[1])==mp[ans[2]].end())\\n                return 1;\\n        }\\n        \\n        // for count=2, either we can add direct edge bw them\\n        if(count==2 && mp[ans[0]].find(ans[1])==mp[ans[0]].end())\\n            return 1;\\n        \\n        // or we need to consider one more vertex which is not connected to any of these deprecated vertices. Connect the deprecated vertices to that selected vertex, which results in increase of degree of deprecated vertices by 1 and the selected vertex by 2.\\n        if(count==2){\\n            for(itr=mp.begin();itr!=mp.end();itr++){\\n                if(itr->first==ans[0] || itr->first==ans[1])\\n                    continue;\\n                if((itr->second.find(ans[0])==itr->second.end()) && \\n                (itr->second.find(ans[1])==itr->second.end()))\\n                    return true;\\n            }\\n        }\\n        \\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925078,
                "title": "java-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![WhatsApp Image 2022-12-18 at 4.26.30 PM.jpeg](https://assets.leetcode.com/users/images/22cc0801-d17b-47f9-8f16-4548c6d6dda3_1671361073.3457315.jpeg)\\n\\n![WhatsApp Image 2022-12-18 at 4.26.30 PM (1).jpeg](https://assets.leetcode.com/users/images/e0f813fd-41a4-4adb-9ef5-e030d735999c_1671361094.0193648.jpeg)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        Set<Pair<Integer,Integer>>adj=new HashSet<>();\\n        int degree[]=new int[n+1];\\n        for(List<Integer>edge:edges){\\n            adj.add(new Pair(edge.get(0),edge.get(1)));\\n            adj.add(new Pair(edge.get(1),edge.get(0)));\\n            degree[edge.get(0)]++;\\n            degree[edge.get(1)]++;\\n        }\\n        List<Integer>odd=new ArrayList<>();\\n        for(int i=1;i<=n;i++){\\n            if(degree[i]%2==1) odd.add(i);\\n        }\\n        int m=odd.size();\\n        if(m==0) return true;\\n        if(m==1 || m>4 || m==3){\\n            return false;\\n        }\\n        int a=odd.get(0),b=odd.get(1);\\n        if(m==2){\\n            if(!adj.contains(new Pair(a,b))) return true;\\n            for(int i=1;i<=n;i++){\\n                if(!adj.contains(new Pair(a,i)) && !adj.contains(new Pair(i,b))) return true;\\n            }\\n            return false;\\n        }\\n        int c=odd.get(2),d=odd.get(3);\\n      if ((!adj.contains(new Pair(a,b)) && !adj.contains(new Pair(c,d))) ||\\n            (!adj.contains(new Pair(a,c)) && !adj.contains(new Pair(b,d))) ||\\n            (!adj.contains(new Pair(a,d)) && !adj.contains(new Pair(b,c)))) return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        Set<Pair<Integer,Integer>>adj=new HashSet<>();\\n        int degree[]=new int[n+1];\\n        for(List<Integer>edge:edges){\\n            adj.add(new Pair(edge.get(0),edge.get(1)));\\n            adj.add(new Pair(edge.get(1),edge.get(0)));\\n            degree[edge.get(0)]++;\\n            degree[edge.get(1)]++;\\n        }\\n        List<Integer>odd=new ArrayList<>();\\n        for(int i=1;i<=n;i++){\\n            if(degree[i]%2==1) odd.add(i);\\n        }\\n        int m=odd.size();\\n        if(m==0) return true;\\n        if(m==1 || m>4 || m==3){\\n            return false;\\n        }\\n        int a=odd.get(0),b=odd.get(1);\\n        if(m==2){\\n            if(!adj.contains(new Pair(a,b))) return true;\\n            for(int i=1;i<=n;i++){\\n                if(!adj.contains(new Pair(a,i)) && !adj.contains(new Pair(i,b))) return true;\\n            }\\n            return false;\\n        }\\n        int c=odd.get(2),d=odd.get(3);\\n      if ((!adj.contains(new Pair(a,b)) && !adj.contains(new Pair(c,d))) ||\\n            (!adj.contains(new Pair(a,c)) && !adj.contains(new Pair(b,d))) ||\\n            (!adj.contains(new Pair(a,d)) && !adj.contains(new Pair(b,c)))) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925062,
                "title": "small-implementation-for-this-tricky-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ncalc all nodes that has odd edges if there count > 4 orr odd return false\\nso you just care about 2 or 4 nodes;\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<set<int>>v(n+1);\\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            int x=edges[i][0],y=edges[i][1];\\n            v[x].insert(y);v[y].insert(x);\\n        }\\n        vector<int>vec; // this vector for nodes that has odd edges\\n        for(int i=1; i<=n; i++)\\n        {\\n            if(v[i].size()&1)vec.emplace_back(i);\\n        }\\n        if((vec.size()&1)||vec.size()>4)return 0;\\n        if(vec.empty())return 1; // if there is no odd nodes return true\\n        if(vec.size()==2)\\n        {\\n            if(v[vec[0]].find(vec[1])==v[vec[0]].end())return 1;\\n            // you should tie any two nodes with each other to have\\n            // other nodes still even but in this case if you can\\'t \\n            // tie them try to tie them by even node \\n            for(int i=1; i<=n; i++)\\n            {\\n                if(i!=vec[0]&&i!=vec[1]&&v[i].find(vec[0])==v[i].end()&&v[i].find(vec[1])==v[i].end())return 1;\\n            }\\n            return 0;\\n        }else\\n        {\\n            // here in case of 4 so you should try to tie any two\\n            // with each other\\n            if(v[vec[0]].find(vec[1])==v[vec[0]].end()&&v[vec[2]].find(vec[3])==v[vec[2]].end())return 1;\\n            if(v[vec[0]].find(vec[2])==v[vec[0]].end()&&v[vec[1]].find(vec[3])==v[vec[1]].end())return 1;\\n            if(v[vec[0]].find(vec[3])==v[vec[0]].end()&&v[vec[2]].find(vec[1])==v[vec[2]].end())return 1;\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<set<int>>v(n+1);\\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            int x=edges[i][0],y=edges[i][1];\\n            v[x].insert(y);v[y].insert(x);\\n        }\\n        vector<int>vec; // this vector for nodes that has odd edges\\n        for(int i=1; i<=n; i++)\\n        {\\n            if(v[i].size()&1)vec.emplace_back(i);\\n        }\\n        if((vec.size()&1)||vec.size()>4)return 0;\\n        if(vec.empty())return 1; // if there is no odd nodes return true\\n        if(vec.size()==2)\\n        {\\n            if(v[vec[0]].find(vec[1])==v[vec[0]].end())return 1;\\n            // you should tie any two nodes with each other to have\\n            // other nodes still even but in this case if you can\\'t \\n            // tie them try to tie them by even node \\n            for(int i=1; i<=n; i++)\\n            {\\n                if(i!=vec[0]&&i!=vec[1]&&v[i].find(vec[0])==v[i].end()&&v[i].find(vec[1])==v[i].end())return 1;\\n            }\\n            return 0;\\n        }else\\n        {\\n            // here in case of 4 so you should try to tie any two\\n            // with each other\\n            if(v[vec[0]].find(vec[1])==v[vec[0]].end()&&v[vec[2]].find(vec[3])==v[vec[2]].end())return 1;\\n            if(v[vec[0]].find(vec[2])==v[vec[0]].end()&&v[vec[1]].find(vec[3])==v[vec[1]].end())return 1;\\n            if(v[vec[0]].find(vec[3])==v[vec[0]].end()&&v[vec[2]].find(vec[1])==v[vec[2]].end())return 1;\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924963,
                "title": "easy-solution-to-understand-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst we find node with odd degree and make edges between them.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf Number of nodes with odd degree is 2 or 4 then it is possible otherwise not.\\n\\nIf there is 2 node with odd degree is than if there is no edge between them then you can put edge.\\n    or you can find another node where no edges between that node and this two node.\\n\\nIf there is 4 node similar way you can think.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> numOfDegree(n+1,0);\\n        int i;\\n        for(i=0;i<edges.size();i++)\\n        {\\n            numOfDegree[edges[i][0]]++;\\n            numOfDegree[edges[i][1]]++;\\n        }\\n        int numOfOddDegree=0;\\n        vector<int> nodeWithOddDegree; \\n        for(i=1;i<numOfDegree.size();i++)\\n        {\\n            if(numOfDegree[i]%2)\\n            {\\n                numOfOddDegree++;\\n                nodeWithOddDegree.push_back(i);\\n            }\\n        }\\n        if(numOfOddDegree>4 || numOfOddDegree%2==1)\\n        {\\n            return false;\\n        }\\n        else\\n        {\\n            if(numOfOddDegree==2)\\n            {\\n                i=0;\\n                vector<int> isNodeNotConnected(n+1,0);\\n                isNodeNotConnected[nodeWithOddDegree[0]]=1;\\n                isNodeNotConnected[nodeWithOddDegree[1]]=1;\\n                bool flag = false;\\n                for(i=0;i<edges.size();i++)\\n                {\\n                    if(edges[i][0]==nodeWithOddDegree[0])\\n                    {\\n                        isNodeNotConnected[edges[i][1]]=1;\\n                    }\\n                    else if(edges[i][0]==nodeWithOddDegree[1])\\n                    {\\n                        isNodeNotConnected[edges[i][1]]=1;\\n                    }\\n                    if(edges[i][1]==nodeWithOddDegree[0])\\n                    {\\n                        isNodeNotConnected[edges[i][0]]=1;\\n                    }\\n                    else if(edges[i][1]==nodeWithOddDegree[1])\\n                    {\\n                        isNodeNotConnected[edges[i][0]]=1;\\n                    }\\n                    if((edges[i][0]==nodeWithOddDegree[0] && edges[i][1]==nodeWithOddDegree[1])||(edges[i][0]==nodeWithOddDegree[1] && edges[i][1]==nodeWithOddDegree[0]))\\n                    {\\n                        flag = true;\\n                    }\\n                }\\n                if(flag)\\n                {\\n                    for(i=1;i<isNodeNotConnected.size();i++)\\n                    {\\n                        if(isNodeNotConnected[i]==0)\\n                        {\\n                            return true;\\n                        }\\n                    }\\n                    return false;\\n                }\\n                return true;\\n            }\\n            else if(numOfOddDegree==4)\\n            {\\n                vector<int> si(numOfOddDegree,0);\\n                for(i=0;i<edges.size();i++)\\n                {\\n                    if((edges[i][0] == nodeWithOddDegree[0] && edges[i][1] == nodeWithOddDegree[1])||(edges[i][0] == nodeWithOddDegree[1] && edges[i][1] == nodeWithOddDegree[0]))\\n                    {\\n                        si[0]++;\\n                        si[1]++;\\n                    }\\n                    else if((edges[i][0] == nodeWithOddDegree[1] && edges[i][1] == nodeWithOddDegree[3])||(edges[i][0] == nodeWithOddDegree[3] && edges[i][1] == nodeWithOddDegree[1]))\\n                    {\\n                        si[1]++;\\n                        si[3]++;\\n                    }\\n                    else if((edges[i][0] == nodeWithOddDegree[1] && edges[i][1] == nodeWithOddDegree[2])||(edges[i][0] == nodeWithOddDegree[2] && edges[i][1] == nodeWithOddDegree[1]))\\n                    {\\n                        si[1]++;\\n                        si[2]++;\\n                    }\\n                    else if((edges[i][0] == nodeWithOddDegree[2] && edges[i][1] == nodeWithOddDegree[3])||(edges[i][0] == nodeWithOddDegree[3] && edges[i][1] == nodeWithOddDegree[2]))\\n                    {\\n                        si[3]++;\\n                        si[2]++;\\n                    }\\n                    else if((edges[i][0] == nodeWithOddDegree[0] && edges[i][1] == nodeWithOddDegree[2])||(edges[i][0] == nodeWithOddDegree[2] && edges[i][1] == nodeWithOddDegree[0]))\\n                    {\\n                        si[0]++;\\n                        si[2]++;\\n                    }\\n                    else if((edges[i][0] == nodeWithOddDegree[0] && edges[i][1] == nodeWithOddDegree[3])||(edges[i][0] == nodeWithOddDegree[3] && edges[i][1] == nodeWithOddDegree[0]))\\n                    {\\n                        si[0]++;\\n                        si[3]++;\\n                    }\\n                    else\\n                    {\\n                        \\n                    }\\n                }\\n                cout<<\"hi\"<<endl;\\n                int s=0;\\n                for(i=0;i<si.size();i++)\\n                {\\n                    s+=si[i];\\n                    if(si[i]>2)\\n                    {\\n                        return false;\\n                    }\\n                }\\n                cout<<s<<endl;\\n                if(s>8)\\n                {\\n                    return false;\\n                }\\n                else if(s==6)\\n                {\\n                    for(i=0;i<si.size();i++)\\n                    {\\n                        if(si[i]==0)\\n                        {\\n                            return false;\\n                        }\\n                    }\\n                    return true;\\n                }\\n                else\\n                {\\n                    return true;\\n                }\\n            }\\n            else\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> numOfDegree(n+1,0);\\n        int i;\\n        for(i=0;i<edges.size();i++)\\n        {\\n            numOfDegree[edges[i][0]]++;\\n            numOfDegree[edges[i][1]]++;\\n        }\\n        int numOfOddDegree=0;\\n        vector<int> nodeWithOddDegree; \\n        for(i=1;i<numOfDegree.size();i++)\\n        {\\n            if(numOfDegree[i]%2)\\n            {\\n                numOfOddDegree++;\\n                nodeWithOddDegree.push_back(i);\\n            }\\n        }\\n        if(numOfOddDegree>4 || numOfOddDegree%2==1)\\n        {\\n            return false;\\n        }\\n        else\\n        {\\n            if(numOfOddDegree==2)\\n            {\\n                i=0;\\n                vector<int> isNodeNotConnected(n+1,0);\\n                isNodeNotConnected[nodeWithOddDegree[0]]=1;\\n                isNodeNotConnected[nodeWithOddDegree[1]]=1;\\n                bool flag = false;\\n                for(i=0;i<edges.size();i++)\\n                {\\n                    if(edges[i][0]==nodeWithOddDegree[0])\\n                    {\\n                        isNodeNotConnected[edges[i][1]]=1;\\n                    }\\n                    else if(edges[i][0]==nodeWithOddDegree[1])\\n                    {\\n                        isNodeNotConnected[edges[i][1]]=1;\\n                    }\\n                    if(edges[i][1]==nodeWithOddDegree[0])\\n                    {\\n                        isNodeNotConnected[edges[i][0]]=1;\\n                    }\\n                    else if(edges[i][1]==nodeWithOddDegree[1])\\n                    {\\n                        isNodeNotConnected[edges[i][0]]=1;\\n                    }\\n                    if((edges[i][0]==nodeWithOddDegree[0] && edges[i][1]==nodeWithOddDegree[1])||(edges[i][0]==nodeWithOddDegree[1] && edges[i][1]==nodeWithOddDegree[0]))\\n                    {\\n                        flag = true;\\n                    }\\n                }\\n                if(flag)\\n                {\\n                    for(i=1;i<isNodeNotConnected.size();i++)\\n                    {\\n                        if(isNodeNotConnected[i]==0)\\n                        {\\n                            return true;\\n                        }\\n                    }\\n                    return false;\\n                }\\n                return true;\\n            }\\n            else if(numOfOddDegree==4)\\n            {\\n                vector<int> si(numOfOddDegree,0);\\n                for(i=0;i<edges.size();i++)\\n                {\\n                    if((edges[i][0] == nodeWithOddDegree[0] && edges[i][1] == nodeWithOddDegree[1])||(edges[i][0] == nodeWithOddDegree[1] && edges[i][1] == nodeWithOddDegree[0]))\\n                    {\\n                        si[0]++;\\n                        si[1]++;\\n                    }\\n                    else if((edges[i][0] == nodeWithOddDegree[1] && edges[i][1] == nodeWithOddDegree[3])||(edges[i][0] == nodeWithOddDegree[3] && edges[i][1] == nodeWithOddDegree[1]))\\n                    {\\n                        si[1]++;\\n                        si[3]++;\\n                    }\\n                    else if((edges[i][0] == nodeWithOddDegree[1] && edges[i][1] == nodeWithOddDegree[2])||(edges[i][0] == nodeWithOddDegree[2] && edges[i][1] == nodeWithOddDegree[1]))\\n                    {\\n                        si[1]++;\\n                        si[2]++;\\n                    }\\n                    else if((edges[i][0] == nodeWithOddDegree[2] && edges[i][1] == nodeWithOddDegree[3])||(edges[i][0] == nodeWithOddDegree[3] && edges[i][1] == nodeWithOddDegree[2]))\\n                    {\\n                        si[3]++;\\n                        si[2]++;\\n                    }\\n                    else if((edges[i][0] == nodeWithOddDegree[0] && edges[i][1] == nodeWithOddDegree[2])||(edges[i][0] == nodeWithOddDegree[2] && edges[i][1] == nodeWithOddDegree[0]))\\n                    {\\n                        si[0]++;\\n                        si[2]++;\\n                    }\\n                    else if((edges[i][0] == nodeWithOddDegree[0] && edges[i][1] == nodeWithOddDegree[3])||(edges[i][0] == nodeWithOddDegree[3] && edges[i][1] == nodeWithOddDegree[0]))\\n                    {\\n                        si[0]++;\\n                        si[3]++;\\n                    }\\n                    else\\n                    {\\n                        \\n                    }\\n                }\\n                cout<<\"hi\"<<endl;\\n                int s=0;\\n                for(i=0;i<si.size();i++)\\n                {\\n                    s+=si[i];\\n                    if(si[i]>2)\\n                    {\\n                        return false;\\n                    }\\n                }\\n                cout<<s<<endl;\\n                if(s>8)\\n                {\\n                    return false;\\n                }\\n                else if(s==6)\\n                {\\n                    for(i=0;i<si.size();i++)\\n                    {\\n                        if(si[i]==0)\\n                        {\\n                            return false;\\n                        }\\n                    }\\n                    return true;\\n                }\\n                else\\n                {\\n                    return true;\\n                }\\n            }\\n            else\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2924892,
                "title": "swift-solution-with-thoughts-progress",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nGenral thoughts\\nafter find odds\\ntwo way to make it become even\\n1. two odds connect each other and both become even\\n2. two odds connect to other even nodes, deal with new even nodes\\n\\nBecause the at most two new edge constraints\\n-> check odd nodes must be 2 or 4 (if > 4 the needed edges must over two)\\nso we can limit to three cases based on the odds count\\n\\n**A. 0 odds**\\nAlready make condition, return true\\n\\n**B. 4 odds**\\nonly can connect each other (approach 2)\\nif connect to other nodes, no more chance can deal with new nodes\\n\\n**C. 2 odds**\\nif approach 2 work, just need one new edge to make both 2 odds to even degrees\\n\\nelse we should check approach 1, by going through n nodes to find one node can connect to two odds together\\nwe can\\'t connect to two different even nodes, same reason as case B, no more chance can deal with new nodes\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nWe only need to knwo how to check two nodes can connect\\nit should be clear after two example\\n\\ncheck odds can connect a-b\\nby adjacentList[a] not contains b and vice versa\\n1: [2, 3, 4] -> no noded can add\\n2: [1]\\n3: [1]\\n4: [1]\\n\\n1: [2] -> 1-2(x), 1-2, 1-3\\n2: [1]\\n3: [4]\\n4: [3]\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(n)$$ because we leverate on set in adjacent list to get $$O(1)$$ contain check\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(n)$$ for adjacent list\\n\\n# Code\\n```\\nclass Solution {\\n    var adjacentList = [Int: Set<Int>]()\\n    func isPossible(_ n: Int, _ edges: [[Int]]) -> Bool {\\n        for edge in edges {\\n            adjacentList[edge[0], default: Set<Int>()].insert(edge[1])\\n            adjacentList[edge[1], default: Set<Int>()].insert(edge[0])\\n        }\\n        \\n        var odds = [Int]()\\n        adjacentList.forEach { \\n            if $0.value.count % 2 == 1 {\\n                odds.append($0.key)\\n            }\\n        }\\n        if odds.count == 0 {\\n            return true\\n        }\\n        \\n        guard odds.count == 2 || odds.count == 4 else {\\n            return false\\n        }\\n        if odds.count == 2 {\\n            if canConnect(odds[0], odds[1]) {\\n                return true\\n            } else {\\n                for i in 1...n {\\n                    if canConnect(i, odds[0]) && canConnect(i, odds[1]) {\\n                        return true\\n                    }\\n                }\\n                return false\\n            }\\n        } else {\\n            return \\n                (canConnect(odds[0], odds[1]) && canConnect(odds[2], odds[3])) ||\\n                (canConnect(odds[0], odds[2]) && canConnect(odds[1], odds[3])) ||\\n                (canConnect(odds[0], odds[3]) && canConnect(odds[1], odds[2]))\\n        }\\n    }\\n    \\n    func canConnect(_ node1: Int, _ node2: Int) -> Bool {\\n        return \\n            !adjacentList[node1, default: Set<Int>()].contains(node2) && \\n            !adjacentList[node2, default: Set<Int>()].contains(node1)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    var adjacentList = [Int: Set<Int>]()\\n    func isPossible(_ n: Int, _ edges: [[Int]]) -> Bool {\\n        for edge in edges {\\n            adjacentList[edge[0], default: Set<Int>()].insert(edge[1])\\n            adjacentList[edge[1], default: Set<Int>()].insert(edge[0])\\n        }\\n        \\n        var odds = [Int]()\\n        adjacentList.forEach { \\n            if $0.value.count % 2 == 1 {\\n                odds.append($0.key)\\n            }\\n        }\\n        if odds.count == 0 {\\n            return true\\n        }\\n        \\n        guard odds.count == 2 || odds.count == 4 else {\\n            return false\\n        }\\n        if odds.count == 2 {\\n            if canConnect(odds[0], odds[1]) {\\n                return true\\n            } else {\\n                for i in 1...n {\\n                    if canConnect(i, odds[0]) && canConnect(i, odds[1]) {\\n                        return true\\n                    }\\n                }\\n                return false\\n            }\\n        } else {\\n            return \\n                (canConnect(odds[0], odds[1]) && canConnect(odds[2], odds[3])) ||\\n                (canConnect(odds[0], odds[2]) && canConnect(odds[1], odds[3])) ||\\n                (canConnect(odds[0], odds[3]) && canConnect(odds[1], odds[2]))\\n        }\\n    }\\n    \\n    func canConnect(_ node1: Int, _ node2: Int) -> Bool {\\n        return \\n            !adjacentList[node1, default: Set<Int>()].contains(node2) && \\n            !adjacentList[node2, default: Set<Int>()].contains(node1)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924870,
                "title": "c-set-graph-based-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<unordered_set<int>> adj(n+1);\\n        for(auto x : edges)\\n        {\\n            adj[x[0]].insert(x[1]);\\n            adj[x[1]].insert(x[0]);\\n        }\\n        \\n        vector<int> odds; \\n        for(int i = 0; i<=n; i++)\\n        {\\n            if(adj[i].size() % 2 != 0)\\n            {\\n                odds.push_back(i);\\n            }\\n        }\\n        \\n        if(odds.size() == 0)\\n        {\\n            return true;\\n        }\\n        \\n        if(odds.size()%2!=0 || odds.size() > 4)\\n        {\\n            return false; \\n        }\\n        \\n        if(odds.size() == 2)\\n        {\\n            int a = odds[0]; \\n            int b = odds[1];\\n            if(adj[a].find(b) == adj[a].end())\\n            {\\n                return true;\\n            }\\n            for(int i = 1; i<=n; i++)\\n            {\\n                if(a!=i && b!=i && adj[a].find(i) == adj[a].end() && adj[b].find(i) == adj[b].end())\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        if(odds.size() == 4)\\n        {\\n            int a = odds[0];\\n            int b = odds[1];\\n            int c = odds[2];\\n            int d = odds[3];\\n            \\n            return (adj[a].find(d) == adj[a].end() && adj[b].find(c) == adj[b].end() || \\n                    adj[a].find(b) == adj[a].end() && adj[c].find(d) == adj[c].end() || \\n                    adj[a].find(c) == adj[a].end() && adj[b].find(d) == adj[b].end());\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Graph",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<unordered_set<int>> adj(n+1);\\n        for(auto x : edges)\\n        {\\n            adj[x[0]].insert(x[1]);\\n            adj[x[1]].insert(x[0]);\\n        }\\n        \\n        vector<int> odds; \\n        for(int i = 0; i<=n; i++)\\n        {\\n            if(adj[i].size() % 2 != 0)\\n            {\\n                odds.push_back(i);\\n            }\\n        }\\n        \\n        if(odds.size() == 0)\\n        {\\n            return true;\\n        }\\n        \\n        if(odds.size()%2!=0 || odds.size() > 4)\\n        {\\n            return false; \\n        }\\n        \\n        if(odds.size() == 2)\\n        {\\n            int a = odds[0]; \\n            int b = odds[1];\\n            if(adj[a].find(b) == adj[a].end())\\n            {\\n                return true;\\n            }\\n            for(int i = 1; i<=n; i++)\\n            {\\n                if(a!=i && b!=i && adj[a].find(i) == adj[a].end() && adj[b].find(i) == adj[b].end())\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        if(odds.size() == 4)\\n        {\\n            int a = odds[0];\\n            int b = odds[1];\\n            int c = odds[2];\\n            int d = odds[3];\\n            \\n            return (adj[a].find(d) == adj[a].end() && adj[b].find(c) == adj[b].end() || \\n                    adj[a].find(b) == adj[a].end() && adj[c].find(d) == adj[c].end() || \\n                    adj[a].find(c) == adj[a].end() && adj[b].find(d) == adj[b].end());\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924848,
                "title": "easy-c-solution-talks-about-edge-cases-only-time-complexity-o-log-n-can-be-improved-to-o-1",
                "content": "# Intuition\\nThis whole question is a joke just to check if we can handle the edge cases.\\n\\nFrom the condition at max 2 edges we can find say we can increase the degree of at max 4 nodes (1 degree for every end of the edge). So our question just resolved into, find the number of odd degree nodes and for every case (when there are no odd nodes, when there is one odd node to the max 4 odd nodes) we need to find if we can connect the nodes. \\n\\n# Approach\\nCollect odd degree node in a data-structure\\n\\n# Complexity\\n- Time complexity:\\nO(ln(n))\\nThe most expensive task is to check if a node is connected to a particular node which is handled by set data structure \\n\\n- Space complexity:\\nO(edges) max edges can be nodes * (nodes - 1) so\\nO(n*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        \\n        vector<set<int>> g(n);\\n\\n        for(auto &ed : edges){\\n            int a = ed[0]-1, b = ed[1]-1;\\n            g[a].insert(b);\\n            g[b].insert(a);\\n        }\\n\\n\\n        vector<int> oddD;\\n\\n        // edges case if a node node already have n - 1 connections and n is even number\\n        for(int i = 0 ; i < n ; ++i){\\n            int s = g[i].size();\\n            if(n % 2 == 0 and s == n - 1)\\n                return false;\\n            if(s&1)\\n                oddD.push_back(i);\\n        }\\n\\n        // we cannot handel more than 4 ndoes \\n        if(oddD.size() > 4)\\n            return false;\\n\\n\\n        // odd number of nodes cannot be connected \\n        if(oddD.size() % 2)\\n            return false;\\n\\n        // here we are trying to check if 4 nodes can be connected in any configuration\\n        if(oddD.size() == 4){\\n            vector<vector<bool>> m(4, vector<bool>(4, false));\\n            for(int i = 0 ; i < 3 ; ++i){\\n                int a = oddD[i];\\n                for(int j = i + 1; j < 4 ; ++j){\\n                    int b = oddD[j];\\n                    if(g[a].find(b) == g[a].end())\\n                        m[i][j] = m[j][i] = true;\\n                }\\n            }\\n            if(m[0][1] and m[2][3])\\n                return true;\\n            if(m[0][2] and m[1][3])\\n                return true;\\n            if(m[0][3] and m[1][2])\\n                return true;\\n            return false;\\n        }\\n\\n        if(oddD.size() == 2){\\n            int a = oddD[0], b = oddD[1];\\n            if(g[a].find(b) == g[a].end())\\n                return true;\\n            if(g[a].size() != n - 1 and g[b].size() != n - 1 )\\n                return true;\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        \\n        vector<set<int>> g(n);\\n\\n        for(auto &ed : edges){\\n            int a = ed[0]-1, b = ed[1]-1;\\n            g[a].insert(b);\\n            g[b].insert(a);\\n        }\\n\\n\\n        vector<int> oddD;\\n\\n        // edges case if a node node already have n - 1 connections and n is even number\\n        for(int i = 0 ; i < n ; ++i){\\n            int s = g[i].size();\\n            if(n % 2 == 0 and s == n - 1)\\n                return false;\\n            if(s&1)\\n                oddD.push_back(i);\\n        }\\n\\n        // we cannot handel more than 4 ndoes \\n        if(oddD.size() > 4)\\n            return false;\\n\\n\\n        // odd number of nodes cannot be connected \\n        if(oddD.size() % 2)\\n            return false;\\n\\n        // here we are trying to check if 4 nodes can be connected in any configuration\\n        if(oddD.size() == 4){\\n            vector<vector<bool>> m(4, vector<bool>(4, false));\\n            for(int i = 0 ; i < 3 ; ++i){\\n                int a = oddD[i];\\n                for(int j = i + 1; j < 4 ; ++j){\\n                    int b = oddD[j];\\n                    if(g[a].find(b) == g[a].end())\\n                        m[i][j] = m[j][i] = true;\\n                }\\n            }\\n            if(m[0][1] and m[2][3])\\n                return true;\\n            if(m[0][2] and m[1][3])\\n                return true;\\n            if(m[0][3] and m[1][2])\\n                return true;\\n            return false;\\n        }\\n\\n        if(oddD.size() == 2){\\n            int a = oddD[0], b = oddD[1];\\n            if(g[a].find(b) == g[a].end())\\n                return true;\\n            if(g[a].size() != n - 1 and g[b].size() != n - 1 )\\n                return true;\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924738,
                "title": "easiest-solution-in-java-with-proper-comment",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Find all the odd degree nodes and store into the list\\n2. we have atmost 2 edges to so,we can return true in 3 condition \\n2.1  if there is no odd degree node\\n2.2  if there is 2\\'s odd degree node\\n2.3  if there is 4\\'s odd degree node\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n\\n        // make adjcent list\\n        List<List<Integer>> adj = new ArrayList<>();\\n        int[] node_degree = new int[n+1];\\n\\n        for(int i=0;i<=n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        for (List<Integer> c:edges){\\n            int x = c.get(0);\\n            int y = c.get(1);\\n            adj.get(x).add(y);\\n            adj.get(y).add(x);\\n            node_degree[x]++;\\n            node_degree[y]++;\\n        }  \\n\\n        List<Integer> oddList = new ArrayList<>();\\n        // add all the odd degree node into the another list, that we can easily iterate\\n        for (int i=0;i<=n;i++){\\n            if (node_degree[i] % 2 == 1){\\n                oddList.add(i);\\n            }\\n        }\\n        // if there is no odd degree node\\n        if (oddList.size() == 0) return true;\\n        // if there is two odd degree node\\n        else if (oddList.size() == 2){\\n            int a = oddList.get(0);\\n            int b = oddList.get(1);\\n            if (checkLegal(adj,a,b)) return true;\\n            // n = 4, edges = [[1,2],[3,4]] this is the test case of below code\\n            for (int i=1;i<=n;i++){\\n                if (i == a || i == b) continue;\\n                if (checkLegal(adj,i,a) &&  checkLegal(adj,i,b)) return true;\\n            }\\n        }\\n        // if there is four odd degree node\\n        else if (oddList.size() == 4){\\n            int n1 = oddList.get(0);\\n            int n2 = oddList.get(1);\\n            int n3 = oddList.get(2);\\n            int n4 = oddList.get(3);\\n            if (checkLegal(adj,n1,n2) && checkLegal(adj,n3,n4)) return true;\\n            if (checkLegal(adj,n2,n3) && checkLegal(adj,n1,n4)) return true;\\n            if (checkLegal(adj,n1,n3) && checkLegal(adj,n2,n4)) return true;\\n        }\\n        return false;\\n    }\\n\\n    private boolean checkLegal(List<List<Integer>> adj,int a,int b){\\n        for (int val:adj.get(a)) if (val == b) return false;\\n        for (int val:adj.get(b)) if (val == a) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n\\n        // make adjcent list\\n        List<List<Integer>> adj = new ArrayList<>();\\n        int[] node_degree = new int[n+1];\\n\\n        for(int i=0;i<=n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        for (List<Integer> c:edges){\\n            int x = c.get(0);\\n            int y = c.get(1);\\n            adj.get(x).add(y);\\n            adj.get(y).add(x);\\n            node_degree[x]++;\\n            node_degree[y]++;\\n        }  \\n\\n        List<Integer> oddList = new ArrayList<>();\\n        // add all the odd degree node into the another list, that we can easily iterate\\n        for (int i=0;i<=n;i++){\\n            if (node_degree[i] % 2 == 1){\\n                oddList.add(i);\\n            }\\n        }\\n        // if there is no odd degree node\\n        if (oddList.size() == 0) return true;\\n        // if there is two odd degree node\\n        else if (oddList.size() == 2){\\n            int a = oddList.get(0);\\n            int b = oddList.get(1);\\n            if (checkLegal(adj,a,b)) return true;\\n            // n = 4, edges = [[1,2],[3,4]] this is the test case of below code\\n            for (int i=1;i<=n;i++){\\n                if (i == a || i == b) continue;\\n                if (checkLegal(adj,i,a) &&  checkLegal(adj,i,b)) return true;\\n            }\\n        }\\n        // if there is four odd degree node\\n        else if (oddList.size() == 4){\\n            int n1 = oddList.get(0);\\n            int n2 = oddList.get(1);\\n            int n3 = oddList.get(2);\\n            int n4 = oddList.get(3);\\n            if (checkLegal(adj,n1,n2) && checkLegal(adj,n3,n4)) return true;\\n            if (checkLegal(adj,n2,n3) && checkLegal(adj,n1,n4)) return true;\\n            if (checkLegal(adj,n1,n3) && checkLegal(adj,n2,n4)) return true;\\n        }\\n        return false;\\n    }\\n\\n    private boolean checkLegal(List<List<Integer>> adj,int a,int b){\\n        for (int val:adj.get(a)) if (val == b) return false;\\n        for (int val:adj.get(b)) if (val == a) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924700,
                "title": "python-check-case-by-case-w-t-intuition",
                "content": "# Intuition\\n\\nconstraints:\\n- only 2 extra edges can be added.\\n- graph can be disconnected.\\n\\ndue to constraints above, the only thing we need to concern is **odd degree edge**\\n\\nthus, find all the **odd degree edges** first and discuss case by case:\\n\\n**case 1: more than 4 odd degree nodes**\\n\\nit\\'s impossible to make them even degrees by adding <= 2 edges\\nreturn **False**\\n\\n**case 2: 0 odd degree nodes**\\n\\neach node has even degree, and since graph can be disconnected we can leave disconnected graph alone.\\nreturn **True**\\n\\n**case 3: 2 odd degree nodes**\\n\\nif we can link them together, return **True**.\\n\\n    also means we need a method to check if they\\'ve already had an edge or not.\\n    thus, build a **adjacency set** for this check.\\n\\nif they\\'ve already linked together, find another independent node to link.\\n\\ntherefore:\\n- if there exists an independent node for us to link, return **True**\\n- else **False**\\n\\n**case 4: 4 odd degree nodes**\\n\\nonly valid if they are able to link pair by pair because we only have 2 extra edges to make them even degree\\n\\nsince just 4 nodes, brute force to find these two pair\\n\\n# Complexity\\n- Time complexity:\\n$$O(edges.length)$$\\n\\n- Space complexity:\\n$$O(edges.length)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        degrees = [0] * (n+1)\\n\\n        # build adjacency set, we can check if it\\'s neighbor of someone or not in O(1) complexity\\n        neighbors = [set() for _ in range(n+1)]\\n        for u, v in edges:\\n            neighbors[u].add(v)\\n            neighbors[v].add(u)\\n            degrees[u] += 1\\n            degrees[v] += 1\\n        \\n        oddDeg = [node for node, deg in enumerate(degrees) if deg%2 != 0]\\n        \\n        # since 2 extra edges at most, it\\'s impossible to add less than 2 edges\\n        if len(oddDeg) > 4: return False\\n\\n        # since the graph can be disconnected, every graph is valid\\n        if len(oddDeg) == 0: return True\\n\\n        if len(oddDeg) == 2:\\n            u, v = oddDeg[0], oddDeg[1]\\n            if u not in neighbors[v]: # we can link together\\n                return True\\n            else: # we need to find another independent node to link for both of them\\n                for node in range(1, n+1):\\n                    if node != u and node != v and (node not in neighbors[u] and node not in neighbors[v]):\\n                        return True\\n                return False\\n        \\n        # len(oddDeg) == 4\\n        # since 2 extra edges at most, it\\'ll be valid only if they are able to link together\\n\\n        # only 4 nodes, brute force to check\\n        remain = set(oddDeg)\\n        for i in range(4):\\n            for j in range(i+1, 4):\\n                if i == j: continue\\n                u, v = oddDeg[i], oddDeg[j]\\n                if u not in neighbors[v]:\\n                    otherTwo = [node for node in remain if node != u and node != v]\\n                    a, b = otherTwo[0], otherTwo[1]\\n                    if a not in neighbors[b]:\\n                        return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        degrees = [0] * (n+1)\\n\\n        # build adjacency set, we can check if it\\'s neighbor of someone or not in O(1) complexity\\n        neighbors = [set() for _ in range(n+1)]\\n        for u, v in edges:\\n            neighbors[u].add(v)\\n            neighbors[v].add(u)\\n            degrees[u] += 1\\n            degrees[v] += 1\\n        \\n        oddDeg = [node for node, deg in enumerate(degrees) if deg%2 != 0]\\n        \\n        # since 2 extra edges at most, it\\'s impossible to add less than 2 edges\\n        if len(oddDeg) > 4: return False\\n\\n        # since the graph can be disconnected, every graph is valid\\n        if len(oddDeg) == 0: return True\\n\\n        if len(oddDeg) == 2:\\n            u, v = oddDeg[0], oddDeg[1]\\n            if u not in neighbors[v]: # we can link together\\n                return True\\n            else: # we need to find another independent node to link for both of them\\n                for node in range(1, n+1):\\n                    if node != u and node != v and (node not in neighbors[u] and node not in neighbors[v]):\\n                        return True\\n                return False\\n        \\n        # len(oddDeg) == 4\\n        # since 2 extra edges at most, it\\'ll be valid only if they are able to link together\\n\\n        # only 4 nodes, brute force to check\\n        remain = set(oddDeg)\\n        for i in range(4):\\n            for j in range(i+1, 4):\\n                if i == j: continue\\n                u, v = oddDeg[i], oddDeg[j]\\n                if u not in neighbors[v]:\\n                    otherTwo = [node for node in remain if node != u and node != v]\\n                    a, b = otherTwo[0], otherTwo[1]\\n                    if a not in neighbors[b]:\\n                        return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924573,
                "title": "build-adjacency-list-count-degree-and-handle-each-possible-cases",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> deg(n + 1);\\n        vector<set<int>> adj(n + 1);\\n        \\n        for (auto& e : edges)\\n        {\\n            adj[e[0]].insert(e[1]);\\n            adj[e[1]].insert(e[0]);\\n            ++deg[e[0]];\\n            ++deg[e[1]];\\n        }\\n        \\n        vector<int> odd;\\n        \\n        for (int i = 1; i <= n; ++i)\\n            if (deg[i] & 1)\\n                odd.push_back(i);\\n        \\n        // handle three possible cases.\\n        // case 1: there are no nodes with odd edges.\\n        if (odd.size() == 0)\\n        {\\n            return true;\\n        }\\n        // case 2: there are 2 nodes with odd edges.\\n        else if (odd.size() == 2)\\n        {\\n            // if there are no edge between these two nodes, \\n            if (adj[odd[0]].count(odd[1]) == 0)\\n                return true;\\n\\n            // if we can find a third node that are not connected with these two nodes.\\n            for (int i = 1; i <= n; ++i)\\n            {\\n                if (i == odd[0] || i == odd[1])\\n                    continue;\\n\\n                if (adj[i].count(odd[0]) == 0 && adj[i].count(odd[1]) == 0)\\n                    return true;\\n            }\\n\\n            // we failed\\n            return false;\\n        }\\n        // case 3: there are 4 nodes with odd edges.\\n        else if (odd.size() == 4)\\n        {\\n            // check every possible combination to connect these four nodes.\\n            if (adj[odd[0]].count(odd[1]) == 0 && adj[odd[2]].count(odd[3]) == 0)\\n                return true;\\n\\n            if (adj[odd[0]].count(odd[2]) == 0 && adj[odd[1]].count(odd[3]) == 0)\\n                return true;\\n\\n            if (adj[odd[0]].count(odd[3]) == 0 && adj[odd[1]].count(odd[2]) == 0)\\n                return true;\\n\\n            return false;\\n        }\\n        \\n        // any other cases are impossible.\\n         return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> deg(n + 1);\\n        vector<set<int>> adj(n + 1);\\n        \\n        for (auto& e : edges)\\n        {\\n            adj[e[0]].insert(e[1]);\\n            adj[e[1]].insert(e[0]);\\n            ++deg[e[0]];\\n            ++deg[e[1]];\\n        }\\n        \\n        vector<int> odd;\\n        \\n        for (int i = 1; i <= n; ++i)\\n            if (deg[i] & 1)\\n                odd.push_back(i);\\n        \\n        // handle three possible cases.\\n        // case 1: there are no nodes with odd edges.\\n        if (odd.size() == 0)\\n        {\\n            return true;\\n        }\\n        // case 2: there are 2 nodes with odd edges.\\n        else if (odd.size() == 2)\\n        {\\n            // if there are no edge between these two nodes, \\n            if (adj[odd[0]].count(odd[1]) == 0)\\n                return true;\\n\\n            // if we can find a third node that are not connected with these two nodes.\\n            for (int i = 1; i <= n; ++i)\\n            {\\n                if (i == odd[0] || i == odd[1])\\n                    continue;\\n\\n                if (adj[i].count(odd[0]) == 0 && adj[i].count(odd[1]) == 0)\\n                    return true;\\n            }\\n\\n            // we failed\\n            return false;\\n        }\\n        // case 3: there are 4 nodes with odd edges.\\n        else if (odd.size() == 4)\\n        {\\n            // check every possible combination to connect these four nodes.\\n            if (adj[odd[0]].count(odd[1]) == 0 && adj[odd[2]].count(odd[3]) == 0)\\n                return true;\\n\\n            if (adj[odd[0]].count(odd[2]) == 0 && adj[odd[1]].count(odd[3]) == 0)\\n                return true;\\n\\n            if (adj[odd[0]].count(odd[3]) == 0 && adj[odd[1]].count(odd[2]) == 0)\\n                return true;\\n\\n            return false;\\n        }\\n        \\n        // any other cases are impossible.\\n         return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924534,
                "title": "c-code-explanation-with-pictures",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf asked to add atmost 2 edges only, then at max we can have only 4 such nodes whose degree is odd else it is not possible to make all nodes have even degrees.\\n\\nSo, think of cases when we have 1 such node only, 2 such nodes only, 3 such nodes only and 4 such nodes only.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nCase 1 & 3 : For only 1 such node and only 3 such nodes, we cannot draw an edge (since it requires 2 & 4 nodes respectively to draw edge)\\n\\nCase 2: For only 2 such nodes, we can have 2 cases :\\n        \\ncase a - these 2 nodes are not connected to each other\\ncase b - these 2 nodes are connected to each other\\n        \\ncase a :- \\n\\nIf they are not connected then, they must have a third node different from these 2 nodes to which they can connect or they can even be connected with an edge to each other.\\n\\nscenario should be something like this\\n\\n![1.png](https://assets.leetcode.com/users/images/020d8691-8987-418c-b4e3-627fba5ea587_1671349984.4784653.png)\\n\\n![Screenshot 2022-12-18 at 13.18.36.png](https://assets.leetcode.com/users/images/4fa62017-0106-49ad-b38f-fb3783dd870e_1671350044.139483.png)\\n\\n\\ncase b :-\\n\\nIf they are connected then, they can again have a 3rd node different from these 2 nodes to which they both can connect to. \\n\\nscenario should be something like this \\n\\n![2.png](https://assets.leetcode.com/users/images/13ab39ab-d1ec-43c2-b3c5-bf535bd6541c_1671350003.0836148.png)\\n\\n\\nIn both cases a & b, the condition that a 3rd node connected to both these nodes (connected and not connected) is common, hence this shall be the sufficient condition for Case 2.\\n\\nCase 4: For only 4 such nodes, here we have 2 cases\\n\\ncase a :-\\n\\nnone of the 4 nodes are connected, then 2 edges can connect any 2 out of 4 nodes in groups of 2 each\\n\\n![3.png](https://assets.leetcode.com/users/images/cac24ed9-4874-4178-a39b-7e296cfbd2a9_1671350116.1079154.png)\\n\\ncase b :-\\n\\n2 of these 4 nodes are connected to each other, then 2 edges can connect the 2 nodes that are not connected to each other\\n\\n![4.png](https://assets.leetcode.com/users/images/72afdda4-f87e-4fbd-b968-e1c7d6a71b1e_1671350125.2602406.png)\\n\\nIn all the rest cases it is impossible to make the degree of nodes even by adding at most 2 edges.\\n\\n\\n<!-- # Complexity\\n- Time complexity:\\n\\nO()\\n\\n- Space complexity:\\nAdd your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        map<pair<int,int>,bool> exists;\\n        \\n        for (auto z : edges) {\\n            int x = z[0]-1;\\n            int y = z[1]-1;\\n            exists[{x,y}]=true;\\n            exists[{y,x}]=true;\\n        }\\n        \\n        vector<int> deg(n,0);\\n        \\n        for(auto x : edges){\\n            deg[x[0]-1]++;\\n            deg[x[1]-1]++;\\n        }\\n        \\n        int odd=0;\\n        vector<int> oddv;\\n        for(int i=0;i<n;i++){\\n            if(deg[i]%2==1) {\\n                odd++;\\n                oddv.push_back(i);\\n            }\\n        }\\n\\n        if (odd == 0) {\\n            return true;\\n        } else if (odd == 2) {\\n            int a = oddv[0];\\n            int b = oddv[1];\\n            for (int k = 0; k < n; k++) {\\n                if (!exists[{a,k}] && !exists[{b,k}]){\\n                    return true;\\n                }\\n            }\\n        } else if (odd == 4) {\\n            int a = oddv[0];\\n            int b = oddv[1];\\n            int c = oddv[2];\\n            int d = oddv[3];\\n            if ((!exists[{a,b}] && !exists[{c,d}]) || (!exists[{a,c}] && !exists[{b,d}]) || (!exists[{a,d}] && !exists[{b,c}])) {\\n               return true;\\n            }\\n        } \\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        map<pair<int,int>,bool> exists;\\n        \\n        for (auto z : edges) {\\n            int x = z[0]-1;\\n            int y = z[1]-1;\\n            exists[{x,y}]=true;\\n            exists[{y,x}]=true;\\n        }\\n        \\n        vector<int> deg(n,0);\\n        \\n        for(auto x : edges){\\n            deg[x[0]-1]++;\\n            deg[x[1]-1]++;\\n        }\\n        \\n        int odd=0;\\n        vector<int> oddv;\\n        for(int i=0;i<n;i++){\\n            if(deg[i]%2==1) {\\n                odd++;\\n                oddv.push_back(i);\\n            }\\n        }\\n\\n        if (odd == 0) {\\n            return true;\\n        } else if (odd == 2) {\\n            int a = oddv[0];\\n            int b = oddv[1];\\n            for (int k = 0; k < n; k++) {\\n                if (!exists[{a,k}] && !exists[{b,k}]){\\n                    return true;\\n                }\\n            }\\n        } else if (odd == 4) {\\n            int a = oddv[0];\\n            int b = oddv[1];\\n            int c = oddv[2];\\n            int d = oddv[3];\\n            if ((!exists[{a,b}] && !exists[{c,d}]) || (!exists[{a,c}] && !exists[{b,d}]) || (!exists[{a,d}] && !exists[{b,c}])) {\\n               return true;\\n            }\\n        } \\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924395,
                "title": "java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        ArrayList<Integer>[] adj = new ArrayList[n + 1];\\n        ArrayList<Integer> odd = new ArrayList<>();\\n        for(int i = 0; i <= n; i++){\\n            adj[i] = new ArrayList<>();\\n        }\\n        \\n        for(int i = 0; i < edges.size(); i++){\\n            int u = edges.get(i).get(0);\\n            int v = edges.get(i).get(1);\\n            adj[u].add(v);\\n            adj[v].add(u);\\n        }\\n\\n        //since we can draw only 2 edges so we can work with only 4 vertex\\n        for(int i = 1; i <= n; i++){\\n            if(adj[i].size() % 2 == 1){\\n                odd.add(i);\\n            }\\n        }\\n        // if(odd.size() == 1 || odd.size() == 3 || odd.size() > 4) return false;\\n        if(odd.size() == 0) return true;\\n        if(odd.size() == 2){\\n            int u = odd.get(0);\\n            int v = odd.get(1);\\n            if(adj[u].contains(v)){\\n                for(int i = 1; i <= n; i++){\\n                    if(i != u && i != v && !adj[i].contains(u) && !adj[i].contains(v)){\\n                        return true;\\n                    }\\n                }\\n                return false;\\n            }\\n            return true;\\n        }\\n\\n        if (odd.size() == 4) {\\n            int a = odd.get(0), b = odd.get(1), c = odd.get(2), d = odd.get(3); \\n            if (!adj[a].contains(b) && !adj[c].contains(d) || \\n                !adj[a].contains(c) && !adj[b].contains(d) || \\n                !adj[a].contains(d) && !adj[b].contains(c))\\n                    return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        ArrayList<Integer>[] adj = new ArrayList[n + 1];\\n        ArrayList<Integer> odd = new ArrayList<>();\\n        for(int i = 0; i <= n; i++){\\n            adj[i] = new ArrayList<>();\\n        }\\n        \\n        for(int i = 0; i < edges.size(); i++){\\n            int u = edges.get(i).get(0);\\n            int v = edges.get(i).get(1);\\n            adj[u].add(v);\\n            adj[v].add(u);\\n        }\\n\\n        //since we can draw only 2 edges so we can work with only 4 vertex\\n        for(int i = 1; i <= n; i++){\\n            if(adj[i].size() % 2 == 1){\\n                odd.add(i);\\n            }\\n        }\\n        // if(odd.size() == 1 || odd.size() == 3 || odd.size() > 4) return false;\\n        if(odd.size() == 0) return true;\\n        if(odd.size() == 2){\\n            int u = odd.get(0);\\n            int v = odd.get(1);\\n            if(adj[u].contains(v)){\\n                for(int i = 1; i <= n; i++){\\n                    if(i != u && i != v && !adj[i].contains(u) && !adj[i].contains(v)){\\n                        return true;\\n                    }\\n                }\\n                return false;\\n            }\\n            return true;\\n        }\\n\\n        if (odd.size() == 4) {\\n            int a = odd.get(0), b = odd.get(1), c = odd.get(2), d = odd.get(3); \\n            if (!adj[a].contains(b) && !adj[c].contains(d) || \\n                !adj[a].contains(c) && !adj[b].contains(d) || \\n                !adj[a].contains(d) && !adj[b].contains(c))\\n                    return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924382,
                "title": "constructive-algorithm-graph-easy-to-understand-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n\\n        unordered_map<int, unordered_set<int>> G;\\n        vector<int> odd;\\n\\n        for(auto it : edges){\\n            G[it[0]].insert(it[1]);\\n            G[it[1]].insert(it[0]);\\n        }\\n\\n        for(auto it : G){\\n            if(it.second.size() & 0x1){\\n                odd.push_back(it.first);\\n            }\\n        }\\n\\n        if(!odd.size()){\\n            return true;\\n        }\\n        else if(odd.size() > 4 || (odd.size() & 0x1)){\\n            return false;\\n        }\\n        else if(odd.size() == 2){\\n            if(G[odd[0]].find(odd[1]) == G[odd[0]].end()){\\n                return true;\\n            }\\n            for(int i = 1; i <= n; ++i){\\n                if(i == odd[0] || i == odd[1] || G[i].size() & 0x1){\\n                    continue;\\n                }\\n                if(G[i].find(odd[0]) == G[i].end() && G[i].find(odd[1]) == G[i].end()){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        else{\\n            if(G[odd[0]].find(odd[1]) == G[odd[0]].end() && G[odd[2]].find(odd[3]) == G[odd[2]].end()){\\n                return true;\\n            }\\n            if(G[odd[0]].find(odd[2]) == G[odd[0]].end() && G[odd[1]].find(odd[3]) == G[odd[2]].end()){\\n                return true;\\n            }\\n            if(G[odd[0]].find(odd[3]) == G[odd[0]].end() && G[odd[2]].find(odd[1]) == G[odd[2]].end()){\\n                return true;\\n            }\\n            bool f01, f02, f03, f12, f13, f23;\\n            f01 = f02 = f03 = f12 = f13 = f23 = false;\\n            for(int i = 1; i <= n; ++i){\\n                if(G[i].size() % 2 == 0){\\n                    if(i != odd[0] && i != odd[1] && G[i].find(odd[0]) == G[i].end() && G[i].find(odd[1]) == G[i].end()){\\n                        f01 = true;\\n                    }\\n                    if(i != odd[0] && i != odd[2] && G[i].find(odd[0]) == G[i].end() && G[i].find(odd[2]) == G[i].end()){\\n                        f02 = true;\\n                    }\\n                    if(i != odd[0] && i != odd[3] && G[i].find(odd[0]) == G[i].end() && G[i].find(odd[3]) == G[i].end()){\\n                        f03 = true;\\n                    }\\n                    if(i != odd[1] && i != odd[2] && G[i].find(odd[1]) == G[i].end() && G[i].find(odd[2]) == G[i].end()){\\n                        f12 = true;\\n                    }\\n                    if(i != odd[1] && i != odd[3] && G[i].find(odd[1]) == G[i].end() && G[i].find(odd[3]) == G[i].end()){\\n                        f13 = true;\\n                    }\\n                    if(i != odd[2] && i != odd[3] && G[i].find(odd[2]) == G[i].end() && G[i].find(odd[3]) == G[i].end()){\\n                        f23 = true;\\n                    }\\n                }\\n            }\\n            return (f01 && f23) || (f02 && f13) || (f03 && f12);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n\\n        unordered_map<int, unordered_set<int>> G;\\n        vector<int> odd;\\n\\n        for(auto it : edges){\\n            G[it[0]].insert(it[1]);\\n            G[it[1]].insert(it[0]);\\n        }\\n\\n        for(auto it : G){\\n            if(it.second.size() & 0x1){\\n                odd.push_back(it.first);\\n            }\\n        }\\n\\n        if(!odd.size()){\\n            return true;\\n        }\\n        else if(odd.size() > 4 || (odd.size() & 0x1)){\\n            return false;\\n        }\\n        else if(odd.size() == 2){\\n            if(G[odd[0]].find(odd[1]) == G[odd[0]].end()){\\n                return true;\\n            }\\n            for(int i = 1; i <= n; ++i){\\n                if(i == odd[0] || i == odd[1] || G[i].size() & 0x1){\\n                    continue;\\n                }\\n                if(G[i].find(odd[0]) == G[i].end() && G[i].find(odd[1]) == G[i].end()){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        else{\\n            if(G[odd[0]].find(odd[1]) == G[odd[0]].end() && G[odd[2]].find(odd[3]) == G[odd[2]].end()){\\n                return true;\\n            }\\n            if(G[odd[0]].find(odd[2]) == G[odd[0]].end() && G[odd[1]].find(odd[3]) == G[odd[2]].end()){\\n                return true;\\n            }\\n            if(G[odd[0]].find(odd[3]) == G[odd[0]].end() && G[odd[2]].find(odd[1]) == G[odd[2]].end()){\\n                return true;\\n            }\\n            bool f01, f02, f03, f12, f13, f23;\\n            f01 = f02 = f03 = f12 = f13 = f23 = false;\\n            for(int i = 1; i <= n; ++i){\\n                if(G[i].size() % 2 == 0){\\n                    if(i != odd[0] && i != odd[1] && G[i].find(odd[0]) == G[i].end() && G[i].find(odd[1]) == G[i].end()){\\n                        f01 = true;\\n                    }\\n                    if(i != odd[0] && i != odd[2] && G[i].find(odd[0]) == G[i].end() && G[i].find(odd[2]) == G[i].end()){\\n                        f02 = true;\\n                    }\\n                    if(i != odd[0] && i != odd[3] && G[i].find(odd[0]) == G[i].end() && G[i].find(odd[3]) == G[i].end()){\\n                        f03 = true;\\n                    }\\n                    if(i != odd[1] && i != odd[2] && G[i].find(odd[1]) == G[i].end() && G[i].find(odd[2]) == G[i].end()){\\n                        f12 = true;\\n                    }\\n                    if(i != odd[1] && i != odd[3] && G[i].find(odd[1]) == G[i].end() && G[i].find(odd[3]) == G[i].end()){\\n                        f13 = true;\\n                    }\\n                    if(i != odd[2] && i != odd[3] && G[i].find(odd[2]) == G[i].end() && G[i].find(odd[3]) == G[i].end()){\\n                        f23 = true;\\n                    }\\n                }\\n            }\\n            return (f01 && f23) || (f02 && f13) || (f03 && f12);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924326,
                "title": "c-fully-commented-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>> adj(n + 1); // adjacency list\\n        \\n        for(auto a : edges) {\\n            adj[a[0]].push_back(a[1]);\\n            adj[a[1]].push_back(a[0]);\\n        }\\n        \\n        vector<int> odd; // nodes with odd degree\\n        vector<int> even; // nodes with even degree\\n        \\n        for(int i = 1 ; i <= n ; i++) {\\n            if(adj[i].size() % 2)\\n                odd.push_back(i);\\n            else\\n                even.push_back(i);\\n        }\\n        \\n        int os = odd.size(); // no. of nodes with odd degree\\n        \\n        if(os == 0) // there is no node with odd degree\\n            return true;\\n        else if(os == 2) \\n        {\\n            int a = odd[0] , b = odd[1];\\n\\n            // if direct edge is possible b/w these 2 vertices\\n            if(find(adj[a].begin() , adj[a].end() , b) == adj[a].end())\\n                return true; \\n            else\\n            {\\n                // checking if there is any node which does not have an edge with any of these 2 odd degree nodes, \\n                // so we can make 2 edges between that node and each of these 2 odd degree nodes \\n                // this will keep the degree of that node even only as we are adding 2 edges to it\\n                // and it will make the degree of our 2 odd degree nodes as even because we are adding 1 edge each to them\\n                \\n                for(int i = 1 ; i <= n && i != odd[0] && i != odd[1] ; i++)\\n                {\\n                    if(find(adj[i].begin() , adj[i].end() , odd[0]) == adj[i].end() && find(adj[i].begin() , adj[i].end() , odd[1]) == adj[i].end())\\n                        return true;\\n                }\\n            }\\n            return false;\\n        }\\n        else if(os == 4) \\n        {\\n            int a = odd[0] , b = odd[1] , c = odd[2] , d = odd[3];\\n            if(find(adj[a].begin() , adj[a].end() , b) == adj[a].end() && find(adj[c].begin() , adj[c].end() , d) == adj[c].end())\\n                return true; // if we can make the edges a-b and c-d\\n            else if(find(adj[a].begin() , adj[a].end() , c) == adj[a].end() && find(adj[b].begin() , adj[b].end() , d) == adj[b].end())\\n                return true; // if we can make the edges a-c and b-d\\n            else if(find(adj[a].begin() , adj[a].end() , d) == adj[a].end() && find(adj[b].begin() , adj[b].end() , c) == adj[b].end())\\n                return true; // if we can make the edges a-d and b-c\\n            else\\n                return false;\\n        }\\n        \\n        // if the no. of nodes with odd degree is odd or it is greater than 4, then making all degrees as even is not possible\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>> adj(n + 1); // adjacency list\\n        \\n        for(auto a : edges) {\\n            adj[a[0]].push_back(a[1]);\\n            adj[a[1]].push_back(a[0]);\\n        }\\n        \\n        vector<int> odd; // nodes with odd degree\\n        vector<int> even; // nodes with even degree\\n        \\n        for(int i = 1 ; i <= n ; i++) {\\n            if(adj[i].size() % 2)\\n                odd.push_back(i);\\n            else\\n                even.push_back(i);\\n        }\\n        \\n        int os = odd.size(); // no. of nodes with odd degree\\n        \\n        if(os == 0) // there is no node with odd degree\\n            return true;\\n        else if(os == 2) \\n        {\\n            int a = odd[0] , b = odd[1];\\n\\n            // if direct edge is possible b/w these 2 vertices\\n            if(find(adj[a].begin() , adj[a].end() , b) == adj[a].end())\\n                return true; \\n            else\\n            {\\n                // checking if there is any node which does not have an edge with any of these 2 odd degree nodes, \\n                // so we can make 2 edges between that node and each of these 2 odd degree nodes \\n                // this will keep the degree of that node even only as we are adding 2 edges to it\\n                // and it will make the degree of our 2 odd degree nodes as even because we are adding 1 edge each to them\\n                \\n                for(int i = 1 ; i <= n && i != odd[0] && i != odd[1] ; i++)\\n                {\\n                    if(find(adj[i].begin() , adj[i].end() , odd[0]) == adj[i].end() && find(adj[i].begin() , adj[i].end() , odd[1]) == adj[i].end())\\n                        return true;\\n                }\\n            }\\n            return false;\\n        }\\n        else if(os == 4) \\n        {\\n            int a = odd[0] , b = odd[1] , c = odd[2] , d = odd[3];\\n            if(find(adj[a].begin() , adj[a].end() , b) == adj[a].end() && find(adj[c].begin() , adj[c].end() , d) == adj[c].end())\\n                return true; // if we can make the edges a-b and c-d\\n            else if(find(adj[a].begin() , adj[a].end() , c) == adj[a].end() && find(adj[b].begin() , adj[b].end() , d) == adj[b].end())\\n                return true; // if we can make the edges a-c and b-d\\n            else if(find(adj[a].begin() , adj[a].end() , d) == adj[a].end() && find(adj[b].begin() , adj[b].end() , c) == adj[b].end())\\n                return true; // if we can make the edges a-d and b-c\\n            else\\n                return false;\\n        }\\n        \\n        // if the no. of nodes with odd degree is odd or it is greater than 4, then making all degrees as even is not possible\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924303,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n + n_edges)\\n * Space Complexity: O(n + n_edges)\\n * where `n_edges` is the length of the vector `edges`\\n */\\nclass Solution {\\n public:\\n  bool isPossible(const int n, const vector<vector<int>> &edges) {\\n    unordered_set<int> graph[n];\\n    int degrees[n];\\n    memset(degrees, 0, sizeof(degrees));\\n    for (const vector<int> &edge : edges) {\\n      const int node1 = edge[0] - 1;\\n      const int node2 = edge[1] - 1;\\n      graph[node1].emplace(node2);\\n      graph[node2].emplace(node1);\\n      ++degrees[node1];\\n      ++degrees[node2];\\n    }\\n    \\n    vector<int> nodes_of_odd_degrees;\\n    for (int i = 0; i < n; ++i) {\\n      if (degrees[i] % 2 == 1) {\\n        nodes_of_odd_degrees.emplace_back(i);\\n      }\\n    }\\n    \\n    if (nodes_of_odd_degrees.empty()) {\\n      return true;\\n    }\\n    if (nodes_of_odd_degrees.size() != 2 && nodes_of_odd_degrees.size() != 4) {\\n      return false;\\n    }\\n    if (nodes_of_odd_degrees.size() == 2) {\\n      const int node1 = nodes_of_odd_degrees[0];\\n      const int node2 = nodes_of_odd_degrees[1];\\n      if (graph[node1].find(node2) == graph[node1].end()) {\\n        return true;\\n      }\\n      \\n      for (int node = 0; node < n; ++node) {\\n        if (node == node1 || node == node2) {\\n          continue;\\n        }\\n        \\n        if (graph[node].find(node1) == graph[node].end() && graph[node].find(node2) == graph[node].end()) {\\n          return true;\\n        }\\n      }\\n      return false;\\n    }\\n    // nodes_of_odd_degrees.size() == 4\\n    const int node1 = nodes_of_odd_degrees[0];\\n    const int node2 = nodes_of_odd_degrees[1];\\n    const int node3 = nodes_of_odd_degrees[2];\\n    const int node4 = nodes_of_odd_degrees[3];\\n    return (graph[node1].find(node2) == graph[node1].end() && graph[node3].find(node4) == graph[node3].end()) ||\\n           (graph[node1].find(node3) == graph[node1].end() && graph[node2].find(node4) == graph[node2].end()) ||\\n           (graph[node1].find(node4) == graph[node1].end() && graph[node2].find(node3) == graph[node2].end());\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n + n_edges)\\n * Space Complexity: O(n + n_edges)\\n * where `n_edges` is the length of the vector `edges`\\n */\\nclass Solution {\\n public:\\n  bool isPossible(const int n, const vector<vector<int>> &edges) {\\n    unordered_set<int> graph[n];\\n    int degrees[n];\\n    memset(degrees, 0, sizeof(degrees));\\n    for (const vector<int> &edge : edges) {\\n      const int node1 = edge[0] - 1;\\n      const int node2 = edge[1] - 1;\\n      graph[node1].emplace(node2);\\n      graph[node2].emplace(node1);\\n      ++degrees[node1];\\n      ++degrees[node2];\\n    }\\n    \\n    vector<int> nodes_of_odd_degrees;\\n    for (int i = 0; i < n; ++i) {\\n      if (degrees[i] % 2 == 1) {\\n        nodes_of_odd_degrees.emplace_back(i);\\n      }\\n    }\\n    \\n    if (nodes_of_odd_degrees.empty()) {\\n      return true;\\n    }\\n    if (nodes_of_odd_degrees.size() != 2 && nodes_of_odd_degrees.size() != 4) {\\n      return false;\\n    }\\n    if (nodes_of_odd_degrees.size() == 2) {\\n      const int node1 = nodes_of_odd_degrees[0];\\n      const int node2 = nodes_of_odd_degrees[1];\\n      if (graph[node1].find(node2) == graph[node1].end()) {\\n        return true;\\n      }\\n      \\n      for (int node = 0; node < n; ++node) {\\n        if (node == node1 || node == node2) {\\n          continue;\\n        }\\n        \\n        if (graph[node].find(node1) == graph[node].end() && graph[node].find(node2) == graph[node].end()) {\\n          return true;\\n        }\\n      }\\n      return false;\\n    }\\n    // nodes_of_odd_degrees.size() == 4\\n    const int node1 = nodes_of_odd_degrees[0];\\n    const int node2 = nodes_of_odd_degrees[1];\\n    const int node3 = nodes_of_odd_degrees[2];\\n    const int node4 = nodes_of_odd_degrees[3];\\n    return (graph[node1].find(node2) == graph[node1].end() && graph[node3].find(node4) == graph[node3].end()) ||\\n           (graph[node1].find(node3) == graph[node1].end() && graph[node2].find(node4) == graph[node2].end()) ||\\n           (graph[node1].find(node4) == graph[node1].end() && graph[node2].find(node3) == graph[node2].end());\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924295,
                "title": "c-solution",
                "content": "# Intuition\\nThere cannot be more than 4 odd degree nodes. So we can use a brute force approach to try to connect them with every possible candidate.\\n\\n# Approach\\nJust find all the odd nodes and try to connect them with some other node.\\n\\n# Complexity\\n- Time complexity:\\nRoughly $$O(n)$$\\n\\n- Space complexity:\\nRoughly $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  bool comb(int i, vector<unordered_set<int>>& graph,\\n            vector<int>& even, vector<bool>& takenEven,\\n            vector<int>& odd, vector<bool>& takenOdd) {\\n    if (i >= odd.size()) return true;\\n    if (takenOdd[i]) return comb(i + 1, graph, even, takenEven, odd, takenOdd);\\n    takenOdd[i] = true;\\n    for (int j = 0; j < odd.size(); ++j) {\\n      if (takenOdd[j]) continue;\\n      if (graph[odd[i]].find(odd[j]) != graph[odd[i]].end()) continue;\\n      takenOdd[j] = true;\\n      bool possible = comb(i + 1, graph, even, takenEven, odd, takenOdd);\\n      takenOdd[j] = false;\\n      if (possible) {\\n          takenOdd[i] = false;\\n          return true;\\n      }\\n    }\\n    for (int j = 0; j < even.size(); ++j) {\\n      if (takenEven[j]) continue;\\n      if (graph[odd[i]].find(even[j]) != graph[odd[i]].end()) continue;\\n      takenEven[j] = true;\\n      odd.push_back(even[j]);\\n      takenOdd.push_back(false);\\n      bool possible = comb(i + 1, graph, even, takenEven, odd, takenOdd);\\n      odd.pop_back();\\n      takenOdd.pop_back();\\n      takenEven[j] = false;\\n      if (possible) {\\n          takenOdd[i] = false;\\n          return true;\\n      }\\n    }\\n    takenOdd[i] = false;\\n    return false;\\n  }\\n  \\n  bool isPossible(int n, vector<vector<int>>& edges) {\\n    vector<unordered_set<int>> graph(n + 1);\\n    for (auto& e : edges) {\\n      graph[e[0]].insert(e[1]);\\n      graph[e[1]].insert(e[0]);\\n    }\\n    int numOdd = 0;\\n    vector<int> odd, even;\\n    for (int i = 1; i <= n; ++i) {\\n      int deg = graph[i].size();\\n      if (deg % 2 == 0) {\\n        even.push_back(i);\\n        continue;\\n      }\\n      odd.push_back(i);\\n      numOdd++;\\n    }\\n    if (numOdd > 4) return false;\\n    vector<bool> takenOdd(odd.size(), false);\\n    vector<bool> takenEven(even.size(), false);\\n    return comb(0, graph, even, takenEven, odd, takenOdd);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  bool comb(int i, vector<unordered_set<int>>& graph,\\n            vector<int>& even, vector<bool>& takenEven,\\n            vector<int>& odd, vector<bool>& takenOdd) {\\n    if (i >= odd.size()) return true;\\n    if (takenOdd[i]) return comb(i + 1, graph, even, takenEven, odd, takenOdd);\\n    takenOdd[i] = true;\\n    for (int j = 0; j < odd.size(); ++j) {\\n      if (takenOdd[j]) continue;\\n      if (graph[odd[i]].find(odd[j]) != graph[odd[i]].end()) continue;\\n      takenOdd[j] = true;\\n      bool possible = comb(i + 1, graph, even, takenEven, odd, takenOdd);\\n      takenOdd[j] = false;\\n      if (possible) {\\n          takenOdd[i] = false;\\n          return true;\\n      }\\n    }\\n    for (int j = 0; j < even.size(); ++j) {\\n      if (takenEven[j]) continue;\\n      if (graph[odd[i]].find(even[j]) != graph[odd[i]].end()) continue;\\n      takenEven[j] = true;\\n      odd.push_back(even[j]);\\n      takenOdd.push_back(false);\\n      bool possible = comb(i + 1, graph, even, takenEven, odd, takenOdd);\\n      odd.pop_back();\\n      takenOdd.pop_back();\\n      takenEven[j] = false;\\n      if (possible) {\\n          takenOdd[i] = false;\\n          return true;\\n      }\\n    }\\n    takenOdd[i] = false;\\n    return false;\\n  }\\n  \\n  bool isPossible(int n, vector<vector<int>>& edges) {\\n    vector<unordered_set<int>> graph(n + 1);\\n    for (auto& e : edges) {\\n      graph[e[0]].insert(e[1]);\\n      graph[e[1]].insert(e[0]);\\n    }\\n    int numOdd = 0;\\n    vector<int> odd, even;\\n    for (int i = 1; i <= n; ++i) {\\n      int deg = graph[i].size();\\n      if (deg % 2 == 0) {\\n        even.push_back(i);\\n        continue;\\n      }\\n      odd.push_back(i);\\n      numOdd++;\\n    }\\n    if (numOdd > 4) return false;\\n    vector<bool> takenOdd(odd.size(), false);\\n    vector<bool> takenEven(even.size(), false);\\n    return comb(0, graph, even, takenEven, odd, takenOdd);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924294,
                "title": "java-count-degree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(E + N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(E + N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//Runtime: 173 ms, 33%; Memory: 134.9MB 83%\\n    //Time: O(E + N); Space: O(E + N)\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        List<Set<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i <= n; i++) graph.add(new HashSet<>());\\n\\n        int[] counter = new int[n + 1];\\n\\n        for(List<Integer> edge : edges) {\\n            Set<Integer> set0 = graph.get(edge.get(0));\\n            set0.add(edge.get(1));\\n\\n            Set<Integer> set1= graph.get(edge.get(1));\\n            set1.add(edge.get(0));\\n\\n            counter[edge.get(0)]++;\\n            counter[edge.get(1)]++;\\n        }\\n\\n        List<Integer> oddNode = new ArrayList<>();\\n        for (int i = 1; i <= n; i++)\\n            if (counter[i] % 2 != 0) oddNode.add(i);\\n\\n        if (oddNode.size() == 0) return true;\\n        if (oddNode.size() != 2 && oddNode.size() != 4) return false;\\n\\n        return oddNode.size() == 2 ? helper_2nodes(graph, n, counter, oddNode) : helper_4nodes(graph, oddNode);\\n    }\\n\\n    static int[][] offsets = new int[][]{{0,1,2,3}, {0,2,1,3},{0,3,1,2}};\\n    private boolean helper_4nodes(List<Set<Integer>> graph, List<Integer> oddNode){\\n        for(int[] offset: offsets){\\n            if (!graph.get(oddNode.get(offset[0])).contains(oddNode.get(offset[1]))\\n                && !graph.get(oddNode.get(offset[2])).contains(oddNode.get(offset[3])))\\n                    return true;\\n        }\\n        return false;\\n    }\\n\\n    private boolean helper_2nodes(List<Set<Integer>> graph, int n, int[] counter, List<Integer> oddNode){\\n        if (!graph.get(oddNode.get(0)).contains(oddNode.get(1)))\\n            return true;\\n\\n        for (int i = 1; i <= n; i++) {\\n            if (i == oddNode.get(0) || i == oddNode.get(1)) continue;\\n            if (counter[i] >= n - 2) continue;\\n            Set<Integer> set = graph.get(i);\\n            if (!set.contains(oddNode.get(0)) && !set.contains(oddNode.get(1)))\\n                return true;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//Runtime: 173 ms, 33%; Memory: 134.9MB 83%\\n    //Time: O(E + N); Space: O(E + N)\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        List<Set<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i <= n; i++) graph.add(new HashSet<>());\\n\\n        int[] counter = new int[n + 1];\\n\\n        for(List<Integer> edge : edges) {\\n            Set<Integer> set0 = graph.get(edge.get(0));\\n            set0.add(edge.get(1));\\n\\n            Set<Integer> set1= graph.get(edge.get(1));\\n            set1.add(edge.get(0));\\n\\n            counter[edge.get(0)]++;\\n            counter[edge.get(1)]++;\\n        }\\n\\n        List<Integer> oddNode = new ArrayList<>();\\n        for (int i = 1; i <= n; i++)\\n            if (counter[i] % 2 != 0) oddNode.add(i);\\n\\n        if (oddNode.size() == 0) return true;\\n        if (oddNode.size() != 2 && oddNode.size() != 4) return false;\\n\\n        return oddNode.size() == 2 ? helper_2nodes(graph, n, counter, oddNode) : helper_4nodes(graph, oddNode);\\n    }\\n\\n    static int[][] offsets = new int[][]{{0,1,2,3}, {0,2,1,3},{0,3,1,2}};\\n    private boolean helper_4nodes(List<Set<Integer>> graph, List<Integer> oddNode){\\n        for(int[] offset: offsets){\\n            if (!graph.get(oddNode.get(offset[0])).contains(oddNode.get(offset[1]))\\n                && !graph.get(oddNode.get(offset[2])).contains(oddNode.get(offset[3])))\\n                    return true;\\n        }\\n        return false;\\n    }\\n\\n    private boolean helper_2nodes(List<Set<Integer>> graph, int n, int[] counter, List<Integer> oddNode){\\n        if (!graph.get(oddNode.get(0)).contains(oddNode.get(1)))\\n            return true;\\n\\n        for (int i = 1; i <= n; i++) {\\n            if (i == oddNode.get(0) || i == oddNode.get(1)) continue;\\n            if (counter[i] >= n - 2) continue;\\n            Set<Integer> set = graph.get(i);\\n            if (!set.contains(oddNode.get(0)) && !set.contains(oddNode.get(1)))\\n                return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2924290,
                "title": "simple-java-code-with-comments",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n         List<List<Integer>> adjList= new ArrayList<>();\\n         for(int i= 0; i < n + 1;i++){\\n            adjList.add(new ArrayList<>()); \\n         }\\n         for(List<Integer> a: edges){\\n             adjList.get(a.get(0)).add(a.get(1));\\n             adjList.get(a.get(1)).add(a.get(0));\\n         }\\n         List<Integer> oddDegreeNodes = new ArrayList<>();\\n         for(int i = 0; i < n + 1 ; i++){\\n              if(adjList.get(i).size() %2 == 1)\\n                 oddDegreeNodes.add(i);\\n         }\\n         if(oddDegreeNodes.size() == 0) return true;\\n         if(oddDegreeNodes.size() == 2){\\n            int node1 = oddDegreeNodes.get(0),node2 = oddDegreeNodes.get(1);\\n            // check connecting node1 & node 2\\n            if(!adjList.get(node1).contains(node2) || !adjList.get(node2).contains(node1)) return true;\\n             // check connecting node which does not contains node1 & node2\\n             //both node1 & node2 will be even degree and other node i will remain even\\n            for(int i = 1; i < n + 1; i++){\\n               if(i != node1 && i != node2 && !adjList.get(i).contains(node1) && !adjList.get(i).contains(node2)){\\n                  return true;\\n               }\\n            }\\n         }\\n         if(oddDegreeNodes.size() == 4){\\n            int node1 = oddDegreeNodes.get(0),node2 = oddDegreeNodes.get(1), \\n                  node3 = oddDegreeNodes.get(2), node4 = oddDegreeNodes.get(3);\\n            //node 1 + node 2 && node 3 + node 4\\n            if(!adjList.get(node1).contains(node2) && !adjList.get(node2).contains(node1)  && \\n                 !adjList.get(node3).contains(node4) && !adjList.get(node4).contains(node3)) return true;\\n             //node 1 + node 3 && node 2 + node 4\\n            if(!adjList.get(node1).contains(node3) && !adjList.get(node3).contains(node1)  && \\n                 !adjList.get(node2).contains(node4) && !adjList.get(node4).contains(node2)) return true;\\n             //node 1 + node 4 && node 2 + node 3\\n            if(!adjList.get(node1).contains(node4) && !adjList.get(node4).contains(node1)  && \\n                 !adjList.get(node2).contains(node3) && !adjList.get(node3).contains(node2)) return true;\\n         }\\n         // will return false in odd number of nodes with odd degree\\n         return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n         List<List<Integer>> adjList= new ArrayList<>();\\n         for(int i= 0; i < n + 1;i++){\\n            adjList.add(new ArrayList<>()); \\n         }\\n         for(List<Integer> a: edges){\\n             adjList.get(a.get(0)).add(a.get(1));\\n             adjList.get(a.get(1)).add(a.get(0));\\n         }\\n         List<Integer> oddDegreeNodes = new ArrayList<>();\\n         for(int i = 0; i < n + 1 ; i++){\\n              if(adjList.get(i).size() %2 == 1)\\n                 oddDegreeNodes.add(i);\\n         }\\n         if(oddDegreeNodes.size() == 0) return true;\\n         if(oddDegreeNodes.size() == 2){\\n            int node1 = oddDegreeNodes.get(0),node2 = oddDegreeNodes.get(1);\\n            // check connecting node1 & node 2\\n            if(!adjList.get(node1).contains(node2) || !adjList.get(node2).contains(node1)) return true;\\n             // check connecting node which does not contains node1 & node2\\n             //both node1 & node2 will be even degree and other node i will remain even\\n            for(int i = 1; i < n + 1; i++){\\n               if(i != node1 && i != node2 && !adjList.get(i).contains(node1) && !adjList.get(i).contains(node2)){\\n                  return true;\\n               }\\n            }\\n         }\\n         if(oddDegreeNodes.size() == 4){\\n            int node1 = oddDegreeNodes.get(0),node2 = oddDegreeNodes.get(1), \\n                  node3 = oddDegreeNodes.get(2), node4 = oddDegreeNodes.get(3);\\n            //node 1 + node 2 && node 3 + node 4\\n            if(!adjList.get(node1).contains(node2) && !adjList.get(node2).contains(node1)  && \\n                 !adjList.get(node3).contains(node4) && !adjList.get(node4).contains(node3)) return true;\\n             //node 1 + node 3 && node 2 + node 4\\n            if(!adjList.get(node1).contains(node3) && !adjList.get(node3).contains(node1)  && \\n                 !adjList.get(node2).contains(node4) && !adjList.get(node4).contains(node2)) return true;\\n             //node 1 + node 4 && node 2 + node 3\\n            if(!adjList.get(node1).contains(node4) && !adjList.get(node4).contains(node1)  && \\n                 !adjList.get(node2).contains(node3) && !adjList.get(node3).contains(node2)) return true;\\n         }\\n         // will return false in odd number of nodes with odd degree\\n         return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924274,
                "title": "java-solution-odd-degree-0-2-4",
                "content": "```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        int[] degree = new int[n+1];\\n        Set<Integer>[] graph = new HashSet[n+1];\\n        for (int i = 1; i <= n; i++) {\\n            graph[i] = new HashSet<>();\\n        }\\n        for (List<Integer> e: edges) {\\n            int a = e.get(0), b = e.get(1);\\n            degree[a] += 1;\\n            degree[b] += 1;\\n            graph[a].add(b);\\n            graph[b].add(a);\\n        }\\n        List<Integer> o = new ArrayList<>();\\n        List<Integer> ev = new ArrayList<>();\\n        for (int i = 1; i <= n; i++) {\\n            if (degree[i] % 2 != 0) {\\n                o.add(i);\\n            } else {\\n                ev.add(i);\\n            }\\n        }\\n        int k = o.size();\\n        if (k == 0) {\\n            return true;\\n        }\\n        if (k != 2 && k != 4) {\\n            return false;\\n        }\\n        if (k == 2) {\\n            int a = o.get(0), b = o.get(1);\\n            if (!graph[a].contains(b) && !graph[b].contains(a)) {\\n                return true;\\n            }\\n            for (int i: ev) {\\n                if (!graph[a].contains(i) && !graph[b].contains(i) && !graph[i].contains(a) && !graph[i].contains(b)) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        // k == 4\\n        for (int i = 0; i < 3; i++) {\\n            for (int j = i+1; j < 4; j++) {\\n                int a = o.get(i), b = o.get(j);\\n                if (degree[a] % 2 == 0 || degree[b] % 2 == 0) {\\n                    continue;\\n                }\\n                if (graph[a].contains(b) || graph[b].contains(a)) {\\n                    continue;\\n                }\\n                k -= 2;\\n                graph[a].add(b);\\n                graph[b].add(a);\\n                degree[a] += 1;\\n                degree[b] += 1;\\n            }\\n        }\\n        return k == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        int[] degree = new int[n+1];\\n        Set<Integer>[] graph = new HashSet[n+1];\\n        for (int i = 1; i <= n; i++) {\\n            graph[i] = new HashSet<>();\\n        }\\n        for (List<Integer> e: edges) {\\n            int a = e.get(0), b = e.get(1);\\n            degree[a] += 1;\\n            degree[b] += 1;\\n            graph[a].add(b);\\n            graph[b].add(a);\\n        }\\n        List<Integer> o = new ArrayList<>();\\n        List<Integer> ev = new ArrayList<>();\\n        for (int i = 1; i <= n; i++) {\\n            if (degree[i] % 2 != 0) {\\n                o.add(i);\\n            } else {\\n                ev.add(i);\\n            }\\n        }\\n        int k = o.size();\\n        if (k == 0) {\\n            return true;\\n        }\\n        if (k != 2 && k != 4) {\\n            return false;\\n        }\\n        if (k == 2) {\\n            int a = o.get(0), b = o.get(1);\\n            if (!graph[a].contains(b) && !graph[b].contains(a)) {\\n                return true;\\n            }\\n            for (int i: ev) {\\n                if (!graph[a].contains(i) && !graph[b].contains(i) && !graph[i].contains(a) && !graph[i].contains(b)) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        // k == 4\\n        for (int i = 0; i < 3; i++) {\\n            for (int j = i+1; j < 4; j++) {\\n                int a = o.get(i), b = o.get(j);\\n                if (degree[a] % 2 == 0 || degree[b] % 2 == 0) {\\n                    continue;\\n                }\\n                if (graph[a].contains(b) || graph[b].contains(a)) {\\n                    continue;\\n                }\\n                k -= 2;\\n                graph[a].add(b);\\n                graph[b].add(a);\\n                degree[a] += 1;\\n                degree[b] += 1;\\n            }\\n        }\\n        return k == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924259,
                "title": "python-solution-tried-to-explain-with-diagrams-image",
                "content": "# Intuition and Approach\\nWe need to find how many nodes contains odd edges..\\nNode with 1,3,5.. are odd edges.\\nNode with no edge is even.\\n\\nLimit is we can use almost 2 edges i.e. 0 or 1 or 2 edges can be used to connect any 2 nodes that are not connected yet.\\n\\n```\\nCASE 1:\\n```\\n\\nSo, first case is there are zero nodes with odd edges:\\nwe just return True.\\n```\\nCASE 2:\\n```\\nThere are 1 node or 3 nodes with odd edges:\\nWe will staright return False .. cause its not possible to give unique even connections(edges to them).\\n\\n```\\nCASE 3:\\n```\\n\\nOdd edges nodes = 2\\nThere are two subcases:\\n\\n$$$sub-case1:$$$ if both nodes are connected to each other.\\n            \\nIn this case we need to find a particular node(even edges) to connect them and then everyone will have even nodes.\\nAnd return True.\\n![image.png](https://assets.leetcode.com/users/images/28dd8f00-686e-402c-9899-03a203a43abc_1671344144.6442244.png)\\n\\n$$$sub-Case2:$$$\\nIf these are not connected to each other:\\n![image.png](https://assets.leetcode.com/users/images/1b12eb5c-bc47-4d95-aa9b-5c6fdb3bd7bd_1671344320.2700608.png)\\nwe will check if these are not connected to each other .. \\nand hence return True cause these can be connected.\\n\\n\\nWe have keep a check that there are no self loops:\\n![image.png](https://assets.leetcode.com/users/images/cd5e7d11-e98b-4be5-a91f-548175f20338_1671344418.7164183.png) \\n\\n\\n``` -->```\\n\\n```\\nCASE 4:\\n```\\n\\n\\nwhen number of odd nodes is 4:\\nlets say n1, n2, n3, n4 are these nodes:\\nif any of these 2 doesnt connec any other two, \\nthen only we return True \\nelse false.\\n![image.png](https://assets.leetcode.com/users/images/44563338-0043-4933-acad-39164f255b79_1671344880.6135442.png)\\n```-->```\\n``` # Case 5:```\\nnumber of odd nodes>4:\\nwe cannot connect all these with the limitation on using atmost 2 connections. \\nreturn False.\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        dic = defaultdict(set)\\n        \\n        //mapping all connections\\n        for n1,n2 in edges:\\n            dic[n1].add(n2)\\n            dic[n2].add(n1)\\n        \\n        //seeking number of odd-edges nodes and adding them to a list\\n        oddNodes = []\\n        for i in dic:\\n            if len(dic[i])%2==1:\\n                oddNodes.append(i)\\n\\n        //now the conditions\\n        lod=len(oddNodes)   \\n\\n        //case1:\\n        if lod==0:\\n            return True\\n        //case2 and case 5:\\n        elif lod==1 or lod==3 or lod>4:\\n            return False\\n\\n        //case3:\\n        elif lod==2:\\n            n1=oddNodes[0] \\n            n2= oddNodes[1]\\n            if n1 not in dic[n2]:\\n                return True\\n            for i in dic:\\n                if n1 not in dic[i] and n2 not in dic[i]:\\n                    return True\\n        //case4:\\n        elif lod==4:\\n            n1=oddNodes[0]\\n            n2 = oddNodes[1]\\n            n3 = oddNodes[2]\\n            n4 = oddNodes[3]\\n            \\n            if n1 not in dic[n2] and n3 not in dic[n4]:\\n                return True\\n            elif n1 not in dic[n3] and n2 not in dic[n4]:\\n                return True\\n            elif n1 not in dic[n4] and n2 not in dic[n3]:\\n                return True\\n        return False\\n            \\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nCASE 1:\\n```\n```\\nCASE 2:\\n```\n```\\nCASE 3:\\n```\n``` -->```\n```\\nCASE 4:\\n```\n```-->```\n``` # Case 5:```\n```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        dic = defaultdict(set)\\n        \\n        //mapping all connections\\n        for n1,n2 in edges:\\n            dic[n1].add(n2)\\n            dic[n2].add(n1)\\n        \\n        //seeking number of odd-edges nodes and adding them to a list\\n        oddNodes = []\\n        for i in dic:\\n            if len(dic[i])%2==1:\\n                oddNodes.append(i)\\n\\n        //now the conditions\\n        lod=len(oddNodes)   \\n\\n        //case1:\\n        if lod==0:\\n            return True\\n        //case2 and case 5:\\n        elif lod==1 or lod==3 or lod>4:\\n            return False\\n\\n        //case3:\\n        elif lod==2:\\n            n1=oddNodes[0] \\n            n2= oddNodes[1]\\n            if n1 not in dic[n2]:\\n                return True\\n            for i in dic:\\n                if n1 not in dic[i] and n2 not in dic[i]:\\n                    return True\\n        //case4:\\n        elif lod==4:\\n            n1=oddNodes[0]\\n            n2 = oddNodes[1]\\n            n3 = oddNodes[2]\\n            n4 = oddNodes[3]\\n            \\n            if n1 not in dic[n2] and n3 not in dic[n4]:\\n                return True\\n            elif n1 not in dic[n3] and n2 not in dic[n4]:\\n                return True\\n            elif n1 not in dic[n4] and n2 not in dic[n3]:\\n                return True\\n        return False\\n            \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924178,
                "title": "python-simple-solution-beats-100-just-count-the-number-of-degrees-with-odd-degrees",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this by making an adjacency list and finding out degrees of individual vertices\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe make an Adjacency list ```graph = defaultdict(set)```, which is basically a HashMap of HashSets to find out the degrees of individual vertices\\n1. Now, atmost 2 edges can be added. Which means, degree of only 4 vertices can be increased. So, we return ```False``` if the vertices with odd degrees are more than 4.\\n2. We return ```False``` if the number of vertices with odd degrees is odd. If we add an edge, the degrees increase in pairs.\\n3. Next, we check if the components we are connecting are already connected or not. Firstly for the case where there are 2 vertices with odd degrees and Secondly when there are 4 vertices with odd degrees\\n\\n# Complexity\\n- Time complexity: $$O(V + E)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(V + E)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        graph, numOddDegreeVertices = defaultdict(set), []\\n        for src, dst in edges:\\n            graph[src].add(dst)\\n            graph[dst].add(src)\\n        for node in graph:\\n            if len(graph[node]) & 1:\\n                numOddDegreeVertices.append(node)\\n            if len(numOddDegreeVertices) > 4:\\n                return False\\n        if len(numOddDegreeVertices) & 1:\\n            return False\\n        if len(numOddDegreeVertices) == 0:\\n            return True \\n        if  len(numOddDegreeVertices) == 2:\\n            if  numOddDegreeVertices[0] not in graph[numOddDegreeVertices[1]]:\\n                return True \\n            if len(graph[numOddDegreeVertices[1]].union(graph[numOddDegreeVertices[1]])) < n - 1:\\n                return True \\n            return False\\n        if numOddDegreeVertices[0] not in graph[numOddDegreeVertices[1]] and numOddDegreeVertices[2] not in graph[numOddDegreeVertices[3]]:\\n            return True \\n        if numOddDegreeVertices[0] not in graph[numOddDegreeVertices[2]] and numOddDegreeVertices[1] not in graph[numOddDegreeVertices[3]]:\\n            return True\\n        if numOddDegreeVertices[0] not in graph[numOddDegreeVertices[3]] and numOddDegreeVertices[2] not in graph[numOddDegreeVertices[1]]:\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```graph = defaultdict(set)```\n```False```\n```False```\n```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        graph, numOddDegreeVertices = defaultdict(set), []\\n        for src, dst in edges:\\n            graph[src].add(dst)\\n            graph[dst].add(src)\\n        for node in graph:\\n            if len(graph[node]) & 1:\\n                numOddDegreeVertices.append(node)\\n            if len(numOddDegreeVertices) > 4:\\n                return False\\n        if len(numOddDegreeVertices) & 1:\\n            return False\\n        if len(numOddDegreeVertices) == 0:\\n            return True \\n        if  len(numOddDegreeVertices) == 2:\\n            if  numOddDegreeVertices[0] not in graph[numOddDegreeVertices[1]]:\\n                return True \\n            if len(graph[numOddDegreeVertices[1]].union(graph[numOddDegreeVertices[1]])) < n - 1:\\n                return True \\n            return False\\n        if numOddDegreeVertices[0] not in graph[numOddDegreeVertices[1]] and numOddDegreeVertices[2] not in graph[numOddDegreeVertices[3]]:\\n            return True \\n        if numOddDegreeVertices[0] not in graph[numOddDegreeVertices[2]] and numOddDegreeVertices[1] not in graph[numOddDegreeVertices[3]]:\\n            return True\\n        if numOddDegreeVertices[0] not in graph[numOddDegreeVertices[3]] and numOddDegreeVertices[2] not in graph[numOddDegreeVertices[1]]:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924144,
                "title": "java-solution-graph-hashmap-bfs-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int additionLeft = 2;\\n\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        // graph + hashmap + bfs + greedy\\n        Map<Integer, Set<Integer>> nodeEdges = new HashMap<>(); // <node, adjs>\\n        for (int i=1; i<=n; i++) nodeEdges.put(i, new HashSet<>());\\n        for (List<Integer> edge : edges) {\\n            int nodeA = edge.get(0); int nodeB = edge.get(1);\\n            nodeEdges.get(nodeA).add(nodeB);\\n            nodeEdges.get(nodeB).add(nodeA);\\n        }\\n        \\n        Set<Integer> queue = new HashSet<>(); // nodes to processed\\n        for (Map.Entry<Integer, Set<Integer>> entry : nodeEdges.entrySet()) {\\n            if (entry.getValue().size() % 2 != 0) queue.add(entry.getKey());\\n        }\\n        \\n        if (queue.size() % 2 != 0 || queue.size() > 4) return false;\\n\\n        while (!queue.isEmpty() && additionLeft-- > 0) {\\n            int toProcessNode = queue.iterator().next();\\n            int mapNode = findMapNode(toProcessNode, queue, nodeEdges);\\n            if (mapNode == -1) return false;\\n\\n            nodeEdges.get(toProcessNode).add(mapNode);\\n            nodeEdges.get(mapNode).add(toProcessNode);\\n            queue.remove(toProcessNode);\\n\\n            if (queue.contains(mapNode)) queue.remove(mapNode);\\n            else queue.add(mapNode);\\n        }\\n        if (queue.isEmpty()) return true;\\n        else return false;\\n    }\\n\\n    private int findMapNode(int toProcessNode, Set<Integer> queue, Map<Integer, Set<Integer>> nodeEdges) {\\n        for (int curOdd : queue) {\\n            if (curOdd == toProcessNode) continue;\\n            if (!nodeEdges.get(toProcessNode).contains(curOdd)) return curOdd;\\n        }\\n        for (int i=1; i<=nodeEdges.size(); i++) {\\n            if (i == toProcessNode || queue.contains(i)) continue;\\n            if (!nodeEdges.get(toProcessNode).contains(i)) return i; // curEven\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int additionLeft = 2;\\n\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        // graph + hashmap + bfs + greedy\\n        Map<Integer, Set<Integer>> nodeEdges = new HashMap<>(); // <node, adjs>\\n        for (int i=1; i<=n; i++) nodeEdges.put(i, new HashSet<>());\\n        for (List<Integer> edge : edges) {\\n            int nodeA = edge.get(0); int nodeB = edge.get(1);\\n            nodeEdges.get(nodeA).add(nodeB);\\n            nodeEdges.get(nodeB).add(nodeA);\\n        }\\n        \\n        Set<Integer> queue = new HashSet<>(); // nodes to processed\\n        for (Map.Entry<Integer, Set<Integer>> entry : nodeEdges.entrySet()) {\\n            if (entry.getValue().size() % 2 != 0) queue.add(entry.getKey());\\n        }\\n        \\n        if (queue.size() % 2 != 0 || queue.size() > 4) return false;\\n\\n        while (!queue.isEmpty() && additionLeft-- > 0) {\\n            int toProcessNode = queue.iterator().next();\\n            int mapNode = findMapNode(toProcessNode, queue, nodeEdges);\\n            if (mapNode == -1) return false;\\n\\n            nodeEdges.get(toProcessNode).add(mapNode);\\n            nodeEdges.get(mapNode).add(toProcessNode);\\n            queue.remove(toProcessNode);\\n\\n            if (queue.contains(mapNode)) queue.remove(mapNode);\\n            else queue.add(mapNode);\\n        }\\n        if (queue.isEmpty()) return true;\\n        else return false;\\n    }\\n\\n    private int findMapNode(int toProcessNode, Set<Integer> queue, Map<Integer, Set<Integer>> nodeEdges) {\\n        for (int curOdd : queue) {\\n            if (curOdd == toProcessNode) continue;\\n            if (!nodeEdges.get(toProcessNode).contains(curOdd)) return curOdd;\\n        }\\n        for (int i=1; i<=nodeEdges.size(); i++) {\\n            if (i == toProcessNode || queue.contains(i)) continue;\\n            if (!nodeEdges.get(toProcessNode).contains(i)) return i; // curEven\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924045,
                "title": "python-list-of-dictionary-o-edges-time-and-o-edges-space",
                "content": "```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        # Atmost 4 nodes with odd degree, nodes should be even with odd degrees [0,2,4]\\n        \\n        # Then make pair of among themselves and those shouldn\\'t be connected\\n        # print(sorted(edges))\\n        \\n        graph = [set() for i in range(n)]\\n        for src,dst in edges:\\n            graph[src-1].add(dst-1)\\n            graph[dst-1].add(src-1)\\n            \\n        num_odd_degree_set = []\\n        for i in range(n): \\n            if not len(graph[i])%2==0:\\n                num_odd_degree_set.append(i)\\n            if len(num_odd_degree_set)>4:\\n                return False \\n        \\n        # print(num_odd_degree_set)\\n        \\n        if not len(num_odd_degree_set)%2==0:\\n            return False \\n        \\n        \\n        if len(num_odd_degree_set)==0:\\n            return True \\n        if  len(num_odd_degree_set)==2:\\n            if  num_odd_degree_set[0] not in graph[num_odd_degree_set[1]]: # Make a list \\n                return True \\n            \\n            if len(graph[num_odd_degree_set[1]].union(graph[num_odd_degree_set[1]]))<n-1:\\n                return True \\n            \\n            return False\\n    \\n        if num_odd_degree_set[0] not in graph[num_odd_degree_set[1]] and num_odd_degree_set[2] not in graph[num_odd_degree_set[3]]:\\n            return True \\n        \\n        if num_odd_degree_set[0] not in graph[num_odd_degree_set[2]] and num_odd_degree_set[1] not in graph[num_odd_degree_set[3]]:\\n            return True\\n            \\n        if num_odd_degree_set[0] not in graph[num_odd_degree_set[3]] and num_odd_degree_set[2] not in graph[num_odd_degree_set[1]]:\\n            return True\\n            \\n        \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        # Atmost 4 nodes with odd degree, nodes should be even with odd degrees [0,2,4]\\n        \\n        # Then make pair of among themselves and those shouldn\\'t be connected\\n        # print(sorted(edges))\\n        \\n        graph = [set() for i in range(n)]\\n        for src,dst in edges:\\n            graph[src-1].add(dst-1)\\n            graph[dst-1].add(src-1)\\n            \\n        num_odd_degree_set = []\\n        for i in range(n): \\n            if not len(graph[i])%2==0:\\n                num_odd_degree_set.append(i)\\n            if len(num_odd_degree_set)>4:\\n                return False \\n        \\n        # print(num_odd_degree_set)\\n        \\n        if not len(num_odd_degree_set)%2==0:\\n            return False \\n        \\n        \\n        if len(num_odd_degree_set)==0:\\n            return True \\n        if  len(num_odd_degree_set)==2:\\n            if  num_odd_degree_set[0] not in graph[num_odd_degree_set[1]]: # Make a list \\n                return True \\n            \\n            if len(graph[num_odd_degree_set[1]].union(graph[num_odd_degree_set[1]]))<n-1:\\n                return True \\n            \\n            return False\\n    \\n        if num_odd_degree_set[0] not in graph[num_odd_degree_set[1]] and num_odd_degree_set[2] not in graph[num_odd_degree_set[3]]:\\n            return True \\n        \\n        if num_odd_degree_set[0] not in graph[num_odd_degree_set[2]] and num_odd_degree_set[1] not in graph[num_odd_degree_set[3]]:\\n            return True\\n            \\n        if num_odd_degree_set[0] not in graph[num_odd_degree_set[3]] and num_odd_degree_set[2] not in graph[num_odd_degree_set[1]]:\\n            return True\\n            \\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924024,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: O(N + M) N - nodes, M - edges\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N + M) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        \\n        HashSet<Integer>[] adj = new HashSet[n];\\n        IntStream.range(0, n).forEach(x -> adj[x] = new HashSet());\\n        int[] degree = new int[n];\\n        \\n        for(int i = 0; i < edges.size(); i++) {\\n            adj[edges.get(i).get(0) - 1].add(edges.get(i).get(1) - 1);\\n            adj[edges.get(i).get(1) - 1].add(edges.get(i).get(0) - 1);\\n            degree[edges.get(i).get(0) - 1]++;\\n            degree[edges.get(i).get(1) - 1]++;\\n        }\\n        \\n        ArrayList<Integer> oddDegList = new ArrayList();\\n        for(int i = 0; i < n; i++) {\\n            if(degree[i]%2 == 1)\\n                oddDegList.add(i);\\n        }\\n        \\n        if(oddDegList.size() > 4 || oddDegList.size()%2 == 1)\\n            return false;\\n        if(oddDegList.size() == 0)\\n            return true;\\n        else if(oddDegList.size() == 4)\\n            return fourOddDegreeCheck(adj, oddDegList, degree);\\n        else \\n            return twoOddDegreeCheck(adj, oddDegList.get(0), oddDegList.get(1), degree);\\n    }\\n    \\n    public boolean twoOddDegreeCheck( HashSet<Integer>[] adj, int n1, int n2, int[] degree) {\\n        \\n        if(!adj[n1].contains(n2))\\n            return true;\\n        \\n        for(int i = 0; i < adj.length; i++) {\\n            if(i != n1 && i != n2 && degree[i]%2 == 0 && !adj[i].contains(n1) && !adj[i].contains(n2)) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean fourOddDegreeCheck( HashSet<Integer>[] adj, ArrayList<Integer> list, int[] degree) {\\n        ArrayList<Integer> copy = (ArrayList<Integer>)list.clone();\\n        int n1 = 0, n2 = 0;\\n        \\n        for(int i = 0; i < 3; i++) {\\n            for(int j = i + 1; j < 4; j++) {\\n                n1 = list.get(i); n2 = list.get(j);\\n                list.remove(j); list.remove(i);\\n                \\n                if(twoOddDegreeCheck(adj, n1, n2, degree) && twoOddDegreeCheck(adj, list.get(0), list.get(1), degree)) \\n                    return true;\\n                \\n                list = copy;\\n                copy = (ArrayList<Integer>)copy.clone();\\n                \\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        \\n        HashSet<Integer>[] adj = new HashSet[n];\\n        IntStream.range(0, n).forEach(x -> adj[x] = new HashSet());\\n        int[] degree = new int[n];\\n        \\n        for(int i = 0; i < edges.size(); i++) {\\n            adj[edges.get(i).get(0) - 1].add(edges.get(i).get(1) - 1);\\n            adj[edges.get(i).get(1) - 1].add(edges.get(i).get(0) - 1);\\n            degree[edges.get(i).get(0) - 1]++;\\n            degree[edges.get(i).get(1) - 1]++;\\n        }\\n        \\n        ArrayList<Integer> oddDegList = new ArrayList();\\n        for(int i = 0; i < n; i++) {\\n            if(degree[i]%2 == 1)\\n                oddDegList.add(i);\\n        }\\n        \\n        if(oddDegList.size() > 4 || oddDegList.size()%2 == 1)\\n            return false;\\n        if(oddDegList.size() == 0)\\n            return true;\\n        else if(oddDegList.size() == 4)\\n            return fourOddDegreeCheck(adj, oddDegList, degree);\\n        else \\n            return twoOddDegreeCheck(adj, oddDegList.get(0), oddDegList.get(1), degree);\\n    }\\n    \\n    public boolean twoOddDegreeCheck( HashSet<Integer>[] adj, int n1, int n2, int[] degree) {\\n        \\n        if(!adj[n1].contains(n2))\\n            return true;\\n        \\n        for(int i = 0; i < adj.length; i++) {\\n            if(i != n1 && i != n2 && degree[i]%2 == 0 && !adj[i].contains(n1) && !adj[i].contains(n2)) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean fourOddDegreeCheck( HashSet<Integer>[] adj, ArrayList<Integer> list, int[] degree) {\\n        ArrayList<Integer> copy = (ArrayList<Integer>)list.clone();\\n        int n1 = 0, n2 = 0;\\n        \\n        for(int i = 0; i < 3; i++) {\\n            for(int j = i + 1; j < 4; j++) {\\n                n1 = list.get(i); n2 = list.get(j);\\n                list.remove(j); list.remove(i);\\n                \\n                if(twoOddDegreeCheck(adj, n1, n2, degree) && twoOddDegreeCheck(adj, list.get(0), list.get(1), degree)) \\n                    return true;\\n                \\n                list = copy;\\n                copy = (ArrayList<Integer>)copy.clone();\\n                \\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924007,
                "title": "odd-degree-basic-intuition",
                "content": "# Intuition\\nMain intuition is that adding two edges is only posstion if we have 2 or 4 odd degree vertex. If we have 0 odd degree vertex then we can return true otherwise we can directly return false.\\n\\n# Approach\\n1. Now we have to pair up the vertices such that given condition satisfy.\\n\\n# Complexity\\n- Time complexity: O(N+E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N+E)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int>odd;\\n        vector<int>adj[n+1];\\n        unordered_set<int>st[n+1];\\n        for(auto &edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n            st[edge[1]].insert(edge[0]);\\n            st[edge[0]].insert(edge[1]);\\n        }\\n        for(int i = 1;i <= n;i++){\\n            if(adj[i].size()%2){\\n                odd.push_back(i);\\n            }\\n        }\\n        if(odd.size() > 4 or odd.size() == 3 or odd.size() == 1) return false;\\n        if(odd.size() == 0) return true;\\n        // cout << odd.size() << endl;\\n        // cout << odd[0] << \" \" << odd[1] << \" \" << odd[2] << \" \" << odd[3] << endl;\\n        if(odd.size() == 2){\\n            int a = odd[0];\\n            int b = odd[1];\\n            bool flag = false;\\n            for(auto &nbr:adj[a]){\\n                if(nbr == b){\\n                    flag = true;\\n                }\\n            }\\n            if(flag){\\n                for(int i = 1;i <= n;i++){\\n                    if(i == a or i == b) continue;\\n                    if(!st[a].count(i) and !st[b].count(i)) return true;\\n                }\\n                return false;\\n            }\\n            return true;\\n        }else{\\n            int a = odd[0];\\n            int b = odd[1];\\n            int c = odd[2];\\n            int d = odd[3];\\n            \\n            for(int i = 1;i <= n;i++){\\n                if(i == a or i == b or i == c or i == d) continue;\\n                if(!st[a].count(i) and !st[b].count(i) and !st[c].count(i) and !st[d].count(i)) return true;\\n            }\\n            \\n            if(!st[a].count(b)){\\n                if(!st[c].count(d)) return true;\\n            }\\n            if(!st[a].count(c)){\\n                if(!st[b].count(d)) return true;\\n            }\\n            if(!st[a].count(d)){\\n                if(!st[b].count(c)) return true;\\n            }\\n            return false;\\n            \\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int>odd;\\n        vector<int>adj[n+1];\\n        unordered_set<int>st[n+1];\\n        for(auto &edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n            st[edge[1]].insert(edge[0]);\\n            st[edge[0]].insert(edge[1]);\\n        }\\n        for(int i = 1;i <= n;i++){\\n            if(adj[i].size()%2){\\n                odd.push_back(i);\\n            }\\n        }\\n        if(odd.size() > 4 or odd.size() == 3 or odd.size() == 1) return false;\\n        if(odd.size() == 0) return true;\\n        // cout << odd.size() << endl;\\n        // cout << odd[0] << \" \" << odd[1] << \" \" << odd[2] << \" \" << odd[3] << endl;\\n        if(odd.size() == 2){\\n            int a = odd[0];\\n            int b = odd[1];\\n            bool flag = false;\\n            for(auto &nbr:adj[a]){\\n                if(nbr == b){\\n                    flag = true;\\n                }\\n            }\\n            if(flag){\\n                for(int i = 1;i <= n;i++){\\n                    if(i == a or i == b) continue;\\n                    if(!st[a].count(i) and !st[b].count(i)) return true;\\n                }\\n                return false;\\n            }\\n            return true;\\n        }else{\\n            int a = odd[0];\\n            int b = odd[1];\\n            int c = odd[2];\\n            int d = odd[3];\\n            \\n            for(int i = 1;i <= n;i++){\\n                if(i == a or i == b or i == c or i == d) continue;\\n                if(!st[a].count(i) and !st[b].count(i) and !st[c].count(i) and !st[d].count(i)) return true;\\n            }\\n            \\n            if(!st[a].count(b)){\\n                if(!st[c].count(d)) return true;\\n            }\\n            if(!st[a].count(c)){\\n                if(!st[b].count(d)) return true;\\n            }\\n            if(!st[a].count(d)){\\n                if(!st[b].count(c)) return true;\\n            }\\n            return false;\\n            \\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2923985,
                "title": "degree-count-explanation-of-scenarios",
                "content": "There are 4 cases here:\\n1. All degree are even then answer is **true**.\\n2.  Degree of exactly 2 nodes are odd. Answer: currently **undetermined**\\n3.  Degree of exactly 4 nodes are odd. Answer: currently **undetermined**\\n4.  All other case: Answer is **false**.\\n\\nNow, lets see **case 2** first: \\nif the 2 nodes with odd degree are already not connected to each other, then connect them, and we are done with **true** as our solution.\\nIf those 2 nodes already have edge b/w them then we have to find another node with **even** degree to which both nodes doesn\\'t have the edge. If found solution is **true** otherwise it is **false**\\nBut, all other nodes already have even degree, so even if you don\\'t apply the check, its fine.(recommended, but, I also have not done that in code below)\\n\\nNow, at **case 3**, there is no option for solution to be **true** unless 2 out of 4 nodes are connected to each other with new edge and other 2 are connected to each other with another new edge:\\nso let say those 4 nodes are **a**, **b**, **c**, **d** so solution will be **true** only if:\\n1. both **a** - **b** don\\'t have existing edge and **c** - **d** don\\'t have exisiting edge.\\n2. both **a** - **c** don\\'t have existing edge and **b** - **d** don\\'t have exisiting edge.\\n3. both **a** - **d** don\\'t have existing edge and **b** - **c** don\\'t have exisiting edge.\\n\\nAll other sub-case of this case 3 will be **false** as we only are allowed with **atmost** 2 edges.\\n\\nAlso, don\\'t forget to store all nodes to which any given node has edge as an hash_set. If you are going for 1-hot vector instead, it will give MLE.\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<unordered_set<int> > adj(n, unordered_set<int>());\\n        vector<int> deg(n, 0);\\n        for(vector<int> x : edges){\\n            adj[x[0]-1].insert(x[1]-1);\\n            adj[x[1]-1].insert(x[0]-1);\\n            deg[x[0] - 1]++;\\n            deg[x[1] - 1]++;\\n        }\\n        vector<int> s;\\n        for(int i = 0; i < n; i++){\\n            if(deg[i]%2 == 1) s.push_back(i);\\n        }\\n        if(s.size() == 0) return true;\\n        if(s.size() == 2 || s.size() == 4){\\n            if(s.size() == 2){\\n                for(int i = 0; i < adj.size(); i++){\\n                    if(adj[i].find(s[0]) == adj[i].end() && adj[i].find(s[1]) == adj[i].end()) return true;\\n                }\\n                return false;\\n            }\\n            else{\\n                if(adj[s[0]].find(s[1]) == adj[s[0]].end() && adj[s[2]].find(s[3]) == adj[s[2]].end()) return true;\\n                if(adj[s[0]].find(s[2]) == adj[s[0]].end() && adj[s[1]].find(s[3]) == adj[s[1]].end()) return true;\\n                if(adj[s[0]].find(s[3]) == adj[s[0]].end() && adj[s[1]].find(s[2]) == adj[s[1]].end()) return true;\\n                return false;\\n            }\\n        }\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<unordered_set<int> > adj(n, unordered_set<int>());\\n        vector<int> deg(n, 0);\\n        for(vector<int> x : edges){\\n            adj[x[0]-1].insert(x[1]-1);\\n            adj[x[1]-1].insert(x[0]-1);\\n            deg[x[0] - 1]++;\\n            deg[x[1] - 1]++;\\n        }\\n        vector<int> s;\\n        for(int i = 0; i < n; i++){\\n            if(deg[i]%2 == 1) s.push_back(i);\\n        }\\n        if(s.size() == 0) return true;\\n        if(s.size() == 2 || s.size() == 4){\\n            if(s.size() == 2){\\n                for(int i = 0; i < adj.size(); i++){\\n                    if(adj[i].find(s[0]) == adj[i].end() && adj[i].find(s[1]) == adj[i].end()) return true;\\n                }\\n                return false;\\n            }\\n            else{\\n                if(adj[s[0]].find(s[1]) == adj[s[0]].end() && adj[s[2]].find(s[3]) == adj[s[2]].end()) return true;\\n                if(adj[s[0]].find(s[2]) == adj[s[0]].end() && adj[s[1]].find(s[3]) == adj[s[1]].end()) return true;\\n                if(adj[s[0]].find(s[3]) == adj[s[0]].end() && adj[s[1]].find(s[2]) == adj[s[1]].end()) return true;\\n                return false;\\n            }\\n        }\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923950,
                "title": "java-map-brutal-force",
                "content": "```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for(List<Integer> l: edges){\\n            int s = l.get(0);\\n            int e = l.get(1);\\n            List<Integer> sl = map.getOrDefault(s, new ArrayList<>());\\n            sl.add(e);\\n            map.put(s, sl);\\n            \\n            List<Integer> el = map.getOrDefault(e, new ArrayList<>());\\n            el.add(s);\\n            map.put(e, el);\\n        }\\n        Set<Integer> set = new HashSet<>();\\n        List<Integer> l = new ArrayList<>();\\n        for(Map.Entry<Integer, List<Integer>> entry: map.entrySet()){\\n            int k = entry.getKey();\\n            int v = entry.getValue().size();\\n            if(v%2==1){\\n                set.add(k);\\n                l.add(k);\\n            }\\n        }\\n        int remain = 2;\\n        for(int i: l){\\n            if(!set.contains(i)){\\n                continue;\\n            }\\n            \\n            int p = getPos(i, map, n, set, remain);\\n            if(p==-1){\\n                return false;\\n            }\\n            set.remove(p);\\n            set.remove(i);\\n            if(map.containsKey(i) && map.get(i).contains(p)){\\n                remain--;\\n            }\\n            remain--;\\n            \\n            if(remain==0){\\n                break;\\n            }\\n        }\\n        return set.size()==0;\\n        \\n    }\\n    \\n    public int getPos(int i, Map<Integer, List<Integer>> map, int n, Set<Integer> set, int remain){\\n        int start = 1;\\n        List<Integer> l = map.getOrDefault(i, new ArrayList<>());\\n        while(start<=n){\\n            if(set.contains(start) && start!=i && (l==null || !l.contains(start))){\\n                return start;\\n            }\\n            start++;\\n        }\\n        for(int j: l){\\n            if(set.contains(j) && remain>1 && l.size() > 1 && l.size() < n-1){\\n                return j;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for(List<Integer> l: edges){\\n            int s = l.get(0);\\n            int e = l.get(1);\\n            List<Integer> sl = map.getOrDefault(s, new ArrayList<>());\\n            sl.add(e);\\n            map.put(s, sl);\\n            \\n            List<Integer> el = map.getOrDefault(e, new ArrayList<>());\\n            el.add(s);\\n            map.put(e, el);\\n        }\\n        Set<Integer> set = new HashSet<>();\\n        List<Integer> l = new ArrayList<>();\\n        for(Map.Entry<Integer, List<Integer>> entry: map.entrySet()){\\n            int k = entry.getKey();\\n            int v = entry.getValue().size();\\n            if(v%2==1){\\n                set.add(k);\\n                l.add(k);\\n            }\\n        }\\n        int remain = 2;\\n        for(int i: l){\\n            if(!set.contains(i)){\\n                continue;\\n            }\\n            \\n            int p = getPos(i, map, n, set, remain);\\n            if(p==-1){\\n                return false;\\n            }\\n            set.remove(p);\\n            set.remove(i);\\n            if(map.containsKey(i) && map.get(i).contains(p)){\\n                remain--;\\n            }\\n            remain--;\\n            \\n            if(remain==0){\\n                break;\\n            }\\n        }\\n        return set.size()==0;\\n        \\n    }\\n    \\n    public int getPos(int i, Map<Integer, List<Integer>> map, int n, Set<Integer> set, int remain){\\n        int start = 1;\\n        List<Integer> l = map.getOrDefault(i, new ArrayList<>());\\n        while(start<=n){\\n            if(set.contains(start) && start!=i && (l==null || !l.contains(start))){\\n                return start;\\n            }\\n            start++;\\n        }\\n        for(int j: l){\\n            if(set.contains(j) && remain>1 && l.size() > 1 && l.size() < n-1){\\n                return j;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923922,
                "title": "javascript-531ms",
                "content": "```\\nconst initializeGraphSet = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push(new Set()); } return g; };\\nconst packUG_Set = (g, edges) => { for (const [u, v] of edges) { g[u - 1].add(v - 1); g[v - 1].add(u - 1); } };\\n\\nconst isPossible = (n, edges) => {\\n    let g = initializeGraphSet(n);\\n    packUG_Set(g, edges);\\n    return canAddAtMost2EdgesMakeALLNodesDegreeEven(g);\\n};\\n\\nconst canAddAtMost2EdgesMakeALLNodesDegreeEven = (g) => {\\n    let oddNodes = [];\\n    for (let i = 0; i < g.length; i++) {\\n        let deg = g[i].size;\\n        if (deg % 2 == 1) {\\n            oddNodes.push(i);\\n        }\\n    }\\n    if (oddNodes.length == 0) { // add no edge\\n        return true;\\n    } else if (oddNodes.length == 2) { // add one edge\\n        let [a, b] = oddNodes;\\n        for (let k = 0; k < g.length; k++) { // a <-> k  b <-> k (k as transition node)\\n            if (!g[a].has(k) && !g[b].has(k)) return true;\\n        }\\n        return false;\\n    } else if (oddNodes.length == 4) { // add two edges\\n        let [a, b, c, d] = oddNodes; // find two matched pairs valid\\n        if (!g[a].has(b) && !g[c].has(d)) return true;\\n        if (!g[a].has(c) && !g[b].has(d)) return true;\\n        if (!g[a].has(d) && !g[c].has(b)) return true;\\n        return false;\\n    } else {\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Graph"
                ],
                "code": "```\\nconst initializeGraphSet = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push(new Set()); } return g; };\\nconst packUG_Set = (g, edges) => { for (const [u, v] of edges) { g[u - 1].add(v - 1); g[v - 1].add(u - 1); } };\\n\\nconst isPossible = (n, edges) => {\\n    let g = initializeGraphSet(n);\\n    packUG_Set(g, edges);\\n    return canAddAtMost2EdgesMakeALLNodesDegreeEven(g);\\n};\\n\\nconst canAddAtMost2EdgesMakeALLNodesDegreeEven = (g) => {\\n    let oddNodes = [];\\n    for (let i = 0; i < g.length; i++) {\\n        let deg = g[i].size;\\n        if (deg % 2 == 1) {\\n            oddNodes.push(i);\\n        }\\n    }\\n    if (oddNodes.length == 0) { // add no edge\\n        return true;\\n    } else if (oddNodes.length == 2) { // add one edge\\n        let [a, b] = oddNodes;\\n        for (let k = 0; k < g.length; k++) { // a <-> k  b <-> k (k as transition node)\\n            if (!g[a].has(k) && !g[b].has(k)) return true;\\n        }\\n        return false;\\n    } else if (oddNodes.length == 4) { // add two edges\\n        let [a, b, c, d] = oddNodes; // find two matched pairs valid\\n        if (!g[a].has(b) && !g[c].has(d)) return true;\\n        if (!g[a].has(c) && !g[b].has(d)) return true;\\n        if (!g[a].has(d) && !g[c].has(b)) return true;\\n        return false;\\n    } else {\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2923893,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        List<Integer> oddVertices = new ArrayList<>();\\n        Map<Integer, Set<Integer>> graph = new HashMap<>();        \\n        for (int i = 0; i < edges.size(); i++) {\\n            List<Integer> edge = edges.get(i);\\n            int start = edge.get(0);\\n            int end = edge.get(1);\\n            Set<Integer> startList;\\n            if (graph.containsKey(start)) {\\n                startList = graph.get(start);\\n            } else {\\n                startList = new HashSet<>();\\n            }\\n            startList.add(end);\\n            graph.put(start, startList);\\n            Set<Integer> endList;\\n            if (graph.containsKey(end)) {\\n                endList = graph.get(end);\\n            } else {\\n                endList = new HashSet<>();\\n            }\\n            endList.add(start);\\n            graph.put(end, endList);\\n        }\\n        for (Map.Entry<Integer, Set<Integer>> entry : graph.entrySet()) {\\n            int node = entry.getKey();\\n            Set<Integer> neighbors = entry.getValue();\\n            if (neighbors.size() % 2 == 1) {\\n                oddVertices.add(node);\\n            }\\n        }\\n        if (oddVertices.size() == 0) {\\n            return true;\\n        } \\n        if (oddVertices.size() == 2) {\\n            int node1 = oddVertices.get(0);\\n            int node2 = oddVertices.get(1);\\n            for (int i = 1; i <= n; i++) {\\n                if (!graph.get(node1).contains(i) && !graph.get(node2).contains(i)) {\\n                    return true;\\n                }\\n            }    \\n            return false;\\n        }\\n        if (oddVertices.size() == 4) {\\n            int node1 = oddVertices.get(0);\\n            int node2 = oddVertices.get(1);\\n            int node3 = oddVertices.get(2);\\n            int node4 = oddVertices.get(3);\\n            if (\\n                (!graph.get(node1).contains(node2) && !graph.get(node3).contains(node4)) ||\\n                (!graph.get(node1).contains(node3) && !graph.get(node2).contains(node4)) ||\\n                (!graph.get(node1).contains(node4) && !graph.get(node2).contains(node3))\\n               ) {\\n                return true;\\n            } else {\\n                return false;\\n            }   \\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        List<Integer> oddVertices = new ArrayList<>();\\n        Map<Integer, Set<Integer>> graph = new HashMap<>();        \\n        for (int i = 0; i < edges.size(); i++) {\\n            List<Integer> edge = edges.get(i);\\n            int start = edge.get(0);\\n            int end = edge.get(1);\\n            Set<Integer> startList;\\n            if (graph.containsKey(start)) {\\n                startList = graph.get(start);\\n            } else {\\n                startList = new HashSet<>();\\n            }\\n            startList.add(end);\\n            graph.put(start, startList);\\n            Set<Integer> endList;\\n            if (graph.containsKey(end)) {\\n                endList = graph.get(end);\\n            } else {\\n                endList = new HashSet<>();\\n            }\\n            endList.add(start);\\n            graph.put(end, endList);\\n        }\\n        for (Map.Entry<Integer, Set<Integer>> entry : graph.entrySet()) {\\n            int node = entry.getKey();\\n            Set<Integer> neighbors = entry.getValue();\\n            if (neighbors.size() % 2 == 1) {\\n                oddVertices.add(node);\\n            }\\n        }\\n        if (oddVertices.size() == 0) {\\n            return true;\\n        } \\n        if (oddVertices.size() == 2) {\\n            int node1 = oddVertices.get(0);\\n            int node2 = oddVertices.get(1);\\n            for (int i = 1; i <= n; i++) {\\n                if (!graph.get(node1).contains(i) && !graph.get(node2).contains(i)) {\\n                    return true;\\n                }\\n            }    \\n            return false;\\n        }\\n        if (oddVertices.size() == 4) {\\n            int node1 = oddVertices.get(0);\\n            int node2 = oddVertices.get(1);\\n            int node3 = oddVertices.get(2);\\n            int node4 = oddVertices.get(3);\\n            if (\\n                (!graph.get(node1).contains(node2) && !graph.get(node3).contains(node4)) ||\\n                (!graph.get(node1).contains(node3) && !graph.get(node2).contains(node4)) ||\\n                (!graph.get(node1).contains(node4) && !graph.get(node2).contains(node3))\\n               ) {\\n                return true;\\n            } else {\\n                return false;\\n            }   \\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923891,
                "title": "graph-logic",
                "content": "Cannot solve odd number nodes with odd degree ie (if there is only 1 node with odd degree or 3 nodes)\\n\\nfor 2 nodes with odd degree,\\nthere are 2 ways of solving\\n\\nif those 2 nodes are not connected directly join them problem solved.\\nelse\\nfind a even degree node that is not connected to both of them a connect both nodes to that even degree node\\nproblem solved\\n\\nfor 4 odd degree node,\\ntry out diffrent combination of connecting the nodes to  each other.\\n\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges)\\n    {\\n        vector<unordered_set<int>>adj(n+1);\\n        for(auto &e:edges)\\n        {\\n            adj[e[0]].insert(e[1]);\\n            adj[e[1]].insert(e[0]);\\n        }\\n        \\n        int count=0,a,b,c,d;\\n        for(int i=1;i<n+1;i++)\\n            if(adj[i].size()%2)\\n            {   \\n                count++;\\n                if(count==1)\\n                    a=i;\\n                else if(count==2)\\n                    b=i;\\n                else if(count==3)\\n                    c=i;\\n                else\\n                    d=i;\\n            }\\n        \\n        if(count%2 || count>4)\\n            return false;\\n        if(count==0)\\n            return true;\\n        \\n        if(count==2)\\n        {\\n            if(adj[a].find(b)==adj[a].end())\\n                return true;\\n            \\n            for(int i=1;i<n+1;i++)\\n            {\\n                if(adj[i].size()%2==0)\\n                {\\n                    if(adj[i].find(a)==adj[i].end() and adj[i].find(b)==adj[i].end())\\n                        return true;\\n                }\\n            }\\n            \\n            return false;\\n        }\\n        \\n        // count ==4\\n        \\n        if(adj[a].find(b)==adj[a].end() and adj[c].find(d)==adj[c].end())\\n            return true;\\n        \\n        if(adj[a].find(c)==adj[a].end() and adj[b].find(d)==adj[b].end())\\n            return true;\\n        \\n        if(adj[a].find(d)==adj[a].end() and adj[b].find(c)==adj[b].end())\\n            return true;\\n        \\n        return false;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges)\\n    {\\n        vector<unordered_set<int>>adj(n+1);\\n        for(auto &e:edges)\\n        {\\n            adj[e[0]].insert(e[1]);\\n            adj[e[1]].insert(e[0]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2923885,
                "title": "java-solution-using-hashmap",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(edges.length)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n ^ {2})$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\\n        for(int i = 1; i <= n; i++){\\n            graph.put(i, new HashSet<>());\\n        }\\n        for(List<Integer> edge : edges){\\n            graph.get(edge.get(0)).add(edge.get(1));\\n            graph.get(edge.get(1)).add(edge.get(0));\\n        }\\n        List<Integer> odd = new ArrayList<>();\\n        for(int i = 1; i <= n; i++){\\n            if(graph.get(i).size() % 2 == 1){\\n                if(odd.size() == 4){\\n                    return false;\\n                }\\n                else{\\n                    odd.add(i);\\n                }\\n            }\\n        }\\n        int odds = odd.size();\\n        if(odds == 0){\\n            return true;\\n        }\\n        else if(odds == 1 || odds == 3){\\n            return false;\\n        }\\n        else if(odds == 2){\\n            int v1 = odd.get(0);\\n            int v2 = odd.get(1);\\n            if(!graph.get(v1).contains(v2)){\\n                return true;\\n            }else{\\n                for(int i = 1; i <= n; i++){\\n                    if(graph.get(i).size() % 2 == 0 && !graph.get(i).contains(v1) && !graph.get(i).contains(v2)){\\n                        return true;\\n                    }\\n                }\\n                return false;\\n            }\\n        }\\n        else{\\n            int v1 = odd.get(0);\\n            int v2 = odd.get(1);\\n            int v3 = odd.get(2);\\n            int v4 = odd.get(3);\\n            if(!graph.get(v1).contains(v2) && !graph.get(v3).contains(v4)){\\n                return true;\\n            }else if(!graph.get(v1).contains(v3) && !graph.get(v2).contains(v4)){\\n                return true;\\n            }else if(!graph.get(v1).contains(v4) && !graph.get(v2).contains(v3)){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\\n        for(int i = 1; i <= n; i++){\\n            graph.put(i, new HashSet<>());\\n        }\\n        for(List<Integer> edge : edges){\\n            graph.get(edge.get(0)).add(edge.get(1));\\n            graph.get(edge.get(1)).add(edge.get(0));\\n        }\\n        List<Integer> odd = new ArrayList<>();\\n        for(int i = 1; i <= n; i++){\\n            if(graph.get(i).size() % 2 == 1){\\n                if(odd.size() == 4){\\n                    return false;\\n                }\\n                else{\\n                    odd.add(i);\\n                }\\n            }\\n        }\\n        int odds = odd.size();\\n        if(odds == 0){\\n            return true;\\n        }\\n        else if(odds == 1 || odds == 3){\\n            return false;\\n        }\\n        else if(odds == 2){\\n            int v1 = odd.get(0);\\n            int v2 = odd.get(1);\\n            if(!graph.get(v1).contains(v2)){\\n                return true;\\n            }else{\\n                for(int i = 1; i <= n; i++){\\n                    if(graph.get(i).size() % 2 == 0 && !graph.get(i).contains(v1) && !graph.get(i).contains(v2)){\\n                        return true;\\n                    }\\n                }\\n                return false;\\n            }\\n        }\\n        else{\\n            int v1 = odd.get(0);\\n            int v2 = odd.get(1);\\n            int v3 = odd.get(2);\\n            int v4 = odd.get(3);\\n            if(!graph.get(v1).contains(v2) && !graph.get(v3).contains(v4)){\\n                return true;\\n            }else if(!graph.get(v1).contains(v3) && !graph.get(v2).contains(v4)){\\n                return true;\\n            }else if(!graph.get(v1).contains(v4) && !graph.get(v2).contains(v3)){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923883,
                "title": "c-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCount nt how many odd degree nodes if cnt=0 then we need not do anything.If cnt=2 then we can find any node which is not connected to both or also try if both these are connected to each other . If cnt=4 as we are allowed only twp edges check if any of the combination taking two at a time is connected or not. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) Build Adj list and indegree for all nodes\\n2) find nodes with odd degree\\n3) check count of odd degree nodes \\n    a) if cnt==0 need not do anything\\n    b) if cnt==2 find a common node which is not connected to both (will increase it\\'s degree by 2) or connect each other each will increase the degree by 1.\\n    c) if cnt==4. As only two allowed connections .Try to find any combination if not already a connection.   \\n# Complexity\\n- Time complexity:\\n$$O(E+V)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> indegree(n+1,0);\\n        unordered_set<int> adj[n+1];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][1]].insert(edges[i][0]);\\n            adj[edges[i][0]].insert(edges[i][1]);\\n            indegree[edges[i][0]]++;\\n            indegree[edges[i][1]]++;\\n        }\\n        int cnt=0;\\n        vector<int> val;\\n        for(int i=1;i<=n;i++){\\n            if(indegree[i]%2){\\n                val.push_back(i);\\n                cnt++;\\n            }\\n        }\\n        if(cnt==0)\\n            return true;\\n        if(cnt==2){\\n            for(int k=1;k<=n;k++){\\n                if(adj[val[0]].find(k)==adj[val[0]].end()&&adj[val[1]].find(k)==adj[val[1]].end())\\n                    return true;\\n            }\\n        }\\n        if(cnt==4){\\n            if((adj[val[0]].find(val[1])==adj[val[0]].end()&&adj[val[2]].find(val[3])==adj[val[2]].end())||\\n              (adj[val[0]].find(val[2])==adj[val[0]].end()&&adj[val[1]].find(val[3])==adj[val[1]].end())||\\n              (adj[val[0]].find(val[3])==adj[val[0]].end()&&adj[val[1]].find(val[2])==adj[val[1]].end()))\\n                return true;\\n            \\n        }\\n        return false;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> indegree(n+1,0);\\n        unordered_set<int> adj[n+1];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][1]].insert(edges[i][0]);\\n            adj[edges[i][0]].insert(edges[i][1]);\\n            indegree[edges[i][0]]++;\\n            indegree[edges[i][1]]++;\\n        }\\n        int cnt=0;\\n        vector<int> val;\\n        for(int i=1;i<=n;i++){\\n            if(indegree[i]%2){\\n                val.push_back(i);\\n                cnt++;\\n            }\\n        }\\n        if(cnt==0)\\n            return true;\\n        if(cnt==2){\\n            for(int k=1;k<=n;k++){\\n                if(adj[val[0]].find(k)==adj[val[0]].end()&&adj[val[1]].find(k)==adj[val[1]].end())\\n                    return true;\\n            }\\n        }\\n        if(cnt==4){\\n            if((adj[val[0]].find(val[1])==adj[val[0]].end()&&adj[val[2]].find(val[3])==adj[val[2]].end())||\\n              (adj[val[0]].find(val[2])==adj[val[0]].end()&&adj[val[1]].find(val[3])==adj[val[1]].end())||\\n              (adj[val[0]].find(val[3])==adj[val[0]].end()&&adj[val[1]].find(val[2])==adj[val[1]].end()))\\n                return true;\\n            \\n        }\\n        return false;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923870,
                "title": "straightforward-approach-in-js-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {boolean}\\n */\\nvar isPossible = function(n, edges) {\\n    let obj = {}\\n    // make an obj that where { node: [edges] }\\n    for (let i = 0; i < edges.length; i++) {\\n        let edge1 = edges[i][0]\\n        let edge2 = edges[i][1]\\n\\n        if (obj[edge1]) {\\n            obj[edge1].push(edge2)\\n        } else {\\n            obj[edge1] = [edge2]\\n        }\\n        if (obj[edge2.toString()]) {\\n           obj[edge2].push(edge1)\\n        } else {\\n            obj[edge2] = [edge1]\\n        }\\n    }\\n    \\n    let odds = 0\\n    let success = true\\n    let candidates = []\\n    // find the immediate fail criteria & candidates for adding 1 or 2 edges to\\n    Object.keys(obj).forEach(k => {\\n        if (obj[k].length === n - 1 && obj[k].length % 2 != 0) {\\n            success = false\\n        }\\n        if (obj[k].length < n - 1 && obj[k].length % 2 != 0) {\\n            candidates.push(Number(k))\\n            odds++\\n        }\\n    })\\n    // one node has odd edges and you can\\'t add any more edges to it\\n    if (!success) { return false }\\n    // can add 2 or 1 edge to respectively\\n    if (odds === 0 || odds === 2) { return true }\\n    // can be true under certain conditions, if there are\\n    // certain amounts of already existing edges\\n    if (odds === 4) {\\n        let count = 0\\n        for (let i = 0; i < candidates.length; i++) {\\n            for (let j = i+1; j < candidates.length; j++) {\\n                if ((obj[candidates[i]]).find(v => v === candidates[j])) {\\n                    count++\\n                }\\n            }\\n        }\\n        return count === 0 || count === 2  || count === 4 || count === 1\\n    }\\n\\n    return false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {boolean}\\n */\\nvar isPossible = function(n, edges) {\\n    let obj = {}\\n    // make an obj that where { node: [edges] }\\n    for (let i = 0; i < edges.length; i++) {\\n        let edge1 = edges[i][0]\\n        let edge2 = edges[i][1]\\n\\n        if (obj[edge1]) {\\n            obj[edge1].push(edge2)\\n        } else {\\n            obj[edge1] = [edge2]\\n        }\\n        if (obj[edge2.toString()]) {\\n           obj[edge2].push(edge1)\\n        } else {\\n            obj[edge2] = [edge1]\\n        }\\n    }\\n    \\n    let odds = 0\\n    let success = true\\n    let candidates = []\\n    // find the immediate fail criteria & candidates for adding 1 or 2 edges to\\n    Object.keys(obj).forEach(k => {\\n        if (obj[k].length === n - 1 && obj[k].length % 2 != 0) {\\n            success = false\\n        }\\n        if (obj[k].length < n - 1 && obj[k].length % 2 != 0) {\\n            candidates.push(Number(k))\\n            odds++\\n        }\\n    })\\n    // one node has odd edges and you can\\'t add any more edges to it\\n    if (!success) { return false }\\n    // can add 2 or 1 edge to respectively\\n    if (odds === 0 || odds === 2) { return true }\\n    // can be true under certain conditions, if there are\\n    // certain amounts of already existing edges\\n    if (odds === 4) {\\n        let count = 0\\n        for (let i = 0; i < candidates.length; i++) {\\n            for (let j = i+1; j < candidates.length; j++) {\\n                if ((obj[candidates[i]]).find(v => v === candidates[j])) {\\n                    count++\\n                }\\n            }\\n        }\\n        return count === 0 || count === 2  || count === 4 || count === 1\\n    }\\n\\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2923863,
                "title": "a-simple-approach-with-degree-count",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate `adjacency list` from graph and `find all edges with odd degree`\\nThen -\\n1) if `length 0` return `true`\\n2) if `length 2` then check either they can `join with each other` or can be `joined commonly to another node`\\n3) if `length 4` then they can be `joined in themselves forming two groups`\\n4) if `none of the above` then return `false`\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        \\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(List<Integer> ed : edges){\\n            int from = ed.get(0) - 1;\\n            int to = ed.get(1) - 1;\\n            adj.get(from).add(to);\\n            adj.get(to).add(from);\\n        }\\n        \\n        int []arr = new int[n];\\n        List<Integer> list = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            arr[i] = adj.get(i).size();\\n            if(arr[i] % 2 != 0){\\n                list.add(i);\\n            }\\n        }\\n        \\n        if(list.size() ==0){\\n            return true;\\n        }\\n        else if(list.size() == 2){\\n            int a = list.get(0);\\n            int b = list.get(1);\\n            \\n            if(!adj.get(a).contains(b)){\\n                return true;\\n            }\\n            else{\\n                for(int i = 0 ; i < n; i++){\\n                    if(!adj.get(i).contains(a) && !adj.get(i).contains(b)){\\n                        return true;\\n                    }\\n                }\\n                return false;\\n            }\\n        }\\n        else if(list.size() == 4){\\n            int []ar = {list.get(0), list.get(1), list.get(2), list.get(3)};\\n            \\n            for(int i = 0 ; i < 4; i++){\\n                if(ar[i] == -1) continue;\\n                for(int j = 0; j < 4; j++){\\n\\n                    if(i == j || ar[j] == -1) continue;\\n                    \\n                    if(!adj.get(ar[i]).contains(ar[j]) && !adj.get(ar[j]).contains(ar[i])){\\n                        ar[i] = -1;\\n                        ar[j] = -1;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            for(int i = 0; i < 4; i++){\\n                if(ar[i] != -1){\\n                    return false;\\n                }\\n            }\\n            \\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        \\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(List<Integer> ed : edges){\\n            int from = ed.get(0) - 1;\\n            int to = ed.get(1) - 1;\\n            adj.get(from).add(to);\\n            adj.get(to).add(from);\\n        }\\n        \\n        int []arr = new int[n];\\n        List<Integer> list = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            arr[i] = adj.get(i).size();\\n            if(arr[i] % 2 != 0){\\n                list.add(i);\\n            }\\n        }\\n        \\n        if(list.size() ==0){\\n            return true;\\n        }\\n        else if(list.size() == 2){\\n            int a = list.get(0);\\n            int b = list.get(1);\\n            \\n            if(!adj.get(a).contains(b)){\\n                return true;\\n            }\\n            else{\\n                for(int i = 0 ; i < n; i++){\\n                    if(!adj.get(i).contains(a) && !adj.get(i).contains(b)){\\n                        return true;\\n                    }\\n                }\\n                return false;\\n            }\\n        }\\n        else if(list.size() == 4){\\n            int []ar = {list.get(0), list.get(1), list.get(2), list.get(3)};\\n            \\n            for(int i = 0 ; i < 4; i++){\\n                if(ar[i] == -1) continue;\\n                for(int j = 0; j < 4; j++){\\n\\n                    if(i == j || ar[j] == -1) continue;\\n                    \\n                    if(!adj.get(ar[i]).contains(ar[j]) && !adj.get(ar[j]).contains(ar[i])){\\n                        ar[i] = -1;\\n                        ar[j] = -1;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            for(int i = 0; i < 4; i++){\\n                if(ar[i] != -1){\\n                    return false;\\n                }\\n            }\\n            \\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923848,
                "title": "count-degree-solution-java",
                "content": "```\\nclass Solution {\\n      public static  boolean isPossible(int n, List<List<Integer>> edges) {\\n        List<Set<Integer>> adj = new ArrayList<Set<Integer>>();\\n        for (int i = 0; i <= n; i++) {\\n            adj.add(new HashSet<>());\\n        }\\n        int[] degree = new int[n+1];\\n        for(List<Integer> e:edges){\\n            degree[e.get(0)]++;\\n            degree[e.get(1)]++;\\n            adj.get(e.get(0)).add(e.get(1));\\n            adj.get(e.get(1)).add(e.get(0));\\n        }\\n        int count = 0;\\n        int[] odd = new int[4];\\n        int j = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if(degree[i]%2!=0){\\n                count++;\\n                if(count > 4){\\n                    return false;\\n                }\\n                odd[j++]=i;\\n            }\\n\\n        }\\n          if(count==0)\\n              return true;\\n        if(count>4 || count %2==1){\\n            return false;\\n        }\\n        System.out.println(count);\\n        if(count==2){\\n            int a = odd[0];\\n            int b = odd[1];\\n            if(!adj.get(a).contains(b))\\n                return true;\\n            return adj.get(a).size()< n-1 && adj.get(b).size()< n-1;\\n        }\\n        if(count==4){\\n            int a = odd[0];\\n            int b = odd[1];\\n            int c = odd[2];\\n            int d = odd[3];\\n            if(!adj.get(a).contains(b) && !adj.get(c).contains(d))\\n                return true;\\n            if(!adj.get(a).contains(c) && !adj.get(b).contains(d))\\n                return true;\\n            if(!adj.get(a).contains(d) && !adj.get(b).contains(c))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n      public static  boolean isPossible(int n, List<List<Integer>> edges) {\\n        List<Set<Integer>> adj = new ArrayList<Set<Integer>>();\\n        for (int i = 0; i <= n; i++) {\\n            adj.add(new HashSet<>());\\n        }\\n        int[] degree = new int[n+1];\\n        for(List<Integer> e:edges){\\n            degree[e.get(0)]++;\\n            degree[e.get(1)]++;\\n            adj.get(e.get(0)).add(e.get(1));\\n            adj.get(e.get(1)).add(e.get(0));\\n        }\\n        int count = 0;\\n        int[] odd = new int[4];\\n        int j = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if(degree[i]%2!=0){\\n                count++;\\n                if(count > 4){\\n                    return false;\\n                }\\n                odd[j++]=i;\\n            }\\n\\n        }\\n          if(count==0)\\n              return true;\\n        if(count>4 || count %2==1){\\n            return false;\\n        }\\n        System.out.println(count);\\n        if(count==2){\\n            int a = odd[0];\\n            int b = odd[1];\\n            if(!adj.get(a).contains(b))\\n                return true;\\n            return adj.get(a).size()< n-1 && adj.get(b).size()< n-1;\\n        }\\n        if(count==4){\\n            int a = odd[0];\\n            int b = odd[1];\\n            int c = odd[2];\\n            int d = odd[3];\\n            if(!adj.get(a).contains(b) && !adj.get(c).contains(d))\\n                return true;\\n            if(!adj.get(a).contains(c) && !adj.get(b).contains(d))\\n                return true;\\n            if(!adj.get(a).contains(d) && !adj.get(b).contains(c))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923834,
                "title": "java-clean-commented-code",
                "content": "# Intuition\\nIt seemed degree of nodes need to be stored and build logic on top of it\\n\\n# Approach\\nCollected all nodes with odd degress and applied simple logic.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(2N)\\n\\n# Code\\n```\\nclass Solution {\\n     public boolean isPossible(int n, List<List<Integer>> edges) {\\n\\n        Map<Integer, Set<Integer>> edgesM = new HashMap<>();\\n        Map<Integer, Integer> map = new HashMap<>(); // node, degree\\n\\n        for (List<Integer> edge : edges) {\\n            int n1 = edge.get(0);\\n            int n2 = edge.get(1);\\n            map.put(n1, map.getOrDefault(n1, 0) + 1);\\n            map.put(n2, map.getOrDefault(n2, 0) + 1);\\n\\n            if (!edgesM.containsKey(n1)) edgesM.put(n1, new HashSet<>());\\n            if (!edgesM.containsKey(n2)) edgesM.put(n2, new HashSet<>());\\n            edgesM.get(n1).add(n2);\\n            edgesM.get(n2).add(n1);\\n        }\\n\\n        // collect all odd degree nodes \\n        Map<Integer, Integer> oddD = map.entrySet()\\n                .stream()\\n                .filter(x -> x.getValue() % 2 != 0)\\n                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\\n\\n        if (oddD.size() == 0) return true;\\n        if (oddD.size() > 4 || oddD.size() % 2 != 0) return false;\\n\\n        List<Integer> keyset = new ArrayList<>(oddD.keySet());\\n\\n        // If 4 nodes having odd degree then  check if there is combination to connect them with 2 edges \\n        if (oddD.size() == 4) {\\n            int cnt = 0;\\n            for (int i = 0; i < keyset.size(); i++) {\\n                for (int j = i + 1; j < keyset.size(); j++) {\\n                    if (oddD.get(keyset.get(i)) % 2 == 0 || oddD.get(keyset.get(j)) % 2 == 0) continue;\\n                    if (!edgesM.get(keyset.get(i)).contains(keyset.get(j))) {\\n\\n                        edgesM.get(keyset.get(i)).add(keyset.get(j));\\n                        edgesM.get(keyset.get(j)).add(keyset.get(i));\\n\\n                        oddD.put(keyset.get(i), oddD.get(keyset.get(i)) + 1);\\n                        oddD.put(keyset.get(j), oddD.get(keyset.get(j)) + 1);\\n                        cnt++;\\n                    }\\n                }\\n            }\\n            return cnt == 2;\\n        }\\n\\n        // 2 odd edges\\n        // if 2 edges are not connected thn connect them and make degrees even\\n        if (!edgesM.get(keyset.get(0)).contains(keyset.get(1))) return true;\\n\\n        // check if there exist a node with even degree that is not connected to either of them \\n        // if exist connect it to both of them 1 by 1 and all degrees will become even \\n        Map<Integer, Integer> un = map.entrySet()\\n                .stream()\\n                .filter(x -> (x.getValue() % 2 == 0 &&\\n                        !edgesM.get(keyset.get(0)).contains(x.getKey())\\n                        &&\\n                        !edgesM.get(keyset.get(1)).contains(x.getKey())))\\n                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\\n\\n        return un.size() > 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n     public boolean isPossible(int n, List<List<Integer>> edges) {\\n\\n        Map<Integer, Set<Integer>> edgesM = new HashMap<>();\\n        Map<Integer, Integer> map = new HashMap<>(); // node, degree\\n\\n        for (List<Integer> edge : edges) {\\n            int n1 = edge.get(0);\\n            int n2 = edge.get(1);\\n            map.put(n1, map.getOrDefault(n1, 0) + 1);\\n            map.put(n2, map.getOrDefault(n2, 0) + 1);\\n\\n            if (!edgesM.containsKey(n1)) edgesM.put(n1, new HashSet<>());\\n            if (!edgesM.containsKey(n2)) edgesM.put(n2, new HashSet<>());\\n            edgesM.get(n1).add(n2);\\n            edgesM.get(n2).add(n1);\\n        }\\n\\n        // collect all odd degree nodes \\n        Map<Integer, Integer> oddD = map.entrySet()\\n                .stream()\\n                .filter(x -> x.getValue() % 2 != 0)\\n                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\\n\\n        if (oddD.size() == 0) return true;\\n        if (oddD.size() > 4 || oddD.size() % 2 != 0) return false;\\n\\n        List<Integer> keyset = new ArrayList<>(oddD.keySet());\\n\\n        // If 4 nodes having odd degree then  check if there is combination to connect them with 2 edges \\n        if (oddD.size() == 4) {\\n            int cnt = 0;\\n            for (int i = 0; i < keyset.size(); i++) {\\n                for (int j = i + 1; j < keyset.size(); j++) {\\n                    if (oddD.get(keyset.get(i)) % 2 == 0 || oddD.get(keyset.get(j)) % 2 == 0) continue;\\n                    if (!edgesM.get(keyset.get(i)).contains(keyset.get(j))) {\\n\\n                        edgesM.get(keyset.get(i)).add(keyset.get(j));\\n                        edgesM.get(keyset.get(j)).add(keyset.get(i));\\n\\n                        oddD.put(keyset.get(i), oddD.get(keyset.get(i)) + 1);\\n                        oddD.put(keyset.get(j), oddD.get(keyset.get(j)) + 1);\\n                        cnt++;\\n                    }\\n                }\\n            }\\n            return cnt == 2;\\n        }\\n\\n        // 2 odd edges\\n        // if 2 edges are not connected thn connect them and make degrees even\\n        if (!edgesM.get(keyset.get(0)).contains(keyset.get(1))) return true;\\n\\n        // check if there exist a node with even degree that is not connected to either of them \\n        // if exist connect it to both of them 1 by 1 and all degrees will become even \\n        Map<Integer, Integer> un = map.entrySet()\\n                .stream()\\n                .filter(x -> (x.getValue() % 2 == 0 &&\\n                        !edgesM.get(keyset.get(0)).contains(x.getKey())\\n                        &&\\n                        !edgesM.get(keyset.get(1)).contains(x.getKey())))\\n                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\\n\\n        return un.size() > 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923833,
                "title": "js-count-odd-nodes-and-find-all-true-scenarios",
                "content": "# Intuition\\n- Count the even / odd edges of each node\\n- since only a few valid scenario will be true, only check the **truthy** scenarios: can only handle 2 edges at most\\n    - 2 even nodes: `a -- b` or `a--c, b--c`\\n    - 4 even nodes: exact 2 pair of 2 nodes, `a--b, c--d`\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {boolean}\\n */\\nvar isPossible = function(n, edges) {     \\n     // 1. build adj\\n     const map = new Map(); // <node, [neighbors]>\\n     for(const e of edges) {\\n         if(!map.has(e[0])) {\\n             map.set(e[0], new Set());\\n         }\\n         if(!map.has(e[1])) {\\n             map.set(e[1], new Set());\\n         }\\n         map.get(e[0]).add(e[1]);\\n         map.get(e[1]).add(e[0]);\\n     }\\n    // 2. count even or odd nodes\\n    const even = [];\\n    const odd = [];\\n    for(const node of map.keys()) {\\n        if(map.get(node).size % 2 === 0 ) {\\n            even.push(node);\\n        }\\n        else {\\n            odd.push(node);\\n        }\\n    }\\n    \\n    // no odd nodes\\n    if(odd.length === 0) {\\n        return true;\\n    }\\n    \\n    // handle 4 odd nodes\\n    if(odd.length === 4) {\\n        const [a,b,c,d] = odd;\\n        if(!map.get(a).has(b) && !map.get(b).has(a)  && !map.get(c).has(d) && !map.get(d).has(c)) {\\n            return true;\\n        }\\n        if(!map.get(a).has(c) && !map.get(c).has(a)  && !map.get(b).has(d) && !map.get(d).has(b)) {\\n            return true;\\n        }\\n        if(!map.get(a).has(d) && !map.get(d).has(a)  && !map.get(b).has(c) && !map.get(c).has(b)) {\\n            return true;\\n        }\\n    }\\n    \\n    //handle 2 odd nodes\\n    if(odd.length === 2) {\\n        const [a, b] = odd;\\n        if(!map.get(a).has(b) && !map.get(b).has(a) ) {\\n            return true;\\n        }\\n        // pair with another same node\\n        for(const c of even) {\\n            if(!map.get(a).has(c) && !map.get(b).has(c) ) {\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {boolean}\\n */\\nvar isPossible = function(n, edges) {     \\n     // 1. build adj\\n     const map = new Map(); // <node, [neighbors]>\\n     for(const e of edges) {\\n         if(!map.has(e[0])) {\\n             map.set(e[0], new Set());\\n         }\\n         if(!map.has(e[1])) {\\n             map.set(e[1], new Set());\\n         }\\n         map.get(e[0]).add(e[1]);\\n         map.get(e[1]).add(e[0]);\\n     }\\n    // 2. count even or odd nodes\\n    const even = [];\\n    const odd = [];\\n    for(const node of map.keys()) {\\n        if(map.get(node).size % 2 === 0 ) {\\n            even.push(node);\\n        }\\n        else {\\n            odd.push(node);\\n        }\\n    }\\n    \\n    // no odd nodes\\n    if(odd.length === 0) {\\n        return true;\\n    }\\n    \\n    // handle 4 odd nodes\\n    if(odd.length === 4) {\\n        const [a,b,c,d] = odd;\\n        if(!map.get(a).has(b) && !map.get(b).has(a)  && !map.get(c).has(d) && !map.get(d).has(c)) {\\n            return true;\\n        }\\n        if(!map.get(a).has(c) && !map.get(c).has(a)  && !map.get(b).has(d) && !map.get(d).has(b)) {\\n            return true;\\n        }\\n        if(!map.get(a).has(d) && !map.get(d).has(a)  && !map.get(b).has(c) && !map.get(c).has(b)) {\\n            return true;\\n        }\\n    }\\n    \\n    //handle 2 odd nodes\\n    if(odd.length === 2) {\\n        const [a, b] = odd;\\n        if(!map.get(a).has(b) && !map.get(b).has(a) ) {\\n            return true;\\n        }\\n        // pair with another same node\\n        for(const c of even) {\\n            if(!map.get(a).has(c) && !map.get(b).has(c) ) {\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2923820,
                "title": "direct-approach",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Calculate the degree of each nodes. If the number of node with odd degree greater than 4, it is impossible.\\n2. Otherwise, try to link the nodes with odd degree so that they becomes even degree. In case of the number of node with odd degree is equal to two, we can also link those two nodes to a node with even degree using at most 2 edges.\\n\\n# Complexity\\n- Time complexity: $$O(\\\\max(V, E))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(\\\\max(V, E))$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<set<int>> graph(n);\\n        \\n        for (auto edge : edges) {\\n            int u = edge[0], v = edge[1];\\n            graph[u - 1].insert(v - 1);\\n            graph[v - 1].insert(u - 1);\\n        }\\n\\n        // Calculate the degree of each nodes. If the number of odd degree greater than 4. It is impossible.\\n        vector<int> odd_deg_node;\\n        for (int i = 0; i < n; ++i) {\\n            if (graph[i].size() % 2) {\\n                odd_deg_node.push_back(i);\\n            }\\n        }\\n\\n        if (odd_deg_node.empty()) return true;\\n        \\n        // Otherwise, try to link the nodes with odd degree so that they becomes even degree. Or we can link the nodes with odd degree to the node with even degree.\\n        if (odd_deg_node.size() == 2) {\\n            int a = odd_deg_node[0];\\n            int b = odd_deg_node[1];\\n\\n            if (!graph[a].count(b)) {\\n                return true;\\n            }\\n            \\n            for (int i = 0; i < n; ++i) {\\n                if (a == i || b == i) continue;\\n                if (!graph[a].count(i) && !graph[b].count(i))\\n                    return true;\\n            }\\n        } else if (odd_deg_node.size() == 4) {\\n            int a = odd_deg_node[0];\\n            int b = odd_deg_node[1];\\n            int c = odd_deg_node[2];\\n            int d = odd_deg_node[3];\\n\\n            if (!graph[a].count(b) && !graph[c].count(d)) {\\n                return true;\\n            }\\n            \\n            if (!graph[a].count(c) && !graph[b].count(d)) {\\n                return true;\\n            }\\n            \\n            if (!graph[a].count(d) && !graph[b].count(c)) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<set<int>> graph(n);\\n        \\n        for (auto edge : edges) {\\n            int u = edge[0], v = edge[1];\\n            graph[u - 1].insert(v - 1);\\n            graph[v - 1].insert(u - 1);\\n        }\\n\\n        // Calculate the degree of each nodes. If the number of odd degree greater than 4. It is impossible.\\n        vector<int> odd_deg_node;\\n        for (int i = 0; i < n; ++i) {\\n            if (graph[i].size() % 2) {\\n                odd_deg_node.push_back(i);\\n            }\\n        }\\n\\n        if (odd_deg_node.empty()) return true;\\n        \\n        // Otherwise, try to link the nodes with odd degree so that they becomes even degree. Or we can link the nodes with odd degree to the node with even degree.\\n        if (odd_deg_node.size() == 2) {\\n            int a = odd_deg_node[0];\\n            int b = odd_deg_node[1];\\n\\n            if (!graph[a].count(b)) {\\n                return true;\\n            }\\n            \\n            for (int i = 0; i < n; ++i) {\\n                if (a == i || b == i) continue;\\n                if (!graph[a].count(i) && !graph[b].count(i))\\n                    return true;\\n            }\\n        } else if (odd_deg_node.size() == 4) {\\n            int a = odd_deg_node[0];\\n            int b = odd_deg_node[1];\\n            int c = odd_deg_node[2];\\n            int d = odd_deg_node[3];\\n\\n            if (!graph[a].count(b) && !graph[c].count(d)) {\\n                return true;\\n            }\\n            \\n            if (!graph[a].count(c) && !graph[b].count(d)) {\\n                return true;\\n            }\\n            \\n            if (!graph[a].count(d) && !graph[b].count(c)) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923818,
                "title": "c-case-analysis-with-hashset",
                "content": "Intuition:\\n\\nThere will be only 2 extra edges to be added, which means at most 4 nodes can have even out-degree if they were odd. So it will always be `false` if `>4` nodes have odd out-degrees. If analyze case-by-case\\n- 0 nodes have odd-degrees: always `true`.\\n- 1 or 3 nodes have odd-degrees: always `false` (adding an edge can make one node `even` while make another node `odd`).\\n- 2 nodes `(a, b)` have odd-degrees\\n\\t1. add one edge to connect these 2 and return `true`.\\n\\t2. find a node `m` that is already `even` and connect both `[a,b]` to it. `[a,m] and [b,m]` \\n- 4 nodes `(a,b,c,d)` have odd-degrees\\n\\t* add two edges to connect them internally with three possibility\\n\\t* `[a,b] and [c,d]`\\n\\t* `[a,c] and [b,d]`\\n\\t* `[a,d] and [b,c]`\\n\\n\\\\* Note that an edge can only be added iff they haven\\'t been connected. \\n\\nTime: O(E)\\nSpace: O(N)\\n\\n\\\\* Case set is not big, for readibility, I prefer to check each of them one by one.\\n```\\nclass Solution {\\n public:\\n  bool isPossible(int n, vector<vector<int>>& edges) {\\n    // no self-loops and no repeated\\n    // add inner connections to nodes with odd degrees\\n\\n    // preprocessing\\n    vector<int> outdegrees(n + 1, 0);\\n    for (vector<int>& edge : edges) {\\n      outdegrees[edge[0]]++;\\n      outdegrees[edge[1]]++;\\n    }\\n    vector<int> oddDegrees, evenDegrees;\\n    for (int i = 1; i < outdegrees.size(); ++i)\\n      if (outdegrees[i] & 1)\\n        oddDegrees.push_back(i);\\n      else\\n        evenDegrees.push_back(i);\\n\\n    // case: 0,1,3\\n    if (oddDegrees.size() & 1) return false;\\n    if (oddDegrees.size() == 0) return true;\\n\\n    // case 2\\n    if (oddDegrees.size() == 2) {\\n      int a = oddDegrees[0], b = oddDegrees[1];\\n      unordered_map<int, unordered_set<int>> mp;\\n      for (vector<int>& edge : edges) {\\n        if (edge[0] == a) mp[a].insert(edge[1]);\\n        if (edge[1] == a) mp[a].insert(edge[0]);\\n        if (edge[0] == b) mp[b].insert(edge[1]);\\n        if (edge[1] == b) mp[b].insert(edge[0]);\\n      }\\n      if (!mp[a].count(b)) return true;\\n      // can find a common node to connect\\n      for (int node : evenDegrees) {\\n        if (!mp[a].count(node) && !mp[b].count(node)) return true;\\n      }\\n      return false;\\n    }\\n\\n    // case: 4\\n    if (oddDegrees.size() == 4) {\\n      int a = oddDegrees[0], b = oddDegrees[1], c = oddDegrees[2],\\n          d = oddDegrees[3];\\n      unordered_map<int, unordered_set<int>> mp;\\n      unordered_set<int> s = {a, b, c, d};\\n      for (vector<int>& edge : edges)\\n        if (s.count(edge[0]) && s.count(edge[1])) {\\n          mp[edge[0]].insert(edge[1]);\\n          mp[edge[1]].insert(edge[0]);\\n        }\\n      for (auto val : mp)\\n        if (val.second.size() > 2) return false;\\n\\n      // [a,b c,d], [a,c, b,d], [a,d b,c]\\n      if (!mp[a].count(b) && !mp[c].count(d)) return true;\\n      if (!mp[a].count(c) && !mp[b].count(d)) return true;\\n      if (!mp[a].count(d) && !mp[b].count(c)) return true;\\n      return false;\\n    }\\n    // case: >4\\n    return false;\\n  }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n public:\\n  bool isPossible(int n, vector<vector<int>>& edges) {\\n    // no self-loops and no repeated\\n    // add inner connections to nodes with odd degrees\\n\\n    // preprocessing\\n    vector<int> outdegrees(n + 1, 0);\\n    for (vector<int>& edge : edges) {\\n      outdegrees[edge[0]]++;\\n      outdegrees[edge[1]]++;\\n    }\\n    vector<int> oddDegrees, evenDegrees;\\n    for (int i = 1; i < outdegrees.size(); ++i)\\n      if (outdegrees[i] & 1)\\n        oddDegrees.push_back(i);\\n      else\\n        evenDegrees.push_back(i);\\n\\n    // case: 0,1,3\\n    if (oddDegrees.size() & 1) return false;\\n    if (oddDegrees.size() == 0) return true;\\n\\n    // case 2\\n    if (oddDegrees.size() == 2) {\\n      int a = oddDegrees[0], b = oddDegrees[1];\\n      unordered_map<int, unordered_set<int>> mp;\\n      for (vector<int>& edge : edges) {\\n        if (edge[0] == a) mp[a].insert(edge[1]);\\n        if (edge[1] == a) mp[a].insert(edge[0]);\\n        if (edge[0] == b) mp[b].insert(edge[1]);\\n        if (edge[1] == b) mp[b].insert(edge[0]);\\n      }\\n      if (!mp[a].count(b)) return true;\\n      // can find a common node to connect\\n      for (int node : evenDegrees) {\\n        if (!mp[a].count(node) && !mp[b].count(node)) return true;\\n      }\\n      return false;\\n    }\\n\\n    // case: 4\\n    if (oddDegrees.size() == 4) {\\n      int a = oddDegrees[0], b = oddDegrees[1], c = oddDegrees[2],\\n          d = oddDegrees[3];\\n      unordered_map<int, unordered_set<int>> mp;\\n      unordered_set<int> s = {a, b, c, d};\\n      for (vector<int>& edge : edges)\\n        if (s.count(edge[0]) && s.count(edge[1])) {\\n          mp[edge[0]].insert(edge[1]);\\n          mp[edge[1]].insert(edge[0]);\\n        }\\n      for (auto val : mp)\\n        if (val.second.size() > 2) return false;\\n\\n      // [a,b c,d], [a,c, b,d], [a,d b,c]\\n      if (!mp[a].count(b) && !mp[c].count(d)) return true;\\n      if (!mp[a].count(c) && !mp[b].count(d)) return true;\\n      if (!mp[a].count(d) && !mp[b].count(c)) return true;\\n      return false;\\n    }\\n    // case: >4\\n    return false;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923810,
                "title": "python3-straightforward-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCount the degree of each node and keep the node which needs to add one additional edge.\\ncase1: If the degree of a node reaches n - 1 and n - 1 is odd, there is no way to add an additional edge to it. Return false.\\ncase2: The number of odd nodes is 0. We don\\'t need add extra edge into this graph. Return true directly.\\ncase3: The number of odd nodes is 2. It must have a way to guarantee all nodes are even, by adding one or two edges.\\ncase4: The number of odd nodes is 4. Check it there is a way to add two edges within these four nodes. Since there are only 4 nodes, we can enumerate all the possibilities.\\ncase5: The nubmer of odd nodes is 1, 3 or larger than 4. Return false.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        visited = collections.defaultdict(set)\\n        degree = [0] * (n + 1)\\n        for node1, node2 in edges:\\n            visited[node1].add(node2)\\n            visited[node2].add(node1)\\n            degree[node1] += 1\\n            degree[node2] += 1\\n        odds = [node for node in range(1, n + 1) if len(visited[node]) % 2]\\n        if len(odds) > 4 or len(odds) % 2:\\n            return False\\n        if len(odds) == 0:\\n            return True\\n        if len(odds) == 4:\\n            if odds[1] not in visited[odds[0]] and odds[3] not in visited[odds[2]]:\\n                return True\\n            if odds[2] not in visited[odds[0]] and odds[3] not in visited[odds[1]]:\\n                return True\\n            if odds[3] not in visited[odds[0]] and odds[2] not in visited[odds[1]]:\\n                return True\\n        if len(odds) == 2:\\n            if odds[1] not in visited[odds[0]]:\\n                return True\\n            for middle in range(1, n + 1):\\n                if middle == odds[0] or middle == odds[1]:\\n                    continue\\n                if middle not in visited[odds[0]] and middle not in visited[odds[1]]:\\n                    return True\\n        return False\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        visited = collections.defaultdict(set)\\n        degree = [0] * (n + 1)\\n        for node1, node2 in edges:\\n            visited[node1].add(node2)\\n            visited[node2].add(node1)\\n            degree[node1] += 1\\n            degree[node2] += 1\\n        odds = [node for node in range(1, n + 1) if len(visited[node]) % 2]\\n        if len(odds) > 4 or len(odds) % 2:\\n            return False\\n        if len(odds) == 0:\\n            return True\\n        if len(odds) == 4:\\n            if odds[1] not in visited[odds[0]] and odds[3] not in visited[odds[2]]:\\n                return True\\n            if odds[2] not in visited[odds[0]] and odds[3] not in visited[odds[1]]:\\n                return True\\n            if odds[3] not in visited[odds[0]] and odds[2] not in visited[odds[1]]:\\n                return True\\n        if len(odds) == 2:\\n            if odds[1] not in visited[odds[0]]:\\n                return True\\n            for middle in range(1, n + 1):\\n                if middle == odds[0] or middle == odds[1]:\\n                    continue\\n                if middle not in visited[odds[0]] and middle not in visited[odds[1]]:\\n                    return True\\n        return False\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923808,
                "title": "python-easy-logic-explained-map-concise-fast-codeplug",
                "content": "# Intuition\\nWe find the nodes with odd degrees. If the number of such nodes is 0, return true. If its 2, find a node such that it does not exist in both nodes with odd degrees.\\n\\nIf count is 4, we find 2 pairs that are not connected to each other.\\nIf its not possible we return false.\\n\\n**Upvote if you got the logic :)\\n**\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        mat = defaultdict(set)\\n\\n        for u, v in edges:\\n            mat[u].add(v)\\n            mat[v].add(u)\\n\\n        odds = []\\n\\n        for node, neis in mat.items():\\n            if len(neis) % 2:\\n                odds.append(node)\\n\\n        if len(odds) == 0: return True\\n        if len(odds) == 2:\\n            node1, node2 = odds\\n            for i in range(1, n + 1):\\n                if i not in mat[node1] and i not in mat[node2]: return True\\n        if len(odds) == 4:\\n            n1, n2, n3, n4 = odds\\n            if (n1 not in mat[n2] and n3 not in mat[n4]) or (n2 not in mat[n3] and n1 not in mat[n4]) or (n1 not in mat[n3] and n2 not in mat[n4]): return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        mat = defaultdict(set)\\n\\n        for u, v in edges:\\n            mat[u].add(v)\\n            mat[v].add(u)\\n\\n        odds = []\\n\\n        for node, neis in mat.items():\\n            if len(neis) % 2:\\n                odds.append(node)\\n\\n        if len(odds) == 0: return True\\n        if len(odds) == 2:\\n            node1, node2 = odds\\n            for i in range(1, n + 1):\\n                if i not in mat[node1] and i not in mat[node2]: return True\\n        if len(odds) == 4:\\n            n1, n2, n3, n4 = odds\\n            if (n1 not in mat[n2] and n3 not in mat[n4]) or (n2 not in mat[n3] and n1 not in mat[n4]) or (n1 not in mat[n3] and n2 not in mat[n4]): return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923787,
                "title": "c-easy-original-submission-adjacency-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHints given in Question node values 1 to n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAdjacency list with map/Hashmap and count the total nodes of odd degree\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<unordered_map<int,bool>>adj(n+1);\\n        for(auto &it:edges){\\n           adj[it[0]][it[1]]=true;\\n             adj[it[1]][it[0]]=true;\\n        };\\n        int count=0;\\n        vector<int>vec;\\n        for(int i=1;i<=n;i++){\\n            if(adj[i].size()%2!=0){\\n                vec.push_back(i);\\n            }\\n        }\\n        count=vec.size();\\n        if(count>4||count==1||count==3){\\n            return false;\\n        }\\n        if(count==2){\\n            if(adj[vec[0]][vec[1]]){\\n                for(int i=1;i<=n;i++){\\n                    if(adj[i].size()%2==0&&adj[i][vec[0]]==false&&adj[i][vec[1]]==false){\\n                        return true;\\n                    }\\n                }\\n                return false;\\n            }\\n            else{\\n                return true;\\n            }\\n        }\\n        \\n        if(count==4){\\n            if(adj[vec[0]][vec[1]]==false&&adj[vec[2]][vec[3]]==false||adj[vec[0]][vec[2]]==false&&adj[vec[1]][vec[3]]==false||adj[vec[0]][vec[3]]==false&&adj[vec[1]][vec[2]]==false){\\n                return true;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        \\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<unordered_map<int,bool>>adj(n+1);\\n        for(auto &it:edges){\\n           adj[it[0]][it[1]]=true;\\n             adj[it[1]][it[0]]=true;\\n        };\\n        int count=0;\\n        vector<int>vec;\\n        for(int i=1;i<=n;i++){\\n            if(adj[i].size()%2!=0){\\n                vec.push_back(i);\\n            }\\n        }\\n        count=vec.size();\\n        if(count>4||count==1||count==3){\\n            return false;\\n        }\\n        if(count==2){\\n            if(adj[vec[0]][vec[1]]){\\n                for(int i=1;i<=n;i++){\\n                    if(adj[i].size()%2==0&&adj[i][vec[0]]==false&&adj[i][vec[1]]==false){\\n                        return true;\\n                    }\\n                }\\n                return false;\\n            }\\n            else{\\n                return true;\\n            }\\n        }\\n        \\n        if(count==4){\\n            if(adj[vec[0]][vec[1]]==false&&adj[vec[2]][vec[3]]==false||adj[vec[0]][vec[2]]==false&&adj[vec[1]][vec[3]]==false||adj[vec[0]][vec[3]]==false&&adj[vec[1]][vec[2]]==false){\\n                return true;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        \\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923780,
                "title": "case-by-case-analysis",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor an affirmative answer, it is necessary that either 0, 2, or 4 vertices should have an odd degree (number of neighbors).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf there are zero vertices of odd degree, nothing more is needed.\\n\\nIf there are 4, one must look for all 3 possible combinations among them (1 to 2 and 3 to 4, 1 to 3 and 2 to 4, 1 to 4 and 2 to 3) and see if the edges for either combination can be added. If either combination is possible, the nswer is affirmative; otherwise it is negative.\\n\\nFinally, if 2 vertices have odd degrees, then there are two further cases. If one can add an edge between them, problem solved. Otherwise we must use two edges to connect both vertices to a third vertex, whose degree will then stay even. We then go over the list of all vertices and see if this can be done.\\n\\n# Complexity\\n- Time complexity: $O(n)$, where $n$ is the number of edges.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        v=[0]*(n+1)\\n        g=[set() for _ in range(n+1)]\\n        for e in edges:\\n            g[e[0]].add(e[1])\\n            g[e[1]].add(e[0])\\n            v[e[0]]+=1\\n            v[e[1]]+=1\\n        odd=[]\\n        odd_ct=0\\n        for i in range(1, n+1):\\n            if v[i]&1:\\n                odd_ct+=1\\n                if odd_ct>4:\\n                    return False\\n                odd.append(i)\\n        if odd_ct==0:\\n            return True\\n        if odd_ct==1 or odd_ct==3:\\n            return False\\n        if odd_ct==4:\\n            i1, i2, i3, i4=odd\\n            if (i2 not in g[i1]) and (i4 not in g[i3]):\\n                return True\\n            if (i3 not in g[i1]) and (i4 not in g[i2]):\\n                return True\\n            if (i4 not in g[i1]) and (i3 not in g[i2]):\\n                return True\\n            return False\\n        if odd_ct==2:\\n            i1, i2=odd\\n            if i2 not in g[i1]:\\n                return True\\n            for i in range(1, n+1):\\n                if i!=i1 and i!=i2 and i not in g[i1] and i not in g[i2]:\\n                    return True\\n            return False\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        v=[0]*(n+1)\\n        g=[set() for _ in range(n+1)]\\n        for e in edges:\\n            g[e[0]].add(e[1])\\n            g[e[1]].add(e[0])\\n            v[e[0]]+=1\\n            v[e[1]]+=1\\n        odd=[]\\n        odd_ct=0\\n        for i in range(1, n+1):\\n            if v[i]&1:\\n                odd_ct+=1\\n                if odd_ct>4:\\n                    return False\\n                odd.append(i)\\n        if odd_ct==0:\\n            return True\\n        if odd_ct==1 or odd_ct==3:\\n            return False\\n        if odd_ct==4:\\n            i1, i2, i3, i4=odd\\n            if (i2 not in g[i1]) and (i4 not in g[i3]):\\n                return True\\n            if (i3 not in g[i1]) and (i4 not in g[i2]):\\n                return True\\n            if (i4 not in g[i1]) and (i3 not in g[i2]):\\n                return True\\n            return False\\n        if odd_ct==2:\\n            i1, i2=odd\\n            if i2 not in g[i1]:\\n                return True\\n            for i in range(1, n+1):\\n                if i!=i1 and i!=i2 and i not in g[i1] and i not in g[i2]:\\n                    return True\\n            return False\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923771,
                "title": "c-solution-simple-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere can either be two vertices of odd degree or four vertices of odd degrees\\n- If two verices of odd degrees, One edge can be added between these two if they are already not connected. In case they are already connected, an extra vertex can act as a bridge to connect them\\n- If four verices of odd degree, two edges are minimum that should be added for making them of even degrees\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO (n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    bool isTrue(set<int> adj[],int u,int v,int i,int j){\\n        if(adj[u].find(v)==adj[u].end() && adj[i].find(j) == adj[i].end())return true;\\n        return false;\\n    }\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        set<int> adj[n+1];\\n        for(auto &edge:edges){\\n            adj[edge[0]].insert(edge[1]);\\n            adj[edge[1]].insert(edge[0]);\\n            \\n        }\\n        int u,v,i;\\n        vector<int> od; // vertices of odd degree\\n        for(u=1;u<=n;u++){\\n            if((adj[u].size()) &1){\\n                od.push_back(u);\\n            }\\n        }\\n        if(od.size()>4 || (od.size())&1){\\n            return false;\\n        }\\n        if(od.size() == 0)return true;\\n        \\n        if(od.size() == 2){\\n            u=od[0];\\n            v=od[1];\\n            if(adj[u].find(v)==adj[u].end()){\\n                return true;\\n            }\\n            for(i=1;i<=n;i++){\\n                if(i==u || i==v)continue;\\n                \\n                if(adj[u].find(i) == adj[u].end() &&adj[v].find(i) == adj[v].end())return true;\\n            }\\n            return false;\\n        }\\n\\n        // If od.size() == 4\\n        if(isTrue(adj,od[0],od[1],od[2],od[3])){\\n            return true;\\n        }\\n        if(isTrue(adj,od[0],od[2],od[1],od[3])){\\n            return true;\\n        }\\n        if(isTrue(adj,od[0],od[3],od[1],od[2])){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    bool isTrue(set<int> adj[],int u,int v,int i,int j){\\n        if(adj[u].find(v)==adj[u].end() && adj[i].find(j) == adj[i].end())return true;\\n        return false;\\n    }\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        set<int> adj[n+1];\\n        for(auto &edge:edges){\\n            adj[edge[0]].insert(edge[1]);\\n            adj[edge[1]].insert(edge[0]);\\n            \\n        }\\n        int u,v,i;\\n        vector<int> od; // vertices of odd degree\\n        for(u=1;u<=n;u++){\\n            if((adj[u].size()) &1){\\n                od.push_back(u);\\n            }\\n        }\\n        if(od.size()>4 || (od.size())&1){\\n            return false;\\n        }\\n        if(od.size() == 0)return true;\\n        \\n        if(od.size() == 2){\\n            u=od[0];\\n            v=od[1];\\n            if(adj[u].find(v)==adj[u].end()){\\n                return true;\\n            }\\n            for(i=1;i<=n;i++){\\n                if(i==u || i==v)continue;\\n                \\n                if(adj[u].find(i) == adj[u].end() &&adj[v].find(i) == adj[v].end())return true;\\n            }\\n            return false;\\n        }\\n\\n        // If od.size() == 4\\n        if(isTrue(adj,od[0],od[1],od[2],od[3])){\\n            return true;\\n        }\\n        if(isTrue(adj,od[0],od[2],od[1],od[3])){\\n            return true;\\n        }\\n        if(isTrue(adj,od[0],od[3],od[1],od[2])){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923759,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def isPossible(self, n, edges):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: bool\\n          \\n        dic = {}\\n        for edge in edges:\\n            if (edge [0] not in dic):\\n                dic[edge[0]] = set()\\n            if (edge [1] not in dic):\\n                dic[edge[1]] = set()\\n            dic[edge[0]].add(edge[1])\\n            dic[edge[1]].add(edge[0])\\n        \\n        odd = []\\n        for key, value in dic.items():\\n            if (len(value) % 2 != 0):\\n                odd.append(key)\\n        if (len(odd) > 4 or len(odd)%2 != 0):\\n            return False\\n        elif (len(odd) == 0):\\n            return True\\n        elif (len(odd) == 2):\\n            a, b = odd[0], odd[1]\\n            #use one line \\n            if a not in dic[b]:\\n                return True\\n            #use two lines\\n            for i in range(1, n + 1):\\n                if i not in dic[a] and i not in dic[b]:\\n                    return True\\n            return False\\n        elif (len(odd) == 4):\\n            a, b, c, d = odd[0], odd[1], odd[2], odd[3]\\n            if a not in dic[b] and c not in dic[d]:\\n                return True\\n            if a not in dic[c] and b not in dic[d]:\\n                return True\\n            if a not in dic[d] and b not in dic[c]:\\n                return True\\n        \\n        return False \\n                \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isPossible(self, n, edges):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: bool\\n          \\n        dic = {}\\n        for edge in edges:\\n            if (edge [0] not in dic):\\n                dic[edge[0]] = set()\\n            if (edge [1] not in dic):\\n                dic[edge[1]] = set()\\n            dic[edge[0]].add(edge[1])\\n            dic[edge[1]].add(edge[0])\\n        \\n        odd = []\\n        for key, value in dic.items():\\n            if (len(value) % 2 != 0):\\n                odd.append(key)\\n        if (len(odd) > 4 or len(odd)%2 != 0):\\n            return False\\n        elif (len(odd) == 0):\\n            return True\\n        elif (len(odd) == 2):\\n            a, b = odd[0], odd[1]\\n            #use one line \\n            if a not in dic[b]:\\n                return True\\n            #use two lines\\n            for i in range(1, n + 1):\\n                if i not in dic[a] and i not in dic[b]:\\n                    return True\\n            return False\\n        elif (len(odd) == 4):\\n            a, b, c, d = odd[0], odd[1], odd[2], odd[3]\\n            if a not in dic[b] and c not in dic[d]:\\n                return True\\n            if a not in dic[c] and b not in dic[d]:\\n                return True\\n            if a not in dic[d] and b not in dic[c]:\\n                return True\\n        \\n        return False \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923758,
                "title": "c-check-cases",
                "content": "# Code\\n```\\npublic class Solution \\n{\\n    public bool IsPossible(int n, IList<IList<int>> edges)\\n    {\\n        HashSet<int>[] graph = new HashSet<int>[n + 1];\\n        for (int i = 1; i < n + 1; i++)\\n        {\\n            graph[i] = new HashSet<int>();\\n        }\\n        foreach (List<int> edge in edges)\\n        {\\n            graph[edge[0]].Add(edge[1]);\\n            graph[edge[1]].Add(edge[0]);\\n        }\\n        List<int> oddNodes = new List<int>();\\n        for (int i = 1; i < n + 1; i++)\\n        {\\n            if (graph[i].Count % 2 != 0)\\n                oddNodes.Add(i);\\n        }\\n        if (oddNodes.Count == 0)\\n            return true;\\n        if (oddNodes.Count > 4)\\n            return false;\\n        if (oddNodes.Count == 2)\\n        {\\n            if (!graph[oddNodes[0]].Contains(oddNodes[1]))\\n                return true;\\n            else\\n            {\\n                for (int i = 1; i < n + 1; i++)//the case that their is a node which can be connected to both odd nodes\\n                {\\n                    if (i != oddNodes[0] && i != oddNodes[1] && !graph[i].Contains(oddNodes[0]) && !graph[i].Contains(oddNodes[1]))\\n                        return true;\\n                }\\n                return false;\\n            }\\n        }\\n        if (oddNodes.Count == 4)\\n        {\\n            if ((!graph[oddNodes[0]].Contains(oddNodes[1]) && !graph[oddNodes[2]].Contains(oddNodes[3])) ||\\n                (!graph[oddNodes[0]].Contains(oddNodes[2]) && !graph[oddNodes[1]].Contains(oddNodes[3])) ||\\n                (!graph[oddNodes[0]].Contains(oddNodes[3]) && !graph[oddNodes[1]].Contains(oddNodes[2])))\\n                return true;\\n            else\\n                return false;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public bool IsPossible(int n, IList<IList<int>> edges)\\n    {\\n        HashSet<int>[] graph = new HashSet<int>[n + 1];\\n        for (int i = 1; i < n + 1; i++)\\n        {\\n            graph[i] = new HashSet<int>();\\n        }\\n        foreach (List<int> edge in edges)\\n        {\\n            graph[edge[0]].Add(edge[1]);\\n            graph[edge[1]].Add(edge[0]);\\n        }\\n        List<int> oddNodes = new List<int>();\\n        for (int i = 1; i < n + 1; i++)\\n        {\\n            if (graph[i].Count % 2 != 0)\\n                oddNodes.Add(i);\\n        }\\n        if (oddNodes.Count == 0)\\n            return true;\\n        if (oddNodes.Count > 4)\\n            return false;\\n        if (oddNodes.Count == 2)\\n        {\\n            if (!graph[oddNodes[0]].Contains(oddNodes[1]))\\n                return true;\\n            else\\n            {\\n                for (int i = 1; i < n + 1; i++)//the case that their is a node which can be connected to both odd nodes\\n                {\\n                    if (i != oddNodes[0] && i != oddNodes[1] && !graph[i].Contains(oddNodes[0]) && !graph[i].Contains(oddNodes[1]))\\n                        return true;\\n                }\\n                return false;\\n            }\\n        }\\n        if (oddNodes.Count == 4)\\n        {\\n            if ((!graph[oddNodes[0]].Contains(oddNodes[1]) && !graph[oddNodes[2]].Contains(oddNodes[3])) ||\\n                (!graph[oddNodes[0]].Contains(oddNodes[2]) && !graph[oddNodes[1]].Contains(oddNodes[3])) ||\\n                (!graph[oddNodes[0]].Contains(oddNodes[3]) && !graph[oddNodes[1]].Contains(oddNodes[2])))\\n                return true;\\n            else\\n                return false;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923757,
                "title": "easy-c-solution-o-n-space-time",
                "content": "# Intuition\\n\\nThe question is pretty straight-forward. The first idea that you came up with is the correct one in this case. All we have to do is think about edge cases really. So, first we have to find out the edges with odd degrees which we can do very easily. Once we have that let\\'s look at each case.\\n\\n- Count = 0: If there is no edge with odd degree, return directly.\\n- Count = 1: If there is 1 edge then we cannot make it even because if we add an edge it\\'s going to make some other node odd. (Each edge adds a degree of 2: 1 to each node it is connecting to).\\n- Count = 2: If they are not connected to each other we can simply join them. In case they are, then find a common node which is not connected to either of them. \\n- Count = 3: Since we have odd number of nodes with odd degree so we cannot make all the nodes even. Same logic as in case of count = 1.\\n- Count = 4: They all must connect with each other only then we can make them all even using only 2 edges. In this case there will be 3 possible combinations we can check all of them in constant time. \\n- Count > 4: If count goes more than 4 we cannot make them even with only 2 edges. So in that case always return false.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ - For creating graph. It will also cover the case of count == 2 where we iterate over a loop since it will be O(n) itself.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ - For the graph.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<set<int>> graph(n);\\n        // Creating graph\\n        for(vector<int> &edge: edges) {\\n            graph[edge[0] - 1].insert(edge[1] - 1);\\n            graph[edge[1] - 1].insert(edge[0] - 1);\\n        }\\n        \\n        int count = 0;\\n        vector<int> values;\\n        // Finding nodes with Odd degrees.\\n        for(int i = 0; i < n; i++) {\\n            if(graph[i].size() % 2 == 1) {\\n                count += 1;\\n                values.push_back(i);\\n            }\\n        }\\n        \\n        // Handling different cases as discussed.\\n        if(count == 0) return true;\\n        if(count > 4 || count % 2 == 1) return false;\\n        if(count == 2) {\\n            // If the nodes are not connected to each other.\\n            if(graph[values[0]].find(values[1]) == graph[values[0]].end()) return true;\\n            \\n            // If the nodes are nodes are connected to each other and there is no other node.\\n            if(n == 2) return false;\\n            \\n            // Look for a common node that is not connected to either of the nodes.\\n            for(int i = 0; i < n; i++) {\\n                if(i == values[0] || i == values[1]) continue;\\n                else if(graph[i].find(values[0]) == graph[i].end() && graph[i].find(values[1]) == graph[i].end())\\n                    return true;\\n            }\\n        }\\n        else if(count == 4) {\\n            // Fixing 1st node and find it\\'s pair.\\n            for(int i = 1; i <= 3; i++) {\\n                // Check if 0th odd node is already connected to ith odd node.\\n                if(graph[values[0]].find(values[i]) != graph[values[0]].end()) {\\n                    continue;\\n                }\\n\\n                // If not then check if the otherpair is valid. \\n                if(i == 1) {\\n                    // pairs are (0, 1) & (2, 3)\\n                    if(graph[values[2]].find(values[3]) == graph[values[2]].end()) return true;\\n                }\\n                if(i == 2) {\\n                    // pairs are (0, 2) & (1, 3)\\n                    if(graph[values[1]].find(values[3]) == graph[values[1]].end()) return true;\\n                }\\n                if(i == 3) {\\n                    // pairs are (0, 3) & (1, 2)\\n                    if(graph[values[1]].find(values[2]) == graph[values[1]].end()) return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n\\nIf you have any doubts about the solutioin let me know in the comments.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<set<int>> graph(n);\\n        // Creating graph\\n        for(vector<int> &edge: edges) {\\n            graph[edge[0] - 1].insert(edge[1] - 1);\\n            graph[edge[1] - 1].insert(edge[0] - 1);\\n        }\\n        \\n        int count = 0;\\n        vector<int> values;\\n        // Finding nodes with Odd degrees.\\n        for(int i = 0; i < n; i++) {\\n            if(graph[i].size() % 2 == 1) {\\n                count += 1;\\n                values.push_back(i);\\n            }\\n        }\\n        \\n        // Handling different cases as discussed.\\n        if(count == 0) return true;\\n        if(count > 4 || count % 2 == 1) return false;\\n        if(count == 2) {\\n            // If the nodes are not connected to each other.\\n            if(graph[values[0]].find(values[1]) == graph[values[0]].end()) return true;\\n            \\n            // If the nodes are nodes are connected to each other and there is no other node.\\n            if(n == 2) return false;\\n            \\n            // Look for a common node that is not connected to either of the nodes.\\n            for(int i = 0; i < n; i++) {\\n                if(i == values[0] || i == values[1]) continue;\\n                else if(graph[i].find(values[0]) == graph[i].end() && graph[i].find(values[1]) == graph[i].end())\\n                    return true;\\n            }\\n        }\\n        else if(count == 4) {\\n            // Fixing 1st node and find it\\'s pair.\\n            for(int i = 1; i <= 3; i++) {\\n                // Check if 0th odd node is already connected to ith odd node.\\n                if(graph[values[0]].find(values[i]) != graph[values[0]].end()) {\\n                    continue;\\n                }\\n\\n                // If not then check if the otherpair is valid. \\n                if(i == 1) {\\n                    // pairs are (0, 1) & (2, 3)\\n                    if(graph[values[2]].find(values[3]) == graph[values[2]].end()) return true;\\n                }\\n                if(i == 2) {\\n                    // pairs are (0, 2) & (1, 3)\\n                    if(graph[values[1]].find(values[3]) == graph[values[1]].end()) return true;\\n                }\\n                if(i == 3) {\\n                    // pairs are (0, 3) & (1, 2)\\n                    if(graph[values[1]].find(values[2]) == graph[values[1]].end()) return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923751,
                "title": "check-cases-in-o-n",
                "content": "# Intuition\\nThere can be limited number of cases , like if number node having odd edges are greater than 4 then it is false. if its less than 4 we need to check specific cases.\\n\\n# Approach\\nfirst count number of nodes having odd number of edges and lets call it odds.\\n1-if odds size is greater than 4 then return false right away.\\n2-if odds have odd number of elements the we can not join them such that all will have even edges so return false.\\n3- if odds have 2 elements, then \\n    1-if are not connected to each other so by connecting them will   make both of them even edged nodes and we return true.\\n    2- if they are connected to each other then we need to find an edge with even edges and is not connect to any of them , if we found such node then we can connect both odd nodes to that even node and make all three of them even.\\n    3- if none of the above case is true then we will return false.\\n\\n4- if odds size is 4 then we need to find two pairs such that pairs elements are not connected to each other in that case we can connect them and make their count even.\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N*V)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<set<int>>adj(n+1);\\n        \\n        for(auto e:edges){\\n            adj[e[0]].insert(e[1]);\\n            adj[e[1]].insert(e[0]);\\n        }\\n        vector<int>odds;\\n        for(auto i=1;i<adj.size();i++){\\n            if(adj[i].size()%2)odds.push_back(i);\\n        }\\n        \\n        if(odds.size()>4 || odds.size()%2)return false;\\n        if(odds.size()==0)return true;\\n        if(odds.size()==2){\\n            if(adj[odds[0]].count(odds[1])==0){\\n                return true;\\n            }\\n            for(int i=1;i<adj.size();i++){\\n                if(i!=odds[0] and i!=odds[1] and adj[i].count(odds[0])==0 and adj[i].count(odds[1])==0){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        if(adj[odds[0]].count(odds[1])==0 and adj[odds[2]].count(odds[3])==0)return true;\\n        if(adj[odds[0]].count(odds[2])==0 and adj[odds[1]].count(odds[3])==0)return true;\\n        if(adj[odds[0]].count(odds[3])==0 and adj[odds[2]].count(odds[1])==0)return true;\\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<set<int>>adj(n+1);\\n        \\n        for(auto e:edges){\\n            adj[e[0]].insert(e[1]);\\n            adj[e[1]].insert(e[0]);\\n        }\\n        vector<int>odds;\\n        for(auto i=1;i<adj.size();i++){\\n            if(adj[i].size()%2)odds.push_back(i);\\n        }\\n        \\n        if(odds.size()>4 || odds.size()%2)return false;\\n        if(odds.size()==0)return true;\\n        if(odds.size()==2){\\n            if(adj[odds[0]].count(odds[1])==0){\\n                return true;\\n            }\\n            for(int i=1;i<adj.size();i++){\\n                if(i!=odds[0] and i!=odds[1] and adj[i].count(odds[0])==0 and adj[i].count(odds[1])==0){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        if(adj[odds[0]].count(odds[1])==0 and adj[odds[2]].count(odds[3])==0)return true;\\n        if(adj[odds[0]].count(odds[2])==0 and adj[odds[1]].count(odds[3])==0)return true;\\n        if(adj[odds[0]].count(odds[3])==0 and adj[odds[2]].count(odds[1])==0)return true;\\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923742,
                "title": "c-solution-using-adjacency-list-of-unordered-set",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        \\n        vector<unordered_set<int>>adj(n+1);\\n        for(auto it:edges)\\n        {\\n            adj[it[0]].insert(it[1]);\\n            adj[it[1]].insert(it[0]);\\n        }\\n        vector<int>temp;\\n        for(int i=1;i<=n;i++)\\n        {\\n            int n=adj[i].size();\\n            if(n%2==1)\\n            {\\n                temp.push_back(i);\\n            }\\n        }\\n        if(temp.size()==0)\\n        {\\n            return true;\\n        }\\n        if(temp.size()==2)\\n        {\\n            int a=temp[0];\\n            int b=temp[1];\\n            if(adj[a].find(b)==adj[a].end())\\n            {\\n                return true;\\n            }\\n            for(int i=1;i<=n;i++)\\n            {\\n                if((adj[i].find(a)==adj[i].end()) && (adj[i].find(b)==adj[i].end()))\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        if(temp.size()==4)\\n        {\\n            int a=temp[0];\\n            int b=temp[1];\\n            int c=temp[2];\\n            int d=temp[3];\\n            if((adj[a].find(b)==adj[a].end())&& (adj[c].find(d)==adj[c].end()))\\n            {\\n                return true;\\n            }\\n            else if((adj[a].find(c)==adj[a].end())&&(adj[b].find(d)==adj[b].end()))\\n            {\\n                return true;\\n            }\\n            else if((adj[a].find(d)==adj[a].end()) && (adj[b].find(c)==adj[b].end()))\\n            {\\n                return true;\\n            }\\n            return false;\\n        }\\n        return false;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        \\n        vector<unordered_set<int>>adj(n+1);\\n        for(auto it:edges)\\n        {\\n            adj[it[0]].insert(it[1]);\\n            adj[it[1]].insert(it[0]);\\n        }\\n        vector<int>temp;\\n        for(int i=1;i<=n;i++)\\n        {\\n            int n=adj[i].size();\\n            if(n%2==1)\\n            {\\n                temp.push_back(i);\\n            }\\n        }\\n        if(temp.size()==0)\\n        {\\n            return true;\\n        }\\n        if(temp.size()==2)\\n        {\\n            int a=temp[0];\\n            int b=temp[1];\\n            if(adj[a].find(b)==adj[a].end())\\n            {\\n                return true;\\n            }\\n            for(int i=1;i<=n;i++)\\n            {\\n                if((adj[i].find(a)==adj[i].end()) && (adj[i].find(b)==adj[i].end()))\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        if(temp.size()==4)\\n        {\\n            int a=temp[0];\\n            int b=temp[1];\\n            int c=temp[2];\\n            int d=temp[3];\\n            if((adj[a].find(b)==adj[a].end())&& (adj[c].find(d)==adj[c].end()))\\n            {\\n                return true;\\n            }\\n            else if((adj[a].find(c)==adj[a].end())&&(adj[b].find(d)==adj[b].end()))\\n            {\\n                return true;\\n            }\\n            else if((adj[a].find(d)==adj[a].end()) && (adj[b].find(c)==adj[b].end()))\\n            {\\n                return true;\\n            }\\n            return false;\\n        }\\n        return false;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1720063,
                "content": [
                    {
                        "username": "prit_manvar",
                        "content": "Possible Cases:\n1. number of nodes having `odd degree is more than 4` -> `return false`\n2. number of nodes having `odd degree is 4`\n             i -> find internal edges in these 4 nodes.\n             `if number of internal edges is 3 then return false else return true.`\n3. number of nodes having `odd degree is 2`\n            i -> there `isn't edge between these two nodes` having odd degree -> `return true`\n            ii -> search for node in graph who has not connection between both of nodes having odd degree. -> `if found then return true else return false`\n4. number of nodes having `odd degree is 0` -> `return true`\n\n\nNumber of nodes having odd degree will never be odd so i skipped cases like number of nodes having odd degree is 3 or 1."
                    },
                    {
                        "username": "vishnubathla",
                        "content": "was that only me or the test case \\n11\\n[[5,9],[8,1],[2,3],[7,10],[3,6],[6,7],[7,8],[5,1],[5,7],[10,11],[3,7],[6,11],[8,11],[3,4],[8,9],[9,1],[2,10],[9,11],[5,11],[2,5],[8,10],[2,7],[4,1],[3,10],[6,1],[4,9],[4,6],[4,5],[2,4],[2,11],[5,8],[6,9],[4,10],[3,11],[4,7],[3,5],[7,1],[2,9],[6,10],[10,1],[5,6],[3,9],[2,6],[7,9],[4,11],[4,8],[6,8],[3,8],[9,10],[5,10],[2,8],[7,11]]\\nwas wrong ?"
                    },
                    {
                        "username": "shankark",
                        "content": "I had the same problem. The odd edged nodes are [1,2,3,11]. If you are like me, most likely you are moving [1,2] into even-edged once you figured out that [1,2] doesn't have an edge. Now, for [3,11] you are also considering node [1,2] as they have become even-edged. So, don't do that and you will be ok.\n\nYes. Basically they have the wrong answer. But then they are the authors ;)"
                    },
                    {
                        "username": "Nitin_Kukreti",
                        "content": "if you find odd degree node then you realise they cannon be concerted into even degree do this in copy dont create complete graph just draw those node who have odd  degree"
                    },
                    {
                        "username": "sprs_2804",
                        "content": "same "
                    },
                    {
                        "username": "farziengineer",
                        "content": "Did they add some cases after the contest? I was passing all the test during the contest, now they show as WA :("
                    },
                    {
                        "username": "mage594088",
                        "content": "Me too. It sucks."
                    },
                    {
                        "username": "lebaur",
                        "content": "This question should be medium."
                    },
                    {
                        "username": "rayliux",
                        "content": "What's wrong with my memory? I recalled that in the contest I was able to solve this problem but today I found my solution yields WA. Were more test cases added?"
                    },
                    {
                        "username": "mage594088",
                        "content": "[@stash_](/stash_) Me too. WA at this additional case."
                    },
                    {
                        "username": "stash_",
                        "content": "Yes, they added 1 TC :(\\n5\\n[[4,3],[4,5],[5,3],[3,1],[5,2]]\\n"
                    },
                    {
                        "username": "jialihan",
                        "content": "The description is not clear that \"disconnected nodes\" not considered into the final solution. That means we don\\'t need to ensure the disconnected nodes with \"even\" edges."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "disconnected nodes have 0 degree. 0 is an even number"
                    },
                    {
                        "username": "shivansh961",
                        "content": "In this test case, 2 and 3 are the nodes with odd degree, but they both are already connected. So the answer should be false, but it is true.\nCan anyone explain me how ?\n\n\n\n\n[[2,19],[16,17],[8,14],[2,16],[12,20],[12,14],[16,18],[15,16],[10,21],[3,5],[13,18],[17,20],[14,17],[9,12],[5,15],[5,6],[3,7],\n[2,21],[10,13],[8,16],[7,18],[4,6],[9,1],[13,21],[18,20],[7,14],[4,19],[5,8],[3,11],[11,1],[7,12],[4,7],[3,16],[13,17],[17,19],\n[9,13],[7,19],[10,16],[4,13],[4,5],[2,15],[12,19],[11,16],[2,9],[11,17],[17,1],[16,21],[4,10],[10,14],[14,16],[4,1],[13,20],\n[5,20],[4,14],[4,21],[10,20],[2,14],[8,15],[4,8],[6,19],[15,1],[19,1],[8,19],[15,21],[3,12],[11,18],[9,17],[18,19],[7,21],[3,21],\n[16,19],[11,15],[5,1],[8,17],[3,15],[8,1],[10,19],[3,8],[6,16],[2,8],[5,18],[11,13],[11,20],[14,21],[6,20],[4,20],[12,13],[5,12],\n[10,11],[9,15],[3,19],[9,20],[14,18],[21,1],[13,19],[8,21],[2,13],[3,10],[9,18],[19,21],[6,7],[3,18],[2,18],[6,14],[3,17],[5,21],\n[14,20],[8,9],[16,1],[3,4],[13,1],[5,9],[4,15],[17,21],[20,21],[2,17],[13,14],[11,14],[9,16],[10,18],[6,15],[6,12],[3,13],[5,11],\n[6,1],[12,17],[8,10],[5,10],[8,18],[4,12],[10,1],[6,13],[4,18],[7,20],[7,16],[2,6],[12,21],[4,17],[15,18],[13,16],[15,20],[7,10],\n[6,10],[2,20],[7,15],[18,1],[12,1],[3,20],[7,1],[14,15],[4,9],[11,19],[7,9],[5,17],[18,21],[6,21],[8,11],[6,17],[3,14],[7,11],\n[5,7],[7,13],[6,8],[6,9],[10,12],[5,16],[2,4],[17,18],[9,11],[12,16],[3,6],[12,18],[3,9],[11,12],[14,19],[10,15],[5,13],[8,13],\n[15,17],[2,10],[11,21],[20,1],[6,18],[2,12],[19,20],[6,11],[8,12],[2,3],[12,15],[2,11],[9,10],[7,17],[9,19],[13,15],[7,8],[4,11],\n[2,5],[5,19],[16,20],[15,19],[9,14],[14,1],[10,17],[9,21],[2,7],[8,20],[5,14],[4,16]]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you can choose an even node which is not connected to 2 and 3 .... and connect both of them with that even  node... you need two extra edges to connect them.."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@CamLot_9889e](/CamLot_9889e) understood !!!"
                    },
                    {
                        "username": "CamLot_9889e",
                        "content": "// find a third common node to connect to, both have to connect to same node to maintain evenness of the other node,\\n // so they can\\'t already have an edge with that respective third node."
                    },
                    {
                        "username": "vamsibharadwajECE",
                        "content": "I am getting TLE for this code, please help!!\\n  `class Solution {\\n\\n    bool isthereedge(int x,int y, vector<int> adjlist[]){\\n        int listsize=adjlist[x].size();\\n        for(int i=0;i<listsize;i++){\\n            if(y==adjlist[x][i]) return true;\\n        }\\n        return false;\\n    }\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> adjlist[n+1];\\n        int numedges=edges.size();\\n        for(int i=0;i<numedges;i++){\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            adjlist[a].push_back(b);\\n            adjlist[b].push_back(a);\\n        }\\n        vector<int> indegree(n+1,0);\\n        for(int i=0;i<n+1;i++){\\n            indegree[i]=adjlist[i].size();\\n        }\\n        int oddcount=0;\\n        vector<int> odddegrees;\\n        vector<int> evendegrees;\\n        for(int i=1;i<indegree.size();i++){\\n            if(indegree[i]%2!=0) odddegrees.push_back(i);\\n            else evendegrees.push_back(i);\\n        }\\n        if(odddegrees.size()>4) return false;\\n        oddcount=odddegrees.size();\\n        if(oddcount==1) return false;\\n        if(oddcount==0) return true;\\n        if(oddcount==2){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist)) return true;\\n            for(int i=0;i<evendegrees.size();i++){\\n                if(!isthereedge(odddegrees[0],evendegrees[i],adjlist) && !isthereedge(odddegrees[1],evendegrees[i],adjlist)) return true;\\n            } \\n            return false;\\n        }\\n        if(oddcount==4){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist) && !isthereedge(odddegrees[2],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[2],adjlist) && !isthereedge(odddegrees[1],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[3],adjlist) && !isthereedge(odddegrees[2],odddegrees[1],adjlist)) return true;\\n        }\\n        return false;\\n    }\\n};`\\n\\nI have passed 46/52 cases but I do not understand why am I getting TLE here??"
                    },
                    {
                        "username": "ray920822",
                        "content": "try to check the existence of an edge in less than O(number of neighbors) time"
                    },
                    {
                        "username": "AuHg",
                        "content": "Why the number of nodes with odd degree will next  be odd in graph?"
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because each edge contributes 2 to the total degree of all nodes"
                    },
                    {
                        "username": "shubham-sable",
                        "content": "Can someone Help , why this is giving RTE\\nint inDegree[n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            inDegree[i]=0;\\n        }\\n        vector<int> adj[n+1];\\n        for(int i=0;i<n;i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(auto itr:adj[i])\\n            {\\n                inDegree[itr]++;\\n            }\\n        }\\n        int odd=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(inDegree[i]%2!=0)\\n            {\\n                odd++;\\n            }\\n        }\\n        if(odd%2==0 && odd<=4)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It looks fine\\nhard to say where error is"
                    }
                ]
            },
            {
                "id": 1719977,
                "content": [
                    {
                        "username": "prit_manvar",
                        "content": "Possible Cases:\n1. number of nodes having `odd degree is more than 4` -> `return false`\n2. number of nodes having `odd degree is 4`\n             i -> find internal edges in these 4 nodes.\n             `if number of internal edges is 3 then return false else return true.`\n3. number of nodes having `odd degree is 2`\n            i -> there `isn't edge between these two nodes` having odd degree -> `return true`\n            ii -> search for node in graph who has not connection between both of nodes having odd degree. -> `if found then return true else return false`\n4. number of nodes having `odd degree is 0` -> `return true`\n\n\nNumber of nodes having odd degree will never be odd so i skipped cases like number of nodes having odd degree is 3 or 1."
                    },
                    {
                        "username": "vishnubathla",
                        "content": "was that only me or the test case \\n11\\n[[5,9],[8,1],[2,3],[7,10],[3,6],[6,7],[7,8],[5,1],[5,7],[10,11],[3,7],[6,11],[8,11],[3,4],[8,9],[9,1],[2,10],[9,11],[5,11],[2,5],[8,10],[2,7],[4,1],[3,10],[6,1],[4,9],[4,6],[4,5],[2,4],[2,11],[5,8],[6,9],[4,10],[3,11],[4,7],[3,5],[7,1],[2,9],[6,10],[10,1],[5,6],[3,9],[2,6],[7,9],[4,11],[4,8],[6,8],[3,8],[9,10],[5,10],[2,8],[7,11]]\\nwas wrong ?"
                    },
                    {
                        "username": "shankark",
                        "content": "I had the same problem. The odd edged nodes are [1,2,3,11]. If you are like me, most likely you are moving [1,2] into even-edged once you figured out that [1,2] doesn't have an edge. Now, for [3,11] you are also considering node [1,2] as they have become even-edged. So, don't do that and you will be ok.\n\nYes. Basically they have the wrong answer. But then they are the authors ;)"
                    },
                    {
                        "username": "Nitin_Kukreti",
                        "content": "if you find odd degree node then you realise they cannon be concerted into even degree do this in copy dont create complete graph just draw those node who have odd  degree"
                    },
                    {
                        "username": "sprs_2804",
                        "content": "same "
                    },
                    {
                        "username": "farziengineer",
                        "content": "Did they add some cases after the contest? I was passing all the test during the contest, now they show as WA :("
                    },
                    {
                        "username": "mage594088",
                        "content": "Me too. It sucks."
                    },
                    {
                        "username": "lebaur",
                        "content": "This question should be medium."
                    },
                    {
                        "username": "rayliux",
                        "content": "What's wrong with my memory? I recalled that in the contest I was able to solve this problem but today I found my solution yields WA. Were more test cases added?"
                    },
                    {
                        "username": "mage594088",
                        "content": "[@stash_](/stash_) Me too. WA at this additional case."
                    },
                    {
                        "username": "stash_",
                        "content": "Yes, they added 1 TC :(\\n5\\n[[4,3],[4,5],[5,3],[3,1],[5,2]]\\n"
                    },
                    {
                        "username": "jialihan",
                        "content": "The description is not clear that \"disconnected nodes\" not considered into the final solution. That means we don\\'t need to ensure the disconnected nodes with \"even\" edges."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "disconnected nodes have 0 degree. 0 is an even number"
                    },
                    {
                        "username": "shivansh961",
                        "content": "In this test case, 2 and 3 are the nodes with odd degree, but they both are already connected. So the answer should be false, but it is true.\nCan anyone explain me how ?\n\n\n\n\n[[2,19],[16,17],[8,14],[2,16],[12,20],[12,14],[16,18],[15,16],[10,21],[3,5],[13,18],[17,20],[14,17],[9,12],[5,15],[5,6],[3,7],\n[2,21],[10,13],[8,16],[7,18],[4,6],[9,1],[13,21],[18,20],[7,14],[4,19],[5,8],[3,11],[11,1],[7,12],[4,7],[3,16],[13,17],[17,19],\n[9,13],[7,19],[10,16],[4,13],[4,5],[2,15],[12,19],[11,16],[2,9],[11,17],[17,1],[16,21],[4,10],[10,14],[14,16],[4,1],[13,20],\n[5,20],[4,14],[4,21],[10,20],[2,14],[8,15],[4,8],[6,19],[15,1],[19,1],[8,19],[15,21],[3,12],[11,18],[9,17],[18,19],[7,21],[3,21],\n[16,19],[11,15],[5,1],[8,17],[3,15],[8,1],[10,19],[3,8],[6,16],[2,8],[5,18],[11,13],[11,20],[14,21],[6,20],[4,20],[12,13],[5,12],\n[10,11],[9,15],[3,19],[9,20],[14,18],[21,1],[13,19],[8,21],[2,13],[3,10],[9,18],[19,21],[6,7],[3,18],[2,18],[6,14],[3,17],[5,21],\n[14,20],[8,9],[16,1],[3,4],[13,1],[5,9],[4,15],[17,21],[20,21],[2,17],[13,14],[11,14],[9,16],[10,18],[6,15],[6,12],[3,13],[5,11],\n[6,1],[12,17],[8,10],[5,10],[8,18],[4,12],[10,1],[6,13],[4,18],[7,20],[7,16],[2,6],[12,21],[4,17],[15,18],[13,16],[15,20],[7,10],\n[6,10],[2,20],[7,15],[18,1],[12,1],[3,20],[7,1],[14,15],[4,9],[11,19],[7,9],[5,17],[18,21],[6,21],[8,11],[6,17],[3,14],[7,11],\n[5,7],[7,13],[6,8],[6,9],[10,12],[5,16],[2,4],[17,18],[9,11],[12,16],[3,6],[12,18],[3,9],[11,12],[14,19],[10,15],[5,13],[8,13],\n[15,17],[2,10],[11,21],[20,1],[6,18],[2,12],[19,20],[6,11],[8,12],[2,3],[12,15],[2,11],[9,10],[7,17],[9,19],[13,15],[7,8],[4,11],\n[2,5],[5,19],[16,20],[15,19],[9,14],[14,1],[10,17],[9,21],[2,7],[8,20],[5,14],[4,16]]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you can choose an even node which is not connected to 2 and 3 .... and connect both of them with that even  node... you need two extra edges to connect them.."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@CamLot_9889e](/CamLot_9889e) understood !!!"
                    },
                    {
                        "username": "CamLot_9889e",
                        "content": "// find a third common node to connect to, both have to connect to same node to maintain evenness of the other node,\\n // so they can\\'t already have an edge with that respective third node."
                    },
                    {
                        "username": "vamsibharadwajECE",
                        "content": "I am getting TLE for this code, please help!!\\n  `class Solution {\\n\\n    bool isthereedge(int x,int y, vector<int> adjlist[]){\\n        int listsize=adjlist[x].size();\\n        for(int i=0;i<listsize;i++){\\n            if(y==adjlist[x][i]) return true;\\n        }\\n        return false;\\n    }\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> adjlist[n+1];\\n        int numedges=edges.size();\\n        for(int i=0;i<numedges;i++){\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            adjlist[a].push_back(b);\\n            adjlist[b].push_back(a);\\n        }\\n        vector<int> indegree(n+1,0);\\n        for(int i=0;i<n+1;i++){\\n            indegree[i]=adjlist[i].size();\\n        }\\n        int oddcount=0;\\n        vector<int> odddegrees;\\n        vector<int> evendegrees;\\n        for(int i=1;i<indegree.size();i++){\\n            if(indegree[i]%2!=0) odddegrees.push_back(i);\\n            else evendegrees.push_back(i);\\n        }\\n        if(odddegrees.size()>4) return false;\\n        oddcount=odddegrees.size();\\n        if(oddcount==1) return false;\\n        if(oddcount==0) return true;\\n        if(oddcount==2){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist)) return true;\\n            for(int i=0;i<evendegrees.size();i++){\\n                if(!isthereedge(odddegrees[0],evendegrees[i],adjlist) && !isthereedge(odddegrees[1],evendegrees[i],adjlist)) return true;\\n            } \\n            return false;\\n        }\\n        if(oddcount==4){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist) && !isthereedge(odddegrees[2],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[2],adjlist) && !isthereedge(odddegrees[1],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[3],adjlist) && !isthereedge(odddegrees[2],odddegrees[1],adjlist)) return true;\\n        }\\n        return false;\\n    }\\n};`\\n\\nI have passed 46/52 cases but I do not understand why am I getting TLE here??"
                    },
                    {
                        "username": "ray920822",
                        "content": "try to check the existence of an edge in less than O(number of neighbors) time"
                    },
                    {
                        "username": "AuHg",
                        "content": "Why the number of nodes with odd degree will next  be odd in graph?"
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because each edge contributes 2 to the total degree of all nodes"
                    },
                    {
                        "username": "shubham-sable",
                        "content": "Can someone Help , why this is giving RTE\\nint inDegree[n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            inDegree[i]=0;\\n        }\\n        vector<int> adj[n+1];\\n        for(int i=0;i<n;i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(auto itr:adj[i])\\n            {\\n                inDegree[itr]++;\\n            }\\n        }\\n        int odd=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(inDegree[i]%2!=0)\\n            {\\n                odd++;\\n            }\\n        }\\n        if(odd%2==0 && odd<=4)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It looks fine\\nhard to say where error is"
                    }
                ]
            },
            {
                "id": 1723948,
                "content": [
                    {
                        "username": "prit_manvar",
                        "content": "Possible Cases:\n1. number of nodes having `odd degree is more than 4` -> `return false`\n2. number of nodes having `odd degree is 4`\n             i -> find internal edges in these 4 nodes.\n             `if number of internal edges is 3 then return false else return true.`\n3. number of nodes having `odd degree is 2`\n            i -> there `isn't edge between these two nodes` having odd degree -> `return true`\n            ii -> search for node in graph who has not connection between both of nodes having odd degree. -> `if found then return true else return false`\n4. number of nodes having `odd degree is 0` -> `return true`\n\n\nNumber of nodes having odd degree will never be odd so i skipped cases like number of nodes having odd degree is 3 or 1."
                    },
                    {
                        "username": "vishnubathla",
                        "content": "was that only me or the test case \\n11\\n[[5,9],[8,1],[2,3],[7,10],[3,6],[6,7],[7,8],[5,1],[5,7],[10,11],[3,7],[6,11],[8,11],[3,4],[8,9],[9,1],[2,10],[9,11],[5,11],[2,5],[8,10],[2,7],[4,1],[3,10],[6,1],[4,9],[4,6],[4,5],[2,4],[2,11],[5,8],[6,9],[4,10],[3,11],[4,7],[3,5],[7,1],[2,9],[6,10],[10,1],[5,6],[3,9],[2,6],[7,9],[4,11],[4,8],[6,8],[3,8],[9,10],[5,10],[2,8],[7,11]]\\nwas wrong ?"
                    },
                    {
                        "username": "shankark",
                        "content": "I had the same problem. The odd edged nodes are [1,2,3,11]. If you are like me, most likely you are moving [1,2] into even-edged once you figured out that [1,2] doesn't have an edge. Now, for [3,11] you are also considering node [1,2] as they have become even-edged. So, don't do that and you will be ok.\n\nYes. Basically they have the wrong answer. But then they are the authors ;)"
                    },
                    {
                        "username": "Nitin_Kukreti",
                        "content": "if you find odd degree node then you realise they cannon be concerted into even degree do this in copy dont create complete graph just draw those node who have odd  degree"
                    },
                    {
                        "username": "sprs_2804",
                        "content": "same "
                    },
                    {
                        "username": "farziengineer",
                        "content": "Did they add some cases after the contest? I was passing all the test during the contest, now they show as WA :("
                    },
                    {
                        "username": "mage594088",
                        "content": "Me too. It sucks."
                    },
                    {
                        "username": "lebaur",
                        "content": "This question should be medium."
                    },
                    {
                        "username": "rayliux",
                        "content": "What's wrong with my memory? I recalled that in the contest I was able to solve this problem but today I found my solution yields WA. Were more test cases added?"
                    },
                    {
                        "username": "mage594088",
                        "content": "[@stash_](/stash_) Me too. WA at this additional case."
                    },
                    {
                        "username": "stash_",
                        "content": "Yes, they added 1 TC :(\\n5\\n[[4,3],[4,5],[5,3],[3,1],[5,2]]\\n"
                    },
                    {
                        "username": "jialihan",
                        "content": "The description is not clear that \"disconnected nodes\" not considered into the final solution. That means we don\\'t need to ensure the disconnected nodes with \"even\" edges."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "disconnected nodes have 0 degree. 0 is an even number"
                    },
                    {
                        "username": "shivansh961",
                        "content": "In this test case, 2 and 3 are the nodes with odd degree, but they both are already connected. So the answer should be false, but it is true.\nCan anyone explain me how ?\n\n\n\n\n[[2,19],[16,17],[8,14],[2,16],[12,20],[12,14],[16,18],[15,16],[10,21],[3,5],[13,18],[17,20],[14,17],[9,12],[5,15],[5,6],[3,7],\n[2,21],[10,13],[8,16],[7,18],[4,6],[9,1],[13,21],[18,20],[7,14],[4,19],[5,8],[3,11],[11,1],[7,12],[4,7],[3,16],[13,17],[17,19],\n[9,13],[7,19],[10,16],[4,13],[4,5],[2,15],[12,19],[11,16],[2,9],[11,17],[17,1],[16,21],[4,10],[10,14],[14,16],[4,1],[13,20],\n[5,20],[4,14],[4,21],[10,20],[2,14],[8,15],[4,8],[6,19],[15,1],[19,1],[8,19],[15,21],[3,12],[11,18],[9,17],[18,19],[7,21],[3,21],\n[16,19],[11,15],[5,1],[8,17],[3,15],[8,1],[10,19],[3,8],[6,16],[2,8],[5,18],[11,13],[11,20],[14,21],[6,20],[4,20],[12,13],[5,12],\n[10,11],[9,15],[3,19],[9,20],[14,18],[21,1],[13,19],[8,21],[2,13],[3,10],[9,18],[19,21],[6,7],[3,18],[2,18],[6,14],[3,17],[5,21],\n[14,20],[8,9],[16,1],[3,4],[13,1],[5,9],[4,15],[17,21],[20,21],[2,17],[13,14],[11,14],[9,16],[10,18],[6,15],[6,12],[3,13],[5,11],\n[6,1],[12,17],[8,10],[5,10],[8,18],[4,12],[10,1],[6,13],[4,18],[7,20],[7,16],[2,6],[12,21],[4,17],[15,18],[13,16],[15,20],[7,10],\n[6,10],[2,20],[7,15],[18,1],[12,1],[3,20],[7,1],[14,15],[4,9],[11,19],[7,9],[5,17],[18,21],[6,21],[8,11],[6,17],[3,14],[7,11],\n[5,7],[7,13],[6,8],[6,9],[10,12],[5,16],[2,4],[17,18],[9,11],[12,16],[3,6],[12,18],[3,9],[11,12],[14,19],[10,15],[5,13],[8,13],\n[15,17],[2,10],[11,21],[20,1],[6,18],[2,12],[19,20],[6,11],[8,12],[2,3],[12,15],[2,11],[9,10],[7,17],[9,19],[13,15],[7,8],[4,11],\n[2,5],[5,19],[16,20],[15,19],[9,14],[14,1],[10,17],[9,21],[2,7],[8,20],[5,14],[4,16]]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you can choose an even node which is not connected to 2 and 3 .... and connect both of them with that even  node... you need two extra edges to connect them.."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@CamLot_9889e](/CamLot_9889e) understood !!!"
                    },
                    {
                        "username": "CamLot_9889e",
                        "content": "// find a third common node to connect to, both have to connect to same node to maintain evenness of the other node,\\n // so they can\\'t already have an edge with that respective third node."
                    },
                    {
                        "username": "vamsibharadwajECE",
                        "content": "I am getting TLE for this code, please help!!\\n  `class Solution {\\n\\n    bool isthereedge(int x,int y, vector<int> adjlist[]){\\n        int listsize=adjlist[x].size();\\n        for(int i=0;i<listsize;i++){\\n            if(y==adjlist[x][i]) return true;\\n        }\\n        return false;\\n    }\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> adjlist[n+1];\\n        int numedges=edges.size();\\n        for(int i=0;i<numedges;i++){\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            adjlist[a].push_back(b);\\n            adjlist[b].push_back(a);\\n        }\\n        vector<int> indegree(n+1,0);\\n        for(int i=0;i<n+1;i++){\\n            indegree[i]=adjlist[i].size();\\n        }\\n        int oddcount=0;\\n        vector<int> odddegrees;\\n        vector<int> evendegrees;\\n        for(int i=1;i<indegree.size();i++){\\n            if(indegree[i]%2!=0) odddegrees.push_back(i);\\n            else evendegrees.push_back(i);\\n        }\\n        if(odddegrees.size()>4) return false;\\n        oddcount=odddegrees.size();\\n        if(oddcount==1) return false;\\n        if(oddcount==0) return true;\\n        if(oddcount==2){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist)) return true;\\n            for(int i=0;i<evendegrees.size();i++){\\n                if(!isthereedge(odddegrees[0],evendegrees[i],adjlist) && !isthereedge(odddegrees[1],evendegrees[i],adjlist)) return true;\\n            } \\n            return false;\\n        }\\n        if(oddcount==4){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist) && !isthereedge(odddegrees[2],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[2],adjlist) && !isthereedge(odddegrees[1],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[3],adjlist) && !isthereedge(odddegrees[2],odddegrees[1],adjlist)) return true;\\n        }\\n        return false;\\n    }\\n};`\\n\\nI have passed 46/52 cases but I do not understand why am I getting TLE here??"
                    },
                    {
                        "username": "ray920822",
                        "content": "try to check the existence of an edge in less than O(number of neighbors) time"
                    },
                    {
                        "username": "AuHg",
                        "content": "Why the number of nodes with odd degree will next  be odd in graph?"
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because each edge contributes 2 to the total degree of all nodes"
                    },
                    {
                        "username": "shubham-sable",
                        "content": "Can someone Help , why this is giving RTE\\nint inDegree[n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            inDegree[i]=0;\\n        }\\n        vector<int> adj[n+1];\\n        for(int i=0;i<n;i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(auto itr:adj[i])\\n            {\\n                inDegree[itr]++;\\n            }\\n        }\\n        int odd=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(inDegree[i]%2!=0)\\n            {\\n                odd++;\\n            }\\n        }\\n        if(odd%2==0 && odd<=4)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It looks fine\\nhard to say where error is"
                    }
                ]
            },
            {
                "id": 1734361,
                "content": [
                    {
                        "username": "prit_manvar",
                        "content": "Possible Cases:\n1. number of nodes having `odd degree is more than 4` -> `return false`\n2. number of nodes having `odd degree is 4`\n             i -> find internal edges in these 4 nodes.\n             `if number of internal edges is 3 then return false else return true.`\n3. number of nodes having `odd degree is 2`\n            i -> there `isn't edge between these two nodes` having odd degree -> `return true`\n            ii -> search for node in graph who has not connection between both of nodes having odd degree. -> `if found then return true else return false`\n4. number of nodes having `odd degree is 0` -> `return true`\n\n\nNumber of nodes having odd degree will never be odd so i skipped cases like number of nodes having odd degree is 3 or 1."
                    },
                    {
                        "username": "vishnubathla",
                        "content": "was that only me or the test case \\n11\\n[[5,9],[8,1],[2,3],[7,10],[3,6],[6,7],[7,8],[5,1],[5,7],[10,11],[3,7],[6,11],[8,11],[3,4],[8,9],[9,1],[2,10],[9,11],[5,11],[2,5],[8,10],[2,7],[4,1],[3,10],[6,1],[4,9],[4,6],[4,5],[2,4],[2,11],[5,8],[6,9],[4,10],[3,11],[4,7],[3,5],[7,1],[2,9],[6,10],[10,1],[5,6],[3,9],[2,6],[7,9],[4,11],[4,8],[6,8],[3,8],[9,10],[5,10],[2,8],[7,11]]\\nwas wrong ?"
                    },
                    {
                        "username": "shankark",
                        "content": "I had the same problem. The odd edged nodes are [1,2,3,11]. If you are like me, most likely you are moving [1,2] into even-edged once you figured out that [1,2] doesn't have an edge. Now, for [3,11] you are also considering node [1,2] as they have become even-edged. So, don't do that and you will be ok.\n\nYes. Basically they have the wrong answer. But then they are the authors ;)"
                    },
                    {
                        "username": "Nitin_Kukreti",
                        "content": "if you find odd degree node then you realise they cannon be concerted into even degree do this in copy dont create complete graph just draw those node who have odd  degree"
                    },
                    {
                        "username": "sprs_2804",
                        "content": "same "
                    },
                    {
                        "username": "farziengineer",
                        "content": "Did they add some cases after the contest? I was passing all the test during the contest, now they show as WA :("
                    },
                    {
                        "username": "mage594088",
                        "content": "Me too. It sucks."
                    },
                    {
                        "username": "lebaur",
                        "content": "This question should be medium."
                    },
                    {
                        "username": "rayliux",
                        "content": "What's wrong with my memory? I recalled that in the contest I was able to solve this problem but today I found my solution yields WA. Were more test cases added?"
                    },
                    {
                        "username": "mage594088",
                        "content": "[@stash_](/stash_) Me too. WA at this additional case."
                    },
                    {
                        "username": "stash_",
                        "content": "Yes, they added 1 TC :(\\n5\\n[[4,3],[4,5],[5,3],[3,1],[5,2]]\\n"
                    },
                    {
                        "username": "jialihan",
                        "content": "The description is not clear that \"disconnected nodes\" not considered into the final solution. That means we don\\'t need to ensure the disconnected nodes with \"even\" edges."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "disconnected nodes have 0 degree. 0 is an even number"
                    },
                    {
                        "username": "shivansh961",
                        "content": "In this test case, 2 and 3 are the nodes with odd degree, but they both are already connected. So the answer should be false, but it is true.\nCan anyone explain me how ?\n\n\n\n\n[[2,19],[16,17],[8,14],[2,16],[12,20],[12,14],[16,18],[15,16],[10,21],[3,5],[13,18],[17,20],[14,17],[9,12],[5,15],[5,6],[3,7],\n[2,21],[10,13],[8,16],[7,18],[4,6],[9,1],[13,21],[18,20],[7,14],[4,19],[5,8],[3,11],[11,1],[7,12],[4,7],[3,16],[13,17],[17,19],\n[9,13],[7,19],[10,16],[4,13],[4,5],[2,15],[12,19],[11,16],[2,9],[11,17],[17,1],[16,21],[4,10],[10,14],[14,16],[4,1],[13,20],\n[5,20],[4,14],[4,21],[10,20],[2,14],[8,15],[4,8],[6,19],[15,1],[19,1],[8,19],[15,21],[3,12],[11,18],[9,17],[18,19],[7,21],[3,21],\n[16,19],[11,15],[5,1],[8,17],[3,15],[8,1],[10,19],[3,8],[6,16],[2,8],[5,18],[11,13],[11,20],[14,21],[6,20],[4,20],[12,13],[5,12],\n[10,11],[9,15],[3,19],[9,20],[14,18],[21,1],[13,19],[8,21],[2,13],[3,10],[9,18],[19,21],[6,7],[3,18],[2,18],[6,14],[3,17],[5,21],\n[14,20],[8,9],[16,1],[3,4],[13,1],[5,9],[4,15],[17,21],[20,21],[2,17],[13,14],[11,14],[9,16],[10,18],[6,15],[6,12],[3,13],[5,11],\n[6,1],[12,17],[8,10],[5,10],[8,18],[4,12],[10,1],[6,13],[4,18],[7,20],[7,16],[2,6],[12,21],[4,17],[15,18],[13,16],[15,20],[7,10],\n[6,10],[2,20],[7,15],[18,1],[12,1],[3,20],[7,1],[14,15],[4,9],[11,19],[7,9],[5,17],[18,21],[6,21],[8,11],[6,17],[3,14],[7,11],\n[5,7],[7,13],[6,8],[6,9],[10,12],[5,16],[2,4],[17,18],[9,11],[12,16],[3,6],[12,18],[3,9],[11,12],[14,19],[10,15],[5,13],[8,13],\n[15,17],[2,10],[11,21],[20,1],[6,18],[2,12],[19,20],[6,11],[8,12],[2,3],[12,15],[2,11],[9,10],[7,17],[9,19],[13,15],[7,8],[4,11],\n[2,5],[5,19],[16,20],[15,19],[9,14],[14,1],[10,17],[9,21],[2,7],[8,20],[5,14],[4,16]]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you can choose an even node which is not connected to 2 and 3 .... and connect both of them with that even  node... you need two extra edges to connect them.."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@CamLot_9889e](/CamLot_9889e) understood !!!"
                    },
                    {
                        "username": "CamLot_9889e",
                        "content": "// find a third common node to connect to, both have to connect to same node to maintain evenness of the other node,\\n // so they can\\'t already have an edge with that respective third node."
                    },
                    {
                        "username": "vamsibharadwajECE",
                        "content": "I am getting TLE for this code, please help!!\\n  `class Solution {\\n\\n    bool isthereedge(int x,int y, vector<int> adjlist[]){\\n        int listsize=adjlist[x].size();\\n        for(int i=0;i<listsize;i++){\\n            if(y==adjlist[x][i]) return true;\\n        }\\n        return false;\\n    }\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> adjlist[n+1];\\n        int numedges=edges.size();\\n        for(int i=0;i<numedges;i++){\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            adjlist[a].push_back(b);\\n            adjlist[b].push_back(a);\\n        }\\n        vector<int> indegree(n+1,0);\\n        for(int i=0;i<n+1;i++){\\n            indegree[i]=adjlist[i].size();\\n        }\\n        int oddcount=0;\\n        vector<int> odddegrees;\\n        vector<int> evendegrees;\\n        for(int i=1;i<indegree.size();i++){\\n            if(indegree[i]%2!=0) odddegrees.push_back(i);\\n            else evendegrees.push_back(i);\\n        }\\n        if(odddegrees.size()>4) return false;\\n        oddcount=odddegrees.size();\\n        if(oddcount==1) return false;\\n        if(oddcount==0) return true;\\n        if(oddcount==2){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist)) return true;\\n            for(int i=0;i<evendegrees.size();i++){\\n                if(!isthereedge(odddegrees[0],evendegrees[i],adjlist) && !isthereedge(odddegrees[1],evendegrees[i],adjlist)) return true;\\n            } \\n            return false;\\n        }\\n        if(oddcount==4){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist) && !isthereedge(odddegrees[2],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[2],adjlist) && !isthereedge(odddegrees[1],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[3],adjlist) && !isthereedge(odddegrees[2],odddegrees[1],adjlist)) return true;\\n        }\\n        return false;\\n    }\\n};`\\n\\nI have passed 46/52 cases but I do not understand why am I getting TLE here??"
                    },
                    {
                        "username": "ray920822",
                        "content": "try to check the existence of an edge in less than O(number of neighbors) time"
                    },
                    {
                        "username": "AuHg",
                        "content": "Why the number of nodes with odd degree will next  be odd in graph?"
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because each edge contributes 2 to the total degree of all nodes"
                    },
                    {
                        "username": "shubham-sable",
                        "content": "Can someone Help , why this is giving RTE\\nint inDegree[n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            inDegree[i]=0;\\n        }\\n        vector<int> adj[n+1];\\n        for(int i=0;i<n;i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(auto itr:adj[i])\\n            {\\n                inDegree[itr]++;\\n            }\\n        }\\n        int odd=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(inDegree[i]%2!=0)\\n            {\\n                odd++;\\n            }\\n        }\\n        if(odd%2==0 && odd<=4)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It looks fine\\nhard to say where error is"
                    }
                ]
            },
            {
                "id": 1722910,
                "content": [
                    {
                        "username": "prit_manvar",
                        "content": "Possible Cases:\n1. number of nodes having `odd degree is more than 4` -> `return false`\n2. number of nodes having `odd degree is 4`\n             i -> find internal edges in these 4 nodes.\n             `if number of internal edges is 3 then return false else return true.`\n3. number of nodes having `odd degree is 2`\n            i -> there `isn't edge between these two nodes` having odd degree -> `return true`\n            ii -> search for node in graph who has not connection between both of nodes having odd degree. -> `if found then return true else return false`\n4. number of nodes having `odd degree is 0` -> `return true`\n\n\nNumber of nodes having odd degree will never be odd so i skipped cases like number of nodes having odd degree is 3 or 1."
                    },
                    {
                        "username": "vishnubathla",
                        "content": "was that only me or the test case \\n11\\n[[5,9],[8,1],[2,3],[7,10],[3,6],[6,7],[7,8],[5,1],[5,7],[10,11],[3,7],[6,11],[8,11],[3,4],[8,9],[9,1],[2,10],[9,11],[5,11],[2,5],[8,10],[2,7],[4,1],[3,10],[6,1],[4,9],[4,6],[4,5],[2,4],[2,11],[5,8],[6,9],[4,10],[3,11],[4,7],[3,5],[7,1],[2,9],[6,10],[10,1],[5,6],[3,9],[2,6],[7,9],[4,11],[4,8],[6,8],[3,8],[9,10],[5,10],[2,8],[7,11]]\\nwas wrong ?"
                    },
                    {
                        "username": "shankark",
                        "content": "I had the same problem. The odd edged nodes are [1,2,3,11]. If you are like me, most likely you are moving [1,2] into even-edged once you figured out that [1,2] doesn't have an edge. Now, for [3,11] you are also considering node [1,2] as they have become even-edged. So, don't do that and you will be ok.\n\nYes. Basically they have the wrong answer. But then they are the authors ;)"
                    },
                    {
                        "username": "Nitin_Kukreti",
                        "content": "if you find odd degree node then you realise they cannon be concerted into even degree do this in copy dont create complete graph just draw those node who have odd  degree"
                    },
                    {
                        "username": "sprs_2804",
                        "content": "same "
                    },
                    {
                        "username": "farziengineer",
                        "content": "Did they add some cases after the contest? I was passing all the test during the contest, now they show as WA :("
                    },
                    {
                        "username": "mage594088",
                        "content": "Me too. It sucks."
                    },
                    {
                        "username": "lebaur",
                        "content": "This question should be medium."
                    },
                    {
                        "username": "rayliux",
                        "content": "What's wrong with my memory? I recalled that in the contest I was able to solve this problem but today I found my solution yields WA. Were more test cases added?"
                    },
                    {
                        "username": "mage594088",
                        "content": "[@stash_](/stash_) Me too. WA at this additional case."
                    },
                    {
                        "username": "stash_",
                        "content": "Yes, they added 1 TC :(\\n5\\n[[4,3],[4,5],[5,3],[3,1],[5,2]]\\n"
                    },
                    {
                        "username": "jialihan",
                        "content": "The description is not clear that \"disconnected nodes\" not considered into the final solution. That means we don\\'t need to ensure the disconnected nodes with \"even\" edges."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "disconnected nodes have 0 degree. 0 is an even number"
                    },
                    {
                        "username": "shivansh961",
                        "content": "In this test case, 2 and 3 are the nodes with odd degree, but they both are already connected. So the answer should be false, but it is true.\nCan anyone explain me how ?\n\n\n\n\n[[2,19],[16,17],[8,14],[2,16],[12,20],[12,14],[16,18],[15,16],[10,21],[3,5],[13,18],[17,20],[14,17],[9,12],[5,15],[5,6],[3,7],\n[2,21],[10,13],[8,16],[7,18],[4,6],[9,1],[13,21],[18,20],[7,14],[4,19],[5,8],[3,11],[11,1],[7,12],[4,7],[3,16],[13,17],[17,19],\n[9,13],[7,19],[10,16],[4,13],[4,5],[2,15],[12,19],[11,16],[2,9],[11,17],[17,1],[16,21],[4,10],[10,14],[14,16],[4,1],[13,20],\n[5,20],[4,14],[4,21],[10,20],[2,14],[8,15],[4,8],[6,19],[15,1],[19,1],[8,19],[15,21],[3,12],[11,18],[9,17],[18,19],[7,21],[3,21],\n[16,19],[11,15],[5,1],[8,17],[3,15],[8,1],[10,19],[3,8],[6,16],[2,8],[5,18],[11,13],[11,20],[14,21],[6,20],[4,20],[12,13],[5,12],\n[10,11],[9,15],[3,19],[9,20],[14,18],[21,1],[13,19],[8,21],[2,13],[3,10],[9,18],[19,21],[6,7],[3,18],[2,18],[6,14],[3,17],[5,21],\n[14,20],[8,9],[16,1],[3,4],[13,1],[5,9],[4,15],[17,21],[20,21],[2,17],[13,14],[11,14],[9,16],[10,18],[6,15],[6,12],[3,13],[5,11],\n[6,1],[12,17],[8,10],[5,10],[8,18],[4,12],[10,1],[6,13],[4,18],[7,20],[7,16],[2,6],[12,21],[4,17],[15,18],[13,16],[15,20],[7,10],\n[6,10],[2,20],[7,15],[18,1],[12,1],[3,20],[7,1],[14,15],[4,9],[11,19],[7,9],[5,17],[18,21],[6,21],[8,11],[6,17],[3,14],[7,11],\n[5,7],[7,13],[6,8],[6,9],[10,12],[5,16],[2,4],[17,18],[9,11],[12,16],[3,6],[12,18],[3,9],[11,12],[14,19],[10,15],[5,13],[8,13],\n[15,17],[2,10],[11,21],[20,1],[6,18],[2,12],[19,20],[6,11],[8,12],[2,3],[12,15],[2,11],[9,10],[7,17],[9,19],[13,15],[7,8],[4,11],\n[2,5],[5,19],[16,20],[15,19],[9,14],[14,1],[10,17],[9,21],[2,7],[8,20],[5,14],[4,16]]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you can choose an even node which is not connected to 2 and 3 .... and connect both of them with that even  node... you need two extra edges to connect them.."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@CamLot_9889e](/CamLot_9889e) understood !!!"
                    },
                    {
                        "username": "CamLot_9889e",
                        "content": "// find a third common node to connect to, both have to connect to same node to maintain evenness of the other node,\\n // so they can\\'t already have an edge with that respective third node."
                    },
                    {
                        "username": "vamsibharadwajECE",
                        "content": "I am getting TLE for this code, please help!!\\n  `class Solution {\\n\\n    bool isthereedge(int x,int y, vector<int> adjlist[]){\\n        int listsize=adjlist[x].size();\\n        for(int i=0;i<listsize;i++){\\n            if(y==adjlist[x][i]) return true;\\n        }\\n        return false;\\n    }\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> adjlist[n+1];\\n        int numedges=edges.size();\\n        for(int i=0;i<numedges;i++){\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            adjlist[a].push_back(b);\\n            adjlist[b].push_back(a);\\n        }\\n        vector<int> indegree(n+1,0);\\n        for(int i=0;i<n+1;i++){\\n            indegree[i]=adjlist[i].size();\\n        }\\n        int oddcount=0;\\n        vector<int> odddegrees;\\n        vector<int> evendegrees;\\n        for(int i=1;i<indegree.size();i++){\\n            if(indegree[i]%2!=0) odddegrees.push_back(i);\\n            else evendegrees.push_back(i);\\n        }\\n        if(odddegrees.size()>4) return false;\\n        oddcount=odddegrees.size();\\n        if(oddcount==1) return false;\\n        if(oddcount==0) return true;\\n        if(oddcount==2){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist)) return true;\\n            for(int i=0;i<evendegrees.size();i++){\\n                if(!isthereedge(odddegrees[0],evendegrees[i],adjlist) && !isthereedge(odddegrees[1],evendegrees[i],adjlist)) return true;\\n            } \\n            return false;\\n        }\\n        if(oddcount==4){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist) && !isthereedge(odddegrees[2],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[2],adjlist) && !isthereedge(odddegrees[1],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[3],adjlist) && !isthereedge(odddegrees[2],odddegrees[1],adjlist)) return true;\\n        }\\n        return false;\\n    }\\n};`\\n\\nI have passed 46/52 cases but I do not understand why am I getting TLE here??"
                    },
                    {
                        "username": "ray920822",
                        "content": "try to check the existence of an edge in less than O(number of neighbors) time"
                    },
                    {
                        "username": "AuHg",
                        "content": "Why the number of nodes with odd degree will next  be odd in graph?"
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because each edge contributes 2 to the total degree of all nodes"
                    },
                    {
                        "username": "shubham-sable",
                        "content": "Can someone Help , why this is giving RTE\\nint inDegree[n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            inDegree[i]=0;\\n        }\\n        vector<int> adj[n+1];\\n        for(int i=0;i<n;i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(auto itr:adj[i])\\n            {\\n                inDegree[itr]++;\\n            }\\n        }\\n        int odd=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(inDegree[i]%2!=0)\\n            {\\n                odd++;\\n            }\\n        }\\n        if(odd%2==0 && odd<=4)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It looks fine\\nhard to say where error is"
                    }
                ]
            },
            {
                "id": 1720077,
                "content": [
                    {
                        "username": "prit_manvar",
                        "content": "Possible Cases:\n1. number of nodes having `odd degree is more than 4` -> `return false`\n2. number of nodes having `odd degree is 4`\n             i -> find internal edges in these 4 nodes.\n             `if number of internal edges is 3 then return false else return true.`\n3. number of nodes having `odd degree is 2`\n            i -> there `isn't edge between these two nodes` having odd degree -> `return true`\n            ii -> search for node in graph who has not connection between both of nodes having odd degree. -> `if found then return true else return false`\n4. number of nodes having `odd degree is 0` -> `return true`\n\n\nNumber of nodes having odd degree will never be odd so i skipped cases like number of nodes having odd degree is 3 or 1."
                    },
                    {
                        "username": "vishnubathla",
                        "content": "was that only me or the test case \\n11\\n[[5,9],[8,1],[2,3],[7,10],[3,6],[6,7],[7,8],[5,1],[5,7],[10,11],[3,7],[6,11],[8,11],[3,4],[8,9],[9,1],[2,10],[9,11],[5,11],[2,5],[8,10],[2,7],[4,1],[3,10],[6,1],[4,9],[4,6],[4,5],[2,4],[2,11],[5,8],[6,9],[4,10],[3,11],[4,7],[3,5],[7,1],[2,9],[6,10],[10,1],[5,6],[3,9],[2,6],[7,9],[4,11],[4,8],[6,8],[3,8],[9,10],[5,10],[2,8],[7,11]]\\nwas wrong ?"
                    },
                    {
                        "username": "shankark",
                        "content": "I had the same problem. The odd edged nodes are [1,2,3,11]. If you are like me, most likely you are moving [1,2] into even-edged once you figured out that [1,2] doesn't have an edge. Now, for [3,11] you are also considering node [1,2] as they have become even-edged. So, don't do that and you will be ok.\n\nYes. Basically they have the wrong answer. But then they are the authors ;)"
                    },
                    {
                        "username": "Nitin_Kukreti",
                        "content": "if you find odd degree node then you realise they cannon be concerted into even degree do this in copy dont create complete graph just draw those node who have odd  degree"
                    },
                    {
                        "username": "sprs_2804",
                        "content": "same "
                    },
                    {
                        "username": "farziengineer",
                        "content": "Did they add some cases after the contest? I was passing all the test during the contest, now they show as WA :("
                    },
                    {
                        "username": "mage594088",
                        "content": "Me too. It sucks."
                    },
                    {
                        "username": "lebaur",
                        "content": "This question should be medium."
                    },
                    {
                        "username": "rayliux",
                        "content": "What's wrong with my memory? I recalled that in the contest I was able to solve this problem but today I found my solution yields WA. Were more test cases added?"
                    },
                    {
                        "username": "mage594088",
                        "content": "[@stash_](/stash_) Me too. WA at this additional case."
                    },
                    {
                        "username": "stash_",
                        "content": "Yes, they added 1 TC :(\\n5\\n[[4,3],[4,5],[5,3],[3,1],[5,2]]\\n"
                    },
                    {
                        "username": "jialihan",
                        "content": "The description is not clear that \"disconnected nodes\" not considered into the final solution. That means we don\\'t need to ensure the disconnected nodes with \"even\" edges."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "disconnected nodes have 0 degree. 0 is an even number"
                    },
                    {
                        "username": "shivansh961",
                        "content": "In this test case, 2 and 3 are the nodes with odd degree, but they both are already connected. So the answer should be false, but it is true.\nCan anyone explain me how ?\n\n\n\n\n[[2,19],[16,17],[8,14],[2,16],[12,20],[12,14],[16,18],[15,16],[10,21],[3,5],[13,18],[17,20],[14,17],[9,12],[5,15],[5,6],[3,7],\n[2,21],[10,13],[8,16],[7,18],[4,6],[9,1],[13,21],[18,20],[7,14],[4,19],[5,8],[3,11],[11,1],[7,12],[4,7],[3,16],[13,17],[17,19],\n[9,13],[7,19],[10,16],[4,13],[4,5],[2,15],[12,19],[11,16],[2,9],[11,17],[17,1],[16,21],[4,10],[10,14],[14,16],[4,1],[13,20],\n[5,20],[4,14],[4,21],[10,20],[2,14],[8,15],[4,8],[6,19],[15,1],[19,1],[8,19],[15,21],[3,12],[11,18],[9,17],[18,19],[7,21],[3,21],\n[16,19],[11,15],[5,1],[8,17],[3,15],[8,1],[10,19],[3,8],[6,16],[2,8],[5,18],[11,13],[11,20],[14,21],[6,20],[4,20],[12,13],[5,12],\n[10,11],[9,15],[3,19],[9,20],[14,18],[21,1],[13,19],[8,21],[2,13],[3,10],[9,18],[19,21],[6,7],[3,18],[2,18],[6,14],[3,17],[5,21],\n[14,20],[8,9],[16,1],[3,4],[13,1],[5,9],[4,15],[17,21],[20,21],[2,17],[13,14],[11,14],[9,16],[10,18],[6,15],[6,12],[3,13],[5,11],\n[6,1],[12,17],[8,10],[5,10],[8,18],[4,12],[10,1],[6,13],[4,18],[7,20],[7,16],[2,6],[12,21],[4,17],[15,18],[13,16],[15,20],[7,10],\n[6,10],[2,20],[7,15],[18,1],[12,1],[3,20],[7,1],[14,15],[4,9],[11,19],[7,9],[5,17],[18,21],[6,21],[8,11],[6,17],[3,14],[7,11],\n[5,7],[7,13],[6,8],[6,9],[10,12],[5,16],[2,4],[17,18],[9,11],[12,16],[3,6],[12,18],[3,9],[11,12],[14,19],[10,15],[5,13],[8,13],\n[15,17],[2,10],[11,21],[20,1],[6,18],[2,12],[19,20],[6,11],[8,12],[2,3],[12,15],[2,11],[9,10],[7,17],[9,19],[13,15],[7,8],[4,11],\n[2,5],[5,19],[16,20],[15,19],[9,14],[14,1],[10,17],[9,21],[2,7],[8,20],[5,14],[4,16]]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you can choose an even node which is not connected to 2 and 3 .... and connect both of them with that even  node... you need two extra edges to connect them.."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@CamLot_9889e](/CamLot_9889e) understood !!!"
                    },
                    {
                        "username": "CamLot_9889e",
                        "content": "// find a third common node to connect to, both have to connect to same node to maintain evenness of the other node,\\n // so they can\\'t already have an edge with that respective third node."
                    },
                    {
                        "username": "vamsibharadwajECE",
                        "content": "I am getting TLE for this code, please help!!\\n  `class Solution {\\n\\n    bool isthereedge(int x,int y, vector<int> adjlist[]){\\n        int listsize=adjlist[x].size();\\n        for(int i=0;i<listsize;i++){\\n            if(y==adjlist[x][i]) return true;\\n        }\\n        return false;\\n    }\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> adjlist[n+1];\\n        int numedges=edges.size();\\n        for(int i=0;i<numedges;i++){\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            adjlist[a].push_back(b);\\n            adjlist[b].push_back(a);\\n        }\\n        vector<int> indegree(n+1,0);\\n        for(int i=0;i<n+1;i++){\\n            indegree[i]=adjlist[i].size();\\n        }\\n        int oddcount=0;\\n        vector<int> odddegrees;\\n        vector<int> evendegrees;\\n        for(int i=1;i<indegree.size();i++){\\n            if(indegree[i]%2!=0) odddegrees.push_back(i);\\n            else evendegrees.push_back(i);\\n        }\\n        if(odddegrees.size()>4) return false;\\n        oddcount=odddegrees.size();\\n        if(oddcount==1) return false;\\n        if(oddcount==0) return true;\\n        if(oddcount==2){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist)) return true;\\n            for(int i=0;i<evendegrees.size();i++){\\n                if(!isthereedge(odddegrees[0],evendegrees[i],adjlist) && !isthereedge(odddegrees[1],evendegrees[i],adjlist)) return true;\\n            } \\n            return false;\\n        }\\n        if(oddcount==4){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist) && !isthereedge(odddegrees[2],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[2],adjlist) && !isthereedge(odddegrees[1],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[3],adjlist) && !isthereedge(odddegrees[2],odddegrees[1],adjlist)) return true;\\n        }\\n        return false;\\n    }\\n};`\\n\\nI have passed 46/52 cases but I do not understand why am I getting TLE here??"
                    },
                    {
                        "username": "ray920822",
                        "content": "try to check the existence of an edge in less than O(number of neighbors) time"
                    },
                    {
                        "username": "AuHg",
                        "content": "Why the number of nodes with odd degree will next  be odd in graph?"
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because each edge contributes 2 to the total degree of all nodes"
                    },
                    {
                        "username": "shubham-sable",
                        "content": "Can someone Help , why this is giving RTE\\nint inDegree[n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            inDegree[i]=0;\\n        }\\n        vector<int> adj[n+1];\\n        for(int i=0;i<n;i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(auto itr:adj[i])\\n            {\\n                inDegree[itr]++;\\n            }\\n        }\\n        int odd=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(inDegree[i]%2!=0)\\n            {\\n                odd++;\\n            }\\n        }\\n        if(odd%2==0 && odd<=4)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It looks fine\\nhard to say where error is"
                    }
                ]
            },
            {
                "id": 1720182,
                "content": [
                    {
                        "username": "prit_manvar",
                        "content": "Possible Cases:\n1. number of nodes having `odd degree is more than 4` -> `return false`\n2. number of nodes having `odd degree is 4`\n             i -> find internal edges in these 4 nodes.\n             `if number of internal edges is 3 then return false else return true.`\n3. number of nodes having `odd degree is 2`\n            i -> there `isn't edge between these two nodes` having odd degree -> `return true`\n            ii -> search for node in graph who has not connection between both of nodes having odd degree. -> `if found then return true else return false`\n4. number of nodes having `odd degree is 0` -> `return true`\n\n\nNumber of nodes having odd degree will never be odd so i skipped cases like number of nodes having odd degree is 3 or 1."
                    },
                    {
                        "username": "vishnubathla",
                        "content": "was that only me or the test case \\n11\\n[[5,9],[8,1],[2,3],[7,10],[3,6],[6,7],[7,8],[5,1],[5,7],[10,11],[3,7],[6,11],[8,11],[3,4],[8,9],[9,1],[2,10],[9,11],[5,11],[2,5],[8,10],[2,7],[4,1],[3,10],[6,1],[4,9],[4,6],[4,5],[2,4],[2,11],[5,8],[6,9],[4,10],[3,11],[4,7],[3,5],[7,1],[2,9],[6,10],[10,1],[5,6],[3,9],[2,6],[7,9],[4,11],[4,8],[6,8],[3,8],[9,10],[5,10],[2,8],[7,11]]\\nwas wrong ?"
                    },
                    {
                        "username": "shankark",
                        "content": "I had the same problem. The odd edged nodes are [1,2,3,11]. If you are like me, most likely you are moving [1,2] into even-edged once you figured out that [1,2] doesn't have an edge. Now, for [3,11] you are also considering node [1,2] as they have become even-edged. So, don't do that and you will be ok.\n\nYes. Basically they have the wrong answer. But then they are the authors ;)"
                    },
                    {
                        "username": "Nitin_Kukreti",
                        "content": "if you find odd degree node then you realise they cannon be concerted into even degree do this in copy dont create complete graph just draw those node who have odd  degree"
                    },
                    {
                        "username": "sprs_2804",
                        "content": "same "
                    },
                    {
                        "username": "farziengineer",
                        "content": "Did they add some cases after the contest? I was passing all the test during the contest, now they show as WA :("
                    },
                    {
                        "username": "mage594088",
                        "content": "Me too. It sucks."
                    },
                    {
                        "username": "lebaur",
                        "content": "This question should be medium."
                    },
                    {
                        "username": "rayliux",
                        "content": "What's wrong with my memory? I recalled that in the contest I was able to solve this problem but today I found my solution yields WA. Were more test cases added?"
                    },
                    {
                        "username": "mage594088",
                        "content": "[@stash_](/stash_) Me too. WA at this additional case."
                    },
                    {
                        "username": "stash_",
                        "content": "Yes, they added 1 TC :(\\n5\\n[[4,3],[4,5],[5,3],[3,1],[5,2]]\\n"
                    },
                    {
                        "username": "jialihan",
                        "content": "The description is not clear that \"disconnected nodes\" not considered into the final solution. That means we don\\'t need to ensure the disconnected nodes with \"even\" edges."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "disconnected nodes have 0 degree. 0 is an even number"
                    },
                    {
                        "username": "shivansh961",
                        "content": "In this test case, 2 and 3 are the nodes with odd degree, but they both are already connected. So the answer should be false, but it is true.\nCan anyone explain me how ?\n\n\n\n\n[[2,19],[16,17],[8,14],[2,16],[12,20],[12,14],[16,18],[15,16],[10,21],[3,5],[13,18],[17,20],[14,17],[9,12],[5,15],[5,6],[3,7],\n[2,21],[10,13],[8,16],[7,18],[4,6],[9,1],[13,21],[18,20],[7,14],[4,19],[5,8],[3,11],[11,1],[7,12],[4,7],[3,16],[13,17],[17,19],\n[9,13],[7,19],[10,16],[4,13],[4,5],[2,15],[12,19],[11,16],[2,9],[11,17],[17,1],[16,21],[4,10],[10,14],[14,16],[4,1],[13,20],\n[5,20],[4,14],[4,21],[10,20],[2,14],[8,15],[4,8],[6,19],[15,1],[19,1],[8,19],[15,21],[3,12],[11,18],[9,17],[18,19],[7,21],[3,21],\n[16,19],[11,15],[5,1],[8,17],[3,15],[8,1],[10,19],[3,8],[6,16],[2,8],[5,18],[11,13],[11,20],[14,21],[6,20],[4,20],[12,13],[5,12],\n[10,11],[9,15],[3,19],[9,20],[14,18],[21,1],[13,19],[8,21],[2,13],[3,10],[9,18],[19,21],[6,7],[3,18],[2,18],[6,14],[3,17],[5,21],\n[14,20],[8,9],[16,1],[3,4],[13,1],[5,9],[4,15],[17,21],[20,21],[2,17],[13,14],[11,14],[9,16],[10,18],[6,15],[6,12],[3,13],[5,11],\n[6,1],[12,17],[8,10],[5,10],[8,18],[4,12],[10,1],[6,13],[4,18],[7,20],[7,16],[2,6],[12,21],[4,17],[15,18],[13,16],[15,20],[7,10],\n[6,10],[2,20],[7,15],[18,1],[12,1],[3,20],[7,1],[14,15],[4,9],[11,19],[7,9],[5,17],[18,21],[6,21],[8,11],[6,17],[3,14],[7,11],\n[5,7],[7,13],[6,8],[6,9],[10,12],[5,16],[2,4],[17,18],[9,11],[12,16],[3,6],[12,18],[3,9],[11,12],[14,19],[10,15],[5,13],[8,13],\n[15,17],[2,10],[11,21],[20,1],[6,18],[2,12],[19,20],[6,11],[8,12],[2,3],[12,15],[2,11],[9,10],[7,17],[9,19],[13,15],[7,8],[4,11],\n[2,5],[5,19],[16,20],[15,19],[9,14],[14,1],[10,17],[9,21],[2,7],[8,20],[5,14],[4,16]]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you can choose an even node which is not connected to 2 and 3 .... and connect both of them with that even  node... you need two extra edges to connect them.."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@CamLot_9889e](/CamLot_9889e) understood !!!"
                    },
                    {
                        "username": "CamLot_9889e",
                        "content": "// find a third common node to connect to, both have to connect to same node to maintain evenness of the other node,\\n // so they can\\'t already have an edge with that respective third node."
                    },
                    {
                        "username": "vamsibharadwajECE",
                        "content": "I am getting TLE for this code, please help!!\\n  `class Solution {\\n\\n    bool isthereedge(int x,int y, vector<int> adjlist[]){\\n        int listsize=adjlist[x].size();\\n        for(int i=0;i<listsize;i++){\\n            if(y==adjlist[x][i]) return true;\\n        }\\n        return false;\\n    }\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> adjlist[n+1];\\n        int numedges=edges.size();\\n        for(int i=0;i<numedges;i++){\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            adjlist[a].push_back(b);\\n            adjlist[b].push_back(a);\\n        }\\n        vector<int> indegree(n+1,0);\\n        for(int i=0;i<n+1;i++){\\n            indegree[i]=adjlist[i].size();\\n        }\\n        int oddcount=0;\\n        vector<int> odddegrees;\\n        vector<int> evendegrees;\\n        for(int i=1;i<indegree.size();i++){\\n            if(indegree[i]%2!=0) odddegrees.push_back(i);\\n            else evendegrees.push_back(i);\\n        }\\n        if(odddegrees.size()>4) return false;\\n        oddcount=odddegrees.size();\\n        if(oddcount==1) return false;\\n        if(oddcount==0) return true;\\n        if(oddcount==2){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist)) return true;\\n            for(int i=0;i<evendegrees.size();i++){\\n                if(!isthereedge(odddegrees[0],evendegrees[i],adjlist) && !isthereedge(odddegrees[1],evendegrees[i],adjlist)) return true;\\n            } \\n            return false;\\n        }\\n        if(oddcount==4){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist) && !isthereedge(odddegrees[2],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[2],adjlist) && !isthereedge(odddegrees[1],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[3],adjlist) && !isthereedge(odddegrees[2],odddegrees[1],adjlist)) return true;\\n        }\\n        return false;\\n    }\\n};`\\n\\nI have passed 46/52 cases but I do not understand why am I getting TLE here??"
                    },
                    {
                        "username": "ray920822",
                        "content": "try to check the existence of an edge in less than O(number of neighbors) time"
                    },
                    {
                        "username": "AuHg",
                        "content": "Why the number of nodes with odd degree will next  be odd in graph?"
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because each edge contributes 2 to the total degree of all nodes"
                    },
                    {
                        "username": "shubham-sable",
                        "content": "Can someone Help , why this is giving RTE\\nint inDegree[n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            inDegree[i]=0;\\n        }\\n        vector<int> adj[n+1];\\n        for(int i=0;i<n;i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(auto itr:adj[i])\\n            {\\n                inDegree[itr]++;\\n            }\\n        }\\n        int odd=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(inDegree[i]%2!=0)\\n            {\\n                odd++;\\n            }\\n        }\\n        if(odd%2==0 && odd<=4)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It looks fine\\nhard to say where error is"
                    }
                ]
            },
            {
                "id": 1735813,
                "content": [
                    {
                        "username": "prit_manvar",
                        "content": "Possible Cases:\n1. number of nodes having `odd degree is more than 4` -> `return false`\n2. number of nodes having `odd degree is 4`\n             i -> find internal edges in these 4 nodes.\n             `if number of internal edges is 3 then return false else return true.`\n3. number of nodes having `odd degree is 2`\n            i -> there `isn't edge between these two nodes` having odd degree -> `return true`\n            ii -> search for node in graph who has not connection between both of nodes having odd degree. -> `if found then return true else return false`\n4. number of nodes having `odd degree is 0` -> `return true`\n\n\nNumber of nodes having odd degree will never be odd so i skipped cases like number of nodes having odd degree is 3 or 1."
                    },
                    {
                        "username": "vishnubathla",
                        "content": "was that only me or the test case \\n11\\n[[5,9],[8,1],[2,3],[7,10],[3,6],[6,7],[7,8],[5,1],[5,7],[10,11],[3,7],[6,11],[8,11],[3,4],[8,9],[9,1],[2,10],[9,11],[5,11],[2,5],[8,10],[2,7],[4,1],[3,10],[6,1],[4,9],[4,6],[4,5],[2,4],[2,11],[5,8],[6,9],[4,10],[3,11],[4,7],[3,5],[7,1],[2,9],[6,10],[10,1],[5,6],[3,9],[2,6],[7,9],[4,11],[4,8],[6,8],[3,8],[9,10],[5,10],[2,8],[7,11]]\\nwas wrong ?"
                    },
                    {
                        "username": "shankark",
                        "content": "I had the same problem. The odd edged nodes are [1,2,3,11]. If you are like me, most likely you are moving [1,2] into even-edged once you figured out that [1,2] doesn't have an edge. Now, for [3,11] you are also considering node [1,2] as they have become even-edged. So, don't do that and you will be ok.\n\nYes. Basically they have the wrong answer. But then they are the authors ;)"
                    },
                    {
                        "username": "Nitin_Kukreti",
                        "content": "if you find odd degree node then you realise they cannon be concerted into even degree do this in copy dont create complete graph just draw those node who have odd  degree"
                    },
                    {
                        "username": "sprs_2804",
                        "content": "same "
                    },
                    {
                        "username": "farziengineer",
                        "content": "Did they add some cases after the contest? I was passing all the test during the contest, now they show as WA :("
                    },
                    {
                        "username": "mage594088",
                        "content": "Me too. It sucks."
                    },
                    {
                        "username": "lebaur",
                        "content": "This question should be medium."
                    },
                    {
                        "username": "rayliux",
                        "content": "What's wrong with my memory? I recalled that in the contest I was able to solve this problem but today I found my solution yields WA. Were more test cases added?"
                    },
                    {
                        "username": "mage594088",
                        "content": "[@stash_](/stash_) Me too. WA at this additional case."
                    },
                    {
                        "username": "stash_",
                        "content": "Yes, they added 1 TC :(\\n5\\n[[4,3],[4,5],[5,3],[3,1],[5,2]]\\n"
                    },
                    {
                        "username": "jialihan",
                        "content": "The description is not clear that \"disconnected nodes\" not considered into the final solution. That means we don\\'t need to ensure the disconnected nodes with \"even\" edges."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "disconnected nodes have 0 degree. 0 is an even number"
                    },
                    {
                        "username": "shivansh961",
                        "content": "In this test case, 2 and 3 are the nodes with odd degree, but they both are already connected. So the answer should be false, but it is true.\nCan anyone explain me how ?\n\n\n\n\n[[2,19],[16,17],[8,14],[2,16],[12,20],[12,14],[16,18],[15,16],[10,21],[3,5],[13,18],[17,20],[14,17],[9,12],[5,15],[5,6],[3,7],\n[2,21],[10,13],[8,16],[7,18],[4,6],[9,1],[13,21],[18,20],[7,14],[4,19],[5,8],[3,11],[11,1],[7,12],[4,7],[3,16],[13,17],[17,19],\n[9,13],[7,19],[10,16],[4,13],[4,5],[2,15],[12,19],[11,16],[2,9],[11,17],[17,1],[16,21],[4,10],[10,14],[14,16],[4,1],[13,20],\n[5,20],[4,14],[4,21],[10,20],[2,14],[8,15],[4,8],[6,19],[15,1],[19,1],[8,19],[15,21],[3,12],[11,18],[9,17],[18,19],[7,21],[3,21],\n[16,19],[11,15],[5,1],[8,17],[3,15],[8,1],[10,19],[3,8],[6,16],[2,8],[5,18],[11,13],[11,20],[14,21],[6,20],[4,20],[12,13],[5,12],\n[10,11],[9,15],[3,19],[9,20],[14,18],[21,1],[13,19],[8,21],[2,13],[3,10],[9,18],[19,21],[6,7],[3,18],[2,18],[6,14],[3,17],[5,21],\n[14,20],[8,9],[16,1],[3,4],[13,1],[5,9],[4,15],[17,21],[20,21],[2,17],[13,14],[11,14],[9,16],[10,18],[6,15],[6,12],[3,13],[5,11],\n[6,1],[12,17],[8,10],[5,10],[8,18],[4,12],[10,1],[6,13],[4,18],[7,20],[7,16],[2,6],[12,21],[4,17],[15,18],[13,16],[15,20],[7,10],\n[6,10],[2,20],[7,15],[18,1],[12,1],[3,20],[7,1],[14,15],[4,9],[11,19],[7,9],[5,17],[18,21],[6,21],[8,11],[6,17],[3,14],[7,11],\n[5,7],[7,13],[6,8],[6,9],[10,12],[5,16],[2,4],[17,18],[9,11],[12,16],[3,6],[12,18],[3,9],[11,12],[14,19],[10,15],[5,13],[8,13],\n[15,17],[2,10],[11,21],[20,1],[6,18],[2,12],[19,20],[6,11],[8,12],[2,3],[12,15],[2,11],[9,10],[7,17],[9,19],[13,15],[7,8],[4,11],\n[2,5],[5,19],[16,20],[15,19],[9,14],[14,1],[10,17],[9,21],[2,7],[8,20],[5,14],[4,16]]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you can choose an even node which is not connected to 2 and 3 .... and connect both of them with that even  node... you need two extra edges to connect them.."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@CamLot_9889e](/CamLot_9889e) understood !!!"
                    },
                    {
                        "username": "CamLot_9889e",
                        "content": "// find a third common node to connect to, both have to connect to same node to maintain evenness of the other node,\\n // so they can\\'t already have an edge with that respective third node."
                    },
                    {
                        "username": "vamsibharadwajECE",
                        "content": "I am getting TLE for this code, please help!!\\n  `class Solution {\\n\\n    bool isthereedge(int x,int y, vector<int> adjlist[]){\\n        int listsize=adjlist[x].size();\\n        for(int i=0;i<listsize;i++){\\n            if(y==adjlist[x][i]) return true;\\n        }\\n        return false;\\n    }\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> adjlist[n+1];\\n        int numedges=edges.size();\\n        for(int i=0;i<numedges;i++){\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            adjlist[a].push_back(b);\\n            adjlist[b].push_back(a);\\n        }\\n        vector<int> indegree(n+1,0);\\n        for(int i=0;i<n+1;i++){\\n            indegree[i]=adjlist[i].size();\\n        }\\n        int oddcount=0;\\n        vector<int> odddegrees;\\n        vector<int> evendegrees;\\n        for(int i=1;i<indegree.size();i++){\\n            if(indegree[i]%2!=0) odddegrees.push_back(i);\\n            else evendegrees.push_back(i);\\n        }\\n        if(odddegrees.size()>4) return false;\\n        oddcount=odddegrees.size();\\n        if(oddcount==1) return false;\\n        if(oddcount==0) return true;\\n        if(oddcount==2){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist)) return true;\\n            for(int i=0;i<evendegrees.size();i++){\\n                if(!isthereedge(odddegrees[0],evendegrees[i],adjlist) && !isthereedge(odddegrees[1],evendegrees[i],adjlist)) return true;\\n            } \\n            return false;\\n        }\\n        if(oddcount==4){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist) && !isthereedge(odddegrees[2],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[2],adjlist) && !isthereedge(odddegrees[1],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[3],adjlist) && !isthereedge(odddegrees[2],odddegrees[1],adjlist)) return true;\\n        }\\n        return false;\\n    }\\n};`\\n\\nI have passed 46/52 cases but I do not understand why am I getting TLE here??"
                    },
                    {
                        "username": "ray920822",
                        "content": "try to check the existence of an edge in less than O(number of neighbors) time"
                    },
                    {
                        "username": "AuHg",
                        "content": "Why the number of nodes with odd degree will next  be odd in graph?"
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because each edge contributes 2 to the total degree of all nodes"
                    },
                    {
                        "username": "shubham-sable",
                        "content": "Can someone Help , why this is giving RTE\\nint inDegree[n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            inDegree[i]=0;\\n        }\\n        vector<int> adj[n+1];\\n        for(int i=0;i<n;i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(auto itr:adj[i])\\n            {\\n                inDegree[itr]++;\\n            }\\n        }\\n        int odd=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(inDegree[i]%2!=0)\\n            {\\n                odd++;\\n            }\\n        }\\n        if(odd%2==0 && odd<=4)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It looks fine\\nhard to say where error is"
                    }
                ]
            },
            {
                "id": 1720224,
                "content": [
                    {
                        "username": "prit_manvar",
                        "content": "Possible Cases:\n1. number of nodes having `odd degree is more than 4` -> `return false`\n2. number of nodes having `odd degree is 4`\n             i -> find internal edges in these 4 nodes.\n             `if number of internal edges is 3 then return false else return true.`\n3. number of nodes having `odd degree is 2`\n            i -> there `isn't edge between these two nodes` having odd degree -> `return true`\n            ii -> search for node in graph who has not connection between both of nodes having odd degree. -> `if found then return true else return false`\n4. number of nodes having `odd degree is 0` -> `return true`\n\n\nNumber of nodes having odd degree will never be odd so i skipped cases like number of nodes having odd degree is 3 or 1."
                    },
                    {
                        "username": "vishnubathla",
                        "content": "was that only me or the test case \\n11\\n[[5,9],[8,1],[2,3],[7,10],[3,6],[6,7],[7,8],[5,1],[5,7],[10,11],[3,7],[6,11],[8,11],[3,4],[8,9],[9,1],[2,10],[9,11],[5,11],[2,5],[8,10],[2,7],[4,1],[3,10],[6,1],[4,9],[4,6],[4,5],[2,4],[2,11],[5,8],[6,9],[4,10],[3,11],[4,7],[3,5],[7,1],[2,9],[6,10],[10,1],[5,6],[3,9],[2,6],[7,9],[4,11],[4,8],[6,8],[3,8],[9,10],[5,10],[2,8],[7,11]]\\nwas wrong ?"
                    },
                    {
                        "username": "shankark",
                        "content": "I had the same problem. The odd edged nodes are [1,2,3,11]. If you are like me, most likely you are moving [1,2] into even-edged once you figured out that [1,2] doesn't have an edge. Now, for [3,11] you are also considering node [1,2] as they have become even-edged. So, don't do that and you will be ok.\n\nYes. Basically they have the wrong answer. But then they are the authors ;)"
                    },
                    {
                        "username": "Nitin_Kukreti",
                        "content": "if you find odd degree node then you realise they cannon be concerted into even degree do this in copy dont create complete graph just draw those node who have odd  degree"
                    },
                    {
                        "username": "sprs_2804",
                        "content": "same "
                    },
                    {
                        "username": "farziengineer",
                        "content": "Did they add some cases after the contest? I was passing all the test during the contest, now they show as WA :("
                    },
                    {
                        "username": "mage594088",
                        "content": "Me too. It sucks."
                    },
                    {
                        "username": "lebaur",
                        "content": "This question should be medium."
                    },
                    {
                        "username": "rayliux",
                        "content": "What's wrong with my memory? I recalled that in the contest I was able to solve this problem but today I found my solution yields WA. Were more test cases added?"
                    },
                    {
                        "username": "mage594088",
                        "content": "[@stash_](/stash_) Me too. WA at this additional case."
                    },
                    {
                        "username": "stash_",
                        "content": "Yes, they added 1 TC :(\\n5\\n[[4,3],[4,5],[5,3],[3,1],[5,2]]\\n"
                    },
                    {
                        "username": "jialihan",
                        "content": "The description is not clear that \"disconnected nodes\" not considered into the final solution. That means we don\\'t need to ensure the disconnected nodes with \"even\" edges."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "disconnected nodes have 0 degree. 0 is an even number"
                    },
                    {
                        "username": "shivansh961",
                        "content": "In this test case, 2 and 3 are the nodes with odd degree, but they both are already connected. So the answer should be false, but it is true.\nCan anyone explain me how ?\n\n\n\n\n[[2,19],[16,17],[8,14],[2,16],[12,20],[12,14],[16,18],[15,16],[10,21],[3,5],[13,18],[17,20],[14,17],[9,12],[5,15],[5,6],[3,7],\n[2,21],[10,13],[8,16],[7,18],[4,6],[9,1],[13,21],[18,20],[7,14],[4,19],[5,8],[3,11],[11,1],[7,12],[4,7],[3,16],[13,17],[17,19],\n[9,13],[7,19],[10,16],[4,13],[4,5],[2,15],[12,19],[11,16],[2,9],[11,17],[17,1],[16,21],[4,10],[10,14],[14,16],[4,1],[13,20],\n[5,20],[4,14],[4,21],[10,20],[2,14],[8,15],[4,8],[6,19],[15,1],[19,1],[8,19],[15,21],[3,12],[11,18],[9,17],[18,19],[7,21],[3,21],\n[16,19],[11,15],[5,1],[8,17],[3,15],[8,1],[10,19],[3,8],[6,16],[2,8],[5,18],[11,13],[11,20],[14,21],[6,20],[4,20],[12,13],[5,12],\n[10,11],[9,15],[3,19],[9,20],[14,18],[21,1],[13,19],[8,21],[2,13],[3,10],[9,18],[19,21],[6,7],[3,18],[2,18],[6,14],[3,17],[5,21],\n[14,20],[8,9],[16,1],[3,4],[13,1],[5,9],[4,15],[17,21],[20,21],[2,17],[13,14],[11,14],[9,16],[10,18],[6,15],[6,12],[3,13],[5,11],\n[6,1],[12,17],[8,10],[5,10],[8,18],[4,12],[10,1],[6,13],[4,18],[7,20],[7,16],[2,6],[12,21],[4,17],[15,18],[13,16],[15,20],[7,10],\n[6,10],[2,20],[7,15],[18,1],[12,1],[3,20],[7,1],[14,15],[4,9],[11,19],[7,9],[5,17],[18,21],[6,21],[8,11],[6,17],[3,14],[7,11],\n[5,7],[7,13],[6,8],[6,9],[10,12],[5,16],[2,4],[17,18],[9,11],[12,16],[3,6],[12,18],[3,9],[11,12],[14,19],[10,15],[5,13],[8,13],\n[15,17],[2,10],[11,21],[20,1],[6,18],[2,12],[19,20],[6,11],[8,12],[2,3],[12,15],[2,11],[9,10],[7,17],[9,19],[13,15],[7,8],[4,11],\n[2,5],[5,19],[16,20],[15,19],[9,14],[14,1],[10,17],[9,21],[2,7],[8,20],[5,14],[4,16]]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you can choose an even node which is not connected to 2 and 3 .... and connect both of them with that even  node... you need two extra edges to connect them.."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@CamLot_9889e](/CamLot_9889e) understood !!!"
                    },
                    {
                        "username": "CamLot_9889e",
                        "content": "// find a third common node to connect to, both have to connect to same node to maintain evenness of the other node,\\n // so they can\\'t already have an edge with that respective third node."
                    },
                    {
                        "username": "vamsibharadwajECE",
                        "content": "I am getting TLE for this code, please help!!\\n  `class Solution {\\n\\n    bool isthereedge(int x,int y, vector<int> adjlist[]){\\n        int listsize=adjlist[x].size();\\n        for(int i=0;i<listsize;i++){\\n            if(y==adjlist[x][i]) return true;\\n        }\\n        return false;\\n    }\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> adjlist[n+1];\\n        int numedges=edges.size();\\n        for(int i=0;i<numedges;i++){\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            adjlist[a].push_back(b);\\n            adjlist[b].push_back(a);\\n        }\\n        vector<int> indegree(n+1,0);\\n        for(int i=0;i<n+1;i++){\\n            indegree[i]=adjlist[i].size();\\n        }\\n        int oddcount=0;\\n        vector<int> odddegrees;\\n        vector<int> evendegrees;\\n        for(int i=1;i<indegree.size();i++){\\n            if(indegree[i]%2!=0) odddegrees.push_back(i);\\n            else evendegrees.push_back(i);\\n        }\\n        if(odddegrees.size()>4) return false;\\n        oddcount=odddegrees.size();\\n        if(oddcount==1) return false;\\n        if(oddcount==0) return true;\\n        if(oddcount==2){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist)) return true;\\n            for(int i=0;i<evendegrees.size();i++){\\n                if(!isthereedge(odddegrees[0],evendegrees[i],adjlist) && !isthereedge(odddegrees[1],evendegrees[i],adjlist)) return true;\\n            } \\n            return false;\\n        }\\n        if(oddcount==4){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist) && !isthereedge(odddegrees[2],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[2],adjlist) && !isthereedge(odddegrees[1],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[3],adjlist) && !isthereedge(odddegrees[2],odddegrees[1],adjlist)) return true;\\n        }\\n        return false;\\n    }\\n};`\\n\\nI have passed 46/52 cases but I do not understand why am I getting TLE here??"
                    },
                    {
                        "username": "ray920822",
                        "content": "try to check the existence of an edge in less than O(number of neighbors) time"
                    },
                    {
                        "username": "AuHg",
                        "content": "Why the number of nodes with odd degree will next  be odd in graph?"
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because each edge contributes 2 to the total degree of all nodes"
                    },
                    {
                        "username": "shubham-sable",
                        "content": "Can someone Help , why this is giving RTE\\nint inDegree[n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            inDegree[i]=0;\\n        }\\n        vector<int> adj[n+1];\\n        for(int i=0;i<n;i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(auto itr:adj[i])\\n            {\\n                inDegree[itr]++;\\n            }\\n        }\\n        int odd=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(inDegree[i]%2!=0)\\n            {\\n                odd++;\\n            }\\n        }\\n        if(odd%2==0 && odd<=4)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It looks fine\\nhard to say where error is"
                    }
                ]
            },
            {
                "id": 1720067,
                "content": [
                    {
                        "username": "prit_manvar",
                        "content": "Possible Cases:\n1. number of nodes having `odd degree is more than 4` -> `return false`\n2. number of nodes having `odd degree is 4`\n             i -> find internal edges in these 4 nodes.\n             `if number of internal edges is 3 then return false else return true.`\n3. number of nodes having `odd degree is 2`\n            i -> there `isn't edge between these two nodes` having odd degree -> `return true`\n            ii -> search for node in graph who has not connection between both of nodes having odd degree. -> `if found then return true else return false`\n4. number of nodes having `odd degree is 0` -> `return true`\n\n\nNumber of nodes having odd degree will never be odd so i skipped cases like number of nodes having odd degree is 3 or 1."
                    },
                    {
                        "username": "vishnubathla",
                        "content": "was that only me or the test case \\n11\\n[[5,9],[8,1],[2,3],[7,10],[3,6],[6,7],[7,8],[5,1],[5,7],[10,11],[3,7],[6,11],[8,11],[3,4],[8,9],[9,1],[2,10],[9,11],[5,11],[2,5],[8,10],[2,7],[4,1],[3,10],[6,1],[4,9],[4,6],[4,5],[2,4],[2,11],[5,8],[6,9],[4,10],[3,11],[4,7],[3,5],[7,1],[2,9],[6,10],[10,1],[5,6],[3,9],[2,6],[7,9],[4,11],[4,8],[6,8],[3,8],[9,10],[5,10],[2,8],[7,11]]\\nwas wrong ?"
                    },
                    {
                        "username": "shankark",
                        "content": "I had the same problem. The odd edged nodes are [1,2,3,11]. If you are like me, most likely you are moving [1,2] into even-edged once you figured out that [1,2] doesn't have an edge. Now, for [3,11] you are also considering node [1,2] as they have become even-edged. So, don't do that and you will be ok.\n\nYes. Basically they have the wrong answer. But then they are the authors ;)"
                    },
                    {
                        "username": "Nitin_Kukreti",
                        "content": "if you find odd degree node then you realise they cannon be concerted into even degree do this in copy dont create complete graph just draw those node who have odd  degree"
                    },
                    {
                        "username": "sprs_2804",
                        "content": "same "
                    },
                    {
                        "username": "farziengineer",
                        "content": "Did they add some cases after the contest? I was passing all the test during the contest, now they show as WA :("
                    },
                    {
                        "username": "mage594088",
                        "content": "Me too. It sucks."
                    },
                    {
                        "username": "lebaur",
                        "content": "This question should be medium."
                    },
                    {
                        "username": "rayliux",
                        "content": "What's wrong with my memory? I recalled that in the contest I was able to solve this problem but today I found my solution yields WA. Were more test cases added?"
                    },
                    {
                        "username": "mage594088",
                        "content": "[@stash_](/stash_) Me too. WA at this additional case."
                    },
                    {
                        "username": "stash_",
                        "content": "Yes, they added 1 TC :(\\n5\\n[[4,3],[4,5],[5,3],[3,1],[5,2]]\\n"
                    },
                    {
                        "username": "jialihan",
                        "content": "The description is not clear that \"disconnected nodes\" not considered into the final solution. That means we don\\'t need to ensure the disconnected nodes with \"even\" edges."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "disconnected nodes have 0 degree. 0 is an even number"
                    },
                    {
                        "username": "shivansh961",
                        "content": "In this test case, 2 and 3 are the nodes with odd degree, but they both are already connected. So the answer should be false, but it is true.\nCan anyone explain me how ?\n\n\n\n\n[[2,19],[16,17],[8,14],[2,16],[12,20],[12,14],[16,18],[15,16],[10,21],[3,5],[13,18],[17,20],[14,17],[9,12],[5,15],[5,6],[3,7],\n[2,21],[10,13],[8,16],[7,18],[4,6],[9,1],[13,21],[18,20],[7,14],[4,19],[5,8],[3,11],[11,1],[7,12],[4,7],[3,16],[13,17],[17,19],\n[9,13],[7,19],[10,16],[4,13],[4,5],[2,15],[12,19],[11,16],[2,9],[11,17],[17,1],[16,21],[4,10],[10,14],[14,16],[4,1],[13,20],\n[5,20],[4,14],[4,21],[10,20],[2,14],[8,15],[4,8],[6,19],[15,1],[19,1],[8,19],[15,21],[3,12],[11,18],[9,17],[18,19],[7,21],[3,21],\n[16,19],[11,15],[5,1],[8,17],[3,15],[8,1],[10,19],[3,8],[6,16],[2,8],[5,18],[11,13],[11,20],[14,21],[6,20],[4,20],[12,13],[5,12],\n[10,11],[9,15],[3,19],[9,20],[14,18],[21,1],[13,19],[8,21],[2,13],[3,10],[9,18],[19,21],[6,7],[3,18],[2,18],[6,14],[3,17],[5,21],\n[14,20],[8,9],[16,1],[3,4],[13,1],[5,9],[4,15],[17,21],[20,21],[2,17],[13,14],[11,14],[9,16],[10,18],[6,15],[6,12],[3,13],[5,11],\n[6,1],[12,17],[8,10],[5,10],[8,18],[4,12],[10,1],[6,13],[4,18],[7,20],[7,16],[2,6],[12,21],[4,17],[15,18],[13,16],[15,20],[7,10],\n[6,10],[2,20],[7,15],[18,1],[12,1],[3,20],[7,1],[14,15],[4,9],[11,19],[7,9],[5,17],[18,21],[6,21],[8,11],[6,17],[3,14],[7,11],\n[5,7],[7,13],[6,8],[6,9],[10,12],[5,16],[2,4],[17,18],[9,11],[12,16],[3,6],[12,18],[3,9],[11,12],[14,19],[10,15],[5,13],[8,13],\n[15,17],[2,10],[11,21],[20,1],[6,18],[2,12],[19,20],[6,11],[8,12],[2,3],[12,15],[2,11],[9,10],[7,17],[9,19],[13,15],[7,8],[4,11],\n[2,5],[5,19],[16,20],[15,19],[9,14],[14,1],[10,17],[9,21],[2,7],[8,20],[5,14],[4,16]]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you can choose an even node which is not connected to 2 and 3 .... and connect both of them with that even  node... you need two extra edges to connect them.."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@CamLot_9889e](/CamLot_9889e) understood !!!"
                    },
                    {
                        "username": "CamLot_9889e",
                        "content": "// find a third common node to connect to, both have to connect to same node to maintain evenness of the other node,\\n // so they can\\'t already have an edge with that respective third node."
                    },
                    {
                        "username": "vamsibharadwajECE",
                        "content": "I am getting TLE for this code, please help!!\\n  `class Solution {\\n\\n    bool isthereedge(int x,int y, vector<int> adjlist[]){\\n        int listsize=adjlist[x].size();\\n        for(int i=0;i<listsize;i++){\\n            if(y==adjlist[x][i]) return true;\\n        }\\n        return false;\\n    }\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> adjlist[n+1];\\n        int numedges=edges.size();\\n        for(int i=0;i<numedges;i++){\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            adjlist[a].push_back(b);\\n            adjlist[b].push_back(a);\\n        }\\n        vector<int> indegree(n+1,0);\\n        for(int i=0;i<n+1;i++){\\n            indegree[i]=adjlist[i].size();\\n        }\\n        int oddcount=0;\\n        vector<int> odddegrees;\\n        vector<int> evendegrees;\\n        for(int i=1;i<indegree.size();i++){\\n            if(indegree[i]%2!=0) odddegrees.push_back(i);\\n            else evendegrees.push_back(i);\\n        }\\n        if(odddegrees.size()>4) return false;\\n        oddcount=odddegrees.size();\\n        if(oddcount==1) return false;\\n        if(oddcount==0) return true;\\n        if(oddcount==2){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist)) return true;\\n            for(int i=0;i<evendegrees.size();i++){\\n                if(!isthereedge(odddegrees[0],evendegrees[i],adjlist) && !isthereedge(odddegrees[1],evendegrees[i],adjlist)) return true;\\n            } \\n            return false;\\n        }\\n        if(oddcount==4){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist) && !isthereedge(odddegrees[2],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[2],adjlist) && !isthereedge(odddegrees[1],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[3],adjlist) && !isthereedge(odddegrees[2],odddegrees[1],adjlist)) return true;\\n        }\\n        return false;\\n    }\\n};`\\n\\nI have passed 46/52 cases but I do not understand why am I getting TLE here??"
                    },
                    {
                        "username": "ray920822",
                        "content": "try to check the existence of an edge in less than O(number of neighbors) time"
                    },
                    {
                        "username": "AuHg",
                        "content": "Why the number of nodes with odd degree will next  be odd in graph?"
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because each edge contributes 2 to the total degree of all nodes"
                    },
                    {
                        "username": "shubham-sable",
                        "content": "Can someone Help , why this is giving RTE\\nint inDegree[n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            inDegree[i]=0;\\n        }\\n        vector<int> adj[n+1];\\n        for(int i=0;i<n;i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(auto itr:adj[i])\\n            {\\n                inDegree[itr]++;\\n            }\\n        }\\n        int odd=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(inDegree[i]%2!=0)\\n            {\\n                odd++;\\n            }\\n        }\\n        if(odd%2==0 && odd<=4)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It looks fine\\nhard to say where error is"
                    }
                ]
            },
            {
                "id": 1720063,
                "content": [
                    {
                        "username": "prit_manvar",
                        "content": "Possible Cases:\n1. number of nodes having `odd degree is more than 4` -> `return false`\n2. number of nodes having `odd degree is 4`\n             i -> find internal edges in these 4 nodes.\n             `if number of internal edges is 3 then return false else return true.`\n3. number of nodes having `odd degree is 2`\n            i -> there `isn't edge between these two nodes` having odd degree -> `return true`\n            ii -> search for node in graph who has not connection between both of nodes having odd degree. -> `if found then return true else return false`\n4. number of nodes having `odd degree is 0` -> `return true`\n\n\nNumber of nodes having odd degree will never be odd so i skipped cases like number of nodes having odd degree is 3 or 1."
                    },
                    {
                        "username": "vishnubathla",
                        "content": "was that only me or the test case \\n11\\n[[5,9],[8,1],[2,3],[7,10],[3,6],[6,7],[7,8],[5,1],[5,7],[10,11],[3,7],[6,11],[8,11],[3,4],[8,9],[9,1],[2,10],[9,11],[5,11],[2,5],[8,10],[2,7],[4,1],[3,10],[6,1],[4,9],[4,6],[4,5],[2,4],[2,11],[5,8],[6,9],[4,10],[3,11],[4,7],[3,5],[7,1],[2,9],[6,10],[10,1],[5,6],[3,9],[2,6],[7,9],[4,11],[4,8],[6,8],[3,8],[9,10],[5,10],[2,8],[7,11]]\\nwas wrong ?"
                    },
                    {
                        "username": "shankark",
                        "content": "I had the same problem. The odd edged nodes are [1,2,3,11]. If you are like me, most likely you are moving [1,2] into even-edged once you figured out that [1,2] doesn't have an edge. Now, for [3,11] you are also considering node [1,2] as they have become even-edged. So, don't do that and you will be ok.\n\nYes. Basically they have the wrong answer. But then they are the authors ;)"
                    },
                    {
                        "username": "Nitin_Kukreti",
                        "content": "if you find odd degree node then you realise they cannon be concerted into even degree do this in copy dont create complete graph just draw those node who have odd  degree"
                    },
                    {
                        "username": "sprs_2804",
                        "content": "same "
                    },
                    {
                        "username": "farziengineer",
                        "content": "Did they add some cases after the contest? I was passing all the test during the contest, now they show as WA :("
                    },
                    {
                        "username": "mage594088",
                        "content": "Me too. It sucks."
                    },
                    {
                        "username": "lebaur",
                        "content": "This question should be medium."
                    },
                    {
                        "username": "rayliux",
                        "content": "What's wrong with my memory? I recalled that in the contest I was able to solve this problem but today I found my solution yields WA. Were more test cases added?"
                    },
                    {
                        "username": "mage594088",
                        "content": "[@stash_](/stash_) Me too. WA at this additional case."
                    },
                    {
                        "username": "stash_",
                        "content": "Yes, they added 1 TC :(\\n5\\n[[4,3],[4,5],[5,3],[3,1],[5,2]]\\n"
                    },
                    {
                        "username": "jialihan",
                        "content": "The description is not clear that \"disconnected nodes\" not considered into the final solution. That means we don\\'t need to ensure the disconnected nodes with \"even\" edges."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "disconnected nodes have 0 degree. 0 is an even number"
                    },
                    {
                        "username": "shivansh961",
                        "content": "In this test case, 2 and 3 are the nodes with odd degree, but they both are already connected. So the answer should be false, but it is true.\nCan anyone explain me how ?\n\n\n\n\n[[2,19],[16,17],[8,14],[2,16],[12,20],[12,14],[16,18],[15,16],[10,21],[3,5],[13,18],[17,20],[14,17],[9,12],[5,15],[5,6],[3,7],\n[2,21],[10,13],[8,16],[7,18],[4,6],[9,1],[13,21],[18,20],[7,14],[4,19],[5,8],[3,11],[11,1],[7,12],[4,7],[3,16],[13,17],[17,19],\n[9,13],[7,19],[10,16],[4,13],[4,5],[2,15],[12,19],[11,16],[2,9],[11,17],[17,1],[16,21],[4,10],[10,14],[14,16],[4,1],[13,20],\n[5,20],[4,14],[4,21],[10,20],[2,14],[8,15],[4,8],[6,19],[15,1],[19,1],[8,19],[15,21],[3,12],[11,18],[9,17],[18,19],[7,21],[3,21],\n[16,19],[11,15],[5,1],[8,17],[3,15],[8,1],[10,19],[3,8],[6,16],[2,8],[5,18],[11,13],[11,20],[14,21],[6,20],[4,20],[12,13],[5,12],\n[10,11],[9,15],[3,19],[9,20],[14,18],[21,1],[13,19],[8,21],[2,13],[3,10],[9,18],[19,21],[6,7],[3,18],[2,18],[6,14],[3,17],[5,21],\n[14,20],[8,9],[16,1],[3,4],[13,1],[5,9],[4,15],[17,21],[20,21],[2,17],[13,14],[11,14],[9,16],[10,18],[6,15],[6,12],[3,13],[5,11],\n[6,1],[12,17],[8,10],[5,10],[8,18],[4,12],[10,1],[6,13],[4,18],[7,20],[7,16],[2,6],[12,21],[4,17],[15,18],[13,16],[15,20],[7,10],\n[6,10],[2,20],[7,15],[18,1],[12,1],[3,20],[7,1],[14,15],[4,9],[11,19],[7,9],[5,17],[18,21],[6,21],[8,11],[6,17],[3,14],[7,11],\n[5,7],[7,13],[6,8],[6,9],[10,12],[5,16],[2,4],[17,18],[9,11],[12,16],[3,6],[12,18],[3,9],[11,12],[14,19],[10,15],[5,13],[8,13],\n[15,17],[2,10],[11,21],[20,1],[6,18],[2,12],[19,20],[6,11],[8,12],[2,3],[12,15],[2,11],[9,10],[7,17],[9,19],[13,15],[7,8],[4,11],\n[2,5],[5,19],[16,20],[15,19],[9,14],[14,1],[10,17],[9,21],[2,7],[8,20],[5,14],[4,16]]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you can choose an even node which is not connected to 2 and 3 .... and connect both of them with that even  node... you need two extra edges to connect them.."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@CamLot_9889e](/CamLot_9889e) understood !!!"
                    },
                    {
                        "username": "CamLot_9889e",
                        "content": "// find a third common node to connect to, both have to connect to same node to maintain evenness of the other node,\\n // so they can\\'t already have an edge with that respective third node."
                    },
                    {
                        "username": "vamsibharadwajECE",
                        "content": "I am getting TLE for this code, please help!!\\n  `class Solution {\\n\\n    bool isthereedge(int x,int y, vector<int> adjlist[]){\\n        int listsize=adjlist[x].size();\\n        for(int i=0;i<listsize;i++){\\n            if(y==adjlist[x][i]) return true;\\n        }\\n        return false;\\n    }\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> adjlist[n+1];\\n        int numedges=edges.size();\\n        for(int i=0;i<numedges;i++){\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            adjlist[a].push_back(b);\\n            adjlist[b].push_back(a);\\n        }\\n        vector<int> indegree(n+1,0);\\n        for(int i=0;i<n+1;i++){\\n            indegree[i]=adjlist[i].size();\\n        }\\n        int oddcount=0;\\n        vector<int> odddegrees;\\n        vector<int> evendegrees;\\n        for(int i=1;i<indegree.size();i++){\\n            if(indegree[i]%2!=0) odddegrees.push_back(i);\\n            else evendegrees.push_back(i);\\n        }\\n        if(odddegrees.size()>4) return false;\\n        oddcount=odddegrees.size();\\n        if(oddcount==1) return false;\\n        if(oddcount==0) return true;\\n        if(oddcount==2){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist)) return true;\\n            for(int i=0;i<evendegrees.size();i++){\\n                if(!isthereedge(odddegrees[0],evendegrees[i],adjlist) && !isthereedge(odddegrees[1],evendegrees[i],adjlist)) return true;\\n            } \\n            return false;\\n        }\\n        if(oddcount==4){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist) && !isthereedge(odddegrees[2],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[2],adjlist) && !isthereedge(odddegrees[1],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[3],adjlist) && !isthereedge(odddegrees[2],odddegrees[1],adjlist)) return true;\\n        }\\n        return false;\\n    }\\n};`\\n\\nI have passed 46/52 cases but I do not understand why am I getting TLE here??"
                    },
                    {
                        "username": "ray920822",
                        "content": "try to check the existence of an edge in less than O(number of neighbors) time"
                    },
                    {
                        "username": "AuHg",
                        "content": "Why the number of nodes with odd degree will next  be odd in graph?"
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because each edge contributes 2 to the total degree of all nodes"
                    },
                    {
                        "username": "shubham-sable",
                        "content": "Can someone Help , why this is giving RTE\\nint inDegree[n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            inDegree[i]=0;\\n        }\\n        vector<int> adj[n+1];\\n        for(int i=0;i<n;i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(auto itr:adj[i])\\n            {\\n                inDegree[itr]++;\\n            }\\n        }\\n        int odd=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(inDegree[i]%2!=0)\\n            {\\n                odd++;\\n            }\\n        }\\n        if(odd%2==0 && odd<=4)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It looks fine\\nhard to say where error is"
                    }
                ]
            },
            {
                "id": 1719977,
                "content": [
                    {
                        "username": "prit_manvar",
                        "content": "Possible Cases:\n1. number of nodes having `odd degree is more than 4` -> `return false`\n2. number of nodes having `odd degree is 4`\n             i -> find internal edges in these 4 nodes.\n             `if number of internal edges is 3 then return false else return true.`\n3. number of nodes having `odd degree is 2`\n            i -> there `isn't edge between these two nodes` having odd degree -> `return true`\n            ii -> search for node in graph who has not connection between both of nodes having odd degree. -> `if found then return true else return false`\n4. number of nodes having `odd degree is 0` -> `return true`\n\n\nNumber of nodes having odd degree will never be odd so i skipped cases like number of nodes having odd degree is 3 or 1."
                    },
                    {
                        "username": "vishnubathla",
                        "content": "was that only me or the test case \\n11\\n[[5,9],[8,1],[2,3],[7,10],[3,6],[6,7],[7,8],[5,1],[5,7],[10,11],[3,7],[6,11],[8,11],[3,4],[8,9],[9,1],[2,10],[9,11],[5,11],[2,5],[8,10],[2,7],[4,1],[3,10],[6,1],[4,9],[4,6],[4,5],[2,4],[2,11],[5,8],[6,9],[4,10],[3,11],[4,7],[3,5],[7,1],[2,9],[6,10],[10,1],[5,6],[3,9],[2,6],[7,9],[4,11],[4,8],[6,8],[3,8],[9,10],[5,10],[2,8],[7,11]]\\nwas wrong ?"
                    },
                    {
                        "username": "shankark",
                        "content": "I had the same problem. The odd edged nodes are [1,2,3,11]. If you are like me, most likely you are moving [1,2] into even-edged once you figured out that [1,2] doesn't have an edge. Now, for [3,11] you are also considering node [1,2] as they have become even-edged. So, don't do that and you will be ok.\n\nYes. Basically they have the wrong answer. But then they are the authors ;)"
                    },
                    {
                        "username": "Nitin_Kukreti",
                        "content": "if you find odd degree node then you realise they cannon be concerted into even degree do this in copy dont create complete graph just draw those node who have odd  degree"
                    },
                    {
                        "username": "sprs_2804",
                        "content": "same "
                    },
                    {
                        "username": "farziengineer",
                        "content": "Did they add some cases after the contest? I was passing all the test during the contest, now they show as WA :("
                    },
                    {
                        "username": "mage594088",
                        "content": "Me too. It sucks."
                    },
                    {
                        "username": "lebaur",
                        "content": "This question should be medium."
                    },
                    {
                        "username": "rayliux",
                        "content": "What's wrong with my memory? I recalled that in the contest I was able to solve this problem but today I found my solution yields WA. Were more test cases added?"
                    },
                    {
                        "username": "mage594088",
                        "content": "[@stash_](/stash_) Me too. WA at this additional case."
                    },
                    {
                        "username": "stash_",
                        "content": "Yes, they added 1 TC :(\\n5\\n[[4,3],[4,5],[5,3],[3,1],[5,2]]\\n"
                    },
                    {
                        "username": "jialihan",
                        "content": "The description is not clear that \"disconnected nodes\" not considered into the final solution. That means we don\\'t need to ensure the disconnected nodes with \"even\" edges."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "disconnected nodes have 0 degree. 0 is an even number"
                    },
                    {
                        "username": "shivansh961",
                        "content": "In this test case, 2 and 3 are the nodes with odd degree, but they both are already connected. So the answer should be false, but it is true.\nCan anyone explain me how ?\n\n\n\n\n[[2,19],[16,17],[8,14],[2,16],[12,20],[12,14],[16,18],[15,16],[10,21],[3,5],[13,18],[17,20],[14,17],[9,12],[5,15],[5,6],[3,7],\n[2,21],[10,13],[8,16],[7,18],[4,6],[9,1],[13,21],[18,20],[7,14],[4,19],[5,8],[3,11],[11,1],[7,12],[4,7],[3,16],[13,17],[17,19],\n[9,13],[7,19],[10,16],[4,13],[4,5],[2,15],[12,19],[11,16],[2,9],[11,17],[17,1],[16,21],[4,10],[10,14],[14,16],[4,1],[13,20],\n[5,20],[4,14],[4,21],[10,20],[2,14],[8,15],[4,8],[6,19],[15,1],[19,1],[8,19],[15,21],[3,12],[11,18],[9,17],[18,19],[7,21],[3,21],\n[16,19],[11,15],[5,1],[8,17],[3,15],[8,1],[10,19],[3,8],[6,16],[2,8],[5,18],[11,13],[11,20],[14,21],[6,20],[4,20],[12,13],[5,12],\n[10,11],[9,15],[3,19],[9,20],[14,18],[21,1],[13,19],[8,21],[2,13],[3,10],[9,18],[19,21],[6,7],[3,18],[2,18],[6,14],[3,17],[5,21],\n[14,20],[8,9],[16,1],[3,4],[13,1],[5,9],[4,15],[17,21],[20,21],[2,17],[13,14],[11,14],[9,16],[10,18],[6,15],[6,12],[3,13],[5,11],\n[6,1],[12,17],[8,10],[5,10],[8,18],[4,12],[10,1],[6,13],[4,18],[7,20],[7,16],[2,6],[12,21],[4,17],[15,18],[13,16],[15,20],[7,10],\n[6,10],[2,20],[7,15],[18,1],[12,1],[3,20],[7,1],[14,15],[4,9],[11,19],[7,9],[5,17],[18,21],[6,21],[8,11],[6,17],[3,14],[7,11],\n[5,7],[7,13],[6,8],[6,9],[10,12],[5,16],[2,4],[17,18],[9,11],[12,16],[3,6],[12,18],[3,9],[11,12],[14,19],[10,15],[5,13],[8,13],\n[15,17],[2,10],[11,21],[20,1],[6,18],[2,12],[19,20],[6,11],[8,12],[2,3],[12,15],[2,11],[9,10],[7,17],[9,19],[13,15],[7,8],[4,11],\n[2,5],[5,19],[16,20],[15,19],[9,14],[14,1],[10,17],[9,21],[2,7],[8,20],[5,14],[4,16]]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you can choose an even node which is not connected to 2 and 3 .... and connect both of them with that even  node... you need two extra edges to connect them.."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@CamLot_9889e](/CamLot_9889e) understood !!!"
                    },
                    {
                        "username": "CamLot_9889e",
                        "content": "// find a third common node to connect to, both have to connect to same node to maintain evenness of the other node,\\n // so they can\\'t already have an edge with that respective third node."
                    },
                    {
                        "username": "vamsibharadwajECE",
                        "content": "I am getting TLE for this code, please help!!\\n  `class Solution {\\n\\n    bool isthereedge(int x,int y, vector<int> adjlist[]){\\n        int listsize=adjlist[x].size();\\n        for(int i=0;i<listsize;i++){\\n            if(y==adjlist[x][i]) return true;\\n        }\\n        return false;\\n    }\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> adjlist[n+1];\\n        int numedges=edges.size();\\n        for(int i=0;i<numedges;i++){\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            adjlist[a].push_back(b);\\n            adjlist[b].push_back(a);\\n        }\\n        vector<int> indegree(n+1,0);\\n        for(int i=0;i<n+1;i++){\\n            indegree[i]=adjlist[i].size();\\n        }\\n        int oddcount=0;\\n        vector<int> odddegrees;\\n        vector<int> evendegrees;\\n        for(int i=1;i<indegree.size();i++){\\n            if(indegree[i]%2!=0) odddegrees.push_back(i);\\n            else evendegrees.push_back(i);\\n        }\\n        if(odddegrees.size()>4) return false;\\n        oddcount=odddegrees.size();\\n        if(oddcount==1) return false;\\n        if(oddcount==0) return true;\\n        if(oddcount==2){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist)) return true;\\n            for(int i=0;i<evendegrees.size();i++){\\n                if(!isthereedge(odddegrees[0],evendegrees[i],adjlist) && !isthereedge(odddegrees[1],evendegrees[i],adjlist)) return true;\\n            } \\n            return false;\\n        }\\n        if(oddcount==4){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist) && !isthereedge(odddegrees[2],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[2],adjlist) && !isthereedge(odddegrees[1],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[3],adjlist) && !isthereedge(odddegrees[2],odddegrees[1],adjlist)) return true;\\n        }\\n        return false;\\n    }\\n};`\\n\\nI have passed 46/52 cases but I do not understand why am I getting TLE here??"
                    },
                    {
                        "username": "ray920822",
                        "content": "try to check the existence of an edge in less than O(number of neighbors) time"
                    },
                    {
                        "username": "AuHg",
                        "content": "Why the number of nodes with odd degree will next  be odd in graph?"
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because each edge contributes 2 to the total degree of all nodes"
                    },
                    {
                        "username": "shubham-sable",
                        "content": "Can someone Help , why this is giving RTE\\nint inDegree[n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            inDegree[i]=0;\\n        }\\n        vector<int> adj[n+1];\\n        for(int i=0;i<n;i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(auto itr:adj[i])\\n            {\\n                inDegree[itr]++;\\n            }\\n        }\\n        int odd=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(inDegree[i]%2!=0)\\n            {\\n                odd++;\\n            }\\n        }\\n        if(odd%2==0 && odd<=4)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It looks fine\\nhard to say where error is"
                    }
                ]
            },
            {
                "id": 1723948,
                "content": [
                    {
                        "username": "prit_manvar",
                        "content": "Possible Cases:\n1. number of nodes having `odd degree is more than 4` -> `return false`\n2. number of nodes having `odd degree is 4`\n             i -> find internal edges in these 4 nodes.\n             `if number of internal edges is 3 then return false else return true.`\n3. number of nodes having `odd degree is 2`\n            i -> there `isn't edge between these two nodes` having odd degree -> `return true`\n            ii -> search for node in graph who has not connection between both of nodes having odd degree. -> `if found then return true else return false`\n4. number of nodes having `odd degree is 0` -> `return true`\n\n\nNumber of nodes having odd degree will never be odd so i skipped cases like number of nodes having odd degree is 3 or 1."
                    },
                    {
                        "username": "vishnubathla",
                        "content": "was that only me or the test case \\n11\\n[[5,9],[8,1],[2,3],[7,10],[3,6],[6,7],[7,8],[5,1],[5,7],[10,11],[3,7],[6,11],[8,11],[3,4],[8,9],[9,1],[2,10],[9,11],[5,11],[2,5],[8,10],[2,7],[4,1],[3,10],[6,1],[4,9],[4,6],[4,5],[2,4],[2,11],[5,8],[6,9],[4,10],[3,11],[4,7],[3,5],[7,1],[2,9],[6,10],[10,1],[5,6],[3,9],[2,6],[7,9],[4,11],[4,8],[6,8],[3,8],[9,10],[5,10],[2,8],[7,11]]\\nwas wrong ?"
                    },
                    {
                        "username": "shankark",
                        "content": "I had the same problem. The odd edged nodes are [1,2,3,11]. If you are like me, most likely you are moving [1,2] into even-edged once you figured out that [1,2] doesn't have an edge. Now, for [3,11] you are also considering node [1,2] as they have become even-edged. So, don't do that and you will be ok.\n\nYes. Basically they have the wrong answer. But then they are the authors ;)"
                    },
                    {
                        "username": "Nitin_Kukreti",
                        "content": "if you find odd degree node then you realise they cannon be concerted into even degree do this in copy dont create complete graph just draw those node who have odd  degree"
                    },
                    {
                        "username": "sprs_2804",
                        "content": "same "
                    },
                    {
                        "username": "farziengineer",
                        "content": "Did they add some cases after the contest? I was passing all the test during the contest, now they show as WA :("
                    },
                    {
                        "username": "mage594088",
                        "content": "Me too. It sucks."
                    },
                    {
                        "username": "lebaur",
                        "content": "This question should be medium."
                    },
                    {
                        "username": "rayliux",
                        "content": "What's wrong with my memory? I recalled that in the contest I was able to solve this problem but today I found my solution yields WA. Were more test cases added?"
                    },
                    {
                        "username": "mage594088",
                        "content": "[@stash_](/stash_) Me too. WA at this additional case."
                    },
                    {
                        "username": "stash_",
                        "content": "Yes, they added 1 TC :(\\n5\\n[[4,3],[4,5],[5,3],[3,1],[5,2]]\\n"
                    },
                    {
                        "username": "jialihan",
                        "content": "The description is not clear that \"disconnected nodes\" not considered into the final solution. That means we don\\'t need to ensure the disconnected nodes with \"even\" edges."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "disconnected nodes have 0 degree. 0 is an even number"
                    },
                    {
                        "username": "shivansh961",
                        "content": "In this test case, 2 and 3 are the nodes with odd degree, but they both are already connected. So the answer should be false, but it is true.\nCan anyone explain me how ?\n\n\n\n\n[[2,19],[16,17],[8,14],[2,16],[12,20],[12,14],[16,18],[15,16],[10,21],[3,5],[13,18],[17,20],[14,17],[9,12],[5,15],[5,6],[3,7],\n[2,21],[10,13],[8,16],[7,18],[4,6],[9,1],[13,21],[18,20],[7,14],[4,19],[5,8],[3,11],[11,1],[7,12],[4,7],[3,16],[13,17],[17,19],\n[9,13],[7,19],[10,16],[4,13],[4,5],[2,15],[12,19],[11,16],[2,9],[11,17],[17,1],[16,21],[4,10],[10,14],[14,16],[4,1],[13,20],\n[5,20],[4,14],[4,21],[10,20],[2,14],[8,15],[4,8],[6,19],[15,1],[19,1],[8,19],[15,21],[3,12],[11,18],[9,17],[18,19],[7,21],[3,21],\n[16,19],[11,15],[5,1],[8,17],[3,15],[8,1],[10,19],[3,8],[6,16],[2,8],[5,18],[11,13],[11,20],[14,21],[6,20],[4,20],[12,13],[5,12],\n[10,11],[9,15],[3,19],[9,20],[14,18],[21,1],[13,19],[8,21],[2,13],[3,10],[9,18],[19,21],[6,7],[3,18],[2,18],[6,14],[3,17],[5,21],\n[14,20],[8,9],[16,1],[3,4],[13,1],[5,9],[4,15],[17,21],[20,21],[2,17],[13,14],[11,14],[9,16],[10,18],[6,15],[6,12],[3,13],[5,11],\n[6,1],[12,17],[8,10],[5,10],[8,18],[4,12],[10,1],[6,13],[4,18],[7,20],[7,16],[2,6],[12,21],[4,17],[15,18],[13,16],[15,20],[7,10],\n[6,10],[2,20],[7,15],[18,1],[12,1],[3,20],[7,1],[14,15],[4,9],[11,19],[7,9],[5,17],[18,21],[6,21],[8,11],[6,17],[3,14],[7,11],\n[5,7],[7,13],[6,8],[6,9],[10,12],[5,16],[2,4],[17,18],[9,11],[12,16],[3,6],[12,18],[3,9],[11,12],[14,19],[10,15],[5,13],[8,13],\n[15,17],[2,10],[11,21],[20,1],[6,18],[2,12],[19,20],[6,11],[8,12],[2,3],[12,15],[2,11],[9,10],[7,17],[9,19],[13,15],[7,8],[4,11],\n[2,5],[5,19],[16,20],[15,19],[9,14],[14,1],[10,17],[9,21],[2,7],[8,20],[5,14],[4,16]]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you can choose an even node which is not connected to 2 and 3 .... and connect both of them with that even  node... you need two extra edges to connect them.."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@CamLot_9889e](/CamLot_9889e) understood !!!"
                    },
                    {
                        "username": "CamLot_9889e",
                        "content": "// find a third common node to connect to, both have to connect to same node to maintain evenness of the other node,\\n // so they can\\'t already have an edge with that respective third node."
                    },
                    {
                        "username": "vamsibharadwajECE",
                        "content": "I am getting TLE for this code, please help!!\\n  `class Solution {\\n\\n    bool isthereedge(int x,int y, vector<int> adjlist[]){\\n        int listsize=adjlist[x].size();\\n        for(int i=0;i<listsize;i++){\\n            if(y==adjlist[x][i]) return true;\\n        }\\n        return false;\\n    }\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> adjlist[n+1];\\n        int numedges=edges.size();\\n        for(int i=0;i<numedges;i++){\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            adjlist[a].push_back(b);\\n            adjlist[b].push_back(a);\\n        }\\n        vector<int> indegree(n+1,0);\\n        for(int i=0;i<n+1;i++){\\n            indegree[i]=adjlist[i].size();\\n        }\\n        int oddcount=0;\\n        vector<int> odddegrees;\\n        vector<int> evendegrees;\\n        for(int i=1;i<indegree.size();i++){\\n            if(indegree[i]%2!=0) odddegrees.push_back(i);\\n            else evendegrees.push_back(i);\\n        }\\n        if(odddegrees.size()>4) return false;\\n        oddcount=odddegrees.size();\\n        if(oddcount==1) return false;\\n        if(oddcount==0) return true;\\n        if(oddcount==2){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist)) return true;\\n            for(int i=0;i<evendegrees.size();i++){\\n                if(!isthereedge(odddegrees[0],evendegrees[i],adjlist) && !isthereedge(odddegrees[1],evendegrees[i],adjlist)) return true;\\n            } \\n            return false;\\n        }\\n        if(oddcount==4){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist) && !isthereedge(odddegrees[2],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[2],adjlist) && !isthereedge(odddegrees[1],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[3],adjlist) && !isthereedge(odddegrees[2],odddegrees[1],adjlist)) return true;\\n        }\\n        return false;\\n    }\\n};`\\n\\nI have passed 46/52 cases but I do not understand why am I getting TLE here??"
                    },
                    {
                        "username": "ray920822",
                        "content": "try to check the existence of an edge in less than O(number of neighbors) time"
                    },
                    {
                        "username": "AuHg",
                        "content": "Why the number of nodes with odd degree will next  be odd in graph?"
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because each edge contributes 2 to the total degree of all nodes"
                    },
                    {
                        "username": "shubham-sable",
                        "content": "Can someone Help , why this is giving RTE\\nint inDegree[n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            inDegree[i]=0;\\n        }\\n        vector<int> adj[n+1];\\n        for(int i=0;i<n;i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(auto itr:adj[i])\\n            {\\n                inDegree[itr]++;\\n            }\\n        }\\n        int odd=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(inDegree[i]%2!=0)\\n            {\\n                odd++;\\n            }\\n        }\\n        if(odd%2==0 && odd<=4)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It looks fine\\nhard to say where error is"
                    }
                ]
            },
            {
                "id": 1734361,
                "content": [
                    {
                        "username": "prit_manvar",
                        "content": "Possible Cases:\n1. number of nodes having `odd degree is more than 4` -> `return false`\n2. number of nodes having `odd degree is 4`\n             i -> find internal edges in these 4 nodes.\n             `if number of internal edges is 3 then return false else return true.`\n3. number of nodes having `odd degree is 2`\n            i -> there `isn't edge between these two nodes` having odd degree -> `return true`\n            ii -> search for node in graph who has not connection between both of nodes having odd degree. -> `if found then return true else return false`\n4. number of nodes having `odd degree is 0` -> `return true`\n\n\nNumber of nodes having odd degree will never be odd so i skipped cases like number of nodes having odd degree is 3 or 1."
                    },
                    {
                        "username": "vishnubathla",
                        "content": "was that only me or the test case \\n11\\n[[5,9],[8,1],[2,3],[7,10],[3,6],[6,7],[7,8],[5,1],[5,7],[10,11],[3,7],[6,11],[8,11],[3,4],[8,9],[9,1],[2,10],[9,11],[5,11],[2,5],[8,10],[2,7],[4,1],[3,10],[6,1],[4,9],[4,6],[4,5],[2,4],[2,11],[5,8],[6,9],[4,10],[3,11],[4,7],[3,5],[7,1],[2,9],[6,10],[10,1],[5,6],[3,9],[2,6],[7,9],[4,11],[4,8],[6,8],[3,8],[9,10],[5,10],[2,8],[7,11]]\\nwas wrong ?"
                    },
                    {
                        "username": "shankark",
                        "content": "I had the same problem. The odd edged nodes are [1,2,3,11]. If you are like me, most likely you are moving [1,2] into even-edged once you figured out that [1,2] doesn't have an edge. Now, for [3,11] you are also considering node [1,2] as they have become even-edged. So, don't do that and you will be ok.\n\nYes. Basically they have the wrong answer. But then they are the authors ;)"
                    },
                    {
                        "username": "Nitin_Kukreti",
                        "content": "if you find odd degree node then you realise they cannon be concerted into even degree do this in copy dont create complete graph just draw those node who have odd  degree"
                    },
                    {
                        "username": "sprs_2804",
                        "content": "same "
                    },
                    {
                        "username": "farziengineer",
                        "content": "Did they add some cases after the contest? I was passing all the test during the contest, now they show as WA :("
                    },
                    {
                        "username": "mage594088",
                        "content": "Me too. It sucks."
                    },
                    {
                        "username": "lebaur",
                        "content": "This question should be medium."
                    },
                    {
                        "username": "rayliux",
                        "content": "What's wrong with my memory? I recalled that in the contest I was able to solve this problem but today I found my solution yields WA. Were more test cases added?"
                    },
                    {
                        "username": "mage594088",
                        "content": "[@stash_](/stash_) Me too. WA at this additional case."
                    },
                    {
                        "username": "stash_",
                        "content": "Yes, they added 1 TC :(\\n5\\n[[4,3],[4,5],[5,3],[3,1],[5,2]]\\n"
                    },
                    {
                        "username": "jialihan",
                        "content": "The description is not clear that \"disconnected nodes\" not considered into the final solution. That means we don\\'t need to ensure the disconnected nodes with \"even\" edges."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "disconnected nodes have 0 degree. 0 is an even number"
                    },
                    {
                        "username": "shivansh961",
                        "content": "In this test case, 2 and 3 are the nodes with odd degree, but they both are already connected. So the answer should be false, but it is true.\nCan anyone explain me how ?\n\n\n\n\n[[2,19],[16,17],[8,14],[2,16],[12,20],[12,14],[16,18],[15,16],[10,21],[3,5],[13,18],[17,20],[14,17],[9,12],[5,15],[5,6],[3,7],\n[2,21],[10,13],[8,16],[7,18],[4,6],[9,1],[13,21],[18,20],[7,14],[4,19],[5,8],[3,11],[11,1],[7,12],[4,7],[3,16],[13,17],[17,19],\n[9,13],[7,19],[10,16],[4,13],[4,5],[2,15],[12,19],[11,16],[2,9],[11,17],[17,1],[16,21],[4,10],[10,14],[14,16],[4,1],[13,20],\n[5,20],[4,14],[4,21],[10,20],[2,14],[8,15],[4,8],[6,19],[15,1],[19,1],[8,19],[15,21],[3,12],[11,18],[9,17],[18,19],[7,21],[3,21],\n[16,19],[11,15],[5,1],[8,17],[3,15],[8,1],[10,19],[3,8],[6,16],[2,8],[5,18],[11,13],[11,20],[14,21],[6,20],[4,20],[12,13],[5,12],\n[10,11],[9,15],[3,19],[9,20],[14,18],[21,1],[13,19],[8,21],[2,13],[3,10],[9,18],[19,21],[6,7],[3,18],[2,18],[6,14],[3,17],[5,21],\n[14,20],[8,9],[16,1],[3,4],[13,1],[5,9],[4,15],[17,21],[20,21],[2,17],[13,14],[11,14],[9,16],[10,18],[6,15],[6,12],[3,13],[5,11],\n[6,1],[12,17],[8,10],[5,10],[8,18],[4,12],[10,1],[6,13],[4,18],[7,20],[7,16],[2,6],[12,21],[4,17],[15,18],[13,16],[15,20],[7,10],\n[6,10],[2,20],[7,15],[18,1],[12,1],[3,20],[7,1],[14,15],[4,9],[11,19],[7,9],[5,17],[18,21],[6,21],[8,11],[6,17],[3,14],[7,11],\n[5,7],[7,13],[6,8],[6,9],[10,12],[5,16],[2,4],[17,18],[9,11],[12,16],[3,6],[12,18],[3,9],[11,12],[14,19],[10,15],[5,13],[8,13],\n[15,17],[2,10],[11,21],[20,1],[6,18],[2,12],[19,20],[6,11],[8,12],[2,3],[12,15],[2,11],[9,10],[7,17],[9,19],[13,15],[7,8],[4,11],\n[2,5],[5,19],[16,20],[15,19],[9,14],[14,1],[10,17],[9,21],[2,7],[8,20],[5,14],[4,16]]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you can choose an even node which is not connected to 2 and 3 .... and connect both of them with that even  node... you need two extra edges to connect them.."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@CamLot_9889e](/CamLot_9889e) understood !!!"
                    },
                    {
                        "username": "CamLot_9889e",
                        "content": "// find a third common node to connect to, both have to connect to same node to maintain evenness of the other node,\\n // so they can\\'t already have an edge with that respective third node."
                    },
                    {
                        "username": "vamsibharadwajECE",
                        "content": "I am getting TLE for this code, please help!!\\n  `class Solution {\\n\\n    bool isthereedge(int x,int y, vector<int> adjlist[]){\\n        int listsize=adjlist[x].size();\\n        for(int i=0;i<listsize;i++){\\n            if(y==adjlist[x][i]) return true;\\n        }\\n        return false;\\n    }\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> adjlist[n+1];\\n        int numedges=edges.size();\\n        for(int i=0;i<numedges;i++){\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            adjlist[a].push_back(b);\\n            adjlist[b].push_back(a);\\n        }\\n        vector<int> indegree(n+1,0);\\n        for(int i=0;i<n+1;i++){\\n            indegree[i]=adjlist[i].size();\\n        }\\n        int oddcount=0;\\n        vector<int> odddegrees;\\n        vector<int> evendegrees;\\n        for(int i=1;i<indegree.size();i++){\\n            if(indegree[i]%2!=0) odddegrees.push_back(i);\\n            else evendegrees.push_back(i);\\n        }\\n        if(odddegrees.size()>4) return false;\\n        oddcount=odddegrees.size();\\n        if(oddcount==1) return false;\\n        if(oddcount==0) return true;\\n        if(oddcount==2){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist)) return true;\\n            for(int i=0;i<evendegrees.size();i++){\\n                if(!isthereedge(odddegrees[0],evendegrees[i],adjlist) && !isthereedge(odddegrees[1],evendegrees[i],adjlist)) return true;\\n            } \\n            return false;\\n        }\\n        if(oddcount==4){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist) && !isthereedge(odddegrees[2],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[2],adjlist) && !isthereedge(odddegrees[1],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[3],adjlist) && !isthereedge(odddegrees[2],odddegrees[1],adjlist)) return true;\\n        }\\n        return false;\\n    }\\n};`\\n\\nI have passed 46/52 cases but I do not understand why am I getting TLE here??"
                    },
                    {
                        "username": "ray920822",
                        "content": "try to check the existence of an edge in less than O(number of neighbors) time"
                    },
                    {
                        "username": "AuHg",
                        "content": "Why the number of nodes with odd degree will next  be odd in graph?"
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because each edge contributes 2 to the total degree of all nodes"
                    },
                    {
                        "username": "shubham-sable",
                        "content": "Can someone Help , why this is giving RTE\\nint inDegree[n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            inDegree[i]=0;\\n        }\\n        vector<int> adj[n+1];\\n        for(int i=0;i<n;i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(auto itr:adj[i])\\n            {\\n                inDegree[itr]++;\\n            }\\n        }\\n        int odd=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(inDegree[i]%2!=0)\\n            {\\n                odd++;\\n            }\\n        }\\n        if(odd%2==0 && odd<=4)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It looks fine\\nhard to say where error is"
                    }
                ]
            },
            {
                "id": 1722910,
                "content": [
                    {
                        "username": "prit_manvar",
                        "content": "Possible Cases:\n1. number of nodes having `odd degree is more than 4` -> `return false`\n2. number of nodes having `odd degree is 4`\n             i -> find internal edges in these 4 nodes.\n             `if number of internal edges is 3 then return false else return true.`\n3. number of nodes having `odd degree is 2`\n            i -> there `isn't edge between these two nodes` having odd degree -> `return true`\n            ii -> search for node in graph who has not connection between both of nodes having odd degree. -> `if found then return true else return false`\n4. number of nodes having `odd degree is 0` -> `return true`\n\n\nNumber of nodes having odd degree will never be odd so i skipped cases like number of nodes having odd degree is 3 or 1."
                    },
                    {
                        "username": "vishnubathla",
                        "content": "was that only me or the test case \\n11\\n[[5,9],[8,1],[2,3],[7,10],[3,6],[6,7],[7,8],[5,1],[5,7],[10,11],[3,7],[6,11],[8,11],[3,4],[8,9],[9,1],[2,10],[9,11],[5,11],[2,5],[8,10],[2,7],[4,1],[3,10],[6,1],[4,9],[4,6],[4,5],[2,4],[2,11],[5,8],[6,9],[4,10],[3,11],[4,7],[3,5],[7,1],[2,9],[6,10],[10,1],[5,6],[3,9],[2,6],[7,9],[4,11],[4,8],[6,8],[3,8],[9,10],[5,10],[2,8],[7,11]]\\nwas wrong ?"
                    },
                    {
                        "username": "shankark",
                        "content": "I had the same problem. The odd edged nodes are [1,2,3,11]. If you are like me, most likely you are moving [1,2] into even-edged once you figured out that [1,2] doesn't have an edge. Now, for [3,11] you are also considering node [1,2] as they have become even-edged. So, don't do that and you will be ok.\n\nYes. Basically they have the wrong answer. But then they are the authors ;)"
                    },
                    {
                        "username": "Nitin_Kukreti",
                        "content": "if you find odd degree node then you realise they cannon be concerted into even degree do this in copy dont create complete graph just draw those node who have odd  degree"
                    },
                    {
                        "username": "sprs_2804",
                        "content": "same "
                    },
                    {
                        "username": "farziengineer",
                        "content": "Did they add some cases after the contest? I was passing all the test during the contest, now they show as WA :("
                    },
                    {
                        "username": "mage594088",
                        "content": "Me too. It sucks."
                    },
                    {
                        "username": "lebaur",
                        "content": "This question should be medium."
                    },
                    {
                        "username": "rayliux",
                        "content": "What's wrong with my memory? I recalled that in the contest I was able to solve this problem but today I found my solution yields WA. Were more test cases added?"
                    },
                    {
                        "username": "mage594088",
                        "content": "[@stash_](/stash_) Me too. WA at this additional case."
                    },
                    {
                        "username": "stash_",
                        "content": "Yes, they added 1 TC :(\\n5\\n[[4,3],[4,5],[5,3],[3,1],[5,2]]\\n"
                    },
                    {
                        "username": "jialihan",
                        "content": "The description is not clear that \"disconnected nodes\" not considered into the final solution. That means we don\\'t need to ensure the disconnected nodes with \"even\" edges."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "disconnected nodes have 0 degree. 0 is an even number"
                    },
                    {
                        "username": "shivansh961",
                        "content": "In this test case, 2 and 3 are the nodes with odd degree, but they both are already connected. So the answer should be false, but it is true.\nCan anyone explain me how ?\n\n\n\n\n[[2,19],[16,17],[8,14],[2,16],[12,20],[12,14],[16,18],[15,16],[10,21],[3,5],[13,18],[17,20],[14,17],[9,12],[5,15],[5,6],[3,7],\n[2,21],[10,13],[8,16],[7,18],[4,6],[9,1],[13,21],[18,20],[7,14],[4,19],[5,8],[3,11],[11,1],[7,12],[4,7],[3,16],[13,17],[17,19],\n[9,13],[7,19],[10,16],[4,13],[4,5],[2,15],[12,19],[11,16],[2,9],[11,17],[17,1],[16,21],[4,10],[10,14],[14,16],[4,1],[13,20],\n[5,20],[4,14],[4,21],[10,20],[2,14],[8,15],[4,8],[6,19],[15,1],[19,1],[8,19],[15,21],[3,12],[11,18],[9,17],[18,19],[7,21],[3,21],\n[16,19],[11,15],[5,1],[8,17],[3,15],[8,1],[10,19],[3,8],[6,16],[2,8],[5,18],[11,13],[11,20],[14,21],[6,20],[4,20],[12,13],[5,12],\n[10,11],[9,15],[3,19],[9,20],[14,18],[21,1],[13,19],[8,21],[2,13],[3,10],[9,18],[19,21],[6,7],[3,18],[2,18],[6,14],[3,17],[5,21],\n[14,20],[8,9],[16,1],[3,4],[13,1],[5,9],[4,15],[17,21],[20,21],[2,17],[13,14],[11,14],[9,16],[10,18],[6,15],[6,12],[3,13],[5,11],\n[6,1],[12,17],[8,10],[5,10],[8,18],[4,12],[10,1],[6,13],[4,18],[7,20],[7,16],[2,6],[12,21],[4,17],[15,18],[13,16],[15,20],[7,10],\n[6,10],[2,20],[7,15],[18,1],[12,1],[3,20],[7,1],[14,15],[4,9],[11,19],[7,9],[5,17],[18,21],[6,21],[8,11],[6,17],[3,14],[7,11],\n[5,7],[7,13],[6,8],[6,9],[10,12],[5,16],[2,4],[17,18],[9,11],[12,16],[3,6],[12,18],[3,9],[11,12],[14,19],[10,15],[5,13],[8,13],\n[15,17],[2,10],[11,21],[20,1],[6,18],[2,12],[19,20],[6,11],[8,12],[2,3],[12,15],[2,11],[9,10],[7,17],[9,19],[13,15],[7,8],[4,11],\n[2,5],[5,19],[16,20],[15,19],[9,14],[14,1],[10,17],[9,21],[2,7],[8,20],[5,14],[4,16]]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you can choose an even node which is not connected to 2 and 3 .... and connect both of them with that even  node... you need two extra edges to connect them.."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@CamLot_9889e](/CamLot_9889e) understood !!!"
                    },
                    {
                        "username": "CamLot_9889e",
                        "content": "// find a third common node to connect to, both have to connect to same node to maintain evenness of the other node,\\n // so they can\\'t already have an edge with that respective third node."
                    },
                    {
                        "username": "vamsibharadwajECE",
                        "content": "I am getting TLE for this code, please help!!\\n  `class Solution {\\n\\n    bool isthereedge(int x,int y, vector<int> adjlist[]){\\n        int listsize=adjlist[x].size();\\n        for(int i=0;i<listsize;i++){\\n            if(y==adjlist[x][i]) return true;\\n        }\\n        return false;\\n    }\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> adjlist[n+1];\\n        int numedges=edges.size();\\n        for(int i=0;i<numedges;i++){\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            adjlist[a].push_back(b);\\n            adjlist[b].push_back(a);\\n        }\\n        vector<int> indegree(n+1,0);\\n        for(int i=0;i<n+1;i++){\\n            indegree[i]=adjlist[i].size();\\n        }\\n        int oddcount=0;\\n        vector<int> odddegrees;\\n        vector<int> evendegrees;\\n        for(int i=1;i<indegree.size();i++){\\n            if(indegree[i]%2!=0) odddegrees.push_back(i);\\n            else evendegrees.push_back(i);\\n        }\\n        if(odddegrees.size()>4) return false;\\n        oddcount=odddegrees.size();\\n        if(oddcount==1) return false;\\n        if(oddcount==0) return true;\\n        if(oddcount==2){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist)) return true;\\n            for(int i=0;i<evendegrees.size();i++){\\n                if(!isthereedge(odddegrees[0],evendegrees[i],adjlist) && !isthereedge(odddegrees[1],evendegrees[i],adjlist)) return true;\\n            } \\n            return false;\\n        }\\n        if(oddcount==4){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist) && !isthereedge(odddegrees[2],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[2],adjlist) && !isthereedge(odddegrees[1],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[3],adjlist) && !isthereedge(odddegrees[2],odddegrees[1],adjlist)) return true;\\n        }\\n        return false;\\n    }\\n};`\\n\\nI have passed 46/52 cases but I do not understand why am I getting TLE here??"
                    },
                    {
                        "username": "ray920822",
                        "content": "try to check the existence of an edge in less than O(number of neighbors) time"
                    },
                    {
                        "username": "AuHg",
                        "content": "Why the number of nodes with odd degree will next  be odd in graph?"
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because each edge contributes 2 to the total degree of all nodes"
                    },
                    {
                        "username": "shubham-sable",
                        "content": "Can someone Help , why this is giving RTE\\nint inDegree[n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            inDegree[i]=0;\\n        }\\n        vector<int> adj[n+1];\\n        for(int i=0;i<n;i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(auto itr:adj[i])\\n            {\\n                inDegree[itr]++;\\n            }\\n        }\\n        int odd=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(inDegree[i]%2!=0)\\n            {\\n                odd++;\\n            }\\n        }\\n        if(odd%2==0 && odd<=4)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It looks fine\\nhard to say where error is"
                    }
                ]
            },
            {
                "id": 1720077,
                "content": [
                    {
                        "username": "prit_manvar",
                        "content": "Possible Cases:\n1. number of nodes having `odd degree is more than 4` -> `return false`\n2. number of nodes having `odd degree is 4`\n             i -> find internal edges in these 4 nodes.\n             `if number of internal edges is 3 then return false else return true.`\n3. number of nodes having `odd degree is 2`\n            i -> there `isn't edge between these two nodes` having odd degree -> `return true`\n            ii -> search for node in graph who has not connection between both of nodes having odd degree. -> `if found then return true else return false`\n4. number of nodes having `odd degree is 0` -> `return true`\n\n\nNumber of nodes having odd degree will never be odd so i skipped cases like number of nodes having odd degree is 3 or 1."
                    },
                    {
                        "username": "vishnubathla",
                        "content": "was that only me or the test case \\n11\\n[[5,9],[8,1],[2,3],[7,10],[3,6],[6,7],[7,8],[5,1],[5,7],[10,11],[3,7],[6,11],[8,11],[3,4],[8,9],[9,1],[2,10],[9,11],[5,11],[2,5],[8,10],[2,7],[4,1],[3,10],[6,1],[4,9],[4,6],[4,5],[2,4],[2,11],[5,8],[6,9],[4,10],[3,11],[4,7],[3,5],[7,1],[2,9],[6,10],[10,1],[5,6],[3,9],[2,6],[7,9],[4,11],[4,8],[6,8],[3,8],[9,10],[5,10],[2,8],[7,11]]\\nwas wrong ?"
                    },
                    {
                        "username": "shankark",
                        "content": "I had the same problem. The odd edged nodes are [1,2,3,11]. If you are like me, most likely you are moving [1,2] into even-edged once you figured out that [1,2] doesn't have an edge. Now, for [3,11] you are also considering node [1,2] as they have become even-edged. So, don't do that and you will be ok.\n\nYes. Basically they have the wrong answer. But then they are the authors ;)"
                    },
                    {
                        "username": "Nitin_Kukreti",
                        "content": "if you find odd degree node then you realise they cannon be concerted into even degree do this in copy dont create complete graph just draw those node who have odd  degree"
                    },
                    {
                        "username": "sprs_2804",
                        "content": "same "
                    },
                    {
                        "username": "farziengineer",
                        "content": "Did they add some cases after the contest? I was passing all the test during the contest, now they show as WA :("
                    },
                    {
                        "username": "mage594088",
                        "content": "Me too. It sucks."
                    },
                    {
                        "username": "lebaur",
                        "content": "This question should be medium."
                    },
                    {
                        "username": "rayliux",
                        "content": "What's wrong with my memory? I recalled that in the contest I was able to solve this problem but today I found my solution yields WA. Were more test cases added?"
                    },
                    {
                        "username": "mage594088",
                        "content": "[@stash_](/stash_) Me too. WA at this additional case."
                    },
                    {
                        "username": "stash_",
                        "content": "Yes, they added 1 TC :(\\n5\\n[[4,3],[4,5],[5,3],[3,1],[5,2]]\\n"
                    },
                    {
                        "username": "jialihan",
                        "content": "The description is not clear that \"disconnected nodes\" not considered into the final solution. That means we don\\'t need to ensure the disconnected nodes with \"even\" edges."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "disconnected nodes have 0 degree. 0 is an even number"
                    },
                    {
                        "username": "shivansh961",
                        "content": "In this test case, 2 and 3 are the nodes with odd degree, but they both are already connected. So the answer should be false, but it is true.\nCan anyone explain me how ?\n\n\n\n\n[[2,19],[16,17],[8,14],[2,16],[12,20],[12,14],[16,18],[15,16],[10,21],[3,5],[13,18],[17,20],[14,17],[9,12],[5,15],[5,6],[3,7],\n[2,21],[10,13],[8,16],[7,18],[4,6],[9,1],[13,21],[18,20],[7,14],[4,19],[5,8],[3,11],[11,1],[7,12],[4,7],[3,16],[13,17],[17,19],\n[9,13],[7,19],[10,16],[4,13],[4,5],[2,15],[12,19],[11,16],[2,9],[11,17],[17,1],[16,21],[4,10],[10,14],[14,16],[4,1],[13,20],\n[5,20],[4,14],[4,21],[10,20],[2,14],[8,15],[4,8],[6,19],[15,1],[19,1],[8,19],[15,21],[3,12],[11,18],[9,17],[18,19],[7,21],[3,21],\n[16,19],[11,15],[5,1],[8,17],[3,15],[8,1],[10,19],[3,8],[6,16],[2,8],[5,18],[11,13],[11,20],[14,21],[6,20],[4,20],[12,13],[5,12],\n[10,11],[9,15],[3,19],[9,20],[14,18],[21,1],[13,19],[8,21],[2,13],[3,10],[9,18],[19,21],[6,7],[3,18],[2,18],[6,14],[3,17],[5,21],\n[14,20],[8,9],[16,1],[3,4],[13,1],[5,9],[4,15],[17,21],[20,21],[2,17],[13,14],[11,14],[9,16],[10,18],[6,15],[6,12],[3,13],[5,11],\n[6,1],[12,17],[8,10],[5,10],[8,18],[4,12],[10,1],[6,13],[4,18],[7,20],[7,16],[2,6],[12,21],[4,17],[15,18],[13,16],[15,20],[7,10],\n[6,10],[2,20],[7,15],[18,1],[12,1],[3,20],[7,1],[14,15],[4,9],[11,19],[7,9],[5,17],[18,21],[6,21],[8,11],[6,17],[3,14],[7,11],\n[5,7],[7,13],[6,8],[6,9],[10,12],[5,16],[2,4],[17,18],[9,11],[12,16],[3,6],[12,18],[3,9],[11,12],[14,19],[10,15],[5,13],[8,13],\n[15,17],[2,10],[11,21],[20,1],[6,18],[2,12],[19,20],[6,11],[8,12],[2,3],[12,15],[2,11],[9,10],[7,17],[9,19],[13,15],[7,8],[4,11],\n[2,5],[5,19],[16,20],[15,19],[9,14],[14,1],[10,17],[9,21],[2,7],[8,20],[5,14],[4,16]]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you can choose an even node which is not connected to 2 and 3 .... and connect both of them with that even  node... you need two extra edges to connect them.."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@CamLot_9889e](/CamLot_9889e) understood !!!"
                    },
                    {
                        "username": "CamLot_9889e",
                        "content": "// find a third common node to connect to, both have to connect to same node to maintain evenness of the other node,\\n // so they can\\'t already have an edge with that respective third node."
                    },
                    {
                        "username": "vamsibharadwajECE",
                        "content": "I am getting TLE for this code, please help!!\\n  `class Solution {\\n\\n    bool isthereedge(int x,int y, vector<int> adjlist[]){\\n        int listsize=adjlist[x].size();\\n        for(int i=0;i<listsize;i++){\\n            if(y==adjlist[x][i]) return true;\\n        }\\n        return false;\\n    }\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> adjlist[n+1];\\n        int numedges=edges.size();\\n        for(int i=0;i<numedges;i++){\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            adjlist[a].push_back(b);\\n            adjlist[b].push_back(a);\\n        }\\n        vector<int> indegree(n+1,0);\\n        for(int i=0;i<n+1;i++){\\n            indegree[i]=adjlist[i].size();\\n        }\\n        int oddcount=0;\\n        vector<int> odddegrees;\\n        vector<int> evendegrees;\\n        for(int i=1;i<indegree.size();i++){\\n            if(indegree[i]%2!=0) odddegrees.push_back(i);\\n            else evendegrees.push_back(i);\\n        }\\n        if(odddegrees.size()>4) return false;\\n        oddcount=odddegrees.size();\\n        if(oddcount==1) return false;\\n        if(oddcount==0) return true;\\n        if(oddcount==2){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist)) return true;\\n            for(int i=0;i<evendegrees.size();i++){\\n                if(!isthereedge(odddegrees[0],evendegrees[i],adjlist) && !isthereedge(odddegrees[1],evendegrees[i],adjlist)) return true;\\n            } \\n            return false;\\n        }\\n        if(oddcount==4){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist) && !isthereedge(odddegrees[2],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[2],adjlist) && !isthereedge(odddegrees[1],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[3],adjlist) && !isthereedge(odddegrees[2],odddegrees[1],adjlist)) return true;\\n        }\\n        return false;\\n    }\\n};`\\n\\nI have passed 46/52 cases but I do not understand why am I getting TLE here??"
                    },
                    {
                        "username": "ray920822",
                        "content": "try to check the existence of an edge in less than O(number of neighbors) time"
                    },
                    {
                        "username": "AuHg",
                        "content": "Why the number of nodes with odd degree will next  be odd in graph?"
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because each edge contributes 2 to the total degree of all nodes"
                    },
                    {
                        "username": "shubham-sable",
                        "content": "Can someone Help , why this is giving RTE\\nint inDegree[n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            inDegree[i]=0;\\n        }\\n        vector<int> adj[n+1];\\n        for(int i=0;i<n;i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(auto itr:adj[i])\\n            {\\n                inDegree[itr]++;\\n            }\\n        }\\n        int odd=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(inDegree[i]%2!=0)\\n            {\\n                odd++;\\n            }\\n        }\\n        if(odd%2==0 && odd<=4)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It looks fine\\nhard to say where error is"
                    }
                ]
            },
            {
                "id": 1720182,
                "content": [
                    {
                        "username": "prit_manvar",
                        "content": "Possible Cases:\n1. number of nodes having `odd degree is more than 4` -> `return false`\n2. number of nodes having `odd degree is 4`\n             i -> find internal edges in these 4 nodes.\n             `if number of internal edges is 3 then return false else return true.`\n3. number of nodes having `odd degree is 2`\n            i -> there `isn't edge between these two nodes` having odd degree -> `return true`\n            ii -> search for node in graph who has not connection between both of nodes having odd degree. -> `if found then return true else return false`\n4. number of nodes having `odd degree is 0` -> `return true`\n\n\nNumber of nodes having odd degree will never be odd so i skipped cases like number of nodes having odd degree is 3 or 1."
                    },
                    {
                        "username": "vishnubathla",
                        "content": "was that only me or the test case \\n11\\n[[5,9],[8,1],[2,3],[7,10],[3,6],[6,7],[7,8],[5,1],[5,7],[10,11],[3,7],[6,11],[8,11],[3,4],[8,9],[9,1],[2,10],[9,11],[5,11],[2,5],[8,10],[2,7],[4,1],[3,10],[6,1],[4,9],[4,6],[4,5],[2,4],[2,11],[5,8],[6,9],[4,10],[3,11],[4,7],[3,5],[7,1],[2,9],[6,10],[10,1],[5,6],[3,9],[2,6],[7,9],[4,11],[4,8],[6,8],[3,8],[9,10],[5,10],[2,8],[7,11]]\\nwas wrong ?"
                    },
                    {
                        "username": "shankark",
                        "content": "I had the same problem. The odd edged nodes are [1,2,3,11]. If you are like me, most likely you are moving [1,2] into even-edged once you figured out that [1,2] doesn't have an edge. Now, for [3,11] you are also considering node [1,2] as they have become even-edged. So, don't do that and you will be ok.\n\nYes. Basically they have the wrong answer. But then they are the authors ;)"
                    },
                    {
                        "username": "Nitin_Kukreti",
                        "content": "if you find odd degree node then you realise they cannon be concerted into even degree do this in copy dont create complete graph just draw those node who have odd  degree"
                    },
                    {
                        "username": "sprs_2804",
                        "content": "same "
                    },
                    {
                        "username": "farziengineer",
                        "content": "Did they add some cases after the contest? I was passing all the test during the contest, now they show as WA :("
                    },
                    {
                        "username": "mage594088",
                        "content": "Me too. It sucks."
                    },
                    {
                        "username": "lebaur",
                        "content": "This question should be medium."
                    },
                    {
                        "username": "rayliux",
                        "content": "What's wrong with my memory? I recalled that in the contest I was able to solve this problem but today I found my solution yields WA. Were more test cases added?"
                    },
                    {
                        "username": "mage594088",
                        "content": "[@stash_](/stash_) Me too. WA at this additional case."
                    },
                    {
                        "username": "stash_",
                        "content": "Yes, they added 1 TC :(\\n5\\n[[4,3],[4,5],[5,3],[3,1],[5,2]]\\n"
                    },
                    {
                        "username": "jialihan",
                        "content": "The description is not clear that \"disconnected nodes\" not considered into the final solution. That means we don\\'t need to ensure the disconnected nodes with \"even\" edges."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "disconnected nodes have 0 degree. 0 is an even number"
                    },
                    {
                        "username": "shivansh961",
                        "content": "In this test case, 2 and 3 are the nodes with odd degree, but they both are already connected. So the answer should be false, but it is true.\nCan anyone explain me how ?\n\n\n\n\n[[2,19],[16,17],[8,14],[2,16],[12,20],[12,14],[16,18],[15,16],[10,21],[3,5],[13,18],[17,20],[14,17],[9,12],[5,15],[5,6],[3,7],\n[2,21],[10,13],[8,16],[7,18],[4,6],[9,1],[13,21],[18,20],[7,14],[4,19],[5,8],[3,11],[11,1],[7,12],[4,7],[3,16],[13,17],[17,19],\n[9,13],[7,19],[10,16],[4,13],[4,5],[2,15],[12,19],[11,16],[2,9],[11,17],[17,1],[16,21],[4,10],[10,14],[14,16],[4,1],[13,20],\n[5,20],[4,14],[4,21],[10,20],[2,14],[8,15],[4,8],[6,19],[15,1],[19,1],[8,19],[15,21],[3,12],[11,18],[9,17],[18,19],[7,21],[3,21],\n[16,19],[11,15],[5,1],[8,17],[3,15],[8,1],[10,19],[3,8],[6,16],[2,8],[5,18],[11,13],[11,20],[14,21],[6,20],[4,20],[12,13],[5,12],\n[10,11],[9,15],[3,19],[9,20],[14,18],[21,1],[13,19],[8,21],[2,13],[3,10],[9,18],[19,21],[6,7],[3,18],[2,18],[6,14],[3,17],[5,21],\n[14,20],[8,9],[16,1],[3,4],[13,1],[5,9],[4,15],[17,21],[20,21],[2,17],[13,14],[11,14],[9,16],[10,18],[6,15],[6,12],[3,13],[5,11],\n[6,1],[12,17],[8,10],[5,10],[8,18],[4,12],[10,1],[6,13],[4,18],[7,20],[7,16],[2,6],[12,21],[4,17],[15,18],[13,16],[15,20],[7,10],\n[6,10],[2,20],[7,15],[18,1],[12,1],[3,20],[7,1],[14,15],[4,9],[11,19],[7,9],[5,17],[18,21],[6,21],[8,11],[6,17],[3,14],[7,11],\n[5,7],[7,13],[6,8],[6,9],[10,12],[5,16],[2,4],[17,18],[9,11],[12,16],[3,6],[12,18],[3,9],[11,12],[14,19],[10,15],[5,13],[8,13],\n[15,17],[2,10],[11,21],[20,1],[6,18],[2,12],[19,20],[6,11],[8,12],[2,3],[12,15],[2,11],[9,10],[7,17],[9,19],[13,15],[7,8],[4,11],\n[2,5],[5,19],[16,20],[15,19],[9,14],[14,1],[10,17],[9,21],[2,7],[8,20],[5,14],[4,16]]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you can choose an even node which is not connected to 2 and 3 .... and connect both of them with that even  node... you need two extra edges to connect them.."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@CamLot_9889e](/CamLot_9889e) understood !!!"
                    },
                    {
                        "username": "CamLot_9889e",
                        "content": "// find a third common node to connect to, both have to connect to same node to maintain evenness of the other node,\\n // so they can\\'t already have an edge with that respective third node."
                    },
                    {
                        "username": "vamsibharadwajECE",
                        "content": "I am getting TLE for this code, please help!!\\n  `class Solution {\\n\\n    bool isthereedge(int x,int y, vector<int> adjlist[]){\\n        int listsize=adjlist[x].size();\\n        for(int i=0;i<listsize;i++){\\n            if(y==adjlist[x][i]) return true;\\n        }\\n        return false;\\n    }\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> adjlist[n+1];\\n        int numedges=edges.size();\\n        for(int i=0;i<numedges;i++){\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            adjlist[a].push_back(b);\\n            adjlist[b].push_back(a);\\n        }\\n        vector<int> indegree(n+1,0);\\n        for(int i=0;i<n+1;i++){\\n            indegree[i]=adjlist[i].size();\\n        }\\n        int oddcount=0;\\n        vector<int> odddegrees;\\n        vector<int> evendegrees;\\n        for(int i=1;i<indegree.size();i++){\\n            if(indegree[i]%2!=0) odddegrees.push_back(i);\\n            else evendegrees.push_back(i);\\n        }\\n        if(odddegrees.size()>4) return false;\\n        oddcount=odddegrees.size();\\n        if(oddcount==1) return false;\\n        if(oddcount==0) return true;\\n        if(oddcount==2){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist)) return true;\\n            for(int i=0;i<evendegrees.size();i++){\\n                if(!isthereedge(odddegrees[0],evendegrees[i],adjlist) && !isthereedge(odddegrees[1],evendegrees[i],adjlist)) return true;\\n            } \\n            return false;\\n        }\\n        if(oddcount==4){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist) && !isthereedge(odddegrees[2],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[2],adjlist) && !isthereedge(odddegrees[1],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[3],adjlist) && !isthereedge(odddegrees[2],odddegrees[1],adjlist)) return true;\\n        }\\n        return false;\\n    }\\n};`\\n\\nI have passed 46/52 cases but I do not understand why am I getting TLE here??"
                    },
                    {
                        "username": "ray920822",
                        "content": "try to check the existence of an edge in less than O(number of neighbors) time"
                    },
                    {
                        "username": "AuHg",
                        "content": "Why the number of nodes with odd degree will next  be odd in graph?"
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because each edge contributes 2 to the total degree of all nodes"
                    },
                    {
                        "username": "shubham-sable",
                        "content": "Can someone Help , why this is giving RTE\\nint inDegree[n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            inDegree[i]=0;\\n        }\\n        vector<int> adj[n+1];\\n        for(int i=0;i<n;i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(auto itr:adj[i])\\n            {\\n                inDegree[itr]++;\\n            }\\n        }\\n        int odd=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(inDegree[i]%2!=0)\\n            {\\n                odd++;\\n            }\\n        }\\n        if(odd%2==0 && odd<=4)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It looks fine\\nhard to say where error is"
                    }
                ]
            },
            {
                "id": 1735813,
                "content": [
                    {
                        "username": "prit_manvar",
                        "content": "Possible Cases:\n1. number of nodes having `odd degree is more than 4` -> `return false`\n2. number of nodes having `odd degree is 4`\n             i -> find internal edges in these 4 nodes.\n             `if number of internal edges is 3 then return false else return true.`\n3. number of nodes having `odd degree is 2`\n            i -> there `isn't edge between these two nodes` having odd degree -> `return true`\n            ii -> search for node in graph who has not connection between both of nodes having odd degree. -> `if found then return true else return false`\n4. number of nodes having `odd degree is 0` -> `return true`\n\n\nNumber of nodes having odd degree will never be odd so i skipped cases like number of nodes having odd degree is 3 or 1."
                    },
                    {
                        "username": "vishnubathla",
                        "content": "was that only me or the test case \\n11\\n[[5,9],[8,1],[2,3],[7,10],[3,6],[6,7],[7,8],[5,1],[5,7],[10,11],[3,7],[6,11],[8,11],[3,4],[8,9],[9,1],[2,10],[9,11],[5,11],[2,5],[8,10],[2,7],[4,1],[3,10],[6,1],[4,9],[4,6],[4,5],[2,4],[2,11],[5,8],[6,9],[4,10],[3,11],[4,7],[3,5],[7,1],[2,9],[6,10],[10,1],[5,6],[3,9],[2,6],[7,9],[4,11],[4,8],[6,8],[3,8],[9,10],[5,10],[2,8],[7,11]]\\nwas wrong ?"
                    },
                    {
                        "username": "shankark",
                        "content": "I had the same problem. The odd edged nodes are [1,2,3,11]. If you are like me, most likely you are moving [1,2] into even-edged once you figured out that [1,2] doesn't have an edge. Now, for [3,11] you are also considering node [1,2] as they have become even-edged. So, don't do that and you will be ok.\n\nYes. Basically they have the wrong answer. But then they are the authors ;)"
                    },
                    {
                        "username": "Nitin_Kukreti",
                        "content": "if you find odd degree node then you realise they cannon be concerted into even degree do this in copy dont create complete graph just draw those node who have odd  degree"
                    },
                    {
                        "username": "sprs_2804",
                        "content": "same "
                    },
                    {
                        "username": "farziengineer",
                        "content": "Did they add some cases after the contest? I was passing all the test during the contest, now they show as WA :("
                    },
                    {
                        "username": "mage594088",
                        "content": "Me too. It sucks."
                    },
                    {
                        "username": "lebaur",
                        "content": "This question should be medium."
                    },
                    {
                        "username": "rayliux",
                        "content": "What's wrong with my memory? I recalled that in the contest I was able to solve this problem but today I found my solution yields WA. Were more test cases added?"
                    },
                    {
                        "username": "mage594088",
                        "content": "[@stash_](/stash_) Me too. WA at this additional case."
                    },
                    {
                        "username": "stash_",
                        "content": "Yes, they added 1 TC :(\\n5\\n[[4,3],[4,5],[5,3],[3,1],[5,2]]\\n"
                    },
                    {
                        "username": "jialihan",
                        "content": "The description is not clear that \"disconnected nodes\" not considered into the final solution. That means we don\\'t need to ensure the disconnected nodes with \"even\" edges."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "disconnected nodes have 0 degree. 0 is an even number"
                    },
                    {
                        "username": "shivansh961",
                        "content": "In this test case, 2 and 3 are the nodes with odd degree, but they both are already connected. So the answer should be false, but it is true.\nCan anyone explain me how ?\n\n\n\n\n[[2,19],[16,17],[8,14],[2,16],[12,20],[12,14],[16,18],[15,16],[10,21],[3,5],[13,18],[17,20],[14,17],[9,12],[5,15],[5,6],[3,7],\n[2,21],[10,13],[8,16],[7,18],[4,6],[9,1],[13,21],[18,20],[7,14],[4,19],[5,8],[3,11],[11,1],[7,12],[4,7],[3,16],[13,17],[17,19],\n[9,13],[7,19],[10,16],[4,13],[4,5],[2,15],[12,19],[11,16],[2,9],[11,17],[17,1],[16,21],[4,10],[10,14],[14,16],[4,1],[13,20],\n[5,20],[4,14],[4,21],[10,20],[2,14],[8,15],[4,8],[6,19],[15,1],[19,1],[8,19],[15,21],[3,12],[11,18],[9,17],[18,19],[7,21],[3,21],\n[16,19],[11,15],[5,1],[8,17],[3,15],[8,1],[10,19],[3,8],[6,16],[2,8],[5,18],[11,13],[11,20],[14,21],[6,20],[4,20],[12,13],[5,12],\n[10,11],[9,15],[3,19],[9,20],[14,18],[21,1],[13,19],[8,21],[2,13],[3,10],[9,18],[19,21],[6,7],[3,18],[2,18],[6,14],[3,17],[5,21],\n[14,20],[8,9],[16,1],[3,4],[13,1],[5,9],[4,15],[17,21],[20,21],[2,17],[13,14],[11,14],[9,16],[10,18],[6,15],[6,12],[3,13],[5,11],\n[6,1],[12,17],[8,10],[5,10],[8,18],[4,12],[10,1],[6,13],[4,18],[7,20],[7,16],[2,6],[12,21],[4,17],[15,18],[13,16],[15,20],[7,10],\n[6,10],[2,20],[7,15],[18,1],[12,1],[3,20],[7,1],[14,15],[4,9],[11,19],[7,9],[5,17],[18,21],[6,21],[8,11],[6,17],[3,14],[7,11],\n[5,7],[7,13],[6,8],[6,9],[10,12],[5,16],[2,4],[17,18],[9,11],[12,16],[3,6],[12,18],[3,9],[11,12],[14,19],[10,15],[5,13],[8,13],\n[15,17],[2,10],[11,21],[20,1],[6,18],[2,12],[19,20],[6,11],[8,12],[2,3],[12,15],[2,11],[9,10],[7,17],[9,19],[13,15],[7,8],[4,11],\n[2,5],[5,19],[16,20],[15,19],[9,14],[14,1],[10,17],[9,21],[2,7],[8,20],[5,14],[4,16]]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you can choose an even node which is not connected to 2 and 3 .... and connect both of them with that even  node... you need two extra edges to connect them.."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@CamLot_9889e](/CamLot_9889e) understood !!!"
                    },
                    {
                        "username": "CamLot_9889e",
                        "content": "// find a third common node to connect to, both have to connect to same node to maintain evenness of the other node,\\n // so they can\\'t already have an edge with that respective third node."
                    },
                    {
                        "username": "vamsibharadwajECE",
                        "content": "I am getting TLE for this code, please help!!\\n  `class Solution {\\n\\n    bool isthereedge(int x,int y, vector<int> adjlist[]){\\n        int listsize=adjlist[x].size();\\n        for(int i=0;i<listsize;i++){\\n            if(y==adjlist[x][i]) return true;\\n        }\\n        return false;\\n    }\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> adjlist[n+1];\\n        int numedges=edges.size();\\n        for(int i=0;i<numedges;i++){\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            adjlist[a].push_back(b);\\n            adjlist[b].push_back(a);\\n        }\\n        vector<int> indegree(n+1,0);\\n        for(int i=0;i<n+1;i++){\\n            indegree[i]=adjlist[i].size();\\n        }\\n        int oddcount=0;\\n        vector<int> odddegrees;\\n        vector<int> evendegrees;\\n        for(int i=1;i<indegree.size();i++){\\n            if(indegree[i]%2!=0) odddegrees.push_back(i);\\n            else evendegrees.push_back(i);\\n        }\\n        if(odddegrees.size()>4) return false;\\n        oddcount=odddegrees.size();\\n        if(oddcount==1) return false;\\n        if(oddcount==0) return true;\\n        if(oddcount==2){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist)) return true;\\n            for(int i=0;i<evendegrees.size();i++){\\n                if(!isthereedge(odddegrees[0],evendegrees[i],adjlist) && !isthereedge(odddegrees[1],evendegrees[i],adjlist)) return true;\\n            } \\n            return false;\\n        }\\n        if(oddcount==4){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist) && !isthereedge(odddegrees[2],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[2],adjlist) && !isthereedge(odddegrees[1],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[3],adjlist) && !isthereedge(odddegrees[2],odddegrees[1],adjlist)) return true;\\n        }\\n        return false;\\n    }\\n};`\\n\\nI have passed 46/52 cases but I do not understand why am I getting TLE here??"
                    },
                    {
                        "username": "ray920822",
                        "content": "try to check the existence of an edge in less than O(number of neighbors) time"
                    },
                    {
                        "username": "AuHg",
                        "content": "Why the number of nodes with odd degree will next  be odd in graph?"
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because each edge contributes 2 to the total degree of all nodes"
                    },
                    {
                        "username": "shubham-sable",
                        "content": "Can someone Help , why this is giving RTE\\nint inDegree[n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            inDegree[i]=0;\\n        }\\n        vector<int> adj[n+1];\\n        for(int i=0;i<n;i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(auto itr:adj[i])\\n            {\\n                inDegree[itr]++;\\n            }\\n        }\\n        int odd=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(inDegree[i]%2!=0)\\n            {\\n                odd++;\\n            }\\n        }\\n        if(odd%2==0 && odd<=4)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It looks fine\\nhard to say where error is"
                    }
                ]
            },
            {
                "id": 1720224,
                "content": [
                    {
                        "username": "prit_manvar",
                        "content": "Possible Cases:\n1. number of nodes having `odd degree is more than 4` -> `return false`\n2. number of nodes having `odd degree is 4`\n             i -> find internal edges in these 4 nodes.\n             `if number of internal edges is 3 then return false else return true.`\n3. number of nodes having `odd degree is 2`\n            i -> there `isn't edge between these two nodes` having odd degree -> `return true`\n            ii -> search for node in graph who has not connection between both of nodes having odd degree. -> `if found then return true else return false`\n4. number of nodes having `odd degree is 0` -> `return true`\n\n\nNumber of nodes having odd degree will never be odd so i skipped cases like number of nodes having odd degree is 3 or 1."
                    },
                    {
                        "username": "vishnubathla",
                        "content": "was that only me or the test case \\n11\\n[[5,9],[8,1],[2,3],[7,10],[3,6],[6,7],[7,8],[5,1],[5,7],[10,11],[3,7],[6,11],[8,11],[3,4],[8,9],[9,1],[2,10],[9,11],[5,11],[2,5],[8,10],[2,7],[4,1],[3,10],[6,1],[4,9],[4,6],[4,5],[2,4],[2,11],[5,8],[6,9],[4,10],[3,11],[4,7],[3,5],[7,1],[2,9],[6,10],[10,1],[5,6],[3,9],[2,6],[7,9],[4,11],[4,8],[6,8],[3,8],[9,10],[5,10],[2,8],[7,11]]\\nwas wrong ?"
                    },
                    {
                        "username": "shankark",
                        "content": "I had the same problem. The odd edged nodes are [1,2,3,11]. If you are like me, most likely you are moving [1,2] into even-edged once you figured out that [1,2] doesn't have an edge. Now, for [3,11] you are also considering node [1,2] as they have become even-edged. So, don't do that and you will be ok.\n\nYes. Basically they have the wrong answer. But then they are the authors ;)"
                    },
                    {
                        "username": "Nitin_Kukreti",
                        "content": "if you find odd degree node then you realise they cannon be concerted into even degree do this in copy dont create complete graph just draw those node who have odd  degree"
                    },
                    {
                        "username": "sprs_2804",
                        "content": "same "
                    },
                    {
                        "username": "farziengineer",
                        "content": "Did they add some cases after the contest? I was passing all the test during the contest, now they show as WA :("
                    },
                    {
                        "username": "mage594088",
                        "content": "Me too. It sucks."
                    },
                    {
                        "username": "lebaur",
                        "content": "This question should be medium."
                    },
                    {
                        "username": "rayliux",
                        "content": "What's wrong with my memory? I recalled that in the contest I was able to solve this problem but today I found my solution yields WA. Were more test cases added?"
                    },
                    {
                        "username": "mage594088",
                        "content": "[@stash_](/stash_) Me too. WA at this additional case."
                    },
                    {
                        "username": "stash_",
                        "content": "Yes, they added 1 TC :(\\n5\\n[[4,3],[4,5],[5,3],[3,1],[5,2]]\\n"
                    },
                    {
                        "username": "jialihan",
                        "content": "The description is not clear that \"disconnected nodes\" not considered into the final solution. That means we don\\'t need to ensure the disconnected nodes with \"even\" edges."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "disconnected nodes have 0 degree. 0 is an even number"
                    },
                    {
                        "username": "shivansh961",
                        "content": "In this test case, 2 and 3 are the nodes with odd degree, but they both are already connected. So the answer should be false, but it is true.\nCan anyone explain me how ?\n\n\n\n\n[[2,19],[16,17],[8,14],[2,16],[12,20],[12,14],[16,18],[15,16],[10,21],[3,5],[13,18],[17,20],[14,17],[9,12],[5,15],[5,6],[3,7],\n[2,21],[10,13],[8,16],[7,18],[4,6],[9,1],[13,21],[18,20],[7,14],[4,19],[5,8],[3,11],[11,1],[7,12],[4,7],[3,16],[13,17],[17,19],\n[9,13],[7,19],[10,16],[4,13],[4,5],[2,15],[12,19],[11,16],[2,9],[11,17],[17,1],[16,21],[4,10],[10,14],[14,16],[4,1],[13,20],\n[5,20],[4,14],[4,21],[10,20],[2,14],[8,15],[4,8],[6,19],[15,1],[19,1],[8,19],[15,21],[3,12],[11,18],[9,17],[18,19],[7,21],[3,21],\n[16,19],[11,15],[5,1],[8,17],[3,15],[8,1],[10,19],[3,8],[6,16],[2,8],[5,18],[11,13],[11,20],[14,21],[6,20],[4,20],[12,13],[5,12],\n[10,11],[9,15],[3,19],[9,20],[14,18],[21,1],[13,19],[8,21],[2,13],[3,10],[9,18],[19,21],[6,7],[3,18],[2,18],[6,14],[3,17],[5,21],\n[14,20],[8,9],[16,1],[3,4],[13,1],[5,9],[4,15],[17,21],[20,21],[2,17],[13,14],[11,14],[9,16],[10,18],[6,15],[6,12],[3,13],[5,11],\n[6,1],[12,17],[8,10],[5,10],[8,18],[4,12],[10,1],[6,13],[4,18],[7,20],[7,16],[2,6],[12,21],[4,17],[15,18],[13,16],[15,20],[7,10],\n[6,10],[2,20],[7,15],[18,1],[12,1],[3,20],[7,1],[14,15],[4,9],[11,19],[7,9],[5,17],[18,21],[6,21],[8,11],[6,17],[3,14],[7,11],\n[5,7],[7,13],[6,8],[6,9],[10,12],[5,16],[2,4],[17,18],[9,11],[12,16],[3,6],[12,18],[3,9],[11,12],[14,19],[10,15],[5,13],[8,13],\n[15,17],[2,10],[11,21],[20,1],[6,18],[2,12],[19,20],[6,11],[8,12],[2,3],[12,15],[2,11],[9,10],[7,17],[9,19],[13,15],[7,8],[4,11],\n[2,5],[5,19],[16,20],[15,19],[9,14],[14,1],[10,17],[9,21],[2,7],[8,20],[5,14],[4,16]]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you can choose an even node which is not connected to 2 and 3 .... and connect both of them with that even  node... you need two extra edges to connect them.."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@CamLot_9889e](/CamLot_9889e) understood !!!"
                    },
                    {
                        "username": "CamLot_9889e",
                        "content": "// find a third common node to connect to, both have to connect to same node to maintain evenness of the other node,\\n // so they can\\'t already have an edge with that respective third node."
                    },
                    {
                        "username": "vamsibharadwajECE",
                        "content": "I am getting TLE for this code, please help!!\\n  `class Solution {\\n\\n    bool isthereedge(int x,int y, vector<int> adjlist[]){\\n        int listsize=adjlist[x].size();\\n        for(int i=0;i<listsize;i++){\\n            if(y==adjlist[x][i]) return true;\\n        }\\n        return false;\\n    }\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> adjlist[n+1];\\n        int numedges=edges.size();\\n        for(int i=0;i<numedges;i++){\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            adjlist[a].push_back(b);\\n            adjlist[b].push_back(a);\\n        }\\n        vector<int> indegree(n+1,0);\\n        for(int i=0;i<n+1;i++){\\n            indegree[i]=adjlist[i].size();\\n        }\\n        int oddcount=0;\\n        vector<int> odddegrees;\\n        vector<int> evendegrees;\\n        for(int i=1;i<indegree.size();i++){\\n            if(indegree[i]%2!=0) odddegrees.push_back(i);\\n            else evendegrees.push_back(i);\\n        }\\n        if(odddegrees.size()>4) return false;\\n        oddcount=odddegrees.size();\\n        if(oddcount==1) return false;\\n        if(oddcount==0) return true;\\n        if(oddcount==2){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist)) return true;\\n            for(int i=0;i<evendegrees.size();i++){\\n                if(!isthereedge(odddegrees[0],evendegrees[i],adjlist) && !isthereedge(odddegrees[1],evendegrees[i],adjlist)) return true;\\n            } \\n            return false;\\n        }\\n        if(oddcount==4){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist) && !isthereedge(odddegrees[2],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[2],adjlist) && !isthereedge(odddegrees[1],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[3],adjlist) && !isthereedge(odddegrees[2],odddegrees[1],adjlist)) return true;\\n        }\\n        return false;\\n    }\\n};`\\n\\nI have passed 46/52 cases but I do not understand why am I getting TLE here??"
                    },
                    {
                        "username": "ray920822",
                        "content": "try to check the existence of an edge in less than O(number of neighbors) time"
                    },
                    {
                        "username": "AuHg",
                        "content": "Why the number of nodes with odd degree will next  be odd in graph?"
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because each edge contributes 2 to the total degree of all nodes"
                    },
                    {
                        "username": "shubham-sable",
                        "content": "Can someone Help , why this is giving RTE\\nint inDegree[n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            inDegree[i]=0;\\n        }\\n        vector<int> adj[n+1];\\n        for(int i=0;i<n;i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(auto itr:adj[i])\\n            {\\n                inDegree[itr]++;\\n            }\\n        }\\n        int odd=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(inDegree[i]%2!=0)\\n            {\\n                odd++;\\n            }\\n        }\\n        if(odd%2==0 && odd<=4)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It looks fine\\nhard to say where error is"
                    }
                ]
            },
            {
                "id": 1720067,
                "content": [
                    {
                        "username": "prit_manvar",
                        "content": "Possible Cases:\n1. number of nodes having `odd degree is more than 4` -> `return false`\n2. number of nodes having `odd degree is 4`\n             i -> find internal edges in these 4 nodes.\n             `if number of internal edges is 3 then return false else return true.`\n3. number of nodes having `odd degree is 2`\n            i -> there `isn't edge between these two nodes` having odd degree -> `return true`\n            ii -> search for node in graph who has not connection between both of nodes having odd degree. -> `if found then return true else return false`\n4. number of nodes having `odd degree is 0` -> `return true`\n\n\nNumber of nodes having odd degree will never be odd so i skipped cases like number of nodes having odd degree is 3 or 1."
                    },
                    {
                        "username": "vishnubathla",
                        "content": "was that only me or the test case \\n11\\n[[5,9],[8,1],[2,3],[7,10],[3,6],[6,7],[7,8],[5,1],[5,7],[10,11],[3,7],[6,11],[8,11],[3,4],[8,9],[9,1],[2,10],[9,11],[5,11],[2,5],[8,10],[2,7],[4,1],[3,10],[6,1],[4,9],[4,6],[4,5],[2,4],[2,11],[5,8],[6,9],[4,10],[3,11],[4,7],[3,5],[7,1],[2,9],[6,10],[10,1],[5,6],[3,9],[2,6],[7,9],[4,11],[4,8],[6,8],[3,8],[9,10],[5,10],[2,8],[7,11]]\\nwas wrong ?"
                    },
                    {
                        "username": "shankark",
                        "content": "I had the same problem. The odd edged nodes are [1,2,3,11]. If you are like me, most likely you are moving [1,2] into even-edged once you figured out that [1,2] doesn't have an edge. Now, for [3,11] you are also considering node [1,2] as they have become even-edged. So, don't do that and you will be ok.\n\nYes. Basically they have the wrong answer. But then they are the authors ;)"
                    },
                    {
                        "username": "Nitin_Kukreti",
                        "content": "if you find odd degree node then you realise they cannon be concerted into even degree do this in copy dont create complete graph just draw those node who have odd  degree"
                    },
                    {
                        "username": "sprs_2804",
                        "content": "same "
                    },
                    {
                        "username": "farziengineer",
                        "content": "Did they add some cases after the contest? I was passing all the test during the contest, now they show as WA :("
                    },
                    {
                        "username": "mage594088",
                        "content": "Me too. It sucks."
                    },
                    {
                        "username": "lebaur",
                        "content": "This question should be medium."
                    },
                    {
                        "username": "rayliux",
                        "content": "What's wrong with my memory? I recalled that in the contest I was able to solve this problem but today I found my solution yields WA. Were more test cases added?"
                    },
                    {
                        "username": "mage594088",
                        "content": "[@stash_](/stash_) Me too. WA at this additional case."
                    },
                    {
                        "username": "stash_",
                        "content": "Yes, they added 1 TC :(\\n5\\n[[4,3],[4,5],[5,3],[3,1],[5,2]]\\n"
                    },
                    {
                        "username": "jialihan",
                        "content": "The description is not clear that \"disconnected nodes\" not considered into the final solution. That means we don\\'t need to ensure the disconnected nodes with \"even\" edges."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "disconnected nodes have 0 degree. 0 is an even number"
                    },
                    {
                        "username": "shivansh961",
                        "content": "In this test case, 2 and 3 are the nodes with odd degree, but they both are already connected. So the answer should be false, but it is true.\nCan anyone explain me how ?\n\n\n\n\n[[2,19],[16,17],[8,14],[2,16],[12,20],[12,14],[16,18],[15,16],[10,21],[3,5],[13,18],[17,20],[14,17],[9,12],[5,15],[5,6],[3,7],\n[2,21],[10,13],[8,16],[7,18],[4,6],[9,1],[13,21],[18,20],[7,14],[4,19],[5,8],[3,11],[11,1],[7,12],[4,7],[3,16],[13,17],[17,19],\n[9,13],[7,19],[10,16],[4,13],[4,5],[2,15],[12,19],[11,16],[2,9],[11,17],[17,1],[16,21],[4,10],[10,14],[14,16],[4,1],[13,20],\n[5,20],[4,14],[4,21],[10,20],[2,14],[8,15],[4,8],[6,19],[15,1],[19,1],[8,19],[15,21],[3,12],[11,18],[9,17],[18,19],[7,21],[3,21],\n[16,19],[11,15],[5,1],[8,17],[3,15],[8,1],[10,19],[3,8],[6,16],[2,8],[5,18],[11,13],[11,20],[14,21],[6,20],[4,20],[12,13],[5,12],\n[10,11],[9,15],[3,19],[9,20],[14,18],[21,1],[13,19],[8,21],[2,13],[3,10],[9,18],[19,21],[6,7],[3,18],[2,18],[6,14],[3,17],[5,21],\n[14,20],[8,9],[16,1],[3,4],[13,1],[5,9],[4,15],[17,21],[20,21],[2,17],[13,14],[11,14],[9,16],[10,18],[6,15],[6,12],[3,13],[5,11],\n[6,1],[12,17],[8,10],[5,10],[8,18],[4,12],[10,1],[6,13],[4,18],[7,20],[7,16],[2,6],[12,21],[4,17],[15,18],[13,16],[15,20],[7,10],\n[6,10],[2,20],[7,15],[18,1],[12,1],[3,20],[7,1],[14,15],[4,9],[11,19],[7,9],[5,17],[18,21],[6,21],[8,11],[6,17],[3,14],[7,11],\n[5,7],[7,13],[6,8],[6,9],[10,12],[5,16],[2,4],[17,18],[9,11],[12,16],[3,6],[12,18],[3,9],[11,12],[14,19],[10,15],[5,13],[8,13],\n[15,17],[2,10],[11,21],[20,1],[6,18],[2,12],[19,20],[6,11],[8,12],[2,3],[12,15],[2,11],[9,10],[7,17],[9,19],[13,15],[7,8],[4,11],\n[2,5],[5,19],[16,20],[15,19],[9,14],[14,1],[10,17],[9,21],[2,7],[8,20],[5,14],[4,16]]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you can choose an even node which is not connected to 2 and 3 .... and connect both of them with that even  node... you need two extra edges to connect them.."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@CamLot_9889e](/CamLot_9889e) understood !!!"
                    },
                    {
                        "username": "CamLot_9889e",
                        "content": "// find a third common node to connect to, both have to connect to same node to maintain evenness of the other node,\\n // so they can\\'t already have an edge with that respective third node."
                    },
                    {
                        "username": "vamsibharadwajECE",
                        "content": "I am getting TLE for this code, please help!!\\n  `class Solution {\\n\\n    bool isthereedge(int x,int y, vector<int> adjlist[]){\\n        int listsize=adjlist[x].size();\\n        for(int i=0;i<listsize;i++){\\n            if(y==adjlist[x][i]) return true;\\n        }\\n        return false;\\n    }\\n    bool isPossible(int n, vector<vector<int>>& edges) {\\n        vector<int> adjlist[n+1];\\n        int numedges=edges.size();\\n        for(int i=0;i<numedges;i++){\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            adjlist[a].push_back(b);\\n            adjlist[b].push_back(a);\\n        }\\n        vector<int> indegree(n+1,0);\\n        for(int i=0;i<n+1;i++){\\n            indegree[i]=adjlist[i].size();\\n        }\\n        int oddcount=0;\\n        vector<int> odddegrees;\\n        vector<int> evendegrees;\\n        for(int i=1;i<indegree.size();i++){\\n            if(indegree[i]%2!=0) odddegrees.push_back(i);\\n            else evendegrees.push_back(i);\\n        }\\n        if(odddegrees.size()>4) return false;\\n        oddcount=odddegrees.size();\\n        if(oddcount==1) return false;\\n        if(oddcount==0) return true;\\n        if(oddcount==2){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist)) return true;\\n            for(int i=0;i<evendegrees.size();i++){\\n                if(!isthereedge(odddegrees[0],evendegrees[i],adjlist) && !isthereedge(odddegrees[1],evendegrees[i],adjlist)) return true;\\n            } \\n            return false;\\n        }\\n        if(oddcount==4){\\n            if(!isthereedge(odddegrees[0],odddegrees[1],adjlist) && !isthereedge(odddegrees[2],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[2],adjlist) && !isthereedge(odddegrees[1],odddegrees[3],adjlist)) return true;\\n            if(!isthereedge(odddegrees[0],odddegrees[3],adjlist) && !isthereedge(odddegrees[2],odddegrees[1],adjlist)) return true;\\n        }\\n        return false;\\n    }\\n};`\\n\\nI have passed 46/52 cases but I do not understand why am I getting TLE here??"
                    },
                    {
                        "username": "ray920822",
                        "content": "try to check the existence of an edge in less than O(number of neighbors) time"
                    },
                    {
                        "username": "AuHg",
                        "content": "Why the number of nodes with odd degree will next  be odd in graph?"
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because each edge contributes 2 to the total degree of all nodes"
                    },
                    {
                        "username": "shubham-sable",
                        "content": "Can someone Help , why this is giving RTE\\nint inDegree[n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            inDegree[i]=0;\\n        }\\n        vector<int> adj[n+1];\\n        for(int i=0;i<n;i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(auto itr:adj[i])\\n            {\\n                inDegree[itr]++;\\n            }\\n        }\\n        int odd=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(inDegree[i]%2!=0)\\n            {\\n                odd++;\\n            }\\n        }\\n        if(odd%2==0 && odd<=4)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It looks fine\\nhard to say where error is"
                    }
                ]
            }
        ]
    }
]