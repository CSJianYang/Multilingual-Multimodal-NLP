[
    {
        "title": "Pow(x, n)",
        "question_content": "Implement pow(x, n), which calculates x raised to the power n (i.e., xn).\n&nbsp;\nExample 1:\n\nInput: x = 2.00000, n = 10\nOutput: 1024.00000\n\nExample 2:\n\nInput: x = 2.10000, n = 3\nOutput: 9.26100\n\nExample 3:\n\nInput: x = 2.00000, n = -2\nOutput: 0.25000\nExplanation: 2-2 = 1/22 = 1/4 = 0.25\n\n&nbsp;\nConstraints:\n\n\t-100.0 < x < 100.0\n\t-231 <= n <= 231-1\n\tn is an integer.\n\tEither x is not zero or n > 0.\n\t-104 <= xn <= 104",
        "solutions": [
            {
                "id": 1337794,
                "title": "java-c-simple-o-log-n-easy-faster-than-100-explained",
                "content": "* <u>**FIRST APPROACH**</u>\\n\\n\\tWe can solve this problem by multiplying x by n times\\n\\teg:\\n\\t`x = 7 and n = 11`\\n\\t**7 * 7 * 7 * 7 * 7 * 7 * 7 * 7 * 7 * 7 * 7 = 1977326743**\\n\\tHere we have **multiplied 7 for 11 times**, which will result in **O(n)**\\n\\tBut, Suppose `x = 1 and n = 2147483647`\\n\\tIf we follow this approach then, **1 will be multiplied 2147483647 times** which is not efficient at all.\\n\\t\\n* <u>**COMPLEXITY**</u>\\n\\t* **Time: O(n)**, where `n` is the given power\\n\\t* **Space: O(1)**, in-place\\n\\n<hr>\\n\\n* <u>**SECOND  APPROACH**</u>\\n\\n\\tIn order to improve efficiency we will opt for **Binary Exponentiation using which we can calculate x<sup>n</sup> using O log<sub>2</sub>(N) multiplications.**\\n\\n\\t**Basic Idea is to divide the work using binary representation of exponents**\\n\\ti.e. is to keep multiplying pow with x, if the bit is odd, and multiplying x with itself until we get 0\\n\\tWe will use very **1st example of 1st Approach** i.e.\\n\\t`x = 7, n = 11 and pow = 1`\\n\\tHere, we have to calculate 7<sup>11</sup>\\n\\t**Binary of n i.e. (11)<sub>10</sub> is (1011)<sub>2</sub>**\\n\\t**1 &nbsp; 0 &nbsp; 1 &nbsp; 1**\\n\\t2<sup>3 &nbsp;</sup>2<sup>2</sup>&nbsp; 2<sup>1</sup> &nbsp;2<sup>0</sup>&nbsp;&nbsp;  <-- Corresponding **place values** of each bit\\n\\n\\tOR we can also write this as\\n\\t**1  0  1  1**\\n\\t8 4 2 1  <-- Corresponding **place values** of each bit\\n\\n\\tNow, **7<sup>8</sup> &#215; 7<sup>2</sup> &#215; 7<sup>1</sup>** == **7<sup>11</sup>** as **7<sup>(8 + 2 + 1)</sup>** == **7<sup>11</sup>**\\n**NOTE:**  We have not considered **7<sup>4</sup>** in this case as the **4th place bit is OFF**\\n\\n\\tSo, **7<sup>8</sup> &#215; 7<sup>2</sup> &#215; 7<sup>1</sup>** == **5764801 &#215; 49 &#215; 7** == **1977326743** **<-- Desired Output**\\n\\tNow, applying logic keeping this concept in mind\\n\\n\\t```\\n\\tdouble pow = 1;\\n\\twhile(n != 0){\\n\\t\\tif((n & 1) != 0) // equivalent to if((n % 2) != 0) i.e. multiply only when the number is odd  \\n\\t\\tpow *= x;\\n\\n\\t\\tx *= x;\\n\\t\\tn >>>= 1; // equivalent to n = n / 2; i.e. keep dividing the number by 2\\n\\n\\t}\\n\\t```\\n*   <u>**PROCESS**</u>\\n\\t* \\t**Iteration 1**\\n\\tpow = <u>1 &#215; 7</u> = 7\\n\\tx = 7 \\xD7 7 = 49\\n\\tn = 11 >>> 1 = 5\\n\\n\\t* \\t**Iteration 2**\\n\\tpow = <u>7 \\xD7 49</u> = 343\\n\\tx = 49 \\xD7 49 = 2401\\n\\tn = 5 >>> 1 = 2\\n\\n\\t* \\t**Iteration 3**\\n\\tx = 2401 \\xD7 2401 = 5764801\\n\\tn = 2 >>> 1 = 1\\n\\n\\t* \\t**Iteration 4**\\n\\tpow = <u>343 \\xD7 5764801</u> = 1977326743\\n\\tx = 5764801 \\xD7 5764801 = 3.323293057 \\xD7 10\\xB9\\xB3\\n\\tn = 1 >>> 1 = 0\\n\\nWe exit the loop as the number has become 0 and we got pow as **1977326743 which is the desired output**\\nIn this binary exponentiation approach, the loop iterated for only 4 times which is nothing but (O log<sub>2</sub>(N) + 1) ~ **(O log<sub>2</sub>(N))**\\n\\nAnd for **2nd example of 1st Approach** where\\n`x = 1 and n = 2147483647`\\nThis loop executed for only 31 times **(O log<sub>2</sub>(N))** which is far far less than 2147483647 times(in case of O(N) approach)<br>\\n\\n* <u>**JAVA / C++ CODE**</u>\\n\\n\\t<iframe src=\"https://leetcode.com/playground/hRAZkbLc/shared\" frameBorder=\"0\" width=\"100%\" height=\"400\"></iframe>\\n\\n* <u>**COMPLEXITY**</u>\\n\\t* **Time: O(log<sub>2</sub>(n))**, where `n` is the given power\\n\\t* **Space: O(1),** in-place\\n\\n<img src = \"https://assets.leetcode.com/users/images/6f980162-6f32-4bfc-88e2-212a3d2d83cd_1645193689.9401023.jpeg\" width = \"100%\">\\n<br><br><br>\\n<img src = \"https://assets.leetcode.com/users/images/5e27a0db-88da-4bfa-830b-a9e18b37cc30_1645193695.887591.jpeg\" width = \"100%\">\\n<br><br>\\n\\n\\n<u>**Refer to the following github repsitory for more leetcode solutions**</u>\\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\\n\\n# **Please UPVOTE if you find this post helpful :)**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\n\\tdouble pow = 1;\\n\\twhile(n != 0){\\n\\t\\tif((n & 1) != 0) // equivalent to if((n % 2) != 0) i.e. multiply only when the number is odd  \\n\\t\\tpow *= x;\\n\\n\\t\\tx *= x;\\n\\t\\tn >>>= 1; // equivalent to n = n / 2; i.e. keep dividing the number by 2\\n\\n\\t}\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 19546,
                "title": "short-and-easy-to-understand-solution",
                "content": "    public class Solution {\\n        public double pow(double x, int n) {\\n            if(n == 0)\\n                return 1;\\n            if(n<0){\\n                n = -n;\\n                x = 1/x;\\n            }\\n            return (n%2 == 0) ? pow(x*x, n/2) : x*pow(x*x, n/2);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public double pow(double x, int n) {\\n            if(n == 0)\\n                return 1;\\n            if(n<0){\\n                n = -n;\\n                x = 1/x;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 19544,
                "title": "5-different-choices-when-talk-with-interviewers",
                "content": "After reading some good sharing solutions, I'd like to show them together. You can see different ideas in the code.\\n1. nest myPow\\n----------\\n\\n    double myPow(double x, int n) {\\n        if(n<0) return 1/x * myPow(1/x, -(n+1));\\n        if(n==0) return 1;\\n        if(n==2) return x*x;\\n        if(n%2==0) return myPow( myPow(x, n/2), 2);\\n        else return x*myPow( myPow(x, n/2), 2);\\n    }\\n\\n2. double myPow\\n---------------\\n\\n    double myPow(double x, int n) { \\n        if(n==0) return 1;\\n        double t = myPow(x,n/2);\\n        if(n%2) return n<0 ? 1/x*t*t : x*t*t;\\n        else return t*t;\\n    }\\n\\n3. double x\\n---------------\\n\\n    double myPow(double x, int n) { \\n        if(n==0) return 1;\\n        if(n<0){\\n            n = -n;\\n            x = 1/x;\\n        }\\n        return n%2==0 ? myPow(x*x, n/2) : x*myPow(x*x, n/2);\\n    }\\n\\n\\n4. iterative one\\n----------------\\n\\n    double myPow(double x, int n) { \\n        if(n==0) return 1;\\n        if(n<0) {\\n            n = -n;\\n            x = 1/x;\\n        }\\n        double ans = 1;\\n        while(n>0){\\n            if(n&1) ans *= x;\\n            x *= x;\\n            n >>= 1;\\n        }\\n        return ans;\\n    }\\n\\n5. bit operation\\n---------------\\nsee this [solution][1]\\n\\nIf you have other ideas, please leave it below. Thanks.\\n\\n  [1]: https://leetcode.com/discuss/12004/my-answer-using-bit-operation-c-implementation",
                "solutionTags": [
                    "Java"
                ],
                "code": "After reading some good sharing solutions, I'd like to show them together. You can see different ideas in the code.\\n1. nest myPow\\n----------\\n\\n    double myPow(double x, int n) {\\n        if(n<0) return 1/x * myPow(1/x, -(n+1));\\n        if(n==0) return 1;\\n        if(n==2) return x*x;\\n        if(n%2==0) return myPow( myPow(x, n/2), 2);\\n        else return x*myPow( myPow(x, n/2), 2);\\n    }\\n\\n2. double myPow\\n---------------\\n\\n    double myPow(double x, int n) { \\n        if(n==0) return 1;\\n        double t = myPow(x,n/2);\\n        if(n%2) return n<0 ? 1/x*t*t : x*t*t;\\n        else return t*t;\\n    }\\n\\n3. double x\\n---------------\\n\\n    double myPow(double x, int n) { \\n        if(n==0) return 1;\\n        if(n<0){\\n            n = -n;\\n            x = 1/x;\\n        }\\n        return n%2==0 ? myPow(x*x, n/2) : x*myPow(x*x, n/2);\\n    }\\n\\n\\n4. iterative one\\n----------------\\n\\n    double myPow(double x, int n) { \\n        if(n==0) return 1;\\n        if(n<0) {\\n            n = -n;\\n            x = 1/x;\\n        }\\n        double ans = 1;\\n        while(n>0){\\n            if(n&1) ans *= x;\\n            x *= x;\\n            n >>= 1;\\n        }\\n        return ans;\\n    }\\n\\n5. bit operation\\n---------------\\nsee this [solution][1]\\n\\nIf you have other ideas, please leave it below. Thanks.\\n\\n  [1]: https://leetcode.com/discuss/12004/my-answer-using-bit-operation-c-implementation",
                "codeTag": "Unknown"
            },
            {
                "id": 19560,
                "title": "shortest-python-guaranteed",
                "content": "[Surprisingly](http://stackoverflow.com/questions/30693639/why-does-class-x-mypow-pow-work-what-about-self), I can just use Python's existing `pow` like this:\\n\\n    class Solution:\\n        myPow = pow\\n\\nThat's even shorter than the other more obvious \"cheat\":\\n\\n    class Solution:\\n        def myPow(self, x, n):\\n            return x ** n\\n\\nAnd to calm down the haters, here's me *\"doing it myself\"*:\\n\\nRecursive:\\n\\n    class Solution:\\n        def myPow(self, x, n):\\n            if not n:\\n                return 1\\n            if n < 0:\\n                return 1 / self.myPow(x, -n)\\n            if n % 2:\\n                return x * self.myPow(x, n-1)\\n            return self.myPow(x*x, n/2)\\n\\nIterative:\\n\\n    class Solution:\\n        def myPow(self, x, n):\\n            if n < 0:\\n                x = 1 / x\\n                n = -n\\n            pow = 1\\n            while n:\\n                if n & 1:\\n                    pow *= x\\n                x *= x\\n                n >>= 1\\n            return pow",
                "solutionTags": [
                    "Python"
                ],
                "code": "[Surprisingly](http://stackoverflow.com/questions/30693639/why-does-class-x-mypow-pow-work-what-about-self), I can just use Python's existing `pow` like this:\\n\\n    class Solution:\\n        myPow = pow\\n\\nThat's even shorter than the other more obvious \"cheat\":\\n\\n    class Solution:\\n        def myPow(self, x, n):\\n            return x ** n\\n\\nAnd to calm down the haters, here's me *\"doing it myself\"*:\\n\\nRecursive:\\n\\n    class Solution:\\n        def myPow(self, x, n):\\n            if not n:\\n                return 1\\n            if n < 0:\\n                return 1 / self.myPow(x, -n)\\n            if n % 2:\\n                return x * self.myPow(x, n-1)\\n            return self.myPow(x*x, n/2)\\n\\nIterative:\\n\\n    class Solution:\\n        def myPow(self, x, n):\\n            if n < 0:\\n                x = 1 / x\\n                n = -n\\n            pow = 1\\n            while n:\\n                if n & 1:\\n                    pow *= x\\n                x *= x\\n                n >>= 1\\n            return pow",
                "codeTag": "Java"
            },
            {
                "id": 19563,
                "title": "iterative-log-n-solution-with-clear-explanation",
                "content": "I couldn't find a clear explanation for an interative Log(n) solution so here's mine.  The basic idea is to decompose the exponent into powers of 2, so that you can keep dividing the problem in half.  For example, lets say \\n\\nN = 9 = 2^3 + 2^0 = 1001 in binary. Then:\\n\\nx^9 = x^(2^3) * x^(2^0)\\n\\nWe can see that every time we encounter a 1 in the binary representation of N, we need to multiply the answer with x^(2^i) where **i** is the **ith** bit of the exponent.  Thus, we can keep a running total of repeatedly squaring x - (x, x^2, x^4, x^8, etc) and multiply it by the answer when we see a 1.  \\n\\nTo handle the case where N=INTEGER_MIN we use a long (64-bit) variable.  Below is solution:\\n\\n    public class Solution {\\n        public double MyPow(double x, int n) {\\n            double ans = 1;\\n            long absN = Math.Abs((long)n);\\n            while(absN > 0) {\\n                if((absN&1)==1) ans *= x;\\n                absN >>= 1;\\n                x *= x;\\n            }\\n            return n < 0 ?  1/ans : ans;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public double MyPow(double x, int n) {\\n            double ans = 1;\\n            long absN = Math.Abs((long)n);\\n            while(absN > 0) {\\n                if((absN&1)==1) ans *= x;\\n                absN >>= 1;\\n                x *= x;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 739646,
                "title": "c-iterative-vs-recursive-bitwise-solutions-explained-100-time-80-space",
                "content": "This is a classic problem: in order to computer the value of `x` raised to the `n`th power, you might start to consider first of all the case in which `n` is positive.\\n\\nLet\\'s assume that `n == 13`, so we can say `pow(x, 13) == pow(x, 1) * pow(x, 4) * pow(x, 8)`.\\n\\nLooks familiar? We basically decomposed `13` in its binary digits (`1101`).\\n\\nOkay, then: why would we care? Because that is how a computer efficiently gets powers: at each step we multiply `x` by itself, so we will get `x`(`^1`), `x^2`, `x^4`, `x^8`, `x^16` and so on.\\n\\nStarting to see the bits of the puzzle coming together now, now? We can decompose `n` as a binary number and then keep multiplying for `x` raised to some power of `2` value as we go along and - boom, the magic is done!\\n\\nOkay now, but what about negative powers?\\n\\nWell, instead of multiplying, we divide. Period.\\n\\nNo, really: it changes that little.\\n\\nIterative approach, easier to follow:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double res = 1;\\n        while (n) {\\n            if (n % 2) res = n > 0 ? res * x : res / x;\\n            x = x * x;\\n            n /= 2;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nRecursive, because oneliners are always cooler:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    double myPow(double x, int n, double res = 1) {\\n        return n ? myPow(x * x, n / 2, n % 2 ? (n > 0 ? res * x : res / x) : res) : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double res = 1;\\n        while (n) {\\n            if (n % 2) res = n > 0 ? res * x : res / x;\\n            x = x * x;\\n            n /= 2;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    double myPow(double x, int n, double res = 1) {\\n        return n ? myPow(x * x, n / 2, n % 2 ? (n > 0 ? res * x : res / x) : res) : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 738830,
                "title": "python-recursive-o-log-n-solution-explained",
                "content": "This problem has in my opinion a bit strange statement: it is not specified that we can not use already existing power or logarithm function, but I will consider, that we can not use them. Also in python numbers potentially can be very big or very close to zero, what should we do in these cases? You should ask you interviewer. \\n\\nThe main idea of solution is to use as much multiplications as possible, for example how can we evaluate `x^20`? We can just multiply `x` in loop `20` times, but we also can evaluate `x^10` and multiply it by itself! Similarly, `x^10 = x^5 * x^5`. Now we have odd power, but it is not a problem, we evaluate `x^5 = x^2 * x^2 * x`. We also need to deal with some border cases, here is the full algorithm:\\n\\n1. If we have very small value of `x` we can directly return `0`, the smallest value of float is `1.175494 \\xD7 10^(-38)`.\\n2. If we have `n = 0`, return `1`.\\n3. If we have negative power, return positive power of `1/x`.\\n4. Now, we have two cases: for even and for odd `n`, where we evaluate power `n//2`.\\n\\n**Complexity**: time complexity is `O(log n)`, space complexity for this recursive algorithm is also `O(log n)`, which can be reduced to `O(1)`, if we use iterative approach instead.\\n```\\nclass Solution:\\n    def myPow(self, x, n):\\n        if abs(x) < 1e-40: return 0 \\n        if n == 0: return 1\\n        if n < 0: return self.myPow(1/x, -n)\\n        lower = self.myPow(x, n//2)\\n        if n % 2 == 0: return lower*lower\\n        if n % 2 == 1: return lower*lower*x\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def myPow(self, x, n):\\n        if abs(x) < 1e-40: return 0 \\n        if n == 0: return 1\\n        if n < 0: return self.myPow(1/x, -n)\\n        lower = self.myPow(x, n//2)\\n        if n % 2 == 0: return lower*lower\\n        if n % 2 == 1: return lower*lower*x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206602,
                "title": "best-c-5-solution-math-recursion-brute-force-optimize-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using math and recursion.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N), because we call the recurtion until we multiply the base exponent times. Thus the\\n    time complexity is linear.\\n\\n    Space Complexity : O(N), Recursion stack space.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate:\\n    double power(double x, int n){\\n        if(n==0){\\n            return 1;\\n        }\\n        return x * power(x, n-1);\\n    }\\npublic:\\n    double myPow(double x, int n) {\\n        if (n == INT_MAX) return (x == 1) ? 1 : (x == -1) ? -1 : 0;\\n        if (n == INT_MIN) return (x == 1 || x == -1) ? 1 : 0;\\n        double num = 1;\\n        if(n>=0){\\n            num = power(x, n);\\n        }\\n        else{\\n            n = -n;\\n            num = power(x, n);\\n            num = 1.0/num;\\n        }\\n        return num;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), because we loop until we multiply the base exponent times. Thus the time complexity\\n    is linear.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        if (n == INT_MAX) return (x == 1) ? 1 : (x == -1) ? -1 : 0;\\n        if (n == INT_MIN) return (x == 1 || x == -1) ? 1 : 0;\\n        double num = 1;\\n        if(n>=0){\\n            while(n>0){\\n                num *= x;\\n                n--;\\n            }\\n        }\\n        else{\\n            n = -n;\\n            while(n>0){\\n                num *= x;\\n                n--;\\n            }\\n            num = 1.0/num;\\n        }\\n        return num;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(logN).\\n\\n    Space Complexity : O(logN), Recursion stack space.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        if(n==0) return 1;\\n        if(n<0) {\\n            n = abs(n);\\n            x = 1/x;\\n        }\\n        if(n%2==0){\\n            return myPow(x*x, n/2);\\n        }\\n        else{\\n            return x*myPow(x, n-1);\\n        }\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(logN).\\n\\n    Space Complexity : O(1), Constant space.\\n\\n*/\\n\\n\\n/***************************************** Approach 4 *****************************************/\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double num = 1;\\n        long long nn = n;\\n        if(nn < 0) nn = -nn;\\n        while(nn>0){\\n            if(nn%2==1){\\n                num = num * x;\\n                nn--;\\n            }\\n            else{\\n                x = x*x;\\n                nn/=2;\\n            }\\n        }\\n        if(n < 0){\\n            num = 1.0/num;\\n        }\\n        return num;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(logN).\\n\\n    Space Complexity : O(logN), Constant space.\\n\\n*/\\n\\n\\n/***************************************** Approach 5 *****************************************/\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        return pow(x, n);\\n    }\\n};\\n\\n\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N), because we call the recurtion until we multiply the base exponent times. Thus the\\n    time complexity is linear.\\n\\n    Space Complexity : O(N), Recursion stack space.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate:\\n    double power(double x, int n){\\n        if(n==0){\\n            return 1;\\n        }\\n        return x * power(x, n-1);\\n    }\\npublic:\\n    double myPow(double x, int n) {\\n        if (n == INT_MAX) return (x == 1) ? 1 : (x == -1) ? -1 : 0;\\n        if (n == INT_MIN) return (x == 1 || x == -1) ? 1 : 0;\\n        double num = 1;\\n        if(n>=0){\\n            num = power(x, n);\\n        }\\n        else{\\n            n = -n;\\n            num = power(x, n);\\n            num = 1.0/num;\\n        }\\n        return num;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), because we loop until we multiply the base exponent times. Thus the time complexity\\n    is linear.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        if (n == INT_MAX) return (x == 1) ? 1 : (x == -1) ? -1 : 0;\\n        if (n == INT_MIN) return (x == 1 || x == -1) ? 1 : 0;\\n        double num = 1;\\n        if(n>=0){\\n            while(n>0){\\n                num *= x;\\n                n--;\\n            }\\n        }\\n        else{\\n            n = -n;\\n            while(n>0){\\n                num *= x;\\n                n--;\\n            }\\n            num = 1.0/num;\\n        }\\n        return num;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(logN).\\n\\n    Space Complexity : O(logN), Recursion stack space.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        if(n==0) return 1;\\n        if(n<0) {\\n            n = abs(n);\\n            x = 1/x;\\n        }\\n        if(n%2==0){\\n            return myPow(x*x, n/2);\\n        }\\n        else{\\n            return x*myPow(x, n-1);\\n        }\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(logN).\\n\\n    Space Complexity : O(1), Constant space.\\n\\n*/\\n\\n\\n/***************************************** Approach 4 *****************************************/\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double num = 1;\\n        long long nn = n;\\n        if(nn < 0) nn = -nn;\\n        while(nn>0){\\n            if(nn%2==1){\\n                num = num * x;\\n                nn--;\\n            }\\n            else{\\n                x = x*x;\\n                nn/=2;\\n            }\\n        }\\n        if(n < 0){\\n            num = 1.0/num;\\n        }\\n        return num;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(logN).\\n\\n    Space Complexity : O(logN), Constant space.\\n\\n*/\\n\\n\\n/***************************************** Approach 5 *****************************************/\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        return pow(x, n);\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 749109,
                "title": "python-recursive-solution-faster-than-99",
                "content": "![image](https://assets.leetcode.com/users/images/5f84e242-69cb-4dc4-97ef-f492465f46f3_1595418237.69286.png)\\n```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n\\n        def function(base=x, exponent=abs(n)):\\n            if exponent == 0:\\n                return 1\\n            elif exponent % 2 == 0:\\n                return function(base * base, exponent // 2)\\n            else:\\n                return base * function(base * base, (exponent - 1) // 2)\\n\\n        f = function()\\n        \\n        return float(f) if n >= 0 else 1/f\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n\\n        def function(base=x, exponent=abs(n)):\\n            if exponent == 0:\\n                return 1\\n            elif exponent % 2 == 0:\\n                return function(base * base, exponent // 2)\\n            else:\\n                return base * function(base * base, (exponent - 1) // 2)\\n\\n        f = function()\\n        \\n        return float(f) if n >= 0 else 1/f\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693787,
                "title": "pow-x-n-using-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        }\\n        if (n < 0) { \\n            n = abs(n);\\n            x = 1/x;\\n        }\\n        if(n%2==0){\\n            return myPow(x*x,n/2);\\n        \\n        }else{\\n            return x*myPow(x*x,n/2);\\n        }\\n    }\\n};\\n```\\nTC - O(log n)\\n\\nIf you like the code, do give it a upvote\\u270C\\uFE0F",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        }\\n        if (n < 0) { \\n            n = abs(n);\\n            x = 1/x;\\n        }\\n        if(n%2==0){\\n            return myPow(x*x,n/2);\\n        \\n        }else{\\n            return x*myPow(x*x,n/2);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19578,
                "title": "non-recursive-c-log-n-solution",
                "content": "```\\nclass Solution {\\n    public:\\n        double myPow(double x, int n) {\\n        \\tdouble ans = 1;\\n        \\tunsigned long long p;\\n        \\tif (n < 0) {\\n        \\t\\tp = -n;\\n        \\t\\tx = 1 / x;\\n        \\t} else {\\n        \\t\\tp = n;\\n        \\t}\\n    \\t\\twhile (p) {\\n    \\t\\t\\tif (p & 1)\\n    \\t\\t\\t\\tans *= x;\\n    \\t\\t\\tx *= x;\\n    \\t\\t\\tp >>= 1;\\n    \\t\\t}\\n    \\t\\treturn ans;\\n        }\\n    };\\n```\\n\\t\\nUpdate:\\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        if (n == std::numeric_limits<int>::lowest()) {\\n            return myPow(1 / x, -(n + 1)) / x;\\n        }\\n        if (n < 0) {\\n            return myPow(1 / x, -n);\\n        }\\n    \\tdouble ans = 1;\\n\\t\\twhile (n) {\\n\\t\\t\\tif (n & 1 == 1) ans *= x;\\n\\t\\t\\tx *= x;\\n\\t\\t\\tn >>= 1;\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public:\\n        double myPow(double x, int n) {\\n        \\tdouble ans = 1;\\n        \\tunsigned long long p;\\n        \\tif (n < 0) {\\n        \\t\\tp = -n;\\n        \\t\\tx = 1 / x;\\n        \\t} else {\\n        \\t\\tp = n;\\n        \\t}\\n    \\t\\twhile (p) {\\n    \\t\\t\\tif (p & 1)\\n    \\t\\t\\t\\tans *= x;\\n    \\t\\t\\tx *= x;\\n    \\t\\t\\tp >>= 1;\\n    \\t\\t}\\n    \\t\\treturn ans;\\n        }\\n    };\\n```\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        if (n == std::numeric_limits<int>::lowest()) {\\n            return myPow(1 / x, -(n + 1)) / x;\\n        }\\n        if (n < 0) {\\n            return myPow(1 / x, -n);\\n        }\\n    \\tdouble ans = 1;\\n\\t\\twhile (n) {\\n\\t\\t\\tif (n & 1 == 1) ans *= x;\\n\\t\\t\\tx *= x;\\n\\t\\t\\tn >>= 1;\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19593,
                "title": "o-logn-solution-in-java",
                "content": "/* This is a simple solution based on divide and conquer */   \\n\\n     public class Solution {\\n            public double pow(double x, int m) {\\n                double temp=x;\\n                if(m==0)\\n                return 1;\\n                temp=pow(x,m/2);\\n                if(m%2==0)\\n                return temp*temp;\\n                else \\n                {\\n                if(m > 0)\\n                    return x*temp*temp;\\n                else\\n                    return (temp*temp)/x;\\n                }\\n              \\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n            public double pow(double x, int m) {\\n                double temp=x;\\n                if(m==0)\\n                return 1;\\n                temp=pow(x,m/2);\\n                if(m%2==0)\\n                return temp*temp;\\n                else \\n                {\\n                if(m > 0)\\n                    return x*temp*temp;\\n                else\\n                    return (temp*temp)/x;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3438698,
                "title": "simplest-and-fastest-java-recursive-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(log n)\\n\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/bc5dd774-6503-4448-b923-0ee6fa3e3420_1682009445.0235534.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        \\n        // Base condition: If n is 0, x^0 is 1\\n        if (n == 0) {\\n            return 1;\\n        }\\n\\n        // Convert n to a long integer to handle the edge case with Integer.MIN_VALUE\\n        long N = n;\\n\\n        // If n is negative, take the reciprocal of x and make N positive\\n        if (N < 0) {\\n            N = -N;\\n            x = 1 / x;\\n        }\\n\\n        // If N is even, recursively compute the square of x^(N/2)\\n        if (N % 2 == 0) {\\n            return myPow(x * x, (int) (N / 2));\\n        } \\n    \\n        // If N is odd, recursively compute x^(N-1) and multiply it by x\\n        else {\\n            return x * myPow(x, (int) (N - 1));\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        \\n        // Base condition: If n is 0, x^0 is 1\\n        if (n == 0) {\\n            return 1;\\n        }\\n\\n        // Convert n to a long integer to handle the edge case with Integer.MIN_VALUE\\n        long N = n;\\n\\n        // If n is negative, take the reciprocal of x and make N positive\\n        if (N < 0) {\\n            N = -N;\\n            x = 1 / x;\\n        }\\n\\n        // If N is even, recursively compute the square of x^(N/2)\\n        if (N % 2 == 0) {\\n            return myPow(x * x, (int) (N / 2));\\n        } \\n    \\n        // If N is odd, recursively compute x^(N-1) and multiply it by x\\n        else {\\n            return x * myPow(x, (int) (N - 1));\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 313640,
                "title": "javascript-recursion",
                "content": "```\\n/**\\n * @param {number} x\\n * @param {number} n\\n * @return {number}\\n */\\nvar myPow = function(x, n) {\\n    if (n===0) return 1;\\n    \\n    let pow = Math.abs(n);\\n    \\n\\tlet result = pow%2===0 ? myPow(x*x,pow/2) : myPow(x*x,(pow-1)/2) * x;\\n    \\n    return n < 0 ? 1/result : result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number} x\\n * @param {number} n\\n * @return {number}\\n */\\nvar myPow = function(x, n) {\\n    if (n===0) return 1;\\n    \\n    let pow = Math.abs(n);\\n    \\n\\tlet result = pow%2===0 ? myPow(x*x,pow/2) : myPow(x*x,(pow-1)/2) * x;\\n    \\n    return n < 0 ? 1/result : result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 19608,
                "title": "8-lines-of-c-7-ms",
                "content": "       double pow(double x, int n) {\\n            if (n==0) return 1;\\n            double t = pow(x,n/2);\\n            if (n%2) {\\n                return n<0 ? 1/x*t*t : x*t*t;\\n            } else {\\n                return t*t;\\n            }\\n        }",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "       double pow(double x, int n) {\\n            if (n==0) return 1;\\n            double t = pow(x,n/2);\\n            if (n%2) {\\n                return n<0 ? 1/x*t*t : x*t*t;\\n            } else {\\n                return t*t;\\n            }\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3478674,
                "title": "beats-100-full-explanation-super-easy",
                "content": "# Intuition\\nThis problem can be easily solved using **Binary Exponentiation**.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nInitialize ans as 1.0  and store a duplicate copy of n i.e nn using to avoid overflow\\n\\nCheck if nn is a negative number, in that case, make it a positive number.\\n\\nKeep on iterating until nn is greater than zero, now if nn is an odd power then multiply x with ans ans reduce nn by 1. Else multiply x with itself and divide nn by two.\\n\\nNow after the entire binary exponentiation is complete and nn becomes zero, check if n is a negative value we know the answer will be 1 by and.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        double ans=1.0;\\n        long nn=n;\\n        if(nn<0) nn=-1*nn;\\n        while(nn>0){\\n            if(nn%2==1){\\n                ans = ans *x;\\n                nn=nn-1;\\n            }\\n            else{\\n                x=x*x;\\n                nn=nn/2;\\n            }\\n        }\\n        if(n<0)\\n        ans = (double)(1.0)/(double)(ans);\\n        return ans;\\n    }\\n}\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/f124cf1d-e7d1-40eb-93be-5faf89e6c54a_1683047510.624389.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        double ans=1.0;\\n        long nn=n;\\n        if(nn<0) nn=-1*nn;\\n        while(nn>0){\\n            if(nn%2==1){\\n                ans = ans *x;\\n                nn=nn-1;\\n            }\\n            else{\\n                x=x*x;\\n                nn=nn/2;\\n            }\\n        }\\n        if(n<0)\\n        ans = (double)(1.0)/(double)(ans);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515322,
                "title": "java-tc-o-logn-optimized-recursive-iterative-handles-overflow-solutions",
                "content": "**Recursive Solution 1 - Reducing N by half**\\n\\n```java\\n/**\\n * Reduce N by half in every recursion\\n *\\n * Time Complexity: O(log N)\\n *\\n * Space Complexity: O(log N) - Space required by recursion stack.\\n *\\n * N = Input number n.\\n */\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n        if (x == 0 || x == 1 || n == 1) {\\n            return x;\\n        }\\n        if (n < 0) {\\n            /**\\n             * -(n + 1) is done to avoid int overflow.\\n             */\\n            return (1 / x) * myPow(1 / x, -(n + 1));\\n        }\\n        return n % 2 == 0 ? myPow(x * x, n / 2) : x * myPow(x * x, n / 2);\\n    }\\n}\\n```\\n\\n---\\n**Recursive Solution 2 - Reducing N by half**\\n\\n```java\\n/**\\n * Reduce N by half in every recursion\\n *\\n * Time Complexity: O(log N)\\n *\\n * Space Complexity: O(log N) - Space required by recursion stack.\\n *\\n * N = Input number n.\\n */\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n        if (x == 0 || x == 1 || n == 1) {\\n            return x;\\n        }\\n\\n        double num = myPow(x, n / 2);\\n\\n        if (n % 2 == 0) {\\n            return num * num;\\n        } else {\\n            if (n < 0) {\\n                return num * num / x;\\n            } else {\\n                return num * num * x;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n---\\n**Iterative Solution - Reducing N by half**\\n\\n```java\\n/**\\n * Reduce N by half in every iteration.\\n *\\n * Time Complexity: O(log N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Input number n.\\n */\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n        if (x == 0 || x == 1 || n == 1) {\\n            return x;\\n        }\\n\\n        double result = 1;\\n        if (n < 0) {\\n            x = 1 / x;\\n            /**\\n             * -(n + 1) is done to avoid int overflow.\\n             */\\n            n = -(n + 1);\\n            result *= x;\\n        }\\n        while (n > 0) {\\n            if (n % 2 == 1) {\\n                result *= x;\\n                n--;\\n            }\\n            x *= x;\\n            n /= 2;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```java\\n/**\\n * Reduce N by half in every recursion\\n *\\n * Time Complexity: O(log N)\\n *\\n * Space Complexity: O(log N) - Space required by recursion stack.\\n *\\n * N = Input number n.\\n */\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n        if (x == 0 || x == 1 || n == 1) {\\n            return x;\\n        }\\n        if (n < 0) {\\n            /**\\n             * -(n + 1) is done to avoid int overflow.\\n             */\\n            return (1 / x) * myPow(1 / x, -(n + 1));\\n        }\\n        return n % 2 == 0 ? myPow(x * x, n / 2) : x * myPow(x * x, n / 2);\\n    }\\n}\\n```\n```java\\n/**\\n * Reduce N by half in every recursion\\n *\\n * Time Complexity: O(log N)\\n *\\n * Space Complexity: O(log N) - Space required by recursion stack.\\n *\\n * N = Input number n.\\n */\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n        if (x == 0 || x == 1 || n == 1) {\\n            return x;\\n        }\\n\\n        double num = myPow(x, n / 2);\\n\\n        if (n % 2 == 0) {\\n            return num * num;\\n        } else {\\n            if (n < 0) {\\n                return num * num / x;\\n            } else {\\n                return num * num * x;\\n            }\\n        }\\n    }\\n}\\n```\n```java\\n/**\\n * Reduce N by half in every iteration.\\n *\\n * Time Complexity: O(log N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Input number n.\\n */\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n        if (x == 0 || x == 1 || n == 1) {\\n            return x;\\n        }\\n\\n        double result = 1;\\n        if (n < 0) {\\n            x = 1 / x;\\n            /**\\n             * -(n + 1) is done to avoid int overflow.\\n             */\\n            n = -(n + 1);\\n            result *= x;\\n        }\\n        while (n > 0) {\\n            if (n % 2 == 1) {\\n                result *= x;\\n                n--;\\n            }\\n            x *= x;\\n            n /= 2;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807721,
                "title": "2-optimised-method-bit-recursion-video-explanation-faster-log-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe key intuition behind this implementation is to reduce the number of recursive calls and avoid redundant calculations by dividing the problem into smaller subproblems. By using the \"exponentiation by squaring\" technique, the function efficiently computes the power of `x` to `n` in logarithmic time complexity.\\n\\nThis implementation is quite efficient, making it suitable for calculating large powers of numbers without causing a stack overflow due to excessive recursion\\n\\nFor detailed explanation you can refer to my youtube channel (hindi Language)\\nhttps://youtu.be/mosNm5bl8Ts\\n or link in my profile.Here,you can find any solution in playlists monthwise from June 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation (5-10) minutes.\\n\\n# Approach\\nThe given code implements a function `myPow` to calculate the power of a given number `x` raised to the integer `n`. The implementation uses a recursive approach called \"exponentiation by squaring\" to efficiently compute the result in O(log n) time complexity.\\n\\nApproach:\\n1. The `myPow` function takes two parameters: `x` (the base) and `n` (the exponent).\\n2. Inside `myPow`, it calls the `solve` function, passing `x` and the absolute value of `n`.\\n3. The `solve` function recursively calculates the power of `x` raised to `n`, using the following steps:\\n   a. If `n` is 0, it returns 1 since any number raised to the power of 0 is 1.\\n   b. Otherwise, it calculates `temp`, which is the result of `myPow(x, n/2)`. This is done to reduce redundant calculations and improve the efficiency.\\n   c. It squares `temp` to handle even exponents (`n%2==0`). If the exponent is odd, it multiplies `temp` by `x`.\\n   d. The function then returns the calculated result.\\n\\n# Complexity\\n- Time complexity:$$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(logn)$$(Recursion stack)\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n double solve(double x,int n){\\n          if(n==0){\\n            return 1; //power of 0 is 1;\\n        }\\n       double temp=myPow(x,n/2);\\n        temp=temp*temp;\\n        if(n%2==0){ // if even  return  just without doing nothing\\n            return temp;\\n        }\\n        else{\\n            return temp*x;//if odd multiple  return by multipling once more with given number\\n        }\\n    }\\n    double myPow(double x, int n) {\\n        double ans=solve(x,abs(n));\\n        if(n<0)\\n            return 1/ans;\\n            return ans;\\n       \\n    }\\n};\\n```\\n```java []\\npublic class Solution {\\n    public double solve(double x, long n) {\\n        if (n == 0) {\\n            return 1; // power of 0 is 1\\n        }\\n        double temp = solve(x, n / 2);\\n        temp = temp * temp;\\n\\n        if (n % 2 == 0) { // if even, return just without doing anything\\n            return temp;\\n        } else {\\n            return temp * x; // if odd, return by multiplying once more with the given number\\n        }\\n    }\\n\\n    public double myPow(double x, int n) {\\n        long longN = n; // Convert n to a long to handle Integer.MIN_VALUE\\n        double ans = solve(x, Math.abs(longN));\\n\\n        if (longN < 0) {\\n            return 1 / ans;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution:\\n    def solve(self, x, n):\\n        if n == 0:\\n            return 1  # power of 0 is 1\\n        \\n        temp = self.myPow(x, n // 2)\\n        temp = temp * temp\\n        \\n        if n % 2 == 0:  # if even, return just without doing anything\\n            return temp\\n        else:\\n            return temp * x  # if odd, return by multiplying once more with given number\\n    \\n    def myPow(self, x, n):\\n        ans = self.solve(x, abs(n))\\n        \\n        if n < 0:\\n            return 1 / ans\\n        return ans\\n\\n```\\n\\n# Code 2\\n```C++ []\\nclass Solution {\\npublic:\\n//i am passing long long here because the value `-2147483648` after abs will cause overflow because int can store max `-2147483647`.so type casting.\\n    double solve(double x,long long n){\\n        double ans=1;\\n        while(n>0){\\n            int c=n&1;//checking if it is odd then we will multiply  one   extra value of x\\n            for odd value adding extra x \\n            if(c==1){\\n             ans=ans*x;\\n            }\\n           x=x*x;\\n           n=n>>1;\\n        }\\n        return ans;\\n    }\\n    double myPow(double x, int n) {\\n         if(x == 1) return 1;\\n         // -2147483648\\n         double ans=solve(x,abs(n));\\n        if(n<0)\\n            return 1/ans;\\n            cout<<INT_MAX;\\n            return ans;\\n    }\\n};\\n```\\n```java []\\npublic class Solution {\\n    public double solve(double x, long n) {\\n        double ans = 1;\\n        while (n > 0) {\\n            if ((n & 1) == 1) { // checking if it is odd then we will multiply one extra value of x\\n                ans *= x;\\n            }\\n            x *= x;\\n            n >>= 1;\\n        }\\n        return ans;\\n    }\\n\\n    public double myPow(double x, int n) {\\n        if (x == 1) return 1;\\n        long longN = n;\\n        double ans = solve(x, Math.abs(longN));\\n        if (longN < 0)\\n            return 1 / ans;\\n        return ans;\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution:\\n    def solve(self, x, n):\\n        ans = 1\\n        while n > 0:\\n            if n & 1:  # checking if it is odd then we will multiply one extra value of x\\n                ans *= x\\n            x *= x\\n            n >>= 1\\n        return ans\\n    \\n    def myPow(self, x, n):\\n        if x == 1:\\n            return 1\\n        long_n = abs(n)\\n        ans = self.solve(x, long_n)\\n        if n < 0:\\n            return 1 / ans\\n        return ans\\n\\n    def main(self):\\n        x = 2.00000\\n        n = -2147483648\\n        print(self.myPow(x, n))  # Output: 0.0\\n\\nif __name__ == \"__main__\":\\n    solution = Solution()\\n    solution.main()\\n\\n```\\n\\n# Complexity\\n- Time complexity:$$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n double solve(double x,int n){\\n          if(n==0){\\n            return 1; //power of 0 is 1;\\n        }\\n       double temp=myPow(x,n/2);\\n        temp=temp*temp;\\n        if(n%2==0){ // if even  return  just without doing nothing\\n            return temp;\\n        }\\n        else{\\n            return temp*x;//if odd multiple  return by multipling once more with given number\\n        }\\n    }\\n    double myPow(double x, int n) {\\n        double ans=solve(x,abs(n));\\n        if(n<0)\\n            return 1/ans;\\n            return ans;\\n       \\n    }\\n};\\n```\n```java []\\npublic class Solution {\\n    public double solve(double x, long n) {\\n        if (n == 0) {\\n            return 1; // power of 0 is 1\\n        }\\n        double temp = solve(x, n / 2);\\n        temp = temp * temp;\\n\\n        if (n % 2 == 0) { // if even, return just without doing anything\\n            return temp;\\n        } else {\\n            return temp * x; // if odd, return by multiplying once more with the given number\\n        }\\n    }\\n\\n    public double myPow(double x, int n) {\\n        long longN = n; // Convert n to a long to handle Integer.MIN_VALUE\\n        double ans = solve(x, Math.abs(longN));\\n\\n        if (longN < 0) {\\n            return 1 / ans;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n```python []\\nclass Solution:\\n    def solve(self, x, n):\\n        if n == 0:\\n            return 1  # power of 0 is 1\\n        \\n        temp = self.myPow(x, n // 2)\\n        temp = temp * temp\\n        \\n        if n % 2 == 0:  # if even, return just without doing anything\\n            return temp\\n        else:\\n            return temp * x  # if odd, return by multiplying once more with given number\\n    \\n    def myPow(self, x, n):\\n        ans = self.solve(x, abs(n))\\n        \\n        if n < 0:\\n            return 1 / ans\\n        return ans\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n//i am passing long long here because the value `-2147483648` after abs will cause overflow because int can store max `-2147483647`.so type casting.\\n    double solve(double x,long long n){\\n        double ans=1;\\n        while(n>0){\\n            int c=n&1;//checking if it is odd then we will multiply  one   extra value of x\\n            for odd value adding extra x \\n            if(c==1){\\n             ans=ans*x;\\n            }\\n           x=x*x;\\n           n=n>>1;\\n        }\\n        return ans;\\n    }\\n    double myPow(double x, int n) {\\n         if(x == 1) return 1;\\n         // -2147483648\\n         double ans=solve(x,abs(n));\\n        if(n<0)\\n            return 1/ans;\\n            cout<<INT_MAX;\\n            return ans;\\n    }\\n};\\n```\n```java []\\npublic class Solution {\\n    public double solve(double x, long n) {\\n        double ans = 1;\\n        while (n > 0) {\\n            if ((n & 1) == 1) { // checking if it is odd then we will multiply one extra value of x\\n                ans *= x;\\n            }\\n            x *= x;\\n            n >>= 1;\\n        }\\n        return ans;\\n    }\\n\\n    public double myPow(double x, int n) {\\n        if (x == 1) return 1;\\n        long longN = n;\\n        double ans = solve(x, Math.abs(longN));\\n        if (longN < 0)\\n            return 1 / ans;\\n        return ans;\\n    }\\n}\\n\\n```\n```python []\\nclass Solution:\\n    def solve(self, x, n):\\n        ans = 1\\n        while n > 0:\\n            if n & 1:  # checking if it is odd then we will multiply one extra value of x\\n                ans *= x\\n            x *= x\\n            n >>= 1\\n        return ans\\n    \\n    def myPow(self, x, n):\\n        if x == 1:\\n            return 1\\n        long_n = abs(n)\\n        ans = self.solve(x, long_n)\\n        if n < 0:\\n            return 1 / ans\\n        return ans\\n\\n    def main(self):\\n        x = 2.00000\\n        n = -2147483648\\n        print(self.myPow(x, n))  # Output: 0.0\\n\\nif __name__ == \"__main__\":\\n    solution = Solution()\\n    solution.main()\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2541248,
                "title": "java-recursion",
                "content": "### **Please Upvote** :D\\n``` java []\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        if (n == 0) \\n            return 1.0;\\n\\n        if (n % 2 == 1) \\n            return x * myPow(x, n - 1);\\n\\n        if (n % 2 == 0) \\n            return myPow(x * x, n / 2);\\n\\n        return 1 / myPow(x, -n);\\n    }\\n}\\n\\n// TC: O(logn), SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "``` java []\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        if (n == 0) \\n            return 1.0;\\n\\n        if (n % 2 == 1) \\n            return x * myPow(x, n - 1);\\n\\n        if (n % 2 == 0) \\n            return myPow(x * x, n / 2);\\n\\n        return 1 / myPow(x, -n);\\n    }\\n}\\n\\n// TC: O(logn), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356015,
                "title": "swift-pow-x-n-test-cases",
                "content": "```swift\\nclass Solution {\\n    func myPow(_ x: Double, _ n: Int) -> Double {\\n        var x = x, n = n, res = 1.0\\n        \\n        if n < 0 { x = 1.0/x ; n = -n }\\n        \\n        while n > 0 {\\n            if n % 2 != 0 { res *= x }\\n            x *= x\\n            n /= 2\\n        }\\n        return res\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 3 tests, with 0 failures (0 unexpected) in 0.005 (0.007) seconds\\n\\nclass Tests: XCTestCase {\\n    let s = Solution()\\n    func test0() {\\n        let res = s.myPow(2.00000, 10)\\n        XCTAssertEqual(res, 1024)\\n    }\\n    func test1() {\\n        let res = s.myPow(2.10000, 3)\\n        XCTAssertEqual(res, 9.261000000000001)\\n    }\\n    func test2() {\\n        let res = s.myPow(2.00000, -2)\\n        XCTAssertEqual(res, 0.25)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func myPow(_ x: Double, _ n: Int) -> Double {\\n        var x = x, n = n, res = 1.0\\n        \\n        if n < 0 { x = 1.0/x ; n = -n }\\n        \\n        while n > 0 {\\n            if n % 2 != 0 { res *= x }\\n            x *= x\\n            n /= 2\\n        }\\n        return res\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 3 tests, with 0 failures (0 unexpected) in 0.005 (0.007) seconds\\n\\nclass Tests: XCTestCase {\\n    let s = Solution()\\n    func test0() {\\n        let res = s.myPow(2.00000, 10)\\n        XCTAssertEqual(res, 1024)\\n    }\\n    func test1() {\\n        let res = s.myPow(2.10000, 3)\\n        XCTAssertEqual(res, 9.261000000000001)\\n    }\\n    func test2() {\\n        let res = s.myPow(2.00000, -2)\\n        XCTAssertEqual(res, 0.25)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735170,
                "title": "python3-solution-with-a-detailed-explanation",
                "content": "We should implement `pow`, right? What happens when you do a number to the power of sth? It\\'s two cases, the power is either positive, zero, or negative. If it\\'s zero, the result is 1 regardless. Right? If it\\'s positive, you multiply your number  the power times, and if it\\'s negative, you (let\\'s say your number is x) multiply 1/x the power times. That\\'s exactly what we\\'re going to do. The code has two parts, main function (`myPow`) and `helper`, both accepting the same input variabes. Let\\'s focus on the first function, `myPow`. \\n\\nIt\\'s doing the above. If the is `>= 0`, call the `helper` function with `x` and `n` as input (line `#1`). Otherwise, call the inverse of it with `x` and `-n` as input (line `#2`). For the last case, imagine you want to do `2^(-3)`. How will you do it normally? `1/(2^3)`, right? That\\'s all. \\n\\n```\\n# First part\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n >= 0:\\n            return self.helper(x, n) #1\\n        else:\\n            return 1/self.helper(x, -n) #2\\n    \\n    \\n# Second part\\n    \\n    def helper(self, x, n): \\n        if n == 0: #3\\n            return 1\\n        \\n        temp = self.myPow(x, n//2) #4\\n         \\n        if int(n%2) == 0: #5\\n            return  temp * temp\\n        else:\\n            return temp * temp * x #6\\n```\\n\\nNow, let\\'s focus on the second part.  Line `#3` takes care of the base case when `n` is zero. Then we calculate the `temp` for the case that `n = n/2`. This way, we break down the problem into two problems, each with the same solution. So, we just need to calculate it once. If `n` is divisible by 2, then we multiply `temp` by itself (line `#5`) and if it\\'s not, we multiply the product by an additional `x` (line `#6`). \\n\\nThat\\'s all.\\n\\n\\n============================================================\\nFinal note: Please let me know if you found any error/typo/etc. I\\'ll try to fix it. \\n\\nFinal note 2: I\\'ve found explaining stuff in a simple way (at least I think it\\'s simple) would be instructive for myself. I\\'d suggest you do the same in case you\\'re having hard time understanding something. Thanks for reading.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# First part\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n >= 0:\\n            return self.helper(x, n) #1\\n        else:\\n            return 1/self.helper(x, -n) #2\\n    \\n    \\n# Second part\\n    \\n    def helper(self, x, n): \\n        if n == 0: #3\\n            return 1\\n        \\n        temp = self.myPow(x, n//2) #4\\n         \\n        if int(n%2) == 0: #5\\n            return  temp * temp\\n        else:\\n            return temp * temp * x #6\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341862,
                "title": "python-2-fast-pow-solutions-follow-up-find-nth-root-of-a-number",
                "content": "**Solution 1: Jump double step**\\n```python\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n == 0: return 1\\n        if n < 0:\\n            x = 1 / x\\n            n = -n\\n        step = 1\\n        ans = x\\n        while step * 2 <= n:\\n            ans *= ans\\n            step *= 2\\n        return ans * self.myPow(x, n - step)\\n```\\nComplexity:\\n- Time: `O(logN)`\\n- Space: `O(1)`\\n\\n---\\n\\n**Solution 2: Half pow**\\n```python\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n == 0: return 1\\n        if n < 0: return self.myPow(1/x, -n)\\n        half = self.myPow(x, n // 2)\\n        if n & 1:  # if n is an odd number\\n            return half * half * x\\n        return half * half\\n```\\nComplexity:\\n- Time: `O(logN)`\\n- Space: `O(1)`\\n\\n---\\n\\n**Follow-up Question: Find nth root of a number**\\nProblem statement:\\n> Many times, we need to re-implement basic functions without using any standard library functions already implemented. For example, when designing a chip that requires very little memory space.\\n> \\n> In this question we\\u2019ll implement a function root that calculates the n\\u2019th root of a number. The function takes a nonnegative number `x` and a positive integer `n`, and returns the positive `n\\u2019th` root of `x` within an error of 0.001 (i.e. suppose the real root is `y`, then the error is: `|y-root(x,n)|` and must satisfy `|y-root(x,n)| < 0.001)`.\\n> \\n> **Examples:** \\n> input:  x = 7, n = 3\\n> output: 1.913\\n> \\n> input:  x = 9, n = 2\\n> output: 3\\n\\n<iframe src=\"https://leetcode.com/playground/DWT2qBnY/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>\\n\\nComplexity:\\n- Time: `O(logX * logN)`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n == 0: return 1\\n        if n < 0:\\n            x = 1 / x\\n            n = -n\\n        step = 1\\n        ans = x\\n        while step * 2 <= n:\\n            ans *= ans\\n            step *= 2\\n        return ans * self.myPow(x, n - step)\\n```\n```python\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n == 0: return 1\\n        if n < 0: return self.myPow(1/x, -n)\\n        half = self.myPow(x, n // 2)\\n        if n & 1:  # if n is an odd number\\n            return half * half * x\\n        return half * half\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19566,
                "title": "iterative-java-python-short-solution-o-log-n",
                "content": "**Java**\\n\\n    public double myPow(double x, int n) {\\n        long m = n > 0 ? n : -(long)n;\\n        double ans = 1.0;\\n        while (m != 0) {\\n            if ((m & 1) == 1)\\n                ans *= x;\\n            x *= x;\\n            m >>= 1;\\n        }\\n        return n >= 0 ? ans : 1 / ans;\\n    }\\n    //299 / 299 test cases passed.\\n    //Status: Accepted\\n    //Runtime: 1 ms\\n\\n**Python**\\n\\n    def myPow(self, x, n):\\n        m = abs(n)\\n        ans = 1.0\\n        while m:\\n            if m & 1:\\n                ans *= x\\n            x *= x\\n            m >>= 1\\n        return ans if n >= 0 else 1 / ans\\n\\n\\n    # 299 / 299 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 44 ms",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "**Java**\\n\\n    public double myPow(double x, int n) {\\n        long m = n > 0 ? n : -(long)n;\\n        double ans = 1.0;\\n        while (m != 0) {\\n            if ((m & 1) == 1)\\n                ans *= x;\\n            x *= x;\\n            m >>= 1;\\n        }\\n        return n >= 0 ? ans : 1 / ans;\\n    }\\n    //299 / 299 test cases passed.\\n    //Status: Accepted\\n    //Runtime: 1 ms\\n\\n**Python**\\n\\n    def myPow(self, x, n):\\n        m = abs(n)\\n        ans = 1.0\\n        while m:\\n            if m & 1:\\n                ans *= x\\n            x *= x\\n            m >>= 1\\n        return ans if n >= 0 else 1 / ans\\n\\n\\n    # 299 / 299 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 44 ms",
                "codeTag": "Python3"
            },
            {
                "id": 19733,
                "title": "simple-iterative-lg-n-solution",
                "content": "The idea is similar to the recursive version.\\n\\n    double pow(double x, int n) {\\n        double d = 1.; int m = n;\\n        for (; n; x *= x, n /= 2) if (n % 2) d *= x;\\n        return m >= 0 ? d : 1. / d;\\n    }",
                "solutionTags": [],
                "code": "The idea is similar to the recursive version.\\n\\n    double pow(double x, int n) {\\n        double d = 1.; int m = n;\\n        for (; n; x *= x, n /= 2) if (n % 2) d *= x;\\n        return m >= 0 ? d : 1. / d;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 19709,
                "title": "c-4-lines-of-code",
                "content": "    double myPow(double x, int n) {\\n        if (n==0) return 1;\\n        if (n==1) return x;\\n        if (n==-1) return 1/x;\\n        return myPow(x*x,n/2)*(n%2==0?1:n>0?x:1/x);\\n    }",
                "solutionTags": [],
                "code": "    double myPow(double x, int n) {\\n        if (n==0) return 1;\\n        if (n==1) return x;\\n        if (n==-1) return 1/x;\\n        return myPow(x*x,n/2)*(n%2==0?1:n>0?x:1/x);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 19571,
                "title": "my-answer-using-bit-operation-c-implementation",
                "content": "    class Solution {\\n    public:\\n        double pow(double x, int n) {\\n        \\tif(n<0){\\n        \\t\\tx = 1.0/x;\\n        \\t\\tn = -n;\\n        \\t}\\n        \\tint unsigned m = n;\\n            double tbl[32] = {0};\\n            double result = 1;\\n            tbl[0] = x;\\n            for(int i=1;i<32;i++){\\n                tbl[i] = tbl[i-1]*tbl[i-1];\\n            }\\n            for(int i=0;i<32;i++){\\n                if( m & (0x1<<i) )\\n                result *= tbl[i];\\n            }\\n            return result;\\n        }\\n    };\\n\\n\\nIn bit format and for a unsigned number, the number is represented as `k0*2^0 + k1*2^1 + ... +k31*2^31`. Therefore, once we know the pow(x,2^0), pow(x,2^1), ..., pow(x,2^31), we can get pow(x,n). And pow(x,2^m) can be constructed easily as pow(x,2^m) = pow(x,2^(m-1)*pow(x,2^(m-1).",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        double pow(double x, int n) {\\n        \\tif(n<0){\\n        \\t\\tx = 1.0/x;\\n        \\t\\tn = -n;\\n        \\t}",
                "codeTag": "Java"
            },
            {
                "id": 290555,
                "title": "c-fast-100-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double res=1.0;\\n        for(int i=n;i;i/=2){\\n            if(i&1)res*=x;\\n            x*=x;\\n            \\n        }\\n        return n>=0?res:1/res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double res=1.0;\\n        for(int i=n;i;i/=2){\\n            if(i&1)res*=x;\\n            x*=x;\\n            \\n        }\\n        return n>=0?res:1/res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625042,
                "title": "java-c-simple-olog-n-easy-faster-than-100-explained",
                "content": "# **Please UPVOTE if you find this post helpful :)**\\n\\n<u>**Refer to the following github repsitory for more leetcode solutions**</u>\\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\\n\\n**APPROACHES:**\\n* <u>**First Approach**</u>\\n\\n\\tWe can solve this problem by multiplying x by n times\\n\\teg:\\n\\t`x = 7 and n = 11`\\n\\t**7 * 7 * 7 * 7 * 7 * 7 * 7 * 7 * 7 * 7 * 7 = 1977326743**\\n\\tHere we have **multiplied 7 for 11 times**, which will result in **O(n)**\\n\\tBut, Suppose `x = 1 and n = 2147483647`\\n\\tIf we follow this approach then, **1 will be multiplied 2147483647 times** which is not efficient at all.\\n\\n* <u>**Second Approach**</u>\\nIn order to improve efficiency we will opt for **Binary Exponentiation using which we can calculate x<sup>n</sup> using O log<sub>2</sub>(N) multiplications.**\\n\\n\\t**Basic Idea is to divide the work using binary representation of exponents**\\n\\ti.e. is to keep multiplying pow with x, if the bit is odd, and multiplying x with itself until we get 0\\n\\tWe will use very **1st example of 1st Approach** i.e.\\n\\t`x = 7, n = 11 and pow = 1`\\n\\tHere, we have to calculate 7<sup>11</sup>\\n\\t**Binary of n i.e. (11)<sub>10</sub> is (1011)<sub>2</sub>**\\n\\t**1 &nbsp; 0 &nbsp; 1 &nbsp; 1**\\n\\t2<sup>3 &nbsp;</sup>2<sup>2</sup>&nbsp; 2<sup>1</sup> &nbsp;2<sup>0</sup>&nbsp;&nbsp;  <-- Corresponding **place values** of each bit\\n\\n\\tOR we can also write this as\\n\\t**1  0  1  1**\\n\\t8 4 2 1  <-- Corresponding **place values** of each bit\\n\\n\\tNow, **7<sup>8</sup> &#215; 7<sup>2</sup> &#215; 7<sup>1</sup>** == **7<sup>11</sup>** as **7<sup>(8 + 2 + 1)</sup>** == **7<sup>11</sup>**\\n**NOTE:**  We have not considered **7<sup>4</sup>** in this case as the **4th place bit is OFF**\\n\\n\\tSo, **7<sup>8</sup> &#215; 7<sup>2</sup> &#215; 7<sup>1</sup>** == **5764801 &#215; 49 &#215; 7** == **1977326743** **<-- Desired Output**\\n\\tNow, applying logic keeping this concept in mind\\n\\n\\t```\\n\\tdouble pow = 1;\\n\\twhile(n != 0){\\n\\t\\tif((n & 1) != 0) // equivalent to if((n % 2) != 0) i.e. multiply only when the number is odd  \\n\\t\\tpow *= x;\\n\\n\\t\\tx *= x;\\n\\t\\tn >>>= 1; // equivalent to n = n / 2; i.e. keep dividing the number by 2\\n\\n\\t}\\n\\t```\\n*   **PROCESS**\\n\\t* \\t**Iteration 1**\\n\\tpow = <u>1 &#215; 7</u> = 7\\n\\tx = 7 \\xD7 7 = 49\\n\\tn = 11 >>> 1 = 5\\n\\n\\t* \\t**Iteration 2**\\n\\tpow = <u>7 \\xD7 49</u> = 343\\n\\tx = 49 \\xD7 49 = 2401\\n\\tn = 5 >>> 1 = 2\\n\\n\\t* \\t**Iteration 3**\\n\\tx = 2401 \\xD7 2401 = 5764801\\n\\tn = 2 >>> 1 = 1\\n\\n\\t* \\t**Iteration 4**\\n\\tpow = <u>343 \\xD7 5764801</u> = 1977326743\\n\\tx = 5764801 \\xD7 5764801 = 3.323293057 \\xD7 10\\xB9\\xB3\\n\\tn = 1 >>> 1 = 0\\n\\nWe exit the loop as the number has become 0 and we got pow as **1977326743 which is the desired output**\\nIn this binary exponentiation approach, the loop iterated for only 4 times which is nothing but (O log<sub>2</sub>(N) + 1) ~ **(O log<sub>2</sub>(N))**\\n\\nAnd for **2nd example of 1st Approach** where\\n`x = 1 and n = 2147483647`\\nThis loop executed for only 31 times **(O log<sub>2</sub>(N))** which is far far less than 2147483647 times(in case of O(N) approach)<br>\\n\\n<hr>\\n\\n<u>**JAVA / C++ CODE**</u>\\n\\n<iframe src=\"https://leetcode.com/playground/hRAZkbLc/shared\" frameBorder=\"0\" width=\"100%\" height=\"400\"></iframe>\\n\\n**COMPLEXITY:**\\n* **Time: O(log<sub>2</sub>(n))**, where `n` is the given power\\n* **Space: O(1),** in-place\\n\\n<img src = \"https://assets.leetcode.com/users/images/6f980162-6f32-4bfc-88e2-212a3d2d83cd_1645193689.9401023.jpeg\" width = \"100%\">\\n<br><br><br>\\n<img src = \"https://assets.leetcode.com/users/images/5e27a0db-88da-4bfa-830b-a9e18b37cc30_1645193695.887591.jpeg\" width = \"100%\">\\n<br><br>\\n\\n<u>**Refer to the following github repsitory for more leetcode solutions**</u>\\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\\n\\n# **Please UPVOTE if you find this post helpful :)**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\n\\tdouble pow = 1;\\n\\twhile(n != 0){\\n\\t\\tif((n & 1) != 0) // equivalent to if((n % 2) != 0) i.e. multiply only when the number is odd  \\n\\t\\tpow *= x;\\n\\n\\t\\tx *= x;\\n\\t\\tn >>>= 1; // equivalent to n = n / 2; i.e. keep dividing the number by 2\\n\\n\\t}\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1350210,
                "title": "c-brute-force-optimal-solution-time-o-logn-auxiliary-space-o-logn",
                "content": "**Brute Force Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n\\t\\t// Brute Force Solution Time O(N) & Auxiliary Space O(N)\\n        if(n==0)\\n            return 1;\\n        else if(n>0) \\n            return x*myPow(x,n-1); \\n        else\\n            return (1/x)*myPow(x,n+1); \\n    }\\n};\\n```\\n\\n**Optimal Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n\\t\\t// Optimal Solution Time O(logN) & Auxiliary Space O(logN)\\n        if(n==0) \\n\\t\\t\\treturn 1;\\n\\t\\t// Using Binary Exponentiation(Time O(logN))\\n\\t\\t// x^n=x^(n/2)*x^(n/2). So, recursive function is \\n\\t\\t// called logN times where y=x^(n/2) and function returns y*y\\n        double y = myPow(x,n/2);\\n        if(n%2==0)\\n            return y*y;\\n        else if(n < 0)\\n            return 1/x*y*y;\\n        else\\n            return x*y*y; \\n    }\\n};\\n```\\n**All suggestions are welcome. Please upvote if you like it. Thank you for reading the post.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n\\t\\t// Brute Force Solution Time O(N) & Auxiliary Space O(N)\\n        if(n==0)\\n            return 1;\\n        else if(n>0) \\n            return x*myPow(x,n-1); \\n        else\\n            return (1/x)*myPow(x,n+1); \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n\\t\\t// Optimal Solution Time O(logN) & Auxiliary Space O(logN)\\n        if(n==0) \\n\\t\\t\\treturn 1;\\n\\t\\t// Using Binary Exponentiation(Time O(logN))\\n\\t\\t// x^n=x^(n/2)*x^(n/2). So, recursive function is \\n\\t\\t// called logN times where y=x^(n/2) and function returns y*y\\n        double y = myPow(x,n/2);\\n        if(n%2==0)\\n            return y*y;\\n        else if(n < 0)\\n            return 1/x*y*y;\\n        else\\n            return x*y*y; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773206,
                "title": "java-simple-solution-runtime-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double myPow(double x, int n) {\\n      if (n == 0)\\n            return 1.0;\\n\\n            if (n == Integer.MIN_VALUE) \\n            {\\n                x = x * x;\\n                n = n / 2;\\n           }\\n\\n        if (n < 0) \\n        {\\n            x = 1 / x;\\n            n = -n;\\n        }\\n\\n        double result = 1.0;\\n        while (n > 0) \\n        {\\n            if (n % 2 == 1)\\n                result *= x;\\n\\n            x *= x;\\n            n /= 2;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n\\n\\n![e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg](https://assets.leetcode.com/users/images/18ff039e-d2d0-4d30-89be-0628a63fec66_1689505192.1650789.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double myPow(double x, int n) {\\n      if (n == 0)\\n            return 1.0;\\n\\n            if (n == Integer.MIN_VALUE) \\n            {\\n                x = x * x;\\n                n = n / 2;\\n           }\\n\\n        if (n < 0) \\n        {\\n            x = 1 / x;\\n            n = -n;\\n        }\\n\\n        double result = 1.0;\\n        while (n > 0) \\n        {\\n            if (n % 2 == 1)\\n                result *= x;\\n\\n            x *= x;\\n            n /= 2;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 915021,
                "title": "3-approach-for-your-interview-o-n-o-log-n-o-1",
                "content": "# <h4><strong> Approach 1: Brute Force O(n)  </strong></h4>\\n\\n```\\n\\tlet res= 1\\n    for(var i=0;i<b;i++){\\n\\t\\tres = res *a\\n\\t}\\n```\\n<hr> <hr><br> <br>\\n\\n# <h4><strong> Approach 2: Recursive approach O(logn)\\n```\\nvar myPow = function(a, b) {\\n    \\n  if(b==0)      return 1            // base case  \\n  else if(b==1) return a           // base case \\n  else if(b==-1)  return 1/a\\n  else if(b%2==0){\\n  \\t\\tlet t=myPow(a, b/2);\\n      return t*t\\n  }\\n  else if(b%2!=0){\\n  \\t\\treturn a*myPow(a,b-1)\\n  }\\n\\n};\\n\\n```\\nTry to dry run this, by recursion call stack \\n u\\'ll get it.\\n<hr><hr><br> <br>\\n <h4><strong> Approach 3: Using log properties O(1) </strong> </h4>\\n \\n\\n**step1:** primarily we are using `log properties`\\nie: \\n```\\nlet result = a(to the power b)\\nApplying log on both side, we get, \\nlog(res) = b*log(a)\\nres = exp(b*(log(a))\\n```\\n\\n\\n**step2**: problem arises, when a will be negative.\\nbecause log of negatives, isnt feasible\\nto handle that issue, \\ni\\'m first calculating` b*log(a)`\\nthen,` if b is odd`, then, multiply the result with` (-1)`\\nelse for `even` number of b\\'s, `return result`\\n\\n<br><br><hr><hr>\\n\\n```\\nvar myPow = function(a, b) {\\n    \\n    let flag = 0\\n\\t\\n\\t// checking if a is negative \\n    if(a<0) {\\n        a = Math.abs(a)\\n        if(b%2!=0) flag=1    \\n\\t\\tlet res =  Math.exp(  b*Math.log(a)  )\\n        return ( flag==1 ? res*-1 : res  )\\n    }\\n\\t\\n\\t\\n\\t\\n    // when a is not negative\\n    else return Math.exp(  (b)  *  Math.log(a)  )\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n\\tlet res= 1\\n    for(var i=0;i<b;i++){\\n\\t\\tres = res *a\\n\\t}\\n```\n```\\nvar myPow = function(a, b) {\\n    \\n  if(b==0)      return 1            // base case  \\n  else if(b==1) return a           // base case \\n  else if(b==-1)  return 1/a\\n  else if(b%2==0){\\n  \\t\\tlet t=myPow(a, b/2);\\n      return t*t\\n  }\\n  else if(b%2!=0){\\n  \\t\\treturn a*myPow(a,b-1)\\n  }\\n\\n};\\n\\n```\n```\\nlet result = a(to the power b)\\nApplying log on both side, we get, \\nlog(res) = b*log(a)\\nres = exp(b*(log(a))\\n```\n```\\nvar myPow = function(a, b) {\\n    \\n    let flag = 0\\n\\t\\n\\t// checking if a is negative \\n    if(a<0) {\\n        a = Math.abs(a)\\n        if(b%2!=0) flag=1    \\n\\t\\tlet res =  Math.exp(  b*Math.log(a)  )\\n        return ( flag==1 ? res*-1 : res  )\\n    }\\n\\t\\n\\t\\n\\t\\n    // when a is not negative\\n    else return Math.exp(  (b)  *  Math.log(a)  )\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3060365,
                "title": "c-java-100-solution-using-recursion-pow-x-n",
                "content": "# Complexity\\n- Time complexity: $$O(log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    double myPow(double x, long long n) {\\n        if(n==0 || x==1)\\n            return 1;\\n        if(x==0)\\n            return 0;\\n\\n        if(n<0)\\n            return myPow(1/x,abs(n));\\n\\n        return (n%2==0 ? myPow(x*x,n/2) : x*myPow(x*x,n/2));\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public double myPow(double x, long n) {\\n        if(n==0 || x==1)\\n            return 1;\\n        if(x==0)\\n            return 0;\\n\\n        if(n<0)\\n            return myPow(1/x,Math.abs(n));\\n\\n        return (n%2==0 ? myPow(x*x,n/2) : x*myPow(x*x,n/2));\\n    }\\n}\\n```\\nUpvote and Code By: [Arnav Sharma](https://www.linkedin.com/in/arnavsharma2711/)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Math",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    double myPow(double x, long long n) {\\n        if(n==0 || x==1)\\n            return 1;\\n        if(x==0)\\n            return 0;\\n\\n        if(n<0)\\n            return myPow(1/x,abs(n));\\n\\n        return (n%2==0 ? myPow(x*x,n/2) : x*myPow(x*x,n/2));\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public double myPow(double x, long n) {\\n        if(n==0 || x==1)\\n            return 1;\\n        if(x==0)\\n            return 0;\\n\\n        if(n<0)\\n            return myPow(1/x,Math.abs(n));\\n\\n        return (n%2==0 ? myPow(x*x,n/2) : x*myPow(x*x,n/2));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 153357,
                "title": "detailed-comment-on-overflow-case",
                "content": "You can already see many solutions that handle overflow case so I am not going to describe that here. This comment is more about understanding the overflow case. I guess many people are confused around the edge case where n = INT_MAX (or -2147483648) and why doing n = -n doesn\\'t work. It has to do with the way signed numbers are stored in modern computers. Consider simple example of signed char. The range of values for signed char are -128 to 127.\\n\\nThe values are stored in memory as- \\n```\\nInteger     Binary\\n0           0000 0000\\n1           0000 0001\\n2           0000 0010\\n.....\\n127         0111 1111\\n-1          1111 1111\\n-2          1111 1110\\n.....\\n-128        1000 0000\\n```\\nNegative values are stored as 2\\'s complement. Which is calculated as -x = 2^n - x; where n is number of bits in the data type (32 bits for int, 8 bits for signed char, 64 bits for long in most compilers). Why do we need 2\\'s compliment? Let\\'s take an example using 8 bit system which is easy to work with . Let\\'s say you want to subtract 3 from 7\\n```\\n  7\\n- 3\\n---\\n  4\\n```\\nIn memory you would store -3 as 2^8 - 3 = 253. When you want to perform subtraction you simply add the number to 2\\'s  compliment of the number you need to subtract over modulo 256 field i.e. in our case (7 + 253) % 256 i.e. 260 % 256 = 4 which is same as what we expect.\\n\\nIf you see statement n = -n with n = INT_MIN, in assembly on ARM GCC 7.x compiler it looks like\\n```\\n        mov     r3, #-2147483648  ## Load INT_MIN in r3\\n        str     r3, [sp, #4]\\n        ldr     r3, [sp, #4]\\n        rsb     r3, r3, #0         ## Reverse subtract instruction: subtracts r3 from 0\\n        str     r3, [sp, #4]\\n```\\nOn intel X86-64 with gcc 8.x compiler it lookss like\\n```\\n        xor      eax, eax   ## puts 0 value in eax\\n        mov     dword ptr [rbp - 4], -214748364   ##loads -214748364 on stack\\n        sub     eax, dword ptr [rbp - 4] ## subtracts -214748364 from 0\\n```\\nOn different compilers for Intel you may see \\'neg\\' instruction being used which basically  puts 2\\'s compliment of the number in the same place in stack/register. \\n\\n**INT_MIN** value is stored in the memory as 2^32 - 2^31 = 2^31 in 2\\'s compliment form\\n\\nNow we can see how taking 2\\'s compliment of **INT_MIN** or subtracting it from 0 results in overflow - \\n```\\n2\\'s compliment of INT_MIN: 2^32-2^31 = 2^31\\n0+2^31 = 2^31\\n```\\n\\nThis results in the same number we started with i.e. **INT_MIN** (which is negative). For a solution like this - \\n```\\ndouble mypow(double x, int n) {\\n    if(x == 0.00000) return 0.0;\\n    if( n == 0) return 1.0;\\n    if(n < 0) {\\n        n = -n;\\n        x = 1/x;\\n    }\\n    return ( n % 2 == 0) ? mypow(x*x, n/2) : x*mypow(x*x, n/2);\\n}\\n```\\nTake input, x = 2.0, n = INT_MIN. The values at end of each recursive call go as follows, ultimately resulting in overflow of the x value - \\n```\\nn: -2147483648 x: 0.5\\nn: 1073741824 x: 4 << This happens because value of n is still negative in 2nd level of recusion which makes x = 1/0.25 = 4\\nn: 536870912 x: 16\\nn: 268435456 x: 256\\nn: 134217728 x: 65536\\nn: 67108864 x: 4.29497e+09\\nn: 33554432 x: 1.84467e+19\\nn: 16777216 x: 3.40282e+38\\nn: 8388608 x: 1.15792e+77\\nn: 4194304 x: 1.34078e+154\\nn: 2097152 x: inf\\nn: 1048576 x: inf\\nn: 524288 x: inf\\nn: 262144 x: inf\\nn: 131072 x: inf\\nn: 65536 x: inf\\nn: 32768 x: inf\\nn: 16384 x: inf\\nn: 8192 x: inf\\nn: 4096 x: inf\\nn: 2048 x: inf\\nn: 1024 x: inf\\nn: 512 x: inf\\nn: 256 x: inf\\nn: 128 x: inf\\nn: 64 x: inf\\nn: 32 x: inf\\nn: 16 x: inf\\nn: 8 x: inf\\nn: 4 x: inf\\nn: 2 x: inf\\nn: 1 x: inf\\n```",
                "solutionTags": [],
                "code": "```\\nInteger     Binary\\n0           0000 0000\\n1           0000 0001\\n2           0000 0010\\n.....\\n127         0111 1111\\n-1          1111 1111\\n-2          1111 1110\\n.....\\n-128        1000 0000\\n```\n```\\n  7\\n- 3\\n---\\n  4\\n```\n```\\n        mov     r3, #-2147483648  ## Load INT_MIN in r3\\n        str     r3, [sp, #4]\\n        ldr     r3, [sp, #4]\\n        rsb     r3, r3, #0         ## Reverse subtract instruction: subtracts r3 from 0\\n        str     r3, [sp, #4]\\n```\n```\\n        xor      eax, eax   ## puts 0 value in eax\\n        mov     dword ptr [rbp - 4], -214748364   ##loads -214748364 on stack\\n        sub     eax, dword ptr [rbp - 4] ## subtracts -214748364 from 0\\n```\n```\\n2\\'s compliment of INT_MIN: 2^32-2^31 = 2^31\\n0+2^31 = 2^31\\n```\n```\\ndouble mypow(double x, int n) {\\n    if(x == 0.00000) return 0.0;\\n    if( n == 0) return 1.0;\\n    if(n < 0) {\\n        n = -n;\\n        x = 1/x;\\n    }\\n    return ( n % 2 == 0) ? mypow(x*x, n/2) : x*mypow(x*x, n/2);\\n}\\n```\n```\\nn: -2147483648 x: 0.5\\nn: 1073741824 x: 4 << This happens because value of n is still negative in 2nd level of recusion which makes x = 1/0.25 = 4\\nn: 536870912 x: 16\\nn: 268435456 x: 256\\nn: 134217728 x: 65536\\nn: 67108864 x: 4.29497e+09\\nn: 33554432 x: 1.84467e+19\\nn: 16777216 x: 3.40282e+38\\nn: 8388608 x: 1.15792e+77\\nn: 4194304 x: 1.34078e+154\\nn: 2097152 x: inf\\nn: 1048576 x: inf\\nn: 524288 x: inf\\nn: 262144 x: inf\\nn: 131072 x: inf\\nn: 65536 x: inf\\nn: 32768 x: inf\\nn: 16384 x: inf\\nn: 8192 x: inf\\nn: 4096 x: inf\\nn: 2048 x: inf\\nn: 1024 x: inf\\nn: 512 x: inf\\nn: 256 x: inf\\nn: 128 x: inf\\nn: 64 x: inf\\nn: 32 x: inf\\nn: 16 x: inf\\nn: 8 x: inf\\nn: 4 x: inf\\nn: 2 x: inf\\nn: 1 x: inf\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2771360,
                "title": "pow-x-n-java-solution-easy-explanation",
                "content": "```\\n# FIRST APPOACH :- using Loop\\n// pow(x,n) = pow(2,5) = 2*2*2*2*2 = 32 ( Multiply x to the n times)\\n// we can run a loop from 1 to n and updating our ans by multplying x \\n\\nans = 1;\\nfor(int i=1;i<=n;i++){\\n        ans = ans*x;\\n   }\\n//The problem occur when we use loop is --> given constraint of n can have maximum value \\n//upto the 2^31-1 i.e. 2147483647,  that means Time complexity of Loop solution will be O(n).\\n\\n//what if pow(2, 2147483647) = that mean we have to multiply 2 to the 2147483647 times which is obviously not sufficient at all\\n\\n# SECOND APPROACH :-  Optimizing upto O(logn)\\nExample :- pow(2, 10)  \\n\\nwe can write 2^10 as\\n1. pow(x,n) = 2^10  == 2^(2*5) == (2^2)^5 ==  (4)^5 or (2*2)^5 \\n                2^10 == 4^5  that is :- if n is even answer will be    (x*x)^n/2\\nin 2^10 we have to multiply 2 to the 10 time but now we have to multiply 4 to the only 5 times to get the answer which is half of the 10\\n\\nwe can write 4^5 as\\n2. pow(x,n) = 4^5 == (4 )* 4^4\\n if n is odd answer will be   x * x^(n-1)\\n\\nwe can write 4^4 as\\n3. pow(x,n) = 4^4 == 4^(2*2) == (4^2)^2  == (16)^2\\n here n is even answer will be (x*x)^n/2 :- (16)^2 \\nfor calculating 4^4 we have to multiply 4 to the the 4 times but now we can get answer by multipplying 16 to the 2 times\\n\\nwe can write 16^2 as\\n4. pow(x,n) = 16^2 == 16^(2*1) == (16^2)^1 == (256)^1\\nhere n is even answer will be (x*x)^n/2 :- (256)^1\\nfor calculating 16^2 we have to multiply 16 to the 2 time now for getting answer we need to multiply 256 to the 1 time\\n\\n5. pow(x,n) = 256^1 here n is odd that is x * x^(n-1) :- 256 * (256)^0 :- 256 * 1 :- 256\\n\\n//Base case\\n//if(n==0)     for any given number if power is zero it\\'s value is 1 \\n//return 1;\\n\\n//our work is just to check given power is even or odd and according to them recusion calling is doing\\n//if(n%2==0)\\n//return myPow(x*x  ,  n/2);\\n\\n//else\\n//return x *  myPow(x,  n-1);\\n\\n\\nCASE WHEN n is -ve\\nif(n<0){\\n   n = -n;\\n   x = 1/x;\\n   }\\n   \\n   \\nclass Solution {\\n    public double myPow(double x, int n) {\\n\\t\\tlong nm = n;\\n\\t\\tif(n<0){\\n\\t\\t   nm = -nm;\\n\\t\\t   x = 1/x;\\n\\t\\t  }\\n        return pow(x,nm);\\n    }\\n    public double pow(double x, long n)\\n    {\\n        if(n==0)\\n            return 1;\\n\\t\\t\\t\\n        if(n%2==0)\\n            return pow(x*x, n/2);\\n        else\\n            return x * pow(x,n-1);\\n    }\\n}\\n\\nNOTE:-  we are taking n as long varibale suppose n value is -2147483648 and we are doing n = -n\\nif n is integer it will overflow because n = -(-2147483648) = 2147483648 \\nand int can hold max value 2147483647 that why we take n as long\\n\\nTIME COMPLEXITY: - O(logn)\\nexample:- 2^64\\nrecursion calls will be\\n2^64 --> (4)^32 -->(16)^16 -->(256)^8-->(65536)^4-->(4294967296)^2-->(1.84467....)^1-->(1.84467..)^0 \\n\\n64 --> 32-->16-->8-->4-->2-->1  :- this is G.P series (n--->n/2--->n/4-->n/8-->n/16-->n/32-->n/64)\\n  \\n  general term of G.P.\\nn/2^0 --> n/2^1 --> n/2^2 --> n/2^3-->.......n/2^k \\n\\ncomparing both \\nn/2^k = 1\\nn = 2^k\\ntak log on both side\\nlog(n) = log(2^k)\\nlog(n) = klog2\\ndivide both side by log2\\nk = log(n)\\nT.C :- log(n)\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n# FIRST APPOACH :- using Loop\\n// pow(x,n) = pow(2,5) = 2*2*2*2*2 = 32 ( Multiply x to the n times)\\n// we can run a loop from 1 to n and updating our ans by multplying x \\n\\nans = 1;\\nfor(int i=1;i<=n;i++){\\n        ans = ans*x;\\n   }\\n//The problem occur when we use loop is --> given constraint of n can have maximum value \\n//upto the 2^31-1 i.e. 2147483647,  that means Time complexity of Loop solution will be O(n).\\n\\n//what if pow(2, 2147483647) = that mean we have to multiply 2 to the 2147483647 times which is obviously not sufficient at all\\n\\n# SECOND APPROACH :-  Optimizing upto O(logn)\\nExample :- pow(2, 10)  \\n\\nwe can write 2^10 as\\n1. pow(x,n) = 2^10  == 2^(2*5) == (2^2)^5 ==  (4)^5 or (2*2)^5 \\n                2^10 == 4^5  that is :- if n is even answer will be    (x*x)^n/2\\nin 2^10 we have to multiply 2 to the 10 time but now we have to multiply 4 to the only 5 times to get the answer which is half of the 10\\n\\nwe can write 4^5 as\\n2. pow(x,n) = 4^5 == (4 )* 4^4\\n if n is odd answer will be   x * x^(n-1)\\n\\nwe can write 4^4 as\\n3. pow(x,n) = 4^4 == 4^(2*2) == (4^2)^2  == (16)^2\\n here n is even answer will be (x*x)^n/2 :- (16)^2 \\nfor calculating 4^4 we have to multiply 4 to the the 4 times but now we can get answer by multipplying 16 to the 2 times\\n\\nwe can write 16^2 as\\n4. pow(x,n) = 16^2 == 16^(2*1) == (16^2)^1 == (256)^1\\nhere n is even answer will be (x*x)^n/2 :- (256)^1\\nfor calculating 16^2 we have to multiply 16 to the 2 time now for getting answer we need to multiply 256 to the 1 time\\n\\n5. pow(x,n) = 256^1 here n is odd that is x * x^(n-1) :- 256 * (256)^0 :- 256 * 1 :- 256\\n\\n//Base case\\n//if(n==0)     for any given number if power is zero it\\'s value is 1 \\n//return 1;\\n\\n//our work is just to check given power is even or odd and according to them recusion calling is doing\\n//if(n%2==0)\\n//return myPow(x*x  ,  n/2);\\n\\n//else\\n//return x *  myPow(x,  n-1);\\n\\n\\nCASE WHEN n is -ve\\nif(n<0){\\n   n = -n;\\n   x = 1/x;\\n   }\\n   \\n   \\nclass Solution {\\n    public double myPow(double x, int n) {\\n\\t\\tlong nm = n;\\n\\t\\tif(n<0){\\n\\t\\t   nm = -nm;\\n\\t\\t   x = 1/x;\\n\\t\\t  }\\n        return pow(x,nm);\\n    }\\n    public double pow(double x, long n)\\n    {\\n        if(n==0)\\n            return 1;\\n\\t\\t\\t\\n        if(n%2==0)\\n            return pow(x*x, n/2);\\n        else\\n            return x * pow(x,n-1);\\n    }\\n}\\n\\nNOTE:-  we are taking n as long varibale suppose n value is -2147483648 and we are doing n = -n\\nif n is integer it will overflow because n = -(-2147483648) = 2147483648 \\nand int can hold max value 2147483647 that why we take n as long\\n\\nTIME COMPLEXITY: - O(logn)\\nexample:- 2^64\\nrecursion calls will be\\n2^64 --> (4)^32 -->(16)^16 -->(256)^8-->(65536)^4-->(4294967296)^2-->(1.84467....)^1-->(1.84467..)^0 \\n\\n64 --> 32-->16-->8-->4-->2-->1  :- this is G.P series (n--->n/2--->n/4-->n/8-->n/16-->n/32-->n/64)\\n  \\n  general term of G.P.\\nn/2^0 --> n/2^1 --> n/2^2 --> n/2^3-->.......n/2^k \\n\\ncomparing both \\nn/2^k = 1\\nn = 2^k\\ntak log on both side\\nlog(n) = log(2^k)\\nlog(n) = klog2\\ndivide both side by log2\\nk = log(n)\\nT.C :- log(n)\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345741,
                "title": "python3-pow-x-n",
                "content": "*  x^n = (1/x)^(-n)\\n*  x^(2n) = (x^n) *(x^n)\\n```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        # x**n == (1/x)**(-n) \\n        # by using the property above we can transform the negetive power problem to positive power problem\\n        # so that we solve the positive power situation, we also solved the negtive power situation.\\n        if n < 0:\\n            x = 1/x\\n            n = -n\\n        # We solve the positive power here:\\n        power = 1\\n        current_product = x\\n        while n > 0:\\n            # if n is odd numberm, we need to time x one more time\\n            if n%2 : \\n                power = power * current_product\\n            current_product = current_product * current_product\\n            n = n//2\\n        return power\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        # x**n == (1/x)**(-n) \\n        # by using the property above we can transform the negetive power problem to positive power problem\\n        # so that we solve the positive power situation, we also solved the negtive power situation.\\n        if n < 0:\\n            x = 1/x\\n            n = -n\\n        # We solve the positive power here:\\n        power = 1\\n        current_product = x\\n        while n > 0:\\n            # if n is odd numberm, we need to time x one more time\\n            if n%2 : \\n                power = power * current_product\\n            current_product = current_product * current_product\\n            n = n//2\\n        return power\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808188,
                "title": "c-recursion",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    double bin(double x,long long k){\\n        if(k==1)return x;\\n        double a = bin(x,k/2);\\n        if(k&1)return a*a*x;\\n        else return a*a;\\n    }\\n    double myPow(double x, int n) {\\n        if(n==0)return 1;\\n       long long k = long(abs(n));\\n       double ans = bin(x,k);\\n       if(n<0)return 1/ans;\\n       else return ans;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/672361c6-5835-4275-ae39-0367d2738ca3_1690175812.506172.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double bin(double x,long long k){\\n        if(k==1)return x;\\n        double a = bin(x,k/2);\\n        if(k&1)return a*a*x;\\n        else return a*a;\\n    }\\n    double myPow(double x, int n) {\\n        if(n==0)return 1;\\n       long long k = long(abs(n));\\n       double ans = bin(x,k);\\n       if(n<0)return 1/ans;\\n       else return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807619,
                "title": "stepwise-image-explanation-binary-exponentiation-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/6b2f6c9c-6e2f-4320-8d28-6902fd228c12_1690158819.5567503.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    double myPow(double base, int power) \\n    {\\n        if (power < 0) { base = 1 / base; power = abs(power); }\\n        double ans = 1;\\n        while(power > 0)\\n        {\\n            if (power % 2 == 0) \\n            {\\n                base = base * base;\\n                power = power / 2;\\n            }\\n            else \\n            {\\n                ans = (ans * base);\\n                power--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double myPow(double base, int power) \\n    {\\n        if (power < 0) { base = 1 / base; power = abs(power); }\\n        double ans = 1;\\n        while(power > 0)\\n        {\\n            if (power % 2 == 0) \\n            {\\n                base = base * base;\\n                power = power / 2;\\n            }\\n            else \\n            {\\n                ans = (ans * base);\\n                power--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 659996,
                "title": "binary-exponential-indepth-explanation",
                "content": "here is indepth explanation of binary exponential method as explained in https://cp-algorithms.com/algebra/binary-exp.html\\n\\n\\n![image](https://assets.leetcode.com/users/_ro/image_1590829480.png)\\n![image](https://assets.leetcode.com/users/_ro/image_1590829489.png)\\n\\nthis is how i did it\\n```\\ndouble binpow(double a, long long n)\\n    {\\n        double ans = 1;\\n        while(n)\\n        {\\n            if(n&1)\\n                ans *=a;\\n            a*=a;\\n            n>>=1;\\n        }\\n        return ans;\\n    }\\n    double myPow(double x, long long n) {    \\n      bool negative = (n<0) ? 1 : 0;\\n        n = abs(n);\\n        \\n      return negative ? 1 / binpow(x,n) : binpow(x,n);\\n        \\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\ndouble binpow(double a, long long n)\\n    {\\n        double ans = 1;\\n        while(n)\\n        {\\n            if(n&1)\\n                ans *=a;\\n            a*=a;\\n            n>>=1;\\n        }\\n        return ans;\\n    }\\n    double myPow(double x, long long n) {    \\n      bool negative = (n<0) ? 1 : 0;\\n        n = abs(n);\\n        \\n      return negative ? 1 / binpow(x,n) : binpow(x,n);\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1680111,
                "title": "my-recursive-solution",
                "content": "This is my recursive solution\\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        if(n==0){\\n            return 1;\\n        }\\n        if(n>0){\\n        double temp  = myPow(x,n/2);\\n        temp = temp*temp;\\n        \\n        if(n%2==0){\\n            return temp;\\n        }\\n        else{\\n            return temp*x;\\n        }\\n        }\\n        else{\\n            int t = n/2;\\n            double ans = myPow(x,-1*t);\\n            ans = ans*ans;\\n            if(n%2!=0)\\n                ans = ans*x;\\n            return 1/ans;\\n        }\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        if(n==0){\\n            return 1;\\n        }\\n        if(n>0){\\n        double temp  = myPow(x,n/2);\\n        temp = temp*temp;\\n        \\n        if(n%2==0){\\n            return temp;\\n        }\\n        else{\\n            return temp*x;\\n        }\\n        }\\n        else{\\n            int t = n/2;\\n            double ans = myPow(x,-1*t);\\n            ans = ans*ans;\\n            if(n%2!=0)\\n                ans = ans*x;\\n            return 1/ans;\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 739166,
                "title": "c-recursive-approach-with-explanation",
                "content": "**So basically the approach here is to divide the n in even and odd (Since we need to find power for both positive and negative n)**\\n\\nEx:\\n\\n**x^n = x^n/2 * x^n/2;**\\n\\nif n is 0 return 1\\n\\nif n is even call recursive function for n = n/2\\n\\nand if n is odd call function x*x^n-1\\n\\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        if(n==0) return 1;\\n        \\n        double y = myPow(x,n/2);\\n        if(n%2==0){\\n            \\n            return y*y;\\n            \\n        }\\n        else{\\n            return n < 0 ? 1/x*y*y : x*y*y; \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        if(n==0) return 1;\\n        \\n        double y = myPow(x,n/2);\\n        if(n%2==0){\\n            \\n            return y*y;\\n            \\n        }\\n        else{\\n            return n < 0 ? 1/x*y*y : x*y*y; \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 505306,
                "title": "c-detailed-solution-stack-diagrams-and-proper-explanation",
                "content": "My solution is a 0ms solution!\\nProper explanation and stack diagrams are added for better understanding.\\n\\n![image](https://assets.leetcode.com/users/debodirno/image_1581359427.png)\\n\\n```cpp\\n/**\\n * Stack diagrams for the various cases :\\n *\\n * For 2 ^ -4\\n * +              +\\n * |              |\\n * |              |\\n * |              |\\n * |              |\\n * |              |\\n * +--------------+\\n * |              |\\n * |   2, -1      +------------->   0.5\\n * +--------------+\\n * |              |\\n * |   2, -2      +------------->   0.5 x 0.5 = 0.25\\n * +--------------+\\n * |              |\\n * |   2, -4      +------------->   0.25 x 0.25 = 0.0625\\n * +--------------+\\n *\\n *\\n * For 2 ^ -5\\n * +              +\\n * |              |\\n * |              |\\n * |              |\\n * |              |\\n * |              |\\n * +--------------+\\n * |              |\\n * |   2, -1      +------------->   0.5\\n * +--------------+\\n * |              |\\n * |   2, -2      +------------->   0.5 x 0.5 = 0.25\\n * +--------------+\\n * |              |\\n * |   2, -5      +------------->   0.25 x 0.25 x 0.5 = 0.0625 x 0.5 = 0.03125\\n * +--------------+\\n *\\n *\\n * For 2 ^ 4\\n * +              +\\n * |              |\\n * |              |\\n * |              |\\n * |              |\\n * |              |\\n * +--------------+\\n * |              |\\n * |   2, 1       +------------->   2\\n * +--------------+\\n * |              |\\n * |   2, 2       +------------->   2 x 2 = 4\\n * +--------------+\\n * |              |\\n * |   2, 4       +------------->   4 x 4 = 16\\n * +--------------+\\n *\\n *\\n * For 2 ^ 5\\n * +              +\\n * |              |\\n * |              |\\n * |              |\\n * |              |\\n * |              |\\n * +--------------+\\n * |              |\\n * |   2, 1       +------------->   2\\n * +--------------+\\n * |              |\\n * |   2, 2       +------------->   2 x 2 = 4\\n * +--------------+\\n * |              |\\n * |   2, 5       +------------->   4 x 4 x 2 = 16 x 2 = 32\\n * +--------------+\\n */\\nclass Solution {\\npublic:\\n  double myPow(double x, int n) {\\n    // base conditions\\n    if (!n) {\\n      return 1;\\n    } else if (n == 1) {\\n      return x;\\n    } else if (n == -1) {\\n      return 1 / x;\\n    }\\n\\n    // keep recursing till it reaches either 1 or -1;\\n    // neglecting zero, since that cannot happen\\n    // once it reaches 1, power will hold x;\\n    // however, if it reaches -1, power will hold 1 / x.\\n    double power = myPow(x, n / 2);\\n    double base = (n > 0) ? x : 1 / x;\\n\\n    if (n % 2 == 0) { // if n is even, just multiplying the powers would do\\n      return power * power;\\n    } else { // if n is odd, multiplying the powers and then multiplying the base (x) or 1 / x would suffice\\n      return power * power * base;\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```cpp\\n/**\\n * Stack diagrams for the various cases :\\n *\\n * For 2 ^ -4\\n * +              +\\n * |              |\\n * |              |\\n * |              |\\n * |              |\\n * |              |\\n * +--------------+\\n * |              |\\n * |   2, -1      +------------->   0.5\\n * +--------------+\\n * |              |\\n * |   2, -2      +------------->   0.5 x 0.5 = 0.25\\n * +--------------+\\n * |              |\\n * |   2, -4      +------------->   0.25 x 0.25 = 0.0625\\n * +--------------+\\n *\\n *\\n * For 2 ^ -5\\n * +              +\\n * |              |\\n * |              |\\n * |              |\\n * |              |\\n * |              |\\n * +--------------+\\n * |              |\\n * |   2, -1      +------------->   0.5\\n * +--------------+\\n * |              |\\n * |   2, -2      +------------->   0.5 x 0.5 = 0.25\\n * +--------------+\\n * |              |\\n * |   2, -5      +------------->   0.25 x 0.25 x 0.5 = 0.0625 x 0.5 = 0.03125\\n * +--------------+\\n *\\n *\\n * For 2 ^ 4\\n * +              +\\n * |              |\\n * |              |\\n * |              |\\n * |              |\\n * |              |\\n * +--------------+\\n * |              |\\n * |   2, 1       +------------->   2\\n * +--------------+\\n * |              |\\n * |   2, 2       +------------->   2 x 2 = 4\\n * +--------------+\\n * |              |\\n * |   2, 4       +------------->   4 x 4 = 16\\n * +--------------+\\n *\\n *\\n * For 2 ^ 5\\n * +              +\\n * |              |\\n * |              |\\n * |              |\\n * |              |\\n * |              |\\n * +--------------+\\n * |              |\\n * |   2, 1       +------------->   2\\n * +--------------+\\n * |              |\\n * |   2, 2       +------------->   2 x 2 = 4\\n * +--------------+\\n * |              |\\n * |   2, 5       +------------->   4 x 4 x 2 = 16 x 2 = 32\\n * +--------------+\\n */\\nclass Solution {\\npublic:\\n  double myPow(double x, int n) {\\n    // base conditions\\n    if (!n) {\\n      return 1;\\n    } else if (n == 1) {\\n      return x;\\n    } else if (n == -1) {\\n      return 1 / x;\\n    }\\n\\n    // keep recursing till it reaches either 1 or -1;\\n    // neglecting zero, since that cannot happen\\n    // once it reaches 1, power will hold x;\\n    // however, if it reaches -1, power will hold 1 / x.\\n    double power = myPow(x, n / 2);\\n    double base = (n > 0) ? x : 1 / x;\\n\\n    if (n % 2 == 0) { // if n is even, just multiplying the powers would do\\n      return power * power;\\n    } else { // if n is odd, multiplying the powers and then multiplying the base (x) or 1 / x would suffice\\n      return power * power * base;\\n    }\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 358894,
                "title": "c-solution",
                "content": "Iterative O(logn) solution\\n```\\npublic class Solution \\n{\\n    public double MyPow(double x, int n) \\n    {\\n        long p = (long) n; \\n        \\n        if(p < 0 ) \\n        {\\n            p = -p;\\n            x = 1 / x;\\n        }\\n        \\n        double result = 1;\\n        while(p > 0) // x^13 = x^8 * x^4 * x^1   13 = (1101) in binary\\n        {\\n            if(p % 2 == 1) \\n                result = result * x;\\n            x = x * x;\\n            p = p / 2;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\\n\\nRecursive O(logn) solution.\\n```\\npublic class Solution \\n{\\n    public double MyPow(double x, int n) \\n    {\\n        if(n < 0) return 1/x * MyPow(1/x, -(n + 1));\\n        if(n == 0) return 1;\\n        if(n == 1) return x;\\n        if(n % 2 == 0) return MyPow(x * x, n/2);\\n        return x * MyPow(x * x, n/2);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public double MyPow(double x, int n) \\n    {\\n        long p = (long) n; \\n        \\n        if(p < 0 ) \\n        {\\n            p = -p;\\n            x = 1 / x;\\n        }\\n        \\n        double result = 1;\\n        while(p > 0) // x^13 = x^8 * x^4 * x^1   13 = (1101) in binary\\n        {\\n            if(p % 2 == 1) \\n                result = result * x;\\n            x = x * x;\\n            p = p / 2;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\n```\\npublic class Solution \\n{\\n    public double MyPow(double x, int n) \\n    {\\n        if(n < 0) return 1/x * MyPow(1/x, -(n + 1));\\n        if(n == 0) return 1;\\n        if(n == 1) return x;\\n        if(n % 2 == 0) return MyPow(x * x, n/2);\\n        return x * MyPow(x * x, n/2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807610,
                "title": "python-simple-recursive",
                "content": "# Intuition\\n\\nDivide and Conquer\\n\\nTake $x^{10}$ and  as example\\n\\n$x^{10} = x^5 * x^5 * x^0$\\n$x^5 = x^2 * x^2 * x^1$\\n$x^2 = x^1 * x^1 * x^0$\\n\\n# Complexity\\n- Time complexity: $$O(logN)$$\\n\\n- Space complexity: $$O(logN)$$\\n\\n# Code\\n```\\nclass Solution:\\n    @cache\\n    def myPow(self, x: float, n: int) -> float:\\n        if n == 0:\\n            return 1\\n        elif n == 1:\\n            return x\\n        elif n == -1:\\n            return 1/x\\n        return self.myPow(x, n//2) * self.myPow(x, n//2) * self.myPow(x, n%2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    @cache\\n    def myPow(self, x: float, n: int) -> float:\\n        if n == 0:\\n            return 1\\n        elif n == 1:\\n            return x\\n        elif n == -1:\\n            return 1/x\\n        return self.myPow(x, n//2) * self.myPow(x, n//2) * self.myPow(x, n%2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2364754,
                "title": "pow-x-n-iterative-and-recursive-solution-explanation",
                "content": "## Solution 1 : Iterative \"School\" Solution O(n)\\n### Intuition\\nLet\\'s start by looking at the inputs to the function. x is the number we want to raise to a power and n is the power we are going to raise x to. Something important to note is that n will be an integer, that means we can use the middle school definition of exponentiation to solve the problem.\\n[![image](https://assets.leetcode.com/users/images/ac8e025f-c24a-4ff8-a974-e66be9cc36e9_1659207221.4526417.png)](https://en.wikipedia.org/wiki/Exponentiation)\\nThere is a small catch though, n won\\'t excluively be positive integers, it can be any integer even including the negatives. To get around this we need to tap into two of our exponentiation rules.\\n[![image](https://assets.leetcode.com/users/images/5fc3cb0d-4e9e-4cbb-8cef-178da1de088f_1659207789.5562131.png)](https://en.wikipedia.org/wiki/Exponentiation)\\n[![image](https://assets.leetcode.com/users/images/dfbb0d80-7754-41e7-bbcc-56e3a69cab13_1659207698.4003837.png)](https://en.wikipedia.org/wiki/Exponentiation)\\nNow that we we know how account for positive integers, negative integers, and zero, we know how to handle any n input. The case for n = 0 lives on its own, but the solution for positive and negative integers are similar. Both require multiplying x by itself n times, but the negative case needs the extra step of taking that repeated multiplication and putting it all under 1.\\n### Algorithm\\n```\\nfunction pow(x, n)\\n\\tIf n equals 0\\n\\t\\treturn 1\\n\\n\\tIf n is negative\\n\\t\\tnegative_flag = True\\n\\t\\tn = |n|\\n\\n\\trepeated_multiplication = x\\n\\tFor i in [1, n]\\n\\t\\trepeated_multiplication *= x\\n\\n\\tif negative_flag\\n\\t\\treturn (1 / repeated_multiplication)\\n\\treturn repeated_multiplication\\n````\\nNow let\\'s put it all together into our Python code.\\n### Implementation\\n```\\ndef pow(x, n):\\n\\t# Take care of our unique base case\\n\\tif (n == 0):\\n\\t\\treturn 1\\n\\t\\n\\t# Take care of our negative case\\n\\tnegative_exponent = False\\n\\tif (n < 0):\\n\\t\\tnegative_exponent = True\\n\\t\\tn *= -1\\n\\t\\n\\t# Do the shared, repeated multiplication\\n\\trepeated_multiplication = x\\n\\tfor i in range(1, n):\\n\\t\\trepeated_multiplication *= x\\n\\t\\n\\t# Return 1 / repeated_multiplication if our original exponent was negative\\n\\tif (negative_exponent):\\n\\t\\treturn (1 / repeated_multiplication)\\n\\t# Return the normal repeated_multiplication otherwise\\n\\treturn repeated_multiplication\\n```\\n### Complexity Analysis\\nLet n be the exponent x is being raised to.\\n* Time Complexity O(n)\\nFor each multiplication there are exactly two elementary operations, multiplication and assignment, so each multiplication takes O(1) time. Since we have n O(1) steps, the time complexity of our iterative solution is O(n).\\n* Space Complexity O(1)\\nWe use a boolean value to store whether or not the original exponent was exponent and we use a real value to store the return value. Both booleans and real values use constant space therefore the space complexity of this solution is O(1).\\n## Solution 2 : Recursive Solution O(log n)\\n### Intuition\\nIf we look at one more exponentiation rule we can start to formulate changes to our solution.\\n[![image](https://assets.leetcode.com/users/images/e89e6741-67f8-46ad-b0f6-d51fc587d398_1659211707.598999.png)](https://en.wikipedia.org/wiki/Exponentiation)\\nWe can split apart our exponent into two smaller exponents to get the answer. The next logical step is answering the question, how do we split our exponent? The simplest way to split up numbers is in half. When we split a number in half there are two cases, an even and and odd case. If the number was originally even it will become two identical numbers (ex: 4 = 2 + 2). If the number was originally odd it will become two identical numbers plus one (ex: 5 = 2 + 2 + 1). That means we can split our exponent up into two identical subproblems.\\n![image](https://assets.leetcode.com/users/images/083c3f33-2e08-4a96-b6da-66173a15fe27_1659216690.4437017.png)\\nHow can we get around the repeated function calls to save some calculations? A common technique for getting around this is called \"memoization\" where intermediate results are saved, then used in place of a function call we have seen already.\\n### Algorithm\\n```\\nfunction repeated_multiplication(x, n)\\n\\tif n equals 0\\n\\t\\treturn 1\\n\\tintermediate = repeated_multiplication(x, floor(n / 2))\\n\\tif n is even\\n\\t\\treturn intermediate * intermediate\\n\\treturn intermediate * intermediate * x\\n```\\nThe memoization is hard to see, but it happens at `intermediate = repeated_multiplication(x, floor(n / 2))`. If we simply returned `repeated_multiplication(x, floor(n / 2)) * repeated_multiplication(x, floor(n / 2))` the function will still have to go down the same path twice, instead we go down it once, put it in our intermediate variable, then multiply the variable by itself. Now that we have a new method of calculating the repeated multiplication, we can replace it in our previous solution for something brand new.\\n### Implementation\\n```\\ndef repeated_multiplication(base, exponent):\\n\\tif (exponent == 0):\\n\\t\\treturn 1\\n\\tintermediate = repeated_multiplication(base, exponent // 2)\\n\\tif ((exponent % 2) == 0):\\n\\t\\treturn intermediate * intermediate\\n\\treturn intermediate * intermediate * base\\n\\ndef pow(x, n):\\n\\t# The repeated_multiplication helper function takes care of n = 0 case\\n\\t\\n\\t# Take care of the negative case\\n\\tif (n < 0):\\n\\t\\treturn (1 / repeated_multiplication(x, n * -1))\\n\\t\\n\\t# Take care of the nonnegative case\\n\\treturn repeated_multiplication(x, n)\\n```\\n### Complexity Analysis\\nLet n be the exponent x is being raised to. Consider the first recursive step where we have n multiplications. To move onto the next step we divide n by 2, now we have n/2 multiplications. To move on to the next step we divide n/2 by 2, now we have n/4 multiplications. This process continues until the problem is solved.\\n[![image](https://assets.leetcode.com/users/images/d86aefc7-f7d8-4345-b477-4e99639ff992_1659215834.3239772.png)](https://www.geeksforgeeks.org/how-to-solve-time-complexity-recurrence-relations-using-recursion-tree-method/)\\nThe rest of our solution outside of the recursion consists of only elementary operations, therefore the resulting recurrence relation is T(n) = 2T(n/2) + 1.\\n* Time Complexity O(log n)\\nEach level in our recursion tree is made up of only elementary operations, so the time complexity of each level is O(1). By applying the [master theorem](https://brilliant.org/wiki/master-theorem/) to our recurrence relation we get O(log n) recursive calls. O(1) time over O(log n) recursive calls results in a total running time of O(log n).\\n* Space Complexity O(log n)\\nBy applying the master theorem to our recurrence relation we get O(log n) recursive calls. Each recursive call has itself and corresponding intermediate variable on the call stack, resulting in O(1) space complexity for each function call. O(1) memory over O(log n) recursive calls results in a total memory usage of O(log n).",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Memoization",
                    "Iterator"
                ],
                "code": "```\\nfunction pow(x, n)\\n\\tIf n equals 0\\n\\t\\treturn 1\\n\\n\\tIf n is negative\\n\\t\\tnegative_flag = True\\n\\t\\tn = |n|\\n\\n\\trepeated_multiplication = x\\n\\tFor i in [1, n]\\n\\t\\trepeated_multiplication *= x\\n\\n\\tif negative_flag\\n\\t\\treturn (1 / repeated_multiplication)\\n\\treturn repeated_multiplication\\n```\n```\\ndef pow(x, n):\\n\\t# Take care of our unique base case\\n\\tif (n == 0):\\n\\t\\treturn 1\\n\\t\\n\\t# Take care of our negative case\\n\\tnegative_exponent = False\\n\\tif (n < 0):\\n\\t\\tnegative_exponent = True\\n\\t\\tn *= -1\\n\\t\\n\\t# Do the shared, repeated multiplication\\n\\trepeated_multiplication = x\\n\\tfor i in range(1, n):\\n\\t\\trepeated_multiplication *= x\\n\\t\\n\\t# Return 1 / repeated_multiplication if our original exponent was negative\\n\\tif (negative_exponent):\\n\\t\\treturn (1 / repeated_multiplication)\\n\\t# Return the normal repeated_multiplication otherwise\\n\\treturn repeated_multiplication\\n```\n```\\nfunction repeated_multiplication(x, n)\\n\\tif n equals 0\\n\\t\\treturn 1\\n\\tintermediate = repeated_multiplication(x, floor(n / 2))\\n\\tif n is even\\n\\t\\treturn intermediate * intermediate\\n\\treturn intermediate * intermediate * x\\n```\n```\\ndef repeated_multiplication(base, exponent):\\n\\tif (exponent == 0):\\n\\t\\treturn 1\\n\\tintermediate = repeated_multiplication(base, exponent // 2)\\n\\tif ((exponent % 2) == 0):\\n\\t\\treturn intermediate * intermediate\\n\\treturn intermediate * intermediate * base\\n\\ndef pow(x, n):\\n\\t# The repeated_multiplication helper function takes care of n = 0 case\\n\\t\\n\\t# Take care of the negative case\\n\\tif (n < 0):\\n\\t\\treturn (1 / repeated_multiplication(x, n * -1))\\n\\t\\n\\t# Take care of the nonnegative case\\n\\treturn repeated_multiplication(x, n)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2151812,
                "title": "c-5-lines-of-code-runtime-0-ms-faster-than-100-00",
                "content": "```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double res = 1;\\n        while (n) {\\n            if (n % 2) res = n > 0 ? res * x : res / x;\\n            x = x * x;\\n            n /= 2;\\n        }\\n        return res;\\n    }\\n\\t//If you like please upvote for others help\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/80e6a992-cbf9-493f-b7f7-8ecd277dcbf5_1655222885.2281206.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double res = 1;\\n        while (n) {\\n            if (n % 2) res = n > 0 ? res * x : res / x;\\n            x = x * x;\\n            n /= 2;\\n        }\\n        return res;\\n    }\\n\\t//If you like please upvote for others help\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909442,
                "title": "100-fastest-swift-solution-time-o-log-n-space-o-log-n",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(log n), where n is the power value.\\n    //   - space: O(log n), where n is the power value.\\n    \\n    func myPow(_ x: Double, _ n: Int) -> Double {\\n        guard n != 0 else { return 1 }\\n\\n        var x = x\\n        var n = n\\n\\n        if n < 0 {\\n            n = -n\\n            x = 1 / x\\n        }\\n        return n % 2 == 0 ? myPow(x * x, n / 2) : x * myPow(x * x, n / 2)\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(log n), where n is the power value.\\n    //   - space: O(log n), where n is the power value.\\n    \\n    func myPow(_ x: Double, _ n: Int) -> Double {\\n        guard n != 0 else { return 1 }\\n\\n        var x = x\\n        var n = n\\n\\n        if n < 0 {\\n            n = -n\\n            x = 1 / x\\n        }\\n        return n % 2 == 0 ? myPow(x * x, n / 2) : x * myPow(x * x, n / 2)\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 165467,
                "title": "java-python-logical-thinking",
                "content": "```\\nx^n\\n= x * (x ^ (n - 1)) // cool, but not fast enough\\n\\n= (x * x) ^ (n / 2) // perfect if n is positive even \\n= x * (x * x) ^ (n / 2) // perfect if n is positive odd\\n\\nif n is negative, we use -n instead and get reciprocal at last.\\n```\\n****\\n**Java**\\n```\\n    public double myPow(double x, int n) {\\n        if (n < 0)\\n            return 1 / myPowFrom(x, -n);\\n        \\n        return myPowFrom(x, n);\\n    }\\n    \\n    private double myPowFrom(double x, int n) {\\n        if (n == 0)\\n            return 1;\\n\\n        return n % 2 == 0 \\n            ? myPowFrom(x * x, n / 2) \\n            : myPowFrom(x * x, n / 2) * x;\\n    }\\n```\\n**Python**\\n```\\n    def myPow(self, x, n):\\n        if n < 0:\\n            return 1 / self.myPowRecur(x, -n)\\n        return self.myPowRecur(x, n)\\n        \\n    def myPowRecur(self, x, n):\\n        # Base case.\\n        if n == 0:\\n            return 1\\n        \\n        if n % 2 == 0:\\n            return self.myPowRecur(x * x, int(n / 2))\\n        # else:\\n        return x * self.myPowRecur(x * x, int(n / 2))\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\nx^n\\n= x * (x ^ (n - 1)) // cool, but not fast enough\\n\\n= (x * x) ^ (n / 2) // perfect if n is positive even \\n= x * (x * x) ^ (n / 2) // perfect if n is positive odd\\n\\nif n is negative, we use -n instead and get reciprocal at last.\\n```\n```\\n    public double myPow(double x, int n) {\\n        if (n < 0)\\n            return 1 / myPowFrom(x, -n);\\n        \\n        return myPowFrom(x, n);\\n    }\\n    \\n    private double myPowFrom(double x, int n) {\\n        if (n == 0)\\n            return 1;\\n\\n        return n % 2 == 0 \\n            ? myPowFrom(x * x, n / 2) \\n            : myPowFrom(x * x, n / 2) * x;\\n    }\\n```\n```\\n    def myPow(self, x, n):\\n        if n < 0:\\n            return 1 / self.myPowRecur(x, -n)\\n        return self.myPowRecur(x, n)\\n        \\n    def myPowRecur(self, x, n):\\n        # Base case.\\n        if n == 0:\\n            return 1\\n        \\n        if n % 2 == 0:\\n            return self.myPowRecur(x * x, int(n / 2))\\n        # else:\\n        return x * self.myPowRecur(x * x, int(n / 2))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2781323,
                "title": "pow-x-n-using-recursion-100-faster",
                "content": "![image](https://assets.leetcode.com/users/images/073f4e42-78dc-4b6c-be1c-d57df5a51b11_1668528704.7679865.png)\\n\\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        if(n==0) return 1;\\n      if(n<0){\\n       n = abs(n);\\n        x = 1/x;\\n      }\\n      if(n%2==0) return myPow(x*x,n/2);\\n      else return x*myPow(x,n-1);\\n    }\\n};\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        if(n==0) return 1;\\n      if(n<0){\\n       n = abs(n);\\n        x = 1/x;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 2103223,
                "title": "c-solutions-4-approaches-brute-optimal-space-optimal",
                "content": "**1. Brute Force\\nCODE:**\\n\\n\\t // Brute Force TC - O(n) SC - O(1)\\n\\t\\t double myPow(double x, int n) {\\n\\t\\t\\tdouble ans = 1.0;\\n\\t\\t\\tfor(int i = 1; i <= abs(n); i++) {\\n\\t\\t\\t\\tans = ans * x;\\n\\t\\t\\t}\\n\\t\\t\\tif(n < 0)\\n\\t\\t\\t\\treturn 1/ans;\\n\\t\\t\\t return ans;\\n\\t\\t}\\n\\n**2. Recursive\\nCODE:**\\n\\n\\t\\t// Recursive Solution TC - O(logn) SC - O(logn)\\n\\t\\tdouble solve(double x, long long int n) {\\n\\t\\t\\tif(n == 0)\\n\\t\\t\\t\\treturn 1.0;\\n\\t\\t\\tif(n % 2 == 0)\\n\\t\\t\\t\\treturn solve(x * x, n/2);\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn (x * solve(x, n-1));\\n\\t\\t}\\n\\t\\tdouble myPow(double x, int n) {\\n\\t\\t\\tdouble ans = 1.0;\\n\\t\\t\\tlong long int temp = abs(n);\\n\\t\\t\\tans = solve(x, temp);\\n\\t\\t\\tif(n<0)\\n\\t\\t\\t\\tans = 1/(ans);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n**3. Iterative \\nCODE:**\\n\\n\\t // Iterative Solution  TC - O(logn) SC - O(1)\\n\\t\\tdouble myPow(double x, int n) {\\n\\t\\t\\tdouble ans = 1.0;\\n\\t\\t\\tlong long temp = abs(n);\\n\\t\\t\\twhile(temp) {\\n\\t\\t\\t\\tif(temp % 2 != 0) {\\n\\t\\t\\t\\t\\tans = ans * x;      // 4 ^ 3  --> 4 * (4)^2\\n\\t\\t\\t\\t\\ttemp = temp - 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tx = x * x;         // 2 ^ 10 --> (2 * 2) ^ 5   i.e  x = x * x, n = n / 2\\n\\t\\t\\t\\t\\ttemp = temp / 2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(n<0)\\n\\t\\t\\t\\tans = 1/ans;\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\t\\n**4. Standard Library Function\\nCODE:**\\n\\n\\t// Using Standard Library Function TC - O(logn) SC - O(1)\\n\\t\\tdouble myPow(double x, int n) {\\n\\t\\t\\treturn (double)pow(x, n);\\n\\t\\t}",
                "solutionTags": [
                    "C",
                    "Math",
                    "Recursion"
                ],
                "code": "**1. Brute Force\\nCODE:**\\n\\n\\t // Brute Force TC - O(n) SC - O(1)\\n\\t\\t double myPow(double x, int n) {\\n\\t\\t\\tdouble ans = 1.0;\\n\\t\\t\\tfor(int i = 1; i <= abs(n); i++) {\\n\\t\\t\\t\\tans = ans * x;\\n\\t\\t\\t}\\n\\t\\t\\tif(n < 0)\\n\\t\\t\\t\\treturn 1/ans;\\n\\t\\t\\t return ans;\\n\\t\\t}\\n\\n**2. Recursive\\nCODE:**\\n\\n\\t\\t// Recursive Solution TC - O(logn) SC - O(logn)\\n\\t\\tdouble solve(double x, long long int n) {\\n\\t\\t\\tif(n == 0)\\n\\t\\t\\t\\treturn 1.0;\\n\\t\\t\\tif(n % 2 == 0)\\n\\t\\t\\t\\treturn solve(x * x, n/2);\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn (x * solve(x, n-1));\\n\\t\\t}\\n\\t\\tdouble myPow(double x, int n) {\\n\\t\\t\\tdouble ans = 1.0;\\n\\t\\t\\tlong long int temp = abs(n);\\n\\t\\t\\tans = solve(x, temp);\\n\\t\\t\\tif(n<0)\\n\\t\\t\\t\\tans = 1/(ans);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n**3. Iterative \\nCODE:**\\n\\n\\t // Iterative Solution  TC - O(logn) SC - O(1)\\n\\t\\tdouble myPow(double x, int n) {\\n\\t\\t\\tdouble ans = 1.0;\\n\\t\\t\\tlong long temp = abs(n);\\n\\t\\t\\twhile(temp) {\\n\\t\\t\\t\\tif(temp % 2 != 0) {\\n\\t\\t\\t\\t\\tans = ans * x;      // 4 ^ 3  --> 4 * (4)^2\\n\\t\\t\\t\\t\\ttemp = temp - 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tx = x * x;         // 2 ^ 10 --> (2 * 2) ^ 5   i.e  x = x * x, n = n / 2\\n\\t\\t\\t\\t\\ttemp = temp / 2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(n<0)\\n\\t\\t\\t\\tans = 1/ans;\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\t\\n**4. Standard Library Function\\nCODE:**\\n\\n\\t// Using Standard Library Function TC - O(logn) SC - O(1)\\n\\t\\tdouble myPow(double x, int n) {\\n\\t\\t\\treturn (double)pow(x, n);\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 19756,
                "title": "lg-n-320ms-javasolution-9-lines",
                "content": "// main code is the the last line. \\n\\n\\npublic class Solution {\\n    public double pow(double x, int n) {\\n\\n        if (x == 0) return 0; \\n        if (x == 1) return 1;\\n        if (n == 0) return 1; \\n        if (n == 1) return x;\\n        if (x == -1) return (n % 2) == 0 ? 1 : -1; \\n        if (n < 0 ) return 1/ pow (x, -n);\\n        if (n == 2) return x * x;\\n        \\n        int halfPow = n/2; \\n\\n        return pow(pow(x,halfPow),2) * pow(x, n%2); \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public double pow(double x, int n) {\\n\\n        if (x == 0) return 0; \\n        if (x == 1) return 1;\\n        if (n == 0) return 1; \\n        if (n == 1) return x;\\n        if (x == -1) return (n % 2) == 0 ? 1 : -1; \\n        if (n < 0 ) return 1/ pow (x, -n);\\n        if (n == 2) return x * x;\\n        \\n        int halfPow = n/2; \\n\\n        return pow(pow(x,halfPow),2) * pow(x, n%2); \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2681500,
                "title": "java-basic-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public double myPow(double x, int n) {\\n    if(n == 0) return 1;\\n    if(n < 0) {\\n       return ((1 / x) * (myPow(1 / x, -(n + 1))));\\n    } \\n    return (n % 2 == 0) ? myPow(x * x, n / 2) : x * myPow(x * x, n / 2); \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double myPow(double x, int n) {\\n    if(n == 0) return 1;\\n    if(n < 0) {\\n       return ((1 / x) * (myPow(1 / x, -(n + 1))));\\n    } \\n    return (n % 2 == 0) ? myPow(x * x, n / 2) : x * myPow(x * x, n / 2); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1891099,
                "title": "python3-iteration-log-n-time-fast-easy-understanding",
                "content": "**If you like please upvote** \\u2764\\uD83D\\uDE80\\uD83D\\uDE80\\n```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        \\n        if n == 0: return 1\\n        nege = False\\n        \\n        if n < 0: \\n            nege = True\\n            n *= -1\\n        \\n        res = 1\\n        while n:\\n            if n % 2:\\n                res *= x\\n                n -= 1\\n            else:\\n                x *= x\\n                n = n//2\\n                \\n        if nege: return 1/res\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        \\n        if n == 0: return 1\\n        nege = False\\n        \\n        if n < 0: \\n            nege = True\\n            n *= -1\\n        \\n        res = 1\\n        while n:\\n            if n % 2:\\n                res *= x\\n                n -= 1\\n            else:\\n                x *= x\\n                n = n//2\\n                \\n        if nege: return 1/res\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513227,
                "title": "python-pure-recursion-with-memoization",
                "content": "```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        \\n        memo = {}      \\n        def power(x,n):\\n            if n in memo:return memo[n]\\n            if n==0: return 1\\n            elif n==1:return x\\n            elif n < 0:\\n                memo[n] = power(1/x,-n)\\n                return memo[n]\\n            elif n%2==0:\\n                memo[n] = power(x*x,n//2)\\n                return memo[n]\\n            else:\\n                memo[n] = x * power(x*x,(n-1)//2)\\n                return memo[n]\\n            \\n        return power(x,n)\\n```\\n\\n# \\u2714\\uFE0F Upvote will be appriciated",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        \\n        memo = {}      \\n        def power(x,n):\\n            if n in memo:return memo[n]\\n            if n==0: return 1\\n            elif n==1:return x\\n            elif n < 0:\\n                memo[n] = power(1/x,-n)\\n                return memo[n]\\n            elif n%2==0:\\n                memo[n] = power(x*x,n//2)\\n                return memo[n]\\n            else:\\n                memo[n] = x * power(x*x,(n-1)//2)\\n                return memo[n]\\n            \\n        return power(x,n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054687,
                "title": "python-simple-easy-understanding-solution-o-log-n",
                "content": "\\tclass Solution:\\n\\t\\tdef myPow(self, x: float, n: int) -> float:\\n\\t\\t\\tif n == 0: return 1\\n\\t\\t\\tif n < 0: n, x = -n, 1 / x\\n\\t\\t\\tlower = self.myPow(x, n//2)\\n\\t\\t\\treturn lower * lower * x if n % 2 else lower * lower",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef myPow(self, x: float, n: int) -> float:\\n\\t\\t\\tif n == 0: return 1\\n\\t\\t\\tif n < 0: n, x = -n, 1 / x\\n\\t\\t\\tlower = self.myPow(x, n//2)\\n\\t\\t\\treturn lower * lower * x if n % 2 else lower * lower",
                "codeTag": "Java"
            },
            {
                "id": 542477,
                "title": "javascript-o-log2-n",
                "content": "**algorithm**\\n- Base Case: `if (n === 0)  return 1;`\\n- Recurrence Relation: `N**N = N**(N/2 x 2) = N**(N/2) x N**(N/2)`\\n\\n**complexity**\\n- Time Complexity: O(log2 N)\\n- Space Complexity: O(log2 N)\\n```JavaScript\\n/**\\n * @param {number} x\\n * @param {number} n\\n * @return {number}\\n */\\nvar myPow = function(x, n) {\\n    if (n < 0) {\\n        x = 1 / x;\\n        n = -n;\\n    }\\n    return pow(x, n);\\n    \\n    function pow(x, n) {\\n        if (n == 0) {\\n            return 1.0;\\n        }\\n        const half = pow(x, parseInt(n / 2));\\n        if (n % 2 === 0) {\\n            return half * half;\\n        } else {\\n            return half * half * x;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```JavaScript\\n/**\\n * @param {number} x\\n * @param {number} n\\n * @return {number}\\n */\\nvar myPow = function(x, n) {\\n    if (n < 0) {\\n        x = 1 / x;\\n        n = -n;\\n    }\\n    return pow(x, n);\\n    \\n    function pow(x, n) {\\n        if (n == 0) {\\n            return 1.0;\\n        }\\n        const half = pow(x, parseInt(n / 2));\\n        if (n % 2 === 0) {\\n            return half * half;\\n        } else {\\n            return half * half * x;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 234748,
                "title": "c-recursive-and-iterative",
                "content": "[This post](https://leetcode.com/problems/powx-n/discuss/19546/Short-and-easy-to-understand-solution) shares a very neat recursive solution, which is rewritten in C++ below.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        if (!n) {\\n            return 1.0;\\n        }\\n        long p = labs(n);\\n        double power = myPow(x * x, p / 2) * (p % 2 ? x : 1);\\n        return n > 0 ? power : 1 / power;\\n    }\\n};\\n```\\n\\nAnd it can also be made iterative.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        long p = labs(n);\\n        double pow = 1;\\n        while (p) {\\n            if (p % 2) {\\n                pow *= x;\\n            }\\n            x *= x;\\n            p /= 2;\\n        }\\n        return n > 0 ? pow : 1 / pow;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        if (!n) {\\n            return 1.0;\\n        }\\n        long p = labs(n);\\n        double power = myPow(x * x, p / 2) * (p % 2 ? x : 1);\\n        return n > 0 ? power : 1 / power;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        long p = labs(n);\\n        double pow = 1;\\n        while (p) {\\n            if (p % 2) {\\n                pow *= x;\\n            }\\n            x *= x;\\n            p /= 2;\\n        }\\n        return n > 0 ? pow : 1 / pow;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19682,
                "title": "5-lines-python-recursive-solution",
                "content": "    class Solution(object):\\n    def myPow(self, x, n):\\n        if n == 0: \\n            return 1\\n        if n == -1: \\n            return 1 / x\\n        return self.myPow(x * x, n / 2) * ([1, x][n % 2])",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n    def myPow(self, x, n):\\n        if n == 0: \\n            return 1\\n        if n == -1: \\n            return 1 / x\\n        return self.myPow(x * x, n / 2) * ([1, x][n % 2])",
                "codeTag": "Java"
            },
            {
                "id": 3086124,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        if(n==0)\\n            return 1;\\n        if(n==INT_MIN)\\n        {\\n            x*=x;\\n            n/=2;\\n        }\\n        if(n<0)\\n        {\\n            n=-n;\\n            x= 1/x;\\n        }\\n        if(n%2==0)\\n            return myPow(x*x, n/2);\\n        else\\n            return x*myPow(x*x, n/2);\\n                \\n        \\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        if(n==0)\\n            return 1;\\n        if(n==INT_MIN)\\n        {\\n            x*=x;\\n            n/=2;\\n        }\\n        if(n<0)\\n        {\\n            n=-n;\\n            x= 1/x;\\n        }\\n        if(n%2==0)\\n            return myPow(x*x, n/2);\\n        else\\n            return x*myPow(x*x, n/2);\\n                \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826259,
                "title": "python3-zero-line-solution-kind-of",
                "content": "# Code (0 line)\\n```\\nclass Solution:\\n    myPow = pow\\n```\\nthis *has* to be the shortest yet\\n\\nupvote if u liked it",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    myPow = pow\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1559121,
                "title": "50-pow-x-n-java-solution",
                "content": "```\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        double output = 1d;\\n        long power = n;\\n        if(power < 0){\\n            power = -1 * power;\\n        }\\n        while(power > 0){\\n            if(power % 2 == 1){\\n                output = output * x;\\n                power = power - 1;\\n            } else {\\n                x = x * x;\\n                power = power / 2;\\n            }\\n        }\\n        if(n<0){\\n            output = (double)(1.0) / (double)(output);\\n        }\\n        return output;\\n    }\\n}\\n```\\n\\nIf it helped, please UPVOTE. Happy Coding and keep up the good work.\\nFeel free to give your suggestions or correct me in the comments.\\nThanks for reading.\\uD83D\\uDE43",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        double output = 1d;\\n        long power = n;\\n        if(power < 0){\\n            power = -1 * power;\\n        }\\n        while(power > 0){\\n            if(power % 2 == 1){\\n                output = output * x;\\n                power = power - 1;\\n            } else {\\n                x = x * x;\\n                power = power / 2;\\n            }\\n        }\\n        if(n<0){\\n            output = (double)(1.0) / (double)(output);\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502857,
                "title": "c-simple-log-n-solution-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/powx-n/\\n    TC: O(log2n)\\n*/\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        // base case\\n        // +ve power\\n        if(n == 0 || n == 1)\\n            return n == 0 ? 1 : x;\\n        // -ve power\\n        if(n == -1)\\n            return 1 / x;\\n        \\n        double power = myPow(x, n/2);\\n        // if power n is even\\n        if(n % 2 == 0)\\n            return power * power;\\n        // odd power\\n        else {\\n            return power * power * (n < 0 ? (1 / x) : x);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/powx-n/\\n    TC: O(log2n)\\n*/\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        // base case\\n        // +ve power\\n        if(n == 0 || n == 1)\\n            return n == 0 ? 1 : x;\\n        // -ve power\\n        if(n == -1)\\n            return 1 / x;\\n        \\n        double power = myPow(x, n/2);\\n        // if power n is even\\n        if(n % 2 == 0)\\n            return power * power;\\n        // odd power\\n        else {\\n            return power * power * (n < 0 ? (1 / x) : x);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19731,
                "title": "my-solution-in-java-using-divide-and-conquer",
                "content": "    public class Solution {\\n        public double myPow(double x, int n) {\\n            double res=1;\\n            while(n!=0)\\n            {\\n                if(n%2==0)\\n                {\\n                    \\n                    x=x*x;\\n                    n/=2;\\n                }\\n                else\\n                {\\n                    if(n>0)\\n                    {\\n                        res*=x;\\n                        n--;\\n                    }\\n                    else\\n                    {\\n                        res/=x;\\n                        n++;\\n                    }\\n                }\\n            }\\n            return res;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public double myPow(double x, int n) {\\n            double res=1;\\n            while(n!=0)\\n            {\\n                if(n%2==0)\\n                {\\n                    \\n                    x=x*x;\\n                    n/=2;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 19728,
                "title": "my-c-code-accepted-with-0ms",
                "content": "    double myPow(double x, int n){  \\n       if(n == 0)\\n         return 1;\\n       double t = myPow(x, n/2);\\n       if(n % 2 == 0)\\n            return t*t;\\n       else{\\n          if(n > 0)\\n             return x*t*t;\\n          else \\n            return (t*t) / x;\\n      }\\n    }",
                "solutionTags": [],
                "code": "    double myPow(double x, int n){  \\n       if(n == 0)\\n         return 1;\\n       double t = myPow(x, n/2);\\n       if(n % 2 == 0)\\n            return t*t;\\n       else{\\n          if(n > 0)\\n             return x*t*t;\\n          else \\n            return (t*t) / x;\\n      }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 19583,
                "title": "my-answer-bit-operation-o-1",
                "content": "    class Solution {\\n    public:\\n        double pow(double x, int n) {\\n            double res=1;\\n             if(n<0){\\n                x=1/x;\\n                n=-n;\\n            }\\n            while(n>0){\\n                if(n&1==1){\\n                    res=res*x;\\n                }\\n                x*=x;\\n                n=n>>1;\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        double pow(double x, int n) {\\n            double res=1;\\n             if(n<0){\\n                x=1/x;\\n                n=-n;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3811172,
                "title": "ex-amazon-explains-a-solution-with-a-video-python-javascript-java-and-c",
                "content": "# Solution Video\\n## *** Please upvote for this article. *** \\n\\nhttps://youtu.be/wxQ9ig_Nd8s\\n\\n# Subscribe to my channel from here. I have 229 videos as of July 25th\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\n---\\n\\n# Approach\\nThis is based on Python Code. Other language might be different a bit.\\n\\n1. Define the `myPow` function that takes two parameters: `x` (the base) and `n` (the exponent). The function returns the value of `x` raised to the power of `n`.\\n\\n2. Define a helper function `calc_power(x, n)` that will be used for the recursive calculation. This function takes two parameters: `x` (the base) and `n` (the exponent).\\n\\n3. In the `calc_power` function:\\n   - Check the base case: If `x` is 0, return 0 (as anything raised to the power of 0 is 1).\\n   - Check another base case: If `n` is 0, return 1 (as anything raised to the power of 0 is 1).\\n   - If `n` is even, recursively calculate `res` by calling `calc_power(x, n // 2)` and then square `res` (`res = res * res`).\\n   - If `n` is odd, recursively calculate `res` by calling `calc_power(x, (n - 1) // 2)` and then square `res`, finally multiply it with `x` (`res = res * res * x`).\\n\\n4. Now, in the `myPow` function:\\n   - Get the absolute value of `n` using `abs(n)` and store it in a variable `abs_n`.\\n   - Calculate `ans` by calling `calc_power(x, abs_n)`, which gives us the value of `x` raised to the power of `abs_n`.\\n\\n5. If `n` is non-negative (`n >= 0`), return `ans`.\\n   - If `n` is negative (`n < 0`), return `1 / ans` (which gives us the result of `x` raised to the power of `-n`, i.e., the reciprocal).\\n\\nThe algorithm takes advantage of the properties of exponents and the concept that x^(n) can be calculated using x^(n/2) to avoid redundant calculations and improve the efficiency of the power calculation.\\n\\n```python []\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n\\n        def calc_power(x, n):\\n            if x == 0:\\n                return 0\\n            if n == 0:\\n                return 1\\n            \\n            res = calc_power(x, n // 2)\\n            res = res * res\\n\\n            if n % 2 == 1:\\n                return res * x\\n            \\n            return res\\n\\n        ans = calc_power(x, abs(n))\\n\\n        if n >= 0:\\n            return ans\\n        \\n        return 1 / ans \\n```\\n```javascript []\\nfunction myPow(x, n) {\\n    function calc_power(x, n) {\\n        if (x === 0) {\\n            return 0;\\n        }\\n        if (n === 0) {\\n            return 1;\\n        }\\n\\n        let res = calc_power(x, Math.floor(n / 2));\\n        res = res * res;\\n\\n        if (n % 2 === 1) {\\n            return res * x;\\n        }\\n\\n        return res;\\n    }\\n\\n    let ans = calc_power(x, Math.abs(n));\\n\\n    if (n >= 0) {\\n        return ans;\\n    }\\n\\n    return 1 / ans;\\n}\\n```\\n```java []\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        return binaryExp(x, (long) n);\\n    }\\n\\n    private double binaryExp(double x, long n) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n       \\n        if (n < 0) {\\n            return 1.0 / binaryExp(x, -n);\\n        }\\n       \\n        if (n % 2 == 1) {\\n            return x * binaryExp(x * x, (n - 1) / 2);\\n        } else {\\n            return binaryExp(x * x, n / 2);\\n        }\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        return binaryExp(x, static_cast<long>(n));\\n    }\\n\\nprivate:\\n    double binaryExp(double x, long n) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n       \\n        if (n < 0) {\\n            return 1.0 / binaryExp(x, -n);\\n        }\\n       \\n        if (n % 2 == 1) {\\n            return x * binaryExp(x * x, (n - 1) / 2);\\n        } else {\\n            return binaryExp(x * x, n / 2);\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n\\n        def calc_power(x, n):\\n            if x == 0:\\n                return 0\\n            if n == 0:\\n                return 1\\n            \\n            res = calc_power(x, n // 2)\\n            res = res * res\\n\\n            if n % 2 == 1:\\n                return res * x\\n            \\n            return res\\n\\n        ans = calc_power(x, abs(n))\\n\\n        if n >= 0:\\n            return ans\\n        \\n        return 1 / ans \\n```\n```javascript []\\nfunction myPow(x, n) {\\n    function calc_power(x, n) {\\n        if (x === 0) {\\n            return 0;\\n        }\\n        if (n === 0) {\\n            return 1;\\n        }\\n\\n        let res = calc_power(x, Math.floor(n / 2));\\n        res = res * res;\\n\\n        if (n % 2 === 1) {\\n            return res * x;\\n        }\\n\\n        return res;\\n    }\\n\\n    let ans = calc_power(x, Math.abs(n));\\n\\n    if (n >= 0) {\\n        return ans;\\n    }\\n\\n    return 1 / ans;\\n}\\n```\n```java []\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        return binaryExp(x, (long) n);\\n    }\\n\\n    private double binaryExp(double x, long n) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n       \\n        if (n < 0) {\\n            return 1.0 / binaryExp(x, -n);\\n        }\\n       \\n        if (n % 2 == 1) {\\n            return x * binaryExp(x * x, (n - 1) / 2);\\n        } else {\\n            return binaryExp(x * x, n / 2);\\n        }\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        return binaryExp(x, static_cast<long>(n));\\n    }\\n\\nprivate:\\n    double binaryExp(double x, long n) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n       \\n        if (n < 0) {\\n            return 1.0 / binaryExp(x, -n);\\n        }\\n       \\n        if (n % 2 == 1) {\\n            return x * binaryExp(x * x, (n - 1) / 2);\\n        } else {\\n            return binaryExp(x * x, n / 2);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469256,
                "title": "python-easy-to-understand",
                "content": "2^-1 = 1 / 2^1\\n2^4 = 2 * 2 * 2 * 2 = (2^2)^2 = half * half \\n2^5 = 2 * 2 * 2 * 2 * 2 = 2 * (2^2)^2 = 2 * half * half\\n\\n```\\n    def myPow(self, x: float, n: int) -> float:\\n        if n == 0:\\n            return 1\\n\\n        if n < 0:\\n            return 1 / self.myPow(x, -n)\\n\\n        half = self.myPow(x, n // 2)\\n        if n % 2 == 0:\\n            return half * half\\n\\n        return x * half * half\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n    def myPow(self, x: float, n: int) -> float:\\n        if n == 0:\\n            return 1\\n\\n        if n < 0:\\n            return 1 / self.myPow(x, -n)\\n\\n        half = self.myPow(x, n // 2)\\n        if n % 2 == 0:\\n            return half * half\\n\\n        return x * half * half\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2275484,
                "title": "c-0ms-beats-100-optimized",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Time Complexity : `O(logN)`**\\n\\n* Initialize ans as 1.0  and store a duplicate copy of n i.e power_of_x and make it positive.\\n* In a while loop keep on iterating until power_of_x becomes zero\\n* Now if power_of_x is an odd power then multiply x with ans ans reduce power_of_x by 1. Else multiply x with itself and divide power_of_x by 2.\\n* Now the entire binary exponentiation is complete and power_of_x becomes zero\\n* Check if n is a negative value, return 1/ans else return ans.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    double myPow(double x, int n) {\\n        double ans = 1.0;\\n        long long power_of_x = abs(n);\\n        \\n        while(power_of_x>0)\\n        {\\n            // if power is odd\\n            if(power_of_x%2==1)\\n            {\\n                ans = ans*x;\\n                power_of_x = power_of_x - 1;\\n            }\\n            // if power is even\\n            else if(power_of_x%2==0)\\n            {\\n                x = x*x;\\n                power_of_x = power_of_x / 2;\\n            }\\n        }\\n        \\n        if(n<0)\\n            return (double)1/(double)ans;\\n        \\n        return (double)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    double myPow(double x, int n) {\\n        double ans = 1.0;\\n        long long power_of_x = abs(n);\\n        \\n        while(power_of_x>0)\\n        {\\n            // if power is odd\\n            if(power_of_x%2==1)\\n            {\\n                ans = ans*x;\\n                power_of_x = power_of_x - 1;\\n            }\\n            // if power is even\\n            else if(power_of_x%2==0)\\n            {\\n                x = x*x;\\n                power_of_x = power_of_x / 2;\\n            }\\n        }\\n        \\n        if(n<0)\\n            return (double)1/(double)ans;\\n        \\n        return (double)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19607,
                "title": "concise-c-solution",
                "content": "    public class Solution {\\n        public double MyPow(double x, int n) {\\n            if(n == 0) return 1;\\n            if(n == 1) return x;\\n            if(n == -1) return 1/x;\\n            \\n            var a = MyPow(x, n/2);\\n            return a * a * MyPow(x, n % 2);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public double MyPow(double x, int n) {\\n            if(n == 0) return 1;\\n            if(n == 1) return x;\\n            if(n == -1) return 1/x;\\n            \\n            var a = MyPow(x, n/2);\\n            return a * a * MyPow(x, n % 2);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3810572,
                "title": "100-recursion-js-sol-explained-with-intuition-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n-     Recursive Approach.\\n- This approach is very efficient because it breaks down the problem of computing **$$x^n$$** into smaller and smaller subproblems. \\n- The base case of the recursion is when **n = 0**, in which case the function simply returns **1**.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. The function checks if **n** is equal to 0. \\n2. If it is, then the function simply returns **1**.\\n3. Otherwise, the function checks if **n** is negative. \\n4. If it is, then the function negates **x** and sets **n** to the absolute value of **n**.\\n5. The function then checks if **n** is even. \\n6. If it is, then the function ***recursively*** calls itself to compute $$x^(n/2)$$. \\n7. The result of this recursive call is then multiplied by itself to compute $$x^n$$.\\n8. Otherwise, the function returns $$x * myPow(x, n - 1)$$.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n1. This is because the function recursively calls itself, halving the value of n each time. \\n2. The worst-case scenario is when n is a power of 2, in which case the function will make log n recursive calls.\\n\\n\\n\\n\\n\\n\\n\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n1. Because the function only stores a few local variables, and the recursive calls do not create any new objects.\\n2. So, the space complexity is not affected by the value of n.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\n/**\\n * @param {number} x\\n * @param {number} n\\n * @return {number}\\n */\\nvar myPow = function(x, n) {\\n  \\n  if (n === 0) {\\n    return 1;\\n  }\\n\\n  if (n < 0) {\\n    x = 1 / x;\\n    n = -n;\\n  }\\n\\n  if (n % 2 === 0) {\\n    \\n    let halfPower = myPow(x, n / 2);\\n    return halfPower * halfPower;\\n  }\\n  else {\\n    return x * myPow(x, n - 1);\\n  }  \\n};\\n```\\n\\n![cat img for upvote on LC.jpeg](https://assets.leetcode.com/users/images/27fedcbf-ed2a-4b6d-85fa-270ae74e0572_1690212326.246199.jpeg)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number} x\\n * @param {number} n\\n * @return {number}\\n */\\nvar myPow = function(x, n) {\\n  \\n  if (n === 0) {\\n    return 1;\\n  }\\n\\n  if (n < 0) {\\n    x = 1 / x;\\n    n = -n;\\n  }\\n\\n  if (n % 2 === 0) {\\n    \\n    let halfPower = myPow(x, n / 2);\\n    return halfPower * halfPower;\\n  }\\n  else {\\n    return x * myPow(x, n - 1);\\n  }  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3807795,
                "title": "beats-100-video-java-c-python",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/ibyQI7Lo87Q\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        if (n < 0) return 1.0 / pow(x, static_cast<long>(-n));\\n        return pow(x, static_cast<long>(n));\\n    }\\n    \\n    double pow(double x, long n) {\\n        if (n == 0) return 1;\\n        if (n % 2 == 0) return pow(x * x, n / 2);\\n        else return x * pow(x * x, (n - 1) / 2);\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        if (n < 0) return 1.0 / pow(x, (long long)-1*n);\\n        return pow(x, (long long) n);\\n    }\\n    \\n    double pow(double x, long long n) {\\n        if (n == 0) return 1;\\n        if (n % 2 == 0) return pow(x * x, n / 2);\\n        else return x * pow(x * x, (n - 1) / 2);\\n    }\\n};\\n\\n```\\n\\n```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n < 0:\\n            return 1.0 / self.pow(x, -n)\\n        return self.pow(x, n)\\n    \\n    def pow(self, x: float, n: int) -> float:\\n        if n == 0:\\n            return 1.0\\n        if n % 2 == 0:\\n            return self.pow(x * x, n // 2)\\n        else:\\n            return x * self.pow(x * x, (n - 1) // 2)\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        if (n < 0) return 1.0 / pow(x, static_cast<long>(-n));\\n        return pow(x, static_cast<long>(n));\\n    }\\n    \\n    double pow(double x, long n) {\\n        if (n == 0) return 1;\\n        if (n % 2 == 0) return pow(x * x, n / 2);\\n        else return x * pow(x * x, (n - 1) / 2);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        if (n < 0) return 1.0 / pow(x, (long long)-1*n);\\n        return pow(x, (long long) n);\\n    }\\n    \\n    double pow(double x, long long n) {\\n        if (n == 0) return 1;\\n        if (n % 2 == 0) return pow(x * x, n / 2);\\n        else return x * pow(x * x, (n - 1) / 2);\\n    }\\n};\\n\\n```\n```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n < 0:\\n            return 1.0 / self.pow(x, -n)\\n        return self.pow(x, n)\\n    \\n    def pow(self, x: float, n: int) -> float:\\n        if n == 0:\\n            return 1.0\\n        if n % 2 == 0:\\n            return self.pow(x * x, n // 2)\\n        else:\\n            return x * self.pow(x * x, (n - 1) // 2)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535395,
                "title": "simple-solution-c-java-with-explanation",
                "content": "# Brute force\\n<!-- Describe your approach to solving the problem. -->\\nThe brute force recursive solution is `pow(n) = n * pow(n - 1)`.\\nFor both iterative and recursive solution *time complexity:* $$O(n)$$\\nThis will get **Time Limit Exceeded** error, so we need to write a better solution than this.\\n\\n# Optimized solution\\nWe know $$ x^2 = x * x = (x * x)^1 $$\\nTo calculate $$x^2$$ recursively we will need to make 3 function calls,\\n`` f(x, 2) --> f(x, 1) --> f(x, 0) ``.\\nBut, to calculate $$ (x * x)^1 $$ we need 2 function calls, `` f(x * x, 1) --> f(x * x, 0)``.\\n\\nThis may seem like a minor change but this reduces the time complexity from linear to logarithmic. And is a significant improvement for larger power.\\n\\nFor even power ``f(x, n) = f(x * x, n / 2)``  \\nFor odd power ``f(x, n) = x * f(x, n - 1)`` \\n\\n**Negative power**\\n$$ x^{-n} = 1 / x^n$$\\n\\n*NOTE:* Dry run this algorithm for n = 5 and n = 8 (i.e., an even and odd power) for better understanding.\\n\\n# Complexity\\n- Time complexity: $$ O(log_2n) $$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$ O(log_2n) $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        \\n        if (n == 0) return 1.0;\\n        // even power\\n        if (n % 2 == 0) return myPow(x * x, n / 2);\\n        // odd power\\n        if (n % 2 == 1) return x * myPow(x, n - 1);\\n        // negative power\\n        return 1/myPow(x, -n);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        \\n        if (n == 0) return 1.0;\\n        // even power\\n        if (n % 2 == 0)\\n            return myPow(x * x, n / 2);\\n        // odd power\\n        if (n % 2 == 1)\\n            return x * myPow(x, n - 1);        \\n        // negative power\\n        return 1/myPow(x, -n);\\n    }\\n}\\n```\\n**Will you upvote the solution if it was helpful?**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Math",
                    "Recursion"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        \\n        if (n == 0) return 1.0;\\n        // even power\\n        if (n % 2 == 0) return myPow(x * x, n / 2);\\n        // odd power\\n        if (n % 2 == 1) return x * myPow(x, n - 1);\\n        // negative power\\n        return 1/myPow(x, -n);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        \\n        if (n == 0) return 1.0;\\n        // even power\\n        if (n % 2 == 0)\\n            return myPow(x * x, n / 2);\\n        // odd power\\n        if (n % 2 == 1)\\n            return x * myPow(x, n - 1);        \\n        // negative power\\n        return 1/myPow(x, -n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097532,
                "title": "beats-100-simple-c-python-java-very-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInstead of mutlipying x one by one n times do it in logn time since we can  mutliply our number x with itself and divide our n by 2 and if n is odd we multiply our ans by x beacuse on dividing n by 2 we loss some x i.e 3/2 =1 (in reality it is $$x*x*x$$) but it comes only x*x so if n is odd multiply by extra x also. \\nAlso in negative numbers just take $$x$$ as $$1/x$$ and rest is same\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterative approach\\n# Complexity\\n- Time complexity:$$O(logn)$$\\n- - Space complexity:$$O(1)$$\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        if(n==0)return 1;\\n        if(n<0)x=1/x;\\n        n=abs(n);\\n        double ans=1;\\n        while(n>0){\\n          if(n&1) ans=x*ans;\\n           x*=x;\\n           n>>=1;\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n == 0:\\n            return 1\\n        if n < 0:\\n            x = 1/x\\n        n = abs(n)\\n        ans = 1\\n        while n > 0:\\n            if n & 1:\\n                ans = x * ans\\n            x *= x\\n            n >>= 1\\n        return ans\\n\\n```\\n```Java []\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        if(n==0) return 1;\\n        if(n<0) x = 1/x;\\n        n = Math.abs(n);\\n        double ans = 1;\\n        while(n > 0) {\\n            if((n & 1) == 1) ans = x * ans;\\n            x *= x;\\n            n >>= 1;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Recursion"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        if(n==0)return 1;\\n        if(n<0)x=1/x;\\n        n=abs(n);\\n        double ans=1;\\n        while(n>0){\\n          if(n&1) ans=x*ans;\\n           x*=x;\\n           n>>=1;\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n == 0:\\n            return 1\\n        if n < 0:\\n            x = 1/x\\n        n = abs(n)\\n        ans = 1\\n        while n > 0:\\n            if n & 1:\\n                ans = x * ans\\n            x *= x\\n            n >>= 1\\n        return ans\\n\\n```\n```Java []\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        if(n==0) return 1;\\n        if(n<0) x = 1/x;\\n        n = Math.abs(n);\\n        double ans = 1;\\n        while(n > 0) {\\n            if((n & 1) == 1) ans = x * ans;\\n            x *= x;\\n            n >>= 1;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098772,
                "title": "o-log-n-using-binary-exponentiation-easy-step-by-step-explanation",
                "content": "What is Binary Exponentiation?\\nBinary exponentiation (also known as exponentiation by squaring) is a trick which allows to calculate\\npow(x,n) using only O(log n) multiplications.\\n\\nLet us take an example of pow(2,10). In the approach of normal calculation we have to run our loop 10 times. Now, what if we perform binary expo here..\\nP(2,10) \\u2014\\u2014-> (2^5)^2\\np(2,5) \\u2014\\u2014\\u2014> (2^2)^2 * 2\\nP(2,2) \\u2014\\u2014\\u2014> 2 * 2\\n\\nNow , we  can see that in this computation of the power can be done in only 3 steps.\\n\\nIn general, the algorithm will be like:\\n* \\ta) if n is odd like pow(2,3) will be (2^2)*2.\\n* \\tb)if n is even like pow(2,4) will be (2^2)^2.\\n\\t(Note: Here this sign ^ represents power not xor)\\n\\t\\nHere is the code below in Python :\\n```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n == 0: #if n is zero then result is always 1\\n          return(1.0)\\n        res = 1 # initializing res to 1\\n        t = abs(n) #storing n in a temporary variable to preserve its value\\n        while t != 0: #loop till t becomes zero\\n            if t%2 == 1: #checking if t is odd then we multiply res with x as discussed above in step (a).\\n                res *= x\\n            t >>= 1 #right shifting t so it will divide t by 2.\\n            x = x*x # calculating sq of x\\n       #Finally checking if n<0 (negative) then we return 1/res else res\\n\\t   if n < 0:\\n            return 1/res\\n        else:\\n            return res\\n\\n```\\n*Its Run Time Complexity is O(log n)*\\n\\n**Upvote if you liked the solution. Thanks..!!**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n == 0: #if n is zero then result is always 1\\n          return(1.0)\\n        res = 1 # initializing res to 1\\n        t = abs(n) #storing n in a temporary variable to preserve its value\\n        while t != 0: #loop till t becomes zero\\n            if t%2 == 1: #checking if t is odd then we multiply res with x as discussed above in step (a).\\n                res *= x\\n            t >>= 1 #right shifting t so it will divide t by 2.\\n            x = x*x # calculating sq of x\\n       #Finally checking if n<0 (negative) then we return 1/res else res\\n\\t   if n < 0:\\n            return 1/res\\n        else:\\n            return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074126,
                "title": "java-fastest-solution-easy-to-understand",
                "content": "**Please upvote if the solution helped you**\\n*Feel free to ask any questions in the comment section*\\n```\\nclass Solution {\\n    public double myPow(double x, int y) {\\n       double temp;\\n        if( y == 0)\\n            return 1;\\n        temp = myPow(x, y/2); \\n          \\n        if (y%2 == 0)\\n            return temp*temp;\\n        else\\n        {\\n            if(y > 0)\\n                return x * temp * temp;\\n            else\\n                return (temp * temp) / x;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public double myPow(double x, int y) {\\n       double temp;\\n        if( y == 0)\\n            return 1;\\n        temp = myPow(x, y/2); \\n          \\n        if (y%2 == 0)\\n            return temp*temp;\\n        else\\n        {\\n            if(y > 0)\\n                return x * temp * temp;\\n            else\\n                return (temp * temp) / x;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870899,
                "title": "c-0-ms-easy-to-understand-beginner-friendly",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\t\\tdouble power(double a,int b)\\n\\t\\t{\\n\\t\\tif(b==0)return 1;\\n\\t\\telse if(b%2==0)return power(a*a,b/2);\\n\\t\\telse return a*power(a*a,b/2);\\n\\t\\t}        \\n\\n\\t\\tdouble myPow(double x, int n) {\\n\\t\\tif(n<0)\\n\\t\\t{\\n\\t\\t\\tn=abs(n);\\n\\t\\t\\tx=1/x;\\n\\t\\t}\\n\\t\\treturn power(x,n);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\t\\tdouble power(double a,int b)\\n\\t\\t{\\n\\t\\tif(b==0)return 1;\\n\\t\\telse if(b%2==0)return power(a*a,b/2);\\n\\t\\telse return a*power(a*a,b/2);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1078410,
                "title": "python-recursive-and-iterative",
                "content": "Python\\nThe same logic for both approches. There are 4 cases:\\n1. n == 0\\n\\tPow is always 1, no matter what value is x\\n2. n < 1\\n\\tSpecial treatment for x and n, convert it to normal case as n > 0\\n3. n > 0 and n is odd\\n\\tNormal case, standard way of calculating a power, step by step\\n4. n > 0 and n is even\\n\\tImprove the calculation, by changing x to x ** 2, and n to n // 2\\n\\n#### Recursive\\n```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        # Recursive\\n        if n == 0:\\n            return 1\\n        # Negative Power\\n        elif n < 0:\\n            return 1 / self.myPow(x, -n)\\n        # Even Power\\n        elif n % 2 == 0:\\n            return self.myPow(x * x, n / 2)\\n        # Odd Power\\n        else:\\n            return x * self.myPow(x, n - 1)\\n```\\n\\n\\n#### Iterative\\n```\\n\\nclass Solution(object):\\n    def myPow(self, x, n):\\n        \"\"\"\\n        :type x: float\\n        :type n: int\\n        :rtype: float\\n        \"\"\"\\n        # Default value to power 0\\n        pow = 1;\\n        # Iterative\\n        while n != 0:\\n            if n < 0:\\n                x = 1 / x\\n                n = -n\\n            elif n % 2 == 1:\\n                pow = x * pow\\n                n -= 1\\n            else:\\n                x = x * x\\n                n = n / 2\\n        return pow\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        # Recursive\\n        if n == 0:\\n            return 1\\n        # Negative Power\\n        elif n < 0:\\n            return 1 / self.myPow(x, -n)\\n        # Even Power\\n        elif n % 2 == 0:\\n            return self.myPow(x * x, n / 2)\\n        # Odd Power\\n        else:\\n            return x * self.myPow(x, n - 1)\\n```\n```\\n\\nclass Solution(object):\\n    def myPow(self, x, n):\\n        \"\"\"\\n        :type x: float\\n        :type n: int\\n        :rtype: float\\n        \"\"\"\\n        # Default value to power 0\\n        pow = 1;\\n        # Iterative\\n        while n != 0:\\n            if n < 0:\\n                x = 1 / x\\n                n = -n\\n            elif n % 2 == 1:\\n                pow = x * pow\\n                n -= 1\\n            else:\\n                x = x * x\\n                n = n / 2\\n        return pow\\n```",
                "codeTag": "Java"
            },
            {
                "id": 329785,
                "title": "python-lgn-run-time",
                "content": "Run time O(lgn), space O(1)\\n```\\n    def myPow(self, x: float, n: int) -> float:\\n        if n < 0:\\n            x = 1/x\\n            n = -n\\n        ans = 1\\n        while n :\\n            if n % 2:\\n                ans = x * ans\\n                n -= 1\\n            else:\\n                x = x * x\\n                n = n // 2\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def myPow(self, x: float, n: int) -> float:\\n        if n < 0:\\n            x = 1/x\\n            n = -n\\n        ans = 1\\n        while n :\\n            if n % 2:\\n                ans = x * ans\\n                n -= 1\\n            else:\\n                x = x * x\\n                n = n // 2\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 167899,
                "title": "python-solution",
                "content": "The trick is to evalute `a**n` as `(a**(n/2))**2` when `n` is even, and as `a*(a**((n-1)/2))**2` when `n` is odd.\\nRecursive algorithm: Time complexity O(log n), space complexity O(log n) (implicit stack for recursion)\\n```\\nclass Solution(object):\\n    def myPow(self, x, n):\\n        \"\"\"\\n        :type x: float\\n        :type n: int\\n        :rtype: float\\n        \"\"\"\\n        def recursion(x,n):\\n            if n == 0:\\n                return 1\\n            else:\\n                res = recursion(x, n / 2)\\n                if n % 2 == 1:\\n                    return res * res * x\\n                else:\\n                    return res * res\\n\\n        recip = False\\n        if n < 0:\\n            recip = True\\n            n = -n\\n        if recip:\\n            return 1 / recursion(x,n)\\n        else:\\n            return recursion(x,n)\\n```\\nIterative algorithm: Time complexity O(log n), space complexity O(1)\\n```\\nclass Solution(object):\\n    def myPow(self, x, n):\\n        \"\"\"\\n        :type x: float\\n        :type n: int\\n        :rtype: float\\n        \"\"\"\\n        if n == 0:\\n            return 1\\n        elif x == 0:\\n            return 0\\n        recip = False\\n        if n < 0:\\n            recip = True\\n            n = -n\\n        \\n        res = 1\\n        y = x\\n        while n > 0:\\n            if n % 2 == 1:\\n                res *= x\\n                n -= 1\\n            else:\\n                x = x * x\\n                n /= 2\\n                \\n        if recip:\\n            return 1 / res\\n        else:\\n            return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def myPow(self, x, n):\\n        \"\"\"\\n        :type x: float\\n        :type n: int\\n        :rtype: float\\n        \"\"\"\\n        def recursion(x,n):\\n            if n == 0:\\n                return 1\\n            else:\\n                res = recursion(x, n / 2)\\n                if n % 2 == 1:\\n                    return res * res * x\\n                else:\\n                    return res * res\\n\\n        recip = False\\n        if n < 0:\\n            recip = True\\n            n = -n\\n        if recip:\\n            return 1 / recursion(x,n)\\n        else:\\n            return recursion(x,n)\\n```\n```\\nclass Solution(object):\\n    def myPow(self, x, n):\\n        \"\"\"\\n        :type x: float\\n        :type n: int\\n        :rtype: float\\n        \"\"\"\\n        if n == 0:\\n            return 1\\n        elif x == 0:\\n            return 0\\n        recip = False\\n        if n < 0:\\n            recip = True\\n            n = -n\\n        \\n        res = 1\\n        y = x\\n        while n > 0:\\n            if n % 2 == 1:\\n                res *= x\\n                n -= 1\\n            else:\\n                x = x * x\\n                n /= 2\\n                \\n        if recip:\\n            return 1 / res\\n        else:\\n            return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19652,
                "title": "1ms-4-lines-java-solution-o-1",
                "content": "    double ans= 1;\\n     for(long i = Math.abs((long)n); i > 0; i = i >> 1, x *=x) \\n          if((i & 1) == 1) ans *= x;\\n     return n > 0 ? ans : 1/ans;",
                "solutionTags": [
                    "Java"
                ],
                "code": "    double ans= 1;\\n     for(long i = Math.abs((long)n); i > 0; i = i >> 1, x *=x) \\n          if((i & 1) == 1) ans *= x;\\n     return n > 0 ? ans : 1/ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 19565,
                "title": "iterative-c-solution",
                "content": "    class Solution {\\n    public:\\n    double pow(double x, int n) {\\n        if(n < 0)\\n            return 1/power(x, -n);\\n        else \\n            return power(x, n);\\n    }\\n    \\n    double power(double x, int n) {\\n        double result = 1;\\n        while(n>0)\\n        {\\n            if(n&0x01)\\n                result *= x;\\n            x *= x;\\n            n = n >> 1;\\n        }\\n        \\n        return result;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    double pow(double x, int n) {\\n        if(n < 0)\\n            return 1/power(x, -n);\\n        else \\n            return power(x, n);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3808127,
                "title": "easiest-fast-exponential-using-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal is to efficiently calculate the power base^exponent. The binary exponentiation algorithm reduces the number of multiplications required by dividing the exponent in half at each step.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code uses the binary exponentiation algorithm to calculate the result efficiently. The algorithm is based on the observation that:\\nTo compute base^exponent, we can calculate base^(exponent/2) and then square it.\\nIf exponent is odd, we can multiply the result by base.\\n\\nSteps:\\n\\n- The function first checks if exponent is 0. If it is, it returns 1, as any number raised to the power of 0 is 1.\\nThe function initializes result to 1 and is_negative to False.\\n- If exponent is negative, the function sets is_negative to True and takes the absolute value of exponent.\\n- The function then performs the binary exponentiation loop:\\n- It repeatedly divides exponent by 2 (exponent //= 2) and squares base (base *= base) at each step.\\n- If the current exponent (exponent) is odd (i.e., exponent % 2 == 1), it multiplies the result by the current base.\\n- After the loop, the function returns the result. If the original exponent was negative (is_negative is True), it returns the reciprocal of the result.\\n# Complexity\\n- Time complexity:$$O(log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def myPow(self, base: float, exponent: int) -> float:\\n        if exponent == 0:\\n            return 1\\n\\n        result = 1\\n        is_negative = False\\n\\n        if exponent < 0:\\n            is_negative = True\\n            exponent = -exponent\\n\\n        while exponent > 0:\\n            if exponent % 2 == 1:\\n                result *= base\\n            base *= base\\n            exponent //= 2\\n\\n        return 1 / result if is_negative else result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def myPow(self, base: float, exponent: int) -> float:\\n        if exponent == 0:\\n            return 1\\n\\n        result = 1\\n        is_negative = False\\n\\n        if exponent < 0:\\n            is_negative = True\\n            exponent = -exponent\\n\\n        while exponent > 0:\\n            if exponent % 2 == 1:\\n                result *= base\\n            base *= base\\n            exponent //= 2\\n\\n        return 1 / result if is_negative else result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807623,
                "title": "video-fast-and-furious-binary-exponentiation-for-pow-x-n",
                "content": "# Intuition\\nWhen faced with the task of calculating x raised to the power n, the first instinct might be to simply multiply x, n times. However, this approach is time-consuming and inefficient for large values of n. To optimize this, we could use binary exponentiation, a method that allows us to calculate large powers efficiently.\\n\\nhttps://youtu.be/FJr-Yuqr5QE\\n\\n# Approach\\nWe approach this problem using binary exponentiation which reduces the time complexity to O(log n) from O(n). If n is negative, we convert it to positive and take the reciprocal of the base x. We then repeatedly square the base (stored in `current_product`) and reduce the power to half until the power becomes zero. If at any point, the power is odd, we multiply the `result` by `current_product`. The final `result` will be the answer.\\n\\n# Complexity\\n- Time complexity: The time complexity of our algorithm is \\\\(O(\\\\log n)\\\\), as we are reducing the power to half in each step.\\n\\n- Space complexity: The space complexity of our algorithm is \\\\(O(1)\\\\), as we are using only a constant amount of space.\\n\\n# Code\\n```Python []\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n < 0: \\n            x = 1 / x \\n            n = -n \\n        result = 1 \\n        current_product = x \\n        while n > 0: \\n            if n % 2 == 1: \\n                result = result * current_product \\n            current_product = current_product * current_product \\n            n = n // 2 \\n        return result \\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    double myPow(double x, long long n) {\\n        if(n < 0) {\\n            x = 1 / x;\\n            n = -n;\\n        }\\n\\n        double result = 1;\\n        double current_product = x;\\n\\n        while(n > 0) {\\n            if(n % 2 == 1) {\\n                result = result * current_product;\\n            }\\n            current_product = current_product * current_product;\\n            n = n / 2;\\n        }\\n\\n        return result;\\n    }\\n};\\n```\\n``` JavaScript []\\nvar myPow = function(x, n) {\\n    if(n < 0) {\\n        x = 1 / x;\\n        n = -n;\\n    }\\n\\n    let result = 1;\\n    let current_product = x;\\n\\n    while(n > 0) {\\n        if(n % 2 == 1) {\\n            result = result * current_product;\\n        }\\n        current_product = current_product * current_product;\\n        n = Math.floor(n / 2);\\n    }\\n\\n    return result;    \\n};\\n```\\n``` Java []\\nclass Solution {\\n    public double myPow(double x, long n) {\\n        if(n < 0) {\\n            x = 1 / x;\\n            n = -n;\\n        }\\n\\n        double result = 1;\\n        double current_product = x;\\n\\n        while(n > 0) {\\n            if(n % 2 == 1) {\\n                result = result * current_product;\\n            }\\n            current_product = current_product * current_product;\\n            n = n / 2;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public double MyPow(double x, long n) {\\n        if(n < 0) {\\n            x = 1 / x;\\n            n = -n;\\n        }\\n\\n        double result = 1;\\n        double current_product = x;\\n\\n        while(n > 0) {\\n            if(n % 2 == 1) {\\n                result = result * current_product;\\n            }\\n            current_product = current_product * current_product;\\n            n = n / 2;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript"
                ],
                "code": "```Python []\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n < 0: \\n            x = 1 / x \\n            n = -n \\n        result = 1 \\n        current_product = x \\n        while n > 0: \\n            if n % 2 == 1: \\n                result = result * current_product \\n            current_product = current_product * current_product \\n            n = n // 2 \\n        return result \\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    double myPow(double x, long long n) {\\n        if(n < 0) {\\n            x = 1 / x;\\n            n = -n;\\n        }\\n\\n        double result = 1;\\n        double current_product = x;\\n\\n        while(n > 0) {\\n            if(n % 2 == 1) {\\n                result = result * current_product;\\n            }\\n            current_product = current_product * current_product;\\n            n = n / 2;\\n        }\\n\\n        return result;\\n    }\\n};\\n```\n``` JavaScript []\\nvar myPow = function(x, n) {\\n    if(n < 0) {\\n        x = 1 / x;\\n        n = -n;\\n    }\\n\\n    let result = 1;\\n    let current_product = x;\\n\\n    while(n > 0) {\\n        if(n % 2 == 1) {\\n            result = result * current_product;\\n        }\\n        current_product = current_product * current_product;\\n        n = Math.floor(n / 2);\\n    }\\n\\n    return result;    \\n};\\n```\n``` Java []\\nclass Solution {\\n    public double myPow(double x, long n) {\\n        if(n < 0) {\\n            x = 1 / x;\\n            n = -n;\\n        }\\n\\n        double result = 1;\\n        double current_product = x;\\n\\n        while(n > 0) {\\n            if(n % 2 == 1) {\\n                result = result * current_product;\\n            }\\n            current_product = current_product * current_product;\\n            n = n / 2;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public double MyPow(double x, long n) {\\n        if(n < 0) {\\n            x = 1 / x;\\n            n = -n;\\n        }\\n\\n        double result = 1;\\n        double current_product = x;\\n\\n        while(n > 0) {\\n            if(n % 2 == 1) {\\n                result = result * current_product;\\n            }\\n            current_product = current_product * current_product;\\n            n = n / 2;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578585,
                "title": "c-binary-exponentiation-in-o-logn",
                "content": "# Approach\\nThe main idea behind this approach is to use the binary representation of `n` to efficiently calculate `pow(x, n)`\\n\\nThis approach uses the fact that any number `x` raised to an even power can be obtained by squaring `x` multiple times. This property allows us to reduce the number of multiplications required and hence reduces the time complexity.\\n\\n1. Initialize a variable `pow` to 1.0, which will store the result of `x` raised to the power of `n`\\n\\n2. Start with the binary representation of `n` and iterate from its least significant bit to the most significant bit\\n\\n3. If a bit is 1, it means that the corresponding power of `x` contributes to the final result. So, we multiply `pow` with `x` to include this power in the result\\n\\n4. After considering the current power of `x`, square `x`. This prepares `x` for the next iteration, where it will be raised to the power of 2\\n\\n5. Now, we divide `n` with 2\\n\\n6. Repeat steps 3-5 until all the bits of `n` becomes `0`\\n\\nThe key insight here is that by decomposing `n` into its binary representation, we can identify which powers of `x` are needed to compute the final result. Instead of simply multiplying `x` by itself `n` times, we only multiply when the corresponding bit in `n` is set to 1. This reduces the number of multiplications required\\n\\n### Example:\\n`pow(3, 5)` : `3^5`. 5 can be written as `0101` => $2^2+2^0$ => $3^5$ = $3^{2^2}*3^{2^0}$\\n\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n)\\n    {\\n        if(x == 1 || x == 0)\\n            return x;\\n\\n        double pow = 1.0;\\n\\n        while(n)\\n        {\\n            if(n%2 == 1 && n>0)\\n                pow *= x;\\n            else if(n%2 == -1 && n<0)\\n                pow /= x;\\n\\n            x *= x;\\n            n /= 2;\\n        }  \\n\\n        return pow;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n)\\n    {\\n        if(x == 1 || x == 0)\\n            return x;\\n\\n        double pow = 1.0;\\n\\n        while(n)\\n        {\\n            if(n%2 == 1 && n>0)\\n                pow *= x;\\n            else if(n%2 == -1 && n<0)\\n                pow /= x;\\n\\n            x *= x;\\n            n /= 2;\\n        }  \\n\\n        return pow;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987227,
                "title": "java-c-python-javascript-kotlin-swift-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n***Java***\\n```\\npublic class Solution {\\n        public double pow(double x, int m) {\\n            double temp=x;\\n            if(m==0)\\n            return 1;\\n            temp=pow(x,m/2);\\n            if(m%2==0)\\n            return temp*temp;\\n            else \\n            {\\n            if(m > 0)\\n                return x*temp*temp;\\n            else\\n                return (temp*temp)/x;\\n            }\\n          \\n    }\\n```\\n\\n***JavaScript***\\n```\\nvar myPow = function(x, n) {\\n  const on = n;\\n  let ans = 1;\\n  n = [...Math.abs(n).toString(2)];\\n  while(n.length) {\\n    const instruction = n.shift(); \\n    switch(instruction) {\\n      case \"0\": \\n        ans *= ans; \\n        break;\\n      case \"1\":\\n        ans *= ans;\\n        ans *= x; \\n        break;\\n    }\\n  } \\n  return on < 0 ? 1/ans : ans;\\n};\\n```\\n\\n***C++***\\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double res = 1;\\n        while (n) {\\n            if (n % 2) res = n > 0 ? res * x : res / x;\\n            x = x * x;\\n            n /= 2;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n***Python***\\n```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n\\n        def function(base=x, exponent=abs(n)):\\n            if exponent == 0:\\n                return 1\\n            elif exponent % 2 == 0:\\n                return function(base * base, exponent // 2)\\n            else:\\n                return base * function(base * base, (exponent - 1) // 2)\\n\\n        f = function()\\n        \\n        return float(f) if n >= 0 else 1/f\\n```\\n\\n***Kotlin***\\n```\\nclass Solution {\\n    fun myPow(x: Double, n: Int): Double {\\n        val num: Double = if (n < 0) 1/x else x\\n        var power: Long = Math.abs(n.toLong())\\n        var product: Double = num\\n        var res: Double = 1.0\\n        while (power > 0) {\\n            if (power%2 == 1L) {\\n                res = res * product\\n            }\\n            power = power/2\\n            product = product * product\\n        }\\n        return res\\n    }\\n}\\n```\\n\\n***Swift***\\n```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(log n), where n is the power value.\\n    //   - space: O(log n), where n is the power value.\\n    \\n    func myPow(_ x: Double, _ n: Int) -> Double {\\n        guard n != 0 else { return 1 }\\n\\n        var x = x\\n        var n = n\\n\\n        if n < 0 {\\n            n = -n\\n            x = 1 / x\\n        }\\n        return n % 2 == 0 ? myPow(x * x, n / 2) : x * myPow(x * x, n / 2)\\n    }\\n\\n}\\n```\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\npublic class Solution {\\n        public double pow(double x, int m) {\\n            double temp=x;\\n            if(m==0)\\n            return 1;\\n            temp=pow(x,m/2);\\n            if(m%2==0)\\n            return temp*temp;\\n            else \\n            {\\n            if(m > 0)\\n                return x*temp*temp;\\n            else\\n                return (temp*temp)/x;\\n            }\\n          \\n    }\\n```\n```\\nvar myPow = function(x, n) {\\n  const on = n;\\n  let ans = 1;\\n  n = [...Math.abs(n).toString(2)];\\n  while(n.length) {\\n    const instruction = n.shift(); \\n    switch(instruction) {\\n      case \"0\": \\n        ans *= ans; \\n        break;\\n      case \"1\":\\n        ans *= ans;\\n        ans *= x; \\n        break;\\n    }\\n  } \\n  return on < 0 ? 1/ans : ans;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double res = 1;\\n        while (n) {\\n            if (n % 2) res = n > 0 ? res * x : res / x;\\n            x = x * x;\\n            n /= 2;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n\\n        def function(base=x, exponent=abs(n)):\\n            if exponent == 0:\\n                return 1\\n            elif exponent % 2 == 0:\\n                return function(base * base, exponent // 2)\\n            else:\\n                return base * function(base * base, (exponent - 1) // 2)\\n\\n        f = function()\\n        \\n        return float(f) if n >= 0 else 1/f\\n```\n```\\nclass Solution {\\n    fun myPow(x: Double, n: Int): Double {\\n        val num: Double = if (n < 0) 1/x else x\\n        var power: Long = Math.abs(n.toLong())\\n        var product: Double = num\\n        var res: Double = 1.0\\n        while (power > 0) {\\n            if (power%2 == 1L) {\\n                res = res * product\\n            }\\n            power = power/2\\n            product = product * product\\n        }\\n        return res\\n    }\\n}\\n```\n```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(log n), where n is the power value.\\n    //   - space: O(log n), where n is the power value.\\n    \\n    func myPow(_ x: Double, _ n: Int) -> Double {\\n        guard n != 0 else { return 1 }\\n\\n        var x = x\\n        var n = n\\n\\n        if n < 0 {\\n            n = -n\\n            x = 1 / x\\n        }\\n        return n % 2 == 0 ? myPow(x * x, n / 2) : x * myPow(x * x, n / 2)\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1869646,
                "title": "fast-power-algorithm-binary-exponentiation",
                "content": "[Leetcode](https://leetcode.com/) [50. Pow(x, n)](https://leetcode.com/problems/powx-n/).\\n\\n***By Frank Luo***\\n\\nWe know how to find $2.0$ raised to the power $10$. The easiest way is to multiply $10$ times $2.0$ by loop, but what if we have to find $2.0$ raised to the power very large number such as $10000$ or more?\\n\\nWe will discuss how to find the solution of such problems by using an fast, efficient algorithm.\\n\\n# Brute Force\\n\\nWe multiply $a$ to itself $b$ times. That is, $a^b = \\\\underbrace{a \\\\times a \\\\dots \\\\times a}_b$. \\n\\nA simple java implementation of that would be:\\n\\n```java\\n    public static double myPow(double x, int n) {\\n        if (n == 0 || x == 1) {\\n            return 1;\\n        } else if (x == 0) {\\n            return 0;\\n        }\\n\\n        double ans = x;\\n        boolean isNegative = false;\\n        long nLong = n;\\n        if (nLong < 0) {\\n            nLong = -nLong;\\n            isNegative = true;\\n        }\\n\\n        for (int i = 1; i < nLong; i++) {\\n            ans = ans * x;\\n        }\\n\\n        if (isNegative) {\\n            ans = 1 / ans;\\n        }\\n\\n        return ans;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(1)$\\n\\n# Exponentiation by Squaring\\n\\nExponentiation by Squaring can help us in finding the powers of large positive integers. The key is to the **divide the power in half** at each step.\\n\\nThe following recursive approach expresses the same idea:\\n\\n$$\\na^n = \\\\begin{cases} 1 &\\\\text{if } n == 0 \\\\\\\\ \\\\left(a^{\\\\frac{n}{2}}\\\\right)^2 &\\\\text{if } n > 0 \\\\text{ and } n \\\\text{ even} \\\\\\\\\\n\\\\left(a^{\\\\frac{n - 1}{2}}\\\\right)^2 \\\\cdot a &\\\\text{if } n > 0 \\\\text{ and } n \\\\text{ odd} \\\\\\\\ \\\\end{cases}\\n$$\\n\\nLet\\u2019s take an example:\\n\\n$$\\n3^{10} = 3 \\\\times 3 \\\\times 3 \\\\times 3 \\\\times 3 \\\\times 3 \\\\times 3 \\\\times 3 \\\\times 3 \\\\times 3\\n$$\\n\\nTry to divide the power by $2$:\\n\\n$$\\n3^{10} = (3 \\\\times 3) \\\\times (3 \\\\times 3) \\\\times (3 \\\\times 3) \\\\times (3 \\\\times 3) \\\\times (3 \\\\times 3)\\n$$\\n\\n$$\\n3^{10} = ((3 \\\\times 3) ^ 5)\\n$$\\n\\n$$\\n3^{10} = 9^5\\n$$\\n\\nEffectively, power is divided by $2$ and base is multiplied to itself. So we can write $3^10 = 9^5$.\\n\\nNow, our problem is to find $9^5$.\\n\\n$$\\n9^5 = 9 \\\\times 9 \\\\times 9 \\\\times 9 \\\\times 9\\n$$\\n\\n// Try to divide the power by $2$\\n// Since the power is an odd number here, we cannot do so.\\n// However there\\'s another way to represent $9^5$\\n\\n$$\\n9^5 = (9^4) \\\\times 9\\n$$\\n\\n// Now we can find $9^4$ and later multiple the extra $9$ to the result\\n\\n$$\\n9^5 = (81^2) \\\\times 9\\n$$\\n\\nEffectively, when power is not divisible by $2$, we make power even by taking out the extra $9$. Then we already know the solution when power is divisible by $2$. Divide the power by $2$ and multiply the base to itself.\\n\\nNow our problem is to find $(81^2) \\\\times 9$\\n\\n$$\\n(81^2) \\\\times 9 = (81 \\\\times 81) \\\\times 9\\n$$\\n\\n// Try to divide the power by $2$\\n$$\\n(81 ^ 2) \\\\times 9 = (6561 ^ 1) \\\\times 9\\n$$\\n\\nFinally, we have our solution $3^10 = (6561^1) \\\\times 9 = 6561 \\\\times 9 = 59049$\\n\\nLet\\u2019s use **recusive** in java.\\n\\n```java\\n    public static double myPow_quick(double x, int n) {\\n\\t\\tlong N = n;\\n\\t\\tif (n > 0) {\\n            return quickMul(x, N);\\n        } else {\\n            return 1.0 / quickMul(x, -N);\\n        }\\n    }\\n\\n    public static double quickMul(double x, long n) {\\n        if (n == 0) {\\n            return 1.0;\\n        }\\n\\n        double y = quickMul(x, n / 2);\\n        if (n % 2 == 0) {\\n            return y * y;\\n        } else {\\n            return y * y * x;\\n        }\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(\\\\log n)$\\n- **Space Complexity**: $O(\\\\log n)$\\n\\n# Iterative\\n\\nAlthough the complexity of both approaches is identical, but if we use **iteration** instead of **recursion** will be faster in practice since we don\\'t have the overhead of the recursive calls and reduce the space.\\n\\n```java\\n    public static double myPow_3(double x, int n) {\\n        long N = n;\\n        return N >= 0 ? binaryPower(x, N) : 1.0 / binaryPower(x, -N);\\n    }\\n\\n    public static double binaryPower(double a, long b) {\\n\\t\\tdouble res = 1.0;\\n\\t\\twhile (b > 0) {\\n\\t\\t\\tif ((b & 1) == 1) {\\n\\t\\t\\t\\tres = res * a;\\n\\t\\t\\t}\\n\\t\\t\\ta = a * a;\\n\\t\\t\\tb >>= 1;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn res;\\n\\t}\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(logn)$\\n- **Space Complexity**: $O(logn)$\\n\\n--------------------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Binary Search"
                ],
                "code": "```java\\n    public static double myPow(double x, int n) {\\n        if (n == 0 || x == 1) {\\n            return 1;\\n        } else if (x == 0) {\\n            return 0;\\n        }\\n\\n        double ans = x;\\n        boolean isNegative = false;\\n        long nLong = n;\\n        if (nLong < 0) {\\n            nLong = -nLong;\\n            isNegative = true;\\n        }\\n\\n        for (int i = 1; i < nLong; i++) {\\n            ans = ans * x;\\n        }\\n\\n        if (isNegative) {\\n            ans = 1 / ans;\\n        }\\n\\n        return ans;\\n    }\\n```\n```java\\n    public static double myPow_quick(double x, int n) {\\n\\t\\tlong N = n;\\n\\t\\tif (n > 0) {\\n            return quickMul(x, N);\\n        } else {\\n            return 1.0 / quickMul(x, -N);\\n        }\\n    }\\n\\n    public static double quickMul(double x, long n) {\\n        if (n == 0) {\\n            return 1.0;\\n        }\\n\\n        double y = quickMul(x, n / 2);\\n        if (n % 2 == 0) {\\n            return y * y;\\n        } else {\\n            return y * y * x;\\n        }\\n    }\\n```\n```java\\n    public static double myPow_3(double x, int n) {\\n        long N = n;\\n        return N >= 0 ? binaryPower(x, N) : 1.0 / binaryPower(x, -N);\\n    }\\n\\n    public static double binaryPower(double a, long b) {\\n\\t\\tdouble res = 1.0;\\n\\t\\twhile (b > 0) {\\n\\t\\t\\tif ((b & 1) == 1) {\\n\\t\\t\\t\\tres = res * a;\\n\\t\\t\\t}\\n\\t\\t\\ta = a * a;\\n\\t\\t\\tb >>= 1;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn res;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1841398,
                "title": "java-100-recursive-solution-divide-conquer",
                "content": "I was having trouble understanding how the mathematical form for the recursive function works.\\nSo I have shown a visual example of how it works, for better understanding. \\nHope it helps!\\n\\n\\n1) Brute force: (Time Limit Exceeded)\\n\\nTime: O(N)\\nSpace: O(1)\\n\\n\\nclass Solution {\\n    \\n    public double myPow(double x, int n) {\\n        \\n        double res=1;\\n        if(n<0)                //If n is negative, then do (1/x)^(-n)\\n        {\\n            n=-n;\\n            x=1/x;\\n        }\\n        for(int i=0; i<n; i++)\\n            res=res*x;\\n        return res;\\n            \\n    }\\n}\\n\\n\\n2) Divide & Conquer, Recursive solution \\n\\nTime: O(log n)\\nSpace: O(1)\\n\\nExample:\\nFor n>0 & even:\\n![image](https://assets.leetcode.com/users/images/8f14f83d-1ff7-4390-a417-9534cb60ad53_1647062290.2058234.png)\\n\\n\\nFor n>0 & odd: \\n![image](https://assets.leetcode.com/users/images/07690771-f72e-42e7-8861-35452db83e9e_1647061701.036213.png)\\n\\nFor n<0:\\n![image](https://assets.leetcode.com/users/images/7dd4d769-6ea0-4ae9-ad22-68c0e2edc541_1647062223.9094896.png)\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    \\n    double res;\\n    \\n    public double myPow(double x, int n) \\n\\t{\\n        return pow(x,n);\\n    }\\n    \\n    public double pow(double x, long n)         //Here long n is necessary for handling boundary n conditions e.g. Integer.MAX_VALUE or Integer.MIN_VALUE\\n    {\\n        if(n==0) \\n            return 1;\\n        \\n        if(n<0)                   //If n is negative\\n            return pow(1/x, -n);\\n        \\n        res=pow(x*x,n/2);\\n        \\n        if(n%2==1)               //If n is odd\\n            res=res*x;\\n        \\n        return res;\\n    }\\n}\\n\\n",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "class Solution {\\n    \\n    public double myPow(double x, int n) {\\n        \\n        double res=1;\\n        if(n<0)                //If n is negative, then do (1/x)^(-n)\\n        {\\n            n=-n;\\n            x=1/x;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1787981,
                "title": "javascript-solution-beats-99-explained",
                "content": "Should be relatively easy to come up with the recursive setup based on the recurrence:\\n\\n```\\n2 ^ 10 = 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2\\n       =  4 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2\\n\\t   =  8 * 2 * 2 * 2 * 2 * 2 * 2\\n\\t\\t\\tetc\\n```\\n\\n(may have messed up the number of `2` due to copy / paste error, but you get the idea)\\nWe need to acount for `n` being negative, which would just turn into `1 / myPow(x, Math.abs(n))`\\nBases cases of `0` and `1` are also considered.\\n\\n```\\n/**\\n * @param {number} x\\n * @param {number} n\\n * @return {number}\\n */\\nvar myPow = function(x, n) {\\n    if(n == 0) {\\n        return 1;\\n    }\\n    if(n == 1) {\\n        return x\\n    }\\n    if(n < 0) {\\n        return 1 / myPow(x, Math.abs(n))\\n    }\\n    return x * myPow(x, n - 1);\\n};\\n```\\n\\nThe issue with the above approach (while its valid) is that you will continue to put function calls into your runtime\\'s callstack and you\\'ll eventually reach its limit and get a stack over flow error. In order to reduce the number of recursive calls, you need can either:\\n* Use dynamic programming\\n* Find an additional recurrence relation within the computation that reduces the number of calls:\\n\\n```\\n2 ^ 6 = 2 * 2 * 2 * 2 * 2 * 2\\n```\\n\\nNote that we could represent `2 * 2 * 2 * 2 * 2 * 2` into the same base when we recurse:\\n\\n`4 * myPow(2, n - 1)`\\n\\nor we can change the base value in the next recusive call:\\n\\n`myPow(4, n / 2)`\\n\\ne.g. `2 ^ 6` is the same thing as `4^3`, except by using `4^3` you will reduce the number of recusive calls for the next step! In fact, you reduce it by half, with each subsequent call. This only works when `n` is even however. We can now add this additional base case to our function, and achieve `O(log(n))` time.\\n\\n```\\n/**\\n * @param {number} x\\n * @param {number} n\\n * @return {number}\\n */\\nvar myPow = function(x, n) {\\n    if(n == 0) {\\n        return 1;\\n    }\\n    if(n % 2 == 0) {\\n        return myPow(x * x, n / 2)\\n    }\\n    if(n == 1) {\\n        return x\\n    }\\n    if(n < 0) {\\n        return 1 / myPow(x, Math.abs(n))\\n    }\\n    return x * myPow(x, n - 1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n2 ^ 10 = 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2\\n       =  4 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2\\n\\t   =  8 * 2 * 2 * 2 * 2 * 2 * 2\\n\\t\\t\\tetc\\n```\n```\\n/**\\n * @param {number} x\\n * @param {number} n\\n * @return {number}\\n */\\nvar myPow = function(x, n) {\\n    if(n == 0) {\\n        return 1;\\n    }\\n    if(n == 1) {\\n        return x\\n    }\\n    if(n < 0) {\\n        return 1 / myPow(x, Math.abs(n))\\n    }\\n    return x * myPow(x, n - 1);\\n};\\n```\n```\\n2 ^ 6 = 2 * 2 * 2 * 2 * 2 * 2\\n```\n```\\n/**\\n * @param {number} x\\n * @param {number} n\\n * @return {number}\\n */\\nvar myPow = function(x, n) {\\n    if(n == 0) {\\n        return 1;\\n    }\\n    if(n % 2 == 0) {\\n        return myPow(x * x, n / 2)\\n    }\\n    if(n == 1) {\\n        return x\\n    }\\n    if(n < 0) {\\n        return 1 / myPow(x, Math.abs(n))\\n    }\\n    return x * myPow(x, n - 1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1713177,
                "title": "c-binary-representation",
                "content": "```c\\ndouble myPow(double x, int n) {\\n  double sum = 1.0;\\n\\n  int sign = n < 0 ? -1 : 1;\\n  unsigned int nn = (unsigned int) n * sign; // let \"nn\" = positive \"n\"\\n\\n  while (nn) {\\n    if (nn & 1) {\\n      sum *= x;\\n    }\\n    nn >>= 1;\\n    x *= x;\\n  }\\n\\n  return sign == 1 ? sum : 1.0 / sum;\\n}\\n```\\n\\nYou can just scan through the binary representation of `n` from its LSB to its MSB and multiply with its corresonding weighting.\\n![image](https://assets.leetcode.com/users/images/995aad5d-e729-4c9e-8247-13147c7036f8_1642942112.9953718.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```c\\ndouble myPow(double x, int n) {\\n  double sum = 1.0;\\n\\n  int sign = n < 0 ? -1 : 1;\\n  unsigned int nn = (unsigned int) n * sign; // let \"nn\" = positive \"n\"\\n\\n  while (nn) {\\n    if (nn & 1) {\\n      sum *= x;\\n    }\\n    nn >>= 1;\\n    x *= x;\\n  }\\n\\n  return sign == 1 ? sum : 1.0 / sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 739596,
                "title": "java-correct-solution-o-1-capacity-no-abs",
                "content": "1. int absn = Math.abs(n) is bad approach - Integer.MIN_VALUE has no correspondent positive int\\n2. long absn = Math.abs((long)n) is bad approach - solution is not scalable to myPow(double x, long n)\\n3. division by 2 using >> (shift) and modulo by using n & 1 can be used only for n > 0 and\\n    SHOULD NOT BE USED before compiled code understanding (compiler can do optimizations by own)\\n4. recursion is bad approach - O(logn) capacity (call stack)\\n5. this is 99% accurate solution :) last x*= x multiplication (when n == 0) is not needed, feel free to optimize loop body and condition\\n\\n```\\n    public double myPow(double x, int n) {\\n        double result = 1.0;\\n        if (n < 0)\\n            x = 1.0 / x;\\n        while (n != 0) {\\n            if (n % 2 != 0)\\n                result *= x;\\n            n /= 2;\\n            x *= x;\\n        } \\n        return result;\\n    }\\n\\t",
                "solutionTags": [],
                "code": "1. int absn = Math.abs(n) is bad approach - Integer.MIN_VALUE has no correspondent positive int\\n2. long absn = Math.abs((long)n) is bad approach - solution is not scalable to myPow(double x, long n)\\n3. division by 2 using >> (shift) and modulo by using n & 1 can be used only for n > 0 and\\n    SHOULD NOT BE USED before compiled code understanding (compiler can do optimizations by own)\\n4. recursion is bad approach - O(logn) capacity (call stack)\\n5. this is 99% accurate solution :) last x*= x multiplication (when n == 0) is not needed, feel free to optimize loop body and condition\\n\\n```\\n    public double myPow(double x, int n) {\\n        double result = 1.0;\\n        if (n < 0)\\n            x = 1.0 / x;\\n        while (n != 0) {\\n            if (n % 2 != 0)\\n                result *= x;\\n            n /= 2;\\n            x *= x;\\n        } \\n        return result;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 738803,
                "title": "c-recursive-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n     \\n        if(n==0)\\n             return 1;\\n        double t=myPow(x,n/2);\\n        \\n        if(n%2)\\n            return n<0? 1/x*t*t:x*t*t; \\n        else\\n            return t*t;\\n        \\n        \\n        /*\\n        Example \\n        \\n        2^4--->\\n        \\n       n= 4,2,1,0\\n        t=mypow(2,4)   t*t=16\\n        t=mypow(2,2)   t*t=4\\n        t=mypow(2,1)   t=x*t*t=2\\n        t=mypow(2,0)   t=1(returned value)\\n        \\n    \\n        since n=0-->    x*t*t\\n        \\n        */\\n\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n     \\n        if(n==0)\\n             return 1;\\n        double t=myPow(x,n/2);\\n        \\n        if(n%2)\\n            return n<0? 1/x*t*t:x*t*t; \\n        else\\n            return t*t;\\n        \\n        \\n        /*\\n        Example \\n        \\n        2^4--->\\n        \\n       n= 4,2,1,0\\n        t=mypow(2,4)   t*t=16\\n        t=mypow(2,2)   t*t=4\\n        t=mypow(2,1)   t=x*t*t=2\\n        t=mypow(2,0)   t=1(returned value)\\n        \\n    \\n        since n=0-->    x*t*t\\n        \\n        */\\n\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 450392,
                "title": "java-accepted-log2-n-time",
                "content": "\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        double pow = 0;\\n        double result = 0;\\n        \\n        if(n == 0) {\\n            result = 1;\\n        } else {\\n            pow = myPow(x, n / 2);\\n            if(n % 2 == -1) {\\n                result = pow * pow / x;\\n            }\\n            if(n % 2 == 0) {\\n                result = pow * pow;\\n            }\\n            if(n % 2 == +1) {\\n                result = pow * pow * x;\\n            }\\n        }\\n        \\n        return(result);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public double myPow(double x, int n) {\\n        double pow = 0;\\n        double result = 0;\\n        \\n        if(n == 0) {\\n            result = 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 336569,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        if(n<0) return 1/x * myPow(1/x, -(n+1));\\n        if(n==0) return 1;\\n        if(n==2) return x*x;\\n        if(n%2==0) return myPow( myPow(x, n/2), 2);\\n        else return x*myPow( myPow(x, n/2), 2);\\n    }\\n}\\n```\\n\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Pow(x, n).\\nMemory Usage: 33.5 MB, less than 5.02% of Java online submissions for Pow(x, n).",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        if(n<0) return 1/x * myPow(1/x, -(n+1));\\n        if(n==0) return 1;\\n        if(n==2) return x*x;\\n        if(n%2==0) return myPow( myPow(x, n/2), 2);\\n        else return x*myPow( myPow(x, n/2), 2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 245385,
                "title": "java-solutions",
                "content": "**Solution 1: Iterative**\\n\\n- First, lets assume `n` is positive. The **brute-force** algorithm is to form x<sup>2</sup> = x * x, then x<sup>3</sup> = x<sup>2</sup> * x, and so on. This approach takes `n - 1` multiplications, which is 2<sup>k</sup>, where `k` is the number of bits in the integer `n`.\\n- The key to efficiency is to try and get more work done with each multiplication, thereby using fewer multiplications to accomplish the same result. For example- to compute (1.1)<sup>21</sup>, instead of starting with `1.1` and multiplying `20` times by `1.1` , we could multiply `1.1` by (1.1)<sup>2</sup>  `10` times for a total of `11` multiplications, i.e. one to compute (1.1)<sup>2</sup>, and `10` additional multiplications by (1.1)<sup>2</sup>. We can still do better by computing (1.1)<sup>3</sup>, (1.1)<sup>4</sup>, etc.\\n- When `n` is a power of `2`, the approach that uses minimum multiplications is an iterated squaring, i.e., forming x, x<sup>2</sup>, (x<sup>2</sup>)<sup>2</sup> = x<sup>4</sup>, (x<sup>4</sup>)<sup>2</sup> = x<sup>8</sup>, . . .  To develop an algorithm for general `n`, is is instructive to look at the binary representation of `n`, as well as properties of exponentiation, specifically x<sup>n1 + n2</sup> = x<sup>n1</sup> * x<sup>n2</sup>.\\n- We begin with some small concrete instances, first assuming that `n` is positive. For Example- x<sup>(1010)<sub>2</sub></sup> = x<sup>(101)<sub>2</sub> + (101)<sub>2</sub></sup> = x<sup>(101)<sub>2</sub></sup> * x<sup>(101)<sub>2</sub></sup>, Similarly, x<sup>(101)<sub>2</sub></sup> = x<sup>(100)<sub>2</sub> + (1)<sub>2</sub></sup> = x<sup>(100)<sub>2</sub></sup> * x =  x<sup>(10)<sub>2</sub></sup> * x<sup>(10)<sub>2</sub></sup> * x.\\n- Generalizing, if the least significant bit of `n` is `0` (if `n` is even), the result is (x<sup>n/2</sup>)<sup>2</sup>; otherwise it is x * (x<sup>n/2</sup>)<sup>2</sup>. This gives us a recursive algorithm for computing x<sup>n</sup> when `n` is positive.\\n- The only change when `n` is negative is replacing `x` by `1 / x` and `n` by `-n`. Also we need to handle the case separately when `n` is the lowest integer (`Integer.MIN_VALUE`).\\n\\nTime complexity: `O(k) = O(log n)` - where `k` is the number of bits in an integer `n`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n    public double myPow(double x, int n)\\n\\t{\\n        double result = 1;\\n\\t\\t\\n\\t\\tif(x == 1 || n == 0)\\n            return 1;\\n        if(x == -1)\\n\\t\\t    return n % 2 == 0 ? 1 : -1;\\n        if(n == Integer.MIN_VALUE)\\n            return 0;\\n        \\n        if(n < 0)\\n\\t\\t{\\n            n = -n;\\n            x = 1 / x;\\n        }\\n\\n        while(n > 0)\\n\\t\\t{\\n            if(n % 2 == 1) \\n\\t\\t\\t\\tresult *= x;\\n            \\n\\t\\t\\tx = x * x;\\n            n = n >> 1;\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n**Solution 2: Recursive**\\n\\nTime complexity: `O(k) = O(log n)` - where `k` is the number of bits in an integer `n`\\nSpace complexity: `O(k) = O(log n)` - space required for the recursive function call stack.\\n\\n```\\nclass Solution\\n{\\n\\tpublic double myPow(double x, int n)\\n\\t{\\n\\t\\tif(n == 0)\\n\\t\\t\\treturn 1;\\n\\t\\t\\n\\t\\tif(n < 0)\\n\\t\\t{\\n\\t\\t\\tif(n == Integer.MIN_VALUE)\\n\\t\\t\\t{\\n\\t\\t\\t\\tx = x * x;\\n\\t\\t\\t\\tn = n / 2;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tn = -n;\\n\\t\\t\\t\\tx = 1 / x;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn n % 2 == 0 ? myPow(x * x, n / 2) : x *  myPow(x * x, n / 2);\\n\\t}\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public double myPow(double x, int n)\\n\\t{\\n        double result = 1;\\n\\t\\t\\n\\t\\tif(x == 1 || n == 0)\\n            return 1;\\n        if(x == -1)\\n\\t\\t    return n % 2 == 0 ? 1 : -1;\\n        if(n == Integer.MIN_VALUE)\\n            return 0;\\n        \\n        if(n < 0)\\n\\t\\t{\\n            n = -n;\\n            x = 1 / x;\\n        }\\n\\n        while(n > 0)\\n\\t\\t{\\n            if(n % 2 == 1) \\n\\t\\t\\t\\tresult *= x;\\n            \\n\\t\\t\\tx = x * x;\\n            n = n >> 1;\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n\\tpublic double myPow(double x, int n)\\n\\t{\\n\\t\\tif(n == 0)\\n\\t\\t\\treturn 1;\\n\\t\\t\\n\\t\\tif(n < 0)\\n\\t\\t{\\n\\t\\t\\tif(n == Integer.MIN_VALUE)\\n\\t\\t\\t{\\n\\t\\t\\t\\tx = x * x;\\n\\t\\t\\t\\tn = n / 2;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tn = -n;\\n\\t\\t\\t\\tx = 1 / x;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn n % 2 == 0 ? myPow(x * x, n / 2) : x *  myPow(x * x, n / 2);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 197432,
                "title": "javascript-solution",
                "content": "```javascript\\nvar myPow = function(x, n) {\\n  if (n === 0) return 1;\\n  if (n === 1) return x;\\n  if (x === 0) return 0;\\n\\n  if (n > 0) {\\n    return (n % 2 === 1 ? x : 1) * myPow(x * x, Math.floor(n / 2));\\n  } else {\\n    return myPow(1 / x, -n);\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar myPow = function(x, n) {\\n  if (n === 0) return 1;\\n  if (n === 1) return x;\\n  if (x === 0) return 0;\\n\\n  if (n > 0) {\\n    return (n % 2 === 1 ? x : 1) * myPow(x * x, Math.floor(n / 2));\\n  } else {\\n    return myPow(1 / x, -n);\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 19704,
                "title": "4ms-solution-c",
                "content": "    class Solution\\n    {\\n    public:\\n        double myPow(double x, int n)\\n        {\\n            bitset<32> bit(abs(n));\\n            double result = 1;\\n            for(int i = bit.size()-1; i >= 0; i--)\\n            {\\n                result*=result;\\n                if(bit[i] == 1)\\n                    result *=x;\\n            }\\n            return (n >= 0)?result : 1/result;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution\\n    {\\n    public:\\n        double myPow(double x, int n)\\n        {\\n            bitset<32> bit(abs(n));\\n            double result = 1;\\n            for(int i = bit.size()-1; i >= 0; i--)\\n            {\\n                result*=result;\\n                if(bit[i] == 1)\\n                    result *=x;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 19772,
                "title": "share-my-accepted-python-solution-russian",
                "content": "I guess, this is easy to understand, the time complex is O(log(n)), this is a fast implementation.\\n\\n\\n\\n\\n    class Solution:\\n    # @param x, a float\\n    # @param n, a integer\\n    # @return a float\\n    def pow(self, x, n):\\n        if(n==0):\\n            return 1;\\n        elif(n==1):\\n            return x;\\n        if(n<0):\\n            return self.pow(1/x,-n);\\n        else:\\n            if(n%2==0):\\n                return self.pow(x*x,n/2);\\n            else:\\n                return self.pow(x*x,(n-1)/2)*x;",
                "solutionTags": [
                    "Python"
                ],
                "code": "I guess, this is easy to understand, the time complex is O(log(n)), this is a fast implementation.\\n\\n\\n\\n\\n    class Solution:\\n    # @param x, a float\\n    # @param n, a integer\\n    # @return a float\\n    def pow(self, x, n):\\n        if(n==0):\\n            return 1;\\n        elif(n==1):\\n            return x;\\n        if(n<0):\\n            return self.pow(1/x,-n);\\n        else:\\n            if(n%2==0):\\n                return self.pow(x*x,n/2);\\n            else:\\n                return self.pow(x*x,(n-1)/2)*x;",
                "codeTag": "Java"
            },
            {
                "id": 3807836,
                "title": "c-solution-for-pow-x-n-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is to calculate the value of x raised to the power n. Since n can be a large negative number, positive number, or zero, we need to handle these cases efficiently. Additionally, we can use the divide-and-conquer technique to optimize the power calculation process.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We\\'ll handle the base cases first: if n is zero, the result is 1, and if n is negative, we\\'ll convert it to a positive number by taking the reciprocal of x and making n positive.\\n1. We\\'ll then implement a recursive function CalculatePow that will efficiently calculate the power using the divide-and-conquer technique. It recursively calculates the result of x raised to n/2 and then squares it to handle even powers. For odd powers, we multiply the result by x once more.\\n1. The MyPow function first handles the base cases and then calls CalculatePow to compute the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(log n) because the divide-and-conquer approach reduces the number of recursive calls by half in each step.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(log n) as well, as we have log n recursive calls in the call stack due to the divide-and-conquer approach.\\n\\n# Code\\n```\\npublic class Solution {\\n    public double MyPow(double x, int n) {\\n        long N = n;\\n        if (N == 0) return 1;\\n        if (N < 0) {\\n            x = 1 / x;\\n            N = -N;\\n        }\\n        return CalculatePow(x, N);\\n    }\\n    private double CalculatePow(double x, long n) {\\n        if (n == 1) return x;\\n        double halfPow = CalculatePow(x, n / 2);\\n        return n % 2 == 0 ? halfPow * halfPow : halfPow * halfPow * x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public double MyPow(double x, int n) {\\n        long N = n;\\n        if (N == 0) return 1;\\n        if (N < 0) {\\n            x = 1 / x;\\n            N = -N;\\n        }\\n        return CalculatePow(x, N);\\n    }\\n    private double CalculatePow(double x, long n) {\\n        if (n == 1) return x;\\n        double halfPow = CalculatePow(x, n / 2);\\n        return n % 2 == 0 ? halfPow * halfPow : halfPow * halfPow * x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712013,
                "title": "simple-and-clear-solution-c-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        if(n==0){\\n            return 1;\\n        }\\n\\n        if(n==1){\\n            return x;\\n        }\\n\\n        if(n>0){\\n            if(n%2==0){\\n                return myPow(x*x, n/2);\\n            }\\n            else{\\n                return x*myPow(x*x, n/2);\\n            }\\n        }\\n\\n        else{\\n            n= abs(n);\\n            if(n%2==0){\\n                return 1/myPow(x*x, n/2);\\n            }\\n            else{\\n                return 1/(x*myPow(x*x, n/2));\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        if(n==0){\\n            return 1;\\n        }\\n\\n        if(n==1){\\n            return x;\\n        }\\n\\n        if(n>0){\\n            if(n%2==0){\\n                return myPow(x*x, n/2);\\n            }\\n            else{\\n                return x*myPow(x*x, n/2);\\n            }\\n        }\\n\\n        else{\\n            n= abs(n);\\n            if(n%2==0){\\n                return 1/myPow(x*x, n/2);\\n            }\\n            else{\\n                return 1/(x*myPow(x*x, n/2));\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366818,
                "title": "beats-100-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Using Bit Manipulation to solve it.\\n- Very easy approach.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- If number is positive calling ans() function and calculating power.\\n- if number is negative calling ans() function by passing (-n) and returning (1 / ans) as result. [since a ^ -b = 1 / (a ^ b)]\\n- I am taking care of n = -2147483648 at the begining itself. \\uD83D\\uDE1C\\n- In the ans() function we right shift the value of n until it is 0.\\n- Everytime x is updated to (x * x) .\\n- If the last bit of n is 1 then we multiply x to ans.\\n\\n\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        if(x == 1) return 1;\\n        if(n == -2147483648 && x > 1) return 0;\\n        if(n >= 0) return ans(x, n);\\n        else return 1 / ans(x, -1*n);\\n    }\\n\\n    double ans(double x,int n){\\n        double ans = 1;\\n        while(n > 0){\\n            if((n & 1) == 1){\\n                ans *= x;\\n            }\\n            x *= x;\\n            n = n >> 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        if(x == 1) return 1;\\n        if(n == -2147483648 && x > 1) return 0;\\n        if(n >= 0) return ans(x, n);\\n        else return 1 / ans(x, -1*n);\\n    }\\n\\n    double ans(double x,int n){\\n        double ans = 1;\\n        while(n > 0){\\n            if((n & 1) == 1){\\n                ans *= x;\\n            }\\n            x *= x;\\n            n = n >> 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035151,
                "title": "simple-solution-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n    Binary Exponentiation\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log$$n$$)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n   public double MyPow(double x, int n)\\n    {\\n        double resul = 1; \\n        if(n < 0) {\\n            n = -n;\\n            x = 1 / x;\\n        }\\n\\n        while(n != 0) {\\n            if((n & 1) != 0) {\\n                result *= x;\\n            } \\n\\n            x *= x;\\n            n = (int)((uint)n >> 1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n   public double MyPow(double x, int n)\\n    {\\n        double resul = 1; \\n        if(n < 0) {\\n            n = -n;\\n            x = 1 / x;\\n        }\\n\\n        while(n != 0) {\\n            if((n & 1) != 0) {\\n                result *= x;\\n            } \\n\\n            x *= x;\\n            n = (int)((uint)n >> 1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2609922,
                "title": "c-iterative-and-recursive-with-explanation-easy",
                "content": "```\\nclass Solution {\\npublic:\\n        \\n        // iterative approach\\n        double myPow(double x, int n) {\\n        double res = 1;\\n        while (n) {\\n            if (n % 2) \\n            {\\n              if(n) res *= x; // if n is positive than multiply it by x\\n              else res /= x; \\n\\t\\t\\t  // if the power is negative, then we have to divide it  because we know a^-1 = 1/a\\n            }\\n            x = x * x;\\n            n /= 2;\\n        }\\n        return res;\\n    }\\n};\\n\\nclass Solution {\\npublic:        \\n         // one liner recursive and smarter code\\n        \\n         double myPow(double x, int n,double res=1) {\\n         return n ? myPow(x * x, n / 2, n % 2 ? (n > 0 ? res * x : res / x) : res) : res;\\n}\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        \\n        // iterative approach\\n        double myPow(double x, int n) {\\n        double res = 1;\\n        while (n) {\\n            if (n % 2) \\n            {\\n              if(n) res *= x; // if n is positive than multiply it by x\\n              else res /= x; \\n\\t\\t\\t  // if the power is negative, then we have to divide it  because we know a^-1 = 1/a\\n            }\\n            x = x * x;\\n            n /= 2;\\n        }\\n        return res;\\n    }\\n};\\n\\nclass Solution {\\npublic:        \\n         // one liner recursive and smarter code\\n        \\n         double myPow(double x, int n,double res=1) {\\n         return n ? myPow(x * x, n / 2, n % 2 ? (n > 0 ? res * x : res / x) : res) : res;\\n}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2546074,
                "title": "python-o-logn-o-1",
                "content": "```py\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n == 0:\\n            return 1\\n        \\n        total, val, left = 1, x, abs(n)\\n\\n        while left > 1:\\n            if left % 2 == 0:\\n                left = left // 2\\n                val = val * val\\n            else:\\n                total *= val\\n                left -= 1\\n\\n        return total * val if n > 0 else 1 / (total * val)",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```py\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n == 0:\\n            return 1\\n        \\n        total, val, left = 1, x, abs(n)\\n\\n        while left > 1:\\n            if left % 2 == 0:\\n                left = left // 2\\n                val = val * val\\n            else:\\n                total *= val\\n                left -= 1\\n\\n        return total * val if n > 0 else 1 / (total * val)",
                "codeTag": "Java"
            },
            {
                "id": 2472703,
                "title": "brehhhh",
                "content": "```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        \\n        return pow(x,n);\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/1bd29308-2593-4b86-9e28-fbcacc4002ce_1661336453.1564255.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        \\n        return pow(x,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529204,
                "title": "simple-0-ms-faster-than-100-00-of-c-memory-usage-less-than-96-37-of-c",
                "content": ": 0 ms, faster than 100.00% of C++ online submissions for Pow(x, n).\\nMemory Usage: 5.7 MB, less than 96.37% of C++ online submissions for Pow(x, n).\\n\\nhere the hack is you have to change the   ( int n ) to ( long n )\\nbecause of below test case:-\\n1.00000\\n-2147483648\\n\\n```\\ndouble myPow(double x, long n) \\n    {\\n        if(n<0)\\n        {\\n            return (myPow(1/x,-n));\\n        }\\n        if(n==0)\\n            return 1;\\n        if(n%2==0)\\n            return myPow(x*x,n/2);\\n        else\\n            return x*myPow(x*x,(n-1)/2);        \\n    }\\n```\\n\\nplease Upvote if you understand the solution It will help other people also Thank you !!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ndouble myPow(double x, long n) \\n    {\\n        if(n<0)\\n        {\\n            return (myPow(1/x,-n));\\n        }\\n        if(n==0)\\n            return 1;\\n        if(n%2==0)\\n            return myPow(x*x,n/2);\\n        else\\n            return x*myPow(x*x,(n-1)/2);        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1302791,
                "title": "c-solution-descriptive-faster-than-100-o-log-n",
                "content": "**C++ Solution using bitwise operators**\\n\\nSo the question is that we just need to find the x^n\\n\\nFirst we consider teh solution for only positive values of n.\\n\\n### example pow(3,5)\\n\\nOur number is 3 and we want 3 raised to teh power 5 . The most basic approach would be to do solmething like \\n\\nans = 3x3x3x3x3 using a for loop but this would be of complexity o(n)\\n\\n*Optimisation* -> We convert n into its binary form . (ps here n^x means n to the power x and not xor )\\n* 3^5 =>convert 5 to binary=> 3^(101)\\n* 3^(101) => 3^(4x1 + 2x0 + 1x1)\\n*  3^(4x1 + 2x0 + 1x1) =>( 3^(4x1)  ) x (  3^(2x0)  )x ( 3^(1x1))\\n\\nHere we see a pattern :-\\n* If we consider n to be in its binary form , then for each set bit in n at index i from the right , we multiply 3 raised to the power of the index value in our answer . And for unset bits we just mutiply ans by 1 or we can skip this.\\n* What I mean by index value explained ->  The next line will have the binary representaion of a number and below it will have the index value . ex 23\\n___1____0______1______1_____1\\n_2^4__2^3 __2^2 __2^1 __2^0\\n__16____8______4______2_____1\\n\\n* so if we need the 3^23we just do ans = [3^16] x [1] x [3^4] x [3^2] x  [3^1] . \\n\\n### Logic\\n* Store the vaues of x and n in variables Number and Power respecitively.\\n* Take an answer variable equal to 1 for now .\\n* We iterate till our Power is more than 0 . \\n* In each iteration => if the last set bit of variable Power is set , the  we multiply our answer with Number. \\n* in each itearation => Right shift the power and Square the Number .\\n* The loop will go through all the bits and multiply teh requires power of n as we have mentioned above .\\n\\n### Handling for Negative Values of Power\\nex 3^(-5)\\n* We take a bool isNegative and just set it as true if power is negative\\n* if Power is negative just multily power by -1 and do the same thing as metioned in logic\\n* Before returning the ans just check if power was negative and if its true , then we return 1/ans\\n* This is because pow(3,-5) = 1/pow(3/5)\\n\\nCode \\n```\\n    double myPow(double x, int n) {\\n        \\n        // we store these values \\n        double number = x;\\n        long long power = n ;\\n        \\n        //we just store this bool value to keep a track if our power is negative\\n        bool isPowerNegative = ( (n<0) ? true : false );\\n        if( isPowerNegative){\\n            power= (-1)*power;\\n        }       \\n        //how we solve teh qn is that we keep see our power as bbits in binary format\\n        //if m=3 & n = 5 then => n = 101 >> and 3^5 ==> 3^(bin(101)  ==> 3^(4*1 + 2*0  + 1*1) ==>\\n        // 3^(4) * 3^(2*0) * 3^(1*1)\\n        //so at each index of bits , my power of three is swuare and if the bit is set , then\\n        //we will just multiply that power to our answer\\n        double answer = 1 ;\\n        \\n        while( power > 0){\\n                \\n            if((power&1) > 0)\\n            {\\n                answer *=  number;\\n            }\\n            \\n            number*=number;\\n            power = power>>1;\\n            \\n        }\\n        \\n        if(isPowerNegative){\\n            answer = 1/answer;\\n        }\\n        \\n        return answer;\\n        \\n        \\n    }\\n\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\n    double myPow(double x, int n) {\\n        \\n        // we store these values \\n        double number = x;\\n        long long power = n ;\\n        \\n        //we just store this bool value to keep a track if our power is negative\\n        bool isPowerNegative = ( (n<0) ? true : false );\\n        if( isPowerNegative){\\n            power= (-1)*power;\\n        }       \\n        //how we solve teh qn is that we keep see our power as bbits in binary format\\n        //if m=3 & n = 5 then => n = 101 >> and 3^5 ==> 3^(bin(101)  ==> 3^(4*1 + 2*0  + 1*1) ==>\\n        // 3^(4) * 3^(2*0) * 3^(1*1)\\n        //so at each index of bits , my power of three is swuare and if the bit is set , then\\n        //we will just multiply that power to our answer\\n        double answer = 1 ;\\n        \\n        while( power > 0){\\n                \\n            if((power&1) > 0)\\n            {\\n                answer *=  number;\\n            }\\n            \\n            number*=number;\\n            power = power>>1;\\n            \\n        }\\n        \\n        if(isPowerNegative){\\n            answer = 1/answer;\\n        }\\n        \\n        return answer;\\n        \\n        \\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 738814,
                "title": "java-clean-code",
                "content": "```\\nclass Solution {\\n    public double pow(double x, int n){\\n        if(n == 0) return 1;\\n        if(n == 1) return x;\\n        if(n % 2 == 0)\\n            return pow(x * x, n/2);\\n        return x * pow(x * x, n/2);\\n    }\\n    public double myPow(double x, int n) {\\n        if(n < 0)\\n            return 1.0/pow(x, -n);\\n        return pow(x, n);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double pow(double x, int n){\\n        if(n == 0) return 1;\\n        if(n == 1) return x;\\n        if(n % 2 == 0)\\n            return pow(x * x, n/2);\\n        return x * pow(x * x, n/2);\\n    }\\n    public double myPow(double x, int n) {\\n        if(n < 0)\\n            return 1.0/pow(x, -n);\\n        return pow(x, n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 375712,
                "title": "python-iterative-solution",
                "content": "Inspiratioin:\\n```\\n2^10 = 4^5 = (4^1) * (16^2) = (4^1) * (256^1)\\n```\\n\\n**General case:**\\nTo get `pow(num, power)`\\n* If the `power` is even, use `power/2` as new `power` and `num*num` as new `num`.\\n* if the `power` is odd, multiply the `res` by the `num` and `power` becomes even again.\\n* Finally, when `power` becomes 1,  `pow(num, power)` is the product of `res` and `num**1`.\\n\\n```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n == 0 or x == 1.0:\\n            return 1.0\\n        if x == 0:\\n            if n < 0:\\n                return float(\\'inf\\')\\n            else:\\n                return 0.0\\n        \\n        if n < 0:\\n            x, n = 1/x, -n\\n        \\n        res, num, power = 1.0, x, n\\n        while power != 1:\\n            if power%2 == 0:\\n                num = num*num\\n                power /= 2\\n            else:\\n                res *= num\\n                power -= 1\\n        \\n        return res*num\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n2^10 = 4^5 = (4^1) * (16^2) = (4^1) * (256^1)\\n```\n```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n == 0 or x == 1.0:\\n            return 1.0\\n        if x == 0:\\n            if n < 0:\\n                return float(\\'inf\\')\\n            else:\\n                return 0.0\\n        \\n        if n < 0:\\n            x, n = 1/x, -n\\n        \\n        res, num, power = 1.0, x, n\\n        while power != 1:\\n            if power%2 == 0:\\n                num = num*num\\n                power /= 2\\n            else:\\n                res *= num\\n                power -= 1\\n        \\n        return res*num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19665,
                "title": "how-is-this-so-easy-c-solution-did-i-do-this-in-the-right-way",
                "content": "    class Solution {\\n    public:\\n        double myPow(double x, int n) {\\n            if(n==0||x==1) return 1;\\n            if(n==-2147483648) return (double)1/(x*myPow(x,2147483647));\\n            if(n<0) return (double)1/myPow(x,0-n);\\n            if(n%2==0) return myPow(x*x,n/2);\\n            return x* myPow(x,n-1);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        double myPow(double x, int n) {\\n            if(n==0||x==1) return 1;\\n            if(n==-2147483648) return (double)1/(x*myPow(x,2147483647));\\n            if(n<0) return (double)1/myPow(x,0-n);\\n            if(n%2==0) return myPow(x*x,n/2);\\n            return x* myPow(x,n-1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 19581,
                "title": "simple-java-solution-with-explanation-use-binary-search",
                "content": "\\n    public double myPow(double x, int n) {\\n        // special case\\n        if (x == 0 || x == 1 || n == 1) {return x;}\\n        else if (n == 0) {return 1;}\\n        // negative result\\n        if (x < 0 && n % 2 != 0) {return -myPow(-x, n);}\\n        else if (x < 0 && n % 2 == 0) {return myPow(-x, n);}\\n        // fractor result\\n        if (n < 0) {return 1/myPow(x, -n);}\\n        // main calculation\\n        return helper(x, n);\\n    }\\n    private double helper(double x, int n) {\\n        // precondition: x > 0 && n > 0\\n        if (n == 1) {return x;}\\n        return (((n % 2) == 0)? helper(x*x, n/2): (helper(x*x, n/2)*x));\\n    }\\n\\n\\n----------\\nmy idea is:\\n1. firstly, consider all special case and try to make the input x and n as positive number\\n2. use the idea of binary search. it will decrease the n. Even though the x will increase, the total amount of calculation still decreases.",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public double myPow(double x, int n) {\\n        // special case\\n        if (x == 0 || x == 1 || n == 1) {return x;}\\n        else if (n == 0) {return 1;}\\n        // negative result\\n        if (x < 0 && n % 2 != 0) {return -myPow(-x, n);}\\n        else if (x < 0 && n % 2 == 0) {return myPow(-x, n);}\\n        // fractor result\\n        if (n < 0) {return 1/myPow(x, -n);}\\n        // main calculation\\n        return helper(x, n);\\n    }\\n    private double helper(double x, int n) {\\n        // precondition: x > 0 && n > 0\\n        if (n == 1) {return x;}\\n        return (((n % 2) == 0)? helper(x*x, n/2): (helper(x*x, n/2)*x));\\n    }\\n\\n\\n----------\\nmy idea is:\\n1. firstly, consider all special case and try to make the input x and n as positive number\\n2. use the idea of binary search. it will decrease the n. Even though the x will increase, the total amount of calculation still decreases.",
                "codeTag": "Unknown"
            },
            {
                "id": 19739,
                "title": "my-8-lines-ac-o-logn-solution-in-java",
                "content": "This is a concise solution with recursion.\\n\\n    public class Solution {\\n        public double myPow(double x, int n) {\\n    \\t\\tif (n == 0)\\n    \\t\\t\\treturn 1;\\n    \\n    \\t\\tif (n % 2 == 0) {\\n    \\t\\t\\treturn myPow(x * x, n / 2);\\n    \\t\\t} else {\\n    \\t\\t\\tif (n > 0)\\n    \\t\\t\\t\\treturn x * myPow(x, n - 1);\\n    \\t\\t\\telse\\n    \\t\\t\\t\\treturn 1 / x * myPow(x, n + 1);\\n    \\t\\t}\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public double myPow(double x, int n) {\\n    \\t\\tif (n == 0)\\n    \\t\\t\\treturn 1;\\n    \\n    \\t\\tif (n % 2 == 0) {\\n    \\t\\t\\treturn myPow(x * x, n / 2);\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 19542,
                "title": "python-solution-o-logn-59ms",
                "content": "    class Solution:\\n        # @param {float} x\\n        # @param {integer} n\\n        # @return {float}\\n        def myPow(self, x, n):\\n            if n < 0:\\n                return 1 / self.pow(x, -n)\\n            else:\\n                return self.pow(x, n)\\n    \\n        def pow(self, x, n):\\n            if n == 0:\\n                return 1\\n    \\n            temp = self.pow(x, n / 2)\\n            if n % 2 == 0:\\n                return temp * temp\\n            else:\\n                return temp * temp * x",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {float}",
                "codeTag": "Java"
            },
            {
                "id": 3809572,
                "title": "2-methods-explained-beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA modified BS approach.\\n- Create a method binaryExp, which takes x and n as parameters.\\n- If n is 0, we return 1.\\n- If n is negative, we calculate the result if n is positive and return the reciprocal of it, thus we return 1 / binaryExp(1/x, n)\\n-  Otherwise, using binary exponentiation we reduce the exponent n to half and calculate and return the result after solving the new sub-problem recursively as discussed previously.\\n- Call binaryExp(x, n) method and return the result.\\n\\n# Complexity\\n- Time complexity: O(logn) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(logn) : recursion, O(1) : iterative \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Reursive\\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        if(n==0)return 1;\\n        if(n<0){\\n            n = abs(n);\\n            x = 1/x;\\n        }\\n        if(n%2==0){\\n            return myPow(x*x, n/2);\\n        }\\n        else return x* myPow(x ,n-1);\\n        \\n        \\n    }\\n};\\n```\\n\\n# Iterative\\n```\\nclass Solution {\\npublic:\\n    double binaryExp(double x, long long n) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n       \\n        // Handle case where, n < 0.\\n        if (n < 0) {\\n            n = -1 * n;\\n            x = 1.0 / x;\\n        }\\n       \\n        // Perform Binary Exponentiation.\\n        double result = 1;\\n        while (n) {\\n            // If \\'n\\' is odd we multiply result with \\'x\\' and reduce \\'n\\' by \\'1\\'.\\n            if (n % 2 == 1) {\\n                result = result * x;\\n                n -= 1;\\n            }\\n            // We square \\'x\\' and reduce \\'n\\' by half, x^n => (x^2)^(n/2).\\n            x = x * x;\\n            n = n / 2;\\n        }\\n        return result;\\n    }\\n\\n    double myPow(double x, int n) {\\n        return binaryExp(x, (long long) n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        if(n==0)return 1;\\n        if(n<0){\\n            n = abs(n);\\n            x = 1/x;\\n        }\\n        if(n%2==0){\\n            return myPow(x*x, n/2);\\n        }\\n        else return x* myPow(x ,n-1);\\n        \\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    double binaryExp(double x, long long n) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n       \\n        // Handle case where, n < 0.\\n        if (n < 0) {\\n            n = -1 * n;\\n            x = 1.0 / x;\\n        }\\n       \\n        // Perform Binary Exponentiation.\\n        double result = 1;\\n        while (n) {\\n            // If \\'n\\' is odd we multiply result with \\'x\\' and reduce \\'n\\' by \\'1\\'.\\n            if (n % 2 == 1) {\\n                result = result * x;\\n                n -= 1;\\n            }\\n            // We square \\'x\\' and reduce \\'n\\' by half, x^n => (x^2)^(n/2).\\n            x = x * x;\\n            n = n / 2;\\n        }\\n        return result;\\n    }\\n\\n    double myPow(double x, int n) {\\n        return binaryExp(x, (long long) n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808613,
                "title": "iterative-binary-exponentiation-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsed **Binary exponentiation algorithm**, which repeatedly squares the base and halves the exponent until it\\'s zero.\\nSince the exponent is halved at each iteration, the time complexity is logarithmic according to the exponent\\'s size. if n is negative the result is fractional and thus return 1 / binexp(x, n) otherwise return the binexp(x, n)\\n\\nor simply, Using built-in pow() function :: \\nreturn pow(x, n); \\nIt works because given constraints are within the accurately represented range of values by floating-point numbers for pow().\\n\\n# Complexity\\n- Time complexity:\\nO(log n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double binexp(double base, double exp) {\\n        double ans = 1.0;\\n        while(exp)\\n        {\\n            if ((int)exp % 2) ans = (ans * base) ;\\n            base = (base * base) ;\\n            exp /= 2.0;\\n        }\\n        return ans;\\n    }\\n\\n    double myPow(double x, int n) {\\n        return (n < 0)? 1.0 / binexp(x, n) : binexp(x, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double binexp(double base, double exp) {\\n        double ans = 1.0;\\n        while(exp)\\n        {\\n            if ((int)exp % 2) ans = (ans * base) ;\\n            base = (base * base) ;\\n            exp /= 2.0;\\n        }\\n        return ans;\\n    }\\n\\n    double myPow(double x, int n) {\\n        return (n < 0)? 1.0 / binexp(x, n) : binexp(x, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807888,
                "title": "c-o-logn",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    double power(double x ,long n){\\n        if(n==0) return 1;\\n        \\n        if(!(n&1)) return power(x*x,n/2); // even power\\n        return x*power(x,n-1); // odd power \\n    }\\n    \\n    double myPow(double x, int n) {\\n        if(n==0) return 1;\\n        \\n        long l=abs((long)n);\\n        double ans=power(x,l);\\n        \\n        return (n>0 ? ans:1/ans);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    double power(double x ,long n){\\n        if(n==0) return 1;\\n        \\n        if(!(n&1)) return power(x*x,n/2); // even power\\n        return x*power(x,n-1); // odd power \\n    }\\n    \\n    double myPow(double x, int n) {\\n        if(n==0) return 1;\\n        \\n        long l=abs((long)n);\\n        double ans=power(x,l);\\n        \\n        return (n>0 ? ans:1/ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807630,
                "title": "c-lsbf-msbf-in-log-n-time-beats-100",
                "content": "# Intuition\\nFollow the rules. Use LSBF/MSBF algorithm to compute. LSBF is in nature can be implemented in a recursive way. MSBF is plemented in an iterative way and can be furthermore optimised. \\n\\nSuch similar computation is used in the most modern antisymmetry cryptography systems, eg. RSA, DSA. \\n\\n# Approach\\nThis programm is really fast and it beats 100%.\\nAccording to the binary expression of the exponent n, this can be done by using successive multiplications and squarings. In order to speed up the calculation, the syntax of switch-case is used instead of if-else-if one in the possible conditional branches.\\n\\nMSBF algorithm is a little bit more subtle. You need to care for possible overflowing for x=INT_MIN=-2^31. If only int type is used, the change sign will cause overflow.\\n\\nSolve this question violating the rules with only 1 line\\n[Please turn on English subtitles if neccessary]\\n[https://youtu.be/P22N3fd73eM](https://youtu.be/P22N3fd73eM)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(\\\\log n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)+ stack for recursion=$O(\\\\log n)$\\n# Code for BSBF\\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n      if (n==0) return 1.0;\\n      int n_mod2=n%2;\\n      double a=1.0;\\n      switch(n_mod2)\\n      {\\n          case 0:a=1;\\n            break;\\n          case 1: a=x;\\n            break;\\n          case -1: a=1.0/x;\\n            break;\\n      }\\n      return myPow( x*x, n/2)*a;\\n    }\\n};\\n```\\n# Code for MSBF\\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        if (n==0) return 1.0;\\n        int sgn=(n>0)?1:-1;\\n        long long exp=(long long)n*sgn;//avoid of overflow for n=INT_MIN change sign \\n        bitset<32> bexp(exp);\\n        double a=1;\\n        x=(sgn==1)?x:1.0/x;\\n        for(int b=31; b>=0; b--){\\n            a=a*a;\\n            if (bexp[b]) a*=x;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n      if (n==0) return 1.0;\\n      int n_mod2=n%2;\\n      double a=1.0;\\n      switch(n_mod2)\\n      {\\n          case 0:a=1;\\n            break;\\n          case 1: a=x;\\n            break;\\n          case -1: a=1.0/x;\\n            break;\\n      }\\n      return myPow( x*x, n/2)*a;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        if (n==0) return 1.0;\\n        int sgn=(n>0)?1:-1;\\n        long long exp=(long long)n*sgn;//avoid of overflow for n=INT_MIN change sign \\n        bitset<32> bexp(exp);\\n        double a=1;\\n        x=(sgn==1)?x:1.0/x;\\n        for(int b=31; b>=0; b--){\\n            a=a*a;\\n            if (bexp[b]) a*=x;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561202,
                "title": "best-o-logn-solution",
                "content": "# Approach\\nBinary Exponentiation\\n\\n# Complexity\\n- Time complexity:\\n$$O(logn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double ans = 1.0;\\n        long long nn = abs(n);\\n        while (nn != 0) {\\n            if (nn % 2 == 0) {\\n                x = x * x;\\n                nn = nn / 2;\\n            } else {\\n                nn = nn - 1;\\n                ans = ans * x;\\n            }\\n        }\\n        if (n < 0) {\\n            ans = 1 / ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double ans = 1.0;\\n        long long nn = abs(n);\\n        while (nn != 0) {\\n            if (nn % 2 == 0) {\\n                x = x * x;\\n                nn = nn / 2;\\n            } else {\\n                nn = nn - 1;\\n                ans = ans * x;\\n            }\\n        }\\n        if (n < 0) {\\n            ans = 1 / ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265681,
                "title": "easy-to-understand-c-solution-with-0ms-runtime",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n    if (n == 0) {\\n        return 1.0;\\n    }\\n    double res = 1.0;\\n    long long p = abs((long long) n);\\n    while (p > 0) {\\n        if (p % 2 == 1) {\\n            res *= x;\\n        }\\n        x *= x;\\n        p /= 2;\\n    }\\n    if (n < 0) {\\n        return 1.0 / res;\\n    } else {\\n        return res;\\n    }\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n    if (n == 0) {\\n        return 1.0;\\n    }\\n    double res = 1.0;\\n    long long p = abs((long long) n);\\n    while (p > 0) {\\n        if (p % 2 == 1) {\\n            res *= x;\\n        }\\n        x *= x;\\n        p /= 2;\\n    }\\n    if (n < 0) {\\n        return 1.0 / res;\\n    } else {\\n        return res;\\n    }\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2660347,
                "title": "faster-than-100-c",
                "content": "```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double ans = pow(x , n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double ans = pow(x , n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2520941,
                "title": "js-o-logn-with-explanation",
                "content": "We can simply iterate from 1 to n and multiply number by itself:\\n2 ^ 8 = 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 = 256 => O(n)\\nBut from the other side this problem can be simplified to:\\n2 ^ 8 = (2 ^ 4) * (2 ^ 4) \\nIn this case we just want to calculate 2 ^ 4, and then multiply the result by itself. And to calculate 2 ^ 4 we should divide it too:\\n2 ^ 4 = (2 ^ 2) * (2 ^ 2)\\nSo for each step we should just solve half of the problem => O(logn)\\n```\\n/**\\n * @param {number} x\\n * @param {number} n\\n * @return {number}\\n */\\nconst binaryPow = (num, power) => {\\n    if (num === 0) return 0;\\n    if (power === 0) return 1;\\n    if (power === 1) return num;\\n    \\n    const halfPower = Math.floor(power / 2);\\n    const halfRes = binaryPow(num, halfPower);\\n    const res = halfRes * halfRes;\\n    \\n    return power % 2 === 0 ? res : res * num;\\n}\\n\\nconst myPow = (x, n) => {\\n    const res = binaryPow(x, Math.abs(n));\\n    \\n    return n < 0 ? 1/res : res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number} x\\n * @param {number} n\\n * @return {number}\\n */\\nconst binaryPow = (num, power) => {\\n    if (num === 0) return 0;\\n    if (power === 0) return 1;\\n    if (power === 1) return num;\\n    \\n    const halfPower = Math.floor(power / 2);\\n    const halfRes = binaryPow(num, halfPower);\\n    const res = halfRes * halfRes;\\n    \\n    return power % 2 === 0 ? res : res * num;\\n}\\n\\nconst myPow = (x, n) => {\\n    const res = binaryPow(x, Math.abs(n));\\n    \\n    return n < 0 ? 1/res : res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2509076,
                "title": "c-0ms-easy-solution",
                "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        \\n        if(n == 0)\\n            return 1;\\n        \\n        if(x == 1)\\n           return 1; \\n        \\n       long long n1 = n;\\n        double res = 1.0;\\n        \\n        if(n < 0)\\n        {\\n            n1 = n1 * (-1);\\n        }\\n        \\n        while(n1)\\n        {\\n            if(n1%2 == 0){\\n                x = x * x;\\n                n1 = n1 / 2;\\n            }\\n            \\n            else{\\n                res = res * x;\\n                n1--;\\n            }\\n        } \\n        \\n        if(n < 0 )\\n        {\\n            res = 1 / res;\\n        }\\n        \\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        \\n        if(n == 0)\\n            return 1;\\n        \\n        if(x == 1)\\n           return 1; \\n        \\n       long long n1 = n;\\n        double res = 1.0;\\n        \\n        if(n < 0)\\n        {\\n            n1 = n1 * (-1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2264894,
                "title": "cpp-recursion-easy",
                "content": "```\\n  double calculation(double x, long int n) \\n     {\\n         if(n==0) return 1;\\n         else if( n<0)\\n             return calculation(1/x,-n);\\n         else if(n%2)\\n             return calculation(x*x,n/2)*x;\\n         else\\n             return calculation(x*x,n/2);\\n     }\\n   \\n    double myPow(double x, int n) {\\n       \\n     return calculation(x,n)   ;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n  double calculation(double x, long int n) \\n     {\\n         if(n==0) return 1;\\n         else if( n<0)\\n             return calculation(1/x,-n);\\n         else if(n%2)\\n             return calculation(x*x,n/2)*x;\\n         else\\n             return calculation(x*x,n/2);\\n     }\\n   \\n    double myPow(double x, int n) {\\n       \\n     return calculation(x,n)   ;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1687578,
                "title": "c-recursive-o-log-n-solution-recursion-laws-faster-than-100",
                "content": "**Binary Exponentiation :**\\n\\n**Like the robots of Asimov, all recursive algorithms must obey three important laws:**\\n1.  A recursive algorithm must call itself, **recursively.**\\n2.  A recursive algorithm must have a **base case.**\\n\\t`if (n == 0) {\\n\\t\\t\\t\\t\\treturn 1;\\n\\t\\t\\t\\t}`\\t\\t \\n3. A recursive algorithm must change its state and move  **toward the base case.**\\n\\n![image](https://assets.leetcode.com/users/images/abe68c78-acda-4118-82cd-557ad7b70592_1642084413.5401745.png)\\n\\n\\n\\nTo handle the case where N=INTEGER_MIN we can use \"abs\" or long (64-bit) variable\\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n            //base condition\\n        if(n == 0) {\\n            return 1;\\n        }\\n        \\n        if (n < 0) { \\n            n = abs(n);\\n            x = 1/x;\\n        }\\n        \\n        return (n % 2 == 0) ? myPow(x*x, n / 2) : x * myPow(x*x, n / 2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n            //base condition\\n        if(n == 0) {\\n            return 1;\\n        }\\n        \\n        if (n < 0) { \\n            n = abs(n);\\n            x = 1/x;\\n        }\\n        \\n        return (n % 2 == 0) ? myPow(x*x, n / 2) : x * myPow(x*x, n / 2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678542,
                "title": "1-liner-c-solution-100-faster-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n,double res=1) {\\n         return n ? myPow(x * x, n / 2, n % 2 ? (n > 0 ? res * x : res / x) : res) : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n,double res=1) {\\n         return n ? myPow(x * x, n / 2, n % 2 ? (n > 0 ? res * x : res / x) : res) : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613917,
                "title": "easy-python-o-logn-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        ans = 1\\n        #Create temporary variable to store n \\n        N = n\\n        #If it is negative, make it positive\\n        if(N < 0): N = -N\\n        #Iterate while it is greater than 0    \\n        while(N > 0):\\n            #If it is an odd number, multiply ans by x, decrease N by 1\\n            if(N % 2 == 1): ans, N = ans*x, N-1\\n            #If it is an even number, square x, divide N by 2\\n            else: x, N = x*x, N/2\\n        #If it was negative, invert it (since it is to a negative power)\\n        if(n <0): ans = 1 / ans\\n        return ans\\n        \\n```\\nLet\\'s test with an input. \\n\\n        For x = 2, n = -6 \\n\\t\\t\\n        Since n is -6, N = -n = 6\\n        1) First pass:\\n        N%2 != 1 (Since 6 is divisible by 2)\\n        We hit else conditional,\\n        x = x*x = 2*2 = 4\\n        N = N/2 = 6/2 = 3\\n        x = 4, N = 3, ans = 1\\n        \\n        2) Second pass: \\n        N%2 == 1 (Since 3 is not divisible by 2)\\n        We hit if conditional, \\n        ans = ans*x = 1*4 = 4\\n        N = N-1 = 2 \\n        x = 4, N = 2, ans = 4\\n        \\n        3) Third pass: \\n        N%2 != 1 (Since 2 is divisible by 2)\\n        We hit else conditional, \\n        x = x*x = 4*4 = 16\\n        N = N/2 = 2/2 = 1\\n        x = 16, N = 1, ans = 4\\n        \\n        4) Fourth pass (final):\\n        N%2 == 1 (Since 1 is not divisible by 2)\\n        We hit if conditional, \\n        ans = ans*x = 4*16 = 64\\n        N = N-1 = 0 \\n        x = 16, N = 0, ans = 64 \\n        \\n        Loop terminates\\n        \\n        Now, since n < 0, ans = 1/ans = 1/64.\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        ans = 1\\n        #Create temporary variable to store n \\n        N = n\\n        #If it is negative, make it positive\\n        if(N < 0): N = -N\\n        #Iterate while it is greater than 0    \\n        while(N > 0):\\n            #If it is an odd number, multiply ans by x, decrease N by 1\\n            if(N % 2 == 1): ans, N = ans*x, N-1\\n            #If it is an even number, square x, divide N by 2\\n            else: x, N = x*x, N/2\\n        #If it was negative, invert it (since it is to a negative power)\\n        if(n <0): ans = 1 / ans\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555952,
                "title": "o-1-simple-solution-using-math-with-steps-and-explanation",
                "content": "**Simple solution using log concept in math**\\n**Time: O(1)\\nSpace: O(1)**\\n\\n* Let y = x ^ n\\n\\t* Apply log base 10 on both sides \\n* log (y) = log(x ^ n)\\n* log (y) = n * log(x)\\n* y = logInverse( n * log(x) )\\n* y = 10 ^ ( n * log(x) )\\n\\t* Because logInverse(num) = (10 ^ num)   when base is 10\\n```\\nclass Solution:\\n\\n    def myPow(self, x: float, n: int) -> float:\\n        log_y = n * math.log10(abs(x))              # Take abs(x) because log(-x) is invalid\\n        ans = 10 ** log_y\\n\\t\\t\\n        if x < 0:\\n\\t\\t    # Choose the right sign for the ans\\n\\t\\t\\t# If you multiply -ve number even number of times, sign will be +ve; otherwise -ve\\n            ans *= [1,-1][n % 2]\\n\\t\\t\\t\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n\\n    def myPow(self, x: float, n: int) -> float:\\n        log_y = n * math.log10(abs(x))              # Take abs(x) because log(-x) is invalid\\n        ans = 10 ** log_y\\n\\t\\t\\n        if x < 0:\\n\\t\\t    # Choose the right sign for the ans\\n\\t\\t\\t# If you multiply -ve number even number of times, sign will be +ve; otherwise -ve\\n            ans *= [1,-1][n % 2]\\n\\t\\t\\t\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1526020,
                "title": "python-intuitive-solution",
                "content": "## Recursive\\n```python\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n == 0:\\n            return 1\\n        if n < 0:\\n            return 1 / self.myPow(x, abs(n))\\n        return x * self.myPow(x, n - 1) if n % 2 else self.myPow(x * x, n // 2)\\n```\\n\\n## Iterative\\n```python\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        product, index = 1, abs(n)\\n        while index:\\n            if index % 2:\\n                product *= x\\n            # accumulate base on the formula x ** 2n =  (x ** 2) ** n\\n            x *= x  \\n            index //= 2  # index always will be [1, 0] at last\\n        return product if n >= 0 else 1 / product\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n == 0:\\n            return 1\\n        if n < 0:\\n            return 1 / self.myPow(x, abs(n))\\n        return x * self.myPow(x, n - 1) if n % 2 else self.myPow(x * x, n // 2)\\n```\n```python\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        product, index = 1, abs(n)\\n        while index:\\n            if index % 2:\\n                product *= x\\n            # accumulate base on the formula x ** 2n =  (x ** 2) ** n\\n            x *= x  \\n            index //= 2  # index always will be [1, 0] at last\\n        return product if n >= 0 else 1 / product\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228314,
                "title": "java-100-fast-simple-recursive",
                "content": "```\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        if (x==0){\\n            return 0;\\n        }\\n        else if (n>=0){\\n            return pow1(x,n); //will return x^n\\n        }\\n        else{\\n           return pow1(1/x,n); //will return 1/x^n\\n                                //passing n or -n both will give same ans \\n        }\\n        \\n        \\n    }\\n    //recursive function to clac power\\n    //uses x^n=(x^(n/2))*(x^(n/2))\\n    public double pow1(double x,int n){\\n        if(n==0){\\n            return 1;\\n        }\\n        else if(n%2==0){\\n            double a= pow1(x,n/2);\\n            return a*a;\\n        }else{\\n            double a=pow1(x,n/2);\\n            return x*a*a;\\n        }\\n    }\\n   \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public double myPow(double x, int n) {\\n        if (x==0){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1191185,
                "title": "javascript-solution-detailed-explanation",
                "content": "### Basic ideas\\n```\\n(x ^ a) ^ b = x^(a * b)\\n```\\nTherefore,\\n* If n is even,\\n\\t```\\n\\tx ^ n = x ^ (2 * (n / 2)) = (x ^ 2) ^ (n / 2)\\n\\t```\\n* If n is odd\\n\\t```\\n\\tx ^ n = x ^ ( 2 * (n - 1) / 2 + 1 ) = (x ^ 2) ^ ((n - 1) / 2 * x\\n\\t```\\nThis way, we can reach `x ^ n` in O(logN) time\\n### Source code\\n```\\nvar myPow = function(x, n) {\\n    if (n === 0) return 1;\\n    if (n === 1) return x;\\n    if (n < 0) return 1 / myPow(x, -n);\\n    // n is even : x^n = (x^2)^(n/2);\\n    if ((n & 1) === 0) return myPow(x * x, n/2);\\n    // n is odd : x^n = (x^2)^((n-1)/2) * x;\\n    return x * myPow(x * x, (n - 1)/2);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n(x ^ a) ^ b = x^(a * b)\\n```\n```\\n\\tx ^ n = x ^ (2 * (n / 2)) = (x ^ 2) ^ (n / 2)\\n\\t```\n```\\n\\tx ^ n = x ^ ( 2 * (n - 1) / 2 + 1 ) = (x ^ 2) ^ ((n - 1) / 2 * x\\n\\t```\n```\\nvar myPow = function(x, n) {\\n    if (n === 0) return 1;\\n    if (n === 1) return x;\\n    if (n < 0) return 1 / myPow(x, -n);\\n    // n is even : x^n = (x^2)^(n/2);\\n    if ((n & 1) === 0) return myPow(x * x, n/2);\\n    // n is odd : x^n = (x^2)^((n-1)/2) * x;\\n    return x * myPow(x * x, (n - 1)/2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1109673,
                "title": "recursive-and-iterative-fast-exponention-solution-in-java",
                "content": "**Solution 1: Recursive Solution**\\n```\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        boolean negative=false;\\n        \\n     if(n<0){\\n         negative=true;\\n         n=-n;\\n     }\\n        double val=myPowHelper(x,n);\\n        if(negative==true) return 1/val;\\n        return val;\\n    }\\n    \\n    private double myPowHelper(double x,int n){\\n           if(n==0) return 1.0;\\n        \\n        double rans=myPowHelper(x,n/2);  // recursion answer\\n        double ans=rans*rans;   \\n         \\n        if((n&1)!=0) ans*=x;    // if n is odd \\n        \\n        return ans;\\n    }\\n}\\n```\\n\\n**Solution 2: Iterative version**\\n```\\n public double myPow(double x, int n) {\\n        long pow = Math.abs((long)n);\\n        double res = 1;\\n        while(pow>0) {\\n            if((pow&1)>0) {\\n                res*=x;\\n            }\\n            pow>>=1;\\n            x*=x;\\n        }    \\n        return n>=0?res:1/res;\\n    }\\n```\\t\\n**Time : O(logN) and Space :O(1)**\\nApplication of this question. : [Fibonacci number](https://leetcode.com/problems/fibonacci-number/discuss/1109647/all-possible-solutions-in-java)\\n",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        boolean negative=false;\\n        \\n     if(n<0){\\n         negative=true;\\n         n=-n;\\n     }\\n        double val=myPowHelper(x,n);\\n        if(negative==true) return 1/val;\\n        return val;\\n    }\\n    \\n    private double myPowHelper(double x,int n){\\n           if(n==0) return 1.0;\\n        \\n        double rans=myPowHelper(x,n/2);  // recursion answer\\n        double ans=rans*rans;   \\n         \\n        if((n&1)!=0) ans*=x;    // if n is odd \\n        \\n        return ans;\\n    }\\n}\\n```\n```\\n public double myPow(double x, int n) {\\n        long pow = Math.abs((long)n);\\n        double res = 1;\\n        while(pow>0) {\\n            if((pow&1)>0) {\\n                res*=x;\\n            }\\n            pow>>=1;\\n            x*=x;\\n        }    \\n        return n>=0?res:1/res;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1079926,
                "title": "c-solution-100-faster-easy-to-understand",
                "content": "Understand this. Let us say you are given to find 2^10. You can treat it as following.\\n2^10 -> (2^2)^5 -> 4^5 -> (4^4)^2 * 4 -> (16^2) * 4-> 256 * 4=1024.\\nWhat you are doing here is squaring the x part and dividing the power by 2. If power is odd, then you are making it even, by keeping the extra x away. This way you are able to solve the question easily. The same concept is applied below.\\n\\n\\n```class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        // If the power is zero, then no need to proceed.\\n\\t\\tif(n==0){\\n            return 1;\\n        }\\n        double t=1,y=x;\\n\\t\\t\\n\\t\\t//Keep in mind the limit of int data type. If its exceeding the range, return 0;\\n        if(n==-2147483648){\\n            if(x==1){\\n                return 1;\\n            }\\n            else if(x==-1){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n\\t\\t\\n\\t\\t//Keep the absolute power stored in the variable\\n        int ti=abs(n);\\n        \\n\\t\\t/* Now this step is easy. All you have to do is square the y part, and divide the power by half.\\n\\t\\tDo this while the power is greater than 1. If the power is even, divide by 2. Else reduce it by one and multiply \\n\\t\\tthe remaining integer in any other variable, as Explained above.*/\\n        while(ti>1){\\n            if(ti%2==0){\\n                y*=y;\\n                ti/=2;\\n            }\\n            else{\\n                t*=y;\\n                ti-=1;\\n            }\\n        }\\n\\t\\t\\n\\t\\t//Multiply the storing part with the answer.\\n        y*=t;\\n\\t\\t//Check if n is positive or negative. If negative, then we need to divide it by 1.\\n        if(n < 0){\\n            return 1/y;\\n        }\\n\\t\\t//Return the Answer\\n        return y;\\n    }\\n};\\n```\\n\\n**If you like it, then please give an Upvote.**",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        // If the power is zero, then no need to proceed.\\n\\t\\tif(n==0){\\n            return 1;\\n        }\\n        double t=1,y=x;\\n\\t\\t\\n\\t\\t//Keep in mind the limit of int data type. If its exceeding the range, return 0;\\n        if(n==-2147483648){\\n            if(x==1){\\n                return 1;\\n            }\\n            else if(x==-1){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n\\t\\t\\n\\t\\t//Keep the absolute power stored in the variable\\n        int ti=abs(n);\\n        \\n\\t\\t/* Now this step is easy. All you have to do is square the y part, and divide the power by half.\\n\\t\\tDo this while the power is greater than 1. If the power is even, divide by 2. Else reduce it by one and multiply \\n\\t\\tthe remaining integer in any other variable, as Explained above.*/\\n        while(ti>1){\\n            if(ti%2==0){\\n                y*=y;\\n                ti/=2;\\n            }\\n            else{\\n                t*=y;\\n                ti-=1;\\n            }\\n        }\\n\\t\\t\\n\\t\\t//Multiply the storing part with the answer.\\n        y*=t;\\n\\t\\t//Check if n is positive or negative. If negative, then we need to divide it by 1.\\n        if(n < 0){\\n            return 1/y;\\n        }\\n\\t\\t//Return the Answer\\n        return y;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 762118,
                "title": "python-better-than-99",
                "content": "```\\ndef myPow(self, x: float, n: int) -> float:\\n        if n == 0: return 1\\n        if n < 0:\\n            x = 1 / x\\n            n = -n\\n        \\n        if n % 2:\\n            return x * self.myPow(x*x, n//2)\\n        else:\\n            return self.myPow(x*x, n//2)\\n```",
                "solutionTags": [],
                "code": "```\\ndef myPow(self, x: float, n: int) -> float:\\n        if n == 0: return 1\\n        if n < 0:\\n            x = 1 / x\\n            n = -n\\n        \\n        if n % 2:\\n            return x * self.myPow(x*x, n//2)\\n        else:\\n            return self.myPow(x*x, n//2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 739779,
                "title": "java-5-liner-recursion",
                "content": "```\\npublic double myPow(double x, int n) {\\n\\tif (n==Integer.MIN_VALUE) return x==1||x==-1 ? 1 : 0;\\n\\tif (n<0) return 1/myPow(x, -n);\\n\\tif (n==0) return 1;\\n\\tif (n%2==0) return myPow(x * x, n/2);\\n\\treturn x * myPow(x, n - 1);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic double myPow(double x, int n) {\\n\\tif (n==Integer.MIN_VALUE) return x==1||x==-1 ? 1 : 0;\\n\\tif (n<0) return 1/myPow(x, -n);\\n\\tif (n==0) return 1;\\n\\tif (n%2==0) return myPow(x * x, n/2);\\n\\treturn x * myPow(x, n - 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 739000,
                "title": "recursive-o-logn-solution",
                "content": "\\tpublic double myPow(double x, int n) {\\n\\t\\tif (n == 0) {\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\tdouble power = myPow(x, n / 2);\\n\\t\\tif (n % 2 == 0) {\\n\\t\\t\\treturn power * power;\\n\\t\\t} else {\\n\\t\\t\\tif (n > 0) {\\n\\t\\t\\t\\treturn (x * power * power);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn (power * power) / x;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "\\tpublic double myPow(double x, int n) {\\n\\t\\tif (n == 0) {\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\tdouble power = myPow(x, n / 2);\\n\\t\\tif (n % 2 == 0) {\\n\\t\\t\\treturn power * power;\\n\\t\\t} else {\\n\\t\\t\\tif (n > 0) {\\n\\t\\t\\t\\treturn (x * power * power);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn (power * power) / x;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 327778,
                "title": "java-0ms-100-00",
                "content": "Runtime: 0 ms, faster than 100.00% of Java online submissions for Pow(x, n).\\nMemory Usage: 33.5 MB, less than 5.03% of Java online submissions for Pow(x, n).\\n\\n    public double myPow(double x, int n) {\\n        if (n == 0) return 1;\\n        if (n == 1) return x;\\n        if (n == -1) return 1 / x;\\n\\n        final int mid = n / 2;\\n\\n        if (mid * 2 == n) {\\n            // n is even.\\n            double powXMID = myPow(x, mid);\\n            return powXMID * powXMID;\\n        } else {\\n            // n is odd.\\n            double powXMID = myPow(x, mid);\\n            return powXMID * powXMID * myPow(x, n - mid * 2);\\n        }\\n    }",
                "solutionTags": [],
                "code": "Runtime: 0 ms, faster than 100.00% of Java online submissions for Pow(x, n).\\nMemory Usage: 33.5 MB, less than 5.03% of Java online submissions for Pow(x, n).\\n\\n    public double myPow(double x, int n) {\\n        if (n == 0) return 1;\\n        if (n == 1) return x;\\n        if (n == -1) return 1 / x;\\n\\n        final int mid = n / 2;\\n\\n        if (mid * 2 == n) {\\n            // n is even.\\n            double powXMID = myPow(x, mid);\\n            return powXMID * powXMID;\\n        } else {\\n            // n is odd.\\n            double powXMID = myPow(x, mid);\\n            return powXMID * powXMID * myPow(x, n - mid * 2);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 308104,
                "title": "simple-and-easy-to-understand-iterative-python-solution-o-logn",
                "content": "```\\n def myPow(self, x, n):\\n        \"\"\"\\n        :type x: float\\n        :type n: int\\n        :rtype: float\\n        \"\"\"\\n        if n < 0:\\n            x = 1 / x\\n            n = -n\\n        result = 1\\n        while n:\\n            if n % 2:\\n                result *= x\\n            x *= x\\n            n = n//2\\n        return result\\n\\t\\t",
                "solutionTags": [],
                "code": "```\\n def myPow(self, x, n):\\n        \"\"\"\\n        :type x: float\\n        :type n: int\\n        :rtype: float\\n        \"\"\"\\n        if n < 0:\\n            x = 1 / x\\n            n = -n\\n        result = 1\\n        while n:\\n            if n % 2:\\n                result *= x\\n            x *= x\\n            n = n//2\\n        return result\\n\\t\\t",
                "codeTag": "Python3"
            },
            {
                "id": 253204,
                "title": "swift",
                "content": "```\\nclass Solution {\\n    func myPow(_ x: Double, _ n: Int) -> Double {\\n        if n == 0 {\\n            return 1\\n        } else if n < 0 {\\n            return 1/myPow(x,-n)\\n        } else if n%2 == 0 {\\n            let half = myPow(x, n/2)\\n            return half * half\\n        } else {\\n            return x * myPow(x, n-1)\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func myPow(_ x: Double, _ n: Int) -> Double {\\n        if n == 0 {\\n            return 1\\n        } else if n < 0 {\\n            return 1/myPow(x,-n)\\n        } else if n%2 == 0 {\\n            let half = myPow(x, n/2)\\n            return half * half\\n        } else {\\n            return x * myPow(x, n-1)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 252769,
                "title": "simple-java-solution-that-beats-100",
                "content": "```\\npublic double myPow(double x, int n) {\\n\\tif(n == 1) return x;\\n\\tif(n == -1) return 1 / x;\\n\\tif(n == 0) return 1.0;\\n\\tdouble half = myPow(x, n / 2);\\n\\treturn half * half * myPow(x, n % 2);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic double myPow(double x, int n) {\\n\\tif(n == 1) return x;\\n\\tif(n == -1) return 1 / x;\\n\\tif(n == 0) return 1.0;\\n\\tdouble half = myPow(x, n / 2);\\n\\treturn half * half * myPow(x, n % 2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 19547,
                "title": "interesting-java-solution-with-some-tricks-that-beats-95",
                "content": "Here is my recursive solution to this problem. Note that one trick when dealing with negative max Integer is to instead of -n where overflow happens have it -(n+1) then multiply it by x.\\n\\n```\\n    public double myPow(double x, int n) {\\n        if(n<0){\\n            return 1/(myPow(x,-(n+1))*x);\\n        }\\n\\t\\tif (n == 0) {\\n\\t\\t\\treturn 1;\\n\\t\\t} else if (n % 2 == 0) {\\n\\t\\t\\treturn Math.pow(myPow(x, n / 2), 2);\\n\\t\\t} else {\\n\\t\\t\\treturn x * myPow(x, n - 1);\\n\\t\\t}\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n    public double myPow(double x, int n) {\\n        if(n<0){\\n            return 1/(myPow(x,-(n+1))*x);\\n        }\\n\\t\\tif (n == 0) {\\n\\t\\t\\treturn 1;\\n\\t\\t} else if (n % 2 == 0) {\\n\\t\\t\\treturn Math.pow(myPow(x, n / 2), 2);\\n\\t\\t} else {\\n\\t\\t\\treturn x * myPow(x, n - 1);\\n\\t\\t}\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 19580,
                "title": "recursive-javascript-solution",
                "content": "I came out with this implementation myself after a few submissions that covered edge cases.\\n\\nIt's passing all cases but anyone able to improve my solution?\\n\\n```javascript\\n/**\\n * @param {number} x\\n * @param {number} n\\n * @return {number}\\n */\\nvar myPow = function(x, n) {\\n    if (n === 0) return 1\\n    else if (n === 1) return x;\\n    else if (n === -1) return 1 / x;\\n    else if (n % 2 === 0) {\\n        const m = myPow(x, n/2);\\n        return m * m\\n    }\\n    else return x * myPow(x, n - 1);\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * @param {number} x\\n * @param {number} n\\n * @return {number}\\n */\\nvar myPow = function(x, n) {\\n    if (n === 0) return 1\\n    else if (n === 1) return x;\\n    else if (n === -1) return 1 / x;\\n    else if (n % 2 === 0) {\\n        const m = myPow(x, n/2);\\n        return m * m\\n    }\\n    else return x * myPow(x, n - 1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 19618,
                "title": "java-solution-beats-96",
                "content": "\\n\\n```\\npublic class Solution {\\n    public double myPow(double x, int n) {\\n        if(n == 0) { return 1.0; }\\n        if(x == 0) { return 0.0; }\\n        \\n        if(n % 2 == 0) {\\n            return myPow(x * x, n / 2);\\n        } else {\\n            return (n > 0 ? x : 1.0 / x ) * myPow(x * x, n / 2) ;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public double myPow(double x, int n) {\\n        if(n == 0) { return 1.0; }\\n        if(x == 0) { return 0.0; }\\n        \\n        if(n % 2 == 0) {\\n            return myPow(x * x, n / 2);\\n        } else {\\n            return (n > 0 ? x : 1.0 / x ) * myPow(x * x, n / 2) ;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19629,
                "title": "sharing-my-1ms-java-solution-with-pseudocode",
                "content": "/*\\n        PSEUDOCODE:\\n\\nIf n is 0, we return 1 since any number to the power of 0 is 1\\nif n is 1, we return x since any number to the power of 1 is itself\\nif n < 0, we return (1/x) * myPow(1/x, -(n+1))\\n   We could have just return myPow(1/x, -n), but we want to avoid overflow for the case where n is at the borderline \\n   of negative integers (i.e, n = -2147483648). \\n    Example, x^(-3) = (1/x)^3 = (1/x) * (1/x)^2 = (1/x) * (1/x)^(-(-2)) = (1/x) * [(1/x)^(-(-3+1)] = 1/x * [(1/x)^2]\\n\\nFor all other cases, we do the followings:\\n\\nWe know that, for any integers n and k, we can rewrite n as: n = k * (n/k) + (n % k). \\nFor k = 2, n = 2 * (n/2) + (n % 2).\\n\\nExample:\\n7 = 2*(7 / 2) + 7 % 2 = 2*(3) + 1\\n6 = 2*(6 / 2) + 6 % 2 = 2*(3) + 0\\n4 = 3*(4 / 3) + 4 % 3 = 3*(1) + 1\\n\\nWe will be using the formulas below to simplify:\\n\\npow(x, a*b) = pow(x, b*a)\\npow(x, a+b) = pow(x, b+a)\\npow(x, a*b) = pow(pow(x, a), b), i.e. x^(a*b) = (x^(a))^b\\npow(x, a+b) = pow(x, a) * pow(x, b), i.e x^(a+b) = (x^a) * (x^b)\\n\\nSince n = 2 * (n/2) + (n % 2), we have:\\npow(x, n) = pow(x, [ 2*(n/2) + (n%2) ] ) = pow(x, 2*(n/2) ) * pow(x, (n%2)) =\\n          = pow(x, (n/2)*2 ) * pow(x, (n%2)) = pow( pow(x, n/2), 2) * pow(x, (n%2))\\n\\nUsing the ^ sign, we can rewrite the above formula as:\\nx^n = x^[ 2*(n/2) + (n % 2) ] = x^( 2*(n/2) ) * x^(n % 2) =\\n    = [ x^( (n/2)*2 ) ] * x^(n % 2) = [ (x^(n/2)) ^ 2 ] * x^(n % 2)\\n\\nLet y = pow(x, n/2), i.e y = x^(n/2)\\nAlso, let r = n % 2 and z = pow(x, n%2) = pow(x, r).\\n\\nTherefore,\\nresult = pow(x, n) = pow( pow(x, n/2), 2) * pow(x, (n%2)) = \\n       = pow(y, 2) * pow(x, r) = (y^2) * (x^r) = (y*y) * (x^r)\\n\\nBut, since r = n%2 is either 0 or 1, x^r is therefore either 1 (if r=0) or x (if r=1)\\nThus, our result will be: \\nif r = n%2 = 0, result = (y*y). Otherwise, result = (y*y) * x\\n( Remember y = pow(x, n/2) = x^(n/2) )\\n*/\\n```\\npublic double myPow(double x, int n) {\\n        if (n == 0) return 1;\\n        if (n == 1) return x;\\n        if (n < 0) return ( (1/x) * myPow(1/x, -(n+1)) );\\n        \\n        double y = myPow(x, n/2);\\n        double z = y*y;\\n        int r = n % 2;\\n        \\n        return (r == 0) ? z : (z * x);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic double myPow(double x, int n) {\\n        if (n == 0) return 1;\\n        if (n == 1) return x;\\n        if (n < 0) return ( (1/x) * myPow(1/x, -(n+1)) );\\n        \\n        double y = myPow(x, n/2);\\n        double z = y*y;\\n        int r = n % 2;\\n        \\n        return (r == 0) ? z : (z * x);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 19661,
                "title": "simple-and-clear-java-solution",
                "content": "    public class Solution {\\n        public double myPow(double x, int n) {\\n            if(n == 0)\\n                return 1;\\n            \\n            if(n == 1)\\n                return x;\\n            \\n            if(n == -1)\\n                return 1/x;\\n\\n            double num = myPow(x, n/2);       \\n            return num * num * myPow(x, n%2); \\n            \\n        }\\n        \\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public double myPow(double x, int n) {\\n            if(n == 0)\\n                return 1;\\n            \\n            if(n == 1)\\n                return x;\\n            \\n            if(n == -1)\\n                return 1/x;\\n\\n            double num = myPow(x, n/2);       \\n            return num * num * myPow(x, n%2); \\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 19691,
                "title": "exponentiation-by-squaring-java-1ms-ac",
                "content": "    public double myPow(double x, int n) {\\n      if (n == 0) return 1.0;\\n      if (n < 0) { x = 1 / x; n = ~n + 1; }\\n      if (n == 1) return x;\\n      if (n == 2) return x * x;\\n      if ((n & 1) == 1) return x * myPow(x * x, n >> 1);\\n      return myPow(x * x, n >> 1);\\n    }\\n\\n - Anything raised to the 0th power is 1.\\n - Anything raised to a negative power is it's reciprocal raised to a positive power of the same magnitude.\\n - Anything raised to the 1st power remain unchanged.\\n - Raising anything to the second power just multiplies itself once.\\n - Anything raised to an arbitrary odd power is itself multiplied by its second power raised to half the original power.\\n - Anything raised to an arbitrary even power is it's second power raised to half the original power.\\n\\nThe halfing and squaring makes the algorithm logarithmic with respect to n i.e O(log n).\\n[https://en.wikipedia.org/wiki/Exponentiation_by_squaring][1]\\n\\n\\n  [1]: https://en.wikipedia.org/wiki/Exponentiation_by_squaring",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "    public double myPow(double x, int n) {\\n      if (n == 0) return 1.0;\\n      if (n < 0) { x = 1 / x; n = ~n + 1; }\\n      if (n == 1) return x;\\n      if (n == 2) return x * x;\\n      if ((n & 1) == 1) return x * myPow(x * x, n >> 1);\\n      return myPow(x * x, n >> 1);\\n    }\\n\\n - Anything raised to the 0th power is 1.\\n - Anything raised to a negative power is it's reciprocal raised to a positive power of the same magnitude.\\n - Anything raised to the 1st power remain unchanged.\\n - Raising anything to the second power just multiplies itself once.\\n - Anything raised to an arbitrary odd power is itself multiplied by its second power raised to half the original power.\\n - Anything raised to an arbitrary even power is it's second power raised to half the original power.\\n\\nThe halfing and squaring makes the algorithm logarithmic with respect to n i.e O(log n).\\n[https://en.wikipedia.org/wiki/Exponentiation_by_squaring][1]\\n\\n\\n  [1]: https://en.wikipedia.org/wiki/Exponentiation_by_squaring",
                "codeTag": "Unknown"
            },
            {
                "id": 19695,
                "title": "simple-c-solution-using-2-k-ary",
                "content": "    class Solution {\\n    public:\\n        double myPow(double x, int n) {\\n            double ret = 1;\\n            if (n < 0){\\n                n *= -1;\\n                x = 1 / x;\\n            }\\n            while (n > 0){\\n                if (n & 1) ret *= x;\\n                x = x * x;\\n                n >>= 1;\\n            }\\n            return ret;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        double myPow(double x, int n) {\\n            double ret = 1;\\n            if (n < 0){\\n                n *= -1;\\n                x = 1 / x;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3620249,
                "title": "simple-solution-for-python",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Base case: n is zero, `x^0 is 1`\\n2. If n is negative, convert x to its reciprocal and change n to positive\\n3. If n is even, use the formula `(x^n/2)^2`. Otherwise `x * (x^((n-1)/2))^2`\\n\\n\\n# Complexity\\n- Time complexity: O(n) to O(log n) depending the input case\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(log n) extra space for each callstack. (recursive binary tree)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n == 0:\\n            return 1\\n        if n < 0:\\n            x = 1 / x\\n            n = -n\\n\\n        result = self.myPow(x, n // 2)\\n        if n % 2 == 0:\\n            return result * result\\n        else:\\n            return x * result * result\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n == 0:\\n            return 1\\n        if n < 0:\\n            x = 1 / x\\n            n = -n\\n\\n        result = self.myPow(x, n // 2)\\n        if n % 2 == 0:\\n            return result * result\\n        else:\\n            return x * result * result\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531924,
                "title": "accepted-very-easy-and-explained-in-detail",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(logn)\\n\\n- Space complexity:\\nO(logn)\\n\\n# Code\\n```\\nclass Solution {\\n    func myPow(_ x: Double, _ n: Int) -> Double {\\n        // for n==0 we return 0 example 2^0\\n        if n == -1 {\\n            return 1/x\\n        }\\n        // for n==1 we return x example 2^1\\n        if n == 1 {\\n            return x\\n        }\\n        // for n==-1 we return 1/x example 2^-1\\n        if n == 0 {\\n            return 1\\n        }\\n        // we call this function for half power like we have to calculate 2^4 so we can calculate 2^2 * 2^2 \\n        let a = myPow(x, n/2)\\n        if n > 0 {\\n            if n%2 == 0 { // example 2^4 here 4 is even so ans will be  ans*ans here ans is 2^2\\n                return a*a\\n            } \\n            // example 2^5 here 5 is odd so ans will be  ans*ans*2 here ans is 2^2\\n            return a*a*x  \\n        }\\n        \\n        if n%2 == 0 {// example 2^-4 here -4 is even so ans will be  ans*ans here ans is 2^-2\\n            return  a*a\\n        } \\n        // example 2^-5 here 5 is odd so ans will be (ans*ans)/2  here ans is 2^-2\\n        return a*a/x       \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func myPow(_ x: Double, _ n: Int) -> Double {\\n        // for n==0 we return 0 example 2^0\\n        if n == -1 {\\n            return 1/x\\n        }\\n        // for n==1 we return x example 2^1\\n        if n == 1 {\\n            return x\\n        }\\n        // for n==-1 we return 1/x example 2^-1\\n        if n == 0 {\\n            return 1\\n        }\\n        // we call this function for half power like we have to calculate 2^4 so we can calculate 2^2 * 2^2 \\n        let a = myPow(x, n/2)\\n        if n > 0 {\\n            if n%2 == 0 { // example 2^4 here 4 is even so ans will be  ans*ans here ans is 2^2\\n                return a*a\\n            } \\n            // example 2^5 here 5 is odd so ans will be  ans*ans*2 here ans is 2^2\\n            return a*a*x  \\n        }\\n        \\n        if n%2 == 0 {// example 2^-4 here -4 is even so ans will be  ans*ans here ans is 2^-2\\n            return  a*a\\n        } \\n        // example 2^-5 here 5 is odd so ans will be (ans*ans)/2  here ans is 2^-2\\n        return a*a/x       \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531914,
                "title": "accepted-very-easy-and-explained-in-detail",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(log(n))\\n- Space complexity:\\nO(log(n))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n       // for n==0 we return 0 example 2^0\\n        if(n==0) {\\n          return 1;\\n        }\\n         // for n==1 we return x example 2^1\\n        if(n==1) {\\n          return x;\\n        }\\n         // for n==-1 we return 1/x example 2^-1\\n        if(n==-1) {\\n          return 1/x;\\n        }\\n\\n        // we call this function for half power like we have to calculate 2^4 so we can calculate 2^2 * 2^2 \\n        double ans=myPow(x,n/2);\\n       \\n        if(n>0) { \\n          if(n%2==0) { // example 2^4 here 4 is even so ans will be  ans*ans here ans is 2^2\\n            return ans*ans;\\n          }\\n          else {\\n            return ans*ans*x; // example 2^5 here 5 is odd so ans will be  ans*ans*2 here ans is 2^2\\n          }  \\n         } else {\\n            if(n%2==0){\\n              return ans * ans; // example 2^-4 here -4 is even so ans will be  ans*ans here ans is 2^-2\\n            }\\n            else{\\n              return (ans*ans)/x;// example 2^-5 here 5 is odd so ans will be (ans*ans)/2  here ans is 2^-2\\n            }  \\n         }\\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n       // for n==0 we return 0 example 2^0\\n        if(n==0) {\\n          return 1;\\n        }\\n         // for n==1 we return x example 2^1\\n        if(n==1) {\\n          return x;\\n        }\\n         // for n==-1 we return 1/x example 2^-1\\n        if(n==-1) {\\n          return 1/x;\\n        }\\n\\n        // we call this function for half power like we have to calculate 2^4 so we can calculate 2^2 * 2^2 \\n        double ans=myPow(x,n/2);\\n       \\n        if(n>0) { \\n          if(n%2==0) { // example 2^4 here 4 is even so ans will be  ans*ans here ans is 2^2\\n            return ans*ans;\\n          }\\n          else {\\n            return ans*ans*x; // example 2^5 here 5 is odd so ans will be  ans*ans*2 here ans is 2^2\\n          }  \\n         } else {\\n            if(n%2==0){\\n              return ans * ans; // example 2^-4 here -4 is even so ans will be  ans*ans here ans is 2^-2\\n            }\\n            else{\\n              return (ans*ans)/x;// example 2^-5 here 5 is odd so ans will be (ans*ans)/2  here ans is 2^-2\\n            }  \\n         }\\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340508,
                "title": "c-100-fast-single-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        return pow(x,n);\\n    }\\n};\\n```\\nThis works for real\\nLmao Dead :)\\n\\nAlso if you want a detailed function (100% fast), here tis :\\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        if(n < 0)  x = 1 / x;\\n        long num = labs(n);\\n        double pow = 1;\\n        \\n        while(num){          // equivalent to while(num == 1)\\n            if(num & 1)     // equivalent to if(num % 2 == 1) \\n                pow *= x;\\n\\n            x *= x;         //equivalent to x = x^2\\n            num >>= 1;     //equivalent to nums /= 2\\n        }\\n        return pow;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        return pow(x,n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        if(n < 0)  x = 1 / x;\\n        long num = labs(n);\\n        double pow = 1;\\n        \\n        while(num){          // equivalent to while(num == 1)\\n            if(num & 1)     // equivalent to if(num % 2 == 1) \\n                pow *= x;\\n\\n            x *= x;         //equivalent to x = x^2\\n            num >>= 1;     //equivalent to nums /= 2\\n        }\\n        return pow;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217521,
                "title": "o-1-c-solution-explained-with-images",
                "content": "If you have learned the exponential to logarithmic conversion in your school level mathematics. Then, it would be a piece of cake to you.\\n\\n![solution.jpg](https://assets.leetcode.com/users/images/7f2732bb-de75-41a5-86b9-2d65ed0397b7_1677054064.045268.jpeg)\\n\\nAs the log function accepts only positive value, so we have to check for the negative input.\\n\\n# Approach\\n- if x > 0, return the ans as shown in the above image\\n- if x < 0, first check whether the value of n is even or odd (as for odd the answer would be negative and for even answer will be positve)\\nfor example : $$-2^2 = 4$$ but $$-2^5 = -32$$\\n- return the answer according to the above logic, see solution for better understanding.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        // return the equation, if x > 0\\n        if (x > 0) return exp(n * log(x));\\n        \\n        // else, we would check for the even and odd parameter\\n        int sign = n % 2 == 0 ? 1 : -1;\\n        x = abs(x); // convert the x to positve\\n        return sign * exp(n * log(x)); // return the result with the appropriate sign\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        // return the equation, if x > 0\\n        if (x > 0) return exp(n * log(x));\\n        \\n        // else, we would check for the even and odd parameter\\n        int sign = n % 2 == 0 ? 1 : -1;\\n        x = abs(x); // convert the x to positve\\n        return sign * exp(n * log(x)); // return the result with the appropriate sign\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175225,
                "title": "java-recursive-sol-0ms-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        if (n==0) return 1;\\n        else if (n%2==0) return myPow(x*x, n/2);\\n        else if (n%2==1) return x*myPow(x, n-1);\\n        return 1/myPow(x, -n);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public double myPow(double x, int n) {\\n        if (n==0) return 1;\\n        else if (n%2==0) return myPow(x*x, n/2);\\n        else if (n%2==1) return x*myPow(x, n-1);\\n        return 1/myPow(x, -n);\\n    }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1805804,
                "content": [
                    {
                        "username": "mrkanesir",
                        "content": "how am i supposed to NOT get stack overflow with n=2147483647 ..."
                    },
                    {
                        "username": "itsmesuni19",
                        "content": " if your solu is O(n) solu, use long long i in the loop"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "What are you doing bro, I didn\\'t get this error, try to solve in O(log N)"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "use python? "
                    },
                    {
                        "username": "19bec1397",
                        "content": "[@satyasanjay1999](/satyasanjay1999) how\\n"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "You should optimize the solution in logn time complexity. It will also reduce the stack size, then it will also run for n = -2147483648."
                    },
                    {
                        "username": "Linearly_Independent",
                        "content": "\\n\\n\\nreturn x**n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The point of Leetcode is interview practice.\\nWould you go to an interview, and if they ask how should you implement a fast power algorithm you give them the answer of `x**y`? The point is to test your math skills."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The first two words of the question ask you to implement pow(x, n). It's simply illogical to Implement it by calling itself."
                    },
                    {
                        "username": "Satyam_Mishra",
                        "content": "[@Miiza](/Miiza) Where this is mentioned? My code accepted at just return pow(x,n)"
                    },
                    {
                        "username": "Braderbell",
                        "content": "return pow(x, n)"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "as of  this we should know the implementation of x**n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "is it working"
                    },
                    {
                        "username": "Miiza",
                        "content": "Only that this is using pow(x, n) in the background, which you\\'re not suppose to use."
                    },
                    {
                        "username": "henrygriffin330",
                        "content": "this is what i did"
                    },
                    {
                        "username": "yanyehe",
                        "content": "duh"
                    },
                    {
                        "username": "JainAnshul",
                        "content": "for Python, is there anything better (in terms of complexity) than this? Otherwise, this seems to be obvious."
                    },
                    {
                        "username": "olooney",
                        "content": "This is the 37th problem I\\'ve solved on the site and in the end I got a respectible 4ms solution. But honestly, It seems like its 2% algorithm, 98% fiddling with binary representations of signed integers and floating point numbers. I also note that, as of this writing, the problem has 1160 downvotes to 428 upvotes, so there\\'s certainly some shared negativity out there. \\n\\nPersonally, I didn\\'t enjoy this problem because I felt like I spent more time writing custom test cases for corner cases than I did programming. Frankly I cannot imagine getting this question in an interview and having the interviewer go, \"aha! but your solution doesn\\'t account for the case when n is -2^31 and x is exactly -1.0! There\\'s no way we\\'d hire such an incompetent programmer!\" And yet the way the acceptance tests are written, you need to nail *every* *single* corner case. Perhaps that frustration is limited to C/C++? Or there\\'s a different algorithm that more naturally accounts for these edge cases? \\n\\nWhat was your experience? Would you agree or disagree with my thesis that this is the worst problem on the site? "
                    },
                    {
                        "username": "samstafford",
                        "content": "funny, when I saw the title of this one, I initially presumed rational exponent, not integer.  I got all excited about Taylor Series with coefficient reuse.  In fact, I will try that."
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I personally don\\'t like questions that have math as a related topic, because that description is vague. Let\\'s say I want to do this problem, and I don\\'t know recursion, nor do I know how to get the power of a number. I can look in the related topics section, and see that I need to know recursion, and study that, before retrying the problem.\\n\\nWhat will I see for the other part of the problem? Just a generic statement, \"Math\". And sure, this problem tells you what to do, but what about the Climbing Stairs problem? The generic \"Math\" topic tells me nothing of the type of math knowledge needed to solve the problem."
                    },
                    {
                        "username": "adlong01",
                        "content": "[@super____hot](/super____hot) I get a considerably faster solution using log."
                    },
                    {
                        "username": "imfosf0r",
                        "content": "I\\'d disagree: your complaints about the edge cases are just how this function is supposed to work, because of how math works. If you get a different answer for -2^31 than everyone else, then the function isn\\'t working right yet."
                    },
                    {
                        "username": "super____hot",
                        "content": "in python x**n is the fastest method"
                    },
                    {
                        "username": "misterabdul",
                        "content": "I\\'m a C fan & I solve this problem using C. For me this is an interesting problem that let me learn again how the basic pow function could be implemented & let me try to optimize my solution to account for every corner cases. This is such a fun exercises in C IMO."
                    },
                    {
                        "username": "tylermatchett",
                        "content": "Here is a test case made by someone who was in a bad mood\\nx=-1\\nn=2147483647"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "This was a simple one. n%2 ==1, x^n is going to be -1. Because -1 ^ even number is equal to 1  AND -1^odd number is equal to -1."
                    },
                    {
                        "username": "sylvex",
                        "content": "```\\nx =\\n2.00000\\nn =\\n-2147483648\\n```\\nWhat even is the point of this edge case???"
                    },
                    {
                        "username": "tree9",
                        "content": "[@tojoSaha](/tojoSaha)  check this out please https://leetcode.com/problems/powx-n/solutions/4086833/beats-100-log-n-solution/ it handles the above case. Basically invert x and make n positive and carry on with same logic as for positive x and n. Take long N."
                    },
                    {
                        "username": "kavyamittal1282",
                        "content": "[@m_afnan2018](/m_afnan2018)  iam doing in java and geting the same error"
                    },
                    {
                        "username": "sandevil23",
                        "content": "i noticed that they have assigned int to n and here they are passing the upper and lower limits of long int "
                    },
                    {
                        "username": "amar180N_th",
                        "content": "hey I also got the same error here"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Use long long..."
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "[@tojoSaha](/tojoSaha) use abs"
                    },
                    {
                        "username": "issac_tirkey1",
                        "content": "[@heisenberg280](/heisenberg280) -2^31 = 2147483648 and the positive integer limits till 2147483647 i.e 2^31-1. So when n is negative and -2^31  when you multiply it with -1 to make positive it overflows so store -1*n into a temp variable of type long long and it should work. (before storing typecast it into long long)"
                    },
                    {
                        "username": "tojoSaha",
                        "content": "Were u able to find the solution to this test case?.. If so.. then please tell"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "To make sure that your algorithm is fast."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "How to solve this?"
                    },
                    {
                        "username": "shadowfax_",
                        "content": "just has the onsite and the interviewer tdidn\\'t want the recursive version but wanted the fast one with no recursion. \\n\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Hitro",
                        "content": "I\\'m wondering why you guys are not using builtin Math.pow() method??\\nPlease give me some insight.\\nThank you :)"
                    },
                    {
                        "username": "marcjeffs6",
                        "content": "[@barstow123](/barstow123) Is this real? I can go to FAANG and any given Sr developer will know how to recreate any built in method and explain its prime optimization?"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "We were asked to implement the built -in, which is basically Math.pow();\\nSo yeah, that\\'s what we\\'re doing"
                    },
                    {
                        "username": "barstow123",
                        "content": "The idea here is that we perform our work on the shoulders of giants.\\n\\nA more senior developer should be able to recreate built ins and explain how they are optimized if they want higher pay. for example, \"compile the solution in C++ for best performance\" is a good thing to say during senior interviews."
                    },
                    {
                        "username": "otherside2",
                        "content": "My C# code returns the expected Output for the below values when run in Visual Studio, but not here in Leetcode. Where is the disconnect? Could that be the reason why this question has so many thumbs down?\\n\\n240 / 304 test cases passed.\\nStatus: Wrong Answer\\n\\nSubmitted: 0\\xA0minutes ago\\nInput: \\n8.84372\\n-5\\nOutput: \\n0.0\\nExpected: \\n2e-05"
                    },
                    {
                        "username": "AYUSH-KATRE",
                        "content": "make 1 condition for n<0 and return 1/ans(that you are returning)"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Nishtha_2",
                        "content": "Question is under the catogery of binary search can someone suggest me solution with binary search"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@AdityaBhate](/AdityaBhate) IT doesn\\'t exist!!!"
                    },
                    {
                        "username": "r_shweta",
                        "content": "same\\n"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "To implement this problem in a naive way, we would need to multiply x with x for n times, as the n is too large, code would take ages to complete. Idea here is that once we find a square of x, we can multiply square of x with square of x to get x^4, we can again multiply x^4 with x^4 to get x^8 and so on and so forth.\\nx^1 * x^1 = x^(1+1) = x^2\\nx^2 * x^2 = x^(2+2) = x^4\\nx^4 * x^4 = x^(4+4) = x^8\\n.....\\nBy this way, we can reduce the time complexity from O(n) to O(log n), This problem comes under binary search as we are squaring(binary) each answer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "[@chickooo](/chickooo)  Actually it follows the concept of binary search, if you want to calculate for n = 4 you first calculate for  n = 2 and before calculating n = 2, you calculate n =1, so that you can obtain the solution in log(n) instead of calculating for 4 times it will take O(N) "
                    },
                    {
                        "username": "chickooo",
                        "content": "I don\\'t know why it was showing under the tag **binary search**, but the tags are now updated to **Math** and **Recursion**"
                    },
                    {
                        "username": "Will",
                        "content": "Please show me the code if any one can solve this using binary search. \\nThanks a lot!"
                    },
                    {
                        "username": "shivagama02",
                        "content": "The code for the same using binary search can be done in javascript. The code for the same is here: \\n\\nvar myPow = function(x, n) {\\n  if (n === 0) return 1;\\n  if (n > 0) return pow(x, n);\\n  if (n < 0) return 1 / pow(x, -n);\\n};\\n\\nvar pow = function (x, n) {\\n  if (n === 1) return x;\\n  var num = pow(x, Math.floor(n / 2));\\n  if (n % 2 === 0) {\\n    return num * num;\\n  } else {\\n    return x * num * num;\\n  }\\n};\\n\\n\\nThe code i tried has been accepted with time and space complexity of  O(log(n))."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@user2387402](/user2387402) Dude that's comment from 2015, that guy must've already moved on lol"
                    },
                    {
                        "username": "user2387402",
                        "content": "It\\'s not binary search. It is binary exploitation. Read the editorial."
                    },
                    {
                        "username": "mateenrehanbatt",
                        "content": "class Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n < 0:\\n            x = 1 / x\\n            n = -n\\n\\n        result = 1\\n        while n > 0:\\n            if n % 2 == 1:\\n                result *= x\\n            x *= x\\n            n //= 2\\n\\n        return result"
                    }
                ]
            },
            {
                "id": 1576589,
                "content": [
                    {
                        "username": "mrkanesir",
                        "content": "how am i supposed to NOT get stack overflow with n=2147483647 ..."
                    },
                    {
                        "username": "itsmesuni19",
                        "content": " if your solu is O(n) solu, use long long i in the loop"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "What are you doing bro, I didn\\'t get this error, try to solve in O(log N)"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "use python? "
                    },
                    {
                        "username": "19bec1397",
                        "content": "[@satyasanjay1999](/satyasanjay1999) how\\n"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "You should optimize the solution in logn time complexity. It will also reduce the stack size, then it will also run for n = -2147483648."
                    },
                    {
                        "username": "Linearly_Independent",
                        "content": "\\n\\n\\nreturn x**n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The point of Leetcode is interview practice.\\nWould you go to an interview, and if they ask how should you implement a fast power algorithm you give them the answer of `x**y`? The point is to test your math skills."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The first two words of the question ask you to implement pow(x, n). It's simply illogical to Implement it by calling itself."
                    },
                    {
                        "username": "Satyam_Mishra",
                        "content": "[@Miiza](/Miiza) Where this is mentioned? My code accepted at just return pow(x,n)"
                    },
                    {
                        "username": "Braderbell",
                        "content": "return pow(x, n)"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "as of  this we should know the implementation of x**n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "is it working"
                    },
                    {
                        "username": "Miiza",
                        "content": "Only that this is using pow(x, n) in the background, which you\\'re not suppose to use."
                    },
                    {
                        "username": "henrygriffin330",
                        "content": "this is what i did"
                    },
                    {
                        "username": "yanyehe",
                        "content": "duh"
                    },
                    {
                        "username": "JainAnshul",
                        "content": "for Python, is there anything better (in terms of complexity) than this? Otherwise, this seems to be obvious."
                    },
                    {
                        "username": "olooney",
                        "content": "This is the 37th problem I\\'ve solved on the site and in the end I got a respectible 4ms solution. But honestly, It seems like its 2% algorithm, 98% fiddling with binary representations of signed integers and floating point numbers. I also note that, as of this writing, the problem has 1160 downvotes to 428 upvotes, so there\\'s certainly some shared negativity out there. \\n\\nPersonally, I didn\\'t enjoy this problem because I felt like I spent more time writing custom test cases for corner cases than I did programming. Frankly I cannot imagine getting this question in an interview and having the interviewer go, \"aha! but your solution doesn\\'t account for the case when n is -2^31 and x is exactly -1.0! There\\'s no way we\\'d hire such an incompetent programmer!\" And yet the way the acceptance tests are written, you need to nail *every* *single* corner case. Perhaps that frustration is limited to C/C++? Or there\\'s a different algorithm that more naturally accounts for these edge cases? \\n\\nWhat was your experience? Would you agree or disagree with my thesis that this is the worst problem on the site? "
                    },
                    {
                        "username": "samstafford",
                        "content": "funny, when I saw the title of this one, I initially presumed rational exponent, not integer.  I got all excited about Taylor Series with coefficient reuse.  In fact, I will try that."
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I personally don\\'t like questions that have math as a related topic, because that description is vague. Let\\'s say I want to do this problem, and I don\\'t know recursion, nor do I know how to get the power of a number. I can look in the related topics section, and see that I need to know recursion, and study that, before retrying the problem.\\n\\nWhat will I see for the other part of the problem? Just a generic statement, \"Math\". And sure, this problem tells you what to do, but what about the Climbing Stairs problem? The generic \"Math\" topic tells me nothing of the type of math knowledge needed to solve the problem."
                    },
                    {
                        "username": "adlong01",
                        "content": "[@super____hot](/super____hot) I get a considerably faster solution using log."
                    },
                    {
                        "username": "imfosf0r",
                        "content": "I\\'d disagree: your complaints about the edge cases are just how this function is supposed to work, because of how math works. If you get a different answer for -2^31 than everyone else, then the function isn\\'t working right yet."
                    },
                    {
                        "username": "super____hot",
                        "content": "in python x**n is the fastest method"
                    },
                    {
                        "username": "misterabdul",
                        "content": "I\\'m a C fan & I solve this problem using C. For me this is an interesting problem that let me learn again how the basic pow function could be implemented & let me try to optimize my solution to account for every corner cases. This is such a fun exercises in C IMO."
                    },
                    {
                        "username": "tylermatchett",
                        "content": "Here is a test case made by someone who was in a bad mood\\nx=-1\\nn=2147483647"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "This was a simple one. n%2 ==1, x^n is going to be -1. Because -1 ^ even number is equal to 1  AND -1^odd number is equal to -1."
                    },
                    {
                        "username": "sylvex",
                        "content": "```\\nx =\\n2.00000\\nn =\\n-2147483648\\n```\\nWhat even is the point of this edge case???"
                    },
                    {
                        "username": "tree9",
                        "content": "[@tojoSaha](/tojoSaha)  check this out please https://leetcode.com/problems/powx-n/solutions/4086833/beats-100-log-n-solution/ it handles the above case. Basically invert x and make n positive and carry on with same logic as for positive x and n. Take long N."
                    },
                    {
                        "username": "kavyamittal1282",
                        "content": "[@m_afnan2018](/m_afnan2018)  iam doing in java and geting the same error"
                    },
                    {
                        "username": "sandevil23",
                        "content": "i noticed that they have assigned int to n and here they are passing the upper and lower limits of long int "
                    },
                    {
                        "username": "amar180N_th",
                        "content": "hey I also got the same error here"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Use long long..."
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "[@tojoSaha](/tojoSaha) use abs"
                    },
                    {
                        "username": "issac_tirkey1",
                        "content": "[@heisenberg280](/heisenberg280) -2^31 = 2147483648 and the positive integer limits till 2147483647 i.e 2^31-1. So when n is negative and -2^31  when you multiply it with -1 to make positive it overflows so store -1*n into a temp variable of type long long and it should work. (before storing typecast it into long long)"
                    },
                    {
                        "username": "tojoSaha",
                        "content": "Were u able to find the solution to this test case?.. If so.. then please tell"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "To make sure that your algorithm is fast."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "How to solve this?"
                    },
                    {
                        "username": "shadowfax_",
                        "content": "just has the onsite and the interviewer tdidn\\'t want the recursive version but wanted the fast one with no recursion. \\n\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Hitro",
                        "content": "I\\'m wondering why you guys are not using builtin Math.pow() method??\\nPlease give me some insight.\\nThank you :)"
                    },
                    {
                        "username": "marcjeffs6",
                        "content": "[@barstow123](/barstow123) Is this real? I can go to FAANG and any given Sr developer will know how to recreate any built in method and explain its prime optimization?"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "We were asked to implement the built -in, which is basically Math.pow();\\nSo yeah, that\\'s what we\\'re doing"
                    },
                    {
                        "username": "barstow123",
                        "content": "The idea here is that we perform our work on the shoulders of giants.\\n\\nA more senior developer should be able to recreate built ins and explain how they are optimized if they want higher pay. for example, \"compile the solution in C++ for best performance\" is a good thing to say during senior interviews."
                    },
                    {
                        "username": "otherside2",
                        "content": "My C# code returns the expected Output for the below values when run in Visual Studio, but not here in Leetcode. Where is the disconnect? Could that be the reason why this question has so many thumbs down?\\n\\n240 / 304 test cases passed.\\nStatus: Wrong Answer\\n\\nSubmitted: 0\\xA0minutes ago\\nInput: \\n8.84372\\n-5\\nOutput: \\n0.0\\nExpected: \\n2e-05"
                    },
                    {
                        "username": "AYUSH-KATRE",
                        "content": "make 1 condition for n<0 and return 1/ans(that you are returning)"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Nishtha_2",
                        "content": "Question is under the catogery of binary search can someone suggest me solution with binary search"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@AdityaBhate](/AdityaBhate) IT doesn\\'t exist!!!"
                    },
                    {
                        "username": "r_shweta",
                        "content": "same\\n"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "To implement this problem in a naive way, we would need to multiply x with x for n times, as the n is too large, code would take ages to complete. Idea here is that once we find a square of x, we can multiply square of x with square of x to get x^4, we can again multiply x^4 with x^4 to get x^8 and so on and so forth.\\nx^1 * x^1 = x^(1+1) = x^2\\nx^2 * x^2 = x^(2+2) = x^4\\nx^4 * x^4 = x^(4+4) = x^8\\n.....\\nBy this way, we can reduce the time complexity from O(n) to O(log n), This problem comes under binary search as we are squaring(binary) each answer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "[@chickooo](/chickooo)  Actually it follows the concept of binary search, if you want to calculate for n = 4 you first calculate for  n = 2 and before calculating n = 2, you calculate n =1, so that you can obtain the solution in log(n) instead of calculating for 4 times it will take O(N) "
                    },
                    {
                        "username": "chickooo",
                        "content": "I don\\'t know why it was showing under the tag **binary search**, but the tags are now updated to **Math** and **Recursion**"
                    },
                    {
                        "username": "Will",
                        "content": "Please show me the code if any one can solve this using binary search. \\nThanks a lot!"
                    },
                    {
                        "username": "shivagama02",
                        "content": "The code for the same using binary search can be done in javascript. The code for the same is here: \\n\\nvar myPow = function(x, n) {\\n  if (n === 0) return 1;\\n  if (n > 0) return pow(x, n);\\n  if (n < 0) return 1 / pow(x, -n);\\n};\\n\\nvar pow = function (x, n) {\\n  if (n === 1) return x;\\n  var num = pow(x, Math.floor(n / 2));\\n  if (n % 2 === 0) {\\n    return num * num;\\n  } else {\\n    return x * num * num;\\n  }\\n};\\n\\n\\nThe code i tried has been accepted with time and space complexity of  O(log(n))."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@user2387402](/user2387402) Dude that's comment from 2015, that guy must've already moved on lol"
                    },
                    {
                        "username": "user2387402",
                        "content": "It\\'s not binary search. It is binary exploitation. Read the editorial."
                    },
                    {
                        "username": "mateenrehanbatt",
                        "content": "class Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n < 0:\\n            x = 1 / x\\n            n = -n\\n\\n        result = 1\\n        while n > 0:\\n            if n % 2 == 1:\\n                result *= x\\n            x *= x\\n            n //= 2\\n\\n        return result"
                    }
                ]
            },
            {
                "id": 1565960,
                "content": [
                    {
                        "username": "mrkanesir",
                        "content": "how am i supposed to NOT get stack overflow with n=2147483647 ..."
                    },
                    {
                        "username": "itsmesuni19",
                        "content": " if your solu is O(n) solu, use long long i in the loop"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "What are you doing bro, I didn\\'t get this error, try to solve in O(log N)"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "use python? "
                    },
                    {
                        "username": "19bec1397",
                        "content": "[@satyasanjay1999](/satyasanjay1999) how\\n"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "You should optimize the solution in logn time complexity. It will also reduce the stack size, then it will also run for n = -2147483648."
                    },
                    {
                        "username": "Linearly_Independent",
                        "content": "\\n\\n\\nreturn x**n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The point of Leetcode is interview practice.\\nWould you go to an interview, and if they ask how should you implement a fast power algorithm you give them the answer of `x**y`? The point is to test your math skills."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The first two words of the question ask you to implement pow(x, n). It's simply illogical to Implement it by calling itself."
                    },
                    {
                        "username": "Satyam_Mishra",
                        "content": "[@Miiza](/Miiza) Where this is mentioned? My code accepted at just return pow(x,n)"
                    },
                    {
                        "username": "Braderbell",
                        "content": "return pow(x, n)"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "as of  this we should know the implementation of x**n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "is it working"
                    },
                    {
                        "username": "Miiza",
                        "content": "Only that this is using pow(x, n) in the background, which you\\'re not suppose to use."
                    },
                    {
                        "username": "henrygriffin330",
                        "content": "this is what i did"
                    },
                    {
                        "username": "yanyehe",
                        "content": "duh"
                    },
                    {
                        "username": "JainAnshul",
                        "content": "for Python, is there anything better (in terms of complexity) than this? Otherwise, this seems to be obvious."
                    },
                    {
                        "username": "olooney",
                        "content": "This is the 37th problem I\\'ve solved on the site and in the end I got a respectible 4ms solution. But honestly, It seems like its 2% algorithm, 98% fiddling with binary representations of signed integers and floating point numbers. I also note that, as of this writing, the problem has 1160 downvotes to 428 upvotes, so there\\'s certainly some shared negativity out there. \\n\\nPersonally, I didn\\'t enjoy this problem because I felt like I spent more time writing custom test cases for corner cases than I did programming. Frankly I cannot imagine getting this question in an interview and having the interviewer go, \"aha! but your solution doesn\\'t account for the case when n is -2^31 and x is exactly -1.0! There\\'s no way we\\'d hire such an incompetent programmer!\" And yet the way the acceptance tests are written, you need to nail *every* *single* corner case. Perhaps that frustration is limited to C/C++? Or there\\'s a different algorithm that more naturally accounts for these edge cases? \\n\\nWhat was your experience? Would you agree or disagree with my thesis that this is the worst problem on the site? "
                    },
                    {
                        "username": "samstafford",
                        "content": "funny, when I saw the title of this one, I initially presumed rational exponent, not integer.  I got all excited about Taylor Series with coefficient reuse.  In fact, I will try that."
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I personally don\\'t like questions that have math as a related topic, because that description is vague. Let\\'s say I want to do this problem, and I don\\'t know recursion, nor do I know how to get the power of a number. I can look in the related topics section, and see that I need to know recursion, and study that, before retrying the problem.\\n\\nWhat will I see for the other part of the problem? Just a generic statement, \"Math\". And sure, this problem tells you what to do, but what about the Climbing Stairs problem? The generic \"Math\" topic tells me nothing of the type of math knowledge needed to solve the problem."
                    },
                    {
                        "username": "adlong01",
                        "content": "[@super____hot](/super____hot) I get a considerably faster solution using log."
                    },
                    {
                        "username": "imfosf0r",
                        "content": "I\\'d disagree: your complaints about the edge cases are just how this function is supposed to work, because of how math works. If you get a different answer for -2^31 than everyone else, then the function isn\\'t working right yet."
                    },
                    {
                        "username": "super____hot",
                        "content": "in python x**n is the fastest method"
                    },
                    {
                        "username": "misterabdul",
                        "content": "I\\'m a C fan & I solve this problem using C. For me this is an interesting problem that let me learn again how the basic pow function could be implemented & let me try to optimize my solution to account for every corner cases. This is such a fun exercises in C IMO."
                    },
                    {
                        "username": "tylermatchett",
                        "content": "Here is a test case made by someone who was in a bad mood\\nx=-1\\nn=2147483647"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "This was a simple one. n%2 ==1, x^n is going to be -1. Because -1 ^ even number is equal to 1  AND -1^odd number is equal to -1."
                    },
                    {
                        "username": "sylvex",
                        "content": "```\\nx =\\n2.00000\\nn =\\n-2147483648\\n```\\nWhat even is the point of this edge case???"
                    },
                    {
                        "username": "tree9",
                        "content": "[@tojoSaha](/tojoSaha)  check this out please https://leetcode.com/problems/powx-n/solutions/4086833/beats-100-log-n-solution/ it handles the above case. Basically invert x and make n positive and carry on with same logic as for positive x and n. Take long N."
                    },
                    {
                        "username": "kavyamittal1282",
                        "content": "[@m_afnan2018](/m_afnan2018)  iam doing in java and geting the same error"
                    },
                    {
                        "username": "sandevil23",
                        "content": "i noticed that they have assigned int to n and here they are passing the upper and lower limits of long int "
                    },
                    {
                        "username": "amar180N_th",
                        "content": "hey I also got the same error here"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Use long long..."
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "[@tojoSaha](/tojoSaha) use abs"
                    },
                    {
                        "username": "issac_tirkey1",
                        "content": "[@heisenberg280](/heisenberg280) -2^31 = 2147483648 and the positive integer limits till 2147483647 i.e 2^31-1. So when n is negative and -2^31  when you multiply it with -1 to make positive it overflows so store -1*n into a temp variable of type long long and it should work. (before storing typecast it into long long)"
                    },
                    {
                        "username": "tojoSaha",
                        "content": "Were u able to find the solution to this test case?.. If so.. then please tell"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "To make sure that your algorithm is fast."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "How to solve this?"
                    },
                    {
                        "username": "shadowfax_",
                        "content": "just has the onsite and the interviewer tdidn\\'t want the recursive version but wanted the fast one with no recursion. \\n\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Hitro",
                        "content": "I\\'m wondering why you guys are not using builtin Math.pow() method??\\nPlease give me some insight.\\nThank you :)"
                    },
                    {
                        "username": "marcjeffs6",
                        "content": "[@barstow123](/barstow123) Is this real? I can go to FAANG and any given Sr developer will know how to recreate any built in method and explain its prime optimization?"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "We were asked to implement the built -in, which is basically Math.pow();\\nSo yeah, that\\'s what we\\'re doing"
                    },
                    {
                        "username": "barstow123",
                        "content": "The idea here is that we perform our work on the shoulders of giants.\\n\\nA more senior developer should be able to recreate built ins and explain how they are optimized if they want higher pay. for example, \"compile the solution in C++ for best performance\" is a good thing to say during senior interviews."
                    },
                    {
                        "username": "otherside2",
                        "content": "My C# code returns the expected Output for the below values when run in Visual Studio, but not here in Leetcode. Where is the disconnect? Could that be the reason why this question has so many thumbs down?\\n\\n240 / 304 test cases passed.\\nStatus: Wrong Answer\\n\\nSubmitted: 0\\xA0minutes ago\\nInput: \\n8.84372\\n-5\\nOutput: \\n0.0\\nExpected: \\n2e-05"
                    },
                    {
                        "username": "AYUSH-KATRE",
                        "content": "make 1 condition for n<0 and return 1/ans(that you are returning)"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Nishtha_2",
                        "content": "Question is under the catogery of binary search can someone suggest me solution with binary search"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@AdityaBhate](/AdityaBhate) IT doesn\\'t exist!!!"
                    },
                    {
                        "username": "r_shweta",
                        "content": "same\\n"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "To implement this problem in a naive way, we would need to multiply x with x for n times, as the n is too large, code would take ages to complete. Idea here is that once we find a square of x, we can multiply square of x with square of x to get x^4, we can again multiply x^4 with x^4 to get x^8 and so on and so forth.\\nx^1 * x^1 = x^(1+1) = x^2\\nx^2 * x^2 = x^(2+2) = x^4\\nx^4 * x^4 = x^(4+4) = x^8\\n.....\\nBy this way, we can reduce the time complexity from O(n) to O(log n), This problem comes under binary search as we are squaring(binary) each answer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "[@chickooo](/chickooo)  Actually it follows the concept of binary search, if you want to calculate for n = 4 you first calculate for  n = 2 and before calculating n = 2, you calculate n =1, so that you can obtain the solution in log(n) instead of calculating for 4 times it will take O(N) "
                    },
                    {
                        "username": "chickooo",
                        "content": "I don\\'t know why it was showing under the tag **binary search**, but the tags are now updated to **Math** and **Recursion**"
                    },
                    {
                        "username": "Will",
                        "content": "Please show me the code if any one can solve this using binary search. \\nThanks a lot!"
                    },
                    {
                        "username": "shivagama02",
                        "content": "The code for the same using binary search can be done in javascript. The code for the same is here: \\n\\nvar myPow = function(x, n) {\\n  if (n === 0) return 1;\\n  if (n > 0) return pow(x, n);\\n  if (n < 0) return 1 / pow(x, -n);\\n};\\n\\nvar pow = function (x, n) {\\n  if (n === 1) return x;\\n  var num = pow(x, Math.floor(n / 2));\\n  if (n % 2 === 0) {\\n    return num * num;\\n  } else {\\n    return x * num * num;\\n  }\\n};\\n\\n\\nThe code i tried has been accepted with time and space complexity of  O(log(n))."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@user2387402](/user2387402) Dude that's comment from 2015, that guy must've already moved on lol"
                    },
                    {
                        "username": "user2387402",
                        "content": "It\\'s not binary search. It is binary exploitation. Read the editorial."
                    },
                    {
                        "username": "mateenrehanbatt",
                        "content": "class Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n < 0:\\n            x = 1 / x\\n            n = -n\\n\\n        result = 1\\n        while n > 0:\\n            if n % 2 == 1:\\n                result *= x\\n            x *= x\\n            n //= 2\\n\\n        return result"
                    }
                ]
            },
            {
                "id": 1803500,
                "content": [
                    {
                        "username": "mrkanesir",
                        "content": "how am i supposed to NOT get stack overflow with n=2147483647 ..."
                    },
                    {
                        "username": "itsmesuni19",
                        "content": " if your solu is O(n) solu, use long long i in the loop"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "What are you doing bro, I didn\\'t get this error, try to solve in O(log N)"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "use python? "
                    },
                    {
                        "username": "19bec1397",
                        "content": "[@satyasanjay1999](/satyasanjay1999) how\\n"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "You should optimize the solution in logn time complexity. It will also reduce the stack size, then it will also run for n = -2147483648."
                    },
                    {
                        "username": "Linearly_Independent",
                        "content": "\\n\\n\\nreturn x**n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The point of Leetcode is interview practice.\\nWould you go to an interview, and if they ask how should you implement a fast power algorithm you give them the answer of `x**y`? The point is to test your math skills."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The first two words of the question ask you to implement pow(x, n). It's simply illogical to Implement it by calling itself."
                    },
                    {
                        "username": "Satyam_Mishra",
                        "content": "[@Miiza](/Miiza) Where this is mentioned? My code accepted at just return pow(x,n)"
                    },
                    {
                        "username": "Braderbell",
                        "content": "return pow(x, n)"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "as of  this we should know the implementation of x**n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "is it working"
                    },
                    {
                        "username": "Miiza",
                        "content": "Only that this is using pow(x, n) in the background, which you\\'re not suppose to use."
                    },
                    {
                        "username": "henrygriffin330",
                        "content": "this is what i did"
                    },
                    {
                        "username": "yanyehe",
                        "content": "duh"
                    },
                    {
                        "username": "JainAnshul",
                        "content": "for Python, is there anything better (in terms of complexity) than this? Otherwise, this seems to be obvious."
                    },
                    {
                        "username": "olooney",
                        "content": "This is the 37th problem I\\'ve solved on the site and in the end I got a respectible 4ms solution. But honestly, It seems like its 2% algorithm, 98% fiddling with binary representations of signed integers and floating point numbers. I also note that, as of this writing, the problem has 1160 downvotes to 428 upvotes, so there\\'s certainly some shared negativity out there. \\n\\nPersonally, I didn\\'t enjoy this problem because I felt like I spent more time writing custom test cases for corner cases than I did programming. Frankly I cannot imagine getting this question in an interview and having the interviewer go, \"aha! but your solution doesn\\'t account for the case when n is -2^31 and x is exactly -1.0! There\\'s no way we\\'d hire such an incompetent programmer!\" And yet the way the acceptance tests are written, you need to nail *every* *single* corner case. Perhaps that frustration is limited to C/C++? Or there\\'s a different algorithm that more naturally accounts for these edge cases? \\n\\nWhat was your experience? Would you agree or disagree with my thesis that this is the worst problem on the site? "
                    },
                    {
                        "username": "samstafford",
                        "content": "funny, when I saw the title of this one, I initially presumed rational exponent, not integer.  I got all excited about Taylor Series with coefficient reuse.  In fact, I will try that."
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I personally don\\'t like questions that have math as a related topic, because that description is vague. Let\\'s say I want to do this problem, and I don\\'t know recursion, nor do I know how to get the power of a number. I can look in the related topics section, and see that I need to know recursion, and study that, before retrying the problem.\\n\\nWhat will I see for the other part of the problem? Just a generic statement, \"Math\". And sure, this problem tells you what to do, but what about the Climbing Stairs problem? The generic \"Math\" topic tells me nothing of the type of math knowledge needed to solve the problem."
                    },
                    {
                        "username": "adlong01",
                        "content": "[@super____hot](/super____hot) I get a considerably faster solution using log."
                    },
                    {
                        "username": "imfosf0r",
                        "content": "I\\'d disagree: your complaints about the edge cases are just how this function is supposed to work, because of how math works. If you get a different answer for -2^31 than everyone else, then the function isn\\'t working right yet."
                    },
                    {
                        "username": "super____hot",
                        "content": "in python x**n is the fastest method"
                    },
                    {
                        "username": "misterabdul",
                        "content": "I\\'m a C fan & I solve this problem using C. For me this is an interesting problem that let me learn again how the basic pow function could be implemented & let me try to optimize my solution to account for every corner cases. This is such a fun exercises in C IMO."
                    },
                    {
                        "username": "tylermatchett",
                        "content": "Here is a test case made by someone who was in a bad mood\\nx=-1\\nn=2147483647"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "This was a simple one. n%2 ==1, x^n is going to be -1. Because -1 ^ even number is equal to 1  AND -1^odd number is equal to -1."
                    },
                    {
                        "username": "sylvex",
                        "content": "```\\nx =\\n2.00000\\nn =\\n-2147483648\\n```\\nWhat even is the point of this edge case???"
                    },
                    {
                        "username": "tree9",
                        "content": "[@tojoSaha](/tojoSaha)  check this out please https://leetcode.com/problems/powx-n/solutions/4086833/beats-100-log-n-solution/ it handles the above case. Basically invert x and make n positive and carry on with same logic as for positive x and n. Take long N."
                    },
                    {
                        "username": "kavyamittal1282",
                        "content": "[@m_afnan2018](/m_afnan2018)  iam doing in java and geting the same error"
                    },
                    {
                        "username": "sandevil23",
                        "content": "i noticed that they have assigned int to n and here they are passing the upper and lower limits of long int "
                    },
                    {
                        "username": "amar180N_th",
                        "content": "hey I also got the same error here"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Use long long..."
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "[@tojoSaha](/tojoSaha) use abs"
                    },
                    {
                        "username": "issac_tirkey1",
                        "content": "[@heisenberg280](/heisenberg280) -2^31 = 2147483648 and the positive integer limits till 2147483647 i.e 2^31-1. So when n is negative and -2^31  when you multiply it with -1 to make positive it overflows so store -1*n into a temp variable of type long long and it should work. (before storing typecast it into long long)"
                    },
                    {
                        "username": "tojoSaha",
                        "content": "Were u able to find the solution to this test case?.. If so.. then please tell"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "To make sure that your algorithm is fast."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "How to solve this?"
                    },
                    {
                        "username": "shadowfax_",
                        "content": "just has the onsite and the interviewer tdidn\\'t want the recursive version but wanted the fast one with no recursion. \\n\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Hitro",
                        "content": "I\\'m wondering why you guys are not using builtin Math.pow() method??\\nPlease give me some insight.\\nThank you :)"
                    },
                    {
                        "username": "marcjeffs6",
                        "content": "[@barstow123](/barstow123) Is this real? I can go to FAANG and any given Sr developer will know how to recreate any built in method and explain its prime optimization?"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "We were asked to implement the built -in, which is basically Math.pow();\\nSo yeah, that\\'s what we\\'re doing"
                    },
                    {
                        "username": "barstow123",
                        "content": "The idea here is that we perform our work on the shoulders of giants.\\n\\nA more senior developer should be able to recreate built ins and explain how they are optimized if they want higher pay. for example, \"compile the solution in C++ for best performance\" is a good thing to say during senior interviews."
                    },
                    {
                        "username": "otherside2",
                        "content": "My C# code returns the expected Output for the below values when run in Visual Studio, but not here in Leetcode. Where is the disconnect? Could that be the reason why this question has so many thumbs down?\\n\\n240 / 304 test cases passed.\\nStatus: Wrong Answer\\n\\nSubmitted: 0\\xA0minutes ago\\nInput: \\n8.84372\\n-5\\nOutput: \\n0.0\\nExpected: \\n2e-05"
                    },
                    {
                        "username": "AYUSH-KATRE",
                        "content": "make 1 condition for n<0 and return 1/ans(that you are returning)"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Nishtha_2",
                        "content": "Question is under the catogery of binary search can someone suggest me solution with binary search"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@AdityaBhate](/AdityaBhate) IT doesn\\'t exist!!!"
                    },
                    {
                        "username": "r_shweta",
                        "content": "same\\n"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "To implement this problem in a naive way, we would need to multiply x with x for n times, as the n is too large, code would take ages to complete. Idea here is that once we find a square of x, we can multiply square of x with square of x to get x^4, we can again multiply x^4 with x^4 to get x^8 and so on and so forth.\\nx^1 * x^1 = x^(1+1) = x^2\\nx^2 * x^2 = x^(2+2) = x^4\\nx^4 * x^4 = x^(4+4) = x^8\\n.....\\nBy this way, we can reduce the time complexity from O(n) to O(log n), This problem comes under binary search as we are squaring(binary) each answer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "[@chickooo](/chickooo)  Actually it follows the concept of binary search, if you want to calculate for n = 4 you first calculate for  n = 2 and before calculating n = 2, you calculate n =1, so that you can obtain the solution in log(n) instead of calculating for 4 times it will take O(N) "
                    },
                    {
                        "username": "chickooo",
                        "content": "I don\\'t know why it was showing under the tag **binary search**, but the tags are now updated to **Math** and **Recursion**"
                    },
                    {
                        "username": "Will",
                        "content": "Please show me the code if any one can solve this using binary search. \\nThanks a lot!"
                    },
                    {
                        "username": "shivagama02",
                        "content": "The code for the same using binary search can be done in javascript. The code for the same is here: \\n\\nvar myPow = function(x, n) {\\n  if (n === 0) return 1;\\n  if (n > 0) return pow(x, n);\\n  if (n < 0) return 1 / pow(x, -n);\\n};\\n\\nvar pow = function (x, n) {\\n  if (n === 1) return x;\\n  var num = pow(x, Math.floor(n / 2));\\n  if (n % 2 === 0) {\\n    return num * num;\\n  } else {\\n    return x * num * num;\\n  }\\n};\\n\\n\\nThe code i tried has been accepted with time and space complexity of  O(log(n))."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@user2387402](/user2387402) Dude that's comment from 2015, that guy must've already moved on lol"
                    },
                    {
                        "username": "user2387402",
                        "content": "It\\'s not binary search. It is binary exploitation. Read the editorial."
                    },
                    {
                        "username": "mateenrehanbatt",
                        "content": "class Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n < 0:\\n            x = 1 / x\\n            n = -n\\n\\n        result = 1\\n        while n > 0:\\n            if n % 2 == 1:\\n                result *= x\\n            x *= x\\n            n //= 2\\n\\n        return result"
                    }
                ]
            },
            {
                "id": 1835821,
                "content": [
                    {
                        "username": "mrkanesir",
                        "content": "how am i supposed to NOT get stack overflow with n=2147483647 ..."
                    },
                    {
                        "username": "itsmesuni19",
                        "content": " if your solu is O(n) solu, use long long i in the loop"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "What are you doing bro, I didn\\'t get this error, try to solve in O(log N)"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "use python? "
                    },
                    {
                        "username": "19bec1397",
                        "content": "[@satyasanjay1999](/satyasanjay1999) how\\n"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "You should optimize the solution in logn time complexity. It will also reduce the stack size, then it will also run for n = -2147483648."
                    },
                    {
                        "username": "Linearly_Independent",
                        "content": "\\n\\n\\nreturn x**n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The point of Leetcode is interview practice.\\nWould you go to an interview, and if they ask how should you implement a fast power algorithm you give them the answer of `x**y`? The point is to test your math skills."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The first two words of the question ask you to implement pow(x, n). It's simply illogical to Implement it by calling itself."
                    },
                    {
                        "username": "Satyam_Mishra",
                        "content": "[@Miiza](/Miiza) Where this is mentioned? My code accepted at just return pow(x,n)"
                    },
                    {
                        "username": "Braderbell",
                        "content": "return pow(x, n)"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "as of  this we should know the implementation of x**n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "is it working"
                    },
                    {
                        "username": "Miiza",
                        "content": "Only that this is using pow(x, n) in the background, which you\\'re not suppose to use."
                    },
                    {
                        "username": "henrygriffin330",
                        "content": "this is what i did"
                    },
                    {
                        "username": "yanyehe",
                        "content": "duh"
                    },
                    {
                        "username": "JainAnshul",
                        "content": "for Python, is there anything better (in terms of complexity) than this? Otherwise, this seems to be obvious."
                    },
                    {
                        "username": "olooney",
                        "content": "This is the 37th problem I\\'ve solved on the site and in the end I got a respectible 4ms solution. But honestly, It seems like its 2% algorithm, 98% fiddling with binary representations of signed integers and floating point numbers. I also note that, as of this writing, the problem has 1160 downvotes to 428 upvotes, so there\\'s certainly some shared negativity out there. \\n\\nPersonally, I didn\\'t enjoy this problem because I felt like I spent more time writing custom test cases for corner cases than I did programming. Frankly I cannot imagine getting this question in an interview and having the interviewer go, \"aha! but your solution doesn\\'t account for the case when n is -2^31 and x is exactly -1.0! There\\'s no way we\\'d hire such an incompetent programmer!\" And yet the way the acceptance tests are written, you need to nail *every* *single* corner case. Perhaps that frustration is limited to C/C++? Or there\\'s a different algorithm that more naturally accounts for these edge cases? \\n\\nWhat was your experience? Would you agree or disagree with my thesis that this is the worst problem on the site? "
                    },
                    {
                        "username": "samstafford",
                        "content": "funny, when I saw the title of this one, I initially presumed rational exponent, not integer.  I got all excited about Taylor Series with coefficient reuse.  In fact, I will try that."
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I personally don\\'t like questions that have math as a related topic, because that description is vague. Let\\'s say I want to do this problem, and I don\\'t know recursion, nor do I know how to get the power of a number. I can look in the related topics section, and see that I need to know recursion, and study that, before retrying the problem.\\n\\nWhat will I see for the other part of the problem? Just a generic statement, \"Math\". And sure, this problem tells you what to do, but what about the Climbing Stairs problem? The generic \"Math\" topic tells me nothing of the type of math knowledge needed to solve the problem."
                    },
                    {
                        "username": "adlong01",
                        "content": "[@super____hot](/super____hot) I get a considerably faster solution using log."
                    },
                    {
                        "username": "imfosf0r",
                        "content": "I\\'d disagree: your complaints about the edge cases are just how this function is supposed to work, because of how math works. If you get a different answer for -2^31 than everyone else, then the function isn\\'t working right yet."
                    },
                    {
                        "username": "super____hot",
                        "content": "in python x**n is the fastest method"
                    },
                    {
                        "username": "misterabdul",
                        "content": "I\\'m a C fan & I solve this problem using C. For me this is an interesting problem that let me learn again how the basic pow function could be implemented & let me try to optimize my solution to account for every corner cases. This is such a fun exercises in C IMO."
                    },
                    {
                        "username": "tylermatchett",
                        "content": "Here is a test case made by someone who was in a bad mood\\nx=-1\\nn=2147483647"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "This was a simple one. n%2 ==1, x^n is going to be -1. Because -1 ^ even number is equal to 1  AND -1^odd number is equal to -1."
                    },
                    {
                        "username": "sylvex",
                        "content": "```\\nx =\\n2.00000\\nn =\\n-2147483648\\n```\\nWhat even is the point of this edge case???"
                    },
                    {
                        "username": "tree9",
                        "content": "[@tojoSaha](/tojoSaha)  check this out please https://leetcode.com/problems/powx-n/solutions/4086833/beats-100-log-n-solution/ it handles the above case. Basically invert x and make n positive and carry on with same logic as for positive x and n. Take long N."
                    },
                    {
                        "username": "kavyamittal1282",
                        "content": "[@m_afnan2018](/m_afnan2018)  iam doing in java and geting the same error"
                    },
                    {
                        "username": "sandevil23",
                        "content": "i noticed that they have assigned int to n and here they are passing the upper and lower limits of long int "
                    },
                    {
                        "username": "amar180N_th",
                        "content": "hey I also got the same error here"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Use long long..."
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "[@tojoSaha](/tojoSaha) use abs"
                    },
                    {
                        "username": "issac_tirkey1",
                        "content": "[@heisenberg280](/heisenberg280) -2^31 = 2147483648 and the positive integer limits till 2147483647 i.e 2^31-1. So when n is negative and -2^31  when you multiply it with -1 to make positive it overflows so store -1*n into a temp variable of type long long and it should work. (before storing typecast it into long long)"
                    },
                    {
                        "username": "tojoSaha",
                        "content": "Were u able to find the solution to this test case?.. If so.. then please tell"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "To make sure that your algorithm is fast."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "How to solve this?"
                    },
                    {
                        "username": "shadowfax_",
                        "content": "just has the onsite and the interviewer tdidn\\'t want the recursive version but wanted the fast one with no recursion. \\n\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Hitro",
                        "content": "I\\'m wondering why you guys are not using builtin Math.pow() method??\\nPlease give me some insight.\\nThank you :)"
                    },
                    {
                        "username": "marcjeffs6",
                        "content": "[@barstow123](/barstow123) Is this real? I can go to FAANG and any given Sr developer will know how to recreate any built in method and explain its prime optimization?"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "We were asked to implement the built -in, which is basically Math.pow();\\nSo yeah, that\\'s what we\\'re doing"
                    },
                    {
                        "username": "barstow123",
                        "content": "The idea here is that we perform our work on the shoulders of giants.\\n\\nA more senior developer should be able to recreate built ins and explain how they are optimized if they want higher pay. for example, \"compile the solution in C++ for best performance\" is a good thing to say during senior interviews."
                    },
                    {
                        "username": "otherside2",
                        "content": "My C# code returns the expected Output for the below values when run in Visual Studio, but not here in Leetcode. Where is the disconnect? Could that be the reason why this question has so many thumbs down?\\n\\n240 / 304 test cases passed.\\nStatus: Wrong Answer\\n\\nSubmitted: 0\\xA0minutes ago\\nInput: \\n8.84372\\n-5\\nOutput: \\n0.0\\nExpected: \\n2e-05"
                    },
                    {
                        "username": "AYUSH-KATRE",
                        "content": "make 1 condition for n<0 and return 1/ans(that you are returning)"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Nishtha_2",
                        "content": "Question is under the catogery of binary search can someone suggest me solution with binary search"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@AdityaBhate](/AdityaBhate) IT doesn\\'t exist!!!"
                    },
                    {
                        "username": "r_shweta",
                        "content": "same\\n"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "To implement this problem in a naive way, we would need to multiply x with x for n times, as the n is too large, code would take ages to complete. Idea here is that once we find a square of x, we can multiply square of x with square of x to get x^4, we can again multiply x^4 with x^4 to get x^8 and so on and so forth.\\nx^1 * x^1 = x^(1+1) = x^2\\nx^2 * x^2 = x^(2+2) = x^4\\nx^4 * x^4 = x^(4+4) = x^8\\n.....\\nBy this way, we can reduce the time complexity from O(n) to O(log n), This problem comes under binary search as we are squaring(binary) each answer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "[@chickooo](/chickooo)  Actually it follows the concept of binary search, if you want to calculate for n = 4 you first calculate for  n = 2 and before calculating n = 2, you calculate n =1, so that you can obtain the solution in log(n) instead of calculating for 4 times it will take O(N) "
                    },
                    {
                        "username": "chickooo",
                        "content": "I don\\'t know why it was showing under the tag **binary search**, but the tags are now updated to **Math** and **Recursion**"
                    },
                    {
                        "username": "Will",
                        "content": "Please show me the code if any one can solve this using binary search. \\nThanks a lot!"
                    },
                    {
                        "username": "shivagama02",
                        "content": "The code for the same using binary search can be done in javascript. The code for the same is here: \\n\\nvar myPow = function(x, n) {\\n  if (n === 0) return 1;\\n  if (n > 0) return pow(x, n);\\n  if (n < 0) return 1 / pow(x, -n);\\n};\\n\\nvar pow = function (x, n) {\\n  if (n === 1) return x;\\n  var num = pow(x, Math.floor(n / 2));\\n  if (n % 2 === 0) {\\n    return num * num;\\n  } else {\\n    return x * num * num;\\n  }\\n};\\n\\n\\nThe code i tried has been accepted with time and space complexity of  O(log(n))."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@user2387402](/user2387402) Dude that's comment from 2015, that guy must've already moved on lol"
                    },
                    {
                        "username": "user2387402",
                        "content": "It\\'s not binary search. It is binary exploitation. Read the editorial."
                    },
                    {
                        "username": "mateenrehanbatt",
                        "content": "class Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n < 0:\\n            x = 1 / x\\n            n = -n\\n\\n        result = 1\\n        while n > 0:\\n            if n % 2 == 1:\\n                result *= x\\n            x *= x\\n            n //= 2\\n\\n        return result"
                    }
                ]
            },
            {
                "id": 1570780,
                "content": [
                    {
                        "username": "mrkanesir",
                        "content": "how am i supposed to NOT get stack overflow with n=2147483647 ..."
                    },
                    {
                        "username": "itsmesuni19",
                        "content": " if your solu is O(n) solu, use long long i in the loop"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "What are you doing bro, I didn\\'t get this error, try to solve in O(log N)"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "use python? "
                    },
                    {
                        "username": "19bec1397",
                        "content": "[@satyasanjay1999](/satyasanjay1999) how\\n"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "You should optimize the solution in logn time complexity. It will also reduce the stack size, then it will also run for n = -2147483648."
                    },
                    {
                        "username": "Linearly_Independent",
                        "content": "\\n\\n\\nreturn x**n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The point of Leetcode is interview practice.\\nWould you go to an interview, and if they ask how should you implement a fast power algorithm you give them the answer of `x**y`? The point is to test your math skills."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The first two words of the question ask you to implement pow(x, n). It's simply illogical to Implement it by calling itself."
                    },
                    {
                        "username": "Satyam_Mishra",
                        "content": "[@Miiza](/Miiza) Where this is mentioned? My code accepted at just return pow(x,n)"
                    },
                    {
                        "username": "Braderbell",
                        "content": "return pow(x, n)"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "as of  this we should know the implementation of x**n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "is it working"
                    },
                    {
                        "username": "Miiza",
                        "content": "Only that this is using pow(x, n) in the background, which you\\'re not suppose to use."
                    },
                    {
                        "username": "henrygriffin330",
                        "content": "this is what i did"
                    },
                    {
                        "username": "yanyehe",
                        "content": "duh"
                    },
                    {
                        "username": "JainAnshul",
                        "content": "for Python, is there anything better (in terms of complexity) than this? Otherwise, this seems to be obvious."
                    },
                    {
                        "username": "olooney",
                        "content": "This is the 37th problem I\\'ve solved on the site and in the end I got a respectible 4ms solution. But honestly, It seems like its 2% algorithm, 98% fiddling with binary representations of signed integers and floating point numbers. I also note that, as of this writing, the problem has 1160 downvotes to 428 upvotes, so there\\'s certainly some shared negativity out there. \\n\\nPersonally, I didn\\'t enjoy this problem because I felt like I spent more time writing custom test cases for corner cases than I did programming. Frankly I cannot imagine getting this question in an interview and having the interviewer go, \"aha! but your solution doesn\\'t account for the case when n is -2^31 and x is exactly -1.0! There\\'s no way we\\'d hire such an incompetent programmer!\" And yet the way the acceptance tests are written, you need to nail *every* *single* corner case. Perhaps that frustration is limited to C/C++? Or there\\'s a different algorithm that more naturally accounts for these edge cases? \\n\\nWhat was your experience? Would you agree or disagree with my thesis that this is the worst problem on the site? "
                    },
                    {
                        "username": "samstafford",
                        "content": "funny, when I saw the title of this one, I initially presumed rational exponent, not integer.  I got all excited about Taylor Series with coefficient reuse.  In fact, I will try that."
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I personally don\\'t like questions that have math as a related topic, because that description is vague. Let\\'s say I want to do this problem, and I don\\'t know recursion, nor do I know how to get the power of a number. I can look in the related topics section, and see that I need to know recursion, and study that, before retrying the problem.\\n\\nWhat will I see for the other part of the problem? Just a generic statement, \"Math\". And sure, this problem tells you what to do, but what about the Climbing Stairs problem? The generic \"Math\" topic tells me nothing of the type of math knowledge needed to solve the problem."
                    },
                    {
                        "username": "adlong01",
                        "content": "[@super____hot](/super____hot) I get a considerably faster solution using log."
                    },
                    {
                        "username": "imfosf0r",
                        "content": "I\\'d disagree: your complaints about the edge cases are just how this function is supposed to work, because of how math works. If you get a different answer for -2^31 than everyone else, then the function isn\\'t working right yet."
                    },
                    {
                        "username": "super____hot",
                        "content": "in python x**n is the fastest method"
                    },
                    {
                        "username": "misterabdul",
                        "content": "I\\'m a C fan & I solve this problem using C. For me this is an interesting problem that let me learn again how the basic pow function could be implemented & let me try to optimize my solution to account for every corner cases. This is such a fun exercises in C IMO."
                    },
                    {
                        "username": "tylermatchett",
                        "content": "Here is a test case made by someone who was in a bad mood\\nx=-1\\nn=2147483647"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "This was a simple one. n%2 ==1, x^n is going to be -1. Because -1 ^ even number is equal to 1  AND -1^odd number is equal to -1."
                    },
                    {
                        "username": "sylvex",
                        "content": "```\\nx =\\n2.00000\\nn =\\n-2147483648\\n```\\nWhat even is the point of this edge case???"
                    },
                    {
                        "username": "tree9",
                        "content": "[@tojoSaha](/tojoSaha)  check this out please https://leetcode.com/problems/powx-n/solutions/4086833/beats-100-log-n-solution/ it handles the above case. Basically invert x and make n positive and carry on with same logic as for positive x and n. Take long N."
                    },
                    {
                        "username": "kavyamittal1282",
                        "content": "[@m_afnan2018](/m_afnan2018)  iam doing in java and geting the same error"
                    },
                    {
                        "username": "sandevil23",
                        "content": "i noticed that they have assigned int to n and here they are passing the upper and lower limits of long int "
                    },
                    {
                        "username": "amar180N_th",
                        "content": "hey I also got the same error here"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Use long long..."
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "[@tojoSaha](/tojoSaha) use abs"
                    },
                    {
                        "username": "issac_tirkey1",
                        "content": "[@heisenberg280](/heisenberg280) -2^31 = 2147483648 and the positive integer limits till 2147483647 i.e 2^31-1. So when n is negative and -2^31  when you multiply it with -1 to make positive it overflows so store -1*n into a temp variable of type long long and it should work. (before storing typecast it into long long)"
                    },
                    {
                        "username": "tojoSaha",
                        "content": "Were u able to find the solution to this test case?.. If so.. then please tell"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "To make sure that your algorithm is fast."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "How to solve this?"
                    },
                    {
                        "username": "shadowfax_",
                        "content": "just has the onsite and the interviewer tdidn\\'t want the recursive version but wanted the fast one with no recursion. \\n\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Hitro",
                        "content": "I\\'m wondering why you guys are not using builtin Math.pow() method??\\nPlease give me some insight.\\nThank you :)"
                    },
                    {
                        "username": "marcjeffs6",
                        "content": "[@barstow123](/barstow123) Is this real? I can go to FAANG and any given Sr developer will know how to recreate any built in method and explain its prime optimization?"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "We were asked to implement the built -in, which is basically Math.pow();\\nSo yeah, that\\'s what we\\'re doing"
                    },
                    {
                        "username": "barstow123",
                        "content": "The idea here is that we perform our work on the shoulders of giants.\\n\\nA more senior developer should be able to recreate built ins and explain how they are optimized if they want higher pay. for example, \"compile the solution in C++ for best performance\" is a good thing to say during senior interviews."
                    },
                    {
                        "username": "otherside2",
                        "content": "My C# code returns the expected Output for the below values when run in Visual Studio, but not here in Leetcode. Where is the disconnect? Could that be the reason why this question has so many thumbs down?\\n\\n240 / 304 test cases passed.\\nStatus: Wrong Answer\\n\\nSubmitted: 0\\xA0minutes ago\\nInput: \\n8.84372\\n-5\\nOutput: \\n0.0\\nExpected: \\n2e-05"
                    },
                    {
                        "username": "AYUSH-KATRE",
                        "content": "make 1 condition for n<0 and return 1/ans(that you are returning)"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Nishtha_2",
                        "content": "Question is under the catogery of binary search can someone suggest me solution with binary search"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@AdityaBhate](/AdityaBhate) IT doesn\\'t exist!!!"
                    },
                    {
                        "username": "r_shweta",
                        "content": "same\\n"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "To implement this problem in a naive way, we would need to multiply x with x for n times, as the n is too large, code would take ages to complete. Idea here is that once we find a square of x, we can multiply square of x with square of x to get x^4, we can again multiply x^4 with x^4 to get x^8 and so on and so forth.\\nx^1 * x^1 = x^(1+1) = x^2\\nx^2 * x^2 = x^(2+2) = x^4\\nx^4 * x^4 = x^(4+4) = x^8\\n.....\\nBy this way, we can reduce the time complexity from O(n) to O(log n), This problem comes under binary search as we are squaring(binary) each answer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "[@chickooo](/chickooo)  Actually it follows the concept of binary search, if you want to calculate for n = 4 you first calculate for  n = 2 and before calculating n = 2, you calculate n =1, so that you can obtain the solution in log(n) instead of calculating for 4 times it will take O(N) "
                    },
                    {
                        "username": "chickooo",
                        "content": "I don\\'t know why it was showing under the tag **binary search**, but the tags are now updated to **Math** and **Recursion**"
                    },
                    {
                        "username": "Will",
                        "content": "Please show me the code if any one can solve this using binary search. \\nThanks a lot!"
                    },
                    {
                        "username": "shivagama02",
                        "content": "The code for the same using binary search can be done in javascript. The code for the same is here: \\n\\nvar myPow = function(x, n) {\\n  if (n === 0) return 1;\\n  if (n > 0) return pow(x, n);\\n  if (n < 0) return 1 / pow(x, -n);\\n};\\n\\nvar pow = function (x, n) {\\n  if (n === 1) return x;\\n  var num = pow(x, Math.floor(n / 2));\\n  if (n % 2 === 0) {\\n    return num * num;\\n  } else {\\n    return x * num * num;\\n  }\\n};\\n\\n\\nThe code i tried has been accepted with time and space complexity of  O(log(n))."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@user2387402](/user2387402) Dude that's comment from 2015, that guy must've already moved on lol"
                    },
                    {
                        "username": "user2387402",
                        "content": "It\\'s not binary search. It is binary exploitation. Read the editorial."
                    },
                    {
                        "username": "mateenrehanbatt",
                        "content": "class Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n < 0:\\n            x = 1 / x\\n            n = -n\\n\\n        result = 1\\n        while n > 0:\\n            if n % 2 == 1:\\n                result *= x\\n            x *= x\\n            n //= 2\\n\\n        return result"
                    }
                ]
            },
            {
                "id": 1572534,
                "content": [
                    {
                        "username": "mrkanesir",
                        "content": "how am i supposed to NOT get stack overflow with n=2147483647 ..."
                    },
                    {
                        "username": "itsmesuni19",
                        "content": " if your solu is O(n) solu, use long long i in the loop"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "What are you doing bro, I didn\\'t get this error, try to solve in O(log N)"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "use python? "
                    },
                    {
                        "username": "19bec1397",
                        "content": "[@satyasanjay1999](/satyasanjay1999) how\\n"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "You should optimize the solution in logn time complexity. It will also reduce the stack size, then it will also run for n = -2147483648."
                    },
                    {
                        "username": "Linearly_Independent",
                        "content": "\\n\\n\\nreturn x**n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The point of Leetcode is interview practice.\\nWould you go to an interview, and if they ask how should you implement a fast power algorithm you give them the answer of `x**y`? The point is to test your math skills."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The first two words of the question ask you to implement pow(x, n). It's simply illogical to Implement it by calling itself."
                    },
                    {
                        "username": "Satyam_Mishra",
                        "content": "[@Miiza](/Miiza) Where this is mentioned? My code accepted at just return pow(x,n)"
                    },
                    {
                        "username": "Braderbell",
                        "content": "return pow(x, n)"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "as of  this we should know the implementation of x**n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "is it working"
                    },
                    {
                        "username": "Miiza",
                        "content": "Only that this is using pow(x, n) in the background, which you\\'re not suppose to use."
                    },
                    {
                        "username": "henrygriffin330",
                        "content": "this is what i did"
                    },
                    {
                        "username": "yanyehe",
                        "content": "duh"
                    },
                    {
                        "username": "JainAnshul",
                        "content": "for Python, is there anything better (in terms of complexity) than this? Otherwise, this seems to be obvious."
                    },
                    {
                        "username": "olooney",
                        "content": "This is the 37th problem I\\'ve solved on the site and in the end I got a respectible 4ms solution. But honestly, It seems like its 2% algorithm, 98% fiddling with binary representations of signed integers and floating point numbers. I also note that, as of this writing, the problem has 1160 downvotes to 428 upvotes, so there\\'s certainly some shared negativity out there. \\n\\nPersonally, I didn\\'t enjoy this problem because I felt like I spent more time writing custom test cases for corner cases than I did programming. Frankly I cannot imagine getting this question in an interview and having the interviewer go, \"aha! but your solution doesn\\'t account for the case when n is -2^31 and x is exactly -1.0! There\\'s no way we\\'d hire such an incompetent programmer!\" And yet the way the acceptance tests are written, you need to nail *every* *single* corner case. Perhaps that frustration is limited to C/C++? Or there\\'s a different algorithm that more naturally accounts for these edge cases? \\n\\nWhat was your experience? Would you agree or disagree with my thesis that this is the worst problem on the site? "
                    },
                    {
                        "username": "samstafford",
                        "content": "funny, when I saw the title of this one, I initially presumed rational exponent, not integer.  I got all excited about Taylor Series with coefficient reuse.  In fact, I will try that."
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I personally don\\'t like questions that have math as a related topic, because that description is vague. Let\\'s say I want to do this problem, and I don\\'t know recursion, nor do I know how to get the power of a number. I can look in the related topics section, and see that I need to know recursion, and study that, before retrying the problem.\\n\\nWhat will I see for the other part of the problem? Just a generic statement, \"Math\". And sure, this problem tells you what to do, but what about the Climbing Stairs problem? The generic \"Math\" topic tells me nothing of the type of math knowledge needed to solve the problem."
                    },
                    {
                        "username": "adlong01",
                        "content": "[@super____hot](/super____hot) I get a considerably faster solution using log."
                    },
                    {
                        "username": "imfosf0r",
                        "content": "I\\'d disagree: your complaints about the edge cases are just how this function is supposed to work, because of how math works. If you get a different answer for -2^31 than everyone else, then the function isn\\'t working right yet."
                    },
                    {
                        "username": "super____hot",
                        "content": "in python x**n is the fastest method"
                    },
                    {
                        "username": "misterabdul",
                        "content": "I\\'m a C fan & I solve this problem using C. For me this is an interesting problem that let me learn again how the basic pow function could be implemented & let me try to optimize my solution to account for every corner cases. This is such a fun exercises in C IMO."
                    },
                    {
                        "username": "tylermatchett",
                        "content": "Here is a test case made by someone who was in a bad mood\\nx=-1\\nn=2147483647"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "This was a simple one. n%2 ==1, x^n is going to be -1. Because -1 ^ even number is equal to 1  AND -1^odd number is equal to -1."
                    },
                    {
                        "username": "sylvex",
                        "content": "```\\nx =\\n2.00000\\nn =\\n-2147483648\\n```\\nWhat even is the point of this edge case???"
                    },
                    {
                        "username": "tree9",
                        "content": "[@tojoSaha](/tojoSaha)  check this out please https://leetcode.com/problems/powx-n/solutions/4086833/beats-100-log-n-solution/ it handles the above case. Basically invert x and make n positive and carry on with same logic as for positive x and n. Take long N."
                    },
                    {
                        "username": "kavyamittal1282",
                        "content": "[@m_afnan2018](/m_afnan2018)  iam doing in java and geting the same error"
                    },
                    {
                        "username": "sandevil23",
                        "content": "i noticed that they have assigned int to n and here they are passing the upper and lower limits of long int "
                    },
                    {
                        "username": "amar180N_th",
                        "content": "hey I also got the same error here"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Use long long..."
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "[@tojoSaha](/tojoSaha) use abs"
                    },
                    {
                        "username": "issac_tirkey1",
                        "content": "[@heisenberg280](/heisenberg280) -2^31 = 2147483648 and the positive integer limits till 2147483647 i.e 2^31-1. So when n is negative and -2^31  when you multiply it with -1 to make positive it overflows so store -1*n into a temp variable of type long long and it should work. (before storing typecast it into long long)"
                    },
                    {
                        "username": "tojoSaha",
                        "content": "Were u able to find the solution to this test case?.. If so.. then please tell"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "To make sure that your algorithm is fast."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "How to solve this?"
                    },
                    {
                        "username": "shadowfax_",
                        "content": "just has the onsite and the interviewer tdidn\\'t want the recursive version but wanted the fast one with no recursion. \\n\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Hitro",
                        "content": "I\\'m wondering why you guys are not using builtin Math.pow() method??\\nPlease give me some insight.\\nThank you :)"
                    },
                    {
                        "username": "marcjeffs6",
                        "content": "[@barstow123](/barstow123) Is this real? I can go to FAANG and any given Sr developer will know how to recreate any built in method and explain its prime optimization?"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "We were asked to implement the built -in, which is basically Math.pow();\\nSo yeah, that\\'s what we\\'re doing"
                    },
                    {
                        "username": "barstow123",
                        "content": "The idea here is that we perform our work on the shoulders of giants.\\n\\nA more senior developer should be able to recreate built ins and explain how they are optimized if they want higher pay. for example, \"compile the solution in C++ for best performance\" is a good thing to say during senior interviews."
                    },
                    {
                        "username": "otherside2",
                        "content": "My C# code returns the expected Output for the below values when run in Visual Studio, but not here in Leetcode. Where is the disconnect? Could that be the reason why this question has so many thumbs down?\\n\\n240 / 304 test cases passed.\\nStatus: Wrong Answer\\n\\nSubmitted: 0\\xA0minutes ago\\nInput: \\n8.84372\\n-5\\nOutput: \\n0.0\\nExpected: \\n2e-05"
                    },
                    {
                        "username": "AYUSH-KATRE",
                        "content": "make 1 condition for n<0 and return 1/ans(that you are returning)"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Nishtha_2",
                        "content": "Question is under the catogery of binary search can someone suggest me solution with binary search"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@AdityaBhate](/AdityaBhate) IT doesn\\'t exist!!!"
                    },
                    {
                        "username": "r_shweta",
                        "content": "same\\n"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "To implement this problem in a naive way, we would need to multiply x with x for n times, as the n is too large, code would take ages to complete. Idea here is that once we find a square of x, we can multiply square of x with square of x to get x^4, we can again multiply x^4 with x^4 to get x^8 and so on and so forth.\\nx^1 * x^1 = x^(1+1) = x^2\\nx^2 * x^2 = x^(2+2) = x^4\\nx^4 * x^4 = x^(4+4) = x^8\\n.....\\nBy this way, we can reduce the time complexity from O(n) to O(log n), This problem comes under binary search as we are squaring(binary) each answer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "[@chickooo](/chickooo)  Actually it follows the concept of binary search, if you want to calculate for n = 4 you first calculate for  n = 2 and before calculating n = 2, you calculate n =1, so that you can obtain the solution in log(n) instead of calculating for 4 times it will take O(N) "
                    },
                    {
                        "username": "chickooo",
                        "content": "I don\\'t know why it was showing under the tag **binary search**, but the tags are now updated to **Math** and **Recursion**"
                    },
                    {
                        "username": "Will",
                        "content": "Please show me the code if any one can solve this using binary search. \\nThanks a lot!"
                    },
                    {
                        "username": "shivagama02",
                        "content": "The code for the same using binary search can be done in javascript. The code for the same is here: \\n\\nvar myPow = function(x, n) {\\n  if (n === 0) return 1;\\n  if (n > 0) return pow(x, n);\\n  if (n < 0) return 1 / pow(x, -n);\\n};\\n\\nvar pow = function (x, n) {\\n  if (n === 1) return x;\\n  var num = pow(x, Math.floor(n / 2));\\n  if (n % 2 === 0) {\\n    return num * num;\\n  } else {\\n    return x * num * num;\\n  }\\n};\\n\\n\\nThe code i tried has been accepted with time and space complexity of  O(log(n))."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@user2387402](/user2387402) Dude that's comment from 2015, that guy must've already moved on lol"
                    },
                    {
                        "username": "user2387402",
                        "content": "It\\'s not binary search. It is binary exploitation. Read the editorial."
                    },
                    {
                        "username": "mateenrehanbatt",
                        "content": "class Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n < 0:\\n            x = 1 / x\\n            n = -n\\n\\n        result = 1\\n        while n > 0:\\n            if n % 2 == 1:\\n                result *= x\\n            x *= x\\n            n //= 2\\n\\n        return result"
                    }
                ]
            },
            {
                "id": 1572134,
                "content": [
                    {
                        "username": "mrkanesir",
                        "content": "how am i supposed to NOT get stack overflow with n=2147483647 ..."
                    },
                    {
                        "username": "itsmesuni19",
                        "content": " if your solu is O(n) solu, use long long i in the loop"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "What are you doing bro, I didn\\'t get this error, try to solve in O(log N)"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "use python? "
                    },
                    {
                        "username": "19bec1397",
                        "content": "[@satyasanjay1999](/satyasanjay1999) how\\n"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "You should optimize the solution in logn time complexity. It will also reduce the stack size, then it will also run for n = -2147483648."
                    },
                    {
                        "username": "Linearly_Independent",
                        "content": "\\n\\n\\nreturn x**n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The point of Leetcode is interview practice.\\nWould you go to an interview, and if they ask how should you implement a fast power algorithm you give them the answer of `x**y`? The point is to test your math skills."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The first two words of the question ask you to implement pow(x, n). It's simply illogical to Implement it by calling itself."
                    },
                    {
                        "username": "Satyam_Mishra",
                        "content": "[@Miiza](/Miiza) Where this is mentioned? My code accepted at just return pow(x,n)"
                    },
                    {
                        "username": "Braderbell",
                        "content": "return pow(x, n)"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "as of  this we should know the implementation of x**n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "is it working"
                    },
                    {
                        "username": "Miiza",
                        "content": "Only that this is using pow(x, n) in the background, which you\\'re not suppose to use."
                    },
                    {
                        "username": "henrygriffin330",
                        "content": "this is what i did"
                    },
                    {
                        "username": "yanyehe",
                        "content": "duh"
                    },
                    {
                        "username": "JainAnshul",
                        "content": "for Python, is there anything better (in terms of complexity) than this? Otherwise, this seems to be obvious."
                    },
                    {
                        "username": "olooney",
                        "content": "This is the 37th problem I\\'ve solved on the site and in the end I got a respectible 4ms solution. But honestly, It seems like its 2% algorithm, 98% fiddling with binary representations of signed integers and floating point numbers. I also note that, as of this writing, the problem has 1160 downvotes to 428 upvotes, so there\\'s certainly some shared negativity out there. \\n\\nPersonally, I didn\\'t enjoy this problem because I felt like I spent more time writing custom test cases for corner cases than I did programming. Frankly I cannot imagine getting this question in an interview and having the interviewer go, \"aha! but your solution doesn\\'t account for the case when n is -2^31 and x is exactly -1.0! There\\'s no way we\\'d hire such an incompetent programmer!\" And yet the way the acceptance tests are written, you need to nail *every* *single* corner case. Perhaps that frustration is limited to C/C++? Or there\\'s a different algorithm that more naturally accounts for these edge cases? \\n\\nWhat was your experience? Would you agree or disagree with my thesis that this is the worst problem on the site? "
                    },
                    {
                        "username": "samstafford",
                        "content": "funny, when I saw the title of this one, I initially presumed rational exponent, not integer.  I got all excited about Taylor Series with coefficient reuse.  In fact, I will try that."
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I personally don\\'t like questions that have math as a related topic, because that description is vague. Let\\'s say I want to do this problem, and I don\\'t know recursion, nor do I know how to get the power of a number. I can look in the related topics section, and see that I need to know recursion, and study that, before retrying the problem.\\n\\nWhat will I see for the other part of the problem? Just a generic statement, \"Math\". And sure, this problem tells you what to do, but what about the Climbing Stairs problem? The generic \"Math\" topic tells me nothing of the type of math knowledge needed to solve the problem."
                    },
                    {
                        "username": "adlong01",
                        "content": "[@super____hot](/super____hot) I get a considerably faster solution using log."
                    },
                    {
                        "username": "imfosf0r",
                        "content": "I\\'d disagree: your complaints about the edge cases are just how this function is supposed to work, because of how math works. If you get a different answer for -2^31 than everyone else, then the function isn\\'t working right yet."
                    },
                    {
                        "username": "super____hot",
                        "content": "in python x**n is the fastest method"
                    },
                    {
                        "username": "misterabdul",
                        "content": "I\\'m a C fan & I solve this problem using C. For me this is an interesting problem that let me learn again how the basic pow function could be implemented & let me try to optimize my solution to account for every corner cases. This is such a fun exercises in C IMO."
                    },
                    {
                        "username": "tylermatchett",
                        "content": "Here is a test case made by someone who was in a bad mood\\nx=-1\\nn=2147483647"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "This was a simple one. n%2 ==1, x^n is going to be -1. Because -1 ^ even number is equal to 1  AND -1^odd number is equal to -1."
                    },
                    {
                        "username": "sylvex",
                        "content": "```\\nx =\\n2.00000\\nn =\\n-2147483648\\n```\\nWhat even is the point of this edge case???"
                    },
                    {
                        "username": "tree9",
                        "content": "[@tojoSaha](/tojoSaha)  check this out please https://leetcode.com/problems/powx-n/solutions/4086833/beats-100-log-n-solution/ it handles the above case. Basically invert x and make n positive and carry on with same logic as for positive x and n. Take long N."
                    },
                    {
                        "username": "kavyamittal1282",
                        "content": "[@m_afnan2018](/m_afnan2018)  iam doing in java and geting the same error"
                    },
                    {
                        "username": "sandevil23",
                        "content": "i noticed that they have assigned int to n and here they are passing the upper and lower limits of long int "
                    },
                    {
                        "username": "amar180N_th",
                        "content": "hey I also got the same error here"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Use long long..."
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "[@tojoSaha](/tojoSaha) use abs"
                    },
                    {
                        "username": "issac_tirkey1",
                        "content": "[@heisenberg280](/heisenberg280) -2^31 = 2147483648 and the positive integer limits till 2147483647 i.e 2^31-1. So when n is negative and -2^31  when you multiply it with -1 to make positive it overflows so store -1*n into a temp variable of type long long and it should work. (before storing typecast it into long long)"
                    },
                    {
                        "username": "tojoSaha",
                        "content": "Were u able to find the solution to this test case?.. If so.. then please tell"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "To make sure that your algorithm is fast."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "How to solve this?"
                    },
                    {
                        "username": "shadowfax_",
                        "content": "just has the onsite and the interviewer tdidn\\'t want the recursive version but wanted the fast one with no recursion. \\n\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Hitro",
                        "content": "I\\'m wondering why you guys are not using builtin Math.pow() method??\\nPlease give me some insight.\\nThank you :)"
                    },
                    {
                        "username": "marcjeffs6",
                        "content": "[@barstow123](/barstow123) Is this real? I can go to FAANG and any given Sr developer will know how to recreate any built in method and explain its prime optimization?"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "We were asked to implement the built -in, which is basically Math.pow();\\nSo yeah, that\\'s what we\\'re doing"
                    },
                    {
                        "username": "barstow123",
                        "content": "The idea here is that we perform our work on the shoulders of giants.\\n\\nA more senior developer should be able to recreate built ins and explain how they are optimized if they want higher pay. for example, \"compile the solution in C++ for best performance\" is a good thing to say during senior interviews."
                    },
                    {
                        "username": "otherside2",
                        "content": "My C# code returns the expected Output for the below values when run in Visual Studio, but not here in Leetcode. Where is the disconnect? Could that be the reason why this question has so many thumbs down?\\n\\n240 / 304 test cases passed.\\nStatus: Wrong Answer\\n\\nSubmitted: 0\\xA0minutes ago\\nInput: \\n8.84372\\n-5\\nOutput: \\n0.0\\nExpected: \\n2e-05"
                    },
                    {
                        "username": "AYUSH-KATRE",
                        "content": "make 1 condition for n<0 and return 1/ans(that you are returning)"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Nishtha_2",
                        "content": "Question is under the catogery of binary search can someone suggest me solution with binary search"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@AdityaBhate](/AdityaBhate) IT doesn\\'t exist!!!"
                    },
                    {
                        "username": "r_shweta",
                        "content": "same\\n"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "To implement this problem in a naive way, we would need to multiply x with x for n times, as the n is too large, code would take ages to complete. Idea here is that once we find a square of x, we can multiply square of x with square of x to get x^4, we can again multiply x^4 with x^4 to get x^8 and so on and so forth.\\nx^1 * x^1 = x^(1+1) = x^2\\nx^2 * x^2 = x^(2+2) = x^4\\nx^4 * x^4 = x^(4+4) = x^8\\n.....\\nBy this way, we can reduce the time complexity from O(n) to O(log n), This problem comes under binary search as we are squaring(binary) each answer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "[@chickooo](/chickooo)  Actually it follows the concept of binary search, if you want to calculate for n = 4 you first calculate for  n = 2 and before calculating n = 2, you calculate n =1, so that you can obtain the solution in log(n) instead of calculating for 4 times it will take O(N) "
                    },
                    {
                        "username": "chickooo",
                        "content": "I don\\'t know why it was showing under the tag **binary search**, but the tags are now updated to **Math** and **Recursion**"
                    },
                    {
                        "username": "Will",
                        "content": "Please show me the code if any one can solve this using binary search. \\nThanks a lot!"
                    },
                    {
                        "username": "shivagama02",
                        "content": "The code for the same using binary search can be done in javascript. The code for the same is here: \\n\\nvar myPow = function(x, n) {\\n  if (n === 0) return 1;\\n  if (n > 0) return pow(x, n);\\n  if (n < 0) return 1 / pow(x, -n);\\n};\\n\\nvar pow = function (x, n) {\\n  if (n === 1) return x;\\n  var num = pow(x, Math.floor(n / 2));\\n  if (n % 2 === 0) {\\n    return num * num;\\n  } else {\\n    return x * num * num;\\n  }\\n};\\n\\n\\nThe code i tried has been accepted with time and space complexity of  O(log(n))."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@user2387402](/user2387402) Dude that's comment from 2015, that guy must've already moved on lol"
                    },
                    {
                        "username": "user2387402",
                        "content": "It\\'s not binary search. It is binary exploitation. Read the editorial."
                    },
                    {
                        "username": "mateenrehanbatt",
                        "content": "class Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n < 0:\\n            x = 1 / x\\n            n = -n\\n\\n        result = 1\\n        while n > 0:\\n            if n % 2 == 1:\\n                result *= x\\n            x *= x\\n            n //= 2\\n\\n        return result"
                    }
                ]
            },
            {
                "id": 1565602,
                "content": [
                    {
                        "username": "mrkanesir",
                        "content": "how am i supposed to NOT get stack overflow with n=2147483647 ..."
                    },
                    {
                        "username": "itsmesuni19",
                        "content": " if your solu is O(n) solu, use long long i in the loop"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "What are you doing bro, I didn\\'t get this error, try to solve in O(log N)"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "use python? "
                    },
                    {
                        "username": "19bec1397",
                        "content": "[@satyasanjay1999](/satyasanjay1999) how\\n"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "You should optimize the solution in logn time complexity. It will also reduce the stack size, then it will also run for n = -2147483648."
                    },
                    {
                        "username": "Linearly_Independent",
                        "content": "\\n\\n\\nreturn x**n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The point of Leetcode is interview practice.\\nWould you go to an interview, and if they ask how should you implement a fast power algorithm you give them the answer of `x**y`? The point is to test your math skills."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The first two words of the question ask you to implement pow(x, n). It's simply illogical to Implement it by calling itself."
                    },
                    {
                        "username": "Satyam_Mishra",
                        "content": "[@Miiza](/Miiza) Where this is mentioned? My code accepted at just return pow(x,n)"
                    },
                    {
                        "username": "Braderbell",
                        "content": "return pow(x, n)"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "as of  this we should know the implementation of x**n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "is it working"
                    },
                    {
                        "username": "Miiza",
                        "content": "Only that this is using pow(x, n) in the background, which you\\'re not suppose to use."
                    },
                    {
                        "username": "henrygriffin330",
                        "content": "this is what i did"
                    },
                    {
                        "username": "yanyehe",
                        "content": "duh"
                    },
                    {
                        "username": "JainAnshul",
                        "content": "for Python, is there anything better (in terms of complexity) than this? Otherwise, this seems to be obvious."
                    },
                    {
                        "username": "olooney",
                        "content": "This is the 37th problem I\\'ve solved on the site and in the end I got a respectible 4ms solution. But honestly, It seems like its 2% algorithm, 98% fiddling with binary representations of signed integers and floating point numbers. I also note that, as of this writing, the problem has 1160 downvotes to 428 upvotes, so there\\'s certainly some shared negativity out there. \\n\\nPersonally, I didn\\'t enjoy this problem because I felt like I spent more time writing custom test cases for corner cases than I did programming. Frankly I cannot imagine getting this question in an interview and having the interviewer go, \"aha! but your solution doesn\\'t account for the case when n is -2^31 and x is exactly -1.0! There\\'s no way we\\'d hire such an incompetent programmer!\" And yet the way the acceptance tests are written, you need to nail *every* *single* corner case. Perhaps that frustration is limited to C/C++? Or there\\'s a different algorithm that more naturally accounts for these edge cases? \\n\\nWhat was your experience? Would you agree or disagree with my thesis that this is the worst problem on the site? "
                    },
                    {
                        "username": "samstafford",
                        "content": "funny, when I saw the title of this one, I initially presumed rational exponent, not integer.  I got all excited about Taylor Series with coefficient reuse.  In fact, I will try that."
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I personally don\\'t like questions that have math as a related topic, because that description is vague. Let\\'s say I want to do this problem, and I don\\'t know recursion, nor do I know how to get the power of a number. I can look in the related topics section, and see that I need to know recursion, and study that, before retrying the problem.\\n\\nWhat will I see for the other part of the problem? Just a generic statement, \"Math\". And sure, this problem tells you what to do, but what about the Climbing Stairs problem? The generic \"Math\" topic tells me nothing of the type of math knowledge needed to solve the problem."
                    },
                    {
                        "username": "adlong01",
                        "content": "[@super____hot](/super____hot) I get a considerably faster solution using log."
                    },
                    {
                        "username": "imfosf0r",
                        "content": "I\\'d disagree: your complaints about the edge cases are just how this function is supposed to work, because of how math works. If you get a different answer for -2^31 than everyone else, then the function isn\\'t working right yet."
                    },
                    {
                        "username": "super____hot",
                        "content": "in python x**n is the fastest method"
                    },
                    {
                        "username": "misterabdul",
                        "content": "I\\'m a C fan & I solve this problem using C. For me this is an interesting problem that let me learn again how the basic pow function could be implemented & let me try to optimize my solution to account for every corner cases. This is such a fun exercises in C IMO."
                    },
                    {
                        "username": "tylermatchett",
                        "content": "Here is a test case made by someone who was in a bad mood\\nx=-1\\nn=2147483647"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "This was a simple one. n%2 ==1, x^n is going to be -1. Because -1 ^ even number is equal to 1  AND -1^odd number is equal to -1."
                    },
                    {
                        "username": "sylvex",
                        "content": "```\\nx =\\n2.00000\\nn =\\n-2147483648\\n```\\nWhat even is the point of this edge case???"
                    },
                    {
                        "username": "tree9",
                        "content": "[@tojoSaha](/tojoSaha)  check this out please https://leetcode.com/problems/powx-n/solutions/4086833/beats-100-log-n-solution/ it handles the above case. Basically invert x and make n positive and carry on with same logic as for positive x and n. Take long N."
                    },
                    {
                        "username": "kavyamittal1282",
                        "content": "[@m_afnan2018](/m_afnan2018)  iam doing in java and geting the same error"
                    },
                    {
                        "username": "sandevil23",
                        "content": "i noticed that they have assigned int to n and here they are passing the upper and lower limits of long int "
                    },
                    {
                        "username": "amar180N_th",
                        "content": "hey I also got the same error here"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Use long long..."
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "[@tojoSaha](/tojoSaha) use abs"
                    },
                    {
                        "username": "issac_tirkey1",
                        "content": "[@heisenberg280](/heisenberg280) -2^31 = 2147483648 and the positive integer limits till 2147483647 i.e 2^31-1. So when n is negative and -2^31  when you multiply it with -1 to make positive it overflows so store -1*n into a temp variable of type long long and it should work. (before storing typecast it into long long)"
                    },
                    {
                        "username": "tojoSaha",
                        "content": "Were u able to find the solution to this test case?.. If so.. then please tell"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "To make sure that your algorithm is fast."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "How to solve this?"
                    },
                    {
                        "username": "shadowfax_",
                        "content": "just has the onsite and the interviewer tdidn\\'t want the recursive version but wanted the fast one with no recursion. \\n\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Hitro",
                        "content": "I\\'m wondering why you guys are not using builtin Math.pow() method??\\nPlease give me some insight.\\nThank you :)"
                    },
                    {
                        "username": "marcjeffs6",
                        "content": "[@barstow123](/barstow123) Is this real? I can go to FAANG and any given Sr developer will know how to recreate any built in method and explain its prime optimization?"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "We were asked to implement the built -in, which is basically Math.pow();\\nSo yeah, that\\'s what we\\'re doing"
                    },
                    {
                        "username": "barstow123",
                        "content": "The idea here is that we perform our work on the shoulders of giants.\\n\\nA more senior developer should be able to recreate built ins and explain how they are optimized if they want higher pay. for example, \"compile the solution in C++ for best performance\" is a good thing to say during senior interviews."
                    },
                    {
                        "username": "otherside2",
                        "content": "My C# code returns the expected Output for the below values when run in Visual Studio, but not here in Leetcode. Where is the disconnect? Could that be the reason why this question has so many thumbs down?\\n\\n240 / 304 test cases passed.\\nStatus: Wrong Answer\\n\\nSubmitted: 0\\xA0minutes ago\\nInput: \\n8.84372\\n-5\\nOutput: \\n0.0\\nExpected: \\n2e-05"
                    },
                    {
                        "username": "AYUSH-KATRE",
                        "content": "make 1 condition for n<0 and return 1/ans(that you are returning)"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Nishtha_2",
                        "content": "Question is under the catogery of binary search can someone suggest me solution with binary search"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@AdityaBhate](/AdityaBhate) IT doesn\\'t exist!!!"
                    },
                    {
                        "username": "r_shweta",
                        "content": "same\\n"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "To implement this problem in a naive way, we would need to multiply x with x for n times, as the n is too large, code would take ages to complete. Idea here is that once we find a square of x, we can multiply square of x with square of x to get x^4, we can again multiply x^4 with x^4 to get x^8 and so on and so forth.\\nx^1 * x^1 = x^(1+1) = x^2\\nx^2 * x^2 = x^(2+2) = x^4\\nx^4 * x^4 = x^(4+4) = x^8\\n.....\\nBy this way, we can reduce the time complexity from O(n) to O(log n), This problem comes under binary search as we are squaring(binary) each answer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "[@chickooo](/chickooo)  Actually it follows the concept of binary search, if you want to calculate for n = 4 you first calculate for  n = 2 and before calculating n = 2, you calculate n =1, so that you can obtain the solution in log(n) instead of calculating for 4 times it will take O(N) "
                    },
                    {
                        "username": "chickooo",
                        "content": "I don\\'t know why it was showing under the tag **binary search**, but the tags are now updated to **Math** and **Recursion**"
                    },
                    {
                        "username": "Will",
                        "content": "Please show me the code if any one can solve this using binary search. \\nThanks a lot!"
                    },
                    {
                        "username": "shivagama02",
                        "content": "The code for the same using binary search can be done in javascript. The code for the same is here: \\n\\nvar myPow = function(x, n) {\\n  if (n === 0) return 1;\\n  if (n > 0) return pow(x, n);\\n  if (n < 0) return 1 / pow(x, -n);\\n};\\n\\nvar pow = function (x, n) {\\n  if (n === 1) return x;\\n  var num = pow(x, Math.floor(n / 2));\\n  if (n % 2 === 0) {\\n    return num * num;\\n  } else {\\n    return x * num * num;\\n  }\\n};\\n\\n\\nThe code i tried has been accepted with time and space complexity of  O(log(n))."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@user2387402](/user2387402) Dude that's comment from 2015, that guy must've already moved on lol"
                    },
                    {
                        "username": "user2387402",
                        "content": "It\\'s not binary search. It is binary exploitation. Read the editorial."
                    },
                    {
                        "username": "mateenrehanbatt",
                        "content": "class Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n < 0:\\n            x = 1 / x\\n            n = -n\\n\\n        result = 1\\n        while n > 0:\\n            if n % 2 == 1:\\n                result *= x\\n            x *= x\\n            n //= 2\\n\\n        return result"
                    }
                ]
            },
            {
                "id": 1567826,
                "content": [
                    {
                        "username": "mrkanesir",
                        "content": "how am i supposed to NOT get stack overflow with n=2147483647 ..."
                    },
                    {
                        "username": "itsmesuni19",
                        "content": " if your solu is O(n) solu, use long long i in the loop"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "What are you doing bro, I didn\\'t get this error, try to solve in O(log N)"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "use python? "
                    },
                    {
                        "username": "19bec1397",
                        "content": "[@satyasanjay1999](/satyasanjay1999) how\\n"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "You should optimize the solution in logn time complexity. It will also reduce the stack size, then it will also run for n = -2147483648."
                    },
                    {
                        "username": "Linearly_Independent",
                        "content": "\\n\\n\\nreturn x**n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The point of Leetcode is interview practice.\\nWould you go to an interview, and if they ask how should you implement a fast power algorithm you give them the answer of `x**y`? The point is to test your math skills."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The first two words of the question ask you to implement pow(x, n). It's simply illogical to Implement it by calling itself."
                    },
                    {
                        "username": "Satyam_Mishra",
                        "content": "[@Miiza](/Miiza) Where this is mentioned? My code accepted at just return pow(x,n)"
                    },
                    {
                        "username": "Braderbell",
                        "content": "return pow(x, n)"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "as of  this we should know the implementation of x**n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "is it working"
                    },
                    {
                        "username": "Miiza",
                        "content": "Only that this is using pow(x, n) in the background, which you\\'re not suppose to use."
                    },
                    {
                        "username": "henrygriffin330",
                        "content": "this is what i did"
                    },
                    {
                        "username": "yanyehe",
                        "content": "duh"
                    },
                    {
                        "username": "JainAnshul",
                        "content": "for Python, is there anything better (in terms of complexity) than this? Otherwise, this seems to be obvious."
                    },
                    {
                        "username": "olooney",
                        "content": "This is the 37th problem I\\'ve solved on the site and in the end I got a respectible 4ms solution. But honestly, It seems like its 2% algorithm, 98% fiddling with binary representations of signed integers and floating point numbers. I also note that, as of this writing, the problem has 1160 downvotes to 428 upvotes, so there\\'s certainly some shared negativity out there. \\n\\nPersonally, I didn\\'t enjoy this problem because I felt like I spent more time writing custom test cases for corner cases than I did programming. Frankly I cannot imagine getting this question in an interview and having the interviewer go, \"aha! but your solution doesn\\'t account for the case when n is -2^31 and x is exactly -1.0! There\\'s no way we\\'d hire such an incompetent programmer!\" And yet the way the acceptance tests are written, you need to nail *every* *single* corner case. Perhaps that frustration is limited to C/C++? Or there\\'s a different algorithm that more naturally accounts for these edge cases? \\n\\nWhat was your experience? Would you agree or disagree with my thesis that this is the worst problem on the site? "
                    },
                    {
                        "username": "samstafford",
                        "content": "funny, when I saw the title of this one, I initially presumed rational exponent, not integer.  I got all excited about Taylor Series with coefficient reuse.  In fact, I will try that."
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I personally don\\'t like questions that have math as a related topic, because that description is vague. Let\\'s say I want to do this problem, and I don\\'t know recursion, nor do I know how to get the power of a number. I can look in the related topics section, and see that I need to know recursion, and study that, before retrying the problem.\\n\\nWhat will I see for the other part of the problem? Just a generic statement, \"Math\". And sure, this problem tells you what to do, but what about the Climbing Stairs problem? The generic \"Math\" topic tells me nothing of the type of math knowledge needed to solve the problem."
                    },
                    {
                        "username": "adlong01",
                        "content": "[@super____hot](/super____hot) I get a considerably faster solution using log."
                    },
                    {
                        "username": "imfosf0r",
                        "content": "I\\'d disagree: your complaints about the edge cases are just how this function is supposed to work, because of how math works. If you get a different answer for -2^31 than everyone else, then the function isn\\'t working right yet."
                    },
                    {
                        "username": "super____hot",
                        "content": "in python x**n is the fastest method"
                    },
                    {
                        "username": "misterabdul",
                        "content": "I\\'m a C fan & I solve this problem using C. For me this is an interesting problem that let me learn again how the basic pow function could be implemented & let me try to optimize my solution to account for every corner cases. This is such a fun exercises in C IMO."
                    },
                    {
                        "username": "tylermatchett",
                        "content": "Here is a test case made by someone who was in a bad mood\\nx=-1\\nn=2147483647"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "This was a simple one. n%2 ==1, x^n is going to be -1. Because -1 ^ even number is equal to 1  AND -1^odd number is equal to -1."
                    },
                    {
                        "username": "sylvex",
                        "content": "```\\nx =\\n2.00000\\nn =\\n-2147483648\\n```\\nWhat even is the point of this edge case???"
                    },
                    {
                        "username": "tree9",
                        "content": "[@tojoSaha](/tojoSaha)  check this out please https://leetcode.com/problems/powx-n/solutions/4086833/beats-100-log-n-solution/ it handles the above case. Basically invert x and make n positive and carry on with same logic as for positive x and n. Take long N."
                    },
                    {
                        "username": "kavyamittal1282",
                        "content": "[@m_afnan2018](/m_afnan2018)  iam doing in java and geting the same error"
                    },
                    {
                        "username": "sandevil23",
                        "content": "i noticed that they have assigned int to n and here they are passing the upper and lower limits of long int "
                    },
                    {
                        "username": "amar180N_th",
                        "content": "hey I also got the same error here"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Use long long..."
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "[@tojoSaha](/tojoSaha) use abs"
                    },
                    {
                        "username": "issac_tirkey1",
                        "content": "[@heisenberg280](/heisenberg280) -2^31 = 2147483648 and the positive integer limits till 2147483647 i.e 2^31-1. So when n is negative and -2^31  when you multiply it with -1 to make positive it overflows so store -1*n into a temp variable of type long long and it should work. (before storing typecast it into long long)"
                    },
                    {
                        "username": "tojoSaha",
                        "content": "Were u able to find the solution to this test case?.. If so.. then please tell"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "To make sure that your algorithm is fast."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "How to solve this?"
                    },
                    {
                        "username": "shadowfax_",
                        "content": "just has the onsite and the interviewer tdidn\\'t want the recursive version but wanted the fast one with no recursion. \\n\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Hitro",
                        "content": "I\\'m wondering why you guys are not using builtin Math.pow() method??\\nPlease give me some insight.\\nThank you :)"
                    },
                    {
                        "username": "marcjeffs6",
                        "content": "[@barstow123](/barstow123) Is this real? I can go to FAANG and any given Sr developer will know how to recreate any built in method and explain its prime optimization?"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "We were asked to implement the built -in, which is basically Math.pow();\\nSo yeah, that\\'s what we\\'re doing"
                    },
                    {
                        "username": "barstow123",
                        "content": "The idea here is that we perform our work on the shoulders of giants.\\n\\nA more senior developer should be able to recreate built ins and explain how they are optimized if they want higher pay. for example, \"compile the solution in C++ for best performance\" is a good thing to say during senior interviews."
                    },
                    {
                        "username": "otherside2",
                        "content": "My C# code returns the expected Output for the below values when run in Visual Studio, but not here in Leetcode. Where is the disconnect? Could that be the reason why this question has so many thumbs down?\\n\\n240 / 304 test cases passed.\\nStatus: Wrong Answer\\n\\nSubmitted: 0\\xA0minutes ago\\nInput: \\n8.84372\\n-5\\nOutput: \\n0.0\\nExpected: \\n2e-05"
                    },
                    {
                        "username": "AYUSH-KATRE",
                        "content": "make 1 condition for n<0 and return 1/ans(that you are returning)"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Nishtha_2",
                        "content": "Question is under the catogery of binary search can someone suggest me solution with binary search"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@AdityaBhate](/AdityaBhate) IT doesn\\'t exist!!!"
                    },
                    {
                        "username": "r_shweta",
                        "content": "same\\n"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "To implement this problem in a naive way, we would need to multiply x with x for n times, as the n is too large, code would take ages to complete. Idea here is that once we find a square of x, we can multiply square of x with square of x to get x^4, we can again multiply x^4 with x^4 to get x^8 and so on and so forth.\\nx^1 * x^1 = x^(1+1) = x^2\\nx^2 * x^2 = x^(2+2) = x^4\\nx^4 * x^4 = x^(4+4) = x^8\\n.....\\nBy this way, we can reduce the time complexity from O(n) to O(log n), This problem comes under binary search as we are squaring(binary) each answer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "[@chickooo](/chickooo)  Actually it follows the concept of binary search, if you want to calculate for n = 4 you first calculate for  n = 2 and before calculating n = 2, you calculate n =1, so that you can obtain the solution in log(n) instead of calculating for 4 times it will take O(N) "
                    },
                    {
                        "username": "chickooo",
                        "content": "I don\\'t know why it was showing under the tag **binary search**, but the tags are now updated to **Math** and **Recursion**"
                    },
                    {
                        "username": "Will",
                        "content": "Please show me the code if any one can solve this using binary search. \\nThanks a lot!"
                    },
                    {
                        "username": "shivagama02",
                        "content": "The code for the same using binary search can be done in javascript. The code for the same is here: \\n\\nvar myPow = function(x, n) {\\n  if (n === 0) return 1;\\n  if (n > 0) return pow(x, n);\\n  if (n < 0) return 1 / pow(x, -n);\\n};\\n\\nvar pow = function (x, n) {\\n  if (n === 1) return x;\\n  var num = pow(x, Math.floor(n / 2));\\n  if (n % 2 === 0) {\\n    return num * num;\\n  } else {\\n    return x * num * num;\\n  }\\n};\\n\\n\\nThe code i tried has been accepted with time and space complexity of  O(log(n))."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@user2387402](/user2387402) Dude that's comment from 2015, that guy must've already moved on lol"
                    },
                    {
                        "username": "user2387402",
                        "content": "It\\'s not binary search. It is binary exploitation. Read the editorial."
                    },
                    {
                        "username": "mateenrehanbatt",
                        "content": "class Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n < 0:\\n            x = 1 / x\\n            n = -n\\n\\n        result = 1\\n        while n > 0:\\n            if n % 2 == 1:\\n                result *= x\\n            x *= x\\n            n //= 2\\n\\n        return result"
                    }
                ]
            },
            {
                "id": 1805804,
                "content": [
                    {
                        "username": "mrkanesir",
                        "content": "how am i supposed to NOT get stack overflow with n=2147483647 ..."
                    },
                    {
                        "username": "itsmesuni19",
                        "content": " if your solu is O(n) solu, use long long i in the loop"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "What are you doing bro, I didn\\'t get this error, try to solve in O(log N)"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "use python? "
                    },
                    {
                        "username": "19bec1397",
                        "content": "[@satyasanjay1999](/satyasanjay1999) how\\n"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "You should optimize the solution in logn time complexity. It will also reduce the stack size, then it will also run for n = -2147483648."
                    },
                    {
                        "username": "Linearly_Independent",
                        "content": "\\n\\n\\nreturn x**n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The point of Leetcode is interview practice.\\nWould you go to an interview, and if they ask how should you implement a fast power algorithm you give them the answer of `x**y`? The point is to test your math skills."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The first two words of the question ask you to implement pow(x, n). It's simply illogical to Implement it by calling itself."
                    },
                    {
                        "username": "Satyam_Mishra",
                        "content": "[@Miiza](/Miiza) Where this is mentioned? My code accepted at just return pow(x,n)"
                    },
                    {
                        "username": "Braderbell",
                        "content": "return pow(x, n)"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "as of  this we should know the implementation of x**n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "is it working"
                    },
                    {
                        "username": "Miiza",
                        "content": "Only that this is using pow(x, n) in the background, which you\\'re not suppose to use."
                    },
                    {
                        "username": "henrygriffin330",
                        "content": "this is what i did"
                    },
                    {
                        "username": "yanyehe",
                        "content": "duh"
                    },
                    {
                        "username": "JainAnshul",
                        "content": "for Python, is there anything better (in terms of complexity) than this? Otherwise, this seems to be obvious."
                    },
                    {
                        "username": "olooney",
                        "content": "This is the 37th problem I\\'ve solved on the site and in the end I got a respectible 4ms solution. But honestly, It seems like its 2% algorithm, 98% fiddling with binary representations of signed integers and floating point numbers. I also note that, as of this writing, the problem has 1160 downvotes to 428 upvotes, so there\\'s certainly some shared negativity out there. \\n\\nPersonally, I didn\\'t enjoy this problem because I felt like I spent more time writing custom test cases for corner cases than I did programming. Frankly I cannot imagine getting this question in an interview and having the interviewer go, \"aha! but your solution doesn\\'t account for the case when n is -2^31 and x is exactly -1.0! There\\'s no way we\\'d hire such an incompetent programmer!\" And yet the way the acceptance tests are written, you need to nail *every* *single* corner case. Perhaps that frustration is limited to C/C++? Or there\\'s a different algorithm that more naturally accounts for these edge cases? \\n\\nWhat was your experience? Would you agree or disagree with my thesis that this is the worst problem on the site? "
                    },
                    {
                        "username": "samstafford",
                        "content": "funny, when I saw the title of this one, I initially presumed rational exponent, not integer.  I got all excited about Taylor Series with coefficient reuse.  In fact, I will try that."
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I personally don\\'t like questions that have math as a related topic, because that description is vague. Let\\'s say I want to do this problem, and I don\\'t know recursion, nor do I know how to get the power of a number. I can look in the related topics section, and see that I need to know recursion, and study that, before retrying the problem.\\n\\nWhat will I see for the other part of the problem? Just a generic statement, \"Math\". And sure, this problem tells you what to do, but what about the Climbing Stairs problem? The generic \"Math\" topic tells me nothing of the type of math knowledge needed to solve the problem."
                    },
                    {
                        "username": "adlong01",
                        "content": "[@super____hot](/super____hot) I get a considerably faster solution using log."
                    },
                    {
                        "username": "imfosf0r",
                        "content": "I\\'d disagree: your complaints about the edge cases are just how this function is supposed to work, because of how math works. If you get a different answer for -2^31 than everyone else, then the function isn\\'t working right yet."
                    },
                    {
                        "username": "super____hot",
                        "content": "in python x**n is the fastest method"
                    },
                    {
                        "username": "misterabdul",
                        "content": "I\\'m a C fan & I solve this problem using C. For me this is an interesting problem that let me learn again how the basic pow function could be implemented & let me try to optimize my solution to account for every corner cases. This is such a fun exercises in C IMO."
                    },
                    {
                        "username": "tylermatchett",
                        "content": "Here is a test case made by someone who was in a bad mood\\nx=-1\\nn=2147483647"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "This was a simple one. n%2 ==1, x^n is going to be -1. Because -1 ^ even number is equal to 1  AND -1^odd number is equal to -1."
                    },
                    {
                        "username": "sylvex",
                        "content": "```\\nx =\\n2.00000\\nn =\\n-2147483648\\n```\\nWhat even is the point of this edge case???"
                    },
                    {
                        "username": "tree9",
                        "content": "[@tojoSaha](/tojoSaha)  check this out please https://leetcode.com/problems/powx-n/solutions/4086833/beats-100-log-n-solution/ it handles the above case. Basically invert x and make n positive and carry on with same logic as for positive x and n. Take long N."
                    },
                    {
                        "username": "kavyamittal1282",
                        "content": "[@m_afnan2018](/m_afnan2018)  iam doing in java and geting the same error"
                    },
                    {
                        "username": "sandevil23",
                        "content": "i noticed that they have assigned int to n and here they are passing the upper and lower limits of long int "
                    },
                    {
                        "username": "amar180N_th",
                        "content": "hey I also got the same error here"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Use long long..."
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "[@tojoSaha](/tojoSaha) use abs"
                    },
                    {
                        "username": "issac_tirkey1",
                        "content": "[@heisenberg280](/heisenberg280) -2^31 = 2147483648 and the positive integer limits till 2147483647 i.e 2^31-1. So when n is negative and -2^31  when you multiply it with -1 to make positive it overflows so store -1*n into a temp variable of type long long and it should work. (before storing typecast it into long long)"
                    },
                    {
                        "username": "tojoSaha",
                        "content": "Were u able to find the solution to this test case?.. If so.. then please tell"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "To make sure that your algorithm is fast."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "How to solve this?"
                    },
                    {
                        "username": "shadowfax_",
                        "content": "just has the onsite and the interviewer tdidn\\'t want the recursive version but wanted the fast one with no recursion. \\n\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Hitro",
                        "content": "I\\'m wondering why you guys are not using builtin Math.pow() method??\\nPlease give me some insight.\\nThank you :)"
                    },
                    {
                        "username": "marcjeffs6",
                        "content": "[@barstow123](/barstow123) Is this real? I can go to FAANG and any given Sr developer will know how to recreate any built in method and explain its prime optimization?"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "We were asked to implement the built -in, which is basically Math.pow();\\nSo yeah, that\\'s what we\\'re doing"
                    },
                    {
                        "username": "barstow123",
                        "content": "The idea here is that we perform our work on the shoulders of giants.\\n\\nA more senior developer should be able to recreate built ins and explain how they are optimized if they want higher pay. for example, \"compile the solution in C++ for best performance\" is a good thing to say during senior interviews."
                    },
                    {
                        "username": "otherside2",
                        "content": "My C# code returns the expected Output for the below values when run in Visual Studio, but not here in Leetcode. Where is the disconnect? Could that be the reason why this question has so many thumbs down?\\n\\n240 / 304 test cases passed.\\nStatus: Wrong Answer\\n\\nSubmitted: 0\\xA0minutes ago\\nInput: \\n8.84372\\n-5\\nOutput: \\n0.0\\nExpected: \\n2e-05"
                    },
                    {
                        "username": "AYUSH-KATRE",
                        "content": "make 1 condition for n<0 and return 1/ans(that you are returning)"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Nishtha_2",
                        "content": "Question is under the catogery of binary search can someone suggest me solution with binary search"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@AdityaBhate](/AdityaBhate) IT doesn\\'t exist!!!"
                    },
                    {
                        "username": "r_shweta",
                        "content": "same\\n"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "To implement this problem in a naive way, we would need to multiply x with x for n times, as the n is too large, code would take ages to complete. Idea here is that once we find a square of x, we can multiply square of x with square of x to get x^4, we can again multiply x^4 with x^4 to get x^8 and so on and so forth.\\nx^1 * x^1 = x^(1+1) = x^2\\nx^2 * x^2 = x^(2+2) = x^4\\nx^4 * x^4 = x^(4+4) = x^8\\n.....\\nBy this way, we can reduce the time complexity from O(n) to O(log n), This problem comes under binary search as we are squaring(binary) each answer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "[@chickooo](/chickooo)  Actually it follows the concept of binary search, if you want to calculate for n = 4 you first calculate for  n = 2 and before calculating n = 2, you calculate n =1, so that you can obtain the solution in log(n) instead of calculating for 4 times it will take O(N) "
                    },
                    {
                        "username": "chickooo",
                        "content": "I don\\'t know why it was showing under the tag **binary search**, but the tags are now updated to **Math** and **Recursion**"
                    },
                    {
                        "username": "Will",
                        "content": "Please show me the code if any one can solve this using binary search. \\nThanks a lot!"
                    },
                    {
                        "username": "shivagama02",
                        "content": "The code for the same using binary search can be done in javascript. The code for the same is here: \\n\\nvar myPow = function(x, n) {\\n  if (n === 0) return 1;\\n  if (n > 0) return pow(x, n);\\n  if (n < 0) return 1 / pow(x, -n);\\n};\\n\\nvar pow = function (x, n) {\\n  if (n === 1) return x;\\n  var num = pow(x, Math.floor(n / 2));\\n  if (n % 2 === 0) {\\n    return num * num;\\n  } else {\\n    return x * num * num;\\n  }\\n};\\n\\n\\nThe code i tried has been accepted with time and space complexity of  O(log(n))."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@user2387402](/user2387402) Dude that's comment from 2015, that guy must've already moved on lol"
                    },
                    {
                        "username": "user2387402",
                        "content": "It\\'s not binary search. It is binary exploitation. Read the editorial."
                    },
                    {
                        "username": "mateenrehanbatt",
                        "content": "class Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n < 0:\\n            x = 1 / x\\n            n = -n\\n\\n        result = 1\\n        while n > 0:\\n            if n % 2 == 1:\\n                result *= x\\n            x *= x\\n            n //= 2\\n\\n        return result"
                    }
                ]
            },
            {
                "id": 1576589,
                "content": [
                    {
                        "username": "mrkanesir",
                        "content": "how am i supposed to NOT get stack overflow with n=2147483647 ..."
                    },
                    {
                        "username": "itsmesuni19",
                        "content": " if your solu is O(n) solu, use long long i in the loop"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "What are you doing bro, I didn\\'t get this error, try to solve in O(log N)"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "use python? "
                    },
                    {
                        "username": "19bec1397",
                        "content": "[@satyasanjay1999](/satyasanjay1999) how\\n"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "You should optimize the solution in logn time complexity. It will also reduce the stack size, then it will also run for n = -2147483648."
                    },
                    {
                        "username": "Linearly_Independent",
                        "content": "\\n\\n\\nreturn x**n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The point of Leetcode is interview practice.\\nWould you go to an interview, and if they ask how should you implement a fast power algorithm you give them the answer of `x**y`? The point is to test your math skills."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The first two words of the question ask you to implement pow(x, n). It's simply illogical to Implement it by calling itself."
                    },
                    {
                        "username": "Satyam_Mishra",
                        "content": "[@Miiza](/Miiza) Where this is mentioned? My code accepted at just return pow(x,n)"
                    },
                    {
                        "username": "Braderbell",
                        "content": "return pow(x, n)"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "as of  this we should know the implementation of x**n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "is it working"
                    },
                    {
                        "username": "Miiza",
                        "content": "Only that this is using pow(x, n) in the background, which you\\'re not suppose to use."
                    },
                    {
                        "username": "henrygriffin330",
                        "content": "this is what i did"
                    },
                    {
                        "username": "yanyehe",
                        "content": "duh"
                    },
                    {
                        "username": "JainAnshul",
                        "content": "for Python, is there anything better (in terms of complexity) than this? Otherwise, this seems to be obvious."
                    },
                    {
                        "username": "olooney",
                        "content": "This is the 37th problem I\\'ve solved on the site and in the end I got a respectible 4ms solution. But honestly, It seems like its 2% algorithm, 98% fiddling with binary representations of signed integers and floating point numbers. I also note that, as of this writing, the problem has 1160 downvotes to 428 upvotes, so there\\'s certainly some shared negativity out there. \\n\\nPersonally, I didn\\'t enjoy this problem because I felt like I spent more time writing custom test cases for corner cases than I did programming. Frankly I cannot imagine getting this question in an interview and having the interviewer go, \"aha! but your solution doesn\\'t account for the case when n is -2^31 and x is exactly -1.0! There\\'s no way we\\'d hire such an incompetent programmer!\" And yet the way the acceptance tests are written, you need to nail *every* *single* corner case. Perhaps that frustration is limited to C/C++? Or there\\'s a different algorithm that more naturally accounts for these edge cases? \\n\\nWhat was your experience? Would you agree or disagree with my thesis that this is the worst problem on the site? "
                    },
                    {
                        "username": "samstafford",
                        "content": "funny, when I saw the title of this one, I initially presumed rational exponent, not integer.  I got all excited about Taylor Series with coefficient reuse.  In fact, I will try that."
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I personally don\\'t like questions that have math as a related topic, because that description is vague. Let\\'s say I want to do this problem, and I don\\'t know recursion, nor do I know how to get the power of a number. I can look in the related topics section, and see that I need to know recursion, and study that, before retrying the problem.\\n\\nWhat will I see for the other part of the problem? Just a generic statement, \"Math\". And sure, this problem tells you what to do, but what about the Climbing Stairs problem? The generic \"Math\" topic tells me nothing of the type of math knowledge needed to solve the problem."
                    },
                    {
                        "username": "adlong01",
                        "content": "[@super____hot](/super____hot) I get a considerably faster solution using log."
                    },
                    {
                        "username": "imfosf0r",
                        "content": "I\\'d disagree: your complaints about the edge cases are just how this function is supposed to work, because of how math works. If you get a different answer for -2^31 than everyone else, then the function isn\\'t working right yet."
                    },
                    {
                        "username": "super____hot",
                        "content": "in python x**n is the fastest method"
                    },
                    {
                        "username": "misterabdul",
                        "content": "I\\'m a C fan & I solve this problem using C. For me this is an interesting problem that let me learn again how the basic pow function could be implemented & let me try to optimize my solution to account for every corner cases. This is such a fun exercises in C IMO."
                    },
                    {
                        "username": "tylermatchett",
                        "content": "Here is a test case made by someone who was in a bad mood\\nx=-1\\nn=2147483647"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "This was a simple one. n%2 ==1, x^n is going to be -1. Because -1 ^ even number is equal to 1  AND -1^odd number is equal to -1."
                    },
                    {
                        "username": "sylvex",
                        "content": "```\\nx =\\n2.00000\\nn =\\n-2147483648\\n```\\nWhat even is the point of this edge case???"
                    },
                    {
                        "username": "tree9",
                        "content": "[@tojoSaha](/tojoSaha)  check this out please https://leetcode.com/problems/powx-n/solutions/4086833/beats-100-log-n-solution/ it handles the above case. Basically invert x and make n positive and carry on with same logic as for positive x and n. Take long N."
                    },
                    {
                        "username": "kavyamittal1282",
                        "content": "[@m_afnan2018](/m_afnan2018)  iam doing in java and geting the same error"
                    },
                    {
                        "username": "sandevil23",
                        "content": "i noticed that they have assigned int to n and here they are passing the upper and lower limits of long int "
                    },
                    {
                        "username": "amar180N_th",
                        "content": "hey I also got the same error here"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Use long long..."
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "[@tojoSaha](/tojoSaha) use abs"
                    },
                    {
                        "username": "issac_tirkey1",
                        "content": "[@heisenberg280](/heisenberg280) -2^31 = 2147483648 and the positive integer limits till 2147483647 i.e 2^31-1. So when n is negative and -2^31  when you multiply it with -1 to make positive it overflows so store -1*n into a temp variable of type long long and it should work. (before storing typecast it into long long)"
                    },
                    {
                        "username": "tojoSaha",
                        "content": "Were u able to find the solution to this test case?.. If so.. then please tell"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "To make sure that your algorithm is fast."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "How to solve this?"
                    },
                    {
                        "username": "shadowfax_",
                        "content": "just has the onsite and the interviewer tdidn\\'t want the recursive version but wanted the fast one with no recursion. \\n\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Hitro",
                        "content": "I\\'m wondering why you guys are not using builtin Math.pow() method??\\nPlease give me some insight.\\nThank you :)"
                    },
                    {
                        "username": "marcjeffs6",
                        "content": "[@barstow123](/barstow123) Is this real? I can go to FAANG and any given Sr developer will know how to recreate any built in method and explain its prime optimization?"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "We were asked to implement the built -in, which is basically Math.pow();\\nSo yeah, that\\'s what we\\'re doing"
                    },
                    {
                        "username": "barstow123",
                        "content": "The idea here is that we perform our work on the shoulders of giants.\\n\\nA more senior developer should be able to recreate built ins and explain how they are optimized if they want higher pay. for example, \"compile the solution in C++ for best performance\" is a good thing to say during senior interviews."
                    },
                    {
                        "username": "otherside2",
                        "content": "My C# code returns the expected Output for the below values when run in Visual Studio, but not here in Leetcode. Where is the disconnect? Could that be the reason why this question has so many thumbs down?\\n\\n240 / 304 test cases passed.\\nStatus: Wrong Answer\\n\\nSubmitted: 0\\xA0minutes ago\\nInput: \\n8.84372\\n-5\\nOutput: \\n0.0\\nExpected: \\n2e-05"
                    },
                    {
                        "username": "AYUSH-KATRE",
                        "content": "make 1 condition for n<0 and return 1/ans(that you are returning)"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Nishtha_2",
                        "content": "Question is under the catogery of binary search can someone suggest me solution with binary search"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@AdityaBhate](/AdityaBhate) IT doesn\\'t exist!!!"
                    },
                    {
                        "username": "r_shweta",
                        "content": "same\\n"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "To implement this problem in a naive way, we would need to multiply x with x for n times, as the n is too large, code would take ages to complete. Idea here is that once we find a square of x, we can multiply square of x with square of x to get x^4, we can again multiply x^4 with x^4 to get x^8 and so on and so forth.\\nx^1 * x^1 = x^(1+1) = x^2\\nx^2 * x^2 = x^(2+2) = x^4\\nx^4 * x^4 = x^(4+4) = x^8\\n.....\\nBy this way, we can reduce the time complexity from O(n) to O(log n), This problem comes under binary search as we are squaring(binary) each answer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "[@chickooo](/chickooo)  Actually it follows the concept of binary search, if you want to calculate for n = 4 you first calculate for  n = 2 and before calculating n = 2, you calculate n =1, so that you can obtain the solution in log(n) instead of calculating for 4 times it will take O(N) "
                    },
                    {
                        "username": "chickooo",
                        "content": "I don\\'t know why it was showing under the tag **binary search**, but the tags are now updated to **Math** and **Recursion**"
                    },
                    {
                        "username": "Will",
                        "content": "Please show me the code if any one can solve this using binary search. \\nThanks a lot!"
                    },
                    {
                        "username": "shivagama02",
                        "content": "The code for the same using binary search can be done in javascript. The code for the same is here: \\n\\nvar myPow = function(x, n) {\\n  if (n === 0) return 1;\\n  if (n > 0) return pow(x, n);\\n  if (n < 0) return 1 / pow(x, -n);\\n};\\n\\nvar pow = function (x, n) {\\n  if (n === 1) return x;\\n  var num = pow(x, Math.floor(n / 2));\\n  if (n % 2 === 0) {\\n    return num * num;\\n  } else {\\n    return x * num * num;\\n  }\\n};\\n\\n\\nThe code i tried has been accepted with time and space complexity of  O(log(n))."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@user2387402](/user2387402) Dude that's comment from 2015, that guy must've already moved on lol"
                    },
                    {
                        "username": "user2387402",
                        "content": "It\\'s not binary search. It is binary exploitation. Read the editorial."
                    },
                    {
                        "username": "mateenrehanbatt",
                        "content": "class Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n < 0:\\n            x = 1 / x\\n            n = -n\\n\\n        result = 1\\n        while n > 0:\\n            if n % 2 == 1:\\n                result *= x\\n            x *= x\\n            n //= 2\\n\\n        return result"
                    }
                ]
            },
            {
                "id": 1565960,
                "content": [
                    {
                        "username": "mrkanesir",
                        "content": "how am i supposed to NOT get stack overflow with n=2147483647 ..."
                    },
                    {
                        "username": "itsmesuni19",
                        "content": " if your solu is O(n) solu, use long long i in the loop"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "What are you doing bro, I didn\\'t get this error, try to solve in O(log N)"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "use python? "
                    },
                    {
                        "username": "19bec1397",
                        "content": "[@satyasanjay1999](/satyasanjay1999) how\\n"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "You should optimize the solution in logn time complexity. It will also reduce the stack size, then it will also run for n = -2147483648."
                    },
                    {
                        "username": "Linearly_Independent",
                        "content": "\\n\\n\\nreturn x**n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The point of Leetcode is interview practice.\\nWould you go to an interview, and if they ask how should you implement a fast power algorithm you give them the answer of `x**y`? The point is to test your math skills."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The first two words of the question ask you to implement pow(x, n). It's simply illogical to Implement it by calling itself."
                    },
                    {
                        "username": "Satyam_Mishra",
                        "content": "[@Miiza](/Miiza) Where this is mentioned? My code accepted at just return pow(x,n)"
                    },
                    {
                        "username": "Braderbell",
                        "content": "return pow(x, n)"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "as of  this we should know the implementation of x**n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "is it working"
                    },
                    {
                        "username": "Miiza",
                        "content": "Only that this is using pow(x, n) in the background, which you\\'re not suppose to use."
                    },
                    {
                        "username": "henrygriffin330",
                        "content": "this is what i did"
                    },
                    {
                        "username": "yanyehe",
                        "content": "duh"
                    },
                    {
                        "username": "JainAnshul",
                        "content": "for Python, is there anything better (in terms of complexity) than this? Otherwise, this seems to be obvious."
                    },
                    {
                        "username": "olooney",
                        "content": "This is the 37th problem I\\'ve solved on the site and in the end I got a respectible 4ms solution. But honestly, It seems like its 2% algorithm, 98% fiddling with binary representations of signed integers and floating point numbers. I also note that, as of this writing, the problem has 1160 downvotes to 428 upvotes, so there\\'s certainly some shared negativity out there. \\n\\nPersonally, I didn\\'t enjoy this problem because I felt like I spent more time writing custom test cases for corner cases than I did programming. Frankly I cannot imagine getting this question in an interview and having the interviewer go, \"aha! but your solution doesn\\'t account for the case when n is -2^31 and x is exactly -1.0! There\\'s no way we\\'d hire such an incompetent programmer!\" And yet the way the acceptance tests are written, you need to nail *every* *single* corner case. Perhaps that frustration is limited to C/C++? Or there\\'s a different algorithm that more naturally accounts for these edge cases? \\n\\nWhat was your experience? Would you agree or disagree with my thesis that this is the worst problem on the site? "
                    },
                    {
                        "username": "samstafford",
                        "content": "funny, when I saw the title of this one, I initially presumed rational exponent, not integer.  I got all excited about Taylor Series with coefficient reuse.  In fact, I will try that."
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I personally don\\'t like questions that have math as a related topic, because that description is vague. Let\\'s say I want to do this problem, and I don\\'t know recursion, nor do I know how to get the power of a number. I can look in the related topics section, and see that I need to know recursion, and study that, before retrying the problem.\\n\\nWhat will I see for the other part of the problem? Just a generic statement, \"Math\". And sure, this problem tells you what to do, but what about the Climbing Stairs problem? The generic \"Math\" topic tells me nothing of the type of math knowledge needed to solve the problem."
                    },
                    {
                        "username": "adlong01",
                        "content": "[@super____hot](/super____hot) I get a considerably faster solution using log."
                    },
                    {
                        "username": "imfosf0r",
                        "content": "I\\'d disagree: your complaints about the edge cases are just how this function is supposed to work, because of how math works. If you get a different answer for -2^31 than everyone else, then the function isn\\'t working right yet."
                    },
                    {
                        "username": "super____hot",
                        "content": "in python x**n is the fastest method"
                    },
                    {
                        "username": "misterabdul",
                        "content": "I\\'m a C fan & I solve this problem using C. For me this is an interesting problem that let me learn again how the basic pow function could be implemented & let me try to optimize my solution to account for every corner cases. This is such a fun exercises in C IMO."
                    },
                    {
                        "username": "tylermatchett",
                        "content": "Here is a test case made by someone who was in a bad mood\\nx=-1\\nn=2147483647"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "This was a simple one. n%2 ==1, x^n is going to be -1. Because -1 ^ even number is equal to 1  AND -1^odd number is equal to -1."
                    },
                    {
                        "username": "sylvex",
                        "content": "```\\nx =\\n2.00000\\nn =\\n-2147483648\\n```\\nWhat even is the point of this edge case???"
                    },
                    {
                        "username": "tree9",
                        "content": "[@tojoSaha](/tojoSaha)  check this out please https://leetcode.com/problems/powx-n/solutions/4086833/beats-100-log-n-solution/ it handles the above case. Basically invert x and make n positive and carry on with same logic as for positive x and n. Take long N."
                    },
                    {
                        "username": "kavyamittal1282",
                        "content": "[@m_afnan2018](/m_afnan2018)  iam doing in java and geting the same error"
                    },
                    {
                        "username": "sandevil23",
                        "content": "i noticed that they have assigned int to n and here they are passing the upper and lower limits of long int "
                    },
                    {
                        "username": "amar180N_th",
                        "content": "hey I also got the same error here"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Use long long..."
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "[@tojoSaha](/tojoSaha) use abs"
                    },
                    {
                        "username": "issac_tirkey1",
                        "content": "[@heisenberg280](/heisenberg280) -2^31 = 2147483648 and the positive integer limits till 2147483647 i.e 2^31-1. So when n is negative and -2^31  when you multiply it with -1 to make positive it overflows so store -1*n into a temp variable of type long long and it should work. (before storing typecast it into long long)"
                    },
                    {
                        "username": "tojoSaha",
                        "content": "Were u able to find the solution to this test case?.. If so.. then please tell"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "To make sure that your algorithm is fast."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "How to solve this?"
                    },
                    {
                        "username": "shadowfax_",
                        "content": "just has the onsite and the interviewer tdidn\\'t want the recursive version but wanted the fast one with no recursion. \\n\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Hitro",
                        "content": "I\\'m wondering why you guys are not using builtin Math.pow() method??\\nPlease give me some insight.\\nThank you :)"
                    },
                    {
                        "username": "marcjeffs6",
                        "content": "[@barstow123](/barstow123) Is this real? I can go to FAANG and any given Sr developer will know how to recreate any built in method and explain its prime optimization?"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "We were asked to implement the built -in, which is basically Math.pow();\\nSo yeah, that\\'s what we\\'re doing"
                    },
                    {
                        "username": "barstow123",
                        "content": "The idea here is that we perform our work on the shoulders of giants.\\n\\nA more senior developer should be able to recreate built ins and explain how they are optimized if they want higher pay. for example, \"compile the solution in C++ for best performance\" is a good thing to say during senior interviews."
                    },
                    {
                        "username": "otherside2",
                        "content": "My C# code returns the expected Output for the below values when run in Visual Studio, but not here in Leetcode. Where is the disconnect? Could that be the reason why this question has so many thumbs down?\\n\\n240 / 304 test cases passed.\\nStatus: Wrong Answer\\n\\nSubmitted: 0\\xA0minutes ago\\nInput: \\n8.84372\\n-5\\nOutput: \\n0.0\\nExpected: \\n2e-05"
                    },
                    {
                        "username": "AYUSH-KATRE",
                        "content": "make 1 condition for n<0 and return 1/ans(that you are returning)"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Nishtha_2",
                        "content": "Question is under the catogery of binary search can someone suggest me solution with binary search"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@AdityaBhate](/AdityaBhate) IT doesn\\'t exist!!!"
                    },
                    {
                        "username": "r_shweta",
                        "content": "same\\n"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "To implement this problem in a naive way, we would need to multiply x with x for n times, as the n is too large, code would take ages to complete. Idea here is that once we find a square of x, we can multiply square of x with square of x to get x^4, we can again multiply x^4 with x^4 to get x^8 and so on and so forth.\\nx^1 * x^1 = x^(1+1) = x^2\\nx^2 * x^2 = x^(2+2) = x^4\\nx^4 * x^4 = x^(4+4) = x^8\\n.....\\nBy this way, we can reduce the time complexity from O(n) to O(log n), This problem comes under binary search as we are squaring(binary) each answer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "[@chickooo](/chickooo)  Actually it follows the concept of binary search, if you want to calculate for n = 4 you first calculate for  n = 2 and before calculating n = 2, you calculate n =1, so that you can obtain the solution in log(n) instead of calculating for 4 times it will take O(N) "
                    },
                    {
                        "username": "chickooo",
                        "content": "I don\\'t know why it was showing under the tag **binary search**, but the tags are now updated to **Math** and **Recursion**"
                    },
                    {
                        "username": "Will",
                        "content": "Please show me the code if any one can solve this using binary search. \\nThanks a lot!"
                    },
                    {
                        "username": "shivagama02",
                        "content": "The code for the same using binary search can be done in javascript. The code for the same is here: \\n\\nvar myPow = function(x, n) {\\n  if (n === 0) return 1;\\n  if (n > 0) return pow(x, n);\\n  if (n < 0) return 1 / pow(x, -n);\\n};\\n\\nvar pow = function (x, n) {\\n  if (n === 1) return x;\\n  var num = pow(x, Math.floor(n / 2));\\n  if (n % 2 === 0) {\\n    return num * num;\\n  } else {\\n    return x * num * num;\\n  }\\n};\\n\\n\\nThe code i tried has been accepted with time and space complexity of  O(log(n))."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@user2387402](/user2387402) Dude that's comment from 2015, that guy must've already moved on lol"
                    },
                    {
                        "username": "user2387402",
                        "content": "It\\'s not binary search. It is binary exploitation. Read the editorial."
                    },
                    {
                        "username": "mateenrehanbatt",
                        "content": "class Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n < 0:\\n            x = 1 / x\\n            n = -n\\n\\n        result = 1\\n        while n > 0:\\n            if n % 2 == 1:\\n                result *= x\\n            x *= x\\n            n //= 2\\n\\n        return result"
                    }
                ]
            },
            {
                "id": 1803500,
                "content": [
                    {
                        "username": "mrkanesir",
                        "content": "how am i supposed to NOT get stack overflow with n=2147483647 ..."
                    },
                    {
                        "username": "itsmesuni19",
                        "content": " if your solu is O(n) solu, use long long i in the loop"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "What are you doing bro, I didn\\'t get this error, try to solve in O(log N)"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "use python? "
                    },
                    {
                        "username": "19bec1397",
                        "content": "[@satyasanjay1999](/satyasanjay1999) how\\n"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "You should optimize the solution in logn time complexity. It will also reduce the stack size, then it will also run for n = -2147483648."
                    },
                    {
                        "username": "Linearly_Independent",
                        "content": "\\n\\n\\nreturn x**n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The point of Leetcode is interview practice.\\nWould you go to an interview, and if they ask how should you implement a fast power algorithm you give them the answer of `x**y`? The point is to test your math skills."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The first two words of the question ask you to implement pow(x, n). It's simply illogical to Implement it by calling itself."
                    },
                    {
                        "username": "Satyam_Mishra",
                        "content": "[@Miiza](/Miiza) Where this is mentioned? My code accepted at just return pow(x,n)"
                    },
                    {
                        "username": "Braderbell",
                        "content": "return pow(x, n)"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "as of  this we should know the implementation of x**n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "is it working"
                    },
                    {
                        "username": "Miiza",
                        "content": "Only that this is using pow(x, n) in the background, which you\\'re not suppose to use."
                    },
                    {
                        "username": "henrygriffin330",
                        "content": "this is what i did"
                    },
                    {
                        "username": "yanyehe",
                        "content": "duh"
                    },
                    {
                        "username": "JainAnshul",
                        "content": "for Python, is there anything better (in terms of complexity) than this? Otherwise, this seems to be obvious."
                    },
                    {
                        "username": "olooney",
                        "content": "This is the 37th problem I\\'ve solved on the site and in the end I got a respectible 4ms solution. But honestly, It seems like its 2% algorithm, 98% fiddling with binary representations of signed integers and floating point numbers. I also note that, as of this writing, the problem has 1160 downvotes to 428 upvotes, so there\\'s certainly some shared negativity out there. \\n\\nPersonally, I didn\\'t enjoy this problem because I felt like I spent more time writing custom test cases for corner cases than I did programming. Frankly I cannot imagine getting this question in an interview and having the interviewer go, \"aha! but your solution doesn\\'t account for the case when n is -2^31 and x is exactly -1.0! There\\'s no way we\\'d hire such an incompetent programmer!\" And yet the way the acceptance tests are written, you need to nail *every* *single* corner case. Perhaps that frustration is limited to C/C++? Or there\\'s a different algorithm that more naturally accounts for these edge cases? \\n\\nWhat was your experience? Would you agree or disagree with my thesis that this is the worst problem on the site? "
                    },
                    {
                        "username": "samstafford",
                        "content": "funny, when I saw the title of this one, I initially presumed rational exponent, not integer.  I got all excited about Taylor Series with coefficient reuse.  In fact, I will try that."
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I personally don\\'t like questions that have math as a related topic, because that description is vague. Let\\'s say I want to do this problem, and I don\\'t know recursion, nor do I know how to get the power of a number. I can look in the related topics section, and see that I need to know recursion, and study that, before retrying the problem.\\n\\nWhat will I see for the other part of the problem? Just a generic statement, \"Math\". And sure, this problem tells you what to do, but what about the Climbing Stairs problem? The generic \"Math\" topic tells me nothing of the type of math knowledge needed to solve the problem."
                    },
                    {
                        "username": "adlong01",
                        "content": "[@super____hot](/super____hot) I get a considerably faster solution using log."
                    },
                    {
                        "username": "imfosf0r",
                        "content": "I\\'d disagree: your complaints about the edge cases are just how this function is supposed to work, because of how math works. If you get a different answer for -2^31 than everyone else, then the function isn\\'t working right yet."
                    },
                    {
                        "username": "super____hot",
                        "content": "in python x**n is the fastest method"
                    },
                    {
                        "username": "misterabdul",
                        "content": "I\\'m a C fan & I solve this problem using C. For me this is an interesting problem that let me learn again how the basic pow function could be implemented & let me try to optimize my solution to account for every corner cases. This is such a fun exercises in C IMO."
                    },
                    {
                        "username": "tylermatchett",
                        "content": "Here is a test case made by someone who was in a bad mood\\nx=-1\\nn=2147483647"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "This was a simple one. n%2 ==1, x^n is going to be -1. Because -1 ^ even number is equal to 1  AND -1^odd number is equal to -1."
                    },
                    {
                        "username": "sylvex",
                        "content": "```\\nx =\\n2.00000\\nn =\\n-2147483648\\n```\\nWhat even is the point of this edge case???"
                    },
                    {
                        "username": "tree9",
                        "content": "[@tojoSaha](/tojoSaha)  check this out please https://leetcode.com/problems/powx-n/solutions/4086833/beats-100-log-n-solution/ it handles the above case. Basically invert x and make n positive and carry on with same logic as for positive x and n. Take long N."
                    },
                    {
                        "username": "kavyamittal1282",
                        "content": "[@m_afnan2018](/m_afnan2018)  iam doing in java and geting the same error"
                    },
                    {
                        "username": "sandevil23",
                        "content": "i noticed that they have assigned int to n and here they are passing the upper and lower limits of long int "
                    },
                    {
                        "username": "amar180N_th",
                        "content": "hey I also got the same error here"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Use long long..."
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "[@tojoSaha](/tojoSaha) use abs"
                    },
                    {
                        "username": "issac_tirkey1",
                        "content": "[@heisenberg280](/heisenberg280) -2^31 = 2147483648 and the positive integer limits till 2147483647 i.e 2^31-1. So when n is negative and -2^31  when you multiply it with -1 to make positive it overflows so store -1*n into a temp variable of type long long and it should work. (before storing typecast it into long long)"
                    },
                    {
                        "username": "tojoSaha",
                        "content": "Were u able to find the solution to this test case?.. If so.. then please tell"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "To make sure that your algorithm is fast."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "How to solve this?"
                    },
                    {
                        "username": "shadowfax_",
                        "content": "just has the onsite and the interviewer tdidn\\'t want the recursive version but wanted the fast one with no recursion. \\n\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Hitro",
                        "content": "I\\'m wondering why you guys are not using builtin Math.pow() method??\\nPlease give me some insight.\\nThank you :)"
                    },
                    {
                        "username": "marcjeffs6",
                        "content": "[@barstow123](/barstow123) Is this real? I can go to FAANG and any given Sr developer will know how to recreate any built in method and explain its prime optimization?"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "We were asked to implement the built -in, which is basically Math.pow();\\nSo yeah, that\\'s what we\\'re doing"
                    },
                    {
                        "username": "barstow123",
                        "content": "The idea here is that we perform our work on the shoulders of giants.\\n\\nA more senior developer should be able to recreate built ins and explain how they are optimized if they want higher pay. for example, \"compile the solution in C++ for best performance\" is a good thing to say during senior interviews."
                    },
                    {
                        "username": "otherside2",
                        "content": "My C# code returns the expected Output for the below values when run in Visual Studio, but not here in Leetcode. Where is the disconnect? Could that be the reason why this question has so many thumbs down?\\n\\n240 / 304 test cases passed.\\nStatus: Wrong Answer\\n\\nSubmitted: 0\\xA0minutes ago\\nInput: \\n8.84372\\n-5\\nOutput: \\n0.0\\nExpected: \\n2e-05"
                    },
                    {
                        "username": "AYUSH-KATRE",
                        "content": "make 1 condition for n<0 and return 1/ans(that you are returning)"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Nishtha_2",
                        "content": "Question is under the catogery of binary search can someone suggest me solution with binary search"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@AdityaBhate](/AdityaBhate) IT doesn\\'t exist!!!"
                    },
                    {
                        "username": "r_shweta",
                        "content": "same\\n"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "To implement this problem in a naive way, we would need to multiply x with x for n times, as the n is too large, code would take ages to complete. Idea here is that once we find a square of x, we can multiply square of x with square of x to get x^4, we can again multiply x^4 with x^4 to get x^8 and so on and so forth.\\nx^1 * x^1 = x^(1+1) = x^2\\nx^2 * x^2 = x^(2+2) = x^4\\nx^4 * x^4 = x^(4+4) = x^8\\n.....\\nBy this way, we can reduce the time complexity from O(n) to O(log n), This problem comes under binary search as we are squaring(binary) each answer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "[@chickooo](/chickooo)  Actually it follows the concept of binary search, if you want to calculate for n = 4 you first calculate for  n = 2 and before calculating n = 2, you calculate n =1, so that you can obtain the solution in log(n) instead of calculating for 4 times it will take O(N) "
                    },
                    {
                        "username": "chickooo",
                        "content": "I don\\'t know why it was showing under the tag **binary search**, but the tags are now updated to **Math** and **Recursion**"
                    },
                    {
                        "username": "Will",
                        "content": "Please show me the code if any one can solve this using binary search. \\nThanks a lot!"
                    },
                    {
                        "username": "shivagama02",
                        "content": "The code for the same using binary search can be done in javascript. The code for the same is here: \\n\\nvar myPow = function(x, n) {\\n  if (n === 0) return 1;\\n  if (n > 0) return pow(x, n);\\n  if (n < 0) return 1 / pow(x, -n);\\n};\\n\\nvar pow = function (x, n) {\\n  if (n === 1) return x;\\n  var num = pow(x, Math.floor(n / 2));\\n  if (n % 2 === 0) {\\n    return num * num;\\n  } else {\\n    return x * num * num;\\n  }\\n};\\n\\n\\nThe code i tried has been accepted with time and space complexity of  O(log(n))."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@user2387402](/user2387402) Dude that's comment from 2015, that guy must've already moved on lol"
                    },
                    {
                        "username": "user2387402",
                        "content": "It\\'s not binary search. It is binary exploitation. Read the editorial."
                    },
                    {
                        "username": "mateenrehanbatt",
                        "content": "class Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n < 0:\\n            x = 1 / x\\n            n = -n\\n\\n        result = 1\\n        while n > 0:\\n            if n % 2 == 1:\\n                result *= x\\n            x *= x\\n            n //= 2\\n\\n        return result"
                    }
                ]
            },
            {
                "id": 1835821,
                "content": [
                    {
                        "username": "mrkanesir",
                        "content": "how am i supposed to NOT get stack overflow with n=2147483647 ..."
                    },
                    {
                        "username": "itsmesuni19",
                        "content": " if your solu is O(n) solu, use long long i in the loop"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "What are you doing bro, I didn\\'t get this error, try to solve in O(log N)"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "use python? "
                    },
                    {
                        "username": "19bec1397",
                        "content": "[@satyasanjay1999](/satyasanjay1999) how\\n"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "You should optimize the solution in logn time complexity. It will also reduce the stack size, then it will also run for n = -2147483648."
                    },
                    {
                        "username": "Linearly_Independent",
                        "content": "\\n\\n\\nreturn x**n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The point of Leetcode is interview practice.\\nWould you go to an interview, and if they ask how should you implement a fast power algorithm you give them the answer of `x**y`? The point is to test your math skills."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The first two words of the question ask you to implement pow(x, n). It's simply illogical to Implement it by calling itself."
                    },
                    {
                        "username": "Satyam_Mishra",
                        "content": "[@Miiza](/Miiza) Where this is mentioned? My code accepted at just return pow(x,n)"
                    },
                    {
                        "username": "Braderbell",
                        "content": "return pow(x, n)"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "as of  this we should know the implementation of x**n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "is it working"
                    },
                    {
                        "username": "Miiza",
                        "content": "Only that this is using pow(x, n) in the background, which you\\'re not suppose to use."
                    },
                    {
                        "username": "henrygriffin330",
                        "content": "this is what i did"
                    },
                    {
                        "username": "yanyehe",
                        "content": "duh"
                    },
                    {
                        "username": "JainAnshul",
                        "content": "for Python, is there anything better (in terms of complexity) than this? Otherwise, this seems to be obvious."
                    },
                    {
                        "username": "olooney",
                        "content": "This is the 37th problem I\\'ve solved on the site and in the end I got a respectible 4ms solution. But honestly, It seems like its 2% algorithm, 98% fiddling with binary representations of signed integers and floating point numbers. I also note that, as of this writing, the problem has 1160 downvotes to 428 upvotes, so there\\'s certainly some shared negativity out there. \\n\\nPersonally, I didn\\'t enjoy this problem because I felt like I spent more time writing custom test cases for corner cases than I did programming. Frankly I cannot imagine getting this question in an interview and having the interviewer go, \"aha! but your solution doesn\\'t account for the case when n is -2^31 and x is exactly -1.0! There\\'s no way we\\'d hire such an incompetent programmer!\" And yet the way the acceptance tests are written, you need to nail *every* *single* corner case. Perhaps that frustration is limited to C/C++? Or there\\'s a different algorithm that more naturally accounts for these edge cases? \\n\\nWhat was your experience? Would you agree or disagree with my thesis that this is the worst problem on the site? "
                    },
                    {
                        "username": "samstafford",
                        "content": "funny, when I saw the title of this one, I initially presumed rational exponent, not integer.  I got all excited about Taylor Series with coefficient reuse.  In fact, I will try that."
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I personally don\\'t like questions that have math as a related topic, because that description is vague. Let\\'s say I want to do this problem, and I don\\'t know recursion, nor do I know how to get the power of a number. I can look in the related topics section, and see that I need to know recursion, and study that, before retrying the problem.\\n\\nWhat will I see for the other part of the problem? Just a generic statement, \"Math\". And sure, this problem tells you what to do, but what about the Climbing Stairs problem? The generic \"Math\" topic tells me nothing of the type of math knowledge needed to solve the problem."
                    },
                    {
                        "username": "adlong01",
                        "content": "[@super____hot](/super____hot) I get a considerably faster solution using log."
                    },
                    {
                        "username": "imfosf0r",
                        "content": "I\\'d disagree: your complaints about the edge cases are just how this function is supposed to work, because of how math works. If you get a different answer for -2^31 than everyone else, then the function isn\\'t working right yet."
                    },
                    {
                        "username": "super____hot",
                        "content": "in python x**n is the fastest method"
                    },
                    {
                        "username": "misterabdul",
                        "content": "I\\'m a C fan & I solve this problem using C. For me this is an interesting problem that let me learn again how the basic pow function could be implemented & let me try to optimize my solution to account for every corner cases. This is such a fun exercises in C IMO."
                    },
                    {
                        "username": "tylermatchett",
                        "content": "Here is a test case made by someone who was in a bad mood\\nx=-1\\nn=2147483647"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "This was a simple one. n%2 ==1, x^n is going to be -1. Because -1 ^ even number is equal to 1  AND -1^odd number is equal to -1."
                    },
                    {
                        "username": "sylvex",
                        "content": "```\\nx =\\n2.00000\\nn =\\n-2147483648\\n```\\nWhat even is the point of this edge case???"
                    },
                    {
                        "username": "tree9",
                        "content": "[@tojoSaha](/tojoSaha)  check this out please https://leetcode.com/problems/powx-n/solutions/4086833/beats-100-log-n-solution/ it handles the above case. Basically invert x and make n positive and carry on with same logic as for positive x and n. Take long N."
                    },
                    {
                        "username": "kavyamittal1282",
                        "content": "[@m_afnan2018](/m_afnan2018)  iam doing in java and geting the same error"
                    },
                    {
                        "username": "sandevil23",
                        "content": "i noticed that they have assigned int to n and here they are passing the upper and lower limits of long int "
                    },
                    {
                        "username": "amar180N_th",
                        "content": "hey I also got the same error here"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Use long long..."
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "[@tojoSaha](/tojoSaha) use abs"
                    },
                    {
                        "username": "issac_tirkey1",
                        "content": "[@heisenberg280](/heisenberg280) -2^31 = 2147483648 and the positive integer limits till 2147483647 i.e 2^31-1. So when n is negative and -2^31  when you multiply it with -1 to make positive it overflows so store -1*n into a temp variable of type long long and it should work. (before storing typecast it into long long)"
                    },
                    {
                        "username": "tojoSaha",
                        "content": "Were u able to find the solution to this test case?.. If so.. then please tell"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "To make sure that your algorithm is fast."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "How to solve this?"
                    },
                    {
                        "username": "shadowfax_",
                        "content": "just has the onsite and the interviewer tdidn\\'t want the recursive version but wanted the fast one with no recursion. \\n\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Hitro",
                        "content": "I\\'m wondering why you guys are not using builtin Math.pow() method??\\nPlease give me some insight.\\nThank you :)"
                    },
                    {
                        "username": "marcjeffs6",
                        "content": "[@barstow123](/barstow123) Is this real? I can go to FAANG and any given Sr developer will know how to recreate any built in method and explain its prime optimization?"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "We were asked to implement the built -in, which is basically Math.pow();\\nSo yeah, that\\'s what we\\'re doing"
                    },
                    {
                        "username": "barstow123",
                        "content": "The idea here is that we perform our work on the shoulders of giants.\\n\\nA more senior developer should be able to recreate built ins and explain how they are optimized if they want higher pay. for example, \"compile the solution in C++ for best performance\" is a good thing to say during senior interviews."
                    },
                    {
                        "username": "otherside2",
                        "content": "My C# code returns the expected Output for the below values when run in Visual Studio, but not here in Leetcode. Where is the disconnect? Could that be the reason why this question has so many thumbs down?\\n\\n240 / 304 test cases passed.\\nStatus: Wrong Answer\\n\\nSubmitted: 0\\xA0minutes ago\\nInput: \\n8.84372\\n-5\\nOutput: \\n0.0\\nExpected: \\n2e-05"
                    },
                    {
                        "username": "AYUSH-KATRE",
                        "content": "make 1 condition for n<0 and return 1/ans(that you are returning)"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Nishtha_2",
                        "content": "Question is under the catogery of binary search can someone suggest me solution with binary search"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@AdityaBhate](/AdityaBhate) IT doesn\\'t exist!!!"
                    },
                    {
                        "username": "r_shweta",
                        "content": "same\\n"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "To implement this problem in a naive way, we would need to multiply x with x for n times, as the n is too large, code would take ages to complete. Idea here is that once we find a square of x, we can multiply square of x with square of x to get x^4, we can again multiply x^4 with x^4 to get x^8 and so on and so forth.\\nx^1 * x^1 = x^(1+1) = x^2\\nx^2 * x^2 = x^(2+2) = x^4\\nx^4 * x^4 = x^(4+4) = x^8\\n.....\\nBy this way, we can reduce the time complexity from O(n) to O(log n), This problem comes under binary search as we are squaring(binary) each answer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "[@chickooo](/chickooo)  Actually it follows the concept of binary search, if you want to calculate for n = 4 you first calculate for  n = 2 and before calculating n = 2, you calculate n =1, so that you can obtain the solution in log(n) instead of calculating for 4 times it will take O(N) "
                    },
                    {
                        "username": "chickooo",
                        "content": "I don\\'t know why it was showing under the tag **binary search**, but the tags are now updated to **Math** and **Recursion**"
                    },
                    {
                        "username": "Will",
                        "content": "Please show me the code if any one can solve this using binary search. \\nThanks a lot!"
                    },
                    {
                        "username": "shivagama02",
                        "content": "The code for the same using binary search can be done in javascript. The code for the same is here: \\n\\nvar myPow = function(x, n) {\\n  if (n === 0) return 1;\\n  if (n > 0) return pow(x, n);\\n  if (n < 0) return 1 / pow(x, -n);\\n};\\n\\nvar pow = function (x, n) {\\n  if (n === 1) return x;\\n  var num = pow(x, Math.floor(n / 2));\\n  if (n % 2 === 0) {\\n    return num * num;\\n  } else {\\n    return x * num * num;\\n  }\\n};\\n\\n\\nThe code i tried has been accepted with time and space complexity of  O(log(n))."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@user2387402](/user2387402) Dude that's comment from 2015, that guy must've already moved on lol"
                    },
                    {
                        "username": "user2387402",
                        "content": "It\\'s not binary search. It is binary exploitation. Read the editorial."
                    },
                    {
                        "username": "mateenrehanbatt",
                        "content": "class Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n < 0:\\n            x = 1 / x\\n            n = -n\\n\\n        result = 1\\n        while n > 0:\\n            if n % 2 == 1:\\n                result *= x\\n            x *= x\\n            n //= 2\\n\\n        return result"
                    }
                ]
            },
            {
                "id": 1570780,
                "content": [
                    {
                        "username": "mrkanesir",
                        "content": "how am i supposed to NOT get stack overflow with n=2147483647 ..."
                    },
                    {
                        "username": "itsmesuni19",
                        "content": " if your solu is O(n) solu, use long long i in the loop"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "What are you doing bro, I didn\\'t get this error, try to solve in O(log N)"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "use python? "
                    },
                    {
                        "username": "19bec1397",
                        "content": "[@satyasanjay1999](/satyasanjay1999) how\\n"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "You should optimize the solution in logn time complexity. It will also reduce the stack size, then it will also run for n = -2147483648."
                    },
                    {
                        "username": "Linearly_Independent",
                        "content": "\\n\\n\\nreturn x**n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The point of Leetcode is interview practice.\\nWould you go to an interview, and if they ask how should you implement a fast power algorithm you give them the answer of `x**y`? The point is to test your math skills."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The first two words of the question ask you to implement pow(x, n). It's simply illogical to Implement it by calling itself."
                    },
                    {
                        "username": "Satyam_Mishra",
                        "content": "[@Miiza](/Miiza) Where this is mentioned? My code accepted at just return pow(x,n)"
                    },
                    {
                        "username": "Braderbell",
                        "content": "return pow(x, n)"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "as of  this we should know the implementation of x**n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "is it working"
                    },
                    {
                        "username": "Miiza",
                        "content": "Only that this is using pow(x, n) in the background, which you\\'re not suppose to use."
                    },
                    {
                        "username": "henrygriffin330",
                        "content": "this is what i did"
                    },
                    {
                        "username": "yanyehe",
                        "content": "duh"
                    },
                    {
                        "username": "JainAnshul",
                        "content": "for Python, is there anything better (in terms of complexity) than this? Otherwise, this seems to be obvious."
                    },
                    {
                        "username": "olooney",
                        "content": "This is the 37th problem I\\'ve solved on the site and in the end I got a respectible 4ms solution. But honestly, It seems like its 2% algorithm, 98% fiddling with binary representations of signed integers and floating point numbers. I also note that, as of this writing, the problem has 1160 downvotes to 428 upvotes, so there\\'s certainly some shared negativity out there. \\n\\nPersonally, I didn\\'t enjoy this problem because I felt like I spent more time writing custom test cases for corner cases than I did programming. Frankly I cannot imagine getting this question in an interview and having the interviewer go, \"aha! but your solution doesn\\'t account for the case when n is -2^31 and x is exactly -1.0! There\\'s no way we\\'d hire such an incompetent programmer!\" And yet the way the acceptance tests are written, you need to nail *every* *single* corner case. Perhaps that frustration is limited to C/C++? Or there\\'s a different algorithm that more naturally accounts for these edge cases? \\n\\nWhat was your experience? Would you agree or disagree with my thesis that this is the worst problem on the site? "
                    },
                    {
                        "username": "samstafford",
                        "content": "funny, when I saw the title of this one, I initially presumed rational exponent, not integer.  I got all excited about Taylor Series with coefficient reuse.  In fact, I will try that."
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I personally don\\'t like questions that have math as a related topic, because that description is vague. Let\\'s say I want to do this problem, and I don\\'t know recursion, nor do I know how to get the power of a number. I can look in the related topics section, and see that I need to know recursion, and study that, before retrying the problem.\\n\\nWhat will I see for the other part of the problem? Just a generic statement, \"Math\". And sure, this problem tells you what to do, but what about the Climbing Stairs problem? The generic \"Math\" topic tells me nothing of the type of math knowledge needed to solve the problem."
                    },
                    {
                        "username": "adlong01",
                        "content": "[@super____hot](/super____hot) I get a considerably faster solution using log."
                    },
                    {
                        "username": "imfosf0r",
                        "content": "I\\'d disagree: your complaints about the edge cases are just how this function is supposed to work, because of how math works. If you get a different answer for -2^31 than everyone else, then the function isn\\'t working right yet."
                    },
                    {
                        "username": "super____hot",
                        "content": "in python x**n is the fastest method"
                    },
                    {
                        "username": "misterabdul",
                        "content": "I\\'m a C fan & I solve this problem using C. For me this is an interesting problem that let me learn again how the basic pow function could be implemented & let me try to optimize my solution to account for every corner cases. This is such a fun exercises in C IMO."
                    },
                    {
                        "username": "tylermatchett",
                        "content": "Here is a test case made by someone who was in a bad mood\\nx=-1\\nn=2147483647"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "This was a simple one. n%2 ==1, x^n is going to be -1. Because -1 ^ even number is equal to 1  AND -1^odd number is equal to -1."
                    },
                    {
                        "username": "sylvex",
                        "content": "```\\nx =\\n2.00000\\nn =\\n-2147483648\\n```\\nWhat even is the point of this edge case???"
                    },
                    {
                        "username": "tree9",
                        "content": "[@tojoSaha](/tojoSaha)  check this out please https://leetcode.com/problems/powx-n/solutions/4086833/beats-100-log-n-solution/ it handles the above case. Basically invert x and make n positive and carry on with same logic as for positive x and n. Take long N."
                    },
                    {
                        "username": "kavyamittal1282",
                        "content": "[@m_afnan2018](/m_afnan2018)  iam doing in java and geting the same error"
                    },
                    {
                        "username": "sandevil23",
                        "content": "i noticed that they have assigned int to n and here they are passing the upper and lower limits of long int "
                    },
                    {
                        "username": "amar180N_th",
                        "content": "hey I also got the same error here"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Use long long..."
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "[@tojoSaha](/tojoSaha) use abs"
                    },
                    {
                        "username": "issac_tirkey1",
                        "content": "[@heisenberg280](/heisenberg280) -2^31 = 2147483648 and the positive integer limits till 2147483647 i.e 2^31-1. So when n is negative and -2^31  when you multiply it with -1 to make positive it overflows so store -1*n into a temp variable of type long long and it should work. (before storing typecast it into long long)"
                    },
                    {
                        "username": "tojoSaha",
                        "content": "Were u able to find the solution to this test case?.. If so.. then please tell"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "To make sure that your algorithm is fast."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "How to solve this?"
                    },
                    {
                        "username": "shadowfax_",
                        "content": "just has the onsite and the interviewer tdidn\\'t want the recursive version but wanted the fast one with no recursion. \\n\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Hitro",
                        "content": "I\\'m wondering why you guys are not using builtin Math.pow() method??\\nPlease give me some insight.\\nThank you :)"
                    },
                    {
                        "username": "marcjeffs6",
                        "content": "[@barstow123](/barstow123) Is this real? I can go to FAANG and any given Sr developer will know how to recreate any built in method and explain its prime optimization?"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "We were asked to implement the built -in, which is basically Math.pow();\\nSo yeah, that\\'s what we\\'re doing"
                    },
                    {
                        "username": "barstow123",
                        "content": "The idea here is that we perform our work on the shoulders of giants.\\n\\nA more senior developer should be able to recreate built ins and explain how they are optimized if they want higher pay. for example, \"compile the solution in C++ for best performance\" is a good thing to say during senior interviews."
                    },
                    {
                        "username": "otherside2",
                        "content": "My C# code returns the expected Output for the below values when run in Visual Studio, but not here in Leetcode. Where is the disconnect? Could that be the reason why this question has so many thumbs down?\\n\\n240 / 304 test cases passed.\\nStatus: Wrong Answer\\n\\nSubmitted: 0\\xA0minutes ago\\nInput: \\n8.84372\\n-5\\nOutput: \\n0.0\\nExpected: \\n2e-05"
                    },
                    {
                        "username": "AYUSH-KATRE",
                        "content": "make 1 condition for n<0 and return 1/ans(that you are returning)"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Nishtha_2",
                        "content": "Question is under the catogery of binary search can someone suggest me solution with binary search"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@AdityaBhate](/AdityaBhate) IT doesn\\'t exist!!!"
                    },
                    {
                        "username": "r_shweta",
                        "content": "same\\n"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "To implement this problem in a naive way, we would need to multiply x with x for n times, as the n is too large, code would take ages to complete. Idea here is that once we find a square of x, we can multiply square of x with square of x to get x^4, we can again multiply x^4 with x^4 to get x^8 and so on and so forth.\\nx^1 * x^1 = x^(1+1) = x^2\\nx^2 * x^2 = x^(2+2) = x^4\\nx^4 * x^4 = x^(4+4) = x^8\\n.....\\nBy this way, we can reduce the time complexity from O(n) to O(log n), This problem comes under binary search as we are squaring(binary) each answer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "[@chickooo](/chickooo)  Actually it follows the concept of binary search, if you want to calculate for n = 4 you first calculate for  n = 2 and before calculating n = 2, you calculate n =1, so that you can obtain the solution in log(n) instead of calculating for 4 times it will take O(N) "
                    },
                    {
                        "username": "chickooo",
                        "content": "I don\\'t know why it was showing under the tag **binary search**, but the tags are now updated to **Math** and **Recursion**"
                    },
                    {
                        "username": "Will",
                        "content": "Please show me the code if any one can solve this using binary search. \\nThanks a lot!"
                    },
                    {
                        "username": "shivagama02",
                        "content": "The code for the same using binary search can be done in javascript. The code for the same is here: \\n\\nvar myPow = function(x, n) {\\n  if (n === 0) return 1;\\n  if (n > 0) return pow(x, n);\\n  if (n < 0) return 1 / pow(x, -n);\\n};\\n\\nvar pow = function (x, n) {\\n  if (n === 1) return x;\\n  var num = pow(x, Math.floor(n / 2));\\n  if (n % 2 === 0) {\\n    return num * num;\\n  } else {\\n    return x * num * num;\\n  }\\n};\\n\\n\\nThe code i tried has been accepted with time and space complexity of  O(log(n))."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@user2387402](/user2387402) Dude that's comment from 2015, that guy must've already moved on lol"
                    },
                    {
                        "username": "user2387402",
                        "content": "It\\'s not binary search. It is binary exploitation. Read the editorial."
                    },
                    {
                        "username": "mateenrehanbatt",
                        "content": "class Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n < 0:\\n            x = 1 / x\\n            n = -n\\n\\n        result = 1\\n        while n > 0:\\n            if n % 2 == 1:\\n                result *= x\\n            x *= x\\n            n //= 2\\n\\n        return result"
                    }
                ]
            },
            {
                "id": 1572534,
                "content": [
                    {
                        "username": "mrkanesir",
                        "content": "how am i supposed to NOT get stack overflow with n=2147483647 ..."
                    },
                    {
                        "username": "itsmesuni19",
                        "content": " if your solu is O(n) solu, use long long i in the loop"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "What are you doing bro, I didn\\'t get this error, try to solve in O(log N)"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "use python? "
                    },
                    {
                        "username": "19bec1397",
                        "content": "[@satyasanjay1999](/satyasanjay1999) how\\n"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "You should optimize the solution in logn time complexity. It will also reduce the stack size, then it will also run for n = -2147483648."
                    },
                    {
                        "username": "Linearly_Independent",
                        "content": "\\n\\n\\nreturn x**n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The point of Leetcode is interview practice.\\nWould you go to an interview, and if they ask how should you implement a fast power algorithm you give them the answer of `x**y`? The point is to test your math skills."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The first two words of the question ask you to implement pow(x, n). It's simply illogical to Implement it by calling itself."
                    },
                    {
                        "username": "Satyam_Mishra",
                        "content": "[@Miiza](/Miiza) Where this is mentioned? My code accepted at just return pow(x,n)"
                    },
                    {
                        "username": "Braderbell",
                        "content": "return pow(x, n)"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "as of  this we should know the implementation of x**n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "is it working"
                    },
                    {
                        "username": "Miiza",
                        "content": "Only that this is using pow(x, n) in the background, which you\\'re not suppose to use."
                    },
                    {
                        "username": "henrygriffin330",
                        "content": "this is what i did"
                    },
                    {
                        "username": "yanyehe",
                        "content": "duh"
                    },
                    {
                        "username": "JainAnshul",
                        "content": "for Python, is there anything better (in terms of complexity) than this? Otherwise, this seems to be obvious."
                    },
                    {
                        "username": "olooney",
                        "content": "This is the 37th problem I\\'ve solved on the site and in the end I got a respectible 4ms solution. But honestly, It seems like its 2% algorithm, 98% fiddling with binary representations of signed integers and floating point numbers. I also note that, as of this writing, the problem has 1160 downvotes to 428 upvotes, so there\\'s certainly some shared negativity out there. \\n\\nPersonally, I didn\\'t enjoy this problem because I felt like I spent more time writing custom test cases for corner cases than I did programming. Frankly I cannot imagine getting this question in an interview and having the interviewer go, \"aha! but your solution doesn\\'t account for the case when n is -2^31 and x is exactly -1.0! There\\'s no way we\\'d hire such an incompetent programmer!\" And yet the way the acceptance tests are written, you need to nail *every* *single* corner case. Perhaps that frustration is limited to C/C++? Or there\\'s a different algorithm that more naturally accounts for these edge cases? \\n\\nWhat was your experience? Would you agree or disagree with my thesis that this is the worst problem on the site? "
                    },
                    {
                        "username": "samstafford",
                        "content": "funny, when I saw the title of this one, I initially presumed rational exponent, not integer.  I got all excited about Taylor Series with coefficient reuse.  In fact, I will try that."
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I personally don\\'t like questions that have math as a related topic, because that description is vague. Let\\'s say I want to do this problem, and I don\\'t know recursion, nor do I know how to get the power of a number. I can look in the related topics section, and see that I need to know recursion, and study that, before retrying the problem.\\n\\nWhat will I see for the other part of the problem? Just a generic statement, \"Math\". And sure, this problem tells you what to do, but what about the Climbing Stairs problem? The generic \"Math\" topic tells me nothing of the type of math knowledge needed to solve the problem."
                    },
                    {
                        "username": "adlong01",
                        "content": "[@super____hot](/super____hot) I get a considerably faster solution using log."
                    },
                    {
                        "username": "imfosf0r",
                        "content": "I\\'d disagree: your complaints about the edge cases are just how this function is supposed to work, because of how math works. If you get a different answer for -2^31 than everyone else, then the function isn\\'t working right yet."
                    },
                    {
                        "username": "super____hot",
                        "content": "in python x**n is the fastest method"
                    },
                    {
                        "username": "misterabdul",
                        "content": "I\\'m a C fan & I solve this problem using C. For me this is an interesting problem that let me learn again how the basic pow function could be implemented & let me try to optimize my solution to account for every corner cases. This is such a fun exercises in C IMO."
                    },
                    {
                        "username": "tylermatchett",
                        "content": "Here is a test case made by someone who was in a bad mood\\nx=-1\\nn=2147483647"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "This was a simple one. n%2 ==1, x^n is going to be -1. Because -1 ^ even number is equal to 1  AND -1^odd number is equal to -1."
                    },
                    {
                        "username": "sylvex",
                        "content": "```\\nx =\\n2.00000\\nn =\\n-2147483648\\n```\\nWhat even is the point of this edge case???"
                    },
                    {
                        "username": "tree9",
                        "content": "[@tojoSaha](/tojoSaha)  check this out please https://leetcode.com/problems/powx-n/solutions/4086833/beats-100-log-n-solution/ it handles the above case. Basically invert x and make n positive and carry on with same logic as for positive x and n. Take long N."
                    },
                    {
                        "username": "kavyamittal1282",
                        "content": "[@m_afnan2018](/m_afnan2018)  iam doing in java and geting the same error"
                    },
                    {
                        "username": "sandevil23",
                        "content": "i noticed that they have assigned int to n and here they are passing the upper and lower limits of long int "
                    },
                    {
                        "username": "amar180N_th",
                        "content": "hey I also got the same error here"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Use long long..."
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "[@tojoSaha](/tojoSaha) use abs"
                    },
                    {
                        "username": "issac_tirkey1",
                        "content": "[@heisenberg280](/heisenberg280) -2^31 = 2147483648 and the positive integer limits till 2147483647 i.e 2^31-1. So when n is negative and -2^31  when you multiply it with -1 to make positive it overflows so store -1*n into a temp variable of type long long and it should work. (before storing typecast it into long long)"
                    },
                    {
                        "username": "tojoSaha",
                        "content": "Were u able to find the solution to this test case?.. If so.. then please tell"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "To make sure that your algorithm is fast."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "How to solve this?"
                    },
                    {
                        "username": "shadowfax_",
                        "content": "just has the onsite and the interviewer tdidn\\'t want the recursive version but wanted the fast one with no recursion. \\n\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Hitro",
                        "content": "I\\'m wondering why you guys are not using builtin Math.pow() method??\\nPlease give me some insight.\\nThank you :)"
                    },
                    {
                        "username": "marcjeffs6",
                        "content": "[@barstow123](/barstow123) Is this real? I can go to FAANG and any given Sr developer will know how to recreate any built in method and explain its prime optimization?"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "We were asked to implement the built -in, which is basically Math.pow();\\nSo yeah, that\\'s what we\\'re doing"
                    },
                    {
                        "username": "barstow123",
                        "content": "The idea here is that we perform our work on the shoulders of giants.\\n\\nA more senior developer should be able to recreate built ins and explain how they are optimized if they want higher pay. for example, \"compile the solution in C++ for best performance\" is a good thing to say during senior interviews."
                    },
                    {
                        "username": "otherside2",
                        "content": "My C# code returns the expected Output for the below values when run in Visual Studio, but not here in Leetcode. Where is the disconnect? Could that be the reason why this question has so many thumbs down?\\n\\n240 / 304 test cases passed.\\nStatus: Wrong Answer\\n\\nSubmitted: 0\\xA0minutes ago\\nInput: \\n8.84372\\n-5\\nOutput: \\n0.0\\nExpected: \\n2e-05"
                    },
                    {
                        "username": "AYUSH-KATRE",
                        "content": "make 1 condition for n<0 and return 1/ans(that you are returning)"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Nishtha_2",
                        "content": "Question is under the catogery of binary search can someone suggest me solution with binary search"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@AdityaBhate](/AdityaBhate) IT doesn\\'t exist!!!"
                    },
                    {
                        "username": "r_shweta",
                        "content": "same\\n"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "To implement this problem in a naive way, we would need to multiply x with x for n times, as the n is too large, code would take ages to complete. Idea here is that once we find a square of x, we can multiply square of x with square of x to get x^4, we can again multiply x^4 with x^4 to get x^8 and so on and so forth.\\nx^1 * x^1 = x^(1+1) = x^2\\nx^2 * x^2 = x^(2+2) = x^4\\nx^4 * x^4 = x^(4+4) = x^8\\n.....\\nBy this way, we can reduce the time complexity from O(n) to O(log n), This problem comes under binary search as we are squaring(binary) each answer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "[@chickooo](/chickooo)  Actually it follows the concept of binary search, if you want to calculate for n = 4 you first calculate for  n = 2 and before calculating n = 2, you calculate n =1, so that you can obtain the solution in log(n) instead of calculating for 4 times it will take O(N) "
                    },
                    {
                        "username": "chickooo",
                        "content": "I don\\'t know why it was showing under the tag **binary search**, but the tags are now updated to **Math** and **Recursion**"
                    },
                    {
                        "username": "Will",
                        "content": "Please show me the code if any one can solve this using binary search. \\nThanks a lot!"
                    },
                    {
                        "username": "shivagama02",
                        "content": "The code for the same using binary search can be done in javascript. The code for the same is here: \\n\\nvar myPow = function(x, n) {\\n  if (n === 0) return 1;\\n  if (n > 0) return pow(x, n);\\n  if (n < 0) return 1 / pow(x, -n);\\n};\\n\\nvar pow = function (x, n) {\\n  if (n === 1) return x;\\n  var num = pow(x, Math.floor(n / 2));\\n  if (n % 2 === 0) {\\n    return num * num;\\n  } else {\\n    return x * num * num;\\n  }\\n};\\n\\n\\nThe code i tried has been accepted with time and space complexity of  O(log(n))."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@user2387402](/user2387402) Dude that's comment from 2015, that guy must've already moved on lol"
                    },
                    {
                        "username": "user2387402",
                        "content": "It\\'s not binary search. It is binary exploitation. Read the editorial."
                    },
                    {
                        "username": "mateenrehanbatt",
                        "content": "class Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n < 0:\\n            x = 1 / x\\n            n = -n\\n\\n        result = 1\\n        while n > 0:\\n            if n % 2 == 1:\\n                result *= x\\n            x *= x\\n            n //= 2\\n\\n        return result"
                    }
                ]
            },
            {
                "id": 1572134,
                "content": [
                    {
                        "username": "mrkanesir",
                        "content": "how am i supposed to NOT get stack overflow with n=2147483647 ..."
                    },
                    {
                        "username": "itsmesuni19",
                        "content": " if your solu is O(n) solu, use long long i in the loop"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "What are you doing bro, I didn\\'t get this error, try to solve in O(log N)"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "use python? "
                    },
                    {
                        "username": "19bec1397",
                        "content": "[@satyasanjay1999](/satyasanjay1999) how\\n"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "You should optimize the solution in logn time complexity. It will also reduce the stack size, then it will also run for n = -2147483648."
                    },
                    {
                        "username": "Linearly_Independent",
                        "content": "\\n\\n\\nreturn x**n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The point of Leetcode is interview practice.\\nWould you go to an interview, and if they ask how should you implement a fast power algorithm you give them the answer of `x**y`? The point is to test your math skills."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The first two words of the question ask you to implement pow(x, n). It's simply illogical to Implement it by calling itself."
                    },
                    {
                        "username": "Satyam_Mishra",
                        "content": "[@Miiza](/Miiza) Where this is mentioned? My code accepted at just return pow(x,n)"
                    },
                    {
                        "username": "Braderbell",
                        "content": "return pow(x, n)"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "as of  this we should know the implementation of x**n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "is it working"
                    },
                    {
                        "username": "Miiza",
                        "content": "Only that this is using pow(x, n) in the background, which you\\'re not suppose to use."
                    },
                    {
                        "username": "henrygriffin330",
                        "content": "this is what i did"
                    },
                    {
                        "username": "yanyehe",
                        "content": "duh"
                    },
                    {
                        "username": "JainAnshul",
                        "content": "for Python, is there anything better (in terms of complexity) than this? Otherwise, this seems to be obvious."
                    },
                    {
                        "username": "olooney",
                        "content": "This is the 37th problem I\\'ve solved on the site and in the end I got a respectible 4ms solution. But honestly, It seems like its 2% algorithm, 98% fiddling with binary representations of signed integers and floating point numbers. I also note that, as of this writing, the problem has 1160 downvotes to 428 upvotes, so there\\'s certainly some shared negativity out there. \\n\\nPersonally, I didn\\'t enjoy this problem because I felt like I spent more time writing custom test cases for corner cases than I did programming. Frankly I cannot imagine getting this question in an interview and having the interviewer go, \"aha! but your solution doesn\\'t account for the case when n is -2^31 and x is exactly -1.0! There\\'s no way we\\'d hire such an incompetent programmer!\" And yet the way the acceptance tests are written, you need to nail *every* *single* corner case. Perhaps that frustration is limited to C/C++? Or there\\'s a different algorithm that more naturally accounts for these edge cases? \\n\\nWhat was your experience? Would you agree or disagree with my thesis that this is the worst problem on the site? "
                    },
                    {
                        "username": "samstafford",
                        "content": "funny, when I saw the title of this one, I initially presumed rational exponent, not integer.  I got all excited about Taylor Series with coefficient reuse.  In fact, I will try that."
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I personally don\\'t like questions that have math as a related topic, because that description is vague. Let\\'s say I want to do this problem, and I don\\'t know recursion, nor do I know how to get the power of a number. I can look in the related topics section, and see that I need to know recursion, and study that, before retrying the problem.\\n\\nWhat will I see for the other part of the problem? Just a generic statement, \"Math\". And sure, this problem tells you what to do, but what about the Climbing Stairs problem? The generic \"Math\" topic tells me nothing of the type of math knowledge needed to solve the problem."
                    },
                    {
                        "username": "adlong01",
                        "content": "[@super____hot](/super____hot) I get a considerably faster solution using log."
                    },
                    {
                        "username": "imfosf0r",
                        "content": "I\\'d disagree: your complaints about the edge cases are just how this function is supposed to work, because of how math works. If you get a different answer for -2^31 than everyone else, then the function isn\\'t working right yet."
                    },
                    {
                        "username": "super____hot",
                        "content": "in python x**n is the fastest method"
                    },
                    {
                        "username": "misterabdul",
                        "content": "I\\'m a C fan & I solve this problem using C. For me this is an interesting problem that let me learn again how the basic pow function could be implemented & let me try to optimize my solution to account for every corner cases. This is such a fun exercises in C IMO."
                    },
                    {
                        "username": "tylermatchett",
                        "content": "Here is a test case made by someone who was in a bad mood\\nx=-1\\nn=2147483647"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "This was a simple one. n%2 ==1, x^n is going to be -1. Because -1 ^ even number is equal to 1  AND -1^odd number is equal to -1."
                    },
                    {
                        "username": "sylvex",
                        "content": "```\\nx =\\n2.00000\\nn =\\n-2147483648\\n```\\nWhat even is the point of this edge case???"
                    },
                    {
                        "username": "tree9",
                        "content": "[@tojoSaha](/tojoSaha)  check this out please https://leetcode.com/problems/powx-n/solutions/4086833/beats-100-log-n-solution/ it handles the above case. Basically invert x and make n positive and carry on with same logic as for positive x and n. Take long N."
                    },
                    {
                        "username": "kavyamittal1282",
                        "content": "[@m_afnan2018](/m_afnan2018)  iam doing in java and geting the same error"
                    },
                    {
                        "username": "sandevil23",
                        "content": "i noticed that they have assigned int to n and here they are passing the upper and lower limits of long int "
                    },
                    {
                        "username": "amar180N_th",
                        "content": "hey I also got the same error here"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Use long long..."
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "[@tojoSaha](/tojoSaha) use abs"
                    },
                    {
                        "username": "issac_tirkey1",
                        "content": "[@heisenberg280](/heisenberg280) -2^31 = 2147483648 and the positive integer limits till 2147483647 i.e 2^31-1. So when n is negative and -2^31  when you multiply it with -1 to make positive it overflows so store -1*n into a temp variable of type long long and it should work. (before storing typecast it into long long)"
                    },
                    {
                        "username": "tojoSaha",
                        "content": "Were u able to find the solution to this test case?.. If so.. then please tell"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "To make sure that your algorithm is fast."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "How to solve this?"
                    },
                    {
                        "username": "shadowfax_",
                        "content": "just has the onsite and the interviewer tdidn\\'t want the recursive version but wanted the fast one with no recursion. \\n\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Hitro",
                        "content": "I\\'m wondering why you guys are not using builtin Math.pow() method??\\nPlease give me some insight.\\nThank you :)"
                    },
                    {
                        "username": "marcjeffs6",
                        "content": "[@barstow123](/barstow123) Is this real? I can go to FAANG and any given Sr developer will know how to recreate any built in method and explain its prime optimization?"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "We were asked to implement the built -in, which is basically Math.pow();\\nSo yeah, that\\'s what we\\'re doing"
                    },
                    {
                        "username": "barstow123",
                        "content": "The idea here is that we perform our work on the shoulders of giants.\\n\\nA more senior developer should be able to recreate built ins and explain how they are optimized if they want higher pay. for example, \"compile the solution in C++ for best performance\" is a good thing to say during senior interviews."
                    },
                    {
                        "username": "otherside2",
                        "content": "My C# code returns the expected Output for the below values when run in Visual Studio, but not here in Leetcode. Where is the disconnect? Could that be the reason why this question has so many thumbs down?\\n\\n240 / 304 test cases passed.\\nStatus: Wrong Answer\\n\\nSubmitted: 0\\xA0minutes ago\\nInput: \\n8.84372\\n-5\\nOutput: \\n0.0\\nExpected: \\n2e-05"
                    },
                    {
                        "username": "AYUSH-KATRE",
                        "content": "make 1 condition for n<0 and return 1/ans(that you are returning)"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Nishtha_2",
                        "content": "Question is under the catogery of binary search can someone suggest me solution with binary search"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@AdityaBhate](/AdityaBhate) IT doesn\\'t exist!!!"
                    },
                    {
                        "username": "r_shweta",
                        "content": "same\\n"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "To implement this problem in a naive way, we would need to multiply x with x for n times, as the n is too large, code would take ages to complete. Idea here is that once we find a square of x, we can multiply square of x with square of x to get x^4, we can again multiply x^4 with x^4 to get x^8 and so on and so forth.\\nx^1 * x^1 = x^(1+1) = x^2\\nx^2 * x^2 = x^(2+2) = x^4\\nx^4 * x^4 = x^(4+4) = x^8\\n.....\\nBy this way, we can reduce the time complexity from O(n) to O(log n), This problem comes under binary search as we are squaring(binary) each answer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "[@chickooo](/chickooo)  Actually it follows the concept of binary search, if you want to calculate for n = 4 you first calculate for  n = 2 and before calculating n = 2, you calculate n =1, so that you can obtain the solution in log(n) instead of calculating for 4 times it will take O(N) "
                    },
                    {
                        "username": "chickooo",
                        "content": "I don\\'t know why it was showing under the tag **binary search**, but the tags are now updated to **Math** and **Recursion**"
                    },
                    {
                        "username": "Will",
                        "content": "Please show me the code if any one can solve this using binary search. \\nThanks a lot!"
                    },
                    {
                        "username": "shivagama02",
                        "content": "The code for the same using binary search can be done in javascript. The code for the same is here: \\n\\nvar myPow = function(x, n) {\\n  if (n === 0) return 1;\\n  if (n > 0) return pow(x, n);\\n  if (n < 0) return 1 / pow(x, -n);\\n};\\n\\nvar pow = function (x, n) {\\n  if (n === 1) return x;\\n  var num = pow(x, Math.floor(n / 2));\\n  if (n % 2 === 0) {\\n    return num * num;\\n  } else {\\n    return x * num * num;\\n  }\\n};\\n\\n\\nThe code i tried has been accepted with time and space complexity of  O(log(n))."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@user2387402](/user2387402) Dude that's comment from 2015, that guy must've already moved on lol"
                    },
                    {
                        "username": "user2387402",
                        "content": "It\\'s not binary search. It is binary exploitation. Read the editorial."
                    },
                    {
                        "username": "mateenrehanbatt",
                        "content": "class Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n < 0:\\n            x = 1 / x\\n            n = -n\\n\\n        result = 1\\n        while n > 0:\\n            if n % 2 == 1:\\n                result *= x\\n            x *= x\\n            n //= 2\\n\\n        return result"
                    }
                ]
            },
            {
                "id": 1565602,
                "content": [
                    {
                        "username": "mrkanesir",
                        "content": "how am i supposed to NOT get stack overflow with n=2147483647 ..."
                    },
                    {
                        "username": "itsmesuni19",
                        "content": " if your solu is O(n) solu, use long long i in the loop"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "What are you doing bro, I didn\\'t get this error, try to solve in O(log N)"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "use python? "
                    },
                    {
                        "username": "19bec1397",
                        "content": "[@satyasanjay1999](/satyasanjay1999) how\\n"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "You should optimize the solution in logn time complexity. It will also reduce the stack size, then it will also run for n = -2147483648."
                    },
                    {
                        "username": "Linearly_Independent",
                        "content": "\\n\\n\\nreturn x**n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The point of Leetcode is interview practice.\\nWould you go to an interview, and if they ask how should you implement a fast power algorithm you give them the answer of `x**y`? The point is to test your math skills."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The first two words of the question ask you to implement pow(x, n). It's simply illogical to Implement it by calling itself."
                    },
                    {
                        "username": "Satyam_Mishra",
                        "content": "[@Miiza](/Miiza) Where this is mentioned? My code accepted at just return pow(x,n)"
                    },
                    {
                        "username": "Braderbell",
                        "content": "return pow(x, n)"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "as of  this we should know the implementation of x**n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "is it working"
                    },
                    {
                        "username": "Miiza",
                        "content": "Only that this is using pow(x, n) in the background, which you\\'re not suppose to use."
                    },
                    {
                        "username": "henrygriffin330",
                        "content": "this is what i did"
                    },
                    {
                        "username": "yanyehe",
                        "content": "duh"
                    },
                    {
                        "username": "JainAnshul",
                        "content": "for Python, is there anything better (in terms of complexity) than this? Otherwise, this seems to be obvious."
                    },
                    {
                        "username": "olooney",
                        "content": "This is the 37th problem I\\'ve solved on the site and in the end I got a respectible 4ms solution. But honestly, It seems like its 2% algorithm, 98% fiddling with binary representations of signed integers and floating point numbers. I also note that, as of this writing, the problem has 1160 downvotes to 428 upvotes, so there\\'s certainly some shared negativity out there. \\n\\nPersonally, I didn\\'t enjoy this problem because I felt like I spent more time writing custom test cases for corner cases than I did programming. Frankly I cannot imagine getting this question in an interview and having the interviewer go, \"aha! but your solution doesn\\'t account for the case when n is -2^31 and x is exactly -1.0! There\\'s no way we\\'d hire such an incompetent programmer!\" And yet the way the acceptance tests are written, you need to nail *every* *single* corner case. Perhaps that frustration is limited to C/C++? Or there\\'s a different algorithm that more naturally accounts for these edge cases? \\n\\nWhat was your experience? Would you agree or disagree with my thesis that this is the worst problem on the site? "
                    },
                    {
                        "username": "samstafford",
                        "content": "funny, when I saw the title of this one, I initially presumed rational exponent, not integer.  I got all excited about Taylor Series with coefficient reuse.  In fact, I will try that."
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I personally don\\'t like questions that have math as a related topic, because that description is vague. Let\\'s say I want to do this problem, and I don\\'t know recursion, nor do I know how to get the power of a number. I can look in the related topics section, and see that I need to know recursion, and study that, before retrying the problem.\\n\\nWhat will I see for the other part of the problem? Just a generic statement, \"Math\". And sure, this problem tells you what to do, but what about the Climbing Stairs problem? The generic \"Math\" topic tells me nothing of the type of math knowledge needed to solve the problem."
                    },
                    {
                        "username": "adlong01",
                        "content": "[@super____hot](/super____hot) I get a considerably faster solution using log."
                    },
                    {
                        "username": "imfosf0r",
                        "content": "I\\'d disagree: your complaints about the edge cases are just how this function is supposed to work, because of how math works. If you get a different answer for -2^31 than everyone else, then the function isn\\'t working right yet."
                    },
                    {
                        "username": "super____hot",
                        "content": "in python x**n is the fastest method"
                    },
                    {
                        "username": "misterabdul",
                        "content": "I\\'m a C fan & I solve this problem using C. For me this is an interesting problem that let me learn again how the basic pow function could be implemented & let me try to optimize my solution to account for every corner cases. This is such a fun exercises in C IMO."
                    },
                    {
                        "username": "tylermatchett",
                        "content": "Here is a test case made by someone who was in a bad mood\\nx=-1\\nn=2147483647"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "This was a simple one. n%2 ==1, x^n is going to be -1. Because -1 ^ even number is equal to 1  AND -1^odd number is equal to -1."
                    },
                    {
                        "username": "sylvex",
                        "content": "```\\nx =\\n2.00000\\nn =\\n-2147483648\\n```\\nWhat even is the point of this edge case???"
                    },
                    {
                        "username": "tree9",
                        "content": "[@tojoSaha](/tojoSaha)  check this out please https://leetcode.com/problems/powx-n/solutions/4086833/beats-100-log-n-solution/ it handles the above case. Basically invert x and make n positive and carry on with same logic as for positive x and n. Take long N."
                    },
                    {
                        "username": "kavyamittal1282",
                        "content": "[@m_afnan2018](/m_afnan2018)  iam doing in java and geting the same error"
                    },
                    {
                        "username": "sandevil23",
                        "content": "i noticed that they have assigned int to n and here they are passing the upper and lower limits of long int "
                    },
                    {
                        "username": "amar180N_th",
                        "content": "hey I also got the same error here"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Use long long..."
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "[@tojoSaha](/tojoSaha) use abs"
                    },
                    {
                        "username": "issac_tirkey1",
                        "content": "[@heisenberg280](/heisenberg280) -2^31 = 2147483648 and the positive integer limits till 2147483647 i.e 2^31-1. So when n is negative and -2^31  when you multiply it with -1 to make positive it overflows so store -1*n into a temp variable of type long long and it should work. (before storing typecast it into long long)"
                    },
                    {
                        "username": "tojoSaha",
                        "content": "Were u able to find the solution to this test case?.. If so.. then please tell"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "To make sure that your algorithm is fast."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "How to solve this?"
                    },
                    {
                        "username": "shadowfax_",
                        "content": "just has the onsite and the interviewer tdidn\\'t want the recursive version but wanted the fast one with no recursion. \\n\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Hitro",
                        "content": "I\\'m wondering why you guys are not using builtin Math.pow() method??\\nPlease give me some insight.\\nThank you :)"
                    },
                    {
                        "username": "marcjeffs6",
                        "content": "[@barstow123](/barstow123) Is this real? I can go to FAANG and any given Sr developer will know how to recreate any built in method and explain its prime optimization?"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "We were asked to implement the built -in, which is basically Math.pow();\\nSo yeah, that\\'s what we\\'re doing"
                    },
                    {
                        "username": "barstow123",
                        "content": "The idea here is that we perform our work on the shoulders of giants.\\n\\nA more senior developer should be able to recreate built ins and explain how they are optimized if they want higher pay. for example, \"compile the solution in C++ for best performance\" is a good thing to say during senior interviews."
                    },
                    {
                        "username": "otherside2",
                        "content": "My C# code returns the expected Output for the below values when run in Visual Studio, but not here in Leetcode. Where is the disconnect? Could that be the reason why this question has so many thumbs down?\\n\\n240 / 304 test cases passed.\\nStatus: Wrong Answer\\n\\nSubmitted: 0\\xA0minutes ago\\nInput: \\n8.84372\\n-5\\nOutput: \\n0.0\\nExpected: \\n2e-05"
                    },
                    {
                        "username": "AYUSH-KATRE",
                        "content": "make 1 condition for n<0 and return 1/ans(that you are returning)"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Nishtha_2",
                        "content": "Question is under the catogery of binary search can someone suggest me solution with binary search"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@AdityaBhate](/AdityaBhate) IT doesn\\'t exist!!!"
                    },
                    {
                        "username": "r_shweta",
                        "content": "same\\n"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "To implement this problem in a naive way, we would need to multiply x with x for n times, as the n is too large, code would take ages to complete. Idea here is that once we find a square of x, we can multiply square of x with square of x to get x^4, we can again multiply x^4 with x^4 to get x^8 and so on and so forth.\\nx^1 * x^1 = x^(1+1) = x^2\\nx^2 * x^2 = x^(2+2) = x^4\\nx^4 * x^4 = x^(4+4) = x^8\\n.....\\nBy this way, we can reduce the time complexity from O(n) to O(log n), This problem comes under binary search as we are squaring(binary) each answer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "[@chickooo](/chickooo)  Actually it follows the concept of binary search, if you want to calculate for n = 4 you first calculate for  n = 2 and before calculating n = 2, you calculate n =1, so that you can obtain the solution in log(n) instead of calculating for 4 times it will take O(N) "
                    },
                    {
                        "username": "chickooo",
                        "content": "I don\\'t know why it was showing under the tag **binary search**, but the tags are now updated to **Math** and **Recursion**"
                    },
                    {
                        "username": "Will",
                        "content": "Please show me the code if any one can solve this using binary search. \\nThanks a lot!"
                    },
                    {
                        "username": "shivagama02",
                        "content": "The code for the same using binary search can be done in javascript. The code for the same is here: \\n\\nvar myPow = function(x, n) {\\n  if (n === 0) return 1;\\n  if (n > 0) return pow(x, n);\\n  if (n < 0) return 1 / pow(x, -n);\\n};\\n\\nvar pow = function (x, n) {\\n  if (n === 1) return x;\\n  var num = pow(x, Math.floor(n / 2));\\n  if (n % 2 === 0) {\\n    return num * num;\\n  } else {\\n    return x * num * num;\\n  }\\n};\\n\\n\\nThe code i tried has been accepted with time and space complexity of  O(log(n))."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@user2387402](/user2387402) Dude that's comment from 2015, that guy must've already moved on lol"
                    },
                    {
                        "username": "user2387402",
                        "content": "It\\'s not binary search. It is binary exploitation. Read the editorial."
                    },
                    {
                        "username": "mateenrehanbatt",
                        "content": "class Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n < 0:\\n            x = 1 / x\\n            n = -n\\n\\n        result = 1\\n        while n > 0:\\n            if n % 2 == 1:\\n                result *= x\\n            x *= x\\n            n //= 2\\n\\n        return result"
                    }
                ]
            },
            {
                "id": 1567826,
                "content": [
                    {
                        "username": "mrkanesir",
                        "content": "how am i supposed to NOT get stack overflow with n=2147483647 ..."
                    },
                    {
                        "username": "itsmesuni19",
                        "content": " if your solu is O(n) solu, use long long i in the loop"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "What are you doing bro, I didn\\'t get this error, try to solve in O(log N)"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "use python? "
                    },
                    {
                        "username": "19bec1397",
                        "content": "[@satyasanjay1999](/satyasanjay1999) how\\n"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "You should optimize the solution in logn time complexity. It will also reduce the stack size, then it will also run for n = -2147483648."
                    },
                    {
                        "username": "Linearly_Independent",
                        "content": "\\n\\n\\nreturn x**n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The point of Leetcode is interview practice.\\nWould you go to an interview, and if they ask how should you implement a fast power algorithm you give them the answer of `x**y`? The point is to test your math skills."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@Satyam_Mishra](/Satyam_Mishra) The first two words of the question ask you to implement pow(x, n). It's simply illogical to Implement it by calling itself."
                    },
                    {
                        "username": "Satyam_Mishra",
                        "content": "[@Miiza](/Miiza) Where this is mentioned? My code accepted at just return pow(x,n)"
                    },
                    {
                        "username": "Braderbell",
                        "content": "return pow(x, n)"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "as of  this we should know the implementation of x**n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "is it working"
                    },
                    {
                        "username": "Miiza",
                        "content": "Only that this is using pow(x, n) in the background, which you\\'re not suppose to use."
                    },
                    {
                        "username": "henrygriffin330",
                        "content": "this is what i did"
                    },
                    {
                        "username": "yanyehe",
                        "content": "duh"
                    },
                    {
                        "username": "JainAnshul",
                        "content": "for Python, is there anything better (in terms of complexity) than this? Otherwise, this seems to be obvious."
                    },
                    {
                        "username": "olooney",
                        "content": "This is the 37th problem I\\'ve solved on the site and in the end I got a respectible 4ms solution. But honestly, It seems like its 2% algorithm, 98% fiddling with binary representations of signed integers and floating point numbers. I also note that, as of this writing, the problem has 1160 downvotes to 428 upvotes, so there\\'s certainly some shared negativity out there. \\n\\nPersonally, I didn\\'t enjoy this problem because I felt like I spent more time writing custom test cases for corner cases than I did programming. Frankly I cannot imagine getting this question in an interview and having the interviewer go, \"aha! but your solution doesn\\'t account for the case when n is -2^31 and x is exactly -1.0! There\\'s no way we\\'d hire such an incompetent programmer!\" And yet the way the acceptance tests are written, you need to nail *every* *single* corner case. Perhaps that frustration is limited to C/C++? Or there\\'s a different algorithm that more naturally accounts for these edge cases? \\n\\nWhat was your experience? Would you agree or disagree with my thesis that this is the worst problem on the site? "
                    },
                    {
                        "username": "samstafford",
                        "content": "funny, when I saw the title of this one, I initially presumed rational exponent, not integer.  I got all excited about Taylor Series with coefficient reuse.  In fact, I will try that."
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I personally don\\'t like questions that have math as a related topic, because that description is vague. Let\\'s say I want to do this problem, and I don\\'t know recursion, nor do I know how to get the power of a number. I can look in the related topics section, and see that I need to know recursion, and study that, before retrying the problem.\\n\\nWhat will I see for the other part of the problem? Just a generic statement, \"Math\". And sure, this problem tells you what to do, but what about the Climbing Stairs problem? The generic \"Math\" topic tells me nothing of the type of math knowledge needed to solve the problem."
                    },
                    {
                        "username": "adlong01",
                        "content": "[@super____hot](/super____hot) I get a considerably faster solution using log."
                    },
                    {
                        "username": "imfosf0r",
                        "content": "I\\'d disagree: your complaints about the edge cases are just how this function is supposed to work, because of how math works. If you get a different answer for -2^31 than everyone else, then the function isn\\'t working right yet."
                    },
                    {
                        "username": "super____hot",
                        "content": "in python x**n is the fastest method"
                    },
                    {
                        "username": "misterabdul",
                        "content": "I\\'m a C fan & I solve this problem using C. For me this is an interesting problem that let me learn again how the basic pow function could be implemented & let me try to optimize my solution to account for every corner cases. This is such a fun exercises in C IMO."
                    },
                    {
                        "username": "tylermatchett",
                        "content": "Here is a test case made by someone who was in a bad mood\\nx=-1\\nn=2147483647"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "This was a simple one. n%2 ==1, x^n is going to be -1. Because -1 ^ even number is equal to 1  AND -1^odd number is equal to -1."
                    },
                    {
                        "username": "sylvex",
                        "content": "```\\nx =\\n2.00000\\nn =\\n-2147483648\\n```\\nWhat even is the point of this edge case???"
                    },
                    {
                        "username": "tree9",
                        "content": "[@tojoSaha](/tojoSaha)  check this out please https://leetcode.com/problems/powx-n/solutions/4086833/beats-100-log-n-solution/ it handles the above case. Basically invert x and make n positive and carry on with same logic as for positive x and n. Take long N."
                    },
                    {
                        "username": "kavyamittal1282",
                        "content": "[@m_afnan2018](/m_afnan2018)  iam doing in java and geting the same error"
                    },
                    {
                        "username": "sandevil23",
                        "content": "i noticed that they have assigned int to n and here they are passing the upper and lower limits of long int "
                    },
                    {
                        "username": "amar180N_th",
                        "content": "hey I also got the same error here"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Use long long..."
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "[@tojoSaha](/tojoSaha) use abs"
                    },
                    {
                        "username": "issac_tirkey1",
                        "content": "[@heisenberg280](/heisenberg280) -2^31 = 2147483648 and the positive integer limits till 2147483647 i.e 2^31-1. So when n is negative and -2^31  when you multiply it with -1 to make positive it overflows so store -1*n into a temp variable of type long long and it should work. (before storing typecast it into long long)"
                    },
                    {
                        "username": "tojoSaha",
                        "content": "Were u able to find the solution to this test case?.. If so.. then please tell"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "To make sure that your algorithm is fast."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "How to solve this?"
                    },
                    {
                        "username": "shadowfax_",
                        "content": "just has the onsite and the interviewer tdidn\\'t want the recursive version but wanted the fast one with no recursion. \\n\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Hitro",
                        "content": "I\\'m wondering why you guys are not using builtin Math.pow() method??\\nPlease give me some insight.\\nThank you :)"
                    },
                    {
                        "username": "marcjeffs6",
                        "content": "[@barstow123](/barstow123) Is this real? I can go to FAANG and any given Sr developer will know how to recreate any built in method and explain its prime optimization?"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "We were asked to implement the built -in, which is basically Math.pow();\\nSo yeah, that\\'s what we\\'re doing"
                    },
                    {
                        "username": "barstow123",
                        "content": "The idea here is that we perform our work on the shoulders of giants.\\n\\nA more senior developer should be able to recreate built ins and explain how they are optimized if they want higher pay. for example, \"compile the solution in C++ for best performance\" is a good thing to say during senior interviews."
                    },
                    {
                        "username": "otherside2",
                        "content": "My C# code returns the expected Output for the below values when run in Visual Studio, but not here in Leetcode. Where is the disconnect? Could that be the reason why this question has so many thumbs down?\\n\\n240 / 304 test cases passed.\\nStatus: Wrong Answer\\n\\nSubmitted: 0\\xA0minutes ago\\nInput: \\n8.84372\\n-5\\nOutput: \\n0.0\\nExpected: \\n2e-05"
                    },
                    {
                        "username": "AYUSH-KATRE",
                        "content": "make 1 condition for n<0 and return 1/ans(that you are returning)"
                    },
                    {
                        "username": "201132",
                        "content": "https://youtu.be/-mNn11iRZ5k\\n"
                    },
                    {
                        "username": "Nishtha_2",
                        "content": "Question is under the catogery of binary search can someone suggest me solution with binary search"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@AdityaBhate](/AdityaBhate) IT doesn\\'t exist!!!"
                    },
                    {
                        "username": "r_shweta",
                        "content": "same\\n"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "To implement this problem in a naive way, we would need to multiply x with x for n times, as the n is too large, code would take ages to complete. Idea here is that once we find a square of x, we can multiply square of x with square of x to get x^4, we can again multiply x^4 with x^4 to get x^8 and so on and so forth.\\nx^1 * x^1 = x^(1+1) = x^2\\nx^2 * x^2 = x^(2+2) = x^4\\nx^4 * x^4 = x^(4+4) = x^8\\n.....\\nBy this way, we can reduce the time complexity from O(n) to O(log n), This problem comes under binary search as we are squaring(binary) each answer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "[@chickooo](/chickooo)  Actually it follows the concept of binary search, if you want to calculate for n = 4 you first calculate for  n = 2 and before calculating n = 2, you calculate n =1, so that you can obtain the solution in log(n) instead of calculating for 4 times it will take O(N) "
                    },
                    {
                        "username": "chickooo",
                        "content": "I don\\'t know why it was showing under the tag **binary search**, but the tags are now updated to **Math** and **Recursion**"
                    },
                    {
                        "username": "Will",
                        "content": "Please show me the code if any one can solve this using binary search. \\nThanks a lot!"
                    },
                    {
                        "username": "shivagama02",
                        "content": "The code for the same using binary search can be done in javascript. The code for the same is here: \\n\\nvar myPow = function(x, n) {\\n  if (n === 0) return 1;\\n  if (n > 0) return pow(x, n);\\n  if (n < 0) return 1 / pow(x, -n);\\n};\\n\\nvar pow = function (x, n) {\\n  if (n === 1) return x;\\n  var num = pow(x, Math.floor(n / 2));\\n  if (n % 2 === 0) {\\n    return num * num;\\n  } else {\\n    return x * num * num;\\n  }\\n};\\n\\n\\nThe code i tried has been accepted with time and space complexity of  O(log(n))."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@user2387402](/user2387402) Dude that's comment from 2015, that guy must've already moved on lol"
                    },
                    {
                        "username": "user2387402",
                        "content": "It\\'s not binary search. It is binary exploitation. Read the editorial."
                    },
                    {
                        "username": "mateenrehanbatt",
                        "content": "class Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n < 0:\\n            x = 1 / x\\n            n = -n\\n\\n        result = 1\\n        while n > 0:\\n            if n % 2 == 1:\\n                result *= x\\n            x *= x\\n            n //= 2\\n\\n        return result"
                    }
                ]
            },
            {
                "id": 1863488,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Is there something broken about testcase 305?"
                    },
                    {
                        "username": "Shristi_uniyal",
                        "content": "return Double.parseDouble(String.format(\"%.5f\",Math.pow(x,n)));"
                    },
                    {
                        "username": "fantazer",
                        "content": "There is something abnormal. \\n\\nTime Limit Exceeded ------ 305 / 305 testcases passed ???\\nLast Executed Input\\nx = \\n\\nLiterally, x = nothing there, empty space. \\nHow is that possible? \\n \\n`double myPow(double x, int n){\\n\\n    if (x==1.0) return 1;\\n    if (x==-1){\\n        if (n%2 == 0) return 1.0;\\n        else return -1.0;\\n    }\\n    if (x>1.0 && n<-2147483647) return 0;\\n    double res = 1;\\n    int t;\\n    if (n>=0) t=n;\\n    else t=n*(-1);\\n    if (t>=0){\\n        while(t--){\\n            res*=x; \\n        }\\n    }\\n    if (n>=0)\\n    return res;\\n    return 1/res;\\n}`"
                    },
                    {
                        "username": "superplane",
                        "content": "I have done several Leetcode problems with python. In general I feel that using python, iterative solutions are generally faster than recursive ones. For some problems, recursive solutions will exceed time limit, while iterative ones will not. Does anyone have similar feeling? Is it generally true for python?"
                    },
                    {
                        "username": "the-iter8",
                        "content": "[@Dabboiiii](/Dabboiiii) Time + space"
                    },
                    {
                        "username": "Dabboiiii",
                        "content": "recursive solutions always take more time than iterative. it\\'s one of their downsides"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Exponentiation can use its binary expression to compute! \n# If you want to change sign for n, be careful! When n=-2^31, it would lead to a overflow."
                    },
                    {
                        "username": "Arpit_001",
                        "content": "Stucking at a high on weed test case\\nx= 0.000001\\nn=-2147483647 \\nhow to not get StackOverFlowError"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Use long instead of int"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Couldn\\'t pass the test case where $x =  0.999999999 and $n = -2147483648.\\nIf I var_export($x), it is 1.00000. Am I missing something or is this an issue with how leetcode runs these test cases for php?"
                    },
                    {
                        "username": "Shaybra",
                        "content": "your code should check for the maxes for the power, and then return 0 or inf"
                    },
                    {
                        "username": "TibetSoap",
                        "content": "Happening the same using C# and C++. This is really ridiculous. "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "return pow(x,n);\\n\\nBeats 100% of the Solution :) \\nI have successfully unlocked my clown outfit."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "lmao, thanks for the laugh"
                    },
                    {
                        "username": "szm9119",
                        "content": "divide by zero test case not considered"
                    },
                    {
                        "username": "grovre",
                        "content": "Leetcode\\'s got some balls making this one the daily"
                    }
                ]
            },
            {
                "id": 1573433,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Is there something broken about testcase 305?"
                    },
                    {
                        "username": "Shristi_uniyal",
                        "content": "return Double.parseDouble(String.format(\"%.5f\",Math.pow(x,n)));"
                    },
                    {
                        "username": "fantazer",
                        "content": "There is something abnormal. \\n\\nTime Limit Exceeded ------ 305 / 305 testcases passed ???\\nLast Executed Input\\nx = \\n\\nLiterally, x = nothing there, empty space. \\nHow is that possible? \\n \\n`double myPow(double x, int n){\\n\\n    if (x==1.0) return 1;\\n    if (x==-1){\\n        if (n%2 == 0) return 1.0;\\n        else return -1.0;\\n    }\\n    if (x>1.0 && n<-2147483647) return 0;\\n    double res = 1;\\n    int t;\\n    if (n>=0) t=n;\\n    else t=n*(-1);\\n    if (t>=0){\\n        while(t--){\\n            res*=x; \\n        }\\n    }\\n    if (n>=0)\\n    return res;\\n    return 1/res;\\n}`"
                    },
                    {
                        "username": "superplane",
                        "content": "I have done several Leetcode problems with python. In general I feel that using python, iterative solutions are generally faster than recursive ones. For some problems, recursive solutions will exceed time limit, while iterative ones will not. Does anyone have similar feeling? Is it generally true for python?"
                    },
                    {
                        "username": "the-iter8",
                        "content": "[@Dabboiiii](/Dabboiiii) Time + space"
                    },
                    {
                        "username": "Dabboiiii",
                        "content": "recursive solutions always take more time than iterative. it\\'s one of their downsides"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Exponentiation can use its binary expression to compute! \n# If you want to change sign for n, be careful! When n=-2^31, it would lead to a overflow."
                    },
                    {
                        "username": "Arpit_001",
                        "content": "Stucking at a high on weed test case\\nx= 0.000001\\nn=-2147483647 \\nhow to not get StackOverFlowError"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Use long instead of int"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Couldn\\'t pass the test case where $x =  0.999999999 and $n = -2147483648.\\nIf I var_export($x), it is 1.00000. Am I missing something or is this an issue with how leetcode runs these test cases for php?"
                    },
                    {
                        "username": "Shaybra",
                        "content": "your code should check for the maxes for the power, and then return 0 or inf"
                    },
                    {
                        "username": "TibetSoap",
                        "content": "Happening the same using C# and C++. This is really ridiculous. "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "return pow(x,n);\\n\\nBeats 100% of the Solution :) \\nI have successfully unlocked my clown outfit."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "lmao, thanks for the laugh"
                    },
                    {
                        "username": "szm9119",
                        "content": "divide by zero test case not considered"
                    },
                    {
                        "username": "grovre",
                        "content": "Leetcode\\'s got some balls making this one the daily"
                    }
                ]
            },
            {
                "id": 1736993,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Is there something broken about testcase 305?"
                    },
                    {
                        "username": "Shristi_uniyal",
                        "content": "return Double.parseDouble(String.format(\"%.5f\",Math.pow(x,n)));"
                    },
                    {
                        "username": "fantazer",
                        "content": "There is something abnormal. \\n\\nTime Limit Exceeded ------ 305 / 305 testcases passed ???\\nLast Executed Input\\nx = \\n\\nLiterally, x = nothing there, empty space. \\nHow is that possible? \\n \\n`double myPow(double x, int n){\\n\\n    if (x==1.0) return 1;\\n    if (x==-1){\\n        if (n%2 == 0) return 1.0;\\n        else return -1.0;\\n    }\\n    if (x>1.0 && n<-2147483647) return 0;\\n    double res = 1;\\n    int t;\\n    if (n>=0) t=n;\\n    else t=n*(-1);\\n    if (t>=0){\\n        while(t--){\\n            res*=x; \\n        }\\n    }\\n    if (n>=0)\\n    return res;\\n    return 1/res;\\n}`"
                    },
                    {
                        "username": "superplane",
                        "content": "I have done several Leetcode problems with python. In general I feel that using python, iterative solutions are generally faster than recursive ones. For some problems, recursive solutions will exceed time limit, while iterative ones will not. Does anyone have similar feeling? Is it generally true for python?"
                    },
                    {
                        "username": "the-iter8",
                        "content": "[@Dabboiiii](/Dabboiiii) Time + space"
                    },
                    {
                        "username": "Dabboiiii",
                        "content": "recursive solutions always take more time than iterative. it\\'s one of their downsides"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Exponentiation can use its binary expression to compute! \n# If you want to change sign for n, be careful! When n=-2^31, it would lead to a overflow."
                    },
                    {
                        "username": "Arpit_001",
                        "content": "Stucking at a high on weed test case\\nx= 0.000001\\nn=-2147483647 \\nhow to not get StackOverFlowError"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Use long instead of int"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Couldn\\'t pass the test case where $x =  0.999999999 and $n = -2147483648.\\nIf I var_export($x), it is 1.00000. Am I missing something or is this an issue with how leetcode runs these test cases for php?"
                    },
                    {
                        "username": "Shaybra",
                        "content": "your code should check for the maxes for the power, and then return 0 or inf"
                    },
                    {
                        "username": "TibetSoap",
                        "content": "Happening the same using C# and C++. This is really ridiculous. "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "return pow(x,n);\\n\\nBeats 100% of the Solution :) \\nI have successfully unlocked my clown outfit."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "lmao, thanks for the laugh"
                    },
                    {
                        "username": "szm9119",
                        "content": "divide by zero test case not considered"
                    },
                    {
                        "username": "grovre",
                        "content": "Leetcode\\'s got some balls making this one the daily"
                    }
                ]
            },
            {
                "id": 1571123,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Is there something broken about testcase 305?"
                    },
                    {
                        "username": "Shristi_uniyal",
                        "content": "return Double.parseDouble(String.format(\"%.5f\",Math.pow(x,n)));"
                    },
                    {
                        "username": "fantazer",
                        "content": "There is something abnormal. \\n\\nTime Limit Exceeded ------ 305 / 305 testcases passed ???\\nLast Executed Input\\nx = \\n\\nLiterally, x = nothing there, empty space. \\nHow is that possible? \\n \\n`double myPow(double x, int n){\\n\\n    if (x==1.0) return 1;\\n    if (x==-1){\\n        if (n%2 == 0) return 1.0;\\n        else return -1.0;\\n    }\\n    if (x>1.0 && n<-2147483647) return 0;\\n    double res = 1;\\n    int t;\\n    if (n>=0) t=n;\\n    else t=n*(-1);\\n    if (t>=0){\\n        while(t--){\\n            res*=x; \\n        }\\n    }\\n    if (n>=0)\\n    return res;\\n    return 1/res;\\n}`"
                    },
                    {
                        "username": "superplane",
                        "content": "I have done several Leetcode problems with python. In general I feel that using python, iterative solutions are generally faster than recursive ones. For some problems, recursive solutions will exceed time limit, while iterative ones will not. Does anyone have similar feeling? Is it generally true for python?"
                    },
                    {
                        "username": "the-iter8",
                        "content": "[@Dabboiiii](/Dabboiiii) Time + space"
                    },
                    {
                        "username": "Dabboiiii",
                        "content": "recursive solutions always take more time than iterative. it\\'s one of their downsides"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Exponentiation can use its binary expression to compute! \n# If you want to change sign for n, be careful! When n=-2^31, it would lead to a overflow."
                    },
                    {
                        "username": "Arpit_001",
                        "content": "Stucking at a high on weed test case\\nx= 0.000001\\nn=-2147483647 \\nhow to not get StackOverFlowError"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Use long instead of int"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Couldn\\'t pass the test case where $x =  0.999999999 and $n = -2147483648.\\nIf I var_export($x), it is 1.00000. Am I missing something or is this an issue with how leetcode runs these test cases for php?"
                    },
                    {
                        "username": "Shaybra",
                        "content": "your code should check for the maxes for the power, and then return 0 or inf"
                    },
                    {
                        "username": "TibetSoap",
                        "content": "Happening the same using C# and C++. This is really ridiculous. "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "return pow(x,n);\\n\\nBeats 100% of the Solution :) \\nI have successfully unlocked my clown outfit."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "lmao, thanks for the laugh"
                    },
                    {
                        "username": "szm9119",
                        "content": "divide by zero test case not considered"
                    },
                    {
                        "username": "grovre",
                        "content": "Leetcode\\'s got some balls making this one the daily"
                    }
                ]
            },
            {
                "id": 1983554,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Is there something broken about testcase 305?"
                    },
                    {
                        "username": "Shristi_uniyal",
                        "content": "return Double.parseDouble(String.format(\"%.5f\",Math.pow(x,n)));"
                    },
                    {
                        "username": "fantazer",
                        "content": "There is something abnormal. \\n\\nTime Limit Exceeded ------ 305 / 305 testcases passed ???\\nLast Executed Input\\nx = \\n\\nLiterally, x = nothing there, empty space. \\nHow is that possible? \\n \\n`double myPow(double x, int n){\\n\\n    if (x==1.0) return 1;\\n    if (x==-1){\\n        if (n%2 == 0) return 1.0;\\n        else return -1.0;\\n    }\\n    if (x>1.0 && n<-2147483647) return 0;\\n    double res = 1;\\n    int t;\\n    if (n>=0) t=n;\\n    else t=n*(-1);\\n    if (t>=0){\\n        while(t--){\\n            res*=x; \\n        }\\n    }\\n    if (n>=0)\\n    return res;\\n    return 1/res;\\n}`"
                    },
                    {
                        "username": "superplane",
                        "content": "I have done several Leetcode problems with python. In general I feel that using python, iterative solutions are generally faster than recursive ones. For some problems, recursive solutions will exceed time limit, while iterative ones will not. Does anyone have similar feeling? Is it generally true for python?"
                    },
                    {
                        "username": "the-iter8",
                        "content": "[@Dabboiiii](/Dabboiiii) Time + space"
                    },
                    {
                        "username": "Dabboiiii",
                        "content": "recursive solutions always take more time than iterative. it\\'s one of their downsides"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Exponentiation can use its binary expression to compute! \n# If you want to change sign for n, be careful! When n=-2^31, it would lead to a overflow."
                    },
                    {
                        "username": "Arpit_001",
                        "content": "Stucking at a high on weed test case\\nx= 0.000001\\nn=-2147483647 \\nhow to not get StackOverFlowError"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Use long instead of int"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Couldn\\'t pass the test case where $x =  0.999999999 and $n = -2147483648.\\nIf I var_export($x), it is 1.00000. Am I missing something or is this an issue with how leetcode runs these test cases for php?"
                    },
                    {
                        "username": "Shaybra",
                        "content": "your code should check for the maxes for the power, and then return 0 or inf"
                    },
                    {
                        "username": "TibetSoap",
                        "content": "Happening the same using C# and C++. This is really ridiculous. "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "return pow(x,n);\\n\\nBeats 100% of the Solution :) \\nI have successfully unlocked my clown outfit."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "lmao, thanks for the laugh"
                    },
                    {
                        "username": "szm9119",
                        "content": "divide by zero test case not considered"
                    },
                    {
                        "username": "grovre",
                        "content": "Leetcode\\'s got some balls making this one the daily"
                    }
                ]
            },
            {
                "id": 1984112,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Is there something broken about testcase 305?"
                    },
                    {
                        "username": "Shristi_uniyal",
                        "content": "return Double.parseDouble(String.format(\"%.5f\",Math.pow(x,n)));"
                    },
                    {
                        "username": "fantazer",
                        "content": "There is something abnormal. \\n\\nTime Limit Exceeded ------ 305 / 305 testcases passed ???\\nLast Executed Input\\nx = \\n\\nLiterally, x = nothing there, empty space. \\nHow is that possible? \\n \\n`double myPow(double x, int n){\\n\\n    if (x==1.0) return 1;\\n    if (x==-1){\\n        if (n%2 == 0) return 1.0;\\n        else return -1.0;\\n    }\\n    if (x>1.0 && n<-2147483647) return 0;\\n    double res = 1;\\n    int t;\\n    if (n>=0) t=n;\\n    else t=n*(-1);\\n    if (t>=0){\\n        while(t--){\\n            res*=x; \\n        }\\n    }\\n    if (n>=0)\\n    return res;\\n    return 1/res;\\n}`"
                    },
                    {
                        "username": "superplane",
                        "content": "I have done several Leetcode problems with python. In general I feel that using python, iterative solutions are generally faster than recursive ones. For some problems, recursive solutions will exceed time limit, while iterative ones will not. Does anyone have similar feeling? Is it generally true for python?"
                    },
                    {
                        "username": "the-iter8",
                        "content": "[@Dabboiiii](/Dabboiiii) Time + space"
                    },
                    {
                        "username": "Dabboiiii",
                        "content": "recursive solutions always take more time than iterative. it\\'s one of their downsides"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Exponentiation can use its binary expression to compute! \n# If you want to change sign for n, be careful! When n=-2^31, it would lead to a overflow."
                    },
                    {
                        "username": "Arpit_001",
                        "content": "Stucking at a high on weed test case\\nx= 0.000001\\nn=-2147483647 \\nhow to not get StackOverFlowError"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Use long instead of int"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Couldn\\'t pass the test case where $x =  0.999999999 and $n = -2147483648.\\nIf I var_export($x), it is 1.00000. Am I missing something or is this an issue with how leetcode runs these test cases for php?"
                    },
                    {
                        "username": "Shaybra",
                        "content": "your code should check for the maxes for the power, and then return 0 or inf"
                    },
                    {
                        "username": "TibetSoap",
                        "content": "Happening the same using C# and C++. This is really ridiculous. "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "return pow(x,n);\\n\\nBeats 100% of the Solution :) \\nI have successfully unlocked my clown outfit."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "lmao, thanks for the laugh"
                    },
                    {
                        "username": "szm9119",
                        "content": "divide by zero test case not considered"
                    },
                    {
                        "username": "grovre",
                        "content": "Leetcode\\'s got some balls making this one the daily"
                    }
                ]
            },
            {
                "id": 1570660,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Is there something broken about testcase 305?"
                    },
                    {
                        "username": "Shristi_uniyal",
                        "content": "return Double.parseDouble(String.format(\"%.5f\",Math.pow(x,n)));"
                    },
                    {
                        "username": "fantazer",
                        "content": "There is something abnormal. \\n\\nTime Limit Exceeded ------ 305 / 305 testcases passed ???\\nLast Executed Input\\nx = \\n\\nLiterally, x = nothing there, empty space. \\nHow is that possible? \\n \\n`double myPow(double x, int n){\\n\\n    if (x==1.0) return 1;\\n    if (x==-1){\\n        if (n%2 == 0) return 1.0;\\n        else return -1.0;\\n    }\\n    if (x>1.0 && n<-2147483647) return 0;\\n    double res = 1;\\n    int t;\\n    if (n>=0) t=n;\\n    else t=n*(-1);\\n    if (t>=0){\\n        while(t--){\\n            res*=x; \\n        }\\n    }\\n    if (n>=0)\\n    return res;\\n    return 1/res;\\n}`"
                    },
                    {
                        "username": "superplane",
                        "content": "I have done several Leetcode problems with python. In general I feel that using python, iterative solutions are generally faster than recursive ones. For some problems, recursive solutions will exceed time limit, while iterative ones will not. Does anyone have similar feeling? Is it generally true for python?"
                    },
                    {
                        "username": "the-iter8",
                        "content": "[@Dabboiiii](/Dabboiiii) Time + space"
                    },
                    {
                        "username": "Dabboiiii",
                        "content": "recursive solutions always take more time than iterative. it\\'s one of their downsides"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Exponentiation can use its binary expression to compute! \n# If you want to change sign for n, be careful! When n=-2^31, it would lead to a overflow."
                    },
                    {
                        "username": "Arpit_001",
                        "content": "Stucking at a high on weed test case\\nx= 0.000001\\nn=-2147483647 \\nhow to not get StackOverFlowError"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Use long instead of int"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Couldn\\'t pass the test case where $x =  0.999999999 and $n = -2147483648.\\nIf I var_export($x), it is 1.00000. Am I missing something or is this an issue with how leetcode runs these test cases for php?"
                    },
                    {
                        "username": "Shaybra",
                        "content": "your code should check for the maxes for the power, and then return 0 or inf"
                    },
                    {
                        "username": "TibetSoap",
                        "content": "Happening the same using C# and C++. This is really ridiculous. "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "return pow(x,n);\\n\\nBeats 100% of the Solution :) \\nI have successfully unlocked my clown outfit."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "lmao, thanks for the laugh"
                    },
                    {
                        "username": "szm9119",
                        "content": "divide by zero test case not considered"
                    },
                    {
                        "username": "grovre",
                        "content": "Leetcode\\'s got some balls making this one the daily"
                    }
                ]
            },
            {
                "id": 1984485,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Is there something broken about testcase 305?"
                    },
                    {
                        "username": "Shristi_uniyal",
                        "content": "return Double.parseDouble(String.format(\"%.5f\",Math.pow(x,n)));"
                    },
                    {
                        "username": "fantazer",
                        "content": "There is something abnormal. \\n\\nTime Limit Exceeded ------ 305 / 305 testcases passed ???\\nLast Executed Input\\nx = \\n\\nLiterally, x = nothing there, empty space. \\nHow is that possible? \\n \\n`double myPow(double x, int n){\\n\\n    if (x==1.0) return 1;\\n    if (x==-1){\\n        if (n%2 == 0) return 1.0;\\n        else return -1.0;\\n    }\\n    if (x>1.0 && n<-2147483647) return 0;\\n    double res = 1;\\n    int t;\\n    if (n>=0) t=n;\\n    else t=n*(-1);\\n    if (t>=0){\\n        while(t--){\\n            res*=x; \\n        }\\n    }\\n    if (n>=0)\\n    return res;\\n    return 1/res;\\n}`"
                    },
                    {
                        "username": "superplane",
                        "content": "I have done several Leetcode problems with python. In general I feel that using python, iterative solutions are generally faster than recursive ones. For some problems, recursive solutions will exceed time limit, while iterative ones will not. Does anyone have similar feeling? Is it generally true for python?"
                    },
                    {
                        "username": "the-iter8",
                        "content": "[@Dabboiiii](/Dabboiiii) Time + space"
                    },
                    {
                        "username": "Dabboiiii",
                        "content": "recursive solutions always take more time than iterative. it\\'s one of their downsides"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Exponentiation can use its binary expression to compute! \n# If you want to change sign for n, be careful! When n=-2^31, it would lead to a overflow."
                    },
                    {
                        "username": "Arpit_001",
                        "content": "Stucking at a high on weed test case\\nx= 0.000001\\nn=-2147483647 \\nhow to not get StackOverFlowError"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Use long instead of int"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Couldn\\'t pass the test case where $x =  0.999999999 and $n = -2147483648.\\nIf I var_export($x), it is 1.00000. Am I missing something or is this an issue with how leetcode runs these test cases for php?"
                    },
                    {
                        "username": "Shaybra",
                        "content": "your code should check for the maxes for the power, and then return 0 or inf"
                    },
                    {
                        "username": "TibetSoap",
                        "content": "Happening the same using C# and C++. This is really ridiculous. "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "return pow(x,n);\\n\\nBeats 100% of the Solution :) \\nI have successfully unlocked my clown outfit."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "lmao, thanks for the laugh"
                    },
                    {
                        "username": "szm9119",
                        "content": "divide by zero test case not considered"
                    },
                    {
                        "username": "grovre",
                        "content": "Leetcode\\'s got some balls making this one the daily"
                    }
                ]
            },
            {
                "id": 1568875,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Is there something broken about testcase 305?"
                    },
                    {
                        "username": "Shristi_uniyal",
                        "content": "return Double.parseDouble(String.format(\"%.5f\",Math.pow(x,n)));"
                    },
                    {
                        "username": "fantazer",
                        "content": "There is something abnormal. \\n\\nTime Limit Exceeded ------ 305 / 305 testcases passed ???\\nLast Executed Input\\nx = \\n\\nLiterally, x = nothing there, empty space. \\nHow is that possible? \\n \\n`double myPow(double x, int n){\\n\\n    if (x==1.0) return 1;\\n    if (x==-1){\\n        if (n%2 == 0) return 1.0;\\n        else return -1.0;\\n    }\\n    if (x>1.0 && n<-2147483647) return 0;\\n    double res = 1;\\n    int t;\\n    if (n>=0) t=n;\\n    else t=n*(-1);\\n    if (t>=0){\\n        while(t--){\\n            res*=x; \\n        }\\n    }\\n    if (n>=0)\\n    return res;\\n    return 1/res;\\n}`"
                    },
                    {
                        "username": "superplane",
                        "content": "I have done several Leetcode problems with python. In general I feel that using python, iterative solutions are generally faster than recursive ones. For some problems, recursive solutions will exceed time limit, while iterative ones will not. Does anyone have similar feeling? Is it generally true for python?"
                    },
                    {
                        "username": "the-iter8",
                        "content": "[@Dabboiiii](/Dabboiiii) Time + space"
                    },
                    {
                        "username": "Dabboiiii",
                        "content": "recursive solutions always take more time than iterative. it\\'s one of their downsides"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Exponentiation can use its binary expression to compute! \n# If you want to change sign for n, be careful! When n=-2^31, it would lead to a overflow."
                    },
                    {
                        "username": "Arpit_001",
                        "content": "Stucking at a high on weed test case\\nx= 0.000001\\nn=-2147483647 \\nhow to not get StackOverFlowError"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Use long instead of int"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Couldn\\'t pass the test case where $x =  0.999999999 and $n = -2147483648.\\nIf I var_export($x), it is 1.00000. Am I missing something or is this an issue with how leetcode runs these test cases for php?"
                    },
                    {
                        "username": "Shaybra",
                        "content": "your code should check for the maxes for the power, and then return 0 or inf"
                    },
                    {
                        "username": "TibetSoap",
                        "content": "Happening the same using C# and C++. This is really ridiculous. "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "return pow(x,n);\\n\\nBeats 100% of the Solution :) \\nI have successfully unlocked my clown outfit."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "lmao, thanks for the laugh"
                    },
                    {
                        "username": "szm9119",
                        "content": "divide by zero test case not considered"
                    },
                    {
                        "username": "grovre",
                        "content": "Leetcode\\'s got some balls making this one the daily"
                    }
                ]
            },
            {
                "id": 1983973,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Is there something broken about testcase 305?"
                    },
                    {
                        "username": "Shristi_uniyal",
                        "content": "return Double.parseDouble(String.format(\"%.5f\",Math.pow(x,n)));"
                    },
                    {
                        "username": "fantazer",
                        "content": "There is something abnormal. \\n\\nTime Limit Exceeded ------ 305 / 305 testcases passed ???\\nLast Executed Input\\nx = \\n\\nLiterally, x = nothing there, empty space. \\nHow is that possible? \\n \\n`double myPow(double x, int n){\\n\\n    if (x==1.0) return 1;\\n    if (x==-1){\\n        if (n%2 == 0) return 1.0;\\n        else return -1.0;\\n    }\\n    if (x>1.0 && n<-2147483647) return 0;\\n    double res = 1;\\n    int t;\\n    if (n>=0) t=n;\\n    else t=n*(-1);\\n    if (t>=0){\\n        while(t--){\\n            res*=x; \\n        }\\n    }\\n    if (n>=0)\\n    return res;\\n    return 1/res;\\n}`"
                    },
                    {
                        "username": "superplane",
                        "content": "I have done several Leetcode problems with python. In general I feel that using python, iterative solutions are generally faster than recursive ones. For some problems, recursive solutions will exceed time limit, while iterative ones will not. Does anyone have similar feeling? Is it generally true for python?"
                    },
                    {
                        "username": "the-iter8",
                        "content": "[@Dabboiiii](/Dabboiiii) Time + space"
                    },
                    {
                        "username": "Dabboiiii",
                        "content": "recursive solutions always take more time than iterative. it\\'s one of their downsides"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Exponentiation can use its binary expression to compute! \n# If you want to change sign for n, be careful! When n=-2^31, it would lead to a overflow."
                    },
                    {
                        "username": "Arpit_001",
                        "content": "Stucking at a high on weed test case\\nx= 0.000001\\nn=-2147483647 \\nhow to not get StackOverFlowError"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Use long instead of int"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Couldn\\'t pass the test case where $x =  0.999999999 and $n = -2147483648.\\nIf I var_export($x), it is 1.00000. Am I missing something or is this an issue with how leetcode runs these test cases for php?"
                    },
                    {
                        "username": "Shaybra",
                        "content": "your code should check for the maxes for the power, and then return 0 or inf"
                    },
                    {
                        "username": "TibetSoap",
                        "content": "Happening the same using C# and C++. This is really ridiculous. "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "return pow(x,n);\\n\\nBeats 100% of the Solution :) \\nI have successfully unlocked my clown outfit."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "lmao, thanks for the laugh"
                    },
                    {
                        "username": "szm9119",
                        "content": "divide by zero test case not considered"
                    },
                    {
                        "username": "grovre",
                        "content": "Leetcode\\'s got some balls making this one the daily"
                    }
                ]
            },
            {
                "id": 1748280,
                "content": [
                    {
                        "username": "tomereli",
                        "content": "I\\'m keeping getting Time limit exceeded to a simple brut force implementation not different than the one in the official solution. Any idea why??\\n```\\n    def myPow(self, x: float, n: int) -> float:\\n        result = 1\\n        for i in range(abs(n)):\\n            result *= x\\n        return result if n > 0 else 1/result\\n```"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "[@GodOfm4a1](/GodOfm4a1) Yes, you are right. we can set the base cases and do this recursively."
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "[@abdulmoomin007](/abdulmoomin007) So we store the results of x^2 , x^4 .... like that, and then build the intended answer?\\n"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "[@YaJohny](/YaJohny) Here\\'s a hint.\\nx*x = x^2, \\nx^2 * x^2 = x^4, \\nx^4*x^4 = x^8\\n....\\nfor x^2147483648, instead of multiplying x with x 2147483648 times, you have to cut down the logic by divide and conquer."
                    },
                    {
                        "username": "YaJohny",
                        "content": "[@abdulmoomin007](/abdulmoomin007) Do you know how to fix that?"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "One of the constraints for n is -2^31 <= n <= 2^31-1. 2^31 is 2147483648. running for loop a billion times would give TLE always."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I have already solved this question the last month. But now when I am re-submitting my old solution, it\\'s showing _wrong answer_ for certain test cases. It looks like that they have updated and added some new test cases."
                    },
                    {
                        "username": "oops_moment",
                        "content": "LOL WHEN I AM WRITING THIS , WHAT IS SEE IS 8.1K UPVOTES AND 8.1 K DOWNVOTES LOL, but we will do it lesss gooo \\uD83E\\uDD13\\uD83E\\uDD13\\n\\n\\uD83E\\uDD14 We know that naively multiplying x by itself n times would surely lead to a Time Limit Exceeded (TLE) error for larger values of n.\\n\\n\\uD83C\\uDF1F Consider an example, let\\'s find 2^4. Instead of multiplying 2 four times, why not do 2 * 2 raised to power 2? Yes! If n is even, just divide n by 2 (n/=2), and square x (x*=x) in each step.\\n\\n\\uD83E\\uDD37\\u200D\\u2642\\uFE0F But what if n is odd, say 2^3? To handle this, we convert it into an even-powered case. We multiply the finalAns by x to account for the extra power, and then you remain with 2^2, which we handle similarly as we do for positive cases.\\n\\n\\uD83E\\uDD13 Now, here\\'s a question for you! Which special case do you need to handle? If the absolute value of n is INT_MIN, you might try to make it positive by -1. But be cautious! This will exceed the int limit. To address this, we use one more long long variable called temp and perform the operation on it.\\n\\nWith this approach, we can efficiently calculate the power of x raised to n without facing any TLE issues. Keep practicing and happy coding! \\uD83D\\uDE04\\uD83D\\uDC4D\\n"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Couldnt pass this testcase \\nthis is a TLE..!\\nx =\\n2.00000\\nn =\\n-2147483648"
                    },
                    {
                        "username": "Prajjal",
                        "content": "[@ashuranjan003](/ashuranjan003) End the loop immediately when it becomes zero\\n"
                    },
                    {
                        "username": "Prajjal",
                        "content": "End the loop immediately when it becomes zero\\n"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "same happens to me \\uD83D\\uDE05"
                    },
                    {
                        "username": "vintiduggar26",
                        "content": "my code is satisfying all the test cases. but when i am trying to submit the code it is showing me this error\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffe2acafff8 (pc 0x000000343a4b bp 0x7ffe2acb0010 sp 0x7ffe2acb0000 T0)\\n==34==ABORTING"
                    },
                    {
                        "username": "Deepanshu_Chhillar",
                        "content": "This error means either you are  variable is trying to store more value than allocated, basically you can say its stackoverflow. \\n\\nDo check that you are returning zero if variable is exceeding the value.\\n\\nFor eg:\\ndouble p=1;\\n if(p>DBL_MAX)\\n          {\\n              return 0;\\n          }\\n        }"
                    },
                    {
                        "username": "lavankumarganji",
                        "content": "are you check ing all the edg cases ?\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "a \"medium\" problem that lets use the pow function?! please add more checks."
                    },
                    {
                        "username": "eduard92",
                        "content": "checks are done at the interview... Like they give you this problem and you have the audacity to write `Math.Pow` and not knowing any other solution."
                    },
                    {
                        "username": "nitin_leetcode",
                        "content": "When I submit the solution, it runs into stackoverflow exception with the inputs:\\nx: 1.00001 \\nn: 123456\\nBut when I run my code for this input, it runs successfully returning the correct answer.\\n"
                    },
                    {
                        "username": "anujpachauri",
                        "content": "return Math.pow(x, n);"
                    },
                    {
                        "username": "kaviyacute",
                        "content": "return pow(x,n);\\n One line answer and is 100% efficient"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "In C++:\\n```C++\\nclass Solution {\\npublic:\\n    double myPow(double x, int n_) {\\n        long long n = n_;\\n        if(n == 0) return 1.0;\\n        if(n < 0)\\n        {\\n            n = -n;\\n            x = 1./x;\\n        }\\n        double res = x;\\n        while(n > 1)\\n        {\\n            res *= res;\\n            res = n % 2 == 0 ? res : res * x;\\n            n >>= 1;\\n        }\\n        return res;\\n    }\\n};\\n```\\nReturns 0.00000 with x = 8.84372 and n = -5 for some reason, and I cannot figure out why. Any help?"
                    }
                ]
            },
            {
                "id": 1984370,
                "content": [
                    {
                        "username": "tomereli",
                        "content": "I\\'m keeping getting Time limit exceeded to a simple brut force implementation not different than the one in the official solution. Any idea why??\\n```\\n    def myPow(self, x: float, n: int) -> float:\\n        result = 1\\n        for i in range(abs(n)):\\n            result *= x\\n        return result if n > 0 else 1/result\\n```"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "[@GodOfm4a1](/GodOfm4a1) Yes, you are right. we can set the base cases and do this recursively."
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "[@abdulmoomin007](/abdulmoomin007) So we store the results of x^2 , x^4 .... like that, and then build the intended answer?\\n"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "[@YaJohny](/YaJohny) Here\\'s a hint.\\nx*x = x^2, \\nx^2 * x^2 = x^4, \\nx^4*x^4 = x^8\\n....\\nfor x^2147483648, instead of multiplying x with x 2147483648 times, you have to cut down the logic by divide and conquer."
                    },
                    {
                        "username": "YaJohny",
                        "content": "[@abdulmoomin007](/abdulmoomin007) Do you know how to fix that?"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "One of the constraints for n is -2^31 <= n <= 2^31-1. 2^31 is 2147483648. running for loop a billion times would give TLE always."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I have already solved this question the last month. But now when I am re-submitting my old solution, it\\'s showing _wrong answer_ for certain test cases. It looks like that they have updated and added some new test cases."
                    },
                    {
                        "username": "oops_moment",
                        "content": "LOL WHEN I AM WRITING THIS , WHAT IS SEE IS 8.1K UPVOTES AND 8.1 K DOWNVOTES LOL, but we will do it lesss gooo \\uD83E\\uDD13\\uD83E\\uDD13\\n\\n\\uD83E\\uDD14 We know that naively multiplying x by itself n times would surely lead to a Time Limit Exceeded (TLE) error for larger values of n.\\n\\n\\uD83C\\uDF1F Consider an example, let\\'s find 2^4. Instead of multiplying 2 four times, why not do 2 * 2 raised to power 2? Yes! If n is even, just divide n by 2 (n/=2), and square x (x*=x) in each step.\\n\\n\\uD83E\\uDD37\\u200D\\u2642\\uFE0F But what if n is odd, say 2^3? To handle this, we convert it into an even-powered case. We multiply the finalAns by x to account for the extra power, and then you remain with 2^2, which we handle similarly as we do for positive cases.\\n\\n\\uD83E\\uDD13 Now, here\\'s a question for you! Which special case do you need to handle? If the absolute value of n is INT_MIN, you might try to make it positive by -1. But be cautious! This will exceed the int limit. To address this, we use one more long long variable called temp and perform the operation on it.\\n\\nWith this approach, we can efficiently calculate the power of x raised to n without facing any TLE issues. Keep practicing and happy coding! \\uD83D\\uDE04\\uD83D\\uDC4D\\n"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Couldnt pass this testcase \\nthis is a TLE..!\\nx =\\n2.00000\\nn =\\n-2147483648"
                    },
                    {
                        "username": "Prajjal",
                        "content": "[@ashuranjan003](/ashuranjan003) End the loop immediately when it becomes zero\\n"
                    },
                    {
                        "username": "Prajjal",
                        "content": "End the loop immediately when it becomes zero\\n"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "same happens to me \\uD83D\\uDE05"
                    },
                    {
                        "username": "vintiduggar26",
                        "content": "my code is satisfying all the test cases. but when i am trying to submit the code it is showing me this error\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffe2acafff8 (pc 0x000000343a4b bp 0x7ffe2acb0010 sp 0x7ffe2acb0000 T0)\\n==34==ABORTING"
                    },
                    {
                        "username": "Deepanshu_Chhillar",
                        "content": "This error means either you are  variable is trying to store more value than allocated, basically you can say its stackoverflow. \\n\\nDo check that you are returning zero if variable is exceeding the value.\\n\\nFor eg:\\ndouble p=1;\\n if(p>DBL_MAX)\\n          {\\n              return 0;\\n          }\\n        }"
                    },
                    {
                        "username": "lavankumarganji",
                        "content": "are you check ing all the edg cases ?\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "a \"medium\" problem that lets use the pow function?! please add more checks."
                    },
                    {
                        "username": "eduard92",
                        "content": "checks are done at the interview... Like they give you this problem and you have the audacity to write `Math.Pow` and not knowing any other solution."
                    },
                    {
                        "username": "nitin_leetcode",
                        "content": "When I submit the solution, it runs into stackoverflow exception with the inputs:\\nx: 1.00001 \\nn: 123456\\nBut when I run my code for this input, it runs successfully returning the correct answer.\\n"
                    },
                    {
                        "username": "anujpachauri",
                        "content": "return Math.pow(x, n);"
                    },
                    {
                        "username": "kaviyacute",
                        "content": "return pow(x,n);\\n One line answer and is 100% efficient"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "In C++:\\n```C++\\nclass Solution {\\npublic:\\n    double myPow(double x, int n_) {\\n        long long n = n_;\\n        if(n == 0) return 1.0;\\n        if(n < 0)\\n        {\\n            n = -n;\\n            x = 1./x;\\n        }\\n        double res = x;\\n        while(n > 1)\\n        {\\n            res *= res;\\n            res = n % 2 == 0 ? res : res * x;\\n            n >>= 1;\\n        }\\n        return res;\\n    }\\n};\\n```\\nReturns 0.00000 with x = 8.84372 and n = -5 for some reason, and I cannot figure out why. Any help?"
                    }
                ]
            },
            {
                "id": 1984294,
                "content": [
                    {
                        "username": "tomereli",
                        "content": "I\\'m keeping getting Time limit exceeded to a simple brut force implementation not different than the one in the official solution. Any idea why??\\n```\\n    def myPow(self, x: float, n: int) -> float:\\n        result = 1\\n        for i in range(abs(n)):\\n            result *= x\\n        return result if n > 0 else 1/result\\n```"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "[@GodOfm4a1](/GodOfm4a1) Yes, you are right. we can set the base cases and do this recursively."
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "[@abdulmoomin007](/abdulmoomin007) So we store the results of x^2 , x^4 .... like that, and then build the intended answer?\\n"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "[@YaJohny](/YaJohny) Here\\'s a hint.\\nx*x = x^2, \\nx^2 * x^2 = x^4, \\nx^4*x^4 = x^8\\n....\\nfor x^2147483648, instead of multiplying x with x 2147483648 times, you have to cut down the logic by divide and conquer."
                    },
                    {
                        "username": "YaJohny",
                        "content": "[@abdulmoomin007](/abdulmoomin007) Do you know how to fix that?"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "One of the constraints for n is -2^31 <= n <= 2^31-1. 2^31 is 2147483648. running for loop a billion times would give TLE always."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I have already solved this question the last month. But now when I am re-submitting my old solution, it\\'s showing _wrong answer_ for certain test cases. It looks like that they have updated and added some new test cases."
                    },
                    {
                        "username": "oops_moment",
                        "content": "LOL WHEN I AM WRITING THIS , WHAT IS SEE IS 8.1K UPVOTES AND 8.1 K DOWNVOTES LOL, but we will do it lesss gooo \\uD83E\\uDD13\\uD83E\\uDD13\\n\\n\\uD83E\\uDD14 We know that naively multiplying x by itself n times would surely lead to a Time Limit Exceeded (TLE) error for larger values of n.\\n\\n\\uD83C\\uDF1F Consider an example, let\\'s find 2^4. Instead of multiplying 2 four times, why not do 2 * 2 raised to power 2? Yes! If n is even, just divide n by 2 (n/=2), and square x (x*=x) in each step.\\n\\n\\uD83E\\uDD37\\u200D\\u2642\\uFE0F But what if n is odd, say 2^3? To handle this, we convert it into an even-powered case. We multiply the finalAns by x to account for the extra power, and then you remain with 2^2, which we handle similarly as we do for positive cases.\\n\\n\\uD83E\\uDD13 Now, here\\'s a question for you! Which special case do you need to handle? If the absolute value of n is INT_MIN, you might try to make it positive by -1. But be cautious! This will exceed the int limit. To address this, we use one more long long variable called temp and perform the operation on it.\\n\\nWith this approach, we can efficiently calculate the power of x raised to n without facing any TLE issues. Keep practicing and happy coding! \\uD83D\\uDE04\\uD83D\\uDC4D\\n"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Couldnt pass this testcase \\nthis is a TLE..!\\nx =\\n2.00000\\nn =\\n-2147483648"
                    },
                    {
                        "username": "Prajjal",
                        "content": "[@ashuranjan003](/ashuranjan003) End the loop immediately when it becomes zero\\n"
                    },
                    {
                        "username": "Prajjal",
                        "content": "End the loop immediately when it becomes zero\\n"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "same happens to me \\uD83D\\uDE05"
                    },
                    {
                        "username": "vintiduggar26",
                        "content": "my code is satisfying all the test cases. but when i am trying to submit the code it is showing me this error\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffe2acafff8 (pc 0x000000343a4b bp 0x7ffe2acb0010 sp 0x7ffe2acb0000 T0)\\n==34==ABORTING"
                    },
                    {
                        "username": "Deepanshu_Chhillar",
                        "content": "This error means either you are  variable is trying to store more value than allocated, basically you can say its stackoverflow. \\n\\nDo check that you are returning zero if variable is exceeding the value.\\n\\nFor eg:\\ndouble p=1;\\n if(p>DBL_MAX)\\n          {\\n              return 0;\\n          }\\n        }"
                    },
                    {
                        "username": "lavankumarganji",
                        "content": "are you check ing all the edg cases ?\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "a \"medium\" problem that lets use the pow function?! please add more checks."
                    },
                    {
                        "username": "eduard92",
                        "content": "checks are done at the interview... Like they give you this problem and you have the audacity to write `Math.Pow` and not knowing any other solution."
                    },
                    {
                        "username": "nitin_leetcode",
                        "content": "When I submit the solution, it runs into stackoverflow exception with the inputs:\\nx: 1.00001 \\nn: 123456\\nBut when I run my code for this input, it runs successfully returning the correct answer.\\n"
                    },
                    {
                        "username": "anujpachauri",
                        "content": "return Math.pow(x, n);"
                    },
                    {
                        "username": "kaviyacute",
                        "content": "return pow(x,n);\\n One line answer and is 100% efficient"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "In C++:\\n```C++\\nclass Solution {\\npublic:\\n    double myPow(double x, int n_) {\\n        long long n = n_;\\n        if(n == 0) return 1.0;\\n        if(n < 0)\\n        {\\n            n = -n;\\n            x = 1./x;\\n        }\\n        double res = x;\\n        while(n > 1)\\n        {\\n            res *= res;\\n            res = n % 2 == 0 ? res : res * x;\\n            n >>= 1;\\n        }\\n        return res;\\n    }\\n};\\n```\\nReturns 0.00000 with x = 8.84372 and n = -5 for some reason, and I cannot figure out why. Any help?"
                    }
                ]
            },
            {
                "id": 1832314,
                "content": [
                    {
                        "username": "tomereli",
                        "content": "I\\'m keeping getting Time limit exceeded to a simple brut force implementation not different than the one in the official solution. Any idea why??\\n```\\n    def myPow(self, x: float, n: int) -> float:\\n        result = 1\\n        for i in range(abs(n)):\\n            result *= x\\n        return result if n > 0 else 1/result\\n```"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "[@GodOfm4a1](/GodOfm4a1) Yes, you are right. we can set the base cases and do this recursively."
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "[@abdulmoomin007](/abdulmoomin007) So we store the results of x^2 , x^4 .... like that, and then build the intended answer?\\n"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "[@YaJohny](/YaJohny) Here\\'s a hint.\\nx*x = x^2, \\nx^2 * x^2 = x^4, \\nx^4*x^4 = x^8\\n....\\nfor x^2147483648, instead of multiplying x with x 2147483648 times, you have to cut down the logic by divide and conquer."
                    },
                    {
                        "username": "YaJohny",
                        "content": "[@abdulmoomin007](/abdulmoomin007) Do you know how to fix that?"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "One of the constraints for n is -2^31 <= n <= 2^31-1. 2^31 is 2147483648. running for loop a billion times would give TLE always."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I have already solved this question the last month. But now when I am re-submitting my old solution, it\\'s showing _wrong answer_ for certain test cases. It looks like that they have updated and added some new test cases."
                    },
                    {
                        "username": "oops_moment",
                        "content": "LOL WHEN I AM WRITING THIS , WHAT IS SEE IS 8.1K UPVOTES AND 8.1 K DOWNVOTES LOL, but we will do it lesss gooo \\uD83E\\uDD13\\uD83E\\uDD13\\n\\n\\uD83E\\uDD14 We know that naively multiplying x by itself n times would surely lead to a Time Limit Exceeded (TLE) error for larger values of n.\\n\\n\\uD83C\\uDF1F Consider an example, let\\'s find 2^4. Instead of multiplying 2 four times, why not do 2 * 2 raised to power 2? Yes! If n is even, just divide n by 2 (n/=2), and square x (x*=x) in each step.\\n\\n\\uD83E\\uDD37\\u200D\\u2642\\uFE0F But what if n is odd, say 2^3? To handle this, we convert it into an even-powered case. We multiply the finalAns by x to account for the extra power, and then you remain with 2^2, which we handle similarly as we do for positive cases.\\n\\n\\uD83E\\uDD13 Now, here\\'s a question for you! Which special case do you need to handle? If the absolute value of n is INT_MIN, you might try to make it positive by -1. But be cautious! This will exceed the int limit. To address this, we use one more long long variable called temp and perform the operation on it.\\n\\nWith this approach, we can efficiently calculate the power of x raised to n without facing any TLE issues. Keep practicing and happy coding! \\uD83D\\uDE04\\uD83D\\uDC4D\\n"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Couldnt pass this testcase \\nthis is a TLE..!\\nx =\\n2.00000\\nn =\\n-2147483648"
                    },
                    {
                        "username": "Prajjal",
                        "content": "[@ashuranjan003](/ashuranjan003) End the loop immediately when it becomes zero\\n"
                    },
                    {
                        "username": "Prajjal",
                        "content": "End the loop immediately when it becomes zero\\n"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "same happens to me \\uD83D\\uDE05"
                    },
                    {
                        "username": "vintiduggar26",
                        "content": "my code is satisfying all the test cases. but when i am trying to submit the code it is showing me this error\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffe2acafff8 (pc 0x000000343a4b bp 0x7ffe2acb0010 sp 0x7ffe2acb0000 T0)\\n==34==ABORTING"
                    },
                    {
                        "username": "Deepanshu_Chhillar",
                        "content": "This error means either you are  variable is trying to store more value than allocated, basically you can say its stackoverflow. \\n\\nDo check that you are returning zero if variable is exceeding the value.\\n\\nFor eg:\\ndouble p=1;\\n if(p>DBL_MAX)\\n          {\\n              return 0;\\n          }\\n        }"
                    },
                    {
                        "username": "lavankumarganji",
                        "content": "are you check ing all the edg cases ?\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "a \"medium\" problem that lets use the pow function?! please add more checks."
                    },
                    {
                        "username": "eduard92",
                        "content": "checks are done at the interview... Like they give you this problem and you have the audacity to write `Math.Pow` and not knowing any other solution."
                    },
                    {
                        "username": "nitin_leetcode",
                        "content": "When I submit the solution, it runs into stackoverflow exception with the inputs:\\nx: 1.00001 \\nn: 123456\\nBut when I run my code for this input, it runs successfully returning the correct answer.\\n"
                    },
                    {
                        "username": "anujpachauri",
                        "content": "return Math.pow(x, n);"
                    },
                    {
                        "username": "kaviyacute",
                        "content": "return pow(x,n);\\n One line answer and is 100% efficient"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "In C++:\\n```C++\\nclass Solution {\\npublic:\\n    double myPow(double x, int n_) {\\n        long long n = n_;\\n        if(n == 0) return 1.0;\\n        if(n < 0)\\n        {\\n            n = -n;\\n            x = 1./x;\\n        }\\n        double res = x;\\n        while(n > 1)\\n        {\\n            res *= res;\\n            res = n % 2 == 0 ? res : res * x;\\n            n >>= 1;\\n        }\\n        return res;\\n    }\\n};\\n```\\nReturns 0.00000 with x = 8.84372 and n = -5 for some reason, and I cannot figure out why. Any help?"
                    }
                ]
            },
            {
                "id": 1790418,
                "content": [
                    {
                        "username": "tomereli",
                        "content": "I\\'m keeping getting Time limit exceeded to a simple brut force implementation not different than the one in the official solution. Any idea why??\\n```\\n    def myPow(self, x: float, n: int) -> float:\\n        result = 1\\n        for i in range(abs(n)):\\n            result *= x\\n        return result if n > 0 else 1/result\\n```"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "[@GodOfm4a1](/GodOfm4a1) Yes, you are right. we can set the base cases and do this recursively."
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "[@abdulmoomin007](/abdulmoomin007) So we store the results of x^2 , x^4 .... like that, and then build the intended answer?\\n"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "[@YaJohny](/YaJohny) Here\\'s a hint.\\nx*x = x^2, \\nx^2 * x^2 = x^4, \\nx^4*x^4 = x^8\\n....\\nfor x^2147483648, instead of multiplying x with x 2147483648 times, you have to cut down the logic by divide and conquer."
                    },
                    {
                        "username": "YaJohny",
                        "content": "[@abdulmoomin007](/abdulmoomin007) Do you know how to fix that?"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "One of the constraints for n is -2^31 <= n <= 2^31-1. 2^31 is 2147483648. running for loop a billion times would give TLE always."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I have already solved this question the last month. But now when I am re-submitting my old solution, it\\'s showing _wrong answer_ for certain test cases. It looks like that they have updated and added some new test cases."
                    },
                    {
                        "username": "oops_moment",
                        "content": "LOL WHEN I AM WRITING THIS , WHAT IS SEE IS 8.1K UPVOTES AND 8.1 K DOWNVOTES LOL, but we will do it lesss gooo \\uD83E\\uDD13\\uD83E\\uDD13\\n\\n\\uD83E\\uDD14 We know that naively multiplying x by itself n times would surely lead to a Time Limit Exceeded (TLE) error for larger values of n.\\n\\n\\uD83C\\uDF1F Consider an example, let\\'s find 2^4. Instead of multiplying 2 four times, why not do 2 * 2 raised to power 2? Yes! If n is even, just divide n by 2 (n/=2), and square x (x*=x) in each step.\\n\\n\\uD83E\\uDD37\\u200D\\u2642\\uFE0F But what if n is odd, say 2^3? To handle this, we convert it into an even-powered case. We multiply the finalAns by x to account for the extra power, and then you remain with 2^2, which we handle similarly as we do for positive cases.\\n\\n\\uD83E\\uDD13 Now, here\\'s a question for you! Which special case do you need to handle? If the absolute value of n is INT_MIN, you might try to make it positive by -1. But be cautious! This will exceed the int limit. To address this, we use one more long long variable called temp and perform the operation on it.\\n\\nWith this approach, we can efficiently calculate the power of x raised to n without facing any TLE issues. Keep practicing and happy coding! \\uD83D\\uDE04\\uD83D\\uDC4D\\n"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Couldnt pass this testcase \\nthis is a TLE..!\\nx =\\n2.00000\\nn =\\n-2147483648"
                    },
                    {
                        "username": "Prajjal",
                        "content": "[@ashuranjan003](/ashuranjan003) End the loop immediately when it becomes zero\\n"
                    },
                    {
                        "username": "Prajjal",
                        "content": "End the loop immediately when it becomes zero\\n"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "same happens to me \\uD83D\\uDE05"
                    },
                    {
                        "username": "vintiduggar26",
                        "content": "my code is satisfying all the test cases. but when i am trying to submit the code it is showing me this error\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffe2acafff8 (pc 0x000000343a4b bp 0x7ffe2acb0010 sp 0x7ffe2acb0000 T0)\\n==34==ABORTING"
                    },
                    {
                        "username": "Deepanshu_Chhillar",
                        "content": "This error means either you are  variable is trying to store more value than allocated, basically you can say its stackoverflow. \\n\\nDo check that you are returning zero if variable is exceeding the value.\\n\\nFor eg:\\ndouble p=1;\\n if(p>DBL_MAX)\\n          {\\n              return 0;\\n          }\\n        }"
                    },
                    {
                        "username": "lavankumarganji",
                        "content": "are you check ing all the edg cases ?\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "a \"medium\" problem that lets use the pow function?! please add more checks."
                    },
                    {
                        "username": "eduard92",
                        "content": "checks are done at the interview... Like they give you this problem and you have the audacity to write `Math.Pow` and not knowing any other solution."
                    },
                    {
                        "username": "nitin_leetcode",
                        "content": "When I submit the solution, it runs into stackoverflow exception with the inputs:\\nx: 1.00001 \\nn: 123456\\nBut when I run my code for this input, it runs successfully returning the correct answer.\\n"
                    },
                    {
                        "username": "anujpachauri",
                        "content": "return Math.pow(x, n);"
                    },
                    {
                        "username": "kaviyacute",
                        "content": "return pow(x,n);\\n One line answer and is 100% efficient"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "In C++:\\n```C++\\nclass Solution {\\npublic:\\n    double myPow(double x, int n_) {\\n        long long n = n_;\\n        if(n == 0) return 1.0;\\n        if(n < 0)\\n        {\\n            n = -n;\\n            x = 1./x;\\n        }\\n        double res = x;\\n        while(n > 1)\\n        {\\n            res *= res;\\n            res = n % 2 == 0 ? res : res * x;\\n            n >>= 1;\\n        }\\n        return res;\\n    }\\n};\\n```\\nReturns 0.00000 with x = 8.84372 and n = -5 for some reason, and I cannot figure out why. Any help?"
                    }
                ]
            },
            {
                "id": 1781278,
                "content": [
                    {
                        "username": "tomereli",
                        "content": "I\\'m keeping getting Time limit exceeded to a simple brut force implementation not different than the one in the official solution. Any idea why??\\n```\\n    def myPow(self, x: float, n: int) -> float:\\n        result = 1\\n        for i in range(abs(n)):\\n            result *= x\\n        return result if n > 0 else 1/result\\n```"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "[@GodOfm4a1](/GodOfm4a1) Yes, you are right. we can set the base cases and do this recursively."
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "[@abdulmoomin007](/abdulmoomin007) So we store the results of x^2 , x^4 .... like that, and then build the intended answer?\\n"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "[@YaJohny](/YaJohny) Here\\'s a hint.\\nx*x = x^2, \\nx^2 * x^2 = x^4, \\nx^4*x^4 = x^8\\n....\\nfor x^2147483648, instead of multiplying x with x 2147483648 times, you have to cut down the logic by divide and conquer."
                    },
                    {
                        "username": "YaJohny",
                        "content": "[@abdulmoomin007](/abdulmoomin007) Do you know how to fix that?"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "One of the constraints for n is -2^31 <= n <= 2^31-1. 2^31 is 2147483648. running for loop a billion times would give TLE always."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I have already solved this question the last month. But now when I am re-submitting my old solution, it\\'s showing _wrong answer_ for certain test cases. It looks like that they have updated and added some new test cases."
                    },
                    {
                        "username": "oops_moment",
                        "content": "LOL WHEN I AM WRITING THIS , WHAT IS SEE IS 8.1K UPVOTES AND 8.1 K DOWNVOTES LOL, but we will do it lesss gooo \\uD83E\\uDD13\\uD83E\\uDD13\\n\\n\\uD83E\\uDD14 We know that naively multiplying x by itself n times would surely lead to a Time Limit Exceeded (TLE) error for larger values of n.\\n\\n\\uD83C\\uDF1F Consider an example, let\\'s find 2^4. Instead of multiplying 2 four times, why not do 2 * 2 raised to power 2? Yes! If n is even, just divide n by 2 (n/=2), and square x (x*=x) in each step.\\n\\n\\uD83E\\uDD37\\u200D\\u2642\\uFE0F But what if n is odd, say 2^3? To handle this, we convert it into an even-powered case. We multiply the finalAns by x to account for the extra power, and then you remain with 2^2, which we handle similarly as we do for positive cases.\\n\\n\\uD83E\\uDD13 Now, here\\'s a question for you! Which special case do you need to handle? If the absolute value of n is INT_MIN, you might try to make it positive by -1. But be cautious! This will exceed the int limit. To address this, we use one more long long variable called temp and perform the operation on it.\\n\\nWith this approach, we can efficiently calculate the power of x raised to n without facing any TLE issues. Keep practicing and happy coding! \\uD83D\\uDE04\\uD83D\\uDC4D\\n"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Couldnt pass this testcase \\nthis is a TLE..!\\nx =\\n2.00000\\nn =\\n-2147483648"
                    },
                    {
                        "username": "Prajjal",
                        "content": "[@ashuranjan003](/ashuranjan003) End the loop immediately when it becomes zero\\n"
                    },
                    {
                        "username": "Prajjal",
                        "content": "End the loop immediately when it becomes zero\\n"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "same happens to me \\uD83D\\uDE05"
                    },
                    {
                        "username": "vintiduggar26",
                        "content": "my code is satisfying all the test cases. but when i am trying to submit the code it is showing me this error\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffe2acafff8 (pc 0x000000343a4b bp 0x7ffe2acb0010 sp 0x7ffe2acb0000 T0)\\n==34==ABORTING"
                    },
                    {
                        "username": "Deepanshu_Chhillar",
                        "content": "This error means either you are  variable is trying to store more value than allocated, basically you can say its stackoverflow. \\n\\nDo check that you are returning zero if variable is exceeding the value.\\n\\nFor eg:\\ndouble p=1;\\n if(p>DBL_MAX)\\n          {\\n              return 0;\\n          }\\n        }"
                    },
                    {
                        "username": "lavankumarganji",
                        "content": "are you check ing all the edg cases ?\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "a \"medium\" problem that lets use the pow function?! please add more checks."
                    },
                    {
                        "username": "eduard92",
                        "content": "checks are done at the interview... Like they give you this problem and you have the audacity to write `Math.Pow` and not knowing any other solution."
                    },
                    {
                        "username": "nitin_leetcode",
                        "content": "When I submit the solution, it runs into stackoverflow exception with the inputs:\\nx: 1.00001 \\nn: 123456\\nBut when I run my code for this input, it runs successfully returning the correct answer.\\n"
                    },
                    {
                        "username": "anujpachauri",
                        "content": "return Math.pow(x, n);"
                    },
                    {
                        "username": "kaviyacute",
                        "content": "return pow(x,n);\\n One line answer and is 100% efficient"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "In C++:\\n```C++\\nclass Solution {\\npublic:\\n    double myPow(double x, int n_) {\\n        long long n = n_;\\n        if(n == 0) return 1.0;\\n        if(n < 0)\\n        {\\n            n = -n;\\n            x = 1./x;\\n        }\\n        double res = x;\\n        while(n > 1)\\n        {\\n            res *= res;\\n            res = n % 2 == 0 ? res : res * x;\\n            n >>= 1;\\n        }\\n        return res;\\n    }\\n};\\n```\\nReturns 0.00000 with x = 8.84372 and n = -5 for some reason, and I cannot figure out why. Any help?"
                    }
                ]
            },
            {
                "id": 1572025,
                "content": [
                    {
                        "username": "tomereli",
                        "content": "I\\'m keeping getting Time limit exceeded to a simple brut force implementation not different than the one in the official solution. Any idea why??\\n```\\n    def myPow(self, x: float, n: int) -> float:\\n        result = 1\\n        for i in range(abs(n)):\\n            result *= x\\n        return result if n > 0 else 1/result\\n```"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "[@GodOfm4a1](/GodOfm4a1) Yes, you are right. we can set the base cases and do this recursively."
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "[@abdulmoomin007](/abdulmoomin007) So we store the results of x^2 , x^4 .... like that, and then build the intended answer?\\n"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "[@YaJohny](/YaJohny) Here\\'s a hint.\\nx*x = x^2, \\nx^2 * x^2 = x^4, \\nx^4*x^4 = x^8\\n....\\nfor x^2147483648, instead of multiplying x with x 2147483648 times, you have to cut down the logic by divide and conquer."
                    },
                    {
                        "username": "YaJohny",
                        "content": "[@abdulmoomin007](/abdulmoomin007) Do you know how to fix that?"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "One of the constraints for n is -2^31 <= n <= 2^31-1. 2^31 is 2147483648. running for loop a billion times would give TLE always."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I have already solved this question the last month. But now when I am re-submitting my old solution, it\\'s showing _wrong answer_ for certain test cases. It looks like that they have updated and added some new test cases."
                    },
                    {
                        "username": "oops_moment",
                        "content": "LOL WHEN I AM WRITING THIS , WHAT IS SEE IS 8.1K UPVOTES AND 8.1 K DOWNVOTES LOL, but we will do it lesss gooo \\uD83E\\uDD13\\uD83E\\uDD13\\n\\n\\uD83E\\uDD14 We know that naively multiplying x by itself n times would surely lead to a Time Limit Exceeded (TLE) error for larger values of n.\\n\\n\\uD83C\\uDF1F Consider an example, let\\'s find 2^4. Instead of multiplying 2 four times, why not do 2 * 2 raised to power 2? Yes! If n is even, just divide n by 2 (n/=2), and square x (x*=x) in each step.\\n\\n\\uD83E\\uDD37\\u200D\\u2642\\uFE0F But what if n is odd, say 2^3? To handle this, we convert it into an even-powered case. We multiply the finalAns by x to account for the extra power, and then you remain with 2^2, which we handle similarly as we do for positive cases.\\n\\n\\uD83E\\uDD13 Now, here\\'s a question for you! Which special case do you need to handle? If the absolute value of n is INT_MIN, you might try to make it positive by -1. But be cautious! This will exceed the int limit. To address this, we use one more long long variable called temp and perform the operation on it.\\n\\nWith this approach, we can efficiently calculate the power of x raised to n without facing any TLE issues. Keep practicing and happy coding! \\uD83D\\uDE04\\uD83D\\uDC4D\\n"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Couldnt pass this testcase \\nthis is a TLE..!\\nx =\\n2.00000\\nn =\\n-2147483648"
                    },
                    {
                        "username": "Prajjal",
                        "content": "[@ashuranjan003](/ashuranjan003) End the loop immediately when it becomes zero\\n"
                    },
                    {
                        "username": "Prajjal",
                        "content": "End the loop immediately when it becomes zero\\n"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "same happens to me \\uD83D\\uDE05"
                    },
                    {
                        "username": "vintiduggar26",
                        "content": "my code is satisfying all the test cases. but when i am trying to submit the code it is showing me this error\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffe2acafff8 (pc 0x000000343a4b bp 0x7ffe2acb0010 sp 0x7ffe2acb0000 T0)\\n==34==ABORTING"
                    },
                    {
                        "username": "Deepanshu_Chhillar",
                        "content": "This error means either you are  variable is trying to store more value than allocated, basically you can say its stackoverflow. \\n\\nDo check that you are returning zero if variable is exceeding the value.\\n\\nFor eg:\\ndouble p=1;\\n if(p>DBL_MAX)\\n          {\\n              return 0;\\n          }\\n        }"
                    },
                    {
                        "username": "lavankumarganji",
                        "content": "are you check ing all the edg cases ?\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "a \"medium\" problem that lets use the pow function?! please add more checks."
                    },
                    {
                        "username": "eduard92",
                        "content": "checks are done at the interview... Like they give you this problem and you have the audacity to write `Math.Pow` and not knowing any other solution."
                    },
                    {
                        "username": "nitin_leetcode",
                        "content": "When I submit the solution, it runs into stackoverflow exception with the inputs:\\nx: 1.00001 \\nn: 123456\\nBut when I run my code for this input, it runs successfully returning the correct answer.\\n"
                    },
                    {
                        "username": "anujpachauri",
                        "content": "return Math.pow(x, n);"
                    },
                    {
                        "username": "kaviyacute",
                        "content": "return pow(x,n);\\n One line answer and is 100% efficient"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "In C++:\\n```C++\\nclass Solution {\\npublic:\\n    double myPow(double x, int n_) {\\n        long long n = n_;\\n        if(n == 0) return 1.0;\\n        if(n < 0)\\n        {\\n            n = -n;\\n            x = 1./x;\\n        }\\n        double res = x;\\n        while(n > 1)\\n        {\\n            res *= res;\\n            res = n % 2 == 0 ? res : res * x;\\n            n >>= 1;\\n        }\\n        return res;\\n    }\\n};\\n```\\nReturns 0.00000 with x = 8.84372 and n = -5 for some reason, and I cannot figure out why. Any help?"
                    }
                ]
            },
            {
                "id": 1573742,
                "content": [
                    {
                        "username": "tomereli",
                        "content": "I\\'m keeping getting Time limit exceeded to a simple brut force implementation not different than the one in the official solution. Any idea why??\\n```\\n    def myPow(self, x: float, n: int) -> float:\\n        result = 1\\n        for i in range(abs(n)):\\n            result *= x\\n        return result if n > 0 else 1/result\\n```"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "[@GodOfm4a1](/GodOfm4a1) Yes, you are right. we can set the base cases and do this recursively."
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "[@abdulmoomin007](/abdulmoomin007) So we store the results of x^2 , x^4 .... like that, and then build the intended answer?\\n"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "[@YaJohny](/YaJohny) Here\\'s a hint.\\nx*x = x^2, \\nx^2 * x^2 = x^4, \\nx^4*x^4 = x^8\\n....\\nfor x^2147483648, instead of multiplying x with x 2147483648 times, you have to cut down the logic by divide and conquer."
                    },
                    {
                        "username": "YaJohny",
                        "content": "[@abdulmoomin007](/abdulmoomin007) Do you know how to fix that?"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "One of the constraints for n is -2^31 <= n <= 2^31-1. 2^31 is 2147483648. running for loop a billion times would give TLE always."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I have already solved this question the last month. But now when I am re-submitting my old solution, it\\'s showing _wrong answer_ for certain test cases. It looks like that they have updated and added some new test cases."
                    },
                    {
                        "username": "oops_moment",
                        "content": "LOL WHEN I AM WRITING THIS , WHAT IS SEE IS 8.1K UPVOTES AND 8.1 K DOWNVOTES LOL, but we will do it lesss gooo \\uD83E\\uDD13\\uD83E\\uDD13\\n\\n\\uD83E\\uDD14 We know that naively multiplying x by itself n times would surely lead to a Time Limit Exceeded (TLE) error for larger values of n.\\n\\n\\uD83C\\uDF1F Consider an example, let\\'s find 2^4. Instead of multiplying 2 four times, why not do 2 * 2 raised to power 2? Yes! If n is even, just divide n by 2 (n/=2), and square x (x*=x) in each step.\\n\\n\\uD83E\\uDD37\\u200D\\u2642\\uFE0F But what if n is odd, say 2^3? To handle this, we convert it into an even-powered case. We multiply the finalAns by x to account for the extra power, and then you remain with 2^2, which we handle similarly as we do for positive cases.\\n\\n\\uD83E\\uDD13 Now, here\\'s a question for you! Which special case do you need to handle? If the absolute value of n is INT_MIN, you might try to make it positive by -1. But be cautious! This will exceed the int limit. To address this, we use one more long long variable called temp and perform the operation on it.\\n\\nWith this approach, we can efficiently calculate the power of x raised to n without facing any TLE issues. Keep practicing and happy coding! \\uD83D\\uDE04\\uD83D\\uDC4D\\n"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Couldnt pass this testcase \\nthis is a TLE..!\\nx =\\n2.00000\\nn =\\n-2147483648"
                    },
                    {
                        "username": "Prajjal",
                        "content": "[@ashuranjan003](/ashuranjan003) End the loop immediately when it becomes zero\\n"
                    },
                    {
                        "username": "Prajjal",
                        "content": "End the loop immediately when it becomes zero\\n"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "same happens to me \\uD83D\\uDE05"
                    },
                    {
                        "username": "vintiduggar26",
                        "content": "my code is satisfying all the test cases. but when i am trying to submit the code it is showing me this error\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffe2acafff8 (pc 0x000000343a4b bp 0x7ffe2acb0010 sp 0x7ffe2acb0000 T0)\\n==34==ABORTING"
                    },
                    {
                        "username": "Deepanshu_Chhillar",
                        "content": "This error means either you are  variable is trying to store more value than allocated, basically you can say its stackoverflow. \\n\\nDo check that you are returning zero if variable is exceeding the value.\\n\\nFor eg:\\ndouble p=1;\\n if(p>DBL_MAX)\\n          {\\n              return 0;\\n          }\\n        }"
                    },
                    {
                        "username": "lavankumarganji",
                        "content": "are you check ing all the edg cases ?\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "a \"medium\" problem that lets use the pow function?! please add more checks."
                    },
                    {
                        "username": "eduard92",
                        "content": "checks are done at the interview... Like they give you this problem and you have the audacity to write `Math.Pow` and not knowing any other solution."
                    },
                    {
                        "username": "nitin_leetcode",
                        "content": "When I submit the solution, it runs into stackoverflow exception with the inputs:\\nx: 1.00001 \\nn: 123456\\nBut when I run my code for this input, it runs successfully returning the correct answer.\\n"
                    },
                    {
                        "username": "anujpachauri",
                        "content": "return Math.pow(x, n);"
                    },
                    {
                        "username": "kaviyacute",
                        "content": "return pow(x,n);\\n One line answer and is 100% efficient"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "In C++:\\n```C++\\nclass Solution {\\npublic:\\n    double myPow(double x, int n_) {\\n        long long n = n_;\\n        if(n == 0) return 1.0;\\n        if(n < 0)\\n        {\\n            n = -n;\\n            x = 1./x;\\n        }\\n        double res = x;\\n        while(n > 1)\\n        {\\n            res *= res;\\n            res = n % 2 == 0 ? res : res * x;\\n            n >>= 1;\\n        }\\n        return res;\\n    }\\n};\\n```\\nReturns 0.00000 with x = 8.84372 and n = -5 for some reason, and I cannot figure out why. Any help?"
                    }
                ]
            },
            {
                "id": 1572657,
                "content": [
                    {
                        "username": "tomereli",
                        "content": "I\\'m keeping getting Time limit exceeded to a simple brut force implementation not different than the one in the official solution. Any idea why??\\n```\\n    def myPow(self, x: float, n: int) -> float:\\n        result = 1\\n        for i in range(abs(n)):\\n            result *= x\\n        return result if n > 0 else 1/result\\n```"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "[@GodOfm4a1](/GodOfm4a1) Yes, you are right. we can set the base cases and do this recursively."
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "[@abdulmoomin007](/abdulmoomin007) So we store the results of x^2 , x^4 .... like that, and then build the intended answer?\\n"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "[@YaJohny](/YaJohny) Here\\'s a hint.\\nx*x = x^2, \\nx^2 * x^2 = x^4, \\nx^4*x^4 = x^8\\n....\\nfor x^2147483648, instead of multiplying x with x 2147483648 times, you have to cut down the logic by divide and conquer."
                    },
                    {
                        "username": "YaJohny",
                        "content": "[@abdulmoomin007](/abdulmoomin007) Do you know how to fix that?"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "One of the constraints for n is -2^31 <= n <= 2^31-1. 2^31 is 2147483648. running for loop a billion times would give TLE always."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I have already solved this question the last month. But now when I am re-submitting my old solution, it\\'s showing _wrong answer_ for certain test cases. It looks like that they have updated and added some new test cases."
                    },
                    {
                        "username": "oops_moment",
                        "content": "LOL WHEN I AM WRITING THIS , WHAT IS SEE IS 8.1K UPVOTES AND 8.1 K DOWNVOTES LOL, but we will do it lesss gooo \\uD83E\\uDD13\\uD83E\\uDD13\\n\\n\\uD83E\\uDD14 We know that naively multiplying x by itself n times would surely lead to a Time Limit Exceeded (TLE) error for larger values of n.\\n\\n\\uD83C\\uDF1F Consider an example, let\\'s find 2^4. Instead of multiplying 2 four times, why not do 2 * 2 raised to power 2? Yes! If n is even, just divide n by 2 (n/=2), and square x (x*=x) in each step.\\n\\n\\uD83E\\uDD37\\u200D\\u2642\\uFE0F But what if n is odd, say 2^3? To handle this, we convert it into an even-powered case. We multiply the finalAns by x to account for the extra power, and then you remain with 2^2, which we handle similarly as we do for positive cases.\\n\\n\\uD83E\\uDD13 Now, here\\'s a question for you! Which special case do you need to handle? If the absolute value of n is INT_MIN, you might try to make it positive by -1. But be cautious! This will exceed the int limit. To address this, we use one more long long variable called temp and perform the operation on it.\\n\\nWith this approach, we can efficiently calculate the power of x raised to n without facing any TLE issues. Keep practicing and happy coding! \\uD83D\\uDE04\\uD83D\\uDC4D\\n"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Couldnt pass this testcase \\nthis is a TLE..!\\nx =\\n2.00000\\nn =\\n-2147483648"
                    },
                    {
                        "username": "Prajjal",
                        "content": "[@ashuranjan003](/ashuranjan003) End the loop immediately when it becomes zero\\n"
                    },
                    {
                        "username": "Prajjal",
                        "content": "End the loop immediately when it becomes zero\\n"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "same happens to me \\uD83D\\uDE05"
                    },
                    {
                        "username": "vintiduggar26",
                        "content": "my code is satisfying all the test cases. but when i am trying to submit the code it is showing me this error\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffe2acafff8 (pc 0x000000343a4b bp 0x7ffe2acb0010 sp 0x7ffe2acb0000 T0)\\n==34==ABORTING"
                    },
                    {
                        "username": "Deepanshu_Chhillar",
                        "content": "This error means either you are  variable is trying to store more value than allocated, basically you can say its stackoverflow. \\n\\nDo check that you are returning zero if variable is exceeding the value.\\n\\nFor eg:\\ndouble p=1;\\n if(p>DBL_MAX)\\n          {\\n              return 0;\\n          }\\n        }"
                    },
                    {
                        "username": "lavankumarganji",
                        "content": "are you check ing all the edg cases ?\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "a \"medium\" problem that lets use the pow function?! please add more checks."
                    },
                    {
                        "username": "eduard92",
                        "content": "checks are done at the interview... Like they give you this problem and you have the audacity to write `Math.Pow` and not knowing any other solution."
                    },
                    {
                        "username": "nitin_leetcode",
                        "content": "When I submit the solution, it runs into stackoverflow exception with the inputs:\\nx: 1.00001 \\nn: 123456\\nBut when I run my code for this input, it runs successfully returning the correct answer.\\n"
                    },
                    {
                        "username": "anujpachauri",
                        "content": "return Math.pow(x, n);"
                    },
                    {
                        "username": "kaviyacute",
                        "content": "return pow(x,n);\\n One line answer and is 100% efficient"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "In C++:\\n```C++\\nclass Solution {\\npublic:\\n    double myPow(double x, int n_) {\\n        long long n = n_;\\n        if(n == 0) return 1.0;\\n        if(n < 0)\\n        {\\n            n = -n;\\n            x = 1./x;\\n        }\\n        double res = x;\\n        while(n > 1)\\n        {\\n            res *= res;\\n            res = n % 2 == 0 ? res : res * x;\\n            n >>= 1;\\n        }\\n        return res;\\n    }\\n};\\n```\\nReturns 0.00000 with x = 8.84372 and n = -5 for some reason, and I cannot figure out why. Any help?"
                    }
                ]
            },
            {
                "id": 2014670,
                "content": [
                    {
                        "username": "tomereli",
                        "content": "I\\'m keeping getting Time limit exceeded to a simple brut force implementation not different than the one in the official solution. Any idea why??\\n```\\n    def myPow(self, x: float, n: int) -> float:\\n        result = 1\\n        for i in range(abs(n)):\\n            result *= x\\n        return result if n > 0 else 1/result\\n```"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "[@GodOfm4a1](/GodOfm4a1) Yes, you are right. we can set the base cases and do this recursively."
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "[@abdulmoomin007](/abdulmoomin007) So we store the results of x^2 , x^4 .... like that, and then build the intended answer?\\n"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "[@YaJohny](/YaJohny) Here\\'s a hint.\\nx*x = x^2, \\nx^2 * x^2 = x^4, \\nx^4*x^4 = x^8\\n....\\nfor x^2147483648, instead of multiplying x with x 2147483648 times, you have to cut down the logic by divide and conquer."
                    },
                    {
                        "username": "YaJohny",
                        "content": "[@abdulmoomin007](/abdulmoomin007) Do you know how to fix that?"
                    },
                    {
                        "username": "abdulmoomin007",
                        "content": "One of the constraints for n is -2^31 <= n <= 2^31-1. 2^31 is 2147483648. running for loop a billion times would give TLE always."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I have already solved this question the last month. But now when I am re-submitting my old solution, it\\'s showing _wrong answer_ for certain test cases. It looks like that they have updated and added some new test cases."
                    },
                    {
                        "username": "oops_moment",
                        "content": "LOL WHEN I AM WRITING THIS , WHAT IS SEE IS 8.1K UPVOTES AND 8.1 K DOWNVOTES LOL, but we will do it lesss gooo \\uD83E\\uDD13\\uD83E\\uDD13\\n\\n\\uD83E\\uDD14 We know that naively multiplying x by itself n times would surely lead to a Time Limit Exceeded (TLE) error for larger values of n.\\n\\n\\uD83C\\uDF1F Consider an example, let\\'s find 2^4. Instead of multiplying 2 four times, why not do 2 * 2 raised to power 2? Yes! If n is even, just divide n by 2 (n/=2), and square x (x*=x) in each step.\\n\\n\\uD83E\\uDD37\\u200D\\u2642\\uFE0F But what if n is odd, say 2^3? To handle this, we convert it into an even-powered case. We multiply the finalAns by x to account for the extra power, and then you remain with 2^2, which we handle similarly as we do for positive cases.\\n\\n\\uD83E\\uDD13 Now, here\\'s a question for you! Which special case do you need to handle? If the absolute value of n is INT_MIN, you might try to make it positive by -1. But be cautious! This will exceed the int limit. To address this, we use one more long long variable called temp and perform the operation on it.\\n\\nWith this approach, we can efficiently calculate the power of x raised to n without facing any TLE issues. Keep practicing and happy coding! \\uD83D\\uDE04\\uD83D\\uDC4D\\n"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Couldnt pass this testcase \\nthis is a TLE..!\\nx =\\n2.00000\\nn =\\n-2147483648"
                    },
                    {
                        "username": "Prajjal",
                        "content": "[@ashuranjan003](/ashuranjan003) End the loop immediately when it becomes zero\\n"
                    },
                    {
                        "username": "Prajjal",
                        "content": "End the loop immediately when it becomes zero\\n"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "same happens to me \\uD83D\\uDE05"
                    },
                    {
                        "username": "vintiduggar26",
                        "content": "my code is satisfying all the test cases. but when i am trying to submit the code it is showing me this error\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffe2acafff8 (pc 0x000000343a4b bp 0x7ffe2acb0010 sp 0x7ffe2acb0000 T0)\\n==34==ABORTING"
                    },
                    {
                        "username": "Deepanshu_Chhillar",
                        "content": "This error means either you are  variable is trying to store more value than allocated, basically you can say its stackoverflow. \\n\\nDo check that you are returning zero if variable is exceeding the value.\\n\\nFor eg:\\ndouble p=1;\\n if(p>DBL_MAX)\\n          {\\n              return 0;\\n          }\\n        }"
                    },
                    {
                        "username": "lavankumarganji",
                        "content": "are you check ing all the edg cases ?\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "a \"medium\" problem that lets use the pow function?! please add more checks."
                    },
                    {
                        "username": "eduard92",
                        "content": "checks are done at the interview... Like they give you this problem and you have the audacity to write `Math.Pow` and not knowing any other solution."
                    },
                    {
                        "username": "nitin_leetcode",
                        "content": "When I submit the solution, it runs into stackoverflow exception with the inputs:\\nx: 1.00001 \\nn: 123456\\nBut when I run my code for this input, it runs successfully returning the correct answer.\\n"
                    },
                    {
                        "username": "anujpachauri",
                        "content": "return Math.pow(x, n);"
                    },
                    {
                        "username": "kaviyacute",
                        "content": "return pow(x,n);\\n One line answer and is 100% efficient"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "In C++:\\n```C++\\nclass Solution {\\npublic:\\n    double myPow(double x, int n_) {\\n        long long n = n_;\\n        if(n == 0) return 1.0;\\n        if(n < 0)\\n        {\\n            n = -n;\\n            x = 1./x;\\n        }\\n        double res = x;\\n        while(n > 1)\\n        {\\n            res *= res;\\n            res = n % 2 == 0 ? res : res * x;\\n            n >>= 1;\\n        }\\n        return res;\\n    }\\n};\\n```\\nReturns 0.00000 with x = 8.84372 and n = -5 for some reason, and I cannot figure out why. Any help?"
                    }
                ]
            },
            {
                "id": 2006411,
                "content": [
                    {
                        "username": "Rahul_108",
                        "content": "Mood Off  :(\\nx = 0.00001\\nn = 2147483647"
                    },
                    {
                        "username": "RishabhMishra2710",
                        "content": "Someone just hates society \\nn = INT_MIN & x = 1.0000000000001 wtf !!"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "binary exponentiation  :)\\njust a little clue!"
                    },
                    {
                        "username": "Rishipandey14",
                        "content": "return x**n"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "When interviewer has personal issues with you"
                    },
                    {
                        "username": "psionl0",
                        "content": "Without giving too much away (the editorial does that) one way to deal with the edge cases where n = -2147483648 is as follows:\n```\n   if (n < 0) {\n       return myPow(1 / x, -(n+1)) / x;\n   } . . .\n```\nIf you are coding an iterative solution then you can deal with the edge case like this:\n```\n   double div = 1.0, result = 1.0;\n   if (n < 0) {\n       div = x;\n       x = 1/x;\n       n = -(n+1);\n   } . . .\n```\nAt the end of the computations, return ``result / div``."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Changing the arguments like that is cheating. Since the arguments are a double and an integer, these are what we have to work with (although you can cast the integer into a double if you are not using recursion)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) Or you can just promote the exponent's type to a long, and virtually the same binary exponentiation algorithm will still work https://leetcode.com/problems/powx-n/submissions/1002575265/"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@charonme](/charonme) Fancy that! Thanks for that edge case. I have now deleted my edit."
                    },
                    {
                        "username": "charonme",
                        "content": "except 1.0000000000001 ^ (-2147483648) expects 0.99979"
                    },
                    {
                        "username": "supervaka",
                        "content": "is there a similar implement log(b, x) kind of problem?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "y4cj4sul3",
                        "content": "I was just testing some cases using C++ and accidentally found something weird when I do `abs()` on the input argument `n` when `n = -2147483648`. \\n\\nThe expected return value of `abs(INT_MIN)` should be `INT_MIN` because of the 2\\'s complement representation, and I did get `-2147483648` as I printed `abs(n)` out. However, when I try to divide `n` by 2 after that, I got `1073741824`  instead of `-1073741824`.\\n\\nSo I try out several things as shown in the picture below. It seems that `n` is actually converted to positive by `abs()` but in a 64-bit manner.\\n\\n![image](https://assets.leetcode.com/users/images/16ee1a6c-6168-4f7b-8ef7-379dd32d9ace_1648312777.6464503.png)\\n\\nHowever, if one assigns `INT_MIN` to `n` in the code rather than in the leetcode console, it becomes normal as what `a` behaved in the picture. Also, I test it out on my computer and everything works fine. So I guess the problem is happening when the leetcode feeds testcases from the console to the code. Any idea of that?"
                    },
                    {
                        "username": "yuv",
                        "content": "Well, I\\'ve got the reason behind the weirdness. It\\'s lied in the range of a signed integer. The range is [-2147483648 to 2147483647]. So, if we try to do the `abs()` operation on the `INT_MIN` then it won\\'t be possible to fit in `int` range. Because the INT_MAX value is one less than that. To avoid it you must store the power value in a `long` type variable. Then it would behave normally."
                    },
                    {
                        "username": "yuv",
                        "content": "It\\'s weird behavior. It\\'s still showing `n` as negative after `abs()` operation. But it is returning true for the `n > 0` condition. "
                    },
                    {
                        "username": "yixuan5",
                        "content": "It is not specific to algorithm, but more for corner case.\\n\\nUse recursion, but it is slower than while loop."
                    }
                ]
            },
            {
                "id": 1984398,
                "content": [
                    {
                        "username": "Rahul_108",
                        "content": "Mood Off  :(\\nx = 0.00001\\nn = 2147483647"
                    },
                    {
                        "username": "RishabhMishra2710",
                        "content": "Someone just hates society \\nn = INT_MIN & x = 1.0000000000001 wtf !!"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "binary exponentiation  :)\\njust a little clue!"
                    },
                    {
                        "username": "Rishipandey14",
                        "content": "return x**n"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "When interviewer has personal issues with you"
                    },
                    {
                        "username": "psionl0",
                        "content": "Without giving too much away (the editorial does that) one way to deal with the edge cases where n = -2147483648 is as follows:\n```\n   if (n < 0) {\n       return myPow(1 / x, -(n+1)) / x;\n   } . . .\n```\nIf you are coding an iterative solution then you can deal with the edge case like this:\n```\n   double div = 1.0, result = 1.0;\n   if (n < 0) {\n       div = x;\n       x = 1/x;\n       n = -(n+1);\n   } . . .\n```\nAt the end of the computations, return ``result / div``."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Changing the arguments like that is cheating. Since the arguments are a double and an integer, these are what we have to work with (although you can cast the integer into a double if you are not using recursion)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) Or you can just promote the exponent's type to a long, and virtually the same binary exponentiation algorithm will still work https://leetcode.com/problems/powx-n/submissions/1002575265/"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@charonme](/charonme) Fancy that! Thanks for that edge case. I have now deleted my edit."
                    },
                    {
                        "username": "charonme",
                        "content": "except 1.0000000000001 ^ (-2147483648) expects 0.99979"
                    },
                    {
                        "username": "supervaka",
                        "content": "is there a similar implement log(b, x) kind of problem?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "y4cj4sul3",
                        "content": "I was just testing some cases using C++ and accidentally found something weird when I do `abs()` on the input argument `n` when `n = -2147483648`. \\n\\nThe expected return value of `abs(INT_MIN)` should be `INT_MIN` because of the 2\\'s complement representation, and I did get `-2147483648` as I printed `abs(n)` out. However, when I try to divide `n` by 2 after that, I got `1073741824`  instead of `-1073741824`.\\n\\nSo I try out several things as shown in the picture below. It seems that `n` is actually converted to positive by `abs()` but in a 64-bit manner.\\n\\n![image](https://assets.leetcode.com/users/images/16ee1a6c-6168-4f7b-8ef7-379dd32d9ace_1648312777.6464503.png)\\n\\nHowever, if one assigns `INT_MIN` to `n` in the code rather than in the leetcode console, it becomes normal as what `a` behaved in the picture. Also, I test it out on my computer and everything works fine. So I guess the problem is happening when the leetcode feeds testcases from the console to the code. Any idea of that?"
                    },
                    {
                        "username": "yuv",
                        "content": "Well, I\\'ve got the reason behind the weirdness. It\\'s lied in the range of a signed integer. The range is [-2147483648 to 2147483647]. So, if we try to do the `abs()` operation on the `INT_MIN` then it won\\'t be possible to fit in `int` range. Because the INT_MAX value is one less than that. To avoid it you must store the power value in a `long` type variable. Then it would behave normally."
                    },
                    {
                        "username": "yuv",
                        "content": "It\\'s weird behavior. It\\'s still showing `n` as negative after `abs()` operation. But it is returning true for the `n > 0` condition. "
                    },
                    {
                        "username": "yixuan5",
                        "content": "It is not specific to algorithm, but more for corner case.\\n\\nUse recursion, but it is slower than while loop."
                    }
                ]
            },
            {
                "id": 1984113,
                "content": [
                    {
                        "username": "Rahul_108",
                        "content": "Mood Off  :(\\nx = 0.00001\\nn = 2147483647"
                    },
                    {
                        "username": "RishabhMishra2710",
                        "content": "Someone just hates society \\nn = INT_MIN & x = 1.0000000000001 wtf !!"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "binary exponentiation  :)\\njust a little clue!"
                    },
                    {
                        "username": "Rishipandey14",
                        "content": "return x**n"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "When interviewer has personal issues with you"
                    },
                    {
                        "username": "psionl0",
                        "content": "Without giving too much away (the editorial does that) one way to deal with the edge cases where n = -2147483648 is as follows:\n```\n   if (n < 0) {\n       return myPow(1 / x, -(n+1)) / x;\n   } . . .\n```\nIf you are coding an iterative solution then you can deal with the edge case like this:\n```\n   double div = 1.0, result = 1.0;\n   if (n < 0) {\n       div = x;\n       x = 1/x;\n       n = -(n+1);\n   } . . .\n```\nAt the end of the computations, return ``result / div``."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Changing the arguments like that is cheating. Since the arguments are a double and an integer, these are what we have to work with (although you can cast the integer into a double if you are not using recursion)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) Or you can just promote the exponent's type to a long, and virtually the same binary exponentiation algorithm will still work https://leetcode.com/problems/powx-n/submissions/1002575265/"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@charonme](/charonme) Fancy that! Thanks for that edge case. I have now deleted my edit."
                    },
                    {
                        "username": "charonme",
                        "content": "except 1.0000000000001 ^ (-2147483648) expects 0.99979"
                    },
                    {
                        "username": "supervaka",
                        "content": "is there a similar implement log(b, x) kind of problem?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "y4cj4sul3",
                        "content": "I was just testing some cases using C++ and accidentally found something weird when I do `abs()` on the input argument `n` when `n = -2147483648`. \\n\\nThe expected return value of `abs(INT_MIN)` should be `INT_MIN` because of the 2\\'s complement representation, and I did get `-2147483648` as I printed `abs(n)` out. However, when I try to divide `n` by 2 after that, I got `1073741824`  instead of `-1073741824`.\\n\\nSo I try out several things as shown in the picture below. It seems that `n` is actually converted to positive by `abs()` but in a 64-bit manner.\\n\\n![image](https://assets.leetcode.com/users/images/16ee1a6c-6168-4f7b-8ef7-379dd32d9ace_1648312777.6464503.png)\\n\\nHowever, if one assigns `INT_MIN` to `n` in the code rather than in the leetcode console, it becomes normal as what `a` behaved in the picture. Also, I test it out on my computer and everything works fine. So I guess the problem is happening when the leetcode feeds testcases from the console to the code. Any idea of that?"
                    },
                    {
                        "username": "yuv",
                        "content": "Well, I\\'ve got the reason behind the weirdness. It\\'s lied in the range of a signed integer. The range is [-2147483648 to 2147483647]. So, if we try to do the `abs()` operation on the `INT_MIN` then it won\\'t be possible to fit in `int` range. Because the INT_MAX value is one less than that. To avoid it you must store the power value in a `long` type variable. Then it would behave normally."
                    },
                    {
                        "username": "yuv",
                        "content": "It\\'s weird behavior. It\\'s still showing `n` as negative after `abs()` operation. But it is returning true for the `n > 0` condition. "
                    },
                    {
                        "username": "yixuan5",
                        "content": "It is not specific to algorithm, but more for corner case.\\n\\nUse recursion, but it is slower than while loop."
                    }
                ]
            },
            {
                "id": 1983839,
                "content": [
                    {
                        "username": "Rahul_108",
                        "content": "Mood Off  :(\\nx = 0.00001\\nn = 2147483647"
                    },
                    {
                        "username": "RishabhMishra2710",
                        "content": "Someone just hates society \\nn = INT_MIN & x = 1.0000000000001 wtf !!"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "binary exponentiation  :)\\njust a little clue!"
                    },
                    {
                        "username": "Rishipandey14",
                        "content": "return x**n"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "When interviewer has personal issues with you"
                    },
                    {
                        "username": "psionl0",
                        "content": "Without giving too much away (the editorial does that) one way to deal with the edge cases where n = -2147483648 is as follows:\n```\n   if (n < 0) {\n       return myPow(1 / x, -(n+1)) / x;\n   } . . .\n```\nIf you are coding an iterative solution then you can deal with the edge case like this:\n```\n   double div = 1.0, result = 1.0;\n   if (n < 0) {\n       div = x;\n       x = 1/x;\n       n = -(n+1);\n   } . . .\n```\nAt the end of the computations, return ``result / div``."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Changing the arguments like that is cheating. Since the arguments are a double and an integer, these are what we have to work with (although you can cast the integer into a double if you are not using recursion)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) Or you can just promote the exponent's type to a long, and virtually the same binary exponentiation algorithm will still work https://leetcode.com/problems/powx-n/submissions/1002575265/"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@charonme](/charonme) Fancy that! Thanks for that edge case. I have now deleted my edit."
                    },
                    {
                        "username": "charonme",
                        "content": "except 1.0000000000001 ^ (-2147483648) expects 0.99979"
                    },
                    {
                        "username": "supervaka",
                        "content": "is there a similar implement log(b, x) kind of problem?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "y4cj4sul3",
                        "content": "I was just testing some cases using C++ and accidentally found something weird when I do `abs()` on the input argument `n` when `n = -2147483648`. \\n\\nThe expected return value of `abs(INT_MIN)` should be `INT_MIN` because of the 2\\'s complement representation, and I did get `-2147483648` as I printed `abs(n)` out. However, when I try to divide `n` by 2 after that, I got `1073741824`  instead of `-1073741824`.\\n\\nSo I try out several things as shown in the picture below. It seems that `n` is actually converted to positive by `abs()` but in a 64-bit manner.\\n\\n![image](https://assets.leetcode.com/users/images/16ee1a6c-6168-4f7b-8ef7-379dd32d9ace_1648312777.6464503.png)\\n\\nHowever, if one assigns `INT_MIN` to `n` in the code rather than in the leetcode console, it becomes normal as what `a` behaved in the picture. Also, I test it out on my computer and everything works fine. So I guess the problem is happening when the leetcode feeds testcases from the console to the code. Any idea of that?"
                    },
                    {
                        "username": "yuv",
                        "content": "Well, I\\'ve got the reason behind the weirdness. It\\'s lied in the range of a signed integer. The range is [-2147483648 to 2147483647]. So, if we try to do the `abs()` operation on the `INT_MIN` then it won\\'t be possible to fit in `int` range. Because the INT_MAX value is one less than that. To avoid it you must store the power value in a `long` type variable. Then it would behave normally."
                    },
                    {
                        "username": "yuv",
                        "content": "It\\'s weird behavior. It\\'s still showing `n` as negative after `abs()` operation. But it is returning true for the `n > 0` condition. "
                    },
                    {
                        "username": "yixuan5",
                        "content": "It is not specific to algorithm, but more for corner case.\\n\\nUse recursion, but it is slower than while loop."
                    }
                ]
            },
            {
                "id": 1983818,
                "content": [
                    {
                        "username": "Rahul_108",
                        "content": "Mood Off  :(\\nx = 0.00001\\nn = 2147483647"
                    },
                    {
                        "username": "RishabhMishra2710",
                        "content": "Someone just hates society \\nn = INT_MIN & x = 1.0000000000001 wtf !!"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "binary exponentiation  :)\\njust a little clue!"
                    },
                    {
                        "username": "Rishipandey14",
                        "content": "return x**n"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "When interviewer has personal issues with you"
                    },
                    {
                        "username": "psionl0",
                        "content": "Without giving too much away (the editorial does that) one way to deal with the edge cases where n = -2147483648 is as follows:\n```\n   if (n < 0) {\n       return myPow(1 / x, -(n+1)) / x;\n   } . . .\n```\nIf you are coding an iterative solution then you can deal with the edge case like this:\n```\n   double div = 1.0, result = 1.0;\n   if (n < 0) {\n       div = x;\n       x = 1/x;\n       n = -(n+1);\n   } . . .\n```\nAt the end of the computations, return ``result / div``."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Changing the arguments like that is cheating. Since the arguments are a double and an integer, these are what we have to work with (although you can cast the integer into a double if you are not using recursion)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) Or you can just promote the exponent's type to a long, and virtually the same binary exponentiation algorithm will still work https://leetcode.com/problems/powx-n/submissions/1002575265/"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@charonme](/charonme) Fancy that! Thanks for that edge case. I have now deleted my edit."
                    },
                    {
                        "username": "charonme",
                        "content": "except 1.0000000000001 ^ (-2147483648) expects 0.99979"
                    },
                    {
                        "username": "supervaka",
                        "content": "is there a similar implement log(b, x) kind of problem?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "y4cj4sul3",
                        "content": "I was just testing some cases using C++ and accidentally found something weird when I do `abs()` on the input argument `n` when `n = -2147483648`. \\n\\nThe expected return value of `abs(INT_MIN)` should be `INT_MIN` because of the 2\\'s complement representation, and I did get `-2147483648` as I printed `abs(n)` out. However, when I try to divide `n` by 2 after that, I got `1073741824`  instead of `-1073741824`.\\n\\nSo I try out several things as shown in the picture below. It seems that `n` is actually converted to positive by `abs()` but in a 64-bit manner.\\n\\n![image](https://assets.leetcode.com/users/images/16ee1a6c-6168-4f7b-8ef7-379dd32d9ace_1648312777.6464503.png)\\n\\nHowever, if one assigns `INT_MIN` to `n` in the code rather than in the leetcode console, it becomes normal as what `a` behaved in the picture. Also, I test it out on my computer and everything works fine. So I guess the problem is happening when the leetcode feeds testcases from the console to the code. Any idea of that?"
                    },
                    {
                        "username": "yuv",
                        "content": "Well, I\\'ve got the reason behind the weirdness. It\\'s lied in the range of a signed integer. The range is [-2147483648 to 2147483647]. So, if we try to do the `abs()` operation on the `INT_MIN` then it won\\'t be possible to fit in `int` range. Because the INT_MAX value is one less than that. To avoid it you must store the power value in a `long` type variable. Then it would behave normally."
                    },
                    {
                        "username": "yuv",
                        "content": "It\\'s weird behavior. It\\'s still showing `n` as negative after `abs()` operation. But it is returning true for the `n > 0` condition. "
                    },
                    {
                        "username": "yixuan5",
                        "content": "It is not specific to algorithm, but more for corner case.\\n\\nUse recursion, but it is slower than while loop."
                    }
                ]
            },
            {
                "id": 1983632,
                "content": [
                    {
                        "username": "Rahul_108",
                        "content": "Mood Off  :(\\nx = 0.00001\\nn = 2147483647"
                    },
                    {
                        "username": "RishabhMishra2710",
                        "content": "Someone just hates society \\nn = INT_MIN & x = 1.0000000000001 wtf !!"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "binary exponentiation  :)\\njust a little clue!"
                    },
                    {
                        "username": "Rishipandey14",
                        "content": "return x**n"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "When interviewer has personal issues with you"
                    },
                    {
                        "username": "psionl0",
                        "content": "Without giving too much away (the editorial does that) one way to deal with the edge cases where n = -2147483648 is as follows:\n```\n   if (n < 0) {\n       return myPow(1 / x, -(n+1)) / x;\n   } . . .\n```\nIf you are coding an iterative solution then you can deal with the edge case like this:\n```\n   double div = 1.0, result = 1.0;\n   if (n < 0) {\n       div = x;\n       x = 1/x;\n       n = -(n+1);\n   } . . .\n```\nAt the end of the computations, return ``result / div``."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Changing the arguments like that is cheating. Since the arguments are a double and an integer, these are what we have to work with (although you can cast the integer into a double if you are not using recursion)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) Or you can just promote the exponent's type to a long, and virtually the same binary exponentiation algorithm will still work https://leetcode.com/problems/powx-n/submissions/1002575265/"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@charonme](/charonme) Fancy that! Thanks for that edge case. I have now deleted my edit."
                    },
                    {
                        "username": "charonme",
                        "content": "except 1.0000000000001 ^ (-2147483648) expects 0.99979"
                    },
                    {
                        "username": "supervaka",
                        "content": "is there a similar implement log(b, x) kind of problem?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "y4cj4sul3",
                        "content": "I was just testing some cases using C++ and accidentally found something weird when I do `abs()` on the input argument `n` when `n = -2147483648`. \\n\\nThe expected return value of `abs(INT_MIN)` should be `INT_MIN` because of the 2\\'s complement representation, and I did get `-2147483648` as I printed `abs(n)` out. However, when I try to divide `n` by 2 after that, I got `1073741824`  instead of `-1073741824`.\\n\\nSo I try out several things as shown in the picture below. It seems that `n` is actually converted to positive by `abs()` but in a 64-bit manner.\\n\\n![image](https://assets.leetcode.com/users/images/16ee1a6c-6168-4f7b-8ef7-379dd32d9ace_1648312777.6464503.png)\\n\\nHowever, if one assigns `INT_MIN` to `n` in the code rather than in the leetcode console, it becomes normal as what `a` behaved in the picture. Also, I test it out on my computer and everything works fine. So I guess the problem is happening when the leetcode feeds testcases from the console to the code. Any idea of that?"
                    },
                    {
                        "username": "yuv",
                        "content": "Well, I\\'ve got the reason behind the weirdness. It\\'s lied in the range of a signed integer. The range is [-2147483648 to 2147483647]. So, if we try to do the `abs()` operation on the `INT_MIN` then it won\\'t be possible to fit in `int` range. Because the INT_MAX value is one less than that. To avoid it you must store the power value in a `long` type variable. Then it would behave normally."
                    },
                    {
                        "username": "yuv",
                        "content": "It\\'s weird behavior. It\\'s still showing `n` as negative after `abs()` operation. But it is returning true for the `n > 0` condition. "
                    },
                    {
                        "username": "yixuan5",
                        "content": "It is not specific to algorithm, but more for corner case.\\n\\nUse recursion, but it is slower than while loop."
                    }
                ]
            },
            {
                "id": 1832579,
                "content": [
                    {
                        "username": "Rahul_108",
                        "content": "Mood Off  :(\\nx = 0.00001\\nn = 2147483647"
                    },
                    {
                        "username": "RishabhMishra2710",
                        "content": "Someone just hates society \\nn = INT_MIN & x = 1.0000000000001 wtf !!"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "binary exponentiation  :)\\njust a little clue!"
                    },
                    {
                        "username": "Rishipandey14",
                        "content": "return x**n"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "When interviewer has personal issues with you"
                    },
                    {
                        "username": "psionl0",
                        "content": "Without giving too much away (the editorial does that) one way to deal with the edge cases where n = -2147483648 is as follows:\n```\n   if (n < 0) {\n       return myPow(1 / x, -(n+1)) / x;\n   } . . .\n```\nIf you are coding an iterative solution then you can deal with the edge case like this:\n```\n   double div = 1.0, result = 1.0;\n   if (n < 0) {\n       div = x;\n       x = 1/x;\n       n = -(n+1);\n   } . . .\n```\nAt the end of the computations, return ``result / div``."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Changing the arguments like that is cheating. Since the arguments are a double and an integer, these are what we have to work with (although you can cast the integer into a double if you are not using recursion)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) Or you can just promote the exponent's type to a long, and virtually the same binary exponentiation algorithm will still work https://leetcode.com/problems/powx-n/submissions/1002575265/"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@charonme](/charonme) Fancy that! Thanks for that edge case. I have now deleted my edit."
                    },
                    {
                        "username": "charonme",
                        "content": "except 1.0000000000001 ^ (-2147483648) expects 0.99979"
                    },
                    {
                        "username": "supervaka",
                        "content": "is there a similar implement log(b, x) kind of problem?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "y4cj4sul3",
                        "content": "I was just testing some cases using C++ and accidentally found something weird when I do `abs()` on the input argument `n` when `n = -2147483648`. \\n\\nThe expected return value of `abs(INT_MIN)` should be `INT_MIN` because of the 2\\'s complement representation, and I did get `-2147483648` as I printed `abs(n)` out. However, when I try to divide `n` by 2 after that, I got `1073741824`  instead of `-1073741824`.\\n\\nSo I try out several things as shown in the picture below. It seems that `n` is actually converted to positive by `abs()` but in a 64-bit manner.\\n\\n![image](https://assets.leetcode.com/users/images/16ee1a6c-6168-4f7b-8ef7-379dd32d9ace_1648312777.6464503.png)\\n\\nHowever, if one assigns `INT_MIN` to `n` in the code rather than in the leetcode console, it becomes normal as what `a` behaved in the picture. Also, I test it out on my computer and everything works fine. So I guess the problem is happening when the leetcode feeds testcases from the console to the code. Any idea of that?"
                    },
                    {
                        "username": "yuv",
                        "content": "Well, I\\'ve got the reason behind the weirdness. It\\'s lied in the range of a signed integer. The range is [-2147483648 to 2147483647]. So, if we try to do the `abs()` operation on the `INT_MIN` then it won\\'t be possible to fit in `int` range. Because the INT_MAX value is one less than that. To avoid it you must store the power value in a `long` type variable. Then it would behave normally."
                    },
                    {
                        "username": "yuv",
                        "content": "It\\'s weird behavior. It\\'s still showing `n` as negative after `abs()` operation. But it is returning true for the `n > 0` condition. "
                    },
                    {
                        "username": "yixuan5",
                        "content": "It is not specific to algorithm, but more for corner case.\\n\\nUse recursion, but it is slower than while loop."
                    }
                ]
            },
            {
                "id": 1732851,
                "content": [
                    {
                        "username": "Rahul_108",
                        "content": "Mood Off  :(\\nx = 0.00001\\nn = 2147483647"
                    },
                    {
                        "username": "RishabhMishra2710",
                        "content": "Someone just hates society \\nn = INT_MIN & x = 1.0000000000001 wtf !!"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "binary exponentiation  :)\\njust a little clue!"
                    },
                    {
                        "username": "Rishipandey14",
                        "content": "return x**n"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "When interviewer has personal issues with you"
                    },
                    {
                        "username": "psionl0",
                        "content": "Without giving too much away (the editorial does that) one way to deal with the edge cases where n = -2147483648 is as follows:\n```\n   if (n < 0) {\n       return myPow(1 / x, -(n+1)) / x;\n   } . . .\n```\nIf you are coding an iterative solution then you can deal with the edge case like this:\n```\n   double div = 1.0, result = 1.0;\n   if (n < 0) {\n       div = x;\n       x = 1/x;\n       n = -(n+1);\n   } . . .\n```\nAt the end of the computations, return ``result / div``."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Changing the arguments like that is cheating. Since the arguments are a double and an integer, these are what we have to work with (although you can cast the integer into a double if you are not using recursion)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) Or you can just promote the exponent's type to a long, and virtually the same binary exponentiation algorithm will still work https://leetcode.com/problems/powx-n/submissions/1002575265/"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@charonme](/charonme) Fancy that! Thanks for that edge case. I have now deleted my edit."
                    },
                    {
                        "username": "charonme",
                        "content": "except 1.0000000000001 ^ (-2147483648) expects 0.99979"
                    },
                    {
                        "username": "supervaka",
                        "content": "is there a similar implement log(b, x) kind of problem?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "y4cj4sul3",
                        "content": "I was just testing some cases using C++ and accidentally found something weird when I do `abs()` on the input argument `n` when `n = -2147483648`. \\n\\nThe expected return value of `abs(INT_MIN)` should be `INT_MIN` because of the 2\\'s complement representation, and I did get `-2147483648` as I printed `abs(n)` out. However, when I try to divide `n` by 2 after that, I got `1073741824`  instead of `-1073741824`.\\n\\nSo I try out several things as shown in the picture below. It seems that `n` is actually converted to positive by `abs()` but in a 64-bit manner.\\n\\n![image](https://assets.leetcode.com/users/images/16ee1a6c-6168-4f7b-8ef7-379dd32d9ace_1648312777.6464503.png)\\n\\nHowever, if one assigns `INT_MIN` to `n` in the code rather than in the leetcode console, it becomes normal as what `a` behaved in the picture. Also, I test it out on my computer and everything works fine. So I guess the problem is happening when the leetcode feeds testcases from the console to the code. Any idea of that?"
                    },
                    {
                        "username": "yuv",
                        "content": "Well, I\\'ve got the reason behind the weirdness. It\\'s lied in the range of a signed integer. The range is [-2147483648 to 2147483647]. So, if we try to do the `abs()` operation on the `INT_MIN` then it won\\'t be possible to fit in `int` range. Because the INT_MAX value is one less than that. To avoid it you must store the power value in a `long` type variable. Then it would behave normally."
                    },
                    {
                        "username": "yuv",
                        "content": "It\\'s weird behavior. It\\'s still showing `n` as negative after `abs()` operation. But it is returning true for the `n > 0` condition. "
                    },
                    {
                        "username": "yixuan5",
                        "content": "It is not specific to algorithm, but more for corner case.\\n\\nUse recursion, but it is slower than while loop."
                    }
                ]
            },
            {
                "id": 1576550,
                "content": [
                    {
                        "username": "Rahul_108",
                        "content": "Mood Off  :(\\nx = 0.00001\\nn = 2147483647"
                    },
                    {
                        "username": "RishabhMishra2710",
                        "content": "Someone just hates society \\nn = INT_MIN & x = 1.0000000000001 wtf !!"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "binary exponentiation  :)\\njust a little clue!"
                    },
                    {
                        "username": "Rishipandey14",
                        "content": "return x**n"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "When interviewer has personal issues with you"
                    },
                    {
                        "username": "psionl0",
                        "content": "Without giving too much away (the editorial does that) one way to deal with the edge cases where n = -2147483648 is as follows:\n```\n   if (n < 0) {\n       return myPow(1 / x, -(n+1)) / x;\n   } . . .\n```\nIf you are coding an iterative solution then you can deal with the edge case like this:\n```\n   double div = 1.0, result = 1.0;\n   if (n < 0) {\n       div = x;\n       x = 1/x;\n       n = -(n+1);\n   } . . .\n```\nAt the end of the computations, return ``result / div``."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Changing the arguments like that is cheating. Since the arguments are a double and an integer, these are what we have to work with (although you can cast the integer into a double if you are not using recursion)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) Or you can just promote the exponent's type to a long, and virtually the same binary exponentiation algorithm will still work https://leetcode.com/problems/powx-n/submissions/1002575265/"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@charonme](/charonme) Fancy that! Thanks for that edge case. I have now deleted my edit."
                    },
                    {
                        "username": "charonme",
                        "content": "except 1.0000000000001 ^ (-2147483648) expects 0.99979"
                    },
                    {
                        "username": "supervaka",
                        "content": "is there a similar implement log(b, x) kind of problem?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "y4cj4sul3",
                        "content": "I was just testing some cases using C++ and accidentally found something weird when I do `abs()` on the input argument `n` when `n = -2147483648`. \\n\\nThe expected return value of `abs(INT_MIN)` should be `INT_MIN` because of the 2\\'s complement representation, and I did get `-2147483648` as I printed `abs(n)` out. However, when I try to divide `n` by 2 after that, I got `1073741824`  instead of `-1073741824`.\\n\\nSo I try out several things as shown in the picture below. It seems that `n` is actually converted to positive by `abs()` but in a 64-bit manner.\\n\\n![image](https://assets.leetcode.com/users/images/16ee1a6c-6168-4f7b-8ef7-379dd32d9ace_1648312777.6464503.png)\\n\\nHowever, if one assigns `INT_MIN` to `n` in the code rather than in the leetcode console, it becomes normal as what `a` behaved in the picture. Also, I test it out on my computer and everything works fine. So I guess the problem is happening when the leetcode feeds testcases from the console to the code. Any idea of that?"
                    },
                    {
                        "username": "yuv",
                        "content": "Well, I\\'ve got the reason behind the weirdness. It\\'s lied in the range of a signed integer. The range is [-2147483648 to 2147483647]. So, if we try to do the `abs()` operation on the `INT_MIN` then it won\\'t be possible to fit in `int` range. Because the INT_MAX value is one less than that. To avoid it you must store the power value in a `long` type variable. Then it would behave normally."
                    },
                    {
                        "username": "yuv",
                        "content": "It\\'s weird behavior. It\\'s still showing `n` as negative after `abs()` operation. But it is returning true for the `n > 0` condition. "
                    },
                    {
                        "username": "yixuan5",
                        "content": "It is not specific to algorithm, but more for corner case.\\n\\nUse recursion, but it is slower than while loop."
                    }
                ]
            },
            {
                "id": 1573585,
                "content": [
                    {
                        "username": "Rahul_108",
                        "content": "Mood Off  :(\\nx = 0.00001\\nn = 2147483647"
                    },
                    {
                        "username": "RishabhMishra2710",
                        "content": "Someone just hates society \\nn = INT_MIN & x = 1.0000000000001 wtf !!"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "binary exponentiation  :)\\njust a little clue!"
                    },
                    {
                        "username": "Rishipandey14",
                        "content": "return x**n"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "When interviewer has personal issues with you"
                    },
                    {
                        "username": "psionl0",
                        "content": "Without giving too much away (the editorial does that) one way to deal with the edge cases where n = -2147483648 is as follows:\n```\n   if (n < 0) {\n       return myPow(1 / x, -(n+1)) / x;\n   } . . .\n```\nIf you are coding an iterative solution then you can deal with the edge case like this:\n```\n   double div = 1.0, result = 1.0;\n   if (n < 0) {\n       div = x;\n       x = 1/x;\n       n = -(n+1);\n   } . . .\n```\nAt the end of the computations, return ``result / div``."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Changing the arguments like that is cheating. Since the arguments are a double and an integer, these are what we have to work with (although you can cast the integer into a double if you are not using recursion)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) Or you can just promote the exponent's type to a long, and virtually the same binary exponentiation algorithm will still work https://leetcode.com/problems/powx-n/submissions/1002575265/"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@charonme](/charonme) Fancy that! Thanks for that edge case. I have now deleted my edit."
                    },
                    {
                        "username": "charonme",
                        "content": "except 1.0000000000001 ^ (-2147483648) expects 0.99979"
                    },
                    {
                        "username": "supervaka",
                        "content": "is there a similar implement log(b, x) kind of problem?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/powx-n/solutions/2966997/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "y4cj4sul3",
                        "content": "I was just testing some cases using C++ and accidentally found something weird when I do `abs()` on the input argument `n` when `n = -2147483648`. \\n\\nThe expected return value of `abs(INT_MIN)` should be `INT_MIN` because of the 2\\'s complement representation, and I did get `-2147483648` as I printed `abs(n)` out. However, when I try to divide `n` by 2 after that, I got `1073741824`  instead of `-1073741824`.\\n\\nSo I try out several things as shown in the picture below. It seems that `n` is actually converted to positive by `abs()` but in a 64-bit manner.\\n\\n![image](https://assets.leetcode.com/users/images/16ee1a6c-6168-4f7b-8ef7-379dd32d9ace_1648312777.6464503.png)\\n\\nHowever, if one assigns `INT_MIN` to `n` in the code rather than in the leetcode console, it becomes normal as what `a` behaved in the picture. Also, I test it out on my computer and everything works fine. So I guess the problem is happening when the leetcode feeds testcases from the console to the code. Any idea of that?"
                    },
                    {
                        "username": "yuv",
                        "content": "Well, I\\'ve got the reason behind the weirdness. It\\'s lied in the range of a signed integer. The range is [-2147483648 to 2147483647]. So, if we try to do the `abs()` operation on the `INT_MIN` then it won\\'t be possible to fit in `int` range. Because the INT_MAX value is one less than that. To avoid it you must store the power value in a `long` type variable. Then it would behave normally."
                    },
                    {
                        "username": "yuv",
                        "content": "It\\'s weird behavior. It\\'s still showing `n` as negative after `abs()` operation. But it is returning true for the `n > 0` condition. "
                    },
                    {
                        "username": "yixuan5",
                        "content": "It is not specific to algorithm, but more for corner case.\\n\\nUse recursion, but it is slower than while loop."
                    }
                ]
            },
            {
                "id": 1571124,
                "content": [
                    {
                        "username": "taozhuo",
                        "content": "This is Divide and Conquer. Just saying."
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "Any ideas why this question has so many dislikes?"
                    },
                    {
                        "username": "PentaMa",
                        "content": "It doesn\\'t tell us how exactly we should implement this `myPow` but just wants the answer, and that makes a lot of people simply use the built-in methods such as Math.pow()"
                    },
                    {
                        "username": "rexhu100",
                        "content": "I think it\\'s time that the LC team take a comprehensive look at how they evaluate the difficulty rating of the problems."
                    },
                    {
                        "username": "user7478F",
                        "content": "I don\\'t understand why it\\'s only 33% acceptance, it\\'s not even medium, its basic if all that\\'s what we have to do ,we\\'re just asked to implement pow function which returns x raised to power n."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Did you just return x^n or pow(x, n)? That\\'s not really implementing the power function but using a built in. Thats like being asked to write a sorting function for A and responding \"return sorted(A)\". You\\'ve missed the entire point of the exercise. Try computing the squares *without* using a function that does it for you. "
                    },
                    {
                        "username": "superljw",
                        "content": "this is not a good problem, if run code with 0.0/0, the result will be 1.\\nif 0.0/0, then 1=2.\\n\\n0*1=0;\\n0*2=0;\\n=>0*1=0*2\\n=>0/0 *1=2\\n=>1=2\\n\\n"
                    },
                    {
                        "username": "tgrhp",
                        "content": "My code fails the following test:\\n\\nInput:\\t-1.00000, -2147483648\\nOutput:\\t-1.00000\\nExpected:\\t1.00000\\n\\nWhy is this the wrong output?\\n\\n\\nEdit:\\nThanks for answering (-1)^2=1, I realized that after I posted the question..."
                    },
                    {
                        "username": "Thetensordude",
                        "content": "SOLUTION AHEAD!!!\\n\\nNeed advice!\\n\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n == 0: return 1\\n        elif n == 1:    return x\\n        else:\\n            if n % 2 == 0:\\n                potential = (x ** (n // 2))\\n                return potential * potential\\n            else:\\n                pot = (x ** (n // 2))\\n                return pot * pot * x\\n        \\n\\nIs this a valid solution? I think it is too easy for medium level for recursion is the way?"
                    },
                    {
                        "username": "leetcode_tusharlokare",
                        "content": "the answer is straight forward, in python use \\'**\\' operator to find out the power of number."
                    },
                    {
                        "username": "AYUSH-KATRE",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n    if(n==0){\\n        return 1;\\n    }\\n    if(n==1){\\n        return x;\\n    }\\n    double ans = myPow(x,n/2);\\n    if(n&1){\\n        return x*ans*ans;\\n    }\\n    if(n<0){\\n        return 1/(ans*ans);\\n    }\\n    else{\\n        return ans*ans;\\n    }\\n    }\\n};\\n\\nplease help ans is write but for big numbers ans is  not in power of 10 how can i convert it"
                    },
                    {
                        "username": "shetevrushabh77",
                        "content": "Talented me using simple code:\\nMath.pow(x,n);"
                    }
                ]
            },
            {
                "id": 1576095,
                "content": [
                    {
                        "username": "taozhuo",
                        "content": "This is Divide and Conquer. Just saying."
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "Any ideas why this question has so many dislikes?"
                    },
                    {
                        "username": "PentaMa",
                        "content": "It doesn\\'t tell us how exactly we should implement this `myPow` but just wants the answer, and that makes a lot of people simply use the built-in methods such as Math.pow()"
                    },
                    {
                        "username": "rexhu100",
                        "content": "I think it\\'s time that the LC team take a comprehensive look at how they evaluate the difficulty rating of the problems."
                    },
                    {
                        "username": "user7478F",
                        "content": "I don\\'t understand why it\\'s only 33% acceptance, it\\'s not even medium, its basic if all that\\'s what we have to do ,we\\'re just asked to implement pow function which returns x raised to power n."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Did you just return x^n or pow(x, n)? That\\'s not really implementing the power function but using a built in. Thats like being asked to write a sorting function for A and responding \"return sorted(A)\". You\\'ve missed the entire point of the exercise. Try computing the squares *without* using a function that does it for you. "
                    },
                    {
                        "username": "superljw",
                        "content": "this is not a good problem, if run code with 0.0/0, the result will be 1.\\nif 0.0/0, then 1=2.\\n\\n0*1=0;\\n0*2=0;\\n=>0*1=0*2\\n=>0/0 *1=2\\n=>1=2\\n\\n"
                    },
                    {
                        "username": "tgrhp",
                        "content": "My code fails the following test:\\n\\nInput:\\t-1.00000, -2147483648\\nOutput:\\t-1.00000\\nExpected:\\t1.00000\\n\\nWhy is this the wrong output?\\n\\n\\nEdit:\\nThanks for answering (-1)^2=1, I realized that after I posted the question..."
                    },
                    {
                        "username": "Thetensordude",
                        "content": "SOLUTION AHEAD!!!\\n\\nNeed advice!\\n\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n == 0: return 1\\n        elif n == 1:    return x\\n        else:\\n            if n % 2 == 0:\\n                potential = (x ** (n // 2))\\n                return potential * potential\\n            else:\\n                pot = (x ** (n // 2))\\n                return pot * pot * x\\n        \\n\\nIs this a valid solution? I think it is too easy for medium level for recursion is the way?"
                    },
                    {
                        "username": "leetcode_tusharlokare",
                        "content": "the answer is straight forward, in python use \\'**\\' operator to find out the power of number."
                    },
                    {
                        "username": "AYUSH-KATRE",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n    if(n==0){\\n        return 1;\\n    }\\n    if(n==1){\\n        return x;\\n    }\\n    double ans = myPow(x,n/2);\\n    if(n&1){\\n        return x*ans*ans;\\n    }\\n    if(n<0){\\n        return 1/(ans*ans);\\n    }\\n    else{\\n        return ans*ans;\\n    }\\n    }\\n};\\n\\nplease help ans is write but for big numbers ans is  not in power of 10 how can i convert it"
                    },
                    {
                        "username": "shetevrushabh77",
                        "content": "Talented me using simple code:\\nMath.pow(x,n);"
                    }
                ]
            },
            {
                "id": 1574142,
                "content": [
                    {
                        "username": "taozhuo",
                        "content": "This is Divide and Conquer. Just saying."
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "Any ideas why this question has so many dislikes?"
                    },
                    {
                        "username": "PentaMa",
                        "content": "It doesn\\'t tell us how exactly we should implement this `myPow` but just wants the answer, and that makes a lot of people simply use the built-in methods such as Math.pow()"
                    },
                    {
                        "username": "rexhu100",
                        "content": "I think it\\'s time that the LC team take a comprehensive look at how they evaluate the difficulty rating of the problems."
                    },
                    {
                        "username": "user7478F",
                        "content": "I don\\'t understand why it\\'s only 33% acceptance, it\\'s not even medium, its basic if all that\\'s what we have to do ,we\\'re just asked to implement pow function which returns x raised to power n."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Did you just return x^n or pow(x, n)? That\\'s not really implementing the power function but using a built in. Thats like being asked to write a sorting function for A and responding \"return sorted(A)\". You\\'ve missed the entire point of the exercise. Try computing the squares *without* using a function that does it for you. "
                    },
                    {
                        "username": "superljw",
                        "content": "this is not a good problem, if run code with 0.0/0, the result will be 1.\\nif 0.0/0, then 1=2.\\n\\n0*1=0;\\n0*2=0;\\n=>0*1=0*2\\n=>0/0 *1=2\\n=>1=2\\n\\n"
                    },
                    {
                        "username": "tgrhp",
                        "content": "My code fails the following test:\\n\\nInput:\\t-1.00000, -2147483648\\nOutput:\\t-1.00000\\nExpected:\\t1.00000\\n\\nWhy is this the wrong output?\\n\\n\\nEdit:\\nThanks for answering (-1)^2=1, I realized that after I posted the question..."
                    },
                    {
                        "username": "Thetensordude",
                        "content": "SOLUTION AHEAD!!!\\n\\nNeed advice!\\n\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n == 0: return 1\\n        elif n == 1:    return x\\n        else:\\n            if n % 2 == 0:\\n                potential = (x ** (n // 2))\\n                return potential * potential\\n            else:\\n                pot = (x ** (n // 2))\\n                return pot * pot * x\\n        \\n\\nIs this a valid solution? I think it is too easy for medium level for recursion is the way?"
                    },
                    {
                        "username": "leetcode_tusharlokare",
                        "content": "the answer is straight forward, in python use \\'**\\' operator to find out the power of number."
                    },
                    {
                        "username": "AYUSH-KATRE",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n    if(n==0){\\n        return 1;\\n    }\\n    if(n==1){\\n        return x;\\n    }\\n    double ans = myPow(x,n/2);\\n    if(n&1){\\n        return x*ans*ans;\\n    }\\n    if(n<0){\\n        return 1/(ans*ans);\\n    }\\n    else{\\n        return ans*ans;\\n    }\\n    }\\n};\\n\\nplease help ans is write but for big numbers ans is  not in power of 10 how can i convert it"
                    },
                    {
                        "username": "shetevrushabh77",
                        "content": "Talented me using simple code:\\nMath.pow(x,n);"
                    }
                ]
            },
            {
                "id": 1983754,
                "content": [
                    {
                        "username": "taozhuo",
                        "content": "This is Divide and Conquer. Just saying."
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "Any ideas why this question has so many dislikes?"
                    },
                    {
                        "username": "PentaMa",
                        "content": "It doesn\\'t tell us how exactly we should implement this `myPow` but just wants the answer, and that makes a lot of people simply use the built-in methods such as Math.pow()"
                    },
                    {
                        "username": "rexhu100",
                        "content": "I think it\\'s time that the LC team take a comprehensive look at how they evaluate the difficulty rating of the problems."
                    },
                    {
                        "username": "user7478F",
                        "content": "I don\\'t understand why it\\'s only 33% acceptance, it\\'s not even medium, its basic if all that\\'s what we have to do ,we\\'re just asked to implement pow function which returns x raised to power n."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Did you just return x^n or pow(x, n)? That\\'s not really implementing the power function but using a built in. Thats like being asked to write a sorting function for A and responding \"return sorted(A)\". You\\'ve missed the entire point of the exercise. Try computing the squares *without* using a function that does it for you. "
                    },
                    {
                        "username": "superljw",
                        "content": "this is not a good problem, if run code with 0.0/0, the result will be 1.\\nif 0.0/0, then 1=2.\\n\\n0*1=0;\\n0*2=0;\\n=>0*1=0*2\\n=>0/0 *1=2\\n=>1=2\\n\\n"
                    },
                    {
                        "username": "tgrhp",
                        "content": "My code fails the following test:\\n\\nInput:\\t-1.00000, -2147483648\\nOutput:\\t-1.00000\\nExpected:\\t1.00000\\n\\nWhy is this the wrong output?\\n\\n\\nEdit:\\nThanks for answering (-1)^2=1, I realized that after I posted the question..."
                    },
                    {
                        "username": "Thetensordude",
                        "content": "SOLUTION AHEAD!!!\\n\\nNeed advice!\\n\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n == 0: return 1\\n        elif n == 1:    return x\\n        else:\\n            if n % 2 == 0:\\n                potential = (x ** (n // 2))\\n                return potential * potential\\n            else:\\n                pot = (x ** (n // 2))\\n                return pot * pot * x\\n        \\n\\nIs this a valid solution? I think it is too easy for medium level for recursion is the way?"
                    },
                    {
                        "username": "leetcode_tusharlokare",
                        "content": "the answer is straight forward, in python use \\'**\\' operator to find out the power of number."
                    },
                    {
                        "username": "AYUSH-KATRE",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n    if(n==0){\\n        return 1;\\n    }\\n    if(n==1){\\n        return x;\\n    }\\n    double ans = myPow(x,n/2);\\n    if(n&1){\\n        return x*ans*ans;\\n    }\\n    if(n<0){\\n        return 1/(ans*ans);\\n    }\\n    else{\\n        return ans*ans;\\n    }\\n    }\\n};\\n\\nplease help ans is write but for big numbers ans is  not in power of 10 how can i convert it"
                    },
                    {
                        "username": "shetevrushabh77",
                        "content": "Talented me using simple code:\\nMath.pow(x,n);"
                    }
                ]
            },
            {
                "id": 1572749,
                "content": [
                    {
                        "username": "taozhuo",
                        "content": "This is Divide and Conquer. Just saying."
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "Any ideas why this question has so many dislikes?"
                    },
                    {
                        "username": "PentaMa",
                        "content": "It doesn\\'t tell us how exactly we should implement this `myPow` but just wants the answer, and that makes a lot of people simply use the built-in methods such as Math.pow()"
                    },
                    {
                        "username": "rexhu100",
                        "content": "I think it\\'s time that the LC team take a comprehensive look at how they evaluate the difficulty rating of the problems."
                    },
                    {
                        "username": "user7478F",
                        "content": "I don\\'t understand why it\\'s only 33% acceptance, it\\'s not even medium, its basic if all that\\'s what we have to do ,we\\'re just asked to implement pow function which returns x raised to power n."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Did you just return x^n or pow(x, n)? That\\'s not really implementing the power function but using a built in. Thats like being asked to write a sorting function for A and responding \"return sorted(A)\". You\\'ve missed the entire point of the exercise. Try computing the squares *without* using a function that does it for you. "
                    },
                    {
                        "username": "superljw",
                        "content": "this is not a good problem, if run code with 0.0/0, the result will be 1.\\nif 0.0/0, then 1=2.\\n\\n0*1=0;\\n0*2=0;\\n=>0*1=0*2\\n=>0/0 *1=2\\n=>1=2\\n\\n"
                    },
                    {
                        "username": "tgrhp",
                        "content": "My code fails the following test:\\n\\nInput:\\t-1.00000, -2147483648\\nOutput:\\t-1.00000\\nExpected:\\t1.00000\\n\\nWhy is this the wrong output?\\n\\n\\nEdit:\\nThanks for answering (-1)^2=1, I realized that after I posted the question..."
                    },
                    {
                        "username": "Thetensordude",
                        "content": "SOLUTION AHEAD!!!\\n\\nNeed advice!\\n\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n == 0: return 1\\n        elif n == 1:    return x\\n        else:\\n            if n % 2 == 0:\\n                potential = (x ** (n // 2))\\n                return potential * potential\\n            else:\\n                pot = (x ** (n // 2))\\n                return pot * pot * x\\n        \\n\\nIs this a valid solution? I think it is too easy for medium level for recursion is the way?"
                    },
                    {
                        "username": "leetcode_tusharlokare",
                        "content": "the answer is straight forward, in python use \\'**\\' operator to find out the power of number."
                    },
                    {
                        "username": "AYUSH-KATRE",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n    if(n==0){\\n        return 1;\\n    }\\n    if(n==1){\\n        return x;\\n    }\\n    double ans = myPow(x,n/2);\\n    if(n&1){\\n        return x*ans*ans;\\n    }\\n    if(n<0){\\n        return 1/(ans*ans);\\n    }\\n    else{\\n        return ans*ans;\\n    }\\n    }\\n};\\n\\nplease help ans is write but for big numbers ans is  not in power of 10 how can i convert it"
                    },
                    {
                        "username": "shetevrushabh77",
                        "content": "Talented me using simple code:\\nMath.pow(x,n);"
                    }
                ]
            },
            {
                "id": 1571125,
                "content": [
                    {
                        "username": "taozhuo",
                        "content": "This is Divide and Conquer. Just saying."
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "Any ideas why this question has so many dislikes?"
                    },
                    {
                        "username": "PentaMa",
                        "content": "It doesn\\'t tell us how exactly we should implement this `myPow` but just wants the answer, and that makes a lot of people simply use the built-in methods such as Math.pow()"
                    },
                    {
                        "username": "rexhu100",
                        "content": "I think it\\'s time that the LC team take a comprehensive look at how they evaluate the difficulty rating of the problems."
                    },
                    {
                        "username": "user7478F",
                        "content": "I don\\'t understand why it\\'s only 33% acceptance, it\\'s not even medium, its basic if all that\\'s what we have to do ,we\\'re just asked to implement pow function which returns x raised to power n."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Did you just return x^n or pow(x, n)? That\\'s not really implementing the power function but using a built in. Thats like being asked to write a sorting function for A and responding \"return sorted(A)\". You\\'ve missed the entire point of the exercise. Try computing the squares *without* using a function that does it for you. "
                    },
                    {
                        "username": "superljw",
                        "content": "this is not a good problem, if run code with 0.0/0, the result will be 1.\\nif 0.0/0, then 1=2.\\n\\n0*1=0;\\n0*2=0;\\n=>0*1=0*2\\n=>0/0 *1=2\\n=>1=2\\n\\n"
                    },
                    {
                        "username": "tgrhp",
                        "content": "My code fails the following test:\\n\\nInput:\\t-1.00000, -2147483648\\nOutput:\\t-1.00000\\nExpected:\\t1.00000\\n\\nWhy is this the wrong output?\\n\\n\\nEdit:\\nThanks for answering (-1)^2=1, I realized that after I posted the question..."
                    },
                    {
                        "username": "Thetensordude",
                        "content": "SOLUTION AHEAD!!!\\n\\nNeed advice!\\n\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n == 0: return 1\\n        elif n == 1:    return x\\n        else:\\n            if n % 2 == 0:\\n                potential = (x ** (n // 2))\\n                return potential * potential\\n            else:\\n                pot = (x ** (n // 2))\\n                return pot * pot * x\\n        \\n\\nIs this a valid solution? I think it is too easy for medium level for recursion is the way?"
                    },
                    {
                        "username": "leetcode_tusharlokare",
                        "content": "the answer is straight forward, in python use \\'**\\' operator to find out the power of number."
                    },
                    {
                        "username": "AYUSH-KATRE",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n    if(n==0){\\n        return 1;\\n    }\\n    if(n==1){\\n        return x;\\n    }\\n    double ans = myPow(x,n/2);\\n    if(n&1){\\n        return x*ans*ans;\\n    }\\n    if(n<0){\\n        return 1/(ans*ans);\\n    }\\n    else{\\n        return ans*ans;\\n    }\\n    }\\n};\\n\\nplease help ans is write but for big numbers ans is  not in power of 10 how can i convert it"
                    },
                    {
                        "username": "shetevrushabh77",
                        "content": "Talented me using simple code:\\nMath.pow(x,n);"
                    }
                ]
            },
            {
                "id": 2076722,
                "content": [
                    {
                        "username": "taozhuo",
                        "content": "This is Divide and Conquer. Just saying."
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "Any ideas why this question has so many dislikes?"
                    },
                    {
                        "username": "PentaMa",
                        "content": "It doesn\\'t tell us how exactly we should implement this `myPow` but just wants the answer, and that makes a lot of people simply use the built-in methods such as Math.pow()"
                    },
                    {
                        "username": "rexhu100",
                        "content": "I think it\\'s time that the LC team take a comprehensive look at how they evaluate the difficulty rating of the problems."
                    },
                    {
                        "username": "user7478F",
                        "content": "I don\\'t understand why it\\'s only 33% acceptance, it\\'s not even medium, its basic if all that\\'s what we have to do ,we\\'re just asked to implement pow function which returns x raised to power n."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Did you just return x^n or pow(x, n)? That\\'s not really implementing the power function but using a built in. Thats like being asked to write a sorting function for A and responding \"return sorted(A)\". You\\'ve missed the entire point of the exercise. Try computing the squares *without* using a function that does it for you. "
                    },
                    {
                        "username": "superljw",
                        "content": "this is not a good problem, if run code with 0.0/0, the result will be 1.\\nif 0.0/0, then 1=2.\\n\\n0*1=0;\\n0*2=0;\\n=>0*1=0*2\\n=>0/0 *1=2\\n=>1=2\\n\\n"
                    },
                    {
                        "username": "tgrhp",
                        "content": "My code fails the following test:\\n\\nInput:\\t-1.00000, -2147483648\\nOutput:\\t-1.00000\\nExpected:\\t1.00000\\n\\nWhy is this the wrong output?\\n\\n\\nEdit:\\nThanks for answering (-1)^2=1, I realized that after I posted the question..."
                    },
                    {
                        "username": "Thetensordude",
                        "content": "SOLUTION AHEAD!!!\\n\\nNeed advice!\\n\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n == 0: return 1\\n        elif n == 1:    return x\\n        else:\\n            if n % 2 == 0:\\n                potential = (x ** (n // 2))\\n                return potential * potential\\n            else:\\n                pot = (x ** (n // 2))\\n                return pot * pot * x\\n        \\n\\nIs this a valid solution? I think it is too easy for medium level for recursion is the way?"
                    },
                    {
                        "username": "leetcode_tusharlokare",
                        "content": "the answer is straight forward, in python use \\'**\\' operator to find out the power of number."
                    },
                    {
                        "username": "AYUSH-KATRE",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n    if(n==0){\\n        return 1;\\n    }\\n    if(n==1){\\n        return x;\\n    }\\n    double ans = myPow(x,n/2);\\n    if(n&1){\\n        return x*ans*ans;\\n    }\\n    if(n<0){\\n        return 1/(ans*ans);\\n    }\\n    else{\\n        return ans*ans;\\n    }\\n    }\\n};\\n\\nplease help ans is write but for big numbers ans is  not in power of 10 how can i convert it"
                    },
                    {
                        "username": "shetevrushabh77",
                        "content": "Talented me using simple code:\\nMath.pow(x,n);"
                    }
                ]
            },
            {
                "id": 2071070,
                "content": [
                    {
                        "username": "taozhuo",
                        "content": "This is Divide and Conquer. Just saying."
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "Any ideas why this question has so many dislikes?"
                    },
                    {
                        "username": "PentaMa",
                        "content": "It doesn\\'t tell us how exactly we should implement this `myPow` but just wants the answer, and that makes a lot of people simply use the built-in methods such as Math.pow()"
                    },
                    {
                        "username": "rexhu100",
                        "content": "I think it\\'s time that the LC team take a comprehensive look at how they evaluate the difficulty rating of the problems."
                    },
                    {
                        "username": "user7478F",
                        "content": "I don\\'t understand why it\\'s only 33% acceptance, it\\'s not even medium, its basic if all that\\'s what we have to do ,we\\'re just asked to implement pow function which returns x raised to power n."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Did you just return x^n or pow(x, n)? That\\'s not really implementing the power function but using a built in. Thats like being asked to write a sorting function for A and responding \"return sorted(A)\". You\\'ve missed the entire point of the exercise. Try computing the squares *without* using a function that does it for you. "
                    },
                    {
                        "username": "superljw",
                        "content": "this is not a good problem, if run code with 0.0/0, the result will be 1.\\nif 0.0/0, then 1=2.\\n\\n0*1=0;\\n0*2=0;\\n=>0*1=0*2\\n=>0/0 *1=2\\n=>1=2\\n\\n"
                    },
                    {
                        "username": "tgrhp",
                        "content": "My code fails the following test:\\n\\nInput:\\t-1.00000, -2147483648\\nOutput:\\t-1.00000\\nExpected:\\t1.00000\\n\\nWhy is this the wrong output?\\n\\n\\nEdit:\\nThanks for answering (-1)^2=1, I realized that after I posted the question..."
                    },
                    {
                        "username": "Thetensordude",
                        "content": "SOLUTION AHEAD!!!\\n\\nNeed advice!\\n\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n == 0: return 1\\n        elif n == 1:    return x\\n        else:\\n            if n % 2 == 0:\\n                potential = (x ** (n // 2))\\n                return potential * potential\\n            else:\\n                pot = (x ** (n // 2))\\n                return pot * pot * x\\n        \\n\\nIs this a valid solution? I think it is too easy for medium level for recursion is the way?"
                    },
                    {
                        "username": "leetcode_tusharlokare",
                        "content": "the answer is straight forward, in python use \\'**\\' operator to find out the power of number."
                    },
                    {
                        "username": "AYUSH-KATRE",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n    if(n==0){\\n        return 1;\\n    }\\n    if(n==1){\\n        return x;\\n    }\\n    double ans = myPow(x,n/2);\\n    if(n&1){\\n        return x*ans*ans;\\n    }\\n    if(n<0){\\n        return 1/(ans*ans);\\n    }\\n    else{\\n        return ans*ans;\\n    }\\n    }\\n};\\n\\nplease help ans is write but for big numbers ans is  not in power of 10 how can i convert it"
                    },
                    {
                        "username": "shetevrushabh77",
                        "content": "Talented me using simple code:\\nMath.pow(x,n);"
                    }
                ]
            },
            {
                "id": 2070614,
                "content": [
                    {
                        "username": "taozhuo",
                        "content": "This is Divide and Conquer. Just saying."
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "Any ideas why this question has so many dislikes?"
                    },
                    {
                        "username": "PentaMa",
                        "content": "It doesn\\'t tell us how exactly we should implement this `myPow` but just wants the answer, and that makes a lot of people simply use the built-in methods such as Math.pow()"
                    },
                    {
                        "username": "rexhu100",
                        "content": "I think it\\'s time that the LC team take a comprehensive look at how they evaluate the difficulty rating of the problems."
                    },
                    {
                        "username": "user7478F",
                        "content": "I don\\'t understand why it\\'s only 33% acceptance, it\\'s not even medium, its basic if all that\\'s what we have to do ,we\\'re just asked to implement pow function which returns x raised to power n."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Did you just return x^n or pow(x, n)? That\\'s not really implementing the power function but using a built in. Thats like being asked to write a sorting function for A and responding \"return sorted(A)\". You\\'ve missed the entire point of the exercise. Try computing the squares *without* using a function that does it for you. "
                    },
                    {
                        "username": "superljw",
                        "content": "this is not a good problem, if run code with 0.0/0, the result will be 1.\\nif 0.0/0, then 1=2.\\n\\n0*1=0;\\n0*2=0;\\n=>0*1=0*2\\n=>0/0 *1=2\\n=>1=2\\n\\n"
                    },
                    {
                        "username": "tgrhp",
                        "content": "My code fails the following test:\\n\\nInput:\\t-1.00000, -2147483648\\nOutput:\\t-1.00000\\nExpected:\\t1.00000\\n\\nWhy is this the wrong output?\\n\\n\\nEdit:\\nThanks for answering (-1)^2=1, I realized that after I posted the question..."
                    },
                    {
                        "username": "Thetensordude",
                        "content": "SOLUTION AHEAD!!!\\n\\nNeed advice!\\n\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n == 0: return 1\\n        elif n == 1:    return x\\n        else:\\n            if n % 2 == 0:\\n                potential = (x ** (n // 2))\\n                return potential * potential\\n            else:\\n                pot = (x ** (n // 2))\\n                return pot * pot * x\\n        \\n\\nIs this a valid solution? I think it is too easy for medium level for recursion is the way?"
                    },
                    {
                        "username": "leetcode_tusharlokare",
                        "content": "the answer is straight forward, in python use \\'**\\' operator to find out the power of number."
                    },
                    {
                        "username": "AYUSH-KATRE",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n    if(n==0){\\n        return 1;\\n    }\\n    if(n==1){\\n        return x;\\n    }\\n    double ans = myPow(x,n/2);\\n    if(n&1){\\n        return x*ans*ans;\\n    }\\n    if(n<0){\\n        return 1/(ans*ans);\\n    }\\n    else{\\n        return ans*ans;\\n    }\\n    }\\n};\\n\\nplease help ans is write but for big numbers ans is  not in power of 10 how can i convert it"
                    },
                    {
                        "username": "shetevrushabh77",
                        "content": "Talented me using simple code:\\nMath.pow(x,n);"
                    }
                ]
            },
            {
                "id": 2067334,
                "content": [
                    {
                        "username": "taozhuo",
                        "content": "This is Divide and Conquer. Just saying."
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "Any ideas why this question has so many dislikes?"
                    },
                    {
                        "username": "PentaMa",
                        "content": "It doesn\\'t tell us how exactly we should implement this `myPow` but just wants the answer, and that makes a lot of people simply use the built-in methods such as Math.pow()"
                    },
                    {
                        "username": "rexhu100",
                        "content": "I think it\\'s time that the LC team take a comprehensive look at how they evaluate the difficulty rating of the problems."
                    },
                    {
                        "username": "user7478F",
                        "content": "I don\\'t understand why it\\'s only 33% acceptance, it\\'s not even medium, its basic if all that\\'s what we have to do ,we\\'re just asked to implement pow function which returns x raised to power n."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Did you just return x^n or pow(x, n)? That\\'s not really implementing the power function but using a built in. Thats like being asked to write a sorting function for A and responding \"return sorted(A)\". You\\'ve missed the entire point of the exercise. Try computing the squares *without* using a function that does it for you. "
                    },
                    {
                        "username": "superljw",
                        "content": "this is not a good problem, if run code with 0.0/0, the result will be 1.\\nif 0.0/0, then 1=2.\\n\\n0*1=0;\\n0*2=0;\\n=>0*1=0*2\\n=>0/0 *1=2\\n=>1=2\\n\\n"
                    },
                    {
                        "username": "tgrhp",
                        "content": "My code fails the following test:\\n\\nInput:\\t-1.00000, -2147483648\\nOutput:\\t-1.00000\\nExpected:\\t1.00000\\n\\nWhy is this the wrong output?\\n\\n\\nEdit:\\nThanks for answering (-1)^2=1, I realized that after I posted the question..."
                    },
                    {
                        "username": "Thetensordude",
                        "content": "SOLUTION AHEAD!!!\\n\\nNeed advice!\\n\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n == 0: return 1\\n        elif n == 1:    return x\\n        else:\\n            if n % 2 == 0:\\n                potential = (x ** (n // 2))\\n                return potential * potential\\n            else:\\n                pot = (x ** (n // 2))\\n                return pot * pot * x\\n        \\n\\nIs this a valid solution? I think it is too easy for medium level for recursion is the way?"
                    },
                    {
                        "username": "leetcode_tusharlokare",
                        "content": "the answer is straight forward, in python use \\'**\\' operator to find out the power of number."
                    },
                    {
                        "username": "AYUSH-KATRE",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n    if(n==0){\\n        return 1;\\n    }\\n    if(n==1){\\n        return x;\\n    }\\n    double ans = myPow(x,n/2);\\n    if(n&1){\\n        return x*ans*ans;\\n    }\\n    if(n<0){\\n        return 1/(ans*ans);\\n    }\\n    else{\\n        return ans*ans;\\n    }\\n    }\\n};\\n\\nplease help ans is write but for big numbers ans is  not in power of 10 how can i convert it"
                    },
                    {
                        "username": "shetevrushabh77",
                        "content": "Talented me using simple code:\\nMath.pow(x,n);"
                    }
                ]
            },
            {
                "id": 2066844,
                "content": [
                    {
                        "username": "Mr_Harshit_k",
                        "content": "i have an question why we are not using Math.pow(x,n) ?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Because the first two words of the problem statement explicitly ask you to implement it. It makes no sense to implement a function by calling itself."
                    },
                    {
                        "username": "aftabmk",
                        "content": "why pow even a question, since we have built in pow fn in cpp, and other modern language,maybe in the near future leetcode question might be like code Djikstra algorithm without using any coding language."
                    },
                    {
                        "username": "benjelplan",
                        "content": "why do any exercise on leetcode.com then since chatgpt can solve it in a few seconds? "
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "bhadwa ques"
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "this took so much time for the testcase (x=1.00000 and n=-2147483648) I still didnt get the \\ncode:\\npublic double myPow(double x, int n) {\\n        if(n<0){\\n            n=-n;\\n            return 1/(double)myPow(x,n);\\n        }\\n        if(n>0){\\n            if(n%2==0){\\n                return myPow(x*x,(n/2));\\n            }else{\\n                return x*myPow(x,n-1);\\n            }\\n        }\\n        return (double)1;\\n    }"
                    },
                    {
                        "username": "benjelplan",
                        "content": "Can somebody please explain to me how -2.00000 ^ 2 = 4.00000?\\nI think that -2^2 = -4 and that\\'s what happens in python as well if you enter -2**2\\n\\nthanks!"
                    },
                    {
                        "username": "benjelplan",
                        "content": "[@Kaltu](/Kaltu) Thanks for explaining! I thought that writing -2**2 meant the same thing as (-2)**2"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`-2**2` in python means `-(2**2)` but we are passing `-2` a function `def pow(x, n): return x ** n` and called by `pow(-2, 2)` it means `(-2) ** 2`\nmore information, search for `operator precedence`"
                    },
                    {
                        "username": "ishan_01",
                        "content": "This question must be marked easy, Give a single reason for marking it as Medium ?"
                    },
                    {
                        "username": "ishan_01",
                        "content": "[@Kaltu](/Kaltu) let\\'s me clear this to you, I have not used any power function or inbuild function. Also if someone uses power function then too it\\'s not called \"cheating\" [@Yulin Liu](/Kaltu) You need to read problem statement, there no where mentioned that you can\\'t use inbuild functions."
                    },
                    {
                        "username": "Kaltu",
                        "content": "because you are implemeting the power function, which logically means you are not allowed to use power function to do so unless you are cheating. and sure, cheating is always easy."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "Decimals in the descriptions are confusing. In Javascript we don\\'t get a number like 1024.00000, it\\'ll always be 1024\\nI think description should be updated to have proper examples."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@rahulramdasi44](/rahulramdasi44) I don\\'t know what\\'s consufing you but it\\'s just a way to hint you the system is verifying floating point numbers to the precision of fifth decimal point, regardless of the language.\\nI don\\'t see how JavaScript is special anyway here. JavaScript does use IEEE754 just like others."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "In Javascript we don't get a **number** like 1024.00000 because `.toFixed` will return a string and not a number. In description, the return type is number and its confusing because of examples where result is shown as 1024.00000"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Why you don\\'t get a number like 1024.00000in JS? I can just `console.log(myPow(2, 10).toFixed(5))` and I does get `1024.00000`"
                    },
                    {
                        "username": "mohitgoel14",
                        "content": "I want to solve this problem using recursion but getting error of stack overflow error when INT_MAX = n."
                    },
                    {
                        "username": "Sacristaria",
                        "content": "You call a function INT_MAX times the stack is gonna overflow, you need to figure out a way to call it less times."
                    },
                    {
                        "username": "jmeena660",
                        "content": "why i am getting error in greater values its stack overflown on address \\ni just did it using simple recursion "
                    },
                    {
                        "username": "Sacristaria",
                        "content": "Most likely overflowing when the exponent is 2^31-1, each recursion is gonna go to the stack and with that many it is bound to overflow. Might be something else, hard to tell without seeing any code."
                    },
                    {
                        "username": "willmccarten13",
                        "content": "even if this isnt the right way to solve it, i just want to know the answer to this question: why is the compiler saying that 2147483648 is too large to put into my long variable? shouldn\\'t the range for a long encompass that?"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "If you\\'re doing -n, it is putting the result in an int, which is too large for n == INT_MIN, try casting the variable first then negating it."
                    },
                    {
                        "username": "natitati",
                        "content": "The range for long is -2147483648 to 2147483647, therefore 2147483648 will overflow if put into a long variable."
                    }
                ]
            },
            {
                "id": 2062029,
                "content": [
                    {
                        "username": "Mr_Harshit_k",
                        "content": "i have an question why we are not using Math.pow(x,n) ?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Because the first two words of the problem statement explicitly ask you to implement it. It makes no sense to implement a function by calling itself."
                    },
                    {
                        "username": "aftabmk",
                        "content": "why pow even a question, since we have built in pow fn in cpp, and other modern language,maybe in the near future leetcode question might be like code Djikstra algorithm without using any coding language."
                    },
                    {
                        "username": "benjelplan",
                        "content": "why do any exercise on leetcode.com then since chatgpt can solve it in a few seconds? "
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "bhadwa ques"
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "this took so much time for the testcase (x=1.00000 and n=-2147483648) I still didnt get the \\ncode:\\npublic double myPow(double x, int n) {\\n        if(n<0){\\n            n=-n;\\n            return 1/(double)myPow(x,n);\\n        }\\n        if(n>0){\\n            if(n%2==0){\\n                return myPow(x*x,(n/2));\\n            }else{\\n                return x*myPow(x,n-1);\\n            }\\n        }\\n        return (double)1;\\n    }"
                    },
                    {
                        "username": "benjelplan",
                        "content": "Can somebody please explain to me how -2.00000 ^ 2 = 4.00000?\\nI think that -2^2 = -4 and that\\'s what happens in python as well if you enter -2**2\\n\\nthanks!"
                    },
                    {
                        "username": "benjelplan",
                        "content": "[@Kaltu](/Kaltu) Thanks for explaining! I thought that writing -2**2 meant the same thing as (-2)**2"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`-2**2` in python means `-(2**2)` but we are passing `-2` a function `def pow(x, n): return x ** n` and called by `pow(-2, 2)` it means `(-2) ** 2`\nmore information, search for `operator precedence`"
                    },
                    {
                        "username": "ishan_01",
                        "content": "This question must be marked easy, Give a single reason for marking it as Medium ?"
                    },
                    {
                        "username": "ishan_01",
                        "content": "[@Kaltu](/Kaltu) let\\'s me clear this to you, I have not used any power function or inbuild function. Also if someone uses power function then too it\\'s not called \"cheating\" [@Yulin Liu](/Kaltu) You need to read problem statement, there no where mentioned that you can\\'t use inbuild functions."
                    },
                    {
                        "username": "Kaltu",
                        "content": "because you are implemeting the power function, which logically means you are not allowed to use power function to do so unless you are cheating. and sure, cheating is always easy."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "Decimals in the descriptions are confusing. In Javascript we don\\'t get a number like 1024.00000, it\\'ll always be 1024\\nI think description should be updated to have proper examples."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@rahulramdasi44](/rahulramdasi44) I don\\'t know what\\'s consufing you but it\\'s just a way to hint you the system is verifying floating point numbers to the precision of fifth decimal point, regardless of the language.\\nI don\\'t see how JavaScript is special anyway here. JavaScript does use IEEE754 just like others."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "In Javascript we don't get a **number** like 1024.00000 because `.toFixed` will return a string and not a number. In description, the return type is number and its confusing because of examples where result is shown as 1024.00000"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Why you don\\'t get a number like 1024.00000in JS? I can just `console.log(myPow(2, 10).toFixed(5))` and I does get `1024.00000`"
                    },
                    {
                        "username": "mohitgoel14",
                        "content": "I want to solve this problem using recursion but getting error of stack overflow error when INT_MAX = n."
                    },
                    {
                        "username": "Sacristaria",
                        "content": "You call a function INT_MAX times the stack is gonna overflow, you need to figure out a way to call it less times."
                    },
                    {
                        "username": "jmeena660",
                        "content": "why i am getting error in greater values its stack overflown on address \\ni just did it using simple recursion "
                    },
                    {
                        "username": "Sacristaria",
                        "content": "Most likely overflowing when the exponent is 2^31-1, each recursion is gonna go to the stack and with that many it is bound to overflow. Might be something else, hard to tell without seeing any code."
                    },
                    {
                        "username": "willmccarten13",
                        "content": "even if this isnt the right way to solve it, i just want to know the answer to this question: why is the compiler saying that 2147483648 is too large to put into my long variable? shouldn\\'t the range for a long encompass that?"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "If you\\'re doing -n, it is putting the result in an int, which is too large for n == INT_MIN, try casting the variable first then negating it."
                    },
                    {
                        "username": "natitati",
                        "content": "The range for long is -2147483648 to 2147483647, therefore 2147483648 will overflow if put into a long variable."
                    }
                ]
            },
            {
                "id": 2059892,
                "content": [
                    {
                        "username": "Mr_Harshit_k",
                        "content": "i have an question why we are not using Math.pow(x,n) ?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Because the first two words of the problem statement explicitly ask you to implement it. It makes no sense to implement a function by calling itself."
                    },
                    {
                        "username": "aftabmk",
                        "content": "why pow even a question, since we have built in pow fn in cpp, and other modern language,maybe in the near future leetcode question might be like code Djikstra algorithm without using any coding language."
                    },
                    {
                        "username": "benjelplan",
                        "content": "why do any exercise on leetcode.com then since chatgpt can solve it in a few seconds? "
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "bhadwa ques"
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "this took so much time for the testcase (x=1.00000 and n=-2147483648) I still didnt get the \\ncode:\\npublic double myPow(double x, int n) {\\n        if(n<0){\\n            n=-n;\\n            return 1/(double)myPow(x,n);\\n        }\\n        if(n>0){\\n            if(n%2==0){\\n                return myPow(x*x,(n/2));\\n            }else{\\n                return x*myPow(x,n-1);\\n            }\\n        }\\n        return (double)1;\\n    }"
                    },
                    {
                        "username": "benjelplan",
                        "content": "Can somebody please explain to me how -2.00000 ^ 2 = 4.00000?\\nI think that -2^2 = -4 and that\\'s what happens in python as well if you enter -2**2\\n\\nthanks!"
                    },
                    {
                        "username": "benjelplan",
                        "content": "[@Kaltu](/Kaltu) Thanks for explaining! I thought that writing -2**2 meant the same thing as (-2)**2"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`-2**2` in python means `-(2**2)` but we are passing `-2` a function `def pow(x, n): return x ** n` and called by `pow(-2, 2)` it means `(-2) ** 2`\nmore information, search for `operator precedence`"
                    },
                    {
                        "username": "ishan_01",
                        "content": "This question must be marked easy, Give a single reason for marking it as Medium ?"
                    },
                    {
                        "username": "ishan_01",
                        "content": "[@Kaltu](/Kaltu) let\\'s me clear this to you, I have not used any power function or inbuild function. Also if someone uses power function then too it\\'s not called \"cheating\" [@Yulin Liu](/Kaltu) You need to read problem statement, there no where mentioned that you can\\'t use inbuild functions."
                    },
                    {
                        "username": "Kaltu",
                        "content": "because you are implemeting the power function, which logically means you are not allowed to use power function to do so unless you are cheating. and sure, cheating is always easy."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "Decimals in the descriptions are confusing. In Javascript we don\\'t get a number like 1024.00000, it\\'ll always be 1024\\nI think description should be updated to have proper examples."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@rahulramdasi44](/rahulramdasi44) I don\\'t know what\\'s consufing you but it\\'s just a way to hint you the system is verifying floating point numbers to the precision of fifth decimal point, regardless of the language.\\nI don\\'t see how JavaScript is special anyway here. JavaScript does use IEEE754 just like others."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "In Javascript we don't get a **number** like 1024.00000 because `.toFixed` will return a string and not a number. In description, the return type is number and its confusing because of examples where result is shown as 1024.00000"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Why you don\\'t get a number like 1024.00000in JS? I can just `console.log(myPow(2, 10).toFixed(5))` and I does get `1024.00000`"
                    },
                    {
                        "username": "mohitgoel14",
                        "content": "I want to solve this problem using recursion but getting error of stack overflow error when INT_MAX = n."
                    },
                    {
                        "username": "Sacristaria",
                        "content": "You call a function INT_MAX times the stack is gonna overflow, you need to figure out a way to call it less times."
                    },
                    {
                        "username": "jmeena660",
                        "content": "why i am getting error in greater values its stack overflown on address \\ni just did it using simple recursion "
                    },
                    {
                        "username": "Sacristaria",
                        "content": "Most likely overflowing when the exponent is 2^31-1, each recursion is gonna go to the stack and with that many it is bound to overflow. Might be something else, hard to tell without seeing any code."
                    },
                    {
                        "username": "willmccarten13",
                        "content": "even if this isnt the right way to solve it, i just want to know the answer to this question: why is the compiler saying that 2147483648 is too large to put into my long variable? shouldn\\'t the range for a long encompass that?"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "If you\\'re doing -n, it is putting the result in an int, which is too large for n == INT_MIN, try casting the variable first then negating it."
                    },
                    {
                        "username": "natitati",
                        "content": "The range for long is -2147483648 to 2147483647, therefore 2147483648 will overflow if put into a long variable."
                    }
                ]
            },
            {
                "id": 2047867,
                "content": [
                    {
                        "username": "Mr_Harshit_k",
                        "content": "i have an question why we are not using Math.pow(x,n) ?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Because the first two words of the problem statement explicitly ask you to implement it. It makes no sense to implement a function by calling itself."
                    },
                    {
                        "username": "aftabmk",
                        "content": "why pow even a question, since we have built in pow fn in cpp, and other modern language,maybe in the near future leetcode question might be like code Djikstra algorithm without using any coding language."
                    },
                    {
                        "username": "benjelplan",
                        "content": "why do any exercise on leetcode.com then since chatgpt can solve it in a few seconds? "
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "bhadwa ques"
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "this took so much time for the testcase (x=1.00000 and n=-2147483648) I still didnt get the \\ncode:\\npublic double myPow(double x, int n) {\\n        if(n<0){\\n            n=-n;\\n            return 1/(double)myPow(x,n);\\n        }\\n        if(n>0){\\n            if(n%2==0){\\n                return myPow(x*x,(n/2));\\n            }else{\\n                return x*myPow(x,n-1);\\n            }\\n        }\\n        return (double)1;\\n    }"
                    },
                    {
                        "username": "benjelplan",
                        "content": "Can somebody please explain to me how -2.00000 ^ 2 = 4.00000?\\nI think that -2^2 = -4 and that\\'s what happens in python as well if you enter -2**2\\n\\nthanks!"
                    },
                    {
                        "username": "benjelplan",
                        "content": "[@Kaltu](/Kaltu) Thanks for explaining! I thought that writing -2**2 meant the same thing as (-2)**2"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`-2**2` in python means `-(2**2)` but we are passing `-2` a function `def pow(x, n): return x ** n` and called by `pow(-2, 2)` it means `(-2) ** 2`\nmore information, search for `operator precedence`"
                    },
                    {
                        "username": "ishan_01",
                        "content": "This question must be marked easy, Give a single reason for marking it as Medium ?"
                    },
                    {
                        "username": "ishan_01",
                        "content": "[@Kaltu](/Kaltu) let\\'s me clear this to you, I have not used any power function or inbuild function. Also if someone uses power function then too it\\'s not called \"cheating\" [@Yulin Liu](/Kaltu) You need to read problem statement, there no where mentioned that you can\\'t use inbuild functions."
                    },
                    {
                        "username": "Kaltu",
                        "content": "because you are implemeting the power function, which logically means you are not allowed to use power function to do so unless you are cheating. and sure, cheating is always easy."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "Decimals in the descriptions are confusing. In Javascript we don\\'t get a number like 1024.00000, it\\'ll always be 1024\\nI think description should be updated to have proper examples."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@rahulramdasi44](/rahulramdasi44) I don\\'t know what\\'s consufing you but it\\'s just a way to hint you the system is verifying floating point numbers to the precision of fifth decimal point, regardless of the language.\\nI don\\'t see how JavaScript is special anyway here. JavaScript does use IEEE754 just like others."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "In Javascript we don't get a **number** like 1024.00000 because `.toFixed` will return a string and not a number. In description, the return type is number and its confusing because of examples where result is shown as 1024.00000"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Why you don\\'t get a number like 1024.00000in JS? I can just `console.log(myPow(2, 10).toFixed(5))` and I does get `1024.00000`"
                    },
                    {
                        "username": "mohitgoel14",
                        "content": "I want to solve this problem using recursion but getting error of stack overflow error when INT_MAX = n."
                    },
                    {
                        "username": "Sacristaria",
                        "content": "You call a function INT_MAX times the stack is gonna overflow, you need to figure out a way to call it less times."
                    },
                    {
                        "username": "jmeena660",
                        "content": "why i am getting error in greater values its stack overflown on address \\ni just did it using simple recursion "
                    },
                    {
                        "username": "Sacristaria",
                        "content": "Most likely overflowing when the exponent is 2^31-1, each recursion is gonna go to the stack and with that many it is bound to overflow. Might be something else, hard to tell without seeing any code."
                    },
                    {
                        "username": "willmccarten13",
                        "content": "even if this isnt the right way to solve it, i just want to know the answer to this question: why is the compiler saying that 2147483648 is too large to put into my long variable? shouldn\\'t the range for a long encompass that?"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "If you\\'re doing -n, it is putting the result in an int, which is too large for n == INT_MIN, try casting the variable first then negating it."
                    },
                    {
                        "username": "natitati",
                        "content": "The range for long is -2147483648 to 2147483647, therefore 2147483648 will overflow if put into a long variable."
                    }
                ]
            },
            {
                "id": 2039669,
                "content": [
                    {
                        "username": "Mr_Harshit_k",
                        "content": "i have an question why we are not using Math.pow(x,n) ?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Because the first two words of the problem statement explicitly ask you to implement it. It makes no sense to implement a function by calling itself."
                    },
                    {
                        "username": "aftabmk",
                        "content": "why pow even a question, since we have built in pow fn in cpp, and other modern language,maybe in the near future leetcode question might be like code Djikstra algorithm without using any coding language."
                    },
                    {
                        "username": "benjelplan",
                        "content": "why do any exercise on leetcode.com then since chatgpt can solve it in a few seconds? "
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "bhadwa ques"
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "this took so much time for the testcase (x=1.00000 and n=-2147483648) I still didnt get the \\ncode:\\npublic double myPow(double x, int n) {\\n        if(n<0){\\n            n=-n;\\n            return 1/(double)myPow(x,n);\\n        }\\n        if(n>0){\\n            if(n%2==0){\\n                return myPow(x*x,(n/2));\\n            }else{\\n                return x*myPow(x,n-1);\\n            }\\n        }\\n        return (double)1;\\n    }"
                    },
                    {
                        "username": "benjelplan",
                        "content": "Can somebody please explain to me how -2.00000 ^ 2 = 4.00000?\\nI think that -2^2 = -4 and that\\'s what happens in python as well if you enter -2**2\\n\\nthanks!"
                    },
                    {
                        "username": "benjelplan",
                        "content": "[@Kaltu](/Kaltu) Thanks for explaining! I thought that writing -2**2 meant the same thing as (-2)**2"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`-2**2` in python means `-(2**2)` but we are passing `-2` a function `def pow(x, n): return x ** n` and called by `pow(-2, 2)` it means `(-2) ** 2`\nmore information, search for `operator precedence`"
                    },
                    {
                        "username": "ishan_01",
                        "content": "This question must be marked easy, Give a single reason for marking it as Medium ?"
                    },
                    {
                        "username": "ishan_01",
                        "content": "[@Kaltu](/Kaltu) let\\'s me clear this to you, I have not used any power function or inbuild function. Also if someone uses power function then too it\\'s not called \"cheating\" [@Yulin Liu](/Kaltu) You need to read problem statement, there no where mentioned that you can\\'t use inbuild functions."
                    },
                    {
                        "username": "Kaltu",
                        "content": "because you are implemeting the power function, which logically means you are not allowed to use power function to do so unless you are cheating. and sure, cheating is always easy."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "Decimals in the descriptions are confusing. In Javascript we don\\'t get a number like 1024.00000, it\\'ll always be 1024\\nI think description should be updated to have proper examples."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@rahulramdasi44](/rahulramdasi44) I don\\'t know what\\'s consufing you but it\\'s just a way to hint you the system is verifying floating point numbers to the precision of fifth decimal point, regardless of the language.\\nI don\\'t see how JavaScript is special anyway here. JavaScript does use IEEE754 just like others."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "In Javascript we don't get a **number** like 1024.00000 because `.toFixed` will return a string and not a number. In description, the return type is number and its confusing because of examples where result is shown as 1024.00000"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Why you don\\'t get a number like 1024.00000in JS? I can just `console.log(myPow(2, 10).toFixed(5))` and I does get `1024.00000`"
                    },
                    {
                        "username": "mohitgoel14",
                        "content": "I want to solve this problem using recursion but getting error of stack overflow error when INT_MAX = n."
                    },
                    {
                        "username": "Sacristaria",
                        "content": "You call a function INT_MAX times the stack is gonna overflow, you need to figure out a way to call it less times."
                    },
                    {
                        "username": "jmeena660",
                        "content": "why i am getting error in greater values its stack overflown on address \\ni just did it using simple recursion "
                    },
                    {
                        "username": "Sacristaria",
                        "content": "Most likely overflowing when the exponent is 2^31-1, each recursion is gonna go to the stack and with that many it is bound to overflow. Might be something else, hard to tell without seeing any code."
                    },
                    {
                        "username": "willmccarten13",
                        "content": "even if this isnt the right way to solve it, i just want to know the answer to this question: why is the compiler saying that 2147483648 is too large to put into my long variable? shouldn\\'t the range for a long encompass that?"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "If you\\'re doing -n, it is putting the result in an int, which is too large for n == INT_MIN, try casting the variable first then negating it."
                    },
                    {
                        "username": "natitati",
                        "content": "The range for long is -2147483648 to 2147483647, therefore 2147483648 will overflow if put into a long variable."
                    }
                ]
            },
            {
                "id": 2026598,
                "content": [
                    {
                        "username": "Mr_Harshit_k",
                        "content": "i have an question why we are not using Math.pow(x,n) ?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Because the first two words of the problem statement explicitly ask you to implement it. It makes no sense to implement a function by calling itself."
                    },
                    {
                        "username": "aftabmk",
                        "content": "why pow even a question, since we have built in pow fn in cpp, and other modern language,maybe in the near future leetcode question might be like code Djikstra algorithm without using any coding language."
                    },
                    {
                        "username": "benjelplan",
                        "content": "why do any exercise on leetcode.com then since chatgpt can solve it in a few seconds? "
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "bhadwa ques"
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "this took so much time for the testcase (x=1.00000 and n=-2147483648) I still didnt get the \\ncode:\\npublic double myPow(double x, int n) {\\n        if(n<0){\\n            n=-n;\\n            return 1/(double)myPow(x,n);\\n        }\\n        if(n>0){\\n            if(n%2==0){\\n                return myPow(x*x,(n/2));\\n            }else{\\n                return x*myPow(x,n-1);\\n            }\\n        }\\n        return (double)1;\\n    }"
                    },
                    {
                        "username": "benjelplan",
                        "content": "Can somebody please explain to me how -2.00000 ^ 2 = 4.00000?\\nI think that -2^2 = -4 and that\\'s what happens in python as well if you enter -2**2\\n\\nthanks!"
                    },
                    {
                        "username": "benjelplan",
                        "content": "[@Kaltu](/Kaltu) Thanks for explaining! I thought that writing -2**2 meant the same thing as (-2)**2"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`-2**2` in python means `-(2**2)` but we are passing `-2` a function `def pow(x, n): return x ** n` and called by `pow(-2, 2)` it means `(-2) ** 2`\nmore information, search for `operator precedence`"
                    },
                    {
                        "username": "ishan_01",
                        "content": "This question must be marked easy, Give a single reason for marking it as Medium ?"
                    },
                    {
                        "username": "ishan_01",
                        "content": "[@Kaltu](/Kaltu) let\\'s me clear this to you, I have not used any power function or inbuild function. Also if someone uses power function then too it\\'s not called \"cheating\" [@Yulin Liu](/Kaltu) You need to read problem statement, there no where mentioned that you can\\'t use inbuild functions."
                    },
                    {
                        "username": "Kaltu",
                        "content": "because you are implemeting the power function, which logically means you are not allowed to use power function to do so unless you are cheating. and sure, cheating is always easy."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "Decimals in the descriptions are confusing. In Javascript we don\\'t get a number like 1024.00000, it\\'ll always be 1024\\nI think description should be updated to have proper examples."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@rahulramdasi44](/rahulramdasi44) I don\\'t know what\\'s consufing you but it\\'s just a way to hint you the system is verifying floating point numbers to the precision of fifth decimal point, regardless of the language.\\nI don\\'t see how JavaScript is special anyway here. JavaScript does use IEEE754 just like others."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "In Javascript we don't get a **number** like 1024.00000 because `.toFixed` will return a string and not a number. In description, the return type is number and its confusing because of examples where result is shown as 1024.00000"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Why you don\\'t get a number like 1024.00000in JS? I can just `console.log(myPow(2, 10).toFixed(5))` and I does get `1024.00000`"
                    },
                    {
                        "username": "mohitgoel14",
                        "content": "I want to solve this problem using recursion but getting error of stack overflow error when INT_MAX = n."
                    },
                    {
                        "username": "Sacristaria",
                        "content": "You call a function INT_MAX times the stack is gonna overflow, you need to figure out a way to call it less times."
                    },
                    {
                        "username": "jmeena660",
                        "content": "why i am getting error in greater values its stack overflown on address \\ni just did it using simple recursion "
                    },
                    {
                        "username": "Sacristaria",
                        "content": "Most likely overflowing when the exponent is 2^31-1, each recursion is gonna go to the stack and with that many it is bound to overflow. Might be something else, hard to tell without seeing any code."
                    },
                    {
                        "username": "willmccarten13",
                        "content": "even if this isnt the right way to solve it, i just want to know the answer to this question: why is the compiler saying that 2147483648 is too large to put into my long variable? shouldn\\'t the range for a long encompass that?"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "If you\\'re doing -n, it is putting the result in an int, which is too large for n == INT_MIN, try casting the variable first then negating it."
                    },
                    {
                        "username": "natitati",
                        "content": "The range for long is -2147483648 to 2147483647, therefore 2147483648 will overflow if put into a long variable."
                    }
                ]
            },
            {
                "id": 2024407,
                "content": [
                    {
                        "username": "Mr_Harshit_k",
                        "content": "i have an question why we are not using Math.pow(x,n) ?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Because the first two words of the problem statement explicitly ask you to implement it. It makes no sense to implement a function by calling itself."
                    },
                    {
                        "username": "aftabmk",
                        "content": "why pow even a question, since we have built in pow fn in cpp, and other modern language,maybe in the near future leetcode question might be like code Djikstra algorithm without using any coding language."
                    },
                    {
                        "username": "benjelplan",
                        "content": "why do any exercise on leetcode.com then since chatgpt can solve it in a few seconds? "
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "bhadwa ques"
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "this took so much time for the testcase (x=1.00000 and n=-2147483648) I still didnt get the \\ncode:\\npublic double myPow(double x, int n) {\\n        if(n<0){\\n            n=-n;\\n            return 1/(double)myPow(x,n);\\n        }\\n        if(n>0){\\n            if(n%2==0){\\n                return myPow(x*x,(n/2));\\n            }else{\\n                return x*myPow(x,n-1);\\n            }\\n        }\\n        return (double)1;\\n    }"
                    },
                    {
                        "username": "benjelplan",
                        "content": "Can somebody please explain to me how -2.00000 ^ 2 = 4.00000?\\nI think that -2^2 = -4 and that\\'s what happens in python as well if you enter -2**2\\n\\nthanks!"
                    },
                    {
                        "username": "benjelplan",
                        "content": "[@Kaltu](/Kaltu) Thanks for explaining! I thought that writing -2**2 meant the same thing as (-2)**2"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`-2**2` in python means `-(2**2)` but we are passing `-2` a function `def pow(x, n): return x ** n` and called by `pow(-2, 2)` it means `(-2) ** 2`\nmore information, search for `operator precedence`"
                    },
                    {
                        "username": "ishan_01",
                        "content": "This question must be marked easy, Give a single reason for marking it as Medium ?"
                    },
                    {
                        "username": "ishan_01",
                        "content": "[@Kaltu](/Kaltu) let\\'s me clear this to you, I have not used any power function or inbuild function. Also if someone uses power function then too it\\'s not called \"cheating\" [@Yulin Liu](/Kaltu) You need to read problem statement, there no where mentioned that you can\\'t use inbuild functions."
                    },
                    {
                        "username": "Kaltu",
                        "content": "because you are implemeting the power function, which logically means you are not allowed to use power function to do so unless you are cheating. and sure, cheating is always easy."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "Decimals in the descriptions are confusing. In Javascript we don\\'t get a number like 1024.00000, it\\'ll always be 1024\\nI think description should be updated to have proper examples."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@rahulramdasi44](/rahulramdasi44) I don\\'t know what\\'s consufing you but it\\'s just a way to hint you the system is verifying floating point numbers to the precision of fifth decimal point, regardless of the language.\\nI don\\'t see how JavaScript is special anyway here. JavaScript does use IEEE754 just like others."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "In Javascript we don't get a **number** like 1024.00000 because `.toFixed` will return a string and not a number. In description, the return type is number and its confusing because of examples where result is shown as 1024.00000"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Why you don\\'t get a number like 1024.00000in JS? I can just `console.log(myPow(2, 10).toFixed(5))` and I does get `1024.00000`"
                    },
                    {
                        "username": "mohitgoel14",
                        "content": "I want to solve this problem using recursion but getting error of stack overflow error when INT_MAX = n."
                    },
                    {
                        "username": "Sacristaria",
                        "content": "You call a function INT_MAX times the stack is gonna overflow, you need to figure out a way to call it less times."
                    },
                    {
                        "username": "jmeena660",
                        "content": "why i am getting error in greater values its stack overflown on address \\ni just did it using simple recursion "
                    },
                    {
                        "username": "Sacristaria",
                        "content": "Most likely overflowing when the exponent is 2^31-1, each recursion is gonna go to the stack and with that many it is bound to overflow. Might be something else, hard to tell without seeing any code."
                    },
                    {
                        "username": "willmccarten13",
                        "content": "even if this isnt the right way to solve it, i just want to know the answer to this question: why is the compiler saying that 2147483648 is too large to put into my long variable? shouldn\\'t the range for a long encompass that?"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "If you\\'re doing -n, it is putting the result in an int, which is too large for n == INT_MIN, try casting the variable first then negating it."
                    },
                    {
                        "username": "natitati",
                        "content": "The range for long is -2147483648 to 2147483647, therefore 2147483648 will overflow if put into a long variable."
                    }
                ]
            },
            {
                "id": 2013126,
                "content": [
                    {
                        "username": "Mr_Harshit_k",
                        "content": "i have an question why we are not using Math.pow(x,n) ?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Because the first two words of the problem statement explicitly ask you to implement it. It makes no sense to implement a function by calling itself."
                    },
                    {
                        "username": "aftabmk",
                        "content": "why pow even a question, since we have built in pow fn in cpp, and other modern language,maybe in the near future leetcode question might be like code Djikstra algorithm without using any coding language."
                    },
                    {
                        "username": "benjelplan",
                        "content": "why do any exercise on leetcode.com then since chatgpt can solve it in a few seconds? "
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "bhadwa ques"
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "this took so much time for the testcase (x=1.00000 and n=-2147483648) I still didnt get the \\ncode:\\npublic double myPow(double x, int n) {\\n        if(n<0){\\n            n=-n;\\n            return 1/(double)myPow(x,n);\\n        }\\n        if(n>0){\\n            if(n%2==0){\\n                return myPow(x*x,(n/2));\\n            }else{\\n                return x*myPow(x,n-1);\\n            }\\n        }\\n        return (double)1;\\n    }"
                    },
                    {
                        "username": "benjelplan",
                        "content": "Can somebody please explain to me how -2.00000 ^ 2 = 4.00000?\\nI think that -2^2 = -4 and that\\'s what happens in python as well if you enter -2**2\\n\\nthanks!"
                    },
                    {
                        "username": "benjelplan",
                        "content": "[@Kaltu](/Kaltu) Thanks for explaining! I thought that writing -2**2 meant the same thing as (-2)**2"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`-2**2` in python means `-(2**2)` but we are passing `-2` a function `def pow(x, n): return x ** n` and called by `pow(-2, 2)` it means `(-2) ** 2`\nmore information, search for `operator precedence`"
                    },
                    {
                        "username": "ishan_01",
                        "content": "This question must be marked easy, Give a single reason for marking it as Medium ?"
                    },
                    {
                        "username": "ishan_01",
                        "content": "[@Kaltu](/Kaltu) let\\'s me clear this to you, I have not used any power function or inbuild function. Also if someone uses power function then too it\\'s not called \"cheating\" [@Yulin Liu](/Kaltu) You need to read problem statement, there no where mentioned that you can\\'t use inbuild functions."
                    },
                    {
                        "username": "Kaltu",
                        "content": "because you are implemeting the power function, which logically means you are not allowed to use power function to do so unless you are cheating. and sure, cheating is always easy."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "Decimals in the descriptions are confusing. In Javascript we don\\'t get a number like 1024.00000, it\\'ll always be 1024\\nI think description should be updated to have proper examples."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@rahulramdasi44](/rahulramdasi44) I don\\'t know what\\'s consufing you but it\\'s just a way to hint you the system is verifying floating point numbers to the precision of fifth decimal point, regardless of the language.\\nI don\\'t see how JavaScript is special anyway here. JavaScript does use IEEE754 just like others."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "In Javascript we don't get a **number** like 1024.00000 because `.toFixed` will return a string and not a number. In description, the return type is number and its confusing because of examples where result is shown as 1024.00000"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Why you don\\'t get a number like 1024.00000in JS? I can just `console.log(myPow(2, 10).toFixed(5))` and I does get `1024.00000`"
                    },
                    {
                        "username": "mohitgoel14",
                        "content": "I want to solve this problem using recursion but getting error of stack overflow error when INT_MAX = n."
                    },
                    {
                        "username": "Sacristaria",
                        "content": "You call a function INT_MAX times the stack is gonna overflow, you need to figure out a way to call it less times."
                    },
                    {
                        "username": "jmeena660",
                        "content": "why i am getting error in greater values its stack overflown on address \\ni just did it using simple recursion "
                    },
                    {
                        "username": "Sacristaria",
                        "content": "Most likely overflowing when the exponent is 2^31-1, each recursion is gonna go to the stack and with that many it is bound to overflow. Might be something else, hard to tell without seeing any code."
                    },
                    {
                        "username": "willmccarten13",
                        "content": "even if this isnt the right way to solve it, i just want to know the answer to this question: why is the compiler saying that 2147483648 is too large to put into my long variable? shouldn\\'t the range for a long encompass that?"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "If you\\'re doing -n, it is putting the result in an int, which is too large for n == INT_MIN, try casting the variable first then negating it."
                    },
                    {
                        "username": "natitati",
                        "content": "The range for long is -2147483648 to 2147483647, therefore 2147483648 will overflow if put into a long variable."
                    }
                ]
            },
            {
                "id": 2008589,
                "content": [
                    {
                        "username": "Mr_Harshit_k",
                        "content": "i have an question why we are not using Math.pow(x,n) ?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Because the first two words of the problem statement explicitly ask you to implement it. It makes no sense to implement a function by calling itself."
                    },
                    {
                        "username": "aftabmk",
                        "content": "why pow even a question, since we have built in pow fn in cpp, and other modern language,maybe in the near future leetcode question might be like code Djikstra algorithm without using any coding language."
                    },
                    {
                        "username": "benjelplan",
                        "content": "why do any exercise on leetcode.com then since chatgpt can solve it in a few seconds? "
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "bhadwa ques"
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "this took so much time for the testcase (x=1.00000 and n=-2147483648) I still didnt get the \\ncode:\\npublic double myPow(double x, int n) {\\n        if(n<0){\\n            n=-n;\\n            return 1/(double)myPow(x,n);\\n        }\\n        if(n>0){\\n            if(n%2==0){\\n                return myPow(x*x,(n/2));\\n            }else{\\n                return x*myPow(x,n-1);\\n            }\\n        }\\n        return (double)1;\\n    }"
                    },
                    {
                        "username": "benjelplan",
                        "content": "Can somebody please explain to me how -2.00000 ^ 2 = 4.00000?\\nI think that -2^2 = -4 and that\\'s what happens in python as well if you enter -2**2\\n\\nthanks!"
                    },
                    {
                        "username": "benjelplan",
                        "content": "[@Kaltu](/Kaltu) Thanks for explaining! I thought that writing -2**2 meant the same thing as (-2)**2"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`-2**2` in python means `-(2**2)` but we are passing `-2` a function `def pow(x, n): return x ** n` and called by `pow(-2, 2)` it means `(-2) ** 2`\nmore information, search for `operator precedence`"
                    },
                    {
                        "username": "ishan_01",
                        "content": "This question must be marked easy, Give a single reason for marking it as Medium ?"
                    },
                    {
                        "username": "ishan_01",
                        "content": "[@Kaltu](/Kaltu) let\\'s me clear this to you, I have not used any power function or inbuild function. Also if someone uses power function then too it\\'s not called \"cheating\" [@Yulin Liu](/Kaltu) You need to read problem statement, there no where mentioned that you can\\'t use inbuild functions."
                    },
                    {
                        "username": "Kaltu",
                        "content": "because you are implemeting the power function, which logically means you are not allowed to use power function to do so unless you are cheating. and sure, cheating is always easy."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "Decimals in the descriptions are confusing. In Javascript we don\\'t get a number like 1024.00000, it\\'ll always be 1024\\nI think description should be updated to have proper examples."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@rahulramdasi44](/rahulramdasi44) I don\\'t know what\\'s consufing you but it\\'s just a way to hint you the system is verifying floating point numbers to the precision of fifth decimal point, regardless of the language.\\nI don\\'t see how JavaScript is special anyway here. JavaScript does use IEEE754 just like others."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "In Javascript we don't get a **number** like 1024.00000 because `.toFixed` will return a string and not a number. In description, the return type is number and its confusing because of examples where result is shown as 1024.00000"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Why you don\\'t get a number like 1024.00000in JS? I can just `console.log(myPow(2, 10).toFixed(5))` and I does get `1024.00000`"
                    },
                    {
                        "username": "mohitgoel14",
                        "content": "I want to solve this problem using recursion but getting error of stack overflow error when INT_MAX = n."
                    },
                    {
                        "username": "Sacristaria",
                        "content": "You call a function INT_MAX times the stack is gonna overflow, you need to figure out a way to call it less times."
                    },
                    {
                        "username": "jmeena660",
                        "content": "why i am getting error in greater values its stack overflown on address \\ni just did it using simple recursion "
                    },
                    {
                        "username": "Sacristaria",
                        "content": "Most likely overflowing when the exponent is 2^31-1, each recursion is gonna go to the stack and with that many it is bound to overflow. Might be something else, hard to tell without seeing any code."
                    },
                    {
                        "username": "willmccarten13",
                        "content": "even if this isnt the right way to solve it, i just want to know the answer to this question: why is the compiler saying that 2147483648 is too large to put into my long variable? shouldn\\'t the range for a long encompass that?"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "If you\\'re doing -n, it is putting the result in an int, which is too large for n == INT_MIN, try casting the variable first then negating it."
                    },
                    {
                        "username": "natitati",
                        "content": "The range for long is -2147483648 to 2147483647, therefore 2147483648 will overflow if put into a long variable."
                    }
                ]
            },
            {
                "id": 2008285,
                "content": [
                    {
                        "username": "Mr_Harshit_k",
                        "content": "i have an question why we are not using Math.pow(x,n) ?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Because the first two words of the problem statement explicitly ask you to implement it. It makes no sense to implement a function by calling itself."
                    },
                    {
                        "username": "aftabmk",
                        "content": "why pow even a question, since we have built in pow fn in cpp, and other modern language,maybe in the near future leetcode question might be like code Djikstra algorithm without using any coding language."
                    },
                    {
                        "username": "benjelplan",
                        "content": "why do any exercise on leetcode.com then since chatgpt can solve it in a few seconds? "
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "bhadwa ques"
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "this took so much time for the testcase (x=1.00000 and n=-2147483648) I still didnt get the \\ncode:\\npublic double myPow(double x, int n) {\\n        if(n<0){\\n            n=-n;\\n            return 1/(double)myPow(x,n);\\n        }\\n        if(n>0){\\n            if(n%2==0){\\n                return myPow(x*x,(n/2));\\n            }else{\\n                return x*myPow(x,n-1);\\n            }\\n        }\\n        return (double)1;\\n    }"
                    },
                    {
                        "username": "benjelplan",
                        "content": "Can somebody please explain to me how -2.00000 ^ 2 = 4.00000?\\nI think that -2^2 = -4 and that\\'s what happens in python as well if you enter -2**2\\n\\nthanks!"
                    },
                    {
                        "username": "benjelplan",
                        "content": "[@Kaltu](/Kaltu) Thanks for explaining! I thought that writing -2**2 meant the same thing as (-2)**2"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`-2**2` in python means `-(2**2)` but we are passing `-2` a function `def pow(x, n): return x ** n` and called by `pow(-2, 2)` it means `(-2) ** 2`\nmore information, search for `operator precedence`"
                    },
                    {
                        "username": "ishan_01",
                        "content": "This question must be marked easy, Give a single reason for marking it as Medium ?"
                    },
                    {
                        "username": "ishan_01",
                        "content": "[@Kaltu](/Kaltu) let\\'s me clear this to you, I have not used any power function or inbuild function. Also if someone uses power function then too it\\'s not called \"cheating\" [@Yulin Liu](/Kaltu) You need to read problem statement, there no where mentioned that you can\\'t use inbuild functions."
                    },
                    {
                        "username": "Kaltu",
                        "content": "because you are implemeting the power function, which logically means you are not allowed to use power function to do so unless you are cheating. and sure, cheating is always easy."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "Decimals in the descriptions are confusing. In Javascript we don\\'t get a number like 1024.00000, it\\'ll always be 1024\\nI think description should be updated to have proper examples."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@rahulramdasi44](/rahulramdasi44) I don\\'t know what\\'s consufing you but it\\'s just a way to hint you the system is verifying floating point numbers to the precision of fifth decimal point, regardless of the language.\\nI don\\'t see how JavaScript is special anyway here. JavaScript does use IEEE754 just like others."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "In Javascript we don't get a **number** like 1024.00000 because `.toFixed` will return a string and not a number. In description, the return type is number and its confusing because of examples where result is shown as 1024.00000"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Why you don\\'t get a number like 1024.00000in JS? I can just `console.log(myPow(2, 10).toFixed(5))` and I does get `1024.00000`"
                    },
                    {
                        "username": "mohitgoel14",
                        "content": "I want to solve this problem using recursion but getting error of stack overflow error when INT_MAX = n."
                    },
                    {
                        "username": "Sacristaria",
                        "content": "You call a function INT_MAX times the stack is gonna overflow, you need to figure out a way to call it less times."
                    },
                    {
                        "username": "jmeena660",
                        "content": "why i am getting error in greater values its stack overflown on address \\ni just did it using simple recursion "
                    },
                    {
                        "username": "Sacristaria",
                        "content": "Most likely overflowing when the exponent is 2^31-1, each recursion is gonna go to the stack and with that many it is bound to overflow. Might be something else, hard to tell without seeing any code."
                    },
                    {
                        "username": "willmccarten13",
                        "content": "even if this isnt the right way to solve it, i just want to know the answer to this question: why is the compiler saying that 2147483648 is too large to put into my long variable? shouldn\\'t the range for a long encompass that?"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "If you\\'re doing -n, it is putting the result in an int, which is too large for n == INT_MIN, try casting the variable first then negating it."
                    },
                    {
                        "username": "natitati",
                        "content": "The range for long is -2147483648 to 2147483647, therefore 2147483648 will overflow if put into a long variable."
                    }
                ]
            },
            {
                "id": 2006378,
                "content": [
                    {
                        "username": "QuasarZero",
                        "content": "\n*  O(N)  O(logN)\n* \n* 1\n\nEssential\n* Reduce time complexity from O(N) to O(logN) with binary tree\n* Reasonably handle the case where the exponent (n) is odd\n* Reasonably handle the case where the base and exponent are special values (for example: 1, etc.)"
                    },
                    {
                        "username": "munnaluri",
                        "content": "I am getting error for test case where x = 1.0000000000001 , n = -2147483648\\n\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        double result = x  ;\\n        int neg = 0 ; \\n        if (n == Integer.MAX_VALUE) \\n              return x;\\n        if ( n < 0 ){\\n            if ( n == Integer.MIN_VALUE){\\n                return  x == 1 || x == -1 ? 1 : 0 ;     \\n            }\\n            neg = n * -1 ; \\n        }else if ( n == 0 ){\\n            return 1 ; \\n        }else {\\n            neg = n ; \\n        }\\n\\n        for(int i = 1 ; i < neg ; i++){\\n            result = result * x ; \\n        }\\n\\n        if ( n < 0){\\n            result = 1/result ; \\n        }\\n\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "tifv",
                        "content": "Sure, because this particular case is incorrectly hardcoded in your solution :)\\n```\\nif (n == Integer.MIN_VALUE) {\\n    return x == 1 || x == -1 ? 1 : 0 ;\\n}\\n```"
                    },
                    {
                        "username": "dhwyaan",
                        "content": "Someone forgot to put a \"Don\\'t use built in functions and operators\" line"
                    },
                    {
                        "username": "jincanchamber",
                        "content": "Input\\nx =\\n1.0000000000001\\nn =\\n-2147483648\\n\\nUse Testcase\\nOutput\\n0.00000\\nExpected\\n0.99979\\n\\n\\nwhat???? "
                    },
                    {
                        "username": "tifv",
                        "content": "Do you have any problems with that? :)"
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "x =\\n0.00001\\nn =\\n2147483647\\n\\nINTERESTING..."
                    },
                    {
                        "username": "RinatFattakhov",
                        "content": "Not the best problem to practice Kotlin..."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "May be the objective of this problem is to learn binary exponentiation."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "After solving this, try looking into the official code for the pow function. It is mind boggling.\\nYou can easily check it your IDE."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "\\uD83E\\uDD2F"
                    },
                    {
                        "username": "kxntrast",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double total = x;\\n        if (x == 1)\\n            return 1;\\n        if (x == -1)\\n            return n%2 == 0 ? -x : x;\\n        if (n > 0) {\\n            for (int i =1; i < n; i++) {\\n                total *= x; \\n            }\\n        }\\n        else if (n < 0) {\\n            for (int i = -1; i > n; i--) {\\n                total *= x; \\n            }\\n            total = 1 / total;\\n        }\\n\\n        return total;\\n    }\\n};\\nx = 2.00000\\nn = -2147483648\\ntime limit exceeted, tests 301/309. What should I do to fix it?"
                    },
                    {
                        "username": "tifv",
                        "content": "This solution has complexity $O(n)$. You have to find a solution with better (like logarithmic) complexity."
                    },
                    {
                        "username": "pankaj_navale24",
                        "content": "2147483647"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Finally one that I actually know how to figure out before reading the editorial... Turns out that one time I learned to convert integers from decimal to binary by hand actually has a use"
                    }
                ]
            },
            {
                "id": 2003143,
                "content": [
                    {
                        "username": "QuasarZero",
                        "content": "\n*  O(N)  O(logN)\n* \n* 1\n\nEssential\n* Reduce time complexity from O(N) to O(logN) with binary tree\n* Reasonably handle the case where the exponent (n) is odd\n* Reasonably handle the case where the base and exponent are special values (for example: 1, etc.)"
                    },
                    {
                        "username": "munnaluri",
                        "content": "I am getting error for test case where x = 1.0000000000001 , n = -2147483648\\n\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        double result = x  ;\\n        int neg = 0 ; \\n        if (n == Integer.MAX_VALUE) \\n              return x;\\n        if ( n < 0 ){\\n            if ( n == Integer.MIN_VALUE){\\n                return  x == 1 || x == -1 ? 1 : 0 ;     \\n            }\\n            neg = n * -1 ; \\n        }else if ( n == 0 ){\\n            return 1 ; \\n        }else {\\n            neg = n ; \\n        }\\n\\n        for(int i = 1 ; i < neg ; i++){\\n            result = result * x ; \\n        }\\n\\n        if ( n < 0){\\n            result = 1/result ; \\n        }\\n\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "tifv",
                        "content": "Sure, because this particular case is incorrectly hardcoded in your solution :)\\n```\\nif (n == Integer.MIN_VALUE) {\\n    return x == 1 || x == -1 ? 1 : 0 ;\\n}\\n```"
                    },
                    {
                        "username": "dhwyaan",
                        "content": "Someone forgot to put a \"Don\\'t use built in functions and operators\" line"
                    },
                    {
                        "username": "jincanchamber",
                        "content": "Input\\nx =\\n1.0000000000001\\nn =\\n-2147483648\\n\\nUse Testcase\\nOutput\\n0.00000\\nExpected\\n0.99979\\n\\n\\nwhat???? "
                    },
                    {
                        "username": "tifv",
                        "content": "Do you have any problems with that? :)"
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "x =\\n0.00001\\nn =\\n2147483647\\n\\nINTERESTING..."
                    },
                    {
                        "username": "RinatFattakhov",
                        "content": "Not the best problem to practice Kotlin..."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "May be the objective of this problem is to learn binary exponentiation."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "After solving this, try looking into the official code for the pow function. It is mind boggling.\\nYou can easily check it your IDE."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "\\uD83E\\uDD2F"
                    },
                    {
                        "username": "kxntrast",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double total = x;\\n        if (x == 1)\\n            return 1;\\n        if (x == -1)\\n            return n%2 == 0 ? -x : x;\\n        if (n > 0) {\\n            for (int i =1; i < n; i++) {\\n                total *= x; \\n            }\\n        }\\n        else if (n < 0) {\\n            for (int i = -1; i > n; i--) {\\n                total *= x; \\n            }\\n            total = 1 / total;\\n        }\\n\\n        return total;\\n    }\\n};\\nx = 2.00000\\nn = -2147483648\\ntime limit exceeted, tests 301/309. What should I do to fix it?"
                    },
                    {
                        "username": "tifv",
                        "content": "This solution has complexity $O(n)$. You have to find a solution with better (like logarithmic) complexity."
                    },
                    {
                        "username": "pankaj_navale24",
                        "content": "2147483647"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Finally one that I actually know how to figure out before reading the editorial... Turns out that one time I learned to convert integers from decimal to binary by hand actually has a use"
                    }
                ]
            },
            {
                "id": 1996880,
                "content": [
                    {
                        "username": "QuasarZero",
                        "content": "\n*  O(N)  O(logN)\n* \n* 1\n\nEssential\n* Reduce time complexity from O(N) to O(logN) with binary tree\n* Reasonably handle the case where the exponent (n) is odd\n* Reasonably handle the case where the base and exponent are special values (for example: 1, etc.)"
                    },
                    {
                        "username": "munnaluri",
                        "content": "I am getting error for test case where x = 1.0000000000001 , n = -2147483648\\n\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        double result = x  ;\\n        int neg = 0 ; \\n        if (n == Integer.MAX_VALUE) \\n              return x;\\n        if ( n < 0 ){\\n            if ( n == Integer.MIN_VALUE){\\n                return  x == 1 || x == -1 ? 1 : 0 ;     \\n            }\\n            neg = n * -1 ; \\n        }else if ( n == 0 ){\\n            return 1 ; \\n        }else {\\n            neg = n ; \\n        }\\n\\n        for(int i = 1 ; i < neg ; i++){\\n            result = result * x ; \\n        }\\n\\n        if ( n < 0){\\n            result = 1/result ; \\n        }\\n\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "tifv",
                        "content": "Sure, because this particular case is incorrectly hardcoded in your solution :)\\n```\\nif (n == Integer.MIN_VALUE) {\\n    return x == 1 || x == -1 ? 1 : 0 ;\\n}\\n```"
                    },
                    {
                        "username": "dhwyaan",
                        "content": "Someone forgot to put a \"Don\\'t use built in functions and operators\" line"
                    },
                    {
                        "username": "jincanchamber",
                        "content": "Input\\nx =\\n1.0000000000001\\nn =\\n-2147483648\\n\\nUse Testcase\\nOutput\\n0.00000\\nExpected\\n0.99979\\n\\n\\nwhat???? "
                    },
                    {
                        "username": "tifv",
                        "content": "Do you have any problems with that? :)"
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "x =\\n0.00001\\nn =\\n2147483647\\n\\nINTERESTING..."
                    },
                    {
                        "username": "RinatFattakhov",
                        "content": "Not the best problem to practice Kotlin..."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "May be the objective of this problem is to learn binary exponentiation."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "After solving this, try looking into the official code for the pow function. It is mind boggling.\\nYou can easily check it your IDE."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "\\uD83E\\uDD2F"
                    },
                    {
                        "username": "kxntrast",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double total = x;\\n        if (x == 1)\\n            return 1;\\n        if (x == -1)\\n            return n%2 == 0 ? -x : x;\\n        if (n > 0) {\\n            for (int i =1; i < n; i++) {\\n                total *= x; \\n            }\\n        }\\n        else if (n < 0) {\\n            for (int i = -1; i > n; i--) {\\n                total *= x; \\n            }\\n            total = 1 / total;\\n        }\\n\\n        return total;\\n    }\\n};\\nx = 2.00000\\nn = -2147483648\\ntime limit exceeted, tests 301/309. What should I do to fix it?"
                    },
                    {
                        "username": "tifv",
                        "content": "This solution has complexity $O(n)$. You have to find a solution with better (like logarithmic) complexity."
                    },
                    {
                        "username": "pankaj_navale24",
                        "content": "2147483647"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Finally one that I actually know how to figure out before reading the editorial... Turns out that one time I learned to convert integers from decimal to binary by hand actually has a use"
                    }
                ]
            },
            {
                "id": 1995820,
                "content": [
                    {
                        "username": "QuasarZero",
                        "content": "\n*  O(N)  O(logN)\n* \n* 1\n\nEssential\n* Reduce time complexity from O(N) to O(logN) with binary tree\n* Reasonably handle the case where the exponent (n) is odd\n* Reasonably handle the case where the base and exponent are special values (for example: 1, etc.)"
                    },
                    {
                        "username": "munnaluri",
                        "content": "I am getting error for test case where x = 1.0000000000001 , n = -2147483648\\n\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        double result = x  ;\\n        int neg = 0 ; \\n        if (n == Integer.MAX_VALUE) \\n              return x;\\n        if ( n < 0 ){\\n            if ( n == Integer.MIN_VALUE){\\n                return  x == 1 || x == -1 ? 1 : 0 ;     \\n            }\\n            neg = n * -1 ; \\n        }else if ( n == 0 ){\\n            return 1 ; \\n        }else {\\n            neg = n ; \\n        }\\n\\n        for(int i = 1 ; i < neg ; i++){\\n            result = result * x ; \\n        }\\n\\n        if ( n < 0){\\n            result = 1/result ; \\n        }\\n\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "tifv",
                        "content": "Sure, because this particular case is incorrectly hardcoded in your solution :)\\n```\\nif (n == Integer.MIN_VALUE) {\\n    return x == 1 || x == -1 ? 1 : 0 ;\\n}\\n```"
                    },
                    {
                        "username": "dhwyaan",
                        "content": "Someone forgot to put a \"Don\\'t use built in functions and operators\" line"
                    },
                    {
                        "username": "jincanchamber",
                        "content": "Input\\nx =\\n1.0000000000001\\nn =\\n-2147483648\\n\\nUse Testcase\\nOutput\\n0.00000\\nExpected\\n0.99979\\n\\n\\nwhat???? "
                    },
                    {
                        "username": "tifv",
                        "content": "Do you have any problems with that? :)"
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "x =\\n0.00001\\nn =\\n2147483647\\n\\nINTERESTING..."
                    },
                    {
                        "username": "RinatFattakhov",
                        "content": "Not the best problem to practice Kotlin..."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "May be the objective of this problem is to learn binary exponentiation."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "After solving this, try looking into the official code for the pow function. It is mind boggling.\\nYou can easily check it your IDE."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "\\uD83E\\uDD2F"
                    },
                    {
                        "username": "kxntrast",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double total = x;\\n        if (x == 1)\\n            return 1;\\n        if (x == -1)\\n            return n%2 == 0 ? -x : x;\\n        if (n > 0) {\\n            for (int i =1; i < n; i++) {\\n                total *= x; \\n            }\\n        }\\n        else if (n < 0) {\\n            for (int i = -1; i > n; i--) {\\n                total *= x; \\n            }\\n            total = 1 / total;\\n        }\\n\\n        return total;\\n    }\\n};\\nx = 2.00000\\nn = -2147483648\\ntime limit exceeted, tests 301/309. What should I do to fix it?"
                    },
                    {
                        "username": "tifv",
                        "content": "This solution has complexity $O(n)$. You have to find a solution with better (like logarithmic) complexity."
                    },
                    {
                        "username": "pankaj_navale24",
                        "content": "2147483647"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Finally one that I actually know how to figure out before reading the editorial... Turns out that one time I learned to convert integers from decimal to binary by hand actually has a use"
                    }
                ]
            },
            {
                "id": 1991436,
                "content": [
                    {
                        "username": "QuasarZero",
                        "content": "\n*  O(N)  O(logN)\n* \n* 1\n\nEssential\n* Reduce time complexity from O(N) to O(logN) with binary tree\n* Reasonably handle the case where the exponent (n) is odd\n* Reasonably handle the case where the base and exponent are special values (for example: 1, etc.)"
                    },
                    {
                        "username": "munnaluri",
                        "content": "I am getting error for test case where x = 1.0000000000001 , n = -2147483648\\n\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        double result = x  ;\\n        int neg = 0 ; \\n        if (n == Integer.MAX_VALUE) \\n              return x;\\n        if ( n < 0 ){\\n            if ( n == Integer.MIN_VALUE){\\n                return  x == 1 || x == -1 ? 1 : 0 ;     \\n            }\\n            neg = n * -1 ; \\n        }else if ( n == 0 ){\\n            return 1 ; \\n        }else {\\n            neg = n ; \\n        }\\n\\n        for(int i = 1 ; i < neg ; i++){\\n            result = result * x ; \\n        }\\n\\n        if ( n < 0){\\n            result = 1/result ; \\n        }\\n\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "tifv",
                        "content": "Sure, because this particular case is incorrectly hardcoded in your solution :)\\n```\\nif (n == Integer.MIN_VALUE) {\\n    return x == 1 || x == -1 ? 1 : 0 ;\\n}\\n```"
                    },
                    {
                        "username": "dhwyaan",
                        "content": "Someone forgot to put a \"Don\\'t use built in functions and operators\" line"
                    },
                    {
                        "username": "jincanchamber",
                        "content": "Input\\nx =\\n1.0000000000001\\nn =\\n-2147483648\\n\\nUse Testcase\\nOutput\\n0.00000\\nExpected\\n0.99979\\n\\n\\nwhat???? "
                    },
                    {
                        "username": "tifv",
                        "content": "Do you have any problems with that? :)"
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "x =\\n0.00001\\nn =\\n2147483647\\n\\nINTERESTING..."
                    },
                    {
                        "username": "RinatFattakhov",
                        "content": "Not the best problem to practice Kotlin..."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "May be the objective of this problem is to learn binary exponentiation."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "After solving this, try looking into the official code for the pow function. It is mind boggling.\\nYou can easily check it your IDE."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "\\uD83E\\uDD2F"
                    },
                    {
                        "username": "kxntrast",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double total = x;\\n        if (x == 1)\\n            return 1;\\n        if (x == -1)\\n            return n%2 == 0 ? -x : x;\\n        if (n > 0) {\\n            for (int i =1; i < n; i++) {\\n                total *= x; \\n            }\\n        }\\n        else if (n < 0) {\\n            for (int i = -1; i > n; i--) {\\n                total *= x; \\n            }\\n            total = 1 / total;\\n        }\\n\\n        return total;\\n    }\\n};\\nx = 2.00000\\nn = -2147483648\\ntime limit exceeted, tests 301/309. What should I do to fix it?"
                    },
                    {
                        "username": "tifv",
                        "content": "This solution has complexity $O(n)$. You have to find a solution with better (like logarithmic) complexity."
                    },
                    {
                        "username": "pankaj_navale24",
                        "content": "2147483647"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Finally one that I actually know how to figure out before reading the editorial... Turns out that one time I learned to convert integers from decimal to binary by hand actually has a use"
                    }
                ]
            },
            {
                "id": 1987837,
                "content": [
                    {
                        "username": "QuasarZero",
                        "content": "\n*  O(N)  O(logN)\n* \n* 1\n\nEssential\n* Reduce time complexity from O(N) to O(logN) with binary tree\n* Reasonably handle the case where the exponent (n) is odd\n* Reasonably handle the case where the base and exponent are special values (for example: 1, etc.)"
                    },
                    {
                        "username": "munnaluri",
                        "content": "I am getting error for test case where x = 1.0000000000001 , n = -2147483648\\n\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        double result = x  ;\\n        int neg = 0 ; \\n        if (n == Integer.MAX_VALUE) \\n              return x;\\n        if ( n < 0 ){\\n            if ( n == Integer.MIN_VALUE){\\n                return  x == 1 || x == -1 ? 1 : 0 ;     \\n            }\\n            neg = n * -1 ; \\n        }else if ( n == 0 ){\\n            return 1 ; \\n        }else {\\n            neg = n ; \\n        }\\n\\n        for(int i = 1 ; i < neg ; i++){\\n            result = result * x ; \\n        }\\n\\n        if ( n < 0){\\n            result = 1/result ; \\n        }\\n\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "tifv",
                        "content": "Sure, because this particular case is incorrectly hardcoded in your solution :)\\n```\\nif (n == Integer.MIN_VALUE) {\\n    return x == 1 || x == -1 ? 1 : 0 ;\\n}\\n```"
                    },
                    {
                        "username": "dhwyaan",
                        "content": "Someone forgot to put a \"Don\\'t use built in functions and operators\" line"
                    },
                    {
                        "username": "jincanchamber",
                        "content": "Input\\nx =\\n1.0000000000001\\nn =\\n-2147483648\\n\\nUse Testcase\\nOutput\\n0.00000\\nExpected\\n0.99979\\n\\n\\nwhat???? "
                    },
                    {
                        "username": "tifv",
                        "content": "Do you have any problems with that? :)"
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "x =\\n0.00001\\nn =\\n2147483647\\n\\nINTERESTING..."
                    },
                    {
                        "username": "RinatFattakhov",
                        "content": "Not the best problem to practice Kotlin..."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "May be the objective of this problem is to learn binary exponentiation."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "After solving this, try looking into the official code for the pow function. It is mind boggling.\\nYou can easily check it your IDE."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "\\uD83E\\uDD2F"
                    },
                    {
                        "username": "kxntrast",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double total = x;\\n        if (x == 1)\\n            return 1;\\n        if (x == -1)\\n            return n%2 == 0 ? -x : x;\\n        if (n > 0) {\\n            for (int i =1; i < n; i++) {\\n                total *= x; \\n            }\\n        }\\n        else if (n < 0) {\\n            for (int i = -1; i > n; i--) {\\n                total *= x; \\n            }\\n            total = 1 / total;\\n        }\\n\\n        return total;\\n    }\\n};\\nx = 2.00000\\nn = -2147483648\\ntime limit exceeted, tests 301/309. What should I do to fix it?"
                    },
                    {
                        "username": "tifv",
                        "content": "This solution has complexity $O(n)$. You have to find a solution with better (like logarithmic) complexity."
                    },
                    {
                        "username": "pankaj_navale24",
                        "content": "2147483647"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Finally one that I actually know how to figure out before reading the editorial... Turns out that one time I learned to convert integers from decimal to binary by hand actually has a use"
                    }
                ]
            },
            {
                "id": 1986147,
                "content": [
                    {
                        "username": "QuasarZero",
                        "content": "\n*  O(N)  O(logN)\n* \n* 1\n\nEssential\n* Reduce time complexity from O(N) to O(logN) with binary tree\n* Reasonably handle the case where the exponent (n) is odd\n* Reasonably handle the case where the base and exponent are special values (for example: 1, etc.)"
                    },
                    {
                        "username": "munnaluri",
                        "content": "I am getting error for test case where x = 1.0000000000001 , n = -2147483648\\n\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        double result = x  ;\\n        int neg = 0 ; \\n        if (n == Integer.MAX_VALUE) \\n              return x;\\n        if ( n < 0 ){\\n            if ( n == Integer.MIN_VALUE){\\n                return  x == 1 || x == -1 ? 1 : 0 ;     \\n            }\\n            neg = n * -1 ; \\n        }else if ( n == 0 ){\\n            return 1 ; \\n        }else {\\n            neg = n ; \\n        }\\n\\n        for(int i = 1 ; i < neg ; i++){\\n            result = result * x ; \\n        }\\n\\n        if ( n < 0){\\n            result = 1/result ; \\n        }\\n\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "tifv",
                        "content": "Sure, because this particular case is incorrectly hardcoded in your solution :)\\n```\\nif (n == Integer.MIN_VALUE) {\\n    return x == 1 || x == -1 ? 1 : 0 ;\\n}\\n```"
                    },
                    {
                        "username": "dhwyaan",
                        "content": "Someone forgot to put a \"Don\\'t use built in functions and operators\" line"
                    },
                    {
                        "username": "jincanchamber",
                        "content": "Input\\nx =\\n1.0000000000001\\nn =\\n-2147483648\\n\\nUse Testcase\\nOutput\\n0.00000\\nExpected\\n0.99979\\n\\n\\nwhat???? "
                    },
                    {
                        "username": "tifv",
                        "content": "Do you have any problems with that? :)"
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "x =\\n0.00001\\nn =\\n2147483647\\n\\nINTERESTING..."
                    },
                    {
                        "username": "RinatFattakhov",
                        "content": "Not the best problem to practice Kotlin..."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "May be the objective of this problem is to learn binary exponentiation."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "After solving this, try looking into the official code for the pow function. It is mind boggling.\\nYou can easily check it your IDE."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "\\uD83E\\uDD2F"
                    },
                    {
                        "username": "kxntrast",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double total = x;\\n        if (x == 1)\\n            return 1;\\n        if (x == -1)\\n            return n%2 == 0 ? -x : x;\\n        if (n > 0) {\\n            for (int i =1; i < n; i++) {\\n                total *= x; \\n            }\\n        }\\n        else if (n < 0) {\\n            for (int i = -1; i > n; i--) {\\n                total *= x; \\n            }\\n            total = 1 / total;\\n        }\\n\\n        return total;\\n    }\\n};\\nx = 2.00000\\nn = -2147483648\\ntime limit exceeted, tests 301/309. What should I do to fix it?"
                    },
                    {
                        "username": "tifv",
                        "content": "This solution has complexity $O(n)$. You have to find a solution with better (like logarithmic) complexity."
                    },
                    {
                        "username": "pankaj_navale24",
                        "content": "2147483647"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Finally one that I actually know how to figure out before reading the editorial... Turns out that one time I learned to convert integers from decimal to binary by hand actually has a use"
                    }
                ]
            },
            {
                "id": 1984711,
                "content": [
                    {
                        "username": "QuasarZero",
                        "content": "\n*  O(N)  O(logN)\n* \n* 1\n\nEssential\n* Reduce time complexity from O(N) to O(logN) with binary tree\n* Reasonably handle the case where the exponent (n) is odd\n* Reasonably handle the case where the base and exponent are special values (for example: 1, etc.)"
                    },
                    {
                        "username": "munnaluri",
                        "content": "I am getting error for test case where x = 1.0000000000001 , n = -2147483648\\n\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        double result = x  ;\\n        int neg = 0 ; \\n        if (n == Integer.MAX_VALUE) \\n              return x;\\n        if ( n < 0 ){\\n            if ( n == Integer.MIN_VALUE){\\n                return  x == 1 || x == -1 ? 1 : 0 ;     \\n            }\\n            neg = n * -1 ; \\n        }else if ( n == 0 ){\\n            return 1 ; \\n        }else {\\n            neg = n ; \\n        }\\n\\n        for(int i = 1 ; i < neg ; i++){\\n            result = result * x ; \\n        }\\n\\n        if ( n < 0){\\n            result = 1/result ; \\n        }\\n\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "tifv",
                        "content": "Sure, because this particular case is incorrectly hardcoded in your solution :)\\n```\\nif (n == Integer.MIN_VALUE) {\\n    return x == 1 || x == -1 ? 1 : 0 ;\\n}\\n```"
                    },
                    {
                        "username": "dhwyaan",
                        "content": "Someone forgot to put a \"Don\\'t use built in functions and operators\" line"
                    },
                    {
                        "username": "jincanchamber",
                        "content": "Input\\nx =\\n1.0000000000001\\nn =\\n-2147483648\\n\\nUse Testcase\\nOutput\\n0.00000\\nExpected\\n0.99979\\n\\n\\nwhat???? "
                    },
                    {
                        "username": "tifv",
                        "content": "Do you have any problems with that? :)"
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "x =\\n0.00001\\nn =\\n2147483647\\n\\nINTERESTING..."
                    },
                    {
                        "username": "RinatFattakhov",
                        "content": "Not the best problem to practice Kotlin..."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "May be the objective of this problem is to learn binary exponentiation."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "After solving this, try looking into the official code for the pow function. It is mind boggling.\\nYou can easily check it your IDE."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "\\uD83E\\uDD2F"
                    },
                    {
                        "username": "kxntrast",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double total = x;\\n        if (x == 1)\\n            return 1;\\n        if (x == -1)\\n            return n%2 == 0 ? -x : x;\\n        if (n > 0) {\\n            for (int i =1; i < n; i++) {\\n                total *= x; \\n            }\\n        }\\n        else if (n < 0) {\\n            for (int i = -1; i > n; i--) {\\n                total *= x; \\n            }\\n            total = 1 / total;\\n        }\\n\\n        return total;\\n    }\\n};\\nx = 2.00000\\nn = -2147483648\\ntime limit exceeted, tests 301/309. What should I do to fix it?"
                    },
                    {
                        "username": "tifv",
                        "content": "This solution has complexity $O(n)$. You have to find a solution with better (like logarithmic) complexity."
                    },
                    {
                        "username": "pankaj_navale24",
                        "content": "2147483647"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Finally one that I actually know how to figure out before reading the editorial... Turns out that one time I learned to convert integers from decimal to binary by hand actually has a use"
                    }
                ]
            },
            {
                "id": 1984681,
                "content": [
                    {
                        "username": "QuasarZero",
                        "content": "\n*  O(N)  O(logN)\n* \n* 1\n\nEssential\n* Reduce time complexity from O(N) to O(logN) with binary tree\n* Reasonably handle the case where the exponent (n) is odd\n* Reasonably handle the case where the base and exponent are special values (for example: 1, etc.)"
                    },
                    {
                        "username": "munnaluri",
                        "content": "I am getting error for test case where x = 1.0000000000001 , n = -2147483648\\n\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        double result = x  ;\\n        int neg = 0 ; \\n        if (n == Integer.MAX_VALUE) \\n              return x;\\n        if ( n < 0 ){\\n            if ( n == Integer.MIN_VALUE){\\n                return  x == 1 || x == -1 ? 1 : 0 ;     \\n            }\\n            neg = n * -1 ; \\n        }else if ( n == 0 ){\\n            return 1 ; \\n        }else {\\n            neg = n ; \\n        }\\n\\n        for(int i = 1 ; i < neg ; i++){\\n            result = result * x ; \\n        }\\n\\n        if ( n < 0){\\n            result = 1/result ; \\n        }\\n\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "tifv",
                        "content": "Sure, because this particular case is incorrectly hardcoded in your solution :)\\n```\\nif (n == Integer.MIN_VALUE) {\\n    return x == 1 || x == -1 ? 1 : 0 ;\\n}\\n```"
                    },
                    {
                        "username": "dhwyaan",
                        "content": "Someone forgot to put a \"Don\\'t use built in functions and operators\" line"
                    },
                    {
                        "username": "jincanchamber",
                        "content": "Input\\nx =\\n1.0000000000001\\nn =\\n-2147483648\\n\\nUse Testcase\\nOutput\\n0.00000\\nExpected\\n0.99979\\n\\n\\nwhat???? "
                    },
                    {
                        "username": "tifv",
                        "content": "Do you have any problems with that? :)"
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "x =\\n0.00001\\nn =\\n2147483647\\n\\nINTERESTING..."
                    },
                    {
                        "username": "RinatFattakhov",
                        "content": "Not the best problem to practice Kotlin..."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "May be the objective of this problem is to learn binary exponentiation."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "After solving this, try looking into the official code for the pow function. It is mind boggling.\\nYou can easily check it your IDE."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "\\uD83E\\uDD2F"
                    },
                    {
                        "username": "kxntrast",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double total = x;\\n        if (x == 1)\\n            return 1;\\n        if (x == -1)\\n            return n%2 == 0 ? -x : x;\\n        if (n > 0) {\\n            for (int i =1; i < n; i++) {\\n                total *= x; \\n            }\\n        }\\n        else if (n < 0) {\\n            for (int i = -1; i > n; i--) {\\n                total *= x; \\n            }\\n            total = 1 / total;\\n        }\\n\\n        return total;\\n    }\\n};\\nx = 2.00000\\nn = -2147483648\\ntime limit exceeted, tests 301/309. What should I do to fix it?"
                    },
                    {
                        "username": "tifv",
                        "content": "This solution has complexity $O(n)$. You have to find a solution with better (like logarithmic) complexity."
                    },
                    {
                        "username": "pankaj_navale24",
                        "content": "2147483647"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Finally one that I actually know how to figure out before reading the editorial... Turns out that one time I learned to convert integers from decimal to binary by hand actually has a use"
                    }
                ]
            },
            {
                "id": 1984554,
                "content": [
                    {
                        "username": "QuasarZero",
                        "content": "\n*  O(N)  O(logN)\n* \n* 1\n\nEssential\n* Reduce time complexity from O(N) to O(logN) with binary tree\n* Reasonably handle the case where the exponent (n) is odd\n* Reasonably handle the case where the base and exponent are special values (for example: 1, etc.)"
                    },
                    {
                        "username": "munnaluri",
                        "content": "I am getting error for test case where x = 1.0000000000001 , n = -2147483648\\n\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        double result = x  ;\\n        int neg = 0 ; \\n        if (n == Integer.MAX_VALUE) \\n              return x;\\n        if ( n < 0 ){\\n            if ( n == Integer.MIN_VALUE){\\n                return  x == 1 || x == -1 ? 1 : 0 ;     \\n            }\\n            neg = n * -1 ; \\n        }else if ( n == 0 ){\\n            return 1 ; \\n        }else {\\n            neg = n ; \\n        }\\n\\n        for(int i = 1 ; i < neg ; i++){\\n            result = result * x ; \\n        }\\n\\n        if ( n < 0){\\n            result = 1/result ; \\n        }\\n\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "tifv",
                        "content": "Sure, because this particular case is incorrectly hardcoded in your solution :)\\n```\\nif (n == Integer.MIN_VALUE) {\\n    return x == 1 || x == -1 ? 1 : 0 ;\\n}\\n```"
                    },
                    {
                        "username": "dhwyaan",
                        "content": "Someone forgot to put a \"Don\\'t use built in functions and operators\" line"
                    },
                    {
                        "username": "jincanchamber",
                        "content": "Input\\nx =\\n1.0000000000001\\nn =\\n-2147483648\\n\\nUse Testcase\\nOutput\\n0.00000\\nExpected\\n0.99979\\n\\n\\nwhat???? "
                    },
                    {
                        "username": "tifv",
                        "content": "Do you have any problems with that? :)"
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "x =\\n0.00001\\nn =\\n2147483647\\n\\nINTERESTING..."
                    },
                    {
                        "username": "RinatFattakhov",
                        "content": "Not the best problem to practice Kotlin..."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "May be the objective of this problem is to learn binary exponentiation."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "After solving this, try looking into the official code for the pow function. It is mind boggling.\\nYou can easily check it your IDE."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "\\uD83E\\uDD2F"
                    },
                    {
                        "username": "kxntrast",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double total = x;\\n        if (x == 1)\\n            return 1;\\n        if (x == -1)\\n            return n%2 == 0 ? -x : x;\\n        if (n > 0) {\\n            for (int i =1; i < n; i++) {\\n                total *= x; \\n            }\\n        }\\n        else if (n < 0) {\\n            for (int i = -1; i > n; i--) {\\n                total *= x; \\n            }\\n            total = 1 / total;\\n        }\\n\\n        return total;\\n    }\\n};\\nx = 2.00000\\nn = -2147483648\\ntime limit exceeted, tests 301/309. What should I do to fix it?"
                    },
                    {
                        "username": "tifv",
                        "content": "This solution has complexity $O(n)$. You have to find a solution with better (like logarithmic) complexity."
                    },
                    {
                        "username": "pankaj_navale24",
                        "content": "2147483647"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Finally one that I actually know how to figure out before reading the editorial... Turns out that one time I learned to convert integers from decimal to binary by hand actually has a use"
                    }
                ]
            },
            {
                "id": 1984552,
                "content": [
                    {
                        "username": "SabihaKhan",
                        "content": "It accepted my answer using Math.pow method in java\\uD83D\\uDE15"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "cheating, cheating karta hai tu \\uD83D\\uDE1F"
                    },
                    {
                        "username": "khe1154",
                        "content": "not a good interview question but its nice to know how `Math.pow` is implemented"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Close enough. Note that the true pow() function can accept a double exponent, not just an integer."
                    },
                    {
                        "username": "codingconcierge",
                        "content": "If you solve the problem as intended, as the editorial shows, you will gain a lot. Don\\'t skip this one."
                    },
                    {
                        "username": "aman2k1",
                        "content": "why everyone is just using pow function when question is stating implement it ?"
                    },
                    {
                        "username": "charonme",
                        "content": "testcase 305 / 306\nx = 1.0000000000001\nn = -2147483648\ndoesn't work in PHP because the x accepted by the function evaluates to int 1\n\nwhen I force the type as `function myPow(double $x, $n) {` it gives a runtime error \"Uncaught TypeError: Solution::myPow(): Argument #1 (\\$x) must be of type double, int given\".\n\nAnd `echo gettype($x);` says it's an integer"
                    },
                    {
                        "username": "sandeep0423",
                        "content": "For test case 305: x = 1.0000000000001 and n = -2147483648 I get output as 0.99979 but in leetcode my output is 1.00000. which is not matching expected output 0.99979. Why is this different? Can anyone tell me?"
                    },
                    {
                        "username": "sandeep0423",
                        "content": "[@tifv](/tifv) Yes, I am running the program on notepad++ first. Then I copy it on leetcode"
                    },
                    {
                        "username": "tifv",
                        "content": "It is hard to answer such question without seeing the code. Also, the question itself is not clear: what do \\u201CI get output\\u201D and \\u201Cin leetcode my output is\\u201D mean? Are you running your program somewhere outside of leetcode and getting different results?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "come on, this `return Math.pow(x, n); `should not be aacceptable"
                    },
                    {
                        "username": "IhorPryyma",
                        "content": "is it really Medium task?"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Who the hxxx made the last test case"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "Hey Guys, Just wanted to know that  I have implemented both recursive and iterative O(log n) solution but the recursive one beats  100% users while iterative solution beats only 16.69% users. Why so?\\n\\nI think most people implemented the recursive solution and there is some percentage system going on\\n\\nbut recursive solution took 0ms to complete while the iterative took 3ms to complete, why iterative took more time?\\n"
                    },
                    {
                        "username": "grovre",
                        "content": "Depends on how you implemented it which we can\\'t see"
                    }
                ]
            },
            {
                "id": 1984484,
                "content": [
                    {
                        "username": "SabihaKhan",
                        "content": "It accepted my answer using Math.pow method in java\\uD83D\\uDE15"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "cheating, cheating karta hai tu \\uD83D\\uDE1F"
                    },
                    {
                        "username": "khe1154",
                        "content": "not a good interview question but its nice to know how `Math.pow` is implemented"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Close enough. Note that the true pow() function can accept a double exponent, not just an integer."
                    },
                    {
                        "username": "codingconcierge",
                        "content": "If you solve the problem as intended, as the editorial shows, you will gain a lot. Don\\'t skip this one."
                    },
                    {
                        "username": "aman2k1",
                        "content": "why everyone is just using pow function when question is stating implement it ?"
                    },
                    {
                        "username": "charonme",
                        "content": "testcase 305 / 306\nx = 1.0000000000001\nn = -2147483648\ndoesn't work in PHP because the x accepted by the function evaluates to int 1\n\nwhen I force the type as `function myPow(double $x, $n) {` it gives a runtime error \"Uncaught TypeError: Solution::myPow(): Argument #1 (\\$x) must be of type double, int given\".\n\nAnd `echo gettype($x);` says it's an integer"
                    },
                    {
                        "username": "sandeep0423",
                        "content": "For test case 305: x = 1.0000000000001 and n = -2147483648 I get output as 0.99979 but in leetcode my output is 1.00000. which is not matching expected output 0.99979. Why is this different? Can anyone tell me?"
                    },
                    {
                        "username": "sandeep0423",
                        "content": "[@tifv](/tifv) Yes, I am running the program on notepad++ first. Then I copy it on leetcode"
                    },
                    {
                        "username": "tifv",
                        "content": "It is hard to answer such question without seeing the code. Also, the question itself is not clear: what do \\u201CI get output\\u201D and \\u201Cin leetcode my output is\\u201D mean? Are you running your program somewhere outside of leetcode and getting different results?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "come on, this `return Math.pow(x, n); `should not be aacceptable"
                    },
                    {
                        "username": "IhorPryyma",
                        "content": "is it really Medium task?"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Who the hxxx made the last test case"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "Hey Guys, Just wanted to know that  I have implemented both recursive and iterative O(log n) solution but the recursive one beats  100% users while iterative solution beats only 16.69% users. Why so?\\n\\nI think most people implemented the recursive solution and there is some percentage system going on\\n\\nbut recursive solution took 0ms to complete while the iterative took 3ms to complete, why iterative took more time?\\n"
                    },
                    {
                        "username": "grovre",
                        "content": "Depends on how you implemented it which we can\\'t see"
                    }
                ]
            },
            {
                "id": 1984441,
                "content": [
                    {
                        "username": "SabihaKhan",
                        "content": "It accepted my answer using Math.pow method in java\\uD83D\\uDE15"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "cheating, cheating karta hai tu \\uD83D\\uDE1F"
                    },
                    {
                        "username": "khe1154",
                        "content": "not a good interview question but its nice to know how `Math.pow` is implemented"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Close enough. Note that the true pow() function can accept a double exponent, not just an integer."
                    },
                    {
                        "username": "codingconcierge",
                        "content": "If you solve the problem as intended, as the editorial shows, you will gain a lot. Don\\'t skip this one."
                    },
                    {
                        "username": "aman2k1",
                        "content": "why everyone is just using pow function when question is stating implement it ?"
                    },
                    {
                        "username": "charonme",
                        "content": "testcase 305 / 306\nx = 1.0000000000001\nn = -2147483648\ndoesn't work in PHP because the x accepted by the function evaluates to int 1\n\nwhen I force the type as `function myPow(double $x, $n) {` it gives a runtime error \"Uncaught TypeError: Solution::myPow(): Argument #1 (\\$x) must be of type double, int given\".\n\nAnd `echo gettype($x);` says it's an integer"
                    },
                    {
                        "username": "sandeep0423",
                        "content": "For test case 305: x = 1.0000000000001 and n = -2147483648 I get output as 0.99979 but in leetcode my output is 1.00000. which is not matching expected output 0.99979. Why is this different? Can anyone tell me?"
                    },
                    {
                        "username": "sandeep0423",
                        "content": "[@tifv](/tifv) Yes, I am running the program on notepad++ first. Then I copy it on leetcode"
                    },
                    {
                        "username": "tifv",
                        "content": "It is hard to answer such question without seeing the code. Also, the question itself is not clear: what do \\u201CI get output\\u201D and \\u201Cin leetcode my output is\\u201D mean? Are you running your program somewhere outside of leetcode and getting different results?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "come on, this `return Math.pow(x, n); `should not be aacceptable"
                    },
                    {
                        "username": "IhorPryyma",
                        "content": "is it really Medium task?"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Who the hxxx made the last test case"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "Hey Guys, Just wanted to know that  I have implemented both recursive and iterative O(log n) solution but the recursive one beats  100% users while iterative solution beats only 16.69% users. Why so?\\n\\nI think most people implemented the recursive solution and there is some percentage system going on\\n\\nbut recursive solution took 0ms to complete while the iterative took 3ms to complete, why iterative took more time?\\n"
                    },
                    {
                        "username": "grovre",
                        "content": "Depends on how you implemented it which we can\\'t see"
                    }
                ]
            },
            {
                "id": 1984430,
                "content": [
                    {
                        "username": "SabihaKhan",
                        "content": "It accepted my answer using Math.pow method in java\\uD83D\\uDE15"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "cheating, cheating karta hai tu \\uD83D\\uDE1F"
                    },
                    {
                        "username": "khe1154",
                        "content": "not a good interview question but its nice to know how `Math.pow` is implemented"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Close enough. Note that the true pow() function can accept a double exponent, not just an integer."
                    },
                    {
                        "username": "codingconcierge",
                        "content": "If you solve the problem as intended, as the editorial shows, you will gain a lot. Don\\'t skip this one."
                    },
                    {
                        "username": "aman2k1",
                        "content": "why everyone is just using pow function when question is stating implement it ?"
                    },
                    {
                        "username": "charonme",
                        "content": "testcase 305 / 306\nx = 1.0000000000001\nn = -2147483648\ndoesn't work in PHP because the x accepted by the function evaluates to int 1\n\nwhen I force the type as `function myPow(double $x, $n) {` it gives a runtime error \"Uncaught TypeError: Solution::myPow(): Argument #1 (\\$x) must be of type double, int given\".\n\nAnd `echo gettype($x);` says it's an integer"
                    },
                    {
                        "username": "sandeep0423",
                        "content": "For test case 305: x = 1.0000000000001 and n = -2147483648 I get output as 0.99979 but in leetcode my output is 1.00000. which is not matching expected output 0.99979. Why is this different? Can anyone tell me?"
                    },
                    {
                        "username": "sandeep0423",
                        "content": "[@tifv](/tifv) Yes, I am running the program on notepad++ first. Then I copy it on leetcode"
                    },
                    {
                        "username": "tifv",
                        "content": "It is hard to answer such question without seeing the code. Also, the question itself is not clear: what do \\u201CI get output\\u201D and \\u201Cin leetcode my output is\\u201D mean? Are you running your program somewhere outside of leetcode and getting different results?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "come on, this `return Math.pow(x, n); `should not be aacceptable"
                    },
                    {
                        "username": "IhorPryyma",
                        "content": "is it really Medium task?"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Who the hxxx made the last test case"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "Hey Guys, Just wanted to know that  I have implemented both recursive and iterative O(log n) solution but the recursive one beats  100% users while iterative solution beats only 16.69% users. Why so?\\n\\nI think most people implemented the recursive solution and there is some percentage system going on\\n\\nbut recursive solution took 0ms to complete while the iterative took 3ms to complete, why iterative took more time?\\n"
                    },
                    {
                        "username": "grovre",
                        "content": "Depends on how you implemented it which we can\\'t see"
                    }
                ]
            },
            {
                "id": 1984386,
                "content": [
                    {
                        "username": "SabihaKhan",
                        "content": "It accepted my answer using Math.pow method in java\\uD83D\\uDE15"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "cheating, cheating karta hai tu \\uD83D\\uDE1F"
                    },
                    {
                        "username": "khe1154",
                        "content": "not a good interview question but its nice to know how `Math.pow` is implemented"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Close enough. Note that the true pow() function can accept a double exponent, not just an integer."
                    },
                    {
                        "username": "codingconcierge",
                        "content": "If you solve the problem as intended, as the editorial shows, you will gain a lot. Don\\'t skip this one."
                    },
                    {
                        "username": "aman2k1",
                        "content": "why everyone is just using pow function when question is stating implement it ?"
                    },
                    {
                        "username": "charonme",
                        "content": "testcase 305 / 306\nx = 1.0000000000001\nn = -2147483648\ndoesn't work in PHP because the x accepted by the function evaluates to int 1\n\nwhen I force the type as `function myPow(double $x, $n) {` it gives a runtime error \"Uncaught TypeError: Solution::myPow(): Argument #1 (\\$x) must be of type double, int given\".\n\nAnd `echo gettype($x);` says it's an integer"
                    },
                    {
                        "username": "sandeep0423",
                        "content": "For test case 305: x = 1.0000000000001 and n = -2147483648 I get output as 0.99979 but in leetcode my output is 1.00000. which is not matching expected output 0.99979. Why is this different? Can anyone tell me?"
                    },
                    {
                        "username": "sandeep0423",
                        "content": "[@tifv](/tifv) Yes, I am running the program on notepad++ first. Then I copy it on leetcode"
                    },
                    {
                        "username": "tifv",
                        "content": "It is hard to answer such question without seeing the code. Also, the question itself is not clear: what do \\u201CI get output\\u201D and \\u201Cin leetcode my output is\\u201D mean? Are you running your program somewhere outside of leetcode and getting different results?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "come on, this `return Math.pow(x, n); `should not be aacceptable"
                    },
                    {
                        "username": "IhorPryyma",
                        "content": "is it really Medium task?"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Who the hxxx made the last test case"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "Hey Guys, Just wanted to know that  I have implemented both recursive and iterative O(log n) solution but the recursive one beats  100% users while iterative solution beats only 16.69% users. Why so?\\n\\nI think most people implemented the recursive solution and there is some percentage system going on\\n\\nbut recursive solution took 0ms to complete while the iterative took 3ms to complete, why iterative took more time?\\n"
                    },
                    {
                        "username": "grovre",
                        "content": "Depends on how you implemented it which we can\\'t see"
                    }
                ]
            },
            {
                "id": 1984176,
                "content": [
                    {
                        "username": "SabihaKhan",
                        "content": "It accepted my answer using Math.pow method in java\\uD83D\\uDE15"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "cheating, cheating karta hai tu \\uD83D\\uDE1F"
                    },
                    {
                        "username": "khe1154",
                        "content": "not a good interview question but its nice to know how `Math.pow` is implemented"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Close enough. Note that the true pow() function can accept a double exponent, not just an integer."
                    },
                    {
                        "username": "codingconcierge",
                        "content": "If you solve the problem as intended, as the editorial shows, you will gain a lot. Don\\'t skip this one."
                    },
                    {
                        "username": "aman2k1",
                        "content": "why everyone is just using pow function when question is stating implement it ?"
                    },
                    {
                        "username": "charonme",
                        "content": "testcase 305 / 306\nx = 1.0000000000001\nn = -2147483648\ndoesn't work in PHP because the x accepted by the function evaluates to int 1\n\nwhen I force the type as `function myPow(double $x, $n) {` it gives a runtime error \"Uncaught TypeError: Solution::myPow(): Argument #1 (\\$x) must be of type double, int given\".\n\nAnd `echo gettype($x);` says it's an integer"
                    },
                    {
                        "username": "sandeep0423",
                        "content": "For test case 305: x = 1.0000000000001 and n = -2147483648 I get output as 0.99979 but in leetcode my output is 1.00000. which is not matching expected output 0.99979. Why is this different? Can anyone tell me?"
                    },
                    {
                        "username": "sandeep0423",
                        "content": "[@tifv](/tifv) Yes, I am running the program on notepad++ first. Then I copy it on leetcode"
                    },
                    {
                        "username": "tifv",
                        "content": "It is hard to answer such question without seeing the code. Also, the question itself is not clear: what do \\u201CI get output\\u201D and \\u201Cin leetcode my output is\\u201D mean? Are you running your program somewhere outside of leetcode and getting different results?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "come on, this `return Math.pow(x, n); `should not be aacceptable"
                    },
                    {
                        "username": "IhorPryyma",
                        "content": "is it really Medium task?"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Who the hxxx made the last test case"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "Hey Guys, Just wanted to know that  I have implemented both recursive and iterative O(log n) solution but the recursive one beats  100% users while iterative solution beats only 16.69% users. Why so?\\n\\nI think most people implemented the recursive solution and there is some percentage system going on\\n\\nbut recursive solution took 0ms to complete while the iterative took 3ms to complete, why iterative took more time?\\n"
                    },
                    {
                        "username": "grovre",
                        "content": "Depends on how you implemented it which we can\\'t see"
                    }
                ]
            },
            {
                "id": 1984167,
                "content": [
                    {
                        "username": "SabihaKhan",
                        "content": "It accepted my answer using Math.pow method in java\\uD83D\\uDE15"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "cheating, cheating karta hai tu \\uD83D\\uDE1F"
                    },
                    {
                        "username": "khe1154",
                        "content": "not a good interview question but its nice to know how `Math.pow` is implemented"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Close enough. Note that the true pow() function can accept a double exponent, not just an integer."
                    },
                    {
                        "username": "codingconcierge",
                        "content": "If you solve the problem as intended, as the editorial shows, you will gain a lot. Don\\'t skip this one."
                    },
                    {
                        "username": "aman2k1",
                        "content": "why everyone is just using pow function when question is stating implement it ?"
                    },
                    {
                        "username": "charonme",
                        "content": "testcase 305 / 306\nx = 1.0000000000001\nn = -2147483648\ndoesn't work in PHP because the x accepted by the function evaluates to int 1\n\nwhen I force the type as `function myPow(double $x, $n) {` it gives a runtime error \"Uncaught TypeError: Solution::myPow(): Argument #1 (\\$x) must be of type double, int given\".\n\nAnd `echo gettype($x);` says it's an integer"
                    },
                    {
                        "username": "sandeep0423",
                        "content": "For test case 305: x = 1.0000000000001 and n = -2147483648 I get output as 0.99979 but in leetcode my output is 1.00000. which is not matching expected output 0.99979. Why is this different? Can anyone tell me?"
                    },
                    {
                        "username": "sandeep0423",
                        "content": "[@tifv](/tifv) Yes, I am running the program on notepad++ first. Then I copy it on leetcode"
                    },
                    {
                        "username": "tifv",
                        "content": "It is hard to answer such question without seeing the code. Also, the question itself is not clear: what do \\u201CI get output\\u201D and \\u201Cin leetcode my output is\\u201D mean? Are you running your program somewhere outside of leetcode and getting different results?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "come on, this `return Math.pow(x, n); `should not be aacceptable"
                    },
                    {
                        "username": "IhorPryyma",
                        "content": "is it really Medium task?"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Who the hxxx made the last test case"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "Hey Guys, Just wanted to know that  I have implemented both recursive and iterative O(log n) solution but the recursive one beats  100% users while iterative solution beats only 16.69% users. Why so?\\n\\nI think most people implemented the recursive solution and there is some percentage system going on\\n\\nbut recursive solution took 0ms to complete while the iterative took 3ms to complete, why iterative took more time?\\n"
                    },
                    {
                        "username": "grovre",
                        "content": "Depends on how you implemented it which we can\\'t see"
                    }
                ]
            },
            {
                "id": 1984145,
                "content": [
                    {
                        "username": "SabihaKhan",
                        "content": "It accepted my answer using Math.pow method in java\\uD83D\\uDE15"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "cheating, cheating karta hai tu \\uD83D\\uDE1F"
                    },
                    {
                        "username": "khe1154",
                        "content": "not a good interview question but its nice to know how `Math.pow` is implemented"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Close enough. Note that the true pow() function can accept a double exponent, not just an integer."
                    },
                    {
                        "username": "codingconcierge",
                        "content": "If you solve the problem as intended, as the editorial shows, you will gain a lot. Don\\'t skip this one."
                    },
                    {
                        "username": "aman2k1",
                        "content": "why everyone is just using pow function when question is stating implement it ?"
                    },
                    {
                        "username": "charonme",
                        "content": "testcase 305 / 306\nx = 1.0000000000001\nn = -2147483648\ndoesn't work in PHP because the x accepted by the function evaluates to int 1\n\nwhen I force the type as `function myPow(double $x, $n) {` it gives a runtime error \"Uncaught TypeError: Solution::myPow(): Argument #1 (\\$x) must be of type double, int given\".\n\nAnd `echo gettype($x);` says it's an integer"
                    },
                    {
                        "username": "sandeep0423",
                        "content": "For test case 305: x = 1.0000000000001 and n = -2147483648 I get output as 0.99979 but in leetcode my output is 1.00000. which is not matching expected output 0.99979. Why is this different? Can anyone tell me?"
                    },
                    {
                        "username": "sandeep0423",
                        "content": "[@tifv](/tifv) Yes, I am running the program on notepad++ first. Then I copy it on leetcode"
                    },
                    {
                        "username": "tifv",
                        "content": "It is hard to answer such question without seeing the code. Also, the question itself is not clear: what do \\u201CI get output\\u201D and \\u201Cin leetcode my output is\\u201D mean? Are you running your program somewhere outside of leetcode and getting different results?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "come on, this `return Math.pow(x, n); `should not be aacceptable"
                    },
                    {
                        "username": "IhorPryyma",
                        "content": "is it really Medium task?"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Who the hxxx made the last test case"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "Hey Guys, Just wanted to know that  I have implemented both recursive and iterative O(log n) solution but the recursive one beats  100% users while iterative solution beats only 16.69% users. Why so?\\n\\nI think most people implemented the recursive solution and there is some percentage system going on\\n\\nbut recursive solution took 0ms to complete while the iterative took 3ms to complete, why iterative took more time?\\n"
                    },
                    {
                        "username": "grovre",
                        "content": "Depends on how you implemented it which we can\\'t see"
                    }
                ]
            },
            {
                "id": 1984055,
                "content": [
                    {
                        "username": "SabihaKhan",
                        "content": "It accepted my answer using Math.pow method in java\\uD83D\\uDE15"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "cheating, cheating karta hai tu \\uD83D\\uDE1F"
                    },
                    {
                        "username": "khe1154",
                        "content": "not a good interview question but its nice to know how `Math.pow` is implemented"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Close enough. Note that the true pow() function can accept a double exponent, not just an integer."
                    },
                    {
                        "username": "codingconcierge",
                        "content": "If you solve the problem as intended, as the editorial shows, you will gain a lot. Don\\'t skip this one."
                    },
                    {
                        "username": "aman2k1",
                        "content": "why everyone is just using pow function when question is stating implement it ?"
                    },
                    {
                        "username": "charonme",
                        "content": "testcase 305 / 306\nx = 1.0000000000001\nn = -2147483648\ndoesn't work in PHP because the x accepted by the function evaluates to int 1\n\nwhen I force the type as `function myPow(double $x, $n) {` it gives a runtime error \"Uncaught TypeError: Solution::myPow(): Argument #1 (\\$x) must be of type double, int given\".\n\nAnd `echo gettype($x);` says it's an integer"
                    },
                    {
                        "username": "sandeep0423",
                        "content": "For test case 305: x = 1.0000000000001 and n = -2147483648 I get output as 0.99979 but in leetcode my output is 1.00000. which is not matching expected output 0.99979. Why is this different? Can anyone tell me?"
                    },
                    {
                        "username": "sandeep0423",
                        "content": "[@tifv](/tifv) Yes, I am running the program on notepad++ first. Then I copy it on leetcode"
                    },
                    {
                        "username": "tifv",
                        "content": "It is hard to answer such question without seeing the code. Also, the question itself is not clear: what do \\u201CI get output\\u201D and \\u201Cin leetcode my output is\\u201D mean? Are you running your program somewhere outside of leetcode and getting different results?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "come on, this `return Math.pow(x, n); `should not be aacceptable"
                    },
                    {
                        "username": "IhorPryyma",
                        "content": "is it really Medium task?"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Who the hxxx made the last test case"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "Hey Guys, Just wanted to know that  I have implemented both recursive and iterative O(log n) solution but the recursive one beats  100% users while iterative solution beats only 16.69% users. Why so?\\n\\nI think most people implemented the recursive solution and there is some percentage system going on\\n\\nbut recursive solution took 0ms to complete while the iterative took 3ms to complete, why iterative took more time?\\n"
                    },
                    {
                        "username": "grovre",
                        "content": "Depends on how you implemented it which we can\\'t see"
                    }
                ]
            },
            {
                "id": 1984020,
                "content": [
                    {
                        "username": "SabihaKhan",
                        "content": "It accepted my answer using Math.pow method in java\\uD83D\\uDE15"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "cheating, cheating karta hai tu \\uD83D\\uDE1F"
                    },
                    {
                        "username": "khe1154",
                        "content": "not a good interview question but its nice to know how `Math.pow` is implemented"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Close enough. Note that the true pow() function can accept a double exponent, not just an integer."
                    },
                    {
                        "username": "codingconcierge",
                        "content": "If you solve the problem as intended, as the editorial shows, you will gain a lot. Don\\'t skip this one."
                    },
                    {
                        "username": "aman2k1",
                        "content": "why everyone is just using pow function when question is stating implement it ?"
                    },
                    {
                        "username": "charonme",
                        "content": "testcase 305 / 306\nx = 1.0000000000001\nn = -2147483648\ndoesn't work in PHP because the x accepted by the function evaluates to int 1\n\nwhen I force the type as `function myPow(double $x, $n) {` it gives a runtime error \"Uncaught TypeError: Solution::myPow(): Argument #1 (\\$x) must be of type double, int given\".\n\nAnd `echo gettype($x);` says it's an integer"
                    },
                    {
                        "username": "sandeep0423",
                        "content": "For test case 305: x = 1.0000000000001 and n = -2147483648 I get output as 0.99979 but in leetcode my output is 1.00000. which is not matching expected output 0.99979. Why is this different? Can anyone tell me?"
                    },
                    {
                        "username": "sandeep0423",
                        "content": "[@tifv](/tifv) Yes, I am running the program on notepad++ first. Then I copy it on leetcode"
                    },
                    {
                        "username": "tifv",
                        "content": "It is hard to answer such question without seeing the code. Also, the question itself is not clear: what do \\u201CI get output\\u201D and \\u201Cin leetcode my output is\\u201D mean? Are you running your program somewhere outside of leetcode and getting different results?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "come on, this `return Math.pow(x, n); `should not be aacceptable"
                    },
                    {
                        "username": "IhorPryyma",
                        "content": "is it really Medium task?"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Who the hxxx made the last test case"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "Hey Guys, Just wanted to know that  I have implemented both recursive and iterative O(log n) solution but the recursive one beats  100% users while iterative solution beats only 16.69% users. Why so?\\n\\nI think most people implemented the recursive solution and there is some percentage system going on\\n\\nbut recursive solution took 0ms to complete while the iterative took 3ms to complete, why iterative took more time?\\n"
                    },
                    {
                        "username": "grovre",
                        "content": "Depends on how you implemented it which we can\\'t see"
                    }
                ]
            },
            {
                "id": 1983893,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "the solution lies in the question title ..."
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Does somebody know why with this solution for the `x = 2; n = -2147483648` case I've got `Time Limit Exceeded`:\n```\nfunction myPow(x: number, n: number): number {\n    if (!n)  return 1;\n\n    let result = x;\n\n    for (let i = 2; i <= Math.abs(n); i++) {\n        result *= x;\n    }\n\n    return n > 0 ? result : 1 / result;\n};\n```\n\nBut if I add extra checks for `x = 1` and `x = -1` - everything is good for the same case where `x = 2; n = -2147483648`.\n```\nfunction myPow(x: number, n: number): number {\n   //region extra checks for `x = 1` and `x = -1`, to make case with `x = 2` works..\n    if (x === 1) {\n        return 1;\n    }\n\n    if (x === -1) { \n        return n % 2 === 0 ? -x : x;\n    }\n   //endregion\n\n    if (!n) {\n        return 1;\n    }\n    \n    let result = x;\n\n    for (let i = 2; i <= Math.abs(n); i++) {\n        result *= x;\n    }\n\n    return n > 0 ? result : 1 / result;\n};\n```"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "[@psionl0](/psionl0) 0.1^-2147483648 != 0."
                    },
                    {
                        "username": "psionl0",
                        "content": "2147483648 multiplications will take a long time. You need to converge on the answer more rapidly. You can take advantage of the fact that if n is an even number then x^n = (x * x)^(n / 2).\n\n(Note also that when n = -2147483648 you can just return 0)."
                    },
                    {
                        "username": "vetor",
                        "content": "one way is to directly use math module which i wont suggest for medium easy question "
                    },
                    {
                        "username": "jason3410",
                        "content": "Split n into sum of power of 2.\\nThen binary search may help."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "will get stackoverflow for n=2147483647 ..., lol"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Before solving this problem, you'd better understand exponentiation by squaring.\nhttps://en.wikipedia.org/wiki/Exponentiation_by_squaring"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is that a foul to use long long?"
                    },
                    {
                        "username": "isaiahgr",
                        "content": "return pow(x,n);"
                    },
                    {
                        "username": "Tanisha_gupta20",
                        "content": "Line 21: Char 46: runtime error: negation of -2147483648 cannot be represented in type 'int'; cast to an unsigned type to negate this value to itself (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:30:46\n\ncode-\n//const unsigned int mod=1e9+7;\n    double myPow(double x, int n)\n    {\n     \n\n        if(n==0)\n            return 1;\n        else if(x==0)\n            return 0;\n        else \n            if(n>0)\n                return powerhelper(x,n);\n             else\n                return ( 1.0/  powerhelper(x,-n) );          //again runtime error \n    }\n\n    double powerhelper(double x, int n)\n    {\n        if(n==0)\n            return 1;\n        else\n        if( n%2 == 0)\n        {\n            double temp = powerhelper(x,n/2);\n            return temp*temp;\n        }    \n        else\n        {\n            double temp = powerhelper(x,(n-1)/2);\n            return x*temp*temp;\n        }\n    }\n\n\nplease help me with the solution to my error, I have tried so many times to solve this. Please somebody help how to solve this error "
                    },
                    {
                        "username": "tifv",
                        "content": "`-n` is not an always valid operation on `int`: it can overflow with the given constraints. Convert `n` to some other type first (I suppose in C++ it should be `long long`)."
                    },
                    {
                        "username": "Sacristaria",
                        "content": "Easily solvable by passing unsigned int to powerHelper and casting -n."
                    },
                    {
                        "username": "Seviferr",
                        "content": "Is this an issue with the test cases?\\n\\nIn javascript Math.pow(-1, -214748364) = -1\\nBut test case number 305 the same input expects the output to be 1\\n\\nAm I missing something? Thanks!"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "(-1)^even = 1  \nJavascript Math.pow(-1,214748364) does output 1, but the whole point of this problem is to write Math.pow()."
                    }
                ]
            },
            {
                "id": 1983888,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "the solution lies in the question title ..."
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Does somebody know why with this solution for the `x = 2; n = -2147483648` case I've got `Time Limit Exceeded`:\n```\nfunction myPow(x: number, n: number): number {\n    if (!n)  return 1;\n\n    let result = x;\n\n    for (let i = 2; i <= Math.abs(n); i++) {\n        result *= x;\n    }\n\n    return n > 0 ? result : 1 / result;\n};\n```\n\nBut if I add extra checks for `x = 1` and `x = -1` - everything is good for the same case where `x = 2; n = -2147483648`.\n```\nfunction myPow(x: number, n: number): number {\n   //region extra checks for `x = 1` and `x = -1`, to make case with `x = 2` works..\n    if (x === 1) {\n        return 1;\n    }\n\n    if (x === -1) { \n        return n % 2 === 0 ? -x : x;\n    }\n   //endregion\n\n    if (!n) {\n        return 1;\n    }\n    \n    let result = x;\n\n    for (let i = 2; i <= Math.abs(n); i++) {\n        result *= x;\n    }\n\n    return n > 0 ? result : 1 / result;\n};\n```"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "[@psionl0](/psionl0) 0.1^-2147483648 != 0."
                    },
                    {
                        "username": "psionl0",
                        "content": "2147483648 multiplications will take a long time. You need to converge on the answer more rapidly. You can take advantage of the fact that if n is an even number then x^n = (x * x)^(n / 2).\n\n(Note also that when n = -2147483648 you can just return 0)."
                    },
                    {
                        "username": "vetor",
                        "content": "one way is to directly use math module which i wont suggest for medium easy question "
                    },
                    {
                        "username": "jason3410",
                        "content": "Split n into sum of power of 2.\\nThen binary search may help."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "will get stackoverflow for n=2147483647 ..., lol"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Before solving this problem, you'd better understand exponentiation by squaring.\nhttps://en.wikipedia.org/wiki/Exponentiation_by_squaring"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is that a foul to use long long?"
                    },
                    {
                        "username": "isaiahgr",
                        "content": "return pow(x,n);"
                    },
                    {
                        "username": "Tanisha_gupta20",
                        "content": "Line 21: Char 46: runtime error: negation of -2147483648 cannot be represented in type 'int'; cast to an unsigned type to negate this value to itself (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:30:46\n\ncode-\n//const unsigned int mod=1e9+7;\n    double myPow(double x, int n)\n    {\n     \n\n        if(n==0)\n            return 1;\n        else if(x==0)\n            return 0;\n        else \n            if(n>0)\n                return powerhelper(x,n);\n             else\n                return ( 1.0/  powerhelper(x,-n) );          //again runtime error \n    }\n\n    double powerhelper(double x, int n)\n    {\n        if(n==0)\n            return 1;\n        else\n        if( n%2 == 0)\n        {\n            double temp = powerhelper(x,n/2);\n            return temp*temp;\n        }    \n        else\n        {\n            double temp = powerhelper(x,(n-1)/2);\n            return x*temp*temp;\n        }\n    }\n\n\nplease help me with the solution to my error, I have tried so many times to solve this. Please somebody help how to solve this error "
                    },
                    {
                        "username": "tifv",
                        "content": "`-n` is not an always valid operation on `int`: it can overflow with the given constraints. Convert `n` to some other type first (I suppose in C++ it should be `long long`)."
                    },
                    {
                        "username": "Sacristaria",
                        "content": "Easily solvable by passing unsigned int to powerHelper and casting -n."
                    },
                    {
                        "username": "Seviferr",
                        "content": "Is this an issue with the test cases?\\n\\nIn javascript Math.pow(-1, -214748364) = -1\\nBut test case number 305 the same input expects the output to be 1\\n\\nAm I missing something? Thanks!"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "(-1)^even = 1  \nJavascript Math.pow(-1,214748364) does output 1, but the whole point of this problem is to write Math.pow()."
                    }
                ]
            },
            {
                "id": 1983758,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "the solution lies in the question title ..."
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Does somebody know why with this solution for the `x = 2; n = -2147483648` case I've got `Time Limit Exceeded`:\n```\nfunction myPow(x: number, n: number): number {\n    if (!n)  return 1;\n\n    let result = x;\n\n    for (let i = 2; i <= Math.abs(n); i++) {\n        result *= x;\n    }\n\n    return n > 0 ? result : 1 / result;\n};\n```\n\nBut if I add extra checks for `x = 1` and `x = -1` - everything is good for the same case where `x = 2; n = -2147483648`.\n```\nfunction myPow(x: number, n: number): number {\n   //region extra checks for `x = 1` and `x = -1`, to make case with `x = 2` works..\n    if (x === 1) {\n        return 1;\n    }\n\n    if (x === -1) { \n        return n % 2 === 0 ? -x : x;\n    }\n   //endregion\n\n    if (!n) {\n        return 1;\n    }\n    \n    let result = x;\n\n    for (let i = 2; i <= Math.abs(n); i++) {\n        result *= x;\n    }\n\n    return n > 0 ? result : 1 / result;\n};\n```"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "[@psionl0](/psionl0) 0.1^-2147483648 != 0."
                    },
                    {
                        "username": "psionl0",
                        "content": "2147483648 multiplications will take a long time. You need to converge on the answer more rapidly. You can take advantage of the fact that if n is an even number then x^n = (x * x)^(n / 2).\n\n(Note also that when n = -2147483648 you can just return 0)."
                    },
                    {
                        "username": "vetor",
                        "content": "one way is to directly use math module which i wont suggest for medium easy question "
                    },
                    {
                        "username": "jason3410",
                        "content": "Split n into sum of power of 2.\\nThen binary search may help."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "will get stackoverflow for n=2147483647 ..., lol"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Before solving this problem, you'd better understand exponentiation by squaring.\nhttps://en.wikipedia.org/wiki/Exponentiation_by_squaring"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is that a foul to use long long?"
                    },
                    {
                        "username": "isaiahgr",
                        "content": "return pow(x,n);"
                    },
                    {
                        "username": "Tanisha_gupta20",
                        "content": "Line 21: Char 46: runtime error: negation of -2147483648 cannot be represented in type 'int'; cast to an unsigned type to negate this value to itself (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:30:46\n\ncode-\n//const unsigned int mod=1e9+7;\n    double myPow(double x, int n)\n    {\n     \n\n        if(n==0)\n            return 1;\n        else if(x==0)\n            return 0;\n        else \n            if(n>0)\n                return powerhelper(x,n);\n             else\n                return ( 1.0/  powerhelper(x,-n) );          //again runtime error \n    }\n\n    double powerhelper(double x, int n)\n    {\n        if(n==0)\n            return 1;\n        else\n        if( n%2 == 0)\n        {\n            double temp = powerhelper(x,n/2);\n            return temp*temp;\n        }    \n        else\n        {\n            double temp = powerhelper(x,(n-1)/2);\n            return x*temp*temp;\n        }\n    }\n\n\nplease help me with the solution to my error, I have tried so many times to solve this. Please somebody help how to solve this error "
                    },
                    {
                        "username": "tifv",
                        "content": "`-n` is not an always valid operation on `int`: it can overflow with the given constraints. Convert `n` to some other type first (I suppose in C++ it should be `long long`)."
                    },
                    {
                        "username": "Sacristaria",
                        "content": "Easily solvable by passing unsigned int to powerHelper and casting -n."
                    },
                    {
                        "username": "Seviferr",
                        "content": "Is this an issue with the test cases?\\n\\nIn javascript Math.pow(-1, -214748364) = -1\\nBut test case number 305 the same input expects the output to be 1\\n\\nAm I missing something? Thanks!"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "(-1)^even = 1  \nJavascript Math.pow(-1,214748364) does output 1, but the whole point of this problem is to write Math.pow()."
                    }
                ]
            },
            {
                "id": 1983740,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "the solution lies in the question title ..."
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Does somebody know why with this solution for the `x = 2; n = -2147483648` case I've got `Time Limit Exceeded`:\n```\nfunction myPow(x: number, n: number): number {\n    if (!n)  return 1;\n\n    let result = x;\n\n    for (let i = 2; i <= Math.abs(n); i++) {\n        result *= x;\n    }\n\n    return n > 0 ? result : 1 / result;\n};\n```\n\nBut if I add extra checks for `x = 1` and `x = -1` - everything is good for the same case where `x = 2; n = -2147483648`.\n```\nfunction myPow(x: number, n: number): number {\n   //region extra checks for `x = 1` and `x = -1`, to make case with `x = 2` works..\n    if (x === 1) {\n        return 1;\n    }\n\n    if (x === -1) { \n        return n % 2 === 0 ? -x : x;\n    }\n   //endregion\n\n    if (!n) {\n        return 1;\n    }\n    \n    let result = x;\n\n    for (let i = 2; i <= Math.abs(n); i++) {\n        result *= x;\n    }\n\n    return n > 0 ? result : 1 / result;\n};\n```"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "[@psionl0](/psionl0) 0.1^-2147483648 != 0."
                    },
                    {
                        "username": "psionl0",
                        "content": "2147483648 multiplications will take a long time. You need to converge on the answer more rapidly. You can take advantage of the fact that if n is an even number then x^n = (x * x)^(n / 2).\n\n(Note also that when n = -2147483648 you can just return 0)."
                    },
                    {
                        "username": "vetor",
                        "content": "one way is to directly use math module which i wont suggest for medium easy question "
                    },
                    {
                        "username": "jason3410",
                        "content": "Split n into sum of power of 2.\\nThen binary search may help."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "will get stackoverflow for n=2147483647 ..., lol"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Before solving this problem, you'd better understand exponentiation by squaring.\nhttps://en.wikipedia.org/wiki/Exponentiation_by_squaring"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is that a foul to use long long?"
                    },
                    {
                        "username": "isaiahgr",
                        "content": "return pow(x,n);"
                    },
                    {
                        "username": "Tanisha_gupta20",
                        "content": "Line 21: Char 46: runtime error: negation of -2147483648 cannot be represented in type 'int'; cast to an unsigned type to negate this value to itself (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:30:46\n\ncode-\n//const unsigned int mod=1e9+7;\n    double myPow(double x, int n)\n    {\n     \n\n        if(n==0)\n            return 1;\n        else if(x==0)\n            return 0;\n        else \n            if(n>0)\n                return powerhelper(x,n);\n             else\n                return ( 1.0/  powerhelper(x,-n) );          //again runtime error \n    }\n\n    double powerhelper(double x, int n)\n    {\n        if(n==0)\n            return 1;\n        else\n        if( n%2 == 0)\n        {\n            double temp = powerhelper(x,n/2);\n            return temp*temp;\n        }    \n        else\n        {\n            double temp = powerhelper(x,(n-1)/2);\n            return x*temp*temp;\n        }\n    }\n\n\nplease help me with the solution to my error, I have tried so many times to solve this. Please somebody help how to solve this error "
                    },
                    {
                        "username": "tifv",
                        "content": "`-n` is not an always valid operation on `int`: it can overflow with the given constraints. Convert `n` to some other type first (I suppose in C++ it should be `long long`)."
                    },
                    {
                        "username": "Sacristaria",
                        "content": "Easily solvable by passing unsigned int to powerHelper and casting -n."
                    },
                    {
                        "username": "Seviferr",
                        "content": "Is this an issue with the test cases?\\n\\nIn javascript Math.pow(-1, -214748364) = -1\\nBut test case number 305 the same input expects the output to be 1\\n\\nAm I missing something? Thanks!"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "(-1)^even = 1  \nJavascript Math.pow(-1,214748364) does output 1, but the whole point of this problem is to write Math.pow()."
                    }
                ]
            },
            {
                "id": 1983669,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "the solution lies in the question title ..."
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Does somebody know why with this solution for the `x = 2; n = -2147483648` case I've got `Time Limit Exceeded`:\n```\nfunction myPow(x: number, n: number): number {\n    if (!n)  return 1;\n\n    let result = x;\n\n    for (let i = 2; i <= Math.abs(n); i++) {\n        result *= x;\n    }\n\n    return n > 0 ? result : 1 / result;\n};\n```\n\nBut if I add extra checks for `x = 1` and `x = -1` - everything is good for the same case where `x = 2; n = -2147483648`.\n```\nfunction myPow(x: number, n: number): number {\n   //region extra checks for `x = 1` and `x = -1`, to make case with `x = 2` works..\n    if (x === 1) {\n        return 1;\n    }\n\n    if (x === -1) { \n        return n % 2 === 0 ? -x : x;\n    }\n   //endregion\n\n    if (!n) {\n        return 1;\n    }\n    \n    let result = x;\n\n    for (let i = 2; i <= Math.abs(n); i++) {\n        result *= x;\n    }\n\n    return n > 0 ? result : 1 / result;\n};\n```"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "[@psionl0](/psionl0) 0.1^-2147483648 != 0."
                    },
                    {
                        "username": "psionl0",
                        "content": "2147483648 multiplications will take a long time. You need to converge on the answer more rapidly. You can take advantage of the fact that if n is an even number then x^n = (x * x)^(n / 2).\n\n(Note also that when n = -2147483648 you can just return 0)."
                    },
                    {
                        "username": "vetor",
                        "content": "one way is to directly use math module which i wont suggest for medium easy question "
                    },
                    {
                        "username": "jason3410",
                        "content": "Split n into sum of power of 2.\\nThen binary search may help."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "will get stackoverflow for n=2147483647 ..., lol"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Before solving this problem, you'd better understand exponentiation by squaring.\nhttps://en.wikipedia.org/wiki/Exponentiation_by_squaring"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is that a foul to use long long?"
                    },
                    {
                        "username": "isaiahgr",
                        "content": "return pow(x,n);"
                    },
                    {
                        "username": "Tanisha_gupta20",
                        "content": "Line 21: Char 46: runtime error: negation of -2147483648 cannot be represented in type 'int'; cast to an unsigned type to negate this value to itself (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:30:46\n\ncode-\n//const unsigned int mod=1e9+7;\n    double myPow(double x, int n)\n    {\n     \n\n        if(n==0)\n            return 1;\n        else if(x==0)\n            return 0;\n        else \n            if(n>0)\n                return powerhelper(x,n);\n             else\n                return ( 1.0/  powerhelper(x,-n) );          //again runtime error \n    }\n\n    double powerhelper(double x, int n)\n    {\n        if(n==0)\n            return 1;\n        else\n        if( n%2 == 0)\n        {\n            double temp = powerhelper(x,n/2);\n            return temp*temp;\n        }    \n        else\n        {\n            double temp = powerhelper(x,(n-1)/2);\n            return x*temp*temp;\n        }\n    }\n\n\nplease help me with the solution to my error, I have tried so many times to solve this. Please somebody help how to solve this error "
                    },
                    {
                        "username": "tifv",
                        "content": "`-n` is not an always valid operation on `int`: it can overflow with the given constraints. Convert `n` to some other type first (I suppose in C++ it should be `long long`)."
                    },
                    {
                        "username": "Sacristaria",
                        "content": "Easily solvable by passing unsigned int to powerHelper and casting -n."
                    },
                    {
                        "username": "Seviferr",
                        "content": "Is this an issue with the test cases?\\n\\nIn javascript Math.pow(-1, -214748364) = -1\\nBut test case number 305 the same input expects the output to be 1\\n\\nAm I missing something? Thanks!"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "(-1)^even = 1  \nJavascript Math.pow(-1,214748364) does output 1, but the whole point of this problem is to write Math.pow()."
                    }
                ]
            },
            {
                "id": 1983667,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "the solution lies in the question title ..."
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Does somebody know why with this solution for the `x = 2; n = -2147483648` case I've got `Time Limit Exceeded`:\n```\nfunction myPow(x: number, n: number): number {\n    if (!n)  return 1;\n\n    let result = x;\n\n    for (let i = 2; i <= Math.abs(n); i++) {\n        result *= x;\n    }\n\n    return n > 0 ? result : 1 / result;\n};\n```\n\nBut if I add extra checks for `x = 1` and `x = -1` - everything is good for the same case where `x = 2; n = -2147483648`.\n```\nfunction myPow(x: number, n: number): number {\n   //region extra checks for `x = 1` and `x = -1`, to make case with `x = 2` works..\n    if (x === 1) {\n        return 1;\n    }\n\n    if (x === -1) { \n        return n % 2 === 0 ? -x : x;\n    }\n   //endregion\n\n    if (!n) {\n        return 1;\n    }\n    \n    let result = x;\n\n    for (let i = 2; i <= Math.abs(n); i++) {\n        result *= x;\n    }\n\n    return n > 0 ? result : 1 / result;\n};\n```"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "[@psionl0](/psionl0) 0.1^-2147483648 != 0."
                    },
                    {
                        "username": "psionl0",
                        "content": "2147483648 multiplications will take a long time. You need to converge on the answer more rapidly. You can take advantage of the fact that if n is an even number then x^n = (x * x)^(n / 2).\n\n(Note also that when n = -2147483648 you can just return 0)."
                    },
                    {
                        "username": "vetor",
                        "content": "one way is to directly use math module which i wont suggest for medium easy question "
                    },
                    {
                        "username": "jason3410",
                        "content": "Split n into sum of power of 2.\\nThen binary search may help."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "will get stackoverflow for n=2147483647 ..., lol"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Before solving this problem, you'd better understand exponentiation by squaring.\nhttps://en.wikipedia.org/wiki/Exponentiation_by_squaring"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is that a foul to use long long?"
                    },
                    {
                        "username": "isaiahgr",
                        "content": "return pow(x,n);"
                    },
                    {
                        "username": "Tanisha_gupta20",
                        "content": "Line 21: Char 46: runtime error: negation of -2147483648 cannot be represented in type 'int'; cast to an unsigned type to negate this value to itself (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:30:46\n\ncode-\n//const unsigned int mod=1e9+7;\n    double myPow(double x, int n)\n    {\n     \n\n        if(n==0)\n            return 1;\n        else if(x==0)\n            return 0;\n        else \n            if(n>0)\n                return powerhelper(x,n);\n             else\n                return ( 1.0/  powerhelper(x,-n) );          //again runtime error \n    }\n\n    double powerhelper(double x, int n)\n    {\n        if(n==0)\n            return 1;\n        else\n        if( n%2 == 0)\n        {\n            double temp = powerhelper(x,n/2);\n            return temp*temp;\n        }    \n        else\n        {\n            double temp = powerhelper(x,(n-1)/2);\n            return x*temp*temp;\n        }\n    }\n\n\nplease help me with the solution to my error, I have tried so many times to solve this. Please somebody help how to solve this error "
                    },
                    {
                        "username": "tifv",
                        "content": "`-n` is not an always valid operation on `int`: it can overflow with the given constraints. Convert `n` to some other type first (I suppose in C++ it should be `long long`)."
                    },
                    {
                        "username": "Sacristaria",
                        "content": "Easily solvable by passing unsigned int to powerHelper and casting -n."
                    },
                    {
                        "username": "Seviferr",
                        "content": "Is this an issue with the test cases?\\n\\nIn javascript Math.pow(-1, -214748364) = -1\\nBut test case number 305 the same input expects the output to be 1\\n\\nAm I missing something? Thanks!"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "(-1)^even = 1  \nJavascript Math.pow(-1,214748364) does output 1, but the whole point of this problem is to write Math.pow()."
                    }
                ]
            },
            {
                "id": 1983620,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "the solution lies in the question title ..."
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Does somebody know why with this solution for the `x = 2; n = -2147483648` case I've got `Time Limit Exceeded`:\n```\nfunction myPow(x: number, n: number): number {\n    if (!n)  return 1;\n\n    let result = x;\n\n    for (let i = 2; i <= Math.abs(n); i++) {\n        result *= x;\n    }\n\n    return n > 0 ? result : 1 / result;\n};\n```\n\nBut if I add extra checks for `x = 1` and `x = -1` - everything is good for the same case where `x = 2; n = -2147483648`.\n```\nfunction myPow(x: number, n: number): number {\n   //region extra checks for `x = 1` and `x = -1`, to make case with `x = 2` works..\n    if (x === 1) {\n        return 1;\n    }\n\n    if (x === -1) { \n        return n % 2 === 0 ? -x : x;\n    }\n   //endregion\n\n    if (!n) {\n        return 1;\n    }\n    \n    let result = x;\n\n    for (let i = 2; i <= Math.abs(n); i++) {\n        result *= x;\n    }\n\n    return n > 0 ? result : 1 / result;\n};\n```"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "[@psionl0](/psionl0) 0.1^-2147483648 != 0."
                    },
                    {
                        "username": "psionl0",
                        "content": "2147483648 multiplications will take a long time. You need to converge on the answer more rapidly. You can take advantage of the fact that if n is an even number then x^n = (x * x)^(n / 2).\n\n(Note also that when n = -2147483648 you can just return 0)."
                    },
                    {
                        "username": "vetor",
                        "content": "one way is to directly use math module which i wont suggest for medium easy question "
                    },
                    {
                        "username": "jason3410",
                        "content": "Split n into sum of power of 2.\\nThen binary search may help."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "will get stackoverflow for n=2147483647 ..., lol"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Before solving this problem, you'd better understand exponentiation by squaring.\nhttps://en.wikipedia.org/wiki/Exponentiation_by_squaring"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is that a foul to use long long?"
                    },
                    {
                        "username": "isaiahgr",
                        "content": "return pow(x,n);"
                    },
                    {
                        "username": "Tanisha_gupta20",
                        "content": "Line 21: Char 46: runtime error: negation of -2147483648 cannot be represented in type 'int'; cast to an unsigned type to negate this value to itself (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:30:46\n\ncode-\n//const unsigned int mod=1e9+7;\n    double myPow(double x, int n)\n    {\n     \n\n        if(n==0)\n            return 1;\n        else if(x==0)\n            return 0;\n        else \n            if(n>0)\n                return powerhelper(x,n);\n             else\n                return ( 1.0/  powerhelper(x,-n) );          //again runtime error \n    }\n\n    double powerhelper(double x, int n)\n    {\n        if(n==0)\n            return 1;\n        else\n        if( n%2 == 0)\n        {\n            double temp = powerhelper(x,n/2);\n            return temp*temp;\n        }    \n        else\n        {\n            double temp = powerhelper(x,(n-1)/2);\n            return x*temp*temp;\n        }\n    }\n\n\nplease help me with the solution to my error, I have tried so many times to solve this. Please somebody help how to solve this error "
                    },
                    {
                        "username": "tifv",
                        "content": "`-n` is not an always valid operation on `int`: it can overflow with the given constraints. Convert `n` to some other type first (I suppose in C++ it should be `long long`)."
                    },
                    {
                        "username": "Sacristaria",
                        "content": "Easily solvable by passing unsigned int to powerHelper and casting -n."
                    },
                    {
                        "username": "Seviferr",
                        "content": "Is this an issue with the test cases?\\n\\nIn javascript Math.pow(-1, -214748364) = -1\\nBut test case number 305 the same input expects the output to be 1\\n\\nAm I missing something? Thanks!"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "(-1)^even = 1  \nJavascript Math.pow(-1,214748364) does output 1, but the whole point of this problem is to write Math.pow()."
                    }
                ]
            },
            {
                "id": 1983539,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "the solution lies in the question title ..."
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Does somebody know why with this solution for the `x = 2; n = -2147483648` case I've got `Time Limit Exceeded`:\n```\nfunction myPow(x: number, n: number): number {\n    if (!n)  return 1;\n\n    let result = x;\n\n    for (let i = 2; i <= Math.abs(n); i++) {\n        result *= x;\n    }\n\n    return n > 0 ? result : 1 / result;\n};\n```\n\nBut if I add extra checks for `x = 1` and `x = -1` - everything is good for the same case where `x = 2; n = -2147483648`.\n```\nfunction myPow(x: number, n: number): number {\n   //region extra checks for `x = 1` and `x = -1`, to make case with `x = 2` works..\n    if (x === 1) {\n        return 1;\n    }\n\n    if (x === -1) { \n        return n % 2 === 0 ? -x : x;\n    }\n   //endregion\n\n    if (!n) {\n        return 1;\n    }\n    \n    let result = x;\n\n    for (let i = 2; i <= Math.abs(n); i++) {\n        result *= x;\n    }\n\n    return n > 0 ? result : 1 / result;\n};\n```"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "[@psionl0](/psionl0) 0.1^-2147483648 != 0."
                    },
                    {
                        "username": "psionl0",
                        "content": "2147483648 multiplications will take a long time. You need to converge on the answer more rapidly. You can take advantage of the fact that if n is an even number then x^n = (x * x)^(n / 2).\n\n(Note also that when n = -2147483648 you can just return 0)."
                    },
                    {
                        "username": "vetor",
                        "content": "one way is to directly use math module which i wont suggest for medium easy question "
                    },
                    {
                        "username": "jason3410",
                        "content": "Split n into sum of power of 2.\\nThen binary search may help."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "will get stackoverflow for n=2147483647 ..., lol"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Before solving this problem, you'd better understand exponentiation by squaring.\nhttps://en.wikipedia.org/wiki/Exponentiation_by_squaring"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is that a foul to use long long?"
                    },
                    {
                        "username": "isaiahgr",
                        "content": "return pow(x,n);"
                    },
                    {
                        "username": "Tanisha_gupta20",
                        "content": "Line 21: Char 46: runtime error: negation of -2147483648 cannot be represented in type 'int'; cast to an unsigned type to negate this value to itself (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:30:46\n\ncode-\n//const unsigned int mod=1e9+7;\n    double myPow(double x, int n)\n    {\n     \n\n        if(n==0)\n            return 1;\n        else if(x==0)\n            return 0;\n        else \n            if(n>0)\n                return powerhelper(x,n);\n             else\n                return ( 1.0/  powerhelper(x,-n) );          //again runtime error \n    }\n\n    double powerhelper(double x, int n)\n    {\n        if(n==0)\n            return 1;\n        else\n        if( n%2 == 0)\n        {\n            double temp = powerhelper(x,n/2);\n            return temp*temp;\n        }    \n        else\n        {\n            double temp = powerhelper(x,(n-1)/2);\n            return x*temp*temp;\n        }\n    }\n\n\nplease help me with the solution to my error, I have tried so many times to solve this. Please somebody help how to solve this error "
                    },
                    {
                        "username": "tifv",
                        "content": "`-n` is not an always valid operation on `int`: it can overflow with the given constraints. Convert `n` to some other type first (I suppose in C++ it should be `long long`)."
                    },
                    {
                        "username": "Sacristaria",
                        "content": "Easily solvable by passing unsigned int to powerHelper and casting -n."
                    },
                    {
                        "username": "Seviferr",
                        "content": "Is this an issue with the test cases?\\n\\nIn javascript Math.pow(-1, -214748364) = -1\\nBut test case number 305 the same input expects the output to be 1\\n\\nAm I missing something? Thanks!"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "(-1)^even = 1  \nJavascript Math.pow(-1,214748364) does output 1, but the whole point of this problem is to write Math.pow()."
                    }
                ]
            },
            {
                "id": 1983287,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "the solution lies in the question title ..."
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Does somebody know why with this solution for the `x = 2; n = -2147483648` case I've got `Time Limit Exceeded`:\n```\nfunction myPow(x: number, n: number): number {\n    if (!n)  return 1;\n\n    let result = x;\n\n    for (let i = 2; i <= Math.abs(n); i++) {\n        result *= x;\n    }\n\n    return n > 0 ? result : 1 / result;\n};\n```\n\nBut if I add extra checks for `x = 1` and `x = -1` - everything is good for the same case where `x = 2; n = -2147483648`.\n```\nfunction myPow(x: number, n: number): number {\n   //region extra checks for `x = 1` and `x = -1`, to make case with `x = 2` works..\n    if (x === 1) {\n        return 1;\n    }\n\n    if (x === -1) { \n        return n % 2 === 0 ? -x : x;\n    }\n   //endregion\n\n    if (!n) {\n        return 1;\n    }\n    \n    let result = x;\n\n    for (let i = 2; i <= Math.abs(n); i++) {\n        result *= x;\n    }\n\n    return n > 0 ? result : 1 / result;\n};\n```"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "[@psionl0](/psionl0) 0.1^-2147483648 != 0."
                    },
                    {
                        "username": "psionl0",
                        "content": "2147483648 multiplications will take a long time. You need to converge on the answer more rapidly. You can take advantage of the fact that if n is an even number then x^n = (x * x)^(n / 2).\n\n(Note also that when n = -2147483648 you can just return 0)."
                    },
                    {
                        "username": "vetor",
                        "content": "one way is to directly use math module which i wont suggest for medium easy question "
                    },
                    {
                        "username": "jason3410",
                        "content": "Split n into sum of power of 2.\\nThen binary search may help."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "will get stackoverflow for n=2147483647 ..., lol"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Before solving this problem, you'd better understand exponentiation by squaring.\nhttps://en.wikipedia.org/wiki/Exponentiation_by_squaring"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is that a foul to use long long?"
                    },
                    {
                        "username": "isaiahgr",
                        "content": "return pow(x,n);"
                    },
                    {
                        "username": "Tanisha_gupta20",
                        "content": "Line 21: Char 46: runtime error: negation of -2147483648 cannot be represented in type 'int'; cast to an unsigned type to negate this value to itself (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:30:46\n\ncode-\n//const unsigned int mod=1e9+7;\n    double myPow(double x, int n)\n    {\n     \n\n        if(n==0)\n            return 1;\n        else if(x==0)\n            return 0;\n        else \n            if(n>0)\n                return powerhelper(x,n);\n             else\n                return ( 1.0/  powerhelper(x,-n) );          //again runtime error \n    }\n\n    double powerhelper(double x, int n)\n    {\n        if(n==0)\n            return 1;\n        else\n        if( n%2 == 0)\n        {\n            double temp = powerhelper(x,n/2);\n            return temp*temp;\n        }    \n        else\n        {\n            double temp = powerhelper(x,(n-1)/2);\n            return x*temp*temp;\n        }\n    }\n\n\nplease help me with the solution to my error, I have tried so many times to solve this. Please somebody help how to solve this error "
                    },
                    {
                        "username": "tifv",
                        "content": "`-n` is not an always valid operation on `int`: it can overflow with the given constraints. Convert `n` to some other type first (I suppose in C++ it should be `long long`)."
                    },
                    {
                        "username": "Sacristaria",
                        "content": "Easily solvable by passing unsigned int to powerHelper and casting -n."
                    },
                    {
                        "username": "Seviferr",
                        "content": "Is this an issue with the test cases?\\n\\nIn javascript Math.pow(-1, -214748364) = -1\\nBut test case number 305 the same input expects the output to be 1\\n\\nAm I missing something? Thanks!"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "(-1)^even = 1  \nJavascript Math.pow(-1,214748364) does output 1, but the whole point of this problem is to write Math.pow()."
                    }
                ]
            },
            {
                "id": 1979747,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "the solution lies in the question title ..."
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Does somebody know why with this solution for the `x = 2; n = -2147483648` case I've got `Time Limit Exceeded`:\n```\nfunction myPow(x: number, n: number): number {\n    if (!n)  return 1;\n\n    let result = x;\n\n    for (let i = 2; i <= Math.abs(n); i++) {\n        result *= x;\n    }\n\n    return n > 0 ? result : 1 / result;\n};\n```\n\nBut if I add extra checks for `x = 1` and `x = -1` - everything is good for the same case where `x = 2; n = -2147483648`.\n```\nfunction myPow(x: number, n: number): number {\n   //region extra checks for `x = 1` and `x = -1`, to make case with `x = 2` works..\n    if (x === 1) {\n        return 1;\n    }\n\n    if (x === -1) { \n        return n % 2 === 0 ? -x : x;\n    }\n   //endregion\n\n    if (!n) {\n        return 1;\n    }\n    \n    let result = x;\n\n    for (let i = 2; i <= Math.abs(n); i++) {\n        result *= x;\n    }\n\n    return n > 0 ? result : 1 / result;\n};\n```"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "[@psionl0](/psionl0) 0.1^-2147483648 != 0."
                    },
                    {
                        "username": "psionl0",
                        "content": "2147483648 multiplications will take a long time. You need to converge on the answer more rapidly. You can take advantage of the fact that if n is an even number then x^n = (x * x)^(n / 2).\n\n(Note also that when n = -2147483648 you can just return 0)."
                    },
                    {
                        "username": "vetor",
                        "content": "one way is to directly use math module which i wont suggest for medium easy question "
                    },
                    {
                        "username": "jason3410",
                        "content": "Split n into sum of power of 2.\\nThen binary search may help."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "will get stackoverflow for n=2147483647 ..., lol"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Before solving this problem, you'd better understand exponentiation by squaring.\nhttps://en.wikipedia.org/wiki/Exponentiation_by_squaring"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is that a foul to use long long?"
                    },
                    {
                        "username": "isaiahgr",
                        "content": "return pow(x,n);"
                    },
                    {
                        "username": "Tanisha_gupta20",
                        "content": "Line 21: Char 46: runtime error: negation of -2147483648 cannot be represented in type 'int'; cast to an unsigned type to negate this value to itself (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:30:46\n\ncode-\n//const unsigned int mod=1e9+7;\n    double myPow(double x, int n)\n    {\n     \n\n        if(n==0)\n            return 1;\n        else if(x==0)\n            return 0;\n        else \n            if(n>0)\n                return powerhelper(x,n);\n             else\n                return ( 1.0/  powerhelper(x,-n) );          //again runtime error \n    }\n\n    double powerhelper(double x, int n)\n    {\n        if(n==0)\n            return 1;\n        else\n        if( n%2 == 0)\n        {\n            double temp = powerhelper(x,n/2);\n            return temp*temp;\n        }    \n        else\n        {\n            double temp = powerhelper(x,(n-1)/2);\n            return x*temp*temp;\n        }\n    }\n\n\nplease help me with the solution to my error, I have tried so many times to solve this. Please somebody help how to solve this error "
                    },
                    {
                        "username": "tifv",
                        "content": "`-n` is not an always valid operation on `int`: it can overflow with the given constraints. Convert `n` to some other type first (I suppose in C++ it should be `long long`)."
                    },
                    {
                        "username": "Sacristaria",
                        "content": "Easily solvable by passing unsigned int to powerHelper and casting -n."
                    },
                    {
                        "username": "Seviferr",
                        "content": "Is this an issue with the test cases?\\n\\nIn javascript Math.pow(-1, -214748364) = -1\\nBut test case number 305 the same input expects the output to be 1\\n\\nAm I missing something? Thanks!"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "(-1)^even = 1  \nJavascript Math.pow(-1,214748364) does output 1, but the whole point of this problem is to write Math.pow()."
                    }
                ]
            },
            {
                "id": 1977224,
                "content": [
                    {
                        "username": "Nisarg_1709",
                        "content": "This question trick to find when try to find the power of negative  number"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "really? is this medium? \n\nLeetcode keeps making me amazed. Some `easy` problems are hard as hell, some `medium` or `hard` problems are below `easy` and you solve them in some seconds. \n\nATTENTION SPOILER: \nI wrote x ** n and was sure the error will pop up, but it passed..."
                    },
                    {
                        "username": "milanthakor",
                        "content": "What would be the time complexity of the below algorithm? \\n\\nBelow approach is more intuitive to compare to the one in the Editorial. However, I am not able to figure out the time complexity of the algorithm. The time complexity is not exactly O(logn), but is not O(n) either, it somewhere lies in-between. \\n\\nCould anyone please help me to understand it? If possible, take x = 2 and n = 50 as an example. As per my understanding\\n1. When `i = 1` and `y = 50`, the value of `i` will be 1, 2, 4, 8, 16, 32. Then both will be reset to `i = 1` and `y = 50 - 32 = 18`.\\n2. When `i = 1` and `y = 18`, the value of `i` will be 1, 2, 4, 5, 16. Then again both will be reset to `i = 1` and `y = 18 - 16 = 2`.\\n3. When `i = 1` and `y = 2`, the value of `i` will be 1. Then again both will be reset to `i = 1` and `y = 2 - 1`. \\n4. When `i = 1` and `y = 1`, the value of `i` will be 1. Then again both will be reset to `i = 1` and `y = 1 - 1 = 0`. And the algorithm completes.\\n\\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        int y = abs(n);\\n\\n        // Base Condition.\\n        if (x == 0) return x;\\n        if (n == 0) return 1;\\n\\n        long long i = 1;\\n        double ans = 1, temp = x;\\n        while (y != 0) {\\n            if (i + i >= y) {\\n                y = y - i;\\n                i = 1;\\n                ans *= temp;\\n                temp = x;\\n            } else {\\n                temp *= temp;\\n                i <<= 1;\\n            }\\n        }\\n\\n        return n < 0 ? (1 / ans) : ans;\\n    }\\n};\\n``"
                    },
                    {
                        "username": "Boltfire",
                        "content": "Use math.pow() and make your life easier."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "lol I got it correct in one run"
                    },
                    {
                        "username": "psionl0",
                        "content": "Congratulations on anticipating the n = -2147483648 edge case."
                    },
                    {
                        "username": "user2387402",
                        "content": "bruh..."
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "memory error:291/306 test cases passed but this input:\\nx =\\n0.00001\\nn =\\n2147483647\\ncode:\\nans=1\\n        if n>0:\\n            \\n            for i in range(1,n+1):\\n                ans=ans*x\\n        else:\\n            for i in range(1,-n+1):\\n                ans=ans*(1/x)\\n\\n        return ans\\ncan anyone say why??\\n"
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "[@Sacristaria](/Sacristaria) thanks"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "Range essentially creates a list, which given the range uses up all the memory. Use xrange instead. Though it will likely timeout due to the large value."
                    },
                    {
                        "username": "Raedrin",
                        "content": "this problem is incredibly dumb. The fact that some of the test cases are greater than an int32 max value implies that the person calling the function cant read argument types."
                    },
                    {
                        "username": "19bec1397",
                        "content": "class Solution {\n    public double myPow(double x, int n) {\n\n        if(n==0){\n            return 1 ;\n        }\n        if(n==Integer.MIN_VALUE){\n             n = n +1 ; \n              return (1/x)*myPow(x,n);\n        }\n        if(n<0){\n            n = -n ; \n            x= 1/x;\n        }\n        if(n%2==0){\n            return myPow(x*x,n/2);\n        }else{\n            return x*myPow(x,n-1);\n        }\n        \n    }\n}\njava solution passes all test cases"
                    },
                    {
                        "username": "ameypathak39",
                        "content": "we have to return x**n"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "You have to implement x**n."
                    }
                ]
            },
            {
                "id": 1967043,
                "content": [
                    {
                        "username": "Nisarg_1709",
                        "content": "This question trick to find when try to find the power of negative  number"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "really? is this medium? \n\nLeetcode keeps making me amazed. Some `easy` problems are hard as hell, some `medium` or `hard` problems are below `easy` and you solve them in some seconds. \n\nATTENTION SPOILER: \nI wrote x ** n and was sure the error will pop up, but it passed..."
                    },
                    {
                        "username": "milanthakor",
                        "content": "What would be the time complexity of the below algorithm? \\n\\nBelow approach is more intuitive to compare to the one in the Editorial. However, I am not able to figure out the time complexity of the algorithm. The time complexity is not exactly O(logn), but is not O(n) either, it somewhere lies in-between. \\n\\nCould anyone please help me to understand it? If possible, take x = 2 and n = 50 as an example. As per my understanding\\n1. When `i = 1` and `y = 50`, the value of `i` will be 1, 2, 4, 8, 16, 32. Then both will be reset to `i = 1` and `y = 50 - 32 = 18`.\\n2. When `i = 1` and `y = 18`, the value of `i` will be 1, 2, 4, 5, 16. Then again both will be reset to `i = 1` and `y = 18 - 16 = 2`.\\n3. When `i = 1` and `y = 2`, the value of `i` will be 1. Then again both will be reset to `i = 1` and `y = 2 - 1`. \\n4. When `i = 1` and `y = 1`, the value of `i` will be 1. Then again both will be reset to `i = 1` and `y = 1 - 1 = 0`. And the algorithm completes.\\n\\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        int y = abs(n);\\n\\n        // Base Condition.\\n        if (x == 0) return x;\\n        if (n == 0) return 1;\\n\\n        long long i = 1;\\n        double ans = 1, temp = x;\\n        while (y != 0) {\\n            if (i + i >= y) {\\n                y = y - i;\\n                i = 1;\\n                ans *= temp;\\n                temp = x;\\n            } else {\\n                temp *= temp;\\n                i <<= 1;\\n            }\\n        }\\n\\n        return n < 0 ? (1 / ans) : ans;\\n    }\\n};\\n``"
                    },
                    {
                        "username": "Boltfire",
                        "content": "Use math.pow() and make your life easier."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "lol I got it correct in one run"
                    },
                    {
                        "username": "psionl0",
                        "content": "Congratulations on anticipating the n = -2147483648 edge case."
                    },
                    {
                        "username": "user2387402",
                        "content": "bruh..."
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "memory error:291/306 test cases passed but this input:\\nx =\\n0.00001\\nn =\\n2147483647\\ncode:\\nans=1\\n        if n>0:\\n            \\n            for i in range(1,n+1):\\n                ans=ans*x\\n        else:\\n            for i in range(1,-n+1):\\n                ans=ans*(1/x)\\n\\n        return ans\\ncan anyone say why??\\n"
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "[@Sacristaria](/Sacristaria) thanks"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "Range essentially creates a list, which given the range uses up all the memory. Use xrange instead. Though it will likely timeout due to the large value."
                    },
                    {
                        "username": "Raedrin",
                        "content": "this problem is incredibly dumb. The fact that some of the test cases are greater than an int32 max value implies that the person calling the function cant read argument types."
                    },
                    {
                        "username": "19bec1397",
                        "content": "class Solution {\n    public double myPow(double x, int n) {\n\n        if(n==0){\n            return 1 ;\n        }\n        if(n==Integer.MIN_VALUE){\n             n = n +1 ; \n              return (1/x)*myPow(x,n);\n        }\n        if(n<0){\n            n = -n ; \n            x= 1/x;\n        }\n        if(n%2==0){\n            return myPow(x*x,n/2);\n        }else{\n            return x*myPow(x,n-1);\n        }\n        \n    }\n}\njava solution passes all test cases"
                    },
                    {
                        "username": "ameypathak39",
                        "content": "we have to return x**n"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "You have to implement x**n."
                    }
                ]
            },
            {
                "id": 1966381,
                "content": [
                    {
                        "username": "Nisarg_1709",
                        "content": "This question trick to find when try to find the power of negative  number"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "really? is this medium? \n\nLeetcode keeps making me amazed. Some `easy` problems are hard as hell, some `medium` or `hard` problems are below `easy` and you solve them in some seconds. \n\nATTENTION SPOILER: \nI wrote x ** n and was sure the error will pop up, but it passed..."
                    },
                    {
                        "username": "milanthakor",
                        "content": "What would be the time complexity of the below algorithm? \\n\\nBelow approach is more intuitive to compare to the one in the Editorial. However, I am not able to figure out the time complexity of the algorithm. The time complexity is not exactly O(logn), but is not O(n) either, it somewhere lies in-between. \\n\\nCould anyone please help me to understand it? If possible, take x = 2 and n = 50 as an example. As per my understanding\\n1. When `i = 1` and `y = 50`, the value of `i` will be 1, 2, 4, 8, 16, 32. Then both will be reset to `i = 1` and `y = 50 - 32 = 18`.\\n2. When `i = 1` and `y = 18`, the value of `i` will be 1, 2, 4, 5, 16. Then again both will be reset to `i = 1` and `y = 18 - 16 = 2`.\\n3. When `i = 1` and `y = 2`, the value of `i` will be 1. Then again both will be reset to `i = 1` and `y = 2 - 1`. \\n4. When `i = 1` and `y = 1`, the value of `i` will be 1. Then again both will be reset to `i = 1` and `y = 1 - 1 = 0`. And the algorithm completes.\\n\\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        int y = abs(n);\\n\\n        // Base Condition.\\n        if (x == 0) return x;\\n        if (n == 0) return 1;\\n\\n        long long i = 1;\\n        double ans = 1, temp = x;\\n        while (y != 0) {\\n            if (i + i >= y) {\\n                y = y - i;\\n                i = 1;\\n                ans *= temp;\\n                temp = x;\\n            } else {\\n                temp *= temp;\\n                i <<= 1;\\n            }\\n        }\\n\\n        return n < 0 ? (1 / ans) : ans;\\n    }\\n};\\n``"
                    },
                    {
                        "username": "Boltfire",
                        "content": "Use math.pow() and make your life easier."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "lol I got it correct in one run"
                    },
                    {
                        "username": "psionl0",
                        "content": "Congratulations on anticipating the n = -2147483648 edge case."
                    },
                    {
                        "username": "user2387402",
                        "content": "bruh..."
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "memory error:291/306 test cases passed but this input:\\nx =\\n0.00001\\nn =\\n2147483647\\ncode:\\nans=1\\n        if n>0:\\n            \\n            for i in range(1,n+1):\\n                ans=ans*x\\n        else:\\n            for i in range(1,-n+1):\\n                ans=ans*(1/x)\\n\\n        return ans\\ncan anyone say why??\\n"
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "[@Sacristaria](/Sacristaria) thanks"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "Range essentially creates a list, which given the range uses up all the memory. Use xrange instead. Though it will likely timeout due to the large value."
                    },
                    {
                        "username": "Raedrin",
                        "content": "this problem is incredibly dumb. The fact that some of the test cases are greater than an int32 max value implies that the person calling the function cant read argument types."
                    },
                    {
                        "username": "19bec1397",
                        "content": "class Solution {\n    public double myPow(double x, int n) {\n\n        if(n==0){\n            return 1 ;\n        }\n        if(n==Integer.MIN_VALUE){\n             n = n +1 ; \n              return (1/x)*myPow(x,n);\n        }\n        if(n<0){\n            n = -n ; \n            x= 1/x;\n        }\n        if(n%2==0){\n            return myPow(x*x,n/2);\n        }else{\n            return x*myPow(x,n-1);\n        }\n        \n    }\n}\njava solution passes all test cases"
                    },
                    {
                        "username": "ameypathak39",
                        "content": "we have to return x**n"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "You have to implement x**n."
                    }
                ]
            },
            {
                "id": 1966342,
                "content": [
                    {
                        "username": "Nisarg_1709",
                        "content": "This question trick to find when try to find the power of negative  number"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "really? is this medium? \n\nLeetcode keeps making me amazed. Some `easy` problems are hard as hell, some `medium` or `hard` problems are below `easy` and you solve them in some seconds. \n\nATTENTION SPOILER: \nI wrote x ** n and was sure the error will pop up, but it passed..."
                    },
                    {
                        "username": "milanthakor",
                        "content": "What would be the time complexity of the below algorithm? \\n\\nBelow approach is more intuitive to compare to the one in the Editorial. However, I am not able to figure out the time complexity of the algorithm. The time complexity is not exactly O(logn), but is not O(n) either, it somewhere lies in-between. \\n\\nCould anyone please help me to understand it? If possible, take x = 2 and n = 50 as an example. As per my understanding\\n1. When `i = 1` and `y = 50`, the value of `i` will be 1, 2, 4, 8, 16, 32. Then both will be reset to `i = 1` and `y = 50 - 32 = 18`.\\n2. When `i = 1` and `y = 18`, the value of `i` will be 1, 2, 4, 5, 16. Then again both will be reset to `i = 1` and `y = 18 - 16 = 2`.\\n3. When `i = 1` and `y = 2`, the value of `i` will be 1. Then again both will be reset to `i = 1` and `y = 2 - 1`. \\n4. When `i = 1` and `y = 1`, the value of `i` will be 1. Then again both will be reset to `i = 1` and `y = 1 - 1 = 0`. And the algorithm completes.\\n\\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        int y = abs(n);\\n\\n        // Base Condition.\\n        if (x == 0) return x;\\n        if (n == 0) return 1;\\n\\n        long long i = 1;\\n        double ans = 1, temp = x;\\n        while (y != 0) {\\n            if (i + i >= y) {\\n                y = y - i;\\n                i = 1;\\n                ans *= temp;\\n                temp = x;\\n            } else {\\n                temp *= temp;\\n                i <<= 1;\\n            }\\n        }\\n\\n        return n < 0 ? (1 / ans) : ans;\\n    }\\n};\\n``"
                    },
                    {
                        "username": "Boltfire",
                        "content": "Use math.pow() and make your life easier."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "lol I got it correct in one run"
                    },
                    {
                        "username": "psionl0",
                        "content": "Congratulations on anticipating the n = -2147483648 edge case."
                    },
                    {
                        "username": "user2387402",
                        "content": "bruh..."
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "memory error:291/306 test cases passed but this input:\\nx =\\n0.00001\\nn =\\n2147483647\\ncode:\\nans=1\\n        if n>0:\\n            \\n            for i in range(1,n+1):\\n                ans=ans*x\\n        else:\\n            for i in range(1,-n+1):\\n                ans=ans*(1/x)\\n\\n        return ans\\ncan anyone say why??\\n"
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "[@Sacristaria](/Sacristaria) thanks"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "Range essentially creates a list, which given the range uses up all the memory. Use xrange instead. Though it will likely timeout due to the large value."
                    },
                    {
                        "username": "Raedrin",
                        "content": "this problem is incredibly dumb. The fact that some of the test cases are greater than an int32 max value implies that the person calling the function cant read argument types."
                    },
                    {
                        "username": "19bec1397",
                        "content": "class Solution {\n    public double myPow(double x, int n) {\n\n        if(n==0){\n            return 1 ;\n        }\n        if(n==Integer.MIN_VALUE){\n             n = n +1 ; \n              return (1/x)*myPow(x,n);\n        }\n        if(n<0){\n            n = -n ; \n            x= 1/x;\n        }\n        if(n%2==0){\n            return myPow(x*x,n/2);\n        }else{\n            return x*myPow(x,n-1);\n        }\n        \n    }\n}\njava solution passes all test cases"
                    },
                    {
                        "username": "ameypathak39",
                        "content": "we have to return x**n"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "You have to implement x**n."
                    }
                ]
            },
            {
                "id": 1965905,
                "content": [
                    {
                        "username": "Nisarg_1709",
                        "content": "This question trick to find when try to find the power of negative  number"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "really? is this medium? \n\nLeetcode keeps making me amazed. Some `easy` problems are hard as hell, some `medium` or `hard` problems are below `easy` and you solve them in some seconds. \n\nATTENTION SPOILER: \nI wrote x ** n and was sure the error will pop up, but it passed..."
                    },
                    {
                        "username": "milanthakor",
                        "content": "What would be the time complexity of the below algorithm? \\n\\nBelow approach is more intuitive to compare to the one in the Editorial. However, I am not able to figure out the time complexity of the algorithm. The time complexity is not exactly O(logn), but is not O(n) either, it somewhere lies in-between. \\n\\nCould anyone please help me to understand it? If possible, take x = 2 and n = 50 as an example. As per my understanding\\n1. When `i = 1` and `y = 50`, the value of `i` will be 1, 2, 4, 8, 16, 32. Then both will be reset to `i = 1` and `y = 50 - 32 = 18`.\\n2. When `i = 1` and `y = 18`, the value of `i` will be 1, 2, 4, 5, 16. Then again both will be reset to `i = 1` and `y = 18 - 16 = 2`.\\n3. When `i = 1` and `y = 2`, the value of `i` will be 1. Then again both will be reset to `i = 1` and `y = 2 - 1`. \\n4. When `i = 1` and `y = 1`, the value of `i` will be 1. Then again both will be reset to `i = 1` and `y = 1 - 1 = 0`. And the algorithm completes.\\n\\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        int y = abs(n);\\n\\n        // Base Condition.\\n        if (x == 0) return x;\\n        if (n == 0) return 1;\\n\\n        long long i = 1;\\n        double ans = 1, temp = x;\\n        while (y != 0) {\\n            if (i + i >= y) {\\n                y = y - i;\\n                i = 1;\\n                ans *= temp;\\n                temp = x;\\n            } else {\\n                temp *= temp;\\n                i <<= 1;\\n            }\\n        }\\n\\n        return n < 0 ? (1 / ans) : ans;\\n    }\\n};\\n``"
                    },
                    {
                        "username": "Boltfire",
                        "content": "Use math.pow() and make your life easier."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "lol I got it correct in one run"
                    },
                    {
                        "username": "psionl0",
                        "content": "Congratulations on anticipating the n = -2147483648 edge case."
                    },
                    {
                        "username": "user2387402",
                        "content": "bruh..."
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "memory error:291/306 test cases passed but this input:\\nx =\\n0.00001\\nn =\\n2147483647\\ncode:\\nans=1\\n        if n>0:\\n            \\n            for i in range(1,n+1):\\n                ans=ans*x\\n        else:\\n            for i in range(1,-n+1):\\n                ans=ans*(1/x)\\n\\n        return ans\\ncan anyone say why??\\n"
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "[@Sacristaria](/Sacristaria) thanks"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "Range essentially creates a list, which given the range uses up all the memory. Use xrange instead. Though it will likely timeout due to the large value."
                    },
                    {
                        "username": "Raedrin",
                        "content": "this problem is incredibly dumb. The fact that some of the test cases are greater than an int32 max value implies that the person calling the function cant read argument types."
                    },
                    {
                        "username": "19bec1397",
                        "content": "class Solution {\n    public double myPow(double x, int n) {\n\n        if(n==0){\n            return 1 ;\n        }\n        if(n==Integer.MIN_VALUE){\n             n = n +1 ; \n              return (1/x)*myPow(x,n);\n        }\n        if(n<0){\n            n = -n ; \n            x= 1/x;\n        }\n        if(n%2==0){\n            return myPow(x*x,n/2);\n        }else{\n            return x*myPow(x,n-1);\n        }\n        \n    }\n}\njava solution passes all test cases"
                    },
                    {
                        "username": "ameypathak39",
                        "content": "we have to return x**n"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "You have to implement x**n."
                    }
                ]
            },
            {
                "id": 1964859,
                "content": [
                    {
                        "username": "Nisarg_1709",
                        "content": "This question trick to find when try to find the power of negative  number"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "really? is this medium? \n\nLeetcode keeps making me amazed. Some `easy` problems are hard as hell, some `medium` or `hard` problems are below `easy` and you solve them in some seconds. \n\nATTENTION SPOILER: \nI wrote x ** n and was sure the error will pop up, but it passed..."
                    },
                    {
                        "username": "milanthakor",
                        "content": "What would be the time complexity of the below algorithm? \\n\\nBelow approach is more intuitive to compare to the one in the Editorial. However, I am not able to figure out the time complexity of the algorithm. The time complexity is not exactly O(logn), but is not O(n) either, it somewhere lies in-between. \\n\\nCould anyone please help me to understand it? If possible, take x = 2 and n = 50 as an example. As per my understanding\\n1. When `i = 1` and `y = 50`, the value of `i` will be 1, 2, 4, 8, 16, 32. Then both will be reset to `i = 1` and `y = 50 - 32 = 18`.\\n2. When `i = 1` and `y = 18`, the value of `i` will be 1, 2, 4, 5, 16. Then again both will be reset to `i = 1` and `y = 18 - 16 = 2`.\\n3. When `i = 1` and `y = 2`, the value of `i` will be 1. Then again both will be reset to `i = 1` and `y = 2 - 1`. \\n4. When `i = 1` and `y = 1`, the value of `i` will be 1. Then again both will be reset to `i = 1` and `y = 1 - 1 = 0`. And the algorithm completes.\\n\\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        int y = abs(n);\\n\\n        // Base Condition.\\n        if (x == 0) return x;\\n        if (n == 0) return 1;\\n\\n        long long i = 1;\\n        double ans = 1, temp = x;\\n        while (y != 0) {\\n            if (i + i >= y) {\\n                y = y - i;\\n                i = 1;\\n                ans *= temp;\\n                temp = x;\\n            } else {\\n                temp *= temp;\\n                i <<= 1;\\n            }\\n        }\\n\\n        return n < 0 ? (1 / ans) : ans;\\n    }\\n};\\n``"
                    },
                    {
                        "username": "Boltfire",
                        "content": "Use math.pow() and make your life easier."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "lol I got it correct in one run"
                    },
                    {
                        "username": "psionl0",
                        "content": "Congratulations on anticipating the n = -2147483648 edge case."
                    },
                    {
                        "username": "user2387402",
                        "content": "bruh..."
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "memory error:291/306 test cases passed but this input:\\nx =\\n0.00001\\nn =\\n2147483647\\ncode:\\nans=1\\n        if n>0:\\n            \\n            for i in range(1,n+1):\\n                ans=ans*x\\n        else:\\n            for i in range(1,-n+1):\\n                ans=ans*(1/x)\\n\\n        return ans\\ncan anyone say why??\\n"
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "[@Sacristaria](/Sacristaria) thanks"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "Range essentially creates a list, which given the range uses up all the memory. Use xrange instead. Though it will likely timeout due to the large value."
                    },
                    {
                        "username": "Raedrin",
                        "content": "this problem is incredibly dumb. The fact that some of the test cases are greater than an int32 max value implies that the person calling the function cant read argument types."
                    },
                    {
                        "username": "19bec1397",
                        "content": "class Solution {\n    public double myPow(double x, int n) {\n\n        if(n==0){\n            return 1 ;\n        }\n        if(n==Integer.MIN_VALUE){\n             n = n +1 ; \n              return (1/x)*myPow(x,n);\n        }\n        if(n<0){\n            n = -n ; \n            x= 1/x;\n        }\n        if(n%2==0){\n            return myPow(x*x,n/2);\n        }else{\n            return x*myPow(x,n-1);\n        }\n        \n    }\n}\njava solution passes all test cases"
                    },
                    {
                        "username": "ameypathak39",
                        "content": "we have to return x**n"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "You have to implement x**n."
                    }
                ]
            },
            {
                "id": 1957313,
                "content": [
                    {
                        "username": "Nisarg_1709",
                        "content": "This question trick to find when try to find the power of negative  number"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "really? is this medium? \n\nLeetcode keeps making me amazed. Some `easy` problems are hard as hell, some `medium` or `hard` problems are below `easy` and you solve them in some seconds. \n\nATTENTION SPOILER: \nI wrote x ** n and was sure the error will pop up, but it passed..."
                    },
                    {
                        "username": "milanthakor",
                        "content": "What would be the time complexity of the below algorithm? \\n\\nBelow approach is more intuitive to compare to the one in the Editorial. However, I am not able to figure out the time complexity of the algorithm. The time complexity is not exactly O(logn), but is not O(n) either, it somewhere lies in-between. \\n\\nCould anyone please help me to understand it? If possible, take x = 2 and n = 50 as an example. As per my understanding\\n1. When `i = 1` and `y = 50`, the value of `i` will be 1, 2, 4, 8, 16, 32. Then both will be reset to `i = 1` and `y = 50 - 32 = 18`.\\n2. When `i = 1` and `y = 18`, the value of `i` will be 1, 2, 4, 5, 16. Then again both will be reset to `i = 1` and `y = 18 - 16 = 2`.\\n3. When `i = 1` and `y = 2`, the value of `i` will be 1. Then again both will be reset to `i = 1` and `y = 2 - 1`. \\n4. When `i = 1` and `y = 1`, the value of `i` will be 1. Then again both will be reset to `i = 1` and `y = 1 - 1 = 0`. And the algorithm completes.\\n\\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        int y = abs(n);\\n\\n        // Base Condition.\\n        if (x == 0) return x;\\n        if (n == 0) return 1;\\n\\n        long long i = 1;\\n        double ans = 1, temp = x;\\n        while (y != 0) {\\n            if (i + i >= y) {\\n                y = y - i;\\n                i = 1;\\n                ans *= temp;\\n                temp = x;\\n            } else {\\n                temp *= temp;\\n                i <<= 1;\\n            }\\n        }\\n\\n        return n < 0 ? (1 / ans) : ans;\\n    }\\n};\\n``"
                    },
                    {
                        "username": "Boltfire",
                        "content": "Use math.pow() and make your life easier."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "lol I got it correct in one run"
                    },
                    {
                        "username": "psionl0",
                        "content": "Congratulations on anticipating the n = -2147483648 edge case."
                    },
                    {
                        "username": "user2387402",
                        "content": "bruh..."
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "memory error:291/306 test cases passed but this input:\\nx =\\n0.00001\\nn =\\n2147483647\\ncode:\\nans=1\\n        if n>0:\\n            \\n            for i in range(1,n+1):\\n                ans=ans*x\\n        else:\\n            for i in range(1,-n+1):\\n                ans=ans*(1/x)\\n\\n        return ans\\ncan anyone say why??\\n"
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "[@Sacristaria](/Sacristaria) thanks"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "Range essentially creates a list, which given the range uses up all the memory. Use xrange instead. Though it will likely timeout due to the large value."
                    },
                    {
                        "username": "Raedrin",
                        "content": "this problem is incredibly dumb. The fact that some of the test cases are greater than an int32 max value implies that the person calling the function cant read argument types."
                    },
                    {
                        "username": "19bec1397",
                        "content": "class Solution {\n    public double myPow(double x, int n) {\n\n        if(n==0){\n            return 1 ;\n        }\n        if(n==Integer.MIN_VALUE){\n             n = n +1 ; \n              return (1/x)*myPow(x,n);\n        }\n        if(n<0){\n            n = -n ; \n            x= 1/x;\n        }\n        if(n%2==0){\n            return myPow(x*x,n/2);\n        }else{\n            return x*myPow(x,n-1);\n        }\n        \n    }\n}\njava solution passes all test cases"
                    },
                    {
                        "username": "ameypathak39",
                        "content": "we have to return x**n"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "You have to implement x**n."
                    }
                ]
            },
            {
                "id": 1951498,
                "content": [
                    {
                        "username": "Nisarg_1709",
                        "content": "This question trick to find when try to find the power of negative  number"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "really? is this medium? \n\nLeetcode keeps making me amazed. Some `easy` problems are hard as hell, some `medium` or `hard` problems are below `easy` and you solve them in some seconds. \n\nATTENTION SPOILER: \nI wrote x ** n and was sure the error will pop up, but it passed..."
                    },
                    {
                        "username": "milanthakor",
                        "content": "What would be the time complexity of the below algorithm? \\n\\nBelow approach is more intuitive to compare to the one in the Editorial. However, I am not able to figure out the time complexity of the algorithm. The time complexity is not exactly O(logn), but is not O(n) either, it somewhere lies in-between. \\n\\nCould anyone please help me to understand it? If possible, take x = 2 and n = 50 as an example. As per my understanding\\n1. When `i = 1` and `y = 50`, the value of `i` will be 1, 2, 4, 8, 16, 32. Then both will be reset to `i = 1` and `y = 50 - 32 = 18`.\\n2. When `i = 1` and `y = 18`, the value of `i` will be 1, 2, 4, 5, 16. Then again both will be reset to `i = 1` and `y = 18 - 16 = 2`.\\n3. When `i = 1` and `y = 2`, the value of `i` will be 1. Then again both will be reset to `i = 1` and `y = 2 - 1`. \\n4. When `i = 1` and `y = 1`, the value of `i` will be 1. Then again both will be reset to `i = 1` and `y = 1 - 1 = 0`. And the algorithm completes.\\n\\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        int y = abs(n);\\n\\n        // Base Condition.\\n        if (x == 0) return x;\\n        if (n == 0) return 1;\\n\\n        long long i = 1;\\n        double ans = 1, temp = x;\\n        while (y != 0) {\\n            if (i + i >= y) {\\n                y = y - i;\\n                i = 1;\\n                ans *= temp;\\n                temp = x;\\n            } else {\\n                temp *= temp;\\n                i <<= 1;\\n            }\\n        }\\n\\n        return n < 0 ? (1 / ans) : ans;\\n    }\\n};\\n``"
                    },
                    {
                        "username": "Boltfire",
                        "content": "Use math.pow() and make your life easier."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "lol I got it correct in one run"
                    },
                    {
                        "username": "psionl0",
                        "content": "Congratulations on anticipating the n = -2147483648 edge case."
                    },
                    {
                        "username": "user2387402",
                        "content": "bruh..."
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "memory error:291/306 test cases passed but this input:\\nx =\\n0.00001\\nn =\\n2147483647\\ncode:\\nans=1\\n        if n>0:\\n            \\n            for i in range(1,n+1):\\n                ans=ans*x\\n        else:\\n            for i in range(1,-n+1):\\n                ans=ans*(1/x)\\n\\n        return ans\\ncan anyone say why??\\n"
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "[@Sacristaria](/Sacristaria) thanks"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "Range essentially creates a list, which given the range uses up all the memory. Use xrange instead. Though it will likely timeout due to the large value."
                    },
                    {
                        "username": "Raedrin",
                        "content": "this problem is incredibly dumb. The fact that some of the test cases are greater than an int32 max value implies that the person calling the function cant read argument types."
                    },
                    {
                        "username": "19bec1397",
                        "content": "class Solution {\n    public double myPow(double x, int n) {\n\n        if(n==0){\n            return 1 ;\n        }\n        if(n==Integer.MIN_VALUE){\n             n = n +1 ; \n              return (1/x)*myPow(x,n);\n        }\n        if(n<0){\n            n = -n ; \n            x= 1/x;\n        }\n        if(n%2==0){\n            return myPow(x*x,n/2);\n        }else{\n            return x*myPow(x,n-1);\n        }\n        \n    }\n}\njava solution passes all test cases"
                    },
                    {
                        "username": "ameypathak39",
                        "content": "we have to return x**n"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "You have to implement x**n."
                    }
                ]
            },
            {
                "id": 1951346,
                "content": [
                    {
                        "username": "Nisarg_1709",
                        "content": "This question trick to find when try to find the power of negative  number"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "really? is this medium? \n\nLeetcode keeps making me amazed. Some `easy` problems are hard as hell, some `medium` or `hard` problems are below `easy` and you solve them in some seconds. \n\nATTENTION SPOILER: \nI wrote x ** n and was sure the error will pop up, but it passed..."
                    },
                    {
                        "username": "milanthakor",
                        "content": "What would be the time complexity of the below algorithm? \\n\\nBelow approach is more intuitive to compare to the one in the Editorial. However, I am not able to figure out the time complexity of the algorithm. The time complexity is not exactly O(logn), but is not O(n) either, it somewhere lies in-between. \\n\\nCould anyone please help me to understand it? If possible, take x = 2 and n = 50 as an example. As per my understanding\\n1. When `i = 1` and `y = 50`, the value of `i` will be 1, 2, 4, 8, 16, 32. Then both will be reset to `i = 1` and `y = 50 - 32 = 18`.\\n2. When `i = 1` and `y = 18`, the value of `i` will be 1, 2, 4, 5, 16. Then again both will be reset to `i = 1` and `y = 18 - 16 = 2`.\\n3. When `i = 1` and `y = 2`, the value of `i` will be 1. Then again both will be reset to `i = 1` and `y = 2 - 1`. \\n4. When `i = 1` and `y = 1`, the value of `i` will be 1. Then again both will be reset to `i = 1` and `y = 1 - 1 = 0`. And the algorithm completes.\\n\\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        int y = abs(n);\\n\\n        // Base Condition.\\n        if (x == 0) return x;\\n        if (n == 0) return 1;\\n\\n        long long i = 1;\\n        double ans = 1, temp = x;\\n        while (y != 0) {\\n            if (i + i >= y) {\\n                y = y - i;\\n                i = 1;\\n                ans *= temp;\\n                temp = x;\\n            } else {\\n                temp *= temp;\\n                i <<= 1;\\n            }\\n        }\\n\\n        return n < 0 ? (1 / ans) : ans;\\n    }\\n};\\n``"
                    },
                    {
                        "username": "Boltfire",
                        "content": "Use math.pow() and make your life easier."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "lol I got it correct in one run"
                    },
                    {
                        "username": "psionl0",
                        "content": "Congratulations on anticipating the n = -2147483648 edge case."
                    },
                    {
                        "username": "user2387402",
                        "content": "bruh..."
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "memory error:291/306 test cases passed but this input:\\nx =\\n0.00001\\nn =\\n2147483647\\ncode:\\nans=1\\n        if n>0:\\n            \\n            for i in range(1,n+1):\\n                ans=ans*x\\n        else:\\n            for i in range(1,-n+1):\\n                ans=ans*(1/x)\\n\\n        return ans\\ncan anyone say why??\\n"
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "[@Sacristaria](/Sacristaria) thanks"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "Range essentially creates a list, which given the range uses up all the memory. Use xrange instead. Though it will likely timeout due to the large value."
                    },
                    {
                        "username": "Raedrin",
                        "content": "this problem is incredibly dumb. The fact that some of the test cases are greater than an int32 max value implies that the person calling the function cant read argument types."
                    },
                    {
                        "username": "19bec1397",
                        "content": "class Solution {\n    public double myPow(double x, int n) {\n\n        if(n==0){\n            return 1 ;\n        }\n        if(n==Integer.MIN_VALUE){\n             n = n +1 ; \n              return (1/x)*myPow(x,n);\n        }\n        if(n<0){\n            n = -n ; \n            x= 1/x;\n        }\n        if(n%2==0){\n            return myPow(x*x,n/2);\n        }else{\n            return x*myPow(x,n-1);\n        }\n        \n    }\n}\njava solution passes all test cases"
                    },
                    {
                        "username": "ameypathak39",
                        "content": "we have to return x**n"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "You have to implement x**n."
                    }
                ]
            },
            {
                "id": 1951344,
                "content": [
                    {
                        "username": "Nisarg_1709",
                        "content": "This question trick to find when try to find the power of negative  number"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "really? is this medium? \n\nLeetcode keeps making me amazed. Some `easy` problems are hard as hell, some `medium` or `hard` problems are below `easy` and you solve them in some seconds. \n\nATTENTION SPOILER: \nI wrote x ** n and was sure the error will pop up, but it passed..."
                    },
                    {
                        "username": "milanthakor",
                        "content": "What would be the time complexity of the below algorithm? \\n\\nBelow approach is more intuitive to compare to the one in the Editorial. However, I am not able to figure out the time complexity of the algorithm. The time complexity is not exactly O(logn), but is not O(n) either, it somewhere lies in-between. \\n\\nCould anyone please help me to understand it? If possible, take x = 2 and n = 50 as an example. As per my understanding\\n1. When `i = 1` and `y = 50`, the value of `i` will be 1, 2, 4, 8, 16, 32. Then both will be reset to `i = 1` and `y = 50 - 32 = 18`.\\n2. When `i = 1` and `y = 18`, the value of `i` will be 1, 2, 4, 5, 16. Then again both will be reset to `i = 1` and `y = 18 - 16 = 2`.\\n3. When `i = 1` and `y = 2`, the value of `i` will be 1. Then again both will be reset to `i = 1` and `y = 2 - 1`. \\n4. When `i = 1` and `y = 1`, the value of `i` will be 1. Then again both will be reset to `i = 1` and `y = 1 - 1 = 0`. And the algorithm completes.\\n\\n```\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        int y = abs(n);\\n\\n        // Base Condition.\\n        if (x == 0) return x;\\n        if (n == 0) return 1;\\n\\n        long long i = 1;\\n        double ans = 1, temp = x;\\n        while (y != 0) {\\n            if (i + i >= y) {\\n                y = y - i;\\n                i = 1;\\n                ans *= temp;\\n                temp = x;\\n            } else {\\n                temp *= temp;\\n                i <<= 1;\\n            }\\n        }\\n\\n        return n < 0 ? (1 / ans) : ans;\\n    }\\n};\\n``"
                    },
                    {
                        "username": "Boltfire",
                        "content": "Use math.pow() and make your life easier."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "lol I got it correct in one run"
                    },
                    {
                        "username": "psionl0",
                        "content": "Congratulations on anticipating the n = -2147483648 edge case."
                    },
                    {
                        "username": "user2387402",
                        "content": "bruh..."
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "memory error:291/306 test cases passed but this input:\\nx =\\n0.00001\\nn =\\n2147483647\\ncode:\\nans=1\\n        if n>0:\\n            \\n            for i in range(1,n+1):\\n                ans=ans*x\\n        else:\\n            for i in range(1,-n+1):\\n                ans=ans*(1/x)\\n\\n        return ans\\ncan anyone say why??\\n"
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "[@Sacristaria](/Sacristaria) thanks"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "Range essentially creates a list, which given the range uses up all the memory. Use xrange instead. Though it will likely timeout due to the large value."
                    },
                    {
                        "username": "Raedrin",
                        "content": "this problem is incredibly dumb. The fact that some of the test cases are greater than an int32 max value implies that the person calling the function cant read argument types."
                    },
                    {
                        "username": "19bec1397",
                        "content": "class Solution {\n    public double myPow(double x, int n) {\n\n        if(n==0){\n            return 1 ;\n        }\n        if(n==Integer.MIN_VALUE){\n             n = n +1 ; \n              return (1/x)*myPow(x,n);\n        }\n        if(n<0){\n            n = -n ; \n            x= 1/x;\n        }\n        if(n%2==0){\n            return myPow(x*x,n/2);\n        }else{\n            return x*myPow(x,n-1);\n        }\n        \n    }\n}\njava solution passes all test cases"
                    },
                    {
                        "username": "ameypathak39",
                        "content": "we have to return x**n"
                    },
                    {
                        "username": "Sacristaria",
                        "content": "You have to implement x**n."
                    }
                ]
            },
            {
                "id": 1950786,
                "content": [
                    {
                        "username": "abhash_18",
                        "content": "why this is question given Medium Status? Its just a one line code.\\nAm i doing something wrong please guide me"
                    },
                    {
                        "username": "bsumner2",
                        "content": "Imagine your language doesn\\'t have a pow function built in. The challenge of the question is making your own version of it, pretending like the provided one doesn\\'t exist. If you used the built in exponent function provided by the math library of your language, then you\\'re trivializing the challenge. Ofc you can just use pow. But imagine back in the early days of programming where you had to write a pow function from scratch. Hope that helps. Happy coding :) "
                    },
                    {
                        "username": "jungle_jim",
                        "content": "This is a math problem."
                    },
                    {
                        "username": "user5029SI",
                        "content": "Lol the test cases are literally trolling\\n"
                    },
                    {
                        "username": "romantimm25",
                        "content": "Good reads about this topic are:\\nhttps://en.wikipedia.org/wiki/Addition-chain_exponentiation\\nOptimal exponent calculations are not a simple task. So talking about this in the interview might add some value."
                    },
                    {
                        "username": "Yahan-Pranjhol-hai",
                        "content": "var myPow = function(x, n) {\\n  if (n === 0) {\\n    return 1;\\n  }\\n  \\n  if (n < 0) {\\n    return 1 / myPow(x, -n);\\n  }\\n  \\n  if (n % 2 === 0) {\\n    const y = myPow(x, n / 2);\\n    return y * y;\\n  }\\n  \\n  return x * myPow(x, n - 1);\\n};\\n// x**n"
                    },
                    {
                        "username": "juansymontano",
                        "content": "A lot of people are missing the problem. No wonder they can\\u2019t pass technical interviews. "
                    },
                    {
                        "username": "arithin",
                        "content": "Ive written a lot of code. Never have I ever needed to rewrite the POW function. And if I did you know what I\\'d do? Read up on a bunch of math before hand not memorize bs like this"
                    },
                    {
                        "username": "vanshjain499",
                        "content": "return Math.pow(x,n);"
                    },
                    {
                        "username": "juansymontano",
                        "content": "You\\u2019re supposed to implement your own. "
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases I tested my code with\n```\n2\n10\n2\n3\n2\n-2\n2\n13\n-2\n13\n2\n-13\n25\n1\n99\n0\n-99\n-99\n99\n-99\n99\n-2\n0\n10\n1\n25\n1\n0\n```"
                    },
                    {
                        "username": "vadapallichaitu",
                        "content": "something is wrong here, I keep on trying to uses recursive but it says \"name \\'myPow\\' is not defined\", I tried same logic in python playground , it works there"
                    },
                    {
                        "username": "ujwalb29",
                        "content": "x =\\n8.84372\\nn =\\n-5\\nOutput\\n0.00145\\nExpected\\n2e-05\\nWhat\\'s wrong??"
                    }
                ]
            },
            {
                "id": 1911248,
                "content": [
                    {
                        "username": "abhash_18",
                        "content": "why this is question given Medium Status? Its just a one line code.\\nAm i doing something wrong please guide me"
                    },
                    {
                        "username": "bsumner2",
                        "content": "Imagine your language doesn\\'t have a pow function built in. The challenge of the question is making your own version of it, pretending like the provided one doesn\\'t exist. If you used the built in exponent function provided by the math library of your language, then you\\'re trivializing the challenge. Ofc you can just use pow. But imagine back in the early days of programming where you had to write a pow function from scratch. Hope that helps. Happy coding :) "
                    },
                    {
                        "username": "jungle_jim",
                        "content": "This is a math problem."
                    },
                    {
                        "username": "user5029SI",
                        "content": "Lol the test cases are literally trolling\\n"
                    },
                    {
                        "username": "romantimm25",
                        "content": "Good reads about this topic are:\\nhttps://en.wikipedia.org/wiki/Addition-chain_exponentiation\\nOptimal exponent calculations are not a simple task. So talking about this in the interview might add some value."
                    },
                    {
                        "username": "Yahan-Pranjhol-hai",
                        "content": "var myPow = function(x, n) {\\n  if (n === 0) {\\n    return 1;\\n  }\\n  \\n  if (n < 0) {\\n    return 1 / myPow(x, -n);\\n  }\\n  \\n  if (n % 2 === 0) {\\n    const y = myPow(x, n / 2);\\n    return y * y;\\n  }\\n  \\n  return x * myPow(x, n - 1);\\n};\\n// x**n"
                    },
                    {
                        "username": "juansymontano",
                        "content": "A lot of people are missing the problem. No wonder they can\\u2019t pass technical interviews. "
                    },
                    {
                        "username": "arithin",
                        "content": "Ive written a lot of code. Never have I ever needed to rewrite the POW function. And if I did you know what I\\'d do? Read up on a bunch of math before hand not memorize bs like this"
                    },
                    {
                        "username": "vanshjain499",
                        "content": "return Math.pow(x,n);"
                    },
                    {
                        "username": "juansymontano",
                        "content": "You\\u2019re supposed to implement your own. "
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases I tested my code with\n```\n2\n10\n2\n3\n2\n-2\n2\n13\n-2\n13\n2\n-13\n25\n1\n99\n0\n-99\n-99\n99\n-99\n99\n-2\n0\n10\n1\n25\n1\n0\n```"
                    },
                    {
                        "username": "vadapallichaitu",
                        "content": "something is wrong here, I keep on trying to uses recursive but it says \"name \\'myPow\\' is not defined\", I tried same logic in python playground , it works there"
                    },
                    {
                        "username": "ujwalb29",
                        "content": "x =\\n8.84372\\nn =\\n-5\\nOutput\\n0.00145\\nExpected\\n2e-05\\nWhat\\'s wrong??"
                    }
                ]
            },
            {
                "id": 1907314,
                "content": [
                    {
                        "username": "abhash_18",
                        "content": "why this is question given Medium Status? Its just a one line code.\\nAm i doing something wrong please guide me"
                    },
                    {
                        "username": "bsumner2",
                        "content": "Imagine your language doesn\\'t have a pow function built in. The challenge of the question is making your own version of it, pretending like the provided one doesn\\'t exist. If you used the built in exponent function provided by the math library of your language, then you\\'re trivializing the challenge. Ofc you can just use pow. But imagine back in the early days of programming where you had to write a pow function from scratch. Hope that helps. Happy coding :) "
                    },
                    {
                        "username": "jungle_jim",
                        "content": "This is a math problem."
                    },
                    {
                        "username": "user5029SI",
                        "content": "Lol the test cases are literally trolling\\n"
                    },
                    {
                        "username": "romantimm25",
                        "content": "Good reads about this topic are:\\nhttps://en.wikipedia.org/wiki/Addition-chain_exponentiation\\nOptimal exponent calculations are not a simple task. So talking about this in the interview might add some value."
                    },
                    {
                        "username": "Yahan-Pranjhol-hai",
                        "content": "var myPow = function(x, n) {\\n  if (n === 0) {\\n    return 1;\\n  }\\n  \\n  if (n < 0) {\\n    return 1 / myPow(x, -n);\\n  }\\n  \\n  if (n % 2 === 0) {\\n    const y = myPow(x, n / 2);\\n    return y * y;\\n  }\\n  \\n  return x * myPow(x, n - 1);\\n};\\n// x**n"
                    },
                    {
                        "username": "juansymontano",
                        "content": "A lot of people are missing the problem. No wonder they can\\u2019t pass technical interviews. "
                    },
                    {
                        "username": "arithin",
                        "content": "Ive written a lot of code. Never have I ever needed to rewrite the POW function. And if I did you know what I\\'d do? Read up on a bunch of math before hand not memorize bs like this"
                    },
                    {
                        "username": "vanshjain499",
                        "content": "return Math.pow(x,n);"
                    },
                    {
                        "username": "juansymontano",
                        "content": "You\\u2019re supposed to implement your own. "
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases I tested my code with\n```\n2\n10\n2\n3\n2\n-2\n2\n13\n-2\n13\n2\n-13\n25\n1\n99\n0\n-99\n-99\n99\n-99\n99\n-2\n0\n10\n1\n25\n1\n0\n```"
                    },
                    {
                        "username": "vadapallichaitu",
                        "content": "something is wrong here, I keep on trying to uses recursive but it says \"name \\'myPow\\' is not defined\", I tried same logic in python playground , it works there"
                    },
                    {
                        "username": "ujwalb29",
                        "content": "x =\\n8.84372\\nn =\\n-5\\nOutput\\n0.00145\\nExpected\\n2e-05\\nWhat\\'s wrong??"
                    }
                ]
            },
            {
                "id": 1906520,
                "content": [
                    {
                        "username": "abhash_18",
                        "content": "why this is question given Medium Status? Its just a one line code.\\nAm i doing something wrong please guide me"
                    },
                    {
                        "username": "bsumner2",
                        "content": "Imagine your language doesn\\'t have a pow function built in. The challenge of the question is making your own version of it, pretending like the provided one doesn\\'t exist. If you used the built in exponent function provided by the math library of your language, then you\\'re trivializing the challenge. Ofc you can just use pow. But imagine back in the early days of programming where you had to write a pow function from scratch. Hope that helps. Happy coding :) "
                    },
                    {
                        "username": "jungle_jim",
                        "content": "This is a math problem."
                    },
                    {
                        "username": "user5029SI",
                        "content": "Lol the test cases are literally trolling\\n"
                    },
                    {
                        "username": "romantimm25",
                        "content": "Good reads about this topic are:\\nhttps://en.wikipedia.org/wiki/Addition-chain_exponentiation\\nOptimal exponent calculations are not a simple task. So talking about this in the interview might add some value."
                    },
                    {
                        "username": "Yahan-Pranjhol-hai",
                        "content": "var myPow = function(x, n) {\\n  if (n === 0) {\\n    return 1;\\n  }\\n  \\n  if (n < 0) {\\n    return 1 / myPow(x, -n);\\n  }\\n  \\n  if (n % 2 === 0) {\\n    const y = myPow(x, n / 2);\\n    return y * y;\\n  }\\n  \\n  return x * myPow(x, n - 1);\\n};\\n// x**n"
                    },
                    {
                        "username": "juansymontano",
                        "content": "A lot of people are missing the problem. No wonder they can\\u2019t pass technical interviews. "
                    },
                    {
                        "username": "arithin",
                        "content": "Ive written a lot of code. Never have I ever needed to rewrite the POW function. And if I did you know what I\\'d do? Read up on a bunch of math before hand not memorize bs like this"
                    },
                    {
                        "username": "vanshjain499",
                        "content": "return Math.pow(x,n);"
                    },
                    {
                        "username": "juansymontano",
                        "content": "You\\u2019re supposed to implement your own. "
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases I tested my code with\n```\n2\n10\n2\n3\n2\n-2\n2\n13\n-2\n13\n2\n-13\n25\n1\n99\n0\n-99\n-99\n99\n-99\n99\n-2\n0\n10\n1\n25\n1\n0\n```"
                    },
                    {
                        "username": "vadapallichaitu",
                        "content": "something is wrong here, I keep on trying to uses recursive but it says \"name \\'myPow\\' is not defined\", I tried same logic in python playground , it works there"
                    },
                    {
                        "username": "ujwalb29",
                        "content": "x =\\n8.84372\\nn =\\n-5\\nOutput\\n0.00145\\nExpected\\n2e-05\\nWhat\\'s wrong??"
                    }
                ]
            },
            {
                "id": 1901989,
                "content": [
                    {
                        "username": "abhash_18",
                        "content": "why this is question given Medium Status? Its just a one line code.\\nAm i doing something wrong please guide me"
                    },
                    {
                        "username": "bsumner2",
                        "content": "Imagine your language doesn\\'t have a pow function built in. The challenge of the question is making your own version of it, pretending like the provided one doesn\\'t exist. If you used the built in exponent function provided by the math library of your language, then you\\'re trivializing the challenge. Ofc you can just use pow. But imagine back in the early days of programming where you had to write a pow function from scratch. Hope that helps. Happy coding :) "
                    },
                    {
                        "username": "jungle_jim",
                        "content": "This is a math problem."
                    },
                    {
                        "username": "user5029SI",
                        "content": "Lol the test cases are literally trolling\\n"
                    },
                    {
                        "username": "romantimm25",
                        "content": "Good reads about this topic are:\\nhttps://en.wikipedia.org/wiki/Addition-chain_exponentiation\\nOptimal exponent calculations are not a simple task. So talking about this in the interview might add some value."
                    },
                    {
                        "username": "Yahan-Pranjhol-hai",
                        "content": "var myPow = function(x, n) {\\n  if (n === 0) {\\n    return 1;\\n  }\\n  \\n  if (n < 0) {\\n    return 1 / myPow(x, -n);\\n  }\\n  \\n  if (n % 2 === 0) {\\n    const y = myPow(x, n / 2);\\n    return y * y;\\n  }\\n  \\n  return x * myPow(x, n - 1);\\n};\\n// x**n"
                    },
                    {
                        "username": "juansymontano",
                        "content": "A lot of people are missing the problem. No wonder they can\\u2019t pass technical interviews. "
                    },
                    {
                        "username": "arithin",
                        "content": "Ive written a lot of code. Never have I ever needed to rewrite the POW function. And if I did you know what I\\'d do? Read up on a bunch of math before hand not memorize bs like this"
                    },
                    {
                        "username": "vanshjain499",
                        "content": "return Math.pow(x,n);"
                    },
                    {
                        "username": "juansymontano",
                        "content": "You\\u2019re supposed to implement your own. "
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases I tested my code with\n```\n2\n10\n2\n3\n2\n-2\n2\n13\n-2\n13\n2\n-13\n25\n1\n99\n0\n-99\n-99\n99\n-99\n99\n-2\n0\n10\n1\n25\n1\n0\n```"
                    },
                    {
                        "username": "vadapallichaitu",
                        "content": "something is wrong here, I keep on trying to uses recursive but it says \"name \\'myPow\\' is not defined\", I tried same logic in python playground , it works there"
                    },
                    {
                        "username": "ujwalb29",
                        "content": "x =\\n8.84372\\nn =\\n-5\\nOutput\\n0.00145\\nExpected\\n2e-05\\nWhat\\'s wrong??"
                    }
                ]
            },
            {
                "id": 1898841,
                "content": [
                    {
                        "username": "abhash_18",
                        "content": "why this is question given Medium Status? Its just a one line code.\\nAm i doing something wrong please guide me"
                    },
                    {
                        "username": "bsumner2",
                        "content": "Imagine your language doesn\\'t have a pow function built in. The challenge of the question is making your own version of it, pretending like the provided one doesn\\'t exist. If you used the built in exponent function provided by the math library of your language, then you\\'re trivializing the challenge. Ofc you can just use pow. But imagine back in the early days of programming where you had to write a pow function from scratch. Hope that helps. Happy coding :) "
                    },
                    {
                        "username": "jungle_jim",
                        "content": "This is a math problem."
                    },
                    {
                        "username": "user5029SI",
                        "content": "Lol the test cases are literally trolling\\n"
                    },
                    {
                        "username": "romantimm25",
                        "content": "Good reads about this topic are:\\nhttps://en.wikipedia.org/wiki/Addition-chain_exponentiation\\nOptimal exponent calculations are not a simple task. So talking about this in the interview might add some value."
                    },
                    {
                        "username": "Yahan-Pranjhol-hai",
                        "content": "var myPow = function(x, n) {\\n  if (n === 0) {\\n    return 1;\\n  }\\n  \\n  if (n < 0) {\\n    return 1 / myPow(x, -n);\\n  }\\n  \\n  if (n % 2 === 0) {\\n    const y = myPow(x, n / 2);\\n    return y * y;\\n  }\\n  \\n  return x * myPow(x, n - 1);\\n};\\n// x**n"
                    },
                    {
                        "username": "juansymontano",
                        "content": "A lot of people are missing the problem. No wonder they can\\u2019t pass technical interviews. "
                    },
                    {
                        "username": "arithin",
                        "content": "Ive written a lot of code. Never have I ever needed to rewrite the POW function. And if I did you know what I\\'d do? Read up on a bunch of math before hand not memorize bs like this"
                    },
                    {
                        "username": "vanshjain499",
                        "content": "return Math.pow(x,n);"
                    },
                    {
                        "username": "juansymontano",
                        "content": "You\\u2019re supposed to implement your own. "
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases I tested my code with\n```\n2\n10\n2\n3\n2\n-2\n2\n13\n-2\n13\n2\n-13\n25\n1\n99\n0\n-99\n-99\n99\n-99\n99\n-2\n0\n10\n1\n25\n1\n0\n```"
                    },
                    {
                        "username": "vadapallichaitu",
                        "content": "something is wrong here, I keep on trying to uses recursive but it says \"name \\'myPow\\' is not defined\", I tried same logic in python playground , it works there"
                    },
                    {
                        "username": "ujwalb29",
                        "content": "x =\\n8.84372\\nn =\\n-5\\nOutput\\n0.00145\\nExpected\\n2e-05\\nWhat\\'s wrong??"
                    }
                ]
            },
            {
                "id": 1898827,
                "content": [
                    {
                        "username": "abhash_18",
                        "content": "why this is question given Medium Status? Its just a one line code.\\nAm i doing something wrong please guide me"
                    },
                    {
                        "username": "bsumner2",
                        "content": "Imagine your language doesn\\'t have a pow function built in. The challenge of the question is making your own version of it, pretending like the provided one doesn\\'t exist. If you used the built in exponent function provided by the math library of your language, then you\\'re trivializing the challenge. Ofc you can just use pow. But imagine back in the early days of programming where you had to write a pow function from scratch. Hope that helps. Happy coding :) "
                    },
                    {
                        "username": "jungle_jim",
                        "content": "This is a math problem."
                    },
                    {
                        "username": "user5029SI",
                        "content": "Lol the test cases are literally trolling\\n"
                    },
                    {
                        "username": "romantimm25",
                        "content": "Good reads about this topic are:\\nhttps://en.wikipedia.org/wiki/Addition-chain_exponentiation\\nOptimal exponent calculations are not a simple task. So talking about this in the interview might add some value."
                    },
                    {
                        "username": "Yahan-Pranjhol-hai",
                        "content": "var myPow = function(x, n) {\\n  if (n === 0) {\\n    return 1;\\n  }\\n  \\n  if (n < 0) {\\n    return 1 / myPow(x, -n);\\n  }\\n  \\n  if (n % 2 === 0) {\\n    const y = myPow(x, n / 2);\\n    return y * y;\\n  }\\n  \\n  return x * myPow(x, n - 1);\\n};\\n// x**n"
                    },
                    {
                        "username": "juansymontano",
                        "content": "A lot of people are missing the problem. No wonder they can\\u2019t pass technical interviews. "
                    },
                    {
                        "username": "arithin",
                        "content": "Ive written a lot of code. Never have I ever needed to rewrite the POW function. And if I did you know what I\\'d do? Read up on a bunch of math before hand not memorize bs like this"
                    },
                    {
                        "username": "vanshjain499",
                        "content": "return Math.pow(x,n);"
                    },
                    {
                        "username": "juansymontano",
                        "content": "You\\u2019re supposed to implement your own. "
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases I tested my code with\n```\n2\n10\n2\n3\n2\n-2\n2\n13\n-2\n13\n2\n-13\n25\n1\n99\n0\n-99\n-99\n99\n-99\n99\n-2\n0\n10\n1\n25\n1\n0\n```"
                    },
                    {
                        "username": "vadapallichaitu",
                        "content": "something is wrong here, I keep on trying to uses recursive but it says \"name \\'myPow\\' is not defined\", I tried same logic in python playground , it works there"
                    },
                    {
                        "username": "ujwalb29",
                        "content": "x =\\n8.84372\\nn =\\n-5\\nOutput\\n0.00145\\nExpected\\n2e-05\\nWhat\\'s wrong??"
                    }
                ]
            },
            {
                "id": 1895127,
                "content": [
                    {
                        "username": "abhash_18",
                        "content": "why this is question given Medium Status? Its just a one line code.\\nAm i doing something wrong please guide me"
                    },
                    {
                        "username": "bsumner2",
                        "content": "Imagine your language doesn\\'t have a pow function built in. The challenge of the question is making your own version of it, pretending like the provided one doesn\\'t exist. If you used the built in exponent function provided by the math library of your language, then you\\'re trivializing the challenge. Ofc you can just use pow. But imagine back in the early days of programming where you had to write a pow function from scratch. Hope that helps. Happy coding :) "
                    },
                    {
                        "username": "jungle_jim",
                        "content": "This is a math problem."
                    },
                    {
                        "username": "user5029SI",
                        "content": "Lol the test cases are literally trolling\\n"
                    },
                    {
                        "username": "romantimm25",
                        "content": "Good reads about this topic are:\\nhttps://en.wikipedia.org/wiki/Addition-chain_exponentiation\\nOptimal exponent calculations are not a simple task. So talking about this in the interview might add some value."
                    },
                    {
                        "username": "Yahan-Pranjhol-hai",
                        "content": "var myPow = function(x, n) {\\n  if (n === 0) {\\n    return 1;\\n  }\\n  \\n  if (n < 0) {\\n    return 1 / myPow(x, -n);\\n  }\\n  \\n  if (n % 2 === 0) {\\n    const y = myPow(x, n / 2);\\n    return y * y;\\n  }\\n  \\n  return x * myPow(x, n - 1);\\n};\\n// x**n"
                    },
                    {
                        "username": "juansymontano",
                        "content": "A lot of people are missing the problem. No wonder they can\\u2019t pass technical interviews. "
                    },
                    {
                        "username": "arithin",
                        "content": "Ive written a lot of code. Never have I ever needed to rewrite the POW function. And if I did you know what I\\'d do? Read up on a bunch of math before hand not memorize bs like this"
                    },
                    {
                        "username": "vanshjain499",
                        "content": "return Math.pow(x,n);"
                    },
                    {
                        "username": "juansymontano",
                        "content": "You\\u2019re supposed to implement your own. "
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases I tested my code with\n```\n2\n10\n2\n3\n2\n-2\n2\n13\n-2\n13\n2\n-13\n25\n1\n99\n0\n-99\n-99\n99\n-99\n99\n-2\n0\n10\n1\n25\n1\n0\n```"
                    },
                    {
                        "username": "vadapallichaitu",
                        "content": "something is wrong here, I keep on trying to uses recursive but it says \"name \\'myPow\\' is not defined\", I tried same logic in python playground , it works there"
                    },
                    {
                        "username": "ujwalb29",
                        "content": "x =\\n8.84372\\nn =\\n-5\\nOutput\\n0.00145\\nExpected\\n2e-05\\nWhat\\'s wrong??"
                    }
                ]
            },
            {
                "id": 1893532,
                "content": [
                    {
                        "username": "abhash_18",
                        "content": "why this is question given Medium Status? Its just a one line code.\\nAm i doing something wrong please guide me"
                    },
                    {
                        "username": "bsumner2",
                        "content": "Imagine your language doesn\\'t have a pow function built in. The challenge of the question is making your own version of it, pretending like the provided one doesn\\'t exist. If you used the built in exponent function provided by the math library of your language, then you\\'re trivializing the challenge. Ofc you can just use pow. But imagine back in the early days of programming where you had to write a pow function from scratch. Hope that helps. Happy coding :) "
                    },
                    {
                        "username": "jungle_jim",
                        "content": "This is a math problem."
                    },
                    {
                        "username": "user5029SI",
                        "content": "Lol the test cases are literally trolling\\n"
                    },
                    {
                        "username": "romantimm25",
                        "content": "Good reads about this topic are:\\nhttps://en.wikipedia.org/wiki/Addition-chain_exponentiation\\nOptimal exponent calculations are not a simple task. So talking about this in the interview might add some value."
                    },
                    {
                        "username": "Yahan-Pranjhol-hai",
                        "content": "var myPow = function(x, n) {\\n  if (n === 0) {\\n    return 1;\\n  }\\n  \\n  if (n < 0) {\\n    return 1 / myPow(x, -n);\\n  }\\n  \\n  if (n % 2 === 0) {\\n    const y = myPow(x, n / 2);\\n    return y * y;\\n  }\\n  \\n  return x * myPow(x, n - 1);\\n};\\n// x**n"
                    },
                    {
                        "username": "juansymontano",
                        "content": "A lot of people are missing the problem. No wonder they can\\u2019t pass technical interviews. "
                    },
                    {
                        "username": "arithin",
                        "content": "Ive written a lot of code. Never have I ever needed to rewrite the POW function. And if I did you know what I\\'d do? Read up on a bunch of math before hand not memorize bs like this"
                    },
                    {
                        "username": "vanshjain499",
                        "content": "return Math.pow(x,n);"
                    },
                    {
                        "username": "juansymontano",
                        "content": "You\\u2019re supposed to implement your own. "
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases I tested my code with\n```\n2\n10\n2\n3\n2\n-2\n2\n13\n-2\n13\n2\n-13\n25\n1\n99\n0\n-99\n-99\n99\n-99\n99\n-2\n0\n10\n1\n25\n1\n0\n```"
                    },
                    {
                        "username": "vadapallichaitu",
                        "content": "something is wrong here, I keep on trying to uses recursive but it says \"name \\'myPow\\' is not defined\", I tried same logic in python playground , it works there"
                    },
                    {
                        "username": "ujwalb29",
                        "content": "x =\\n8.84372\\nn =\\n-5\\nOutput\\n0.00145\\nExpected\\n2e-05\\nWhat\\'s wrong??"
                    }
                ]
            },
            {
                "id": 1885744,
                "content": [
                    {
                        "username": "abhash_18",
                        "content": "why this is question given Medium Status? Its just a one line code.\\nAm i doing something wrong please guide me"
                    },
                    {
                        "username": "bsumner2",
                        "content": "Imagine your language doesn\\'t have a pow function built in. The challenge of the question is making your own version of it, pretending like the provided one doesn\\'t exist. If you used the built in exponent function provided by the math library of your language, then you\\'re trivializing the challenge. Ofc you can just use pow. But imagine back in the early days of programming where you had to write a pow function from scratch. Hope that helps. Happy coding :) "
                    },
                    {
                        "username": "jungle_jim",
                        "content": "This is a math problem."
                    },
                    {
                        "username": "user5029SI",
                        "content": "Lol the test cases are literally trolling\\n"
                    },
                    {
                        "username": "romantimm25",
                        "content": "Good reads about this topic are:\\nhttps://en.wikipedia.org/wiki/Addition-chain_exponentiation\\nOptimal exponent calculations are not a simple task. So talking about this in the interview might add some value."
                    },
                    {
                        "username": "Yahan-Pranjhol-hai",
                        "content": "var myPow = function(x, n) {\\n  if (n === 0) {\\n    return 1;\\n  }\\n  \\n  if (n < 0) {\\n    return 1 / myPow(x, -n);\\n  }\\n  \\n  if (n % 2 === 0) {\\n    const y = myPow(x, n / 2);\\n    return y * y;\\n  }\\n  \\n  return x * myPow(x, n - 1);\\n};\\n// x**n"
                    },
                    {
                        "username": "juansymontano",
                        "content": "A lot of people are missing the problem. No wonder they can\\u2019t pass technical interviews. "
                    },
                    {
                        "username": "arithin",
                        "content": "Ive written a lot of code. Never have I ever needed to rewrite the POW function. And if I did you know what I\\'d do? Read up on a bunch of math before hand not memorize bs like this"
                    },
                    {
                        "username": "vanshjain499",
                        "content": "return Math.pow(x,n);"
                    },
                    {
                        "username": "juansymontano",
                        "content": "You\\u2019re supposed to implement your own. "
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases I tested my code with\n```\n2\n10\n2\n3\n2\n-2\n2\n13\n-2\n13\n2\n-13\n25\n1\n99\n0\n-99\n-99\n99\n-99\n99\n-2\n0\n10\n1\n25\n1\n0\n```"
                    },
                    {
                        "username": "vadapallichaitu",
                        "content": "something is wrong here, I keep on trying to uses recursive but it says \"name \\'myPow\\' is not defined\", I tried same logic in python playground , it works there"
                    },
                    {
                        "username": "ujwalb29",
                        "content": "x =\\n8.84372\\nn =\\n-5\\nOutput\\n0.00145\\nExpected\\n2e-05\\nWhat\\'s wrong??"
                    }
                ]
            },
            {
                "id": 1874231,
                "content": [
                    {
                        "username": "mr_president",
                        "content": "why is this a medium? too easy."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "ya we have to use directly function written there \\n"
                    },
                    {
                        "username": "ashmgln",
                        "content": "I'm trying to find all the prime factors of n and then recursively trying to find the final multiplication. I'm getting 301/305 test cases passed for this approach, and the test case is timing out for \nx = 2.0000\nn = -2147483648\nHere's my multiplication logic\n\n `List<Integer> primeF = primeFactors(n);\n            if (primeF.size() == 1) {\n                return x * (multiply(x, n - 1));\n            } else {\n                double result = x;\n                for (Integer factor : primeF) {\n                    result = multiply(result, factor); \n                }\n                return result;\n            }`\n\n\nI'm finding prime factors with the following function \n `public List<Integer> primeFactors(int num) {\n        List<Integer> primeF = new ArrayList<>();\n        while(num != 1) {\n            for (int i = 2; i <= num; i++) {\n                if (num % i == 0){\n                    primeF.add(i);\n                    num = num/i;\n                    break;\n                }\n            }\n        }\n        return primeF;\n    }`"
                    },
                    {
                        "username": "yashcr7",
                        "content": "```\\npublic double myPow(double x, int n) {\\n        if(n==0) return 1;\\n        if(n==1) return x;\\n        double res = x*x;\\n        int pow = 2;\\n        while(pow*pow<n){\\n            res *= res;\\n            pow *= pow;\\n        }\\n        System.out.println(x+\" \"+n+\" \"+pow);\\n        return res*myPow(x, n-pow);\\n    }\\n```\\nStd out on run:\\n```\\n2.0 10 4\\n2.0 6 4\\n2.0 2 2\\n2.1 3 2          <----- second test case\\n2.0 -2 2\\n2.0 -4 2\\n2.0 -6 2\\n2.0 -8 2.\\n```\\nWhen I debug I get the right answer. Does anyone know whats going on here? I am not sure why I have second test case called into a single test run?"
                    },
                    {
                        "username": "juansymontano",
                        "content": "The \"edge cases\" for this is just the 1, -1, and 0, and some insanely large number to trigger overflow.\\nIt\\'s dumb because then any x and any n sufficiently large enough will trigger it and no one can pass given constraints.\\n\\nPoorly done. Needs an update."
                    },
                    {
                        "username": "trafalgar_d_law",
                        "content": "For the people experiencing stackOverFlow exception when n = Integer.MAX_VALUE, what I found out was that apparently, stackOverFlow exception occurs even when your number of recursive calls are finite, but of a large number, and there are chances that you are using a call like  `return x*myPow(x,n-1)`. Such type of code makes O(N) recursive calls, which is the cause of the exception when n is very high.\nTo avoid this, we can use O(n/2) calls and multiply the answer twice in our final answer.\nthe code is as follows:\n\n       if(n == 0) return 1;\n\n        if(n == 1)return x;\n\n        if(n == -1) return 1/x;\n\n        double half = myPow(x, n/2);\n\n        double rest = myPow(x, n%2);\n\n        return half*half*rest;\n\nsuch type of a code reduces the number of recursive calls to n/2 instead of n, and we are multiplying the returned value (here, `half`), twice to make up for making half of the required number of calls."
                    },
                    {
                        "username": "JigarRajput",
                        "content": "leetcode walo apne stack ka size badhao \nwith the help of -Xss4m"
                    },
                    {
                        "username": "Shivam_Sikotra",
                        "content": "Just an implementation of Fast Exponential Algorithm!!\nDon't feel bad if you can't solve by own and be happy that by help of this question you get to learn new Algorithm. "
                    },
                    {
                        "username": "Wa1kingR3d",
                        "content": "man that was hard to return one line of code im going to figure out how to make it faster"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "I guess there is an issue, with this question. The test case didn\\'t pass for INT_MIN, but when I created a custom one with n ==INT_MIN-1 it got passes, I guess the range of n which is INT_MIN must be exclusive but they gave it wrongly."
                    },
                    {
                        "username": "wagadregagan",
                        "content": "class Solution {\\n    public double myPow(double x, int n) {\\n        \\n        if(n < 0){\\n            n = -n;\\n            x = 1 / x;\\n        }\\n        \\n        double pow = 1;\\n        \\n        while(n != 0){\\n            if((n & 1) != 0){\\n                pow *= x;\\n            } \\n                \\n            x *= x;\\n            n >>>= 1;\\n            \\n        }\\n        \\n        return pow;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1873059,
                "content": [
                    {
                        "username": "mr_president",
                        "content": "why is this a medium? too easy."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "ya we have to use directly function written there \\n"
                    },
                    {
                        "username": "ashmgln",
                        "content": "I'm trying to find all the prime factors of n and then recursively trying to find the final multiplication. I'm getting 301/305 test cases passed for this approach, and the test case is timing out for \nx = 2.0000\nn = -2147483648\nHere's my multiplication logic\n\n `List<Integer> primeF = primeFactors(n);\n            if (primeF.size() == 1) {\n                return x * (multiply(x, n - 1));\n            } else {\n                double result = x;\n                for (Integer factor : primeF) {\n                    result = multiply(result, factor); \n                }\n                return result;\n            }`\n\n\nI'm finding prime factors with the following function \n `public List<Integer> primeFactors(int num) {\n        List<Integer> primeF = new ArrayList<>();\n        while(num != 1) {\n            for (int i = 2; i <= num; i++) {\n                if (num % i == 0){\n                    primeF.add(i);\n                    num = num/i;\n                    break;\n                }\n            }\n        }\n        return primeF;\n    }`"
                    },
                    {
                        "username": "yashcr7",
                        "content": "```\\npublic double myPow(double x, int n) {\\n        if(n==0) return 1;\\n        if(n==1) return x;\\n        double res = x*x;\\n        int pow = 2;\\n        while(pow*pow<n){\\n            res *= res;\\n            pow *= pow;\\n        }\\n        System.out.println(x+\" \"+n+\" \"+pow);\\n        return res*myPow(x, n-pow);\\n    }\\n```\\nStd out on run:\\n```\\n2.0 10 4\\n2.0 6 4\\n2.0 2 2\\n2.1 3 2          <----- second test case\\n2.0 -2 2\\n2.0 -4 2\\n2.0 -6 2\\n2.0 -8 2.\\n```\\nWhen I debug I get the right answer. Does anyone know whats going on here? I am not sure why I have second test case called into a single test run?"
                    },
                    {
                        "username": "juansymontano",
                        "content": "The \"edge cases\" for this is just the 1, -1, and 0, and some insanely large number to trigger overflow.\\nIt\\'s dumb because then any x and any n sufficiently large enough will trigger it and no one can pass given constraints.\\n\\nPoorly done. Needs an update."
                    },
                    {
                        "username": "trafalgar_d_law",
                        "content": "For the people experiencing stackOverFlow exception when n = Integer.MAX_VALUE, what I found out was that apparently, stackOverFlow exception occurs even when your number of recursive calls are finite, but of a large number, and there are chances that you are using a call like  `return x*myPow(x,n-1)`. Such type of code makes O(N) recursive calls, which is the cause of the exception when n is very high.\nTo avoid this, we can use O(n/2) calls and multiply the answer twice in our final answer.\nthe code is as follows:\n\n       if(n == 0) return 1;\n\n        if(n == 1)return x;\n\n        if(n == -1) return 1/x;\n\n        double half = myPow(x, n/2);\n\n        double rest = myPow(x, n%2);\n\n        return half*half*rest;\n\nsuch type of a code reduces the number of recursive calls to n/2 instead of n, and we are multiplying the returned value (here, `half`), twice to make up for making half of the required number of calls."
                    },
                    {
                        "username": "JigarRajput",
                        "content": "leetcode walo apne stack ka size badhao \nwith the help of -Xss4m"
                    },
                    {
                        "username": "Shivam_Sikotra",
                        "content": "Just an implementation of Fast Exponential Algorithm!!\nDon't feel bad if you can't solve by own and be happy that by help of this question you get to learn new Algorithm. "
                    },
                    {
                        "username": "Wa1kingR3d",
                        "content": "man that was hard to return one line of code im going to figure out how to make it faster"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "I guess there is an issue, with this question. The test case didn\\'t pass for INT_MIN, but when I created a custom one with n ==INT_MIN-1 it got passes, I guess the range of n which is INT_MIN must be exclusive but they gave it wrongly."
                    },
                    {
                        "username": "wagadregagan",
                        "content": "class Solution {\\n    public double myPow(double x, int n) {\\n        \\n        if(n < 0){\\n            n = -n;\\n            x = 1 / x;\\n        }\\n        \\n        double pow = 1;\\n        \\n        while(n != 0){\\n            if((n & 1) != 0){\\n                pow *= x;\\n            } \\n                \\n            x *= x;\\n            n >>>= 1;\\n            \\n        }\\n        \\n        return pow;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1872714,
                "content": [
                    {
                        "username": "mr_president",
                        "content": "why is this a medium? too easy."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "ya we have to use directly function written there \\n"
                    },
                    {
                        "username": "ashmgln",
                        "content": "I'm trying to find all the prime factors of n and then recursively trying to find the final multiplication. I'm getting 301/305 test cases passed for this approach, and the test case is timing out for \nx = 2.0000\nn = -2147483648\nHere's my multiplication logic\n\n `List<Integer> primeF = primeFactors(n);\n            if (primeF.size() == 1) {\n                return x * (multiply(x, n - 1));\n            } else {\n                double result = x;\n                for (Integer factor : primeF) {\n                    result = multiply(result, factor); \n                }\n                return result;\n            }`\n\n\nI'm finding prime factors with the following function \n `public List<Integer> primeFactors(int num) {\n        List<Integer> primeF = new ArrayList<>();\n        while(num != 1) {\n            for (int i = 2; i <= num; i++) {\n                if (num % i == 0){\n                    primeF.add(i);\n                    num = num/i;\n                    break;\n                }\n            }\n        }\n        return primeF;\n    }`"
                    },
                    {
                        "username": "yashcr7",
                        "content": "```\\npublic double myPow(double x, int n) {\\n        if(n==0) return 1;\\n        if(n==1) return x;\\n        double res = x*x;\\n        int pow = 2;\\n        while(pow*pow<n){\\n            res *= res;\\n            pow *= pow;\\n        }\\n        System.out.println(x+\" \"+n+\" \"+pow);\\n        return res*myPow(x, n-pow);\\n    }\\n```\\nStd out on run:\\n```\\n2.0 10 4\\n2.0 6 4\\n2.0 2 2\\n2.1 3 2          <----- second test case\\n2.0 -2 2\\n2.0 -4 2\\n2.0 -6 2\\n2.0 -8 2.\\n```\\nWhen I debug I get the right answer. Does anyone know whats going on here? I am not sure why I have second test case called into a single test run?"
                    },
                    {
                        "username": "juansymontano",
                        "content": "The \"edge cases\" for this is just the 1, -1, and 0, and some insanely large number to trigger overflow.\\nIt\\'s dumb because then any x and any n sufficiently large enough will trigger it and no one can pass given constraints.\\n\\nPoorly done. Needs an update."
                    },
                    {
                        "username": "trafalgar_d_law",
                        "content": "For the people experiencing stackOverFlow exception when n = Integer.MAX_VALUE, what I found out was that apparently, stackOverFlow exception occurs even when your number of recursive calls are finite, but of a large number, and there are chances that you are using a call like  `return x*myPow(x,n-1)`. Such type of code makes O(N) recursive calls, which is the cause of the exception when n is very high.\nTo avoid this, we can use O(n/2) calls and multiply the answer twice in our final answer.\nthe code is as follows:\n\n       if(n == 0) return 1;\n\n        if(n == 1)return x;\n\n        if(n == -1) return 1/x;\n\n        double half = myPow(x, n/2);\n\n        double rest = myPow(x, n%2);\n\n        return half*half*rest;\n\nsuch type of a code reduces the number of recursive calls to n/2 instead of n, and we are multiplying the returned value (here, `half`), twice to make up for making half of the required number of calls."
                    },
                    {
                        "username": "JigarRajput",
                        "content": "leetcode walo apne stack ka size badhao \nwith the help of -Xss4m"
                    },
                    {
                        "username": "Shivam_Sikotra",
                        "content": "Just an implementation of Fast Exponential Algorithm!!\nDon't feel bad if you can't solve by own and be happy that by help of this question you get to learn new Algorithm. "
                    },
                    {
                        "username": "Wa1kingR3d",
                        "content": "man that was hard to return one line of code im going to figure out how to make it faster"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "I guess there is an issue, with this question. The test case didn\\'t pass for INT_MIN, but when I created a custom one with n ==INT_MIN-1 it got passes, I guess the range of n which is INT_MIN must be exclusive but they gave it wrongly."
                    },
                    {
                        "username": "wagadregagan",
                        "content": "class Solution {\\n    public double myPow(double x, int n) {\\n        \\n        if(n < 0){\\n            n = -n;\\n            x = 1 / x;\\n        }\\n        \\n        double pow = 1;\\n        \\n        while(n != 0){\\n            if((n & 1) != 0){\\n                pow *= x;\\n            } \\n                \\n            x *= x;\\n            n >>>= 1;\\n            \\n        }\\n        \\n        return pow;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1868269,
                "content": [
                    {
                        "username": "mr_president",
                        "content": "why is this a medium? too easy."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "ya we have to use directly function written there \\n"
                    },
                    {
                        "username": "ashmgln",
                        "content": "I'm trying to find all the prime factors of n and then recursively trying to find the final multiplication. I'm getting 301/305 test cases passed for this approach, and the test case is timing out for \nx = 2.0000\nn = -2147483648\nHere's my multiplication logic\n\n `List<Integer> primeF = primeFactors(n);\n            if (primeF.size() == 1) {\n                return x * (multiply(x, n - 1));\n            } else {\n                double result = x;\n                for (Integer factor : primeF) {\n                    result = multiply(result, factor); \n                }\n                return result;\n            }`\n\n\nI'm finding prime factors with the following function \n `public List<Integer> primeFactors(int num) {\n        List<Integer> primeF = new ArrayList<>();\n        while(num != 1) {\n            for (int i = 2; i <= num; i++) {\n                if (num % i == 0){\n                    primeF.add(i);\n                    num = num/i;\n                    break;\n                }\n            }\n        }\n        return primeF;\n    }`"
                    },
                    {
                        "username": "yashcr7",
                        "content": "```\\npublic double myPow(double x, int n) {\\n        if(n==0) return 1;\\n        if(n==1) return x;\\n        double res = x*x;\\n        int pow = 2;\\n        while(pow*pow<n){\\n            res *= res;\\n            pow *= pow;\\n        }\\n        System.out.println(x+\" \"+n+\" \"+pow);\\n        return res*myPow(x, n-pow);\\n    }\\n```\\nStd out on run:\\n```\\n2.0 10 4\\n2.0 6 4\\n2.0 2 2\\n2.1 3 2          <----- second test case\\n2.0 -2 2\\n2.0 -4 2\\n2.0 -6 2\\n2.0 -8 2.\\n```\\nWhen I debug I get the right answer. Does anyone know whats going on here? I am not sure why I have second test case called into a single test run?"
                    },
                    {
                        "username": "juansymontano",
                        "content": "The \"edge cases\" for this is just the 1, -1, and 0, and some insanely large number to trigger overflow.\\nIt\\'s dumb because then any x and any n sufficiently large enough will trigger it and no one can pass given constraints.\\n\\nPoorly done. Needs an update."
                    },
                    {
                        "username": "trafalgar_d_law",
                        "content": "For the people experiencing stackOverFlow exception when n = Integer.MAX_VALUE, what I found out was that apparently, stackOverFlow exception occurs even when your number of recursive calls are finite, but of a large number, and there are chances that you are using a call like  `return x*myPow(x,n-1)`. Such type of code makes O(N) recursive calls, which is the cause of the exception when n is very high.\nTo avoid this, we can use O(n/2) calls and multiply the answer twice in our final answer.\nthe code is as follows:\n\n       if(n == 0) return 1;\n\n        if(n == 1)return x;\n\n        if(n == -1) return 1/x;\n\n        double half = myPow(x, n/2);\n\n        double rest = myPow(x, n%2);\n\n        return half*half*rest;\n\nsuch type of a code reduces the number of recursive calls to n/2 instead of n, and we are multiplying the returned value (here, `half`), twice to make up for making half of the required number of calls."
                    },
                    {
                        "username": "JigarRajput",
                        "content": "leetcode walo apne stack ka size badhao \nwith the help of -Xss4m"
                    },
                    {
                        "username": "Shivam_Sikotra",
                        "content": "Just an implementation of Fast Exponential Algorithm!!\nDon't feel bad if you can't solve by own and be happy that by help of this question you get to learn new Algorithm. "
                    },
                    {
                        "username": "Wa1kingR3d",
                        "content": "man that was hard to return one line of code im going to figure out how to make it faster"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "I guess there is an issue, with this question. The test case didn\\'t pass for INT_MIN, but when I created a custom one with n ==INT_MIN-1 it got passes, I guess the range of n which is INT_MIN must be exclusive but they gave it wrongly."
                    },
                    {
                        "username": "wagadregagan",
                        "content": "class Solution {\\n    public double myPow(double x, int n) {\\n        \\n        if(n < 0){\\n            n = -n;\\n            x = 1 / x;\\n        }\\n        \\n        double pow = 1;\\n        \\n        while(n != 0){\\n            if((n & 1) != 0){\\n                pow *= x;\\n            } \\n                \\n            x *= x;\\n            n >>>= 1;\\n            \\n        }\\n        \\n        return pow;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1868176,
                "content": [
                    {
                        "username": "mr_president",
                        "content": "why is this a medium? too easy."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "ya we have to use directly function written there \\n"
                    },
                    {
                        "username": "ashmgln",
                        "content": "I'm trying to find all the prime factors of n and then recursively trying to find the final multiplication. I'm getting 301/305 test cases passed for this approach, and the test case is timing out for \nx = 2.0000\nn = -2147483648\nHere's my multiplication logic\n\n `List<Integer> primeF = primeFactors(n);\n            if (primeF.size() == 1) {\n                return x * (multiply(x, n - 1));\n            } else {\n                double result = x;\n                for (Integer factor : primeF) {\n                    result = multiply(result, factor); \n                }\n                return result;\n            }`\n\n\nI'm finding prime factors with the following function \n `public List<Integer> primeFactors(int num) {\n        List<Integer> primeF = new ArrayList<>();\n        while(num != 1) {\n            for (int i = 2; i <= num; i++) {\n                if (num % i == 0){\n                    primeF.add(i);\n                    num = num/i;\n                    break;\n                }\n            }\n        }\n        return primeF;\n    }`"
                    },
                    {
                        "username": "yashcr7",
                        "content": "```\\npublic double myPow(double x, int n) {\\n        if(n==0) return 1;\\n        if(n==1) return x;\\n        double res = x*x;\\n        int pow = 2;\\n        while(pow*pow<n){\\n            res *= res;\\n            pow *= pow;\\n        }\\n        System.out.println(x+\" \"+n+\" \"+pow);\\n        return res*myPow(x, n-pow);\\n    }\\n```\\nStd out on run:\\n```\\n2.0 10 4\\n2.0 6 4\\n2.0 2 2\\n2.1 3 2          <----- second test case\\n2.0 -2 2\\n2.0 -4 2\\n2.0 -6 2\\n2.0 -8 2.\\n```\\nWhen I debug I get the right answer. Does anyone know whats going on here? I am not sure why I have second test case called into a single test run?"
                    },
                    {
                        "username": "juansymontano",
                        "content": "The \"edge cases\" for this is just the 1, -1, and 0, and some insanely large number to trigger overflow.\\nIt\\'s dumb because then any x and any n sufficiently large enough will trigger it and no one can pass given constraints.\\n\\nPoorly done. Needs an update."
                    },
                    {
                        "username": "trafalgar_d_law",
                        "content": "For the people experiencing stackOverFlow exception when n = Integer.MAX_VALUE, what I found out was that apparently, stackOverFlow exception occurs even when your number of recursive calls are finite, but of a large number, and there are chances that you are using a call like  `return x*myPow(x,n-1)`. Such type of code makes O(N) recursive calls, which is the cause of the exception when n is very high.\nTo avoid this, we can use O(n/2) calls and multiply the answer twice in our final answer.\nthe code is as follows:\n\n       if(n == 0) return 1;\n\n        if(n == 1)return x;\n\n        if(n == -1) return 1/x;\n\n        double half = myPow(x, n/2);\n\n        double rest = myPow(x, n%2);\n\n        return half*half*rest;\n\nsuch type of a code reduces the number of recursive calls to n/2 instead of n, and we are multiplying the returned value (here, `half`), twice to make up for making half of the required number of calls."
                    },
                    {
                        "username": "JigarRajput",
                        "content": "leetcode walo apne stack ka size badhao \nwith the help of -Xss4m"
                    },
                    {
                        "username": "Shivam_Sikotra",
                        "content": "Just an implementation of Fast Exponential Algorithm!!\nDon't feel bad if you can't solve by own and be happy that by help of this question you get to learn new Algorithm. "
                    },
                    {
                        "username": "Wa1kingR3d",
                        "content": "man that was hard to return one line of code im going to figure out how to make it faster"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "I guess there is an issue, with this question. The test case didn\\'t pass for INT_MIN, but when I created a custom one with n ==INT_MIN-1 it got passes, I guess the range of n which is INT_MIN must be exclusive but they gave it wrongly."
                    },
                    {
                        "username": "wagadregagan",
                        "content": "class Solution {\\n    public double myPow(double x, int n) {\\n        \\n        if(n < 0){\\n            n = -n;\\n            x = 1 / x;\\n        }\\n        \\n        double pow = 1;\\n        \\n        while(n != 0){\\n            if((n & 1) != 0){\\n                pow *= x;\\n            } \\n                \\n            x *= x;\\n            n >>>= 1;\\n            \\n        }\\n        \\n        return pow;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1857421,
                "content": [
                    {
                        "username": "mr_president",
                        "content": "why is this a medium? too easy."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "ya we have to use directly function written there \\n"
                    },
                    {
                        "username": "ashmgln",
                        "content": "I'm trying to find all the prime factors of n and then recursively trying to find the final multiplication. I'm getting 301/305 test cases passed for this approach, and the test case is timing out for \nx = 2.0000\nn = -2147483648\nHere's my multiplication logic\n\n `List<Integer> primeF = primeFactors(n);\n            if (primeF.size() == 1) {\n                return x * (multiply(x, n - 1));\n            } else {\n                double result = x;\n                for (Integer factor : primeF) {\n                    result = multiply(result, factor); \n                }\n                return result;\n            }`\n\n\nI'm finding prime factors with the following function \n `public List<Integer> primeFactors(int num) {\n        List<Integer> primeF = new ArrayList<>();\n        while(num != 1) {\n            for (int i = 2; i <= num; i++) {\n                if (num % i == 0){\n                    primeF.add(i);\n                    num = num/i;\n                    break;\n                }\n            }\n        }\n        return primeF;\n    }`"
                    },
                    {
                        "username": "yashcr7",
                        "content": "```\\npublic double myPow(double x, int n) {\\n        if(n==0) return 1;\\n        if(n==1) return x;\\n        double res = x*x;\\n        int pow = 2;\\n        while(pow*pow<n){\\n            res *= res;\\n            pow *= pow;\\n        }\\n        System.out.println(x+\" \"+n+\" \"+pow);\\n        return res*myPow(x, n-pow);\\n    }\\n```\\nStd out on run:\\n```\\n2.0 10 4\\n2.0 6 4\\n2.0 2 2\\n2.1 3 2          <----- second test case\\n2.0 -2 2\\n2.0 -4 2\\n2.0 -6 2\\n2.0 -8 2.\\n```\\nWhen I debug I get the right answer. Does anyone know whats going on here? I am not sure why I have second test case called into a single test run?"
                    },
                    {
                        "username": "juansymontano",
                        "content": "The \"edge cases\" for this is just the 1, -1, and 0, and some insanely large number to trigger overflow.\\nIt\\'s dumb because then any x and any n sufficiently large enough will trigger it and no one can pass given constraints.\\n\\nPoorly done. Needs an update."
                    },
                    {
                        "username": "trafalgar_d_law",
                        "content": "For the people experiencing stackOverFlow exception when n = Integer.MAX_VALUE, what I found out was that apparently, stackOverFlow exception occurs even when your number of recursive calls are finite, but of a large number, and there are chances that you are using a call like  `return x*myPow(x,n-1)`. Such type of code makes O(N) recursive calls, which is the cause of the exception when n is very high.\nTo avoid this, we can use O(n/2) calls and multiply the answer twice in our final answer.\nthe code is as follows:\n\n       if(n == 0) return 1;\n\n        if(n == 1)return x;\n\n        if(n == -1) return 1/x;\n\n        double half = myPow(x, n/2);\n\n        double rest = myPow(x, n%2);\n\n        return half*half*rest;\n\nsuch type of a code reduces the number of recursive calls to n/2 instead of n, and we are multiplying the returned value (here, `half`), twice to make up for making half of the required number of calls."
                    },
                    {
                        "username": "JigarRajput",
                        "content": "leetcode walo apne stack ka size badhao \nwith the help of -Xss4m"
                    },
                    {
                        "username": "Shivam_Sikotra",
                        "content": "Just an implementation of Fast Exponential Algorithm!!\nDon't feel bad if you can't solve by own and be happy that by help of this question you get to learn new Algorithm. "
                    },
                    {
                        "username": "Wa1kingR3d",
                        "content": "man that was hard to return one line of code im going to figure out how to make it faster"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "I guess there is an issue, with this question. The test case didn\\'t pass for INT_MIN, but when I created a custom one with n ==INT_MIN-1 it got passes, I guess the range of n which is INT_MIN must be exclusive but they gave it wrongly."
                    },
                    {
                        "username": "wagadregagan",
                        "content": "class Solution {\\n    public double myPow(double x, int n) {\\n        \\n        if(n < 0){\\n            n = -n;\\n            x = 1 / x;\\n        }\\n        \\n        double pow = 1;\\n        \\n        while(n != 0){\\n            if((n & 1) != 0){\\n                pow *= x;\\n            } \\n                \\n            x *= x;\\n            n >>>= 1;\\n            \\n        }\\n        \\n        return pow;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1852306,
                "content": [
                    {
                        "username": "mr_president",
                        "content": "why is this a medium? too easy."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "ya we have to use directly function written there \\n"
                    },
                    {
                        "username": "ashmgln",
                        "content": "I'm trying to find all the prime factors of n and then recursively trying to find the final multiplication. I'm getting 301/305 test cases passed for this approach, and the test case is timing out for \nx = 2.0000\nn = -2147483648\nHere's my multiplication logic\n\n `List<Integer> primeF = primeFactors(n);\n            if (primeF.size() == 1) {\n                return x * (multiply(x, n - 1));\n            } else {\n                double result = x;\n                for (Integer factor : primeF) {\n                    result = multiply(result, factor); \n                }\n                return result;\n            }`\n\n\nI'm finding prime factors with the following function \n `public List<Integer> primeFactors(int num) {\n        List<Integer> primeF = new ArrayList<>();\n        while(num != 1) {\n            for (int i = 2; i <= num; i++) {\n                if (num % i == 0){\n                    primeF.add(i);\n                    num = num/i;\n                    break;\n                }\n            }\n        }\n        return primeF;\n    }`"
                    },
                    {
                        "username": "yashcr7",
                        "content": "```\\npublic double myPow(double x, int n) {\\n        if(n==0) return 1;\\n        if(n==1) return x;\\n        double res = x*x;\\n        int pow = 2;\\n        while(pow*pow<n){\\n            res *= res;\\n            pow *= pow;\\n        }\\n        System.out.println(x+\" \"+n+\" \"+pow);\\n        return res*myPow(x, n-pow);\\n    }\\n```\\nStd out on run:\\n```\\n2.0 10 4\\n2.0 6 4\\n2.0 2 2\\n2.1 3 2          <----- second test case\\n2.0 -2 2\\n2.0 -4 2\\n2.0 -6 2\\n2.0 -8 2.\\n```\\nWhen I debug I get the right answer. Does anyone know whats going on here? I am not sure why I have second test case called into a single test run?"
                    },
                    {
                        "username": "juansymontano",
                        "content": "The \"edge cases\" for this is just the 1, -1, and 0, and some insanely large number to trigger overflow.\\nIt\\'s dumb because then any x and any n sufficiently large enough will trigger it and no one can pass given constraints.\\n\\nPoorly done. Needs an update."
                    },
                    {
                        "username": "trafalgar_d_law",
                        "content": "For the people experiencing stackOverFlow exception when n = Integer.MAX_VALUE, what I found out was that apparently, stackOverFlow exception occurs even when your number of recursive calls are finite, but of a large number, and there are chances that you are using a call like  `return x*myPow(x,n-1)`. Such type of code makes O(N) recursive calls, which is the cause of the exception when n is very high.\nTo avoid this, we can use O(n/2) calls and multiply the answer twice in our final answer.\nthe code is as follows:\n\n       if(n == 0) return 1;\n\n        if(n == 1)return x;\n\n        if(n == -1) return 1/x;\n\n        double half = myPow(x, n/2);\n\n        double rest = myPow(x, n%2);\n\n        return half*half*rest;\n\nsuch type of a code reduces the number of recursive calls to n/2 instead of n, and we are multiplying the returned value (here, `half`), twice to make up for making half of the required number of calls."
                    },
                    {
                        "username": "JigarRajput",
                        "content": "leetcode walo apne stack ka size badhao \nwith the help of -Xss4m"
                    },
                    {
                        "username": "Shivam_Sikotra",
                        "content": "Just an implementation of Fast Exponential Algorithm!!\nDon't feel bad if you can't solve by own and be happy that by help of this question you get to learn new Algorithm. "
                    },
                    {
                        "username": "Wa1kingR3d",
                        "content": "man that was hard to return one line of code im going to figure out how to make it faster"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "I guess there is an issue, with this question. The test case didn\\'t pass for INT_MIN, but when I created a custom one with n ==INT_MIN-1 it got passes, I guess the range of n which is INT_MIN must be exclusive but they gave it wrongly."
                    },
                    {
                        "username": "wagadregagan",
                        "content": "class Solution {\\n    public double myPow(double x, int n) {\\n        \\n        if(n < 0){\\n            n = -n;\\n            x = 1 / x;\\n        }\\n        \\n        double pow = 1;\\n        \\n        while(n != 0){\\n            if((n & 1) != 0){\\n                pow *= x;\\n            } \\n                \\n            x *= x;\\n            n >>>= 1;\\n            \\n        }\\n        \\n        return pow;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1847026,
                "content": [
                    {
                        "username": "mr_president",
                        "content": "why is this a medium? too easy."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "ya we have to use directly function written there \\n"
                    },
                    {
                        "username": "ashmgln",
                        "content": "I'm trying to find all the prime factors of n and then recursively trying to find the final multiplication. I'm getting 301/305 test cases passed for this approach, and the test case is timing out for \nx = 2.0000\nn = -2147483648\nHere's my multiplication logic\n\n `List<Integer> primeF = primeFactors(n);\n            if (primeF.size() == 1) {\n                return x * (multiply(x, n - 1));\n            } else {\n                double result = x;\n                for (Integer factor : primeF) {\n                    result = multiply(result, factor); \n                }\n                return result;\n            }`\n\n\nI'm finding prime factors with the following function \n `public List<Integer> primeFactors(int num) {\n        List<Integer> primeF = new ArrayList<>();\n        while(num != 1) {\n            for (int i = 2; i <= num; i++) {\n                if (num % i == 0){\n                    primeF.add(i);\n                    num = num/i;\n                    break;\n                }\n            }\n        }\n        return primeF;\n    }`"
                    },
                    {
                        "username": "yashcr7",
                        "content": "```\\npublic double myPow(double x, int n) {\\n        if(n==0) return 1;\\n        if(n==1) return x;\\n        double res = x*x;\\n        int pow = 2;\\n        while(pow*pow<n){\\n            res *= res;\\n            pow *= pow;\\n        }\\n        System.out.println(x+\" \"+n+\" \"+pow);\\n        return res*myPow(x, n-pow);\\n    }\\n```\\nStd out on run:\\n```\\n2.0 10 4\\n2.0 6 4\\n2.0 2 2\\n2.1 3 2          <----- second test case\\n2.0 -2 2\\n2.0 -4 2\\n2.0 -6 2\\n2.0 -8 2.\\n```\\nWhen I debug I get the right answer. Does anyone know whats going on here? I am not sure why I have second test case called into a single test run?"
                    },
                    {
                        "username": "juansymontano",
                        "content": "The \"edge cases\" for this is just the 1, -1, and 0, and some insanely large number to trigger overflow.\\nIt\\'s dumb because then any x and any n sufficiently large enough will trigger it and no one can pass given constraints.\\n\\nPoorly done. Needs an update."
                    },
                    {
                        "username": "trafalgar_d_law",
                        "content": "For the people experiencing stackOverFlow exception when n = Integer.MAX_VALUE, what I found out was that apparently, stackOverFlow exception occurs even when your number of recursive calls are finite, but of a large number, and there are chances that you are using a call like  `return x*myPow(x,n-1)`. Such type of code makes O(N) recursive calls, which is the cause of the exception when n is very high.\nTo avoid this, we can use O(n/2) calls and multiply the answer twice in our final answer.\nthe code is as follows:\n\n       if(n == 0) return 1;\n\n        if(n == 1)return x;\n\n        if(n == -1) return 1/x;\n\n        double half = myPow(x, n/2);\n\n        double rest = myPow(x, n%2);\n\n        return half*half*rest;\n\nsuch type of a code reduces the number of recursive calls to n/2 instead of n, and we are multiplying the returned value (here, `half`), twice to make up for making half of the required number of calls."
                    },
                    {
                        "username": "JigarRajput",
                        "content": "leetcode walo apne stack ka size badhao \nwith the help of -Xss4m"
                    },
                    {
                        "username": "Shivam_Sikotra",
                        "content": "Just an implementation of Fast Exponential Algorithm!!\nDon't feel bad if you can't solve by own and be happy that by help of this question you get to learn new Algorithm. "
                    },
                    {
                        "username": "Wa1kingR3d",
                        "content": "man that was hard to return one line of code im going to figure out how to make it faster"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "I guess there is an issue, with this question. The test case didn\\'t pass for INT_MIN, but when I created a custom one with n ==INT_MIN-1 it got passes, I guess the range of n which is INT_MIN must be exclusive but they gave it wrongly."
                    },
                    {
                        "username": "wagadregagan",
                        "content": "class Solution {\\n    public double myPow(double x, int n) {\\n        \\n        if(n < 0){\\n            n = -n;\\n            x = 1 / x;\\n        }\\n        \\n        double pow = 1;\\n        \\n        while(n != 0){\\n            if((n & 1) != 0){\\n                pow *= x;\\n            } \\n                \\n            x *= x;\\n            n >>>= 1;\\n            \\n        }\\n        \\n        return pow;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1837901,
                "content": [
                    {
                        "username": "mr_president",
                        "content": "why is this a medium? too easy."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "ya we have to use directly function written there \\n"
                    },
                    {
                        "username": "ashmgln",
                        "content": "I'm trying to find all the prime factors of n and then recursively trying to find the final multiplication. I'm getting 301/305 test cases passed for this approach, and the test case is timing out for \nx = 2.0000\nn = -2147483648\nHere's my multiplication logic\n\n `List<Integer> primeF = primeFactors(n);\n            if (primeF.size() == 1) {\n                return x * (multiply(x, n - 1));\n            } else {\n                double result = x;\n                for (Integer factor : primeF) {\n                    result = multiply(result, factor); \n                }\n                return result;\n            }`\n\n\nI'm finding prime factors with the following function \n `public List<Integer> primeFactors(int num) {\n        List<Integer> primeF = new ArrayList<>();\n        while(num != 1) {\n            for (int i = 2; i <= num; i++) {\n                if (num % i == 0){\n                    primeF.add(i);\n                    num = num/i;\n                    break;\n                }\n            }\n        }\n        return primeF;\n    }`"
                    },
                    {
                        "username": "yashcr7",
                        "content": "```\\npublic double myPow(double x, int n) {\\n        if(n==0) return 1;\\n        if(n==1) return x;\\n        double res = x*x;\\n        int pow = 2;\\n        while(pow*pow<n){\\n            res *= res;\\n            pow *= pow;\\n        }\\n        System.out.println(x+\" \"+n+\" \"+pow);\\n        return res*myPow(x, n-pow);\\n    }\\n```\\nStd out on run:\\n```\\n2.0 10 4\\n2.0 6 4\\n2.0 2 2\\n2.1 3 2          <----- second test case\\n2.0 -2 2\\n2.0 -4 2\\n2.0 -6 2\\n2.0 -8 2.\\n```\\nWhen I debug I get the right answer. Does anyone know whats going on here? I am not sure why I have second test case called into a single test run?"
                    },
                    {
                        "username": "juansymontano",
                        "content": "The \"edge cases\" for this is just the 1, -1, and 0, and some insanely large number to trigger overflow.\\nIt\\'s dumb because then any x and any n sufficiently large enough will trigger it and no one can pass given constraints.\\n\\nPoorly done. Needs an update."
                    },
                    {
                        "username": "trafalgar_d_law",
                        "content": "For the people experiencing stackOverFlow exception when n = Integer.MAX_VALUE, what I found out was that apparently, stackOverFlow exception occurs even when your number of recursive calls are finite, but of a large number, and there are chances that you are using a call like  `return x*myPow(x,n-1)`. Such type of code makes O(N) recursive calls, which is the cause of the exception when n is very high.\nTo avoid this, we can use O(n/2) calls and multiply the answer twice in our final answer.\nthe code is as follows:\n\n       if(n == 0) return 1;\n\n        if(n == 1)return x;\n\n        if(n == -1) return 1/x;\n\n        double half = myPow(x, n/2);\n\n        double rest = myPow(x, n%2);\n\n        return half*half*rest;\n\nsuch type of a code reduces the number of recursive calls to n/2 instead of n, and we are multiplying the returned value (here, `half`), twice to make up for making half of the required number of calls."
                    },
                    {
                        "username": "JigarRajput",
                        "content": "leetcode walo apne stack ka size badhao \nwith the help of -Xss4m"
                    },
                    {
                        "username": "Shivam_Sikotra",
                        "content": "Just an implementation of Fast Exponential Algorithm!!\nDon't feel bad if you can't solve by own and be happy that by help of this question you get to learn new Algorithm. "
                    },
                    {
                        "username": "Wa1kingR3d",
                        "content": "man that was hard to return one line of code im going to figure out how to make it faster"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "I guess there is an issue, with this question. The test case didn\\'t pass for INT_MIN, but when I created a custom one with n ==INT_MIN-1 it got passes, I guess the range of n which is INT_MIN must be exclusive but they gave it wrongly."
                    },
                    {
                        "username": "wagadregagan",
                        "content": "class Solution {\\n    public double myPow(double x, int n) {\\n        \\n        if(n < 0){\\n            n = -n;\\n            x = 1 / x;\\n        }\\n        \\n        double pow = 1;\\n        \\n        while(n != 0){\\n            if((n & 1) != 0){\\n                pow *= x;\\n            } \\n                \\n            x *= x;\\n            n >>>= 1;\\n            \\n        }\\n        \\n        return pow;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1824241,
                "content": [
                    {
                        "username": "mr_president",
                        "content": "why is this a medium? too easy."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "ya we have to use directly function written there \\n"
                    },
                    {
                        "username": "ashmgln",
                        "content": "I'm trying to find all the prime factors of n and then recursively trying to find the final multiplication. I'm getting 301/305 test cases passed for this approach, and the test case is timing out for \nx = 2.0000\nn = -2147483648\nHere's my multiplication logic\n\n `List<Integer> primeF = primeFactors(n);\n            if (primeF.size() == 1) {\n                return x * (multiply(x, n - 1));\n            } else {\n                double result = x;\n                for (Integer factor : primeF) {\n                    result = multiply(result, factor); \n                }\n                return result;\n            }`\n\n\nI'm finding prime factors with the following function \n `public List<Integer> primeFactors(int num) {\n        List<Integer> primeF = new ArrayList<>();\n        while(num != 1) {\n            for (int i = 2; i <= num; i++) {\n                if (num % i == 0){\n                    primeF.add(i);\n                    num = num/i;\n                    break;\n                }\n            }\n        }\n        return primeF;\n    }`"
                    },
                    {
                        "username": "yashcr7",
                        "content": "```\\npublic double myPow(double x, int n) {\\n        if(n==0) return 1;\\n        if(n==1) return x;\\n        double res = x*x;\\n        int pow = 2;\\n        while(pow*pow<n){\\n            res *= res;\\n            pow *= pow;\\n        }\\n        System.out.println(x+\" \"+n+\" \"+pow);\\n        return res*myPow(x, n-pow);\\n    }\\n```\\nStd out on run:\\n```\\n2.0 10 4\\n2.0 6 4\\n2.0 2 2\\n2.1 3 2          <----- second test case\\n2.0 -2 2\\n2.0 -4 2\\n2.0 -6 2\\n2.0 -8 2.\\n```\\nWhen I debug I get the right answer. Does anyone know whats going on here? I am not sure why I have second test case called into a single test run?"
                    },
                    {
                        "username": "juansymontano",
                        "content": "The \"edge cases\" for this is just the 1, -1, and 0, and some insanely large number to trigger overflow.\\nIt\\'s dumb because then any x and any n sufficiently large enough will trigger it and no one can pass given constraints.\\n\\nPoorly done. Needs an update."
                    },
                    {
                        "username": "trafalgar_d_law",
                        "content": "For the people experiencing stackOverFlow exception when n = Integer.MAX_VALUE, what I found out was that apparently, stackOverFlow exception occurs even when your number of recursive calls are finite, but of a large number, and there are chances that you are using a call like  `return x*myPow(x,n-1)`. Such type of code makes O(N) recursive calls, which is the cause of the exception when n is very high.\nTo avoid this, we can use O(n/2) calls and multiply the answer twice in our final answer.\nthe code is as follows:\n\n       if(n == 0) return 1;\n\n        if(n == 1)return x;\n\n        if(n == -1) return 1/x;\n\n        double half = myPow(x, n/2);\n\n        double rest = myPow(x, n%2);\n\n        return half*half*rest;\n\nsuch type of a code reduces the number of recursive calls to n/2 instead of n, and we are multiplying the returned value (here, `half`), twice to make up for making half of the required number of calls."
                    },
                    {
                        "username": "JigarRajput",
                        "content": "leetcode walo apne stack ka size badhao \nwith the help of -Xss4m"
                    },
                    {
                        "username": "Shivam_Sikotra",
                        "content": "Just an implementation of Fast Exponential Algorithm!!\nDon't feel bad if you can't solve by own and be happy that by help of this question you get to learn new Algorithm. "
                    },
                    {
                        "username": "Wa1kingR3d",
                        "content": "man that was hard to return one line of code im going to figure out how to make it faster"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "I guess there is an issue, with this question. The test case didn\\'t pass for INT_MIN, but when I created a custom one with n ==INT_MIN-1 it got passes, I guess the range of n which is INT_MIN must be exclusive but they gave it wrongly."
                    },
                    {
                        "username": "wagadregagan",
                        "content": "class Solution {\\n    public double myPow(double x, int n) {\\n        \\n        if(n < 0){\\n            n = -n;\\n            x = 1 / x;\\n        }\\n        \\n        double pow = 1;\\n        \\n        while(n != 0){\\n            if((n & 1) != 0){\\n                pow *= x;\\n            } \\n                \\n            x *= x;\\n            n >>>= 1;\\n            \\n        }\\n        \\n        return pow;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1810594,
                "content": [
                    {
                        "username": "bishal_722",
                        "content": "Can you solve it in constant time O(1) ? \\nVisit my solution to understand a different approach to this problem.\\n\\nhttps://leetcode.com/problems/powx-n/solutions/3217521/o1-c-solution-explained-with-images/"
                    },
                    {
                        "username": "psionl0",
                        "content": "I\\'m not convinced that behind the hood, log and exp both have O(1) run times."
                    },
                    {
                        "username": "Nitinkushwaha",
                        "content": "code is passing few test cases but on submitting giving runtime error can anyone help me with code\n\n\nclass Solution {\n    public double myPow(double x, int n)\n     {\n    double a;\n     if(n>=0)\n        {\n        if(n==0)\n            return 1;\n         a=x*myPow(x,n-1);\n        \n         }\n         else\n         {\n             if(n==0)\n               return 1;\n              a=(1/x)*(1/(myPow(x,-(n+1))));\n         }\n        \n        return a;\n    }\n    \n}"
                    },
                    {
                        "username": "titanaro_1410",
                        "content": "I don\\'t know why the tag is binary search, but the tags are now updated to Math and Recursion"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "simple recursion and divide and conquer:\nclass Solution(object):\n    def myPow(self, x, n):\n        \"\"\"\n        :type x: float\n        :type n: int\n        :rtype: float\n        \"\"\"\n if n < 0:\n            n = -n\n            x = 1/x\n        if n==1 or n==0:\n            return x**n\n        if n%2:\n            return self.myPow(x, n/2) * self.myPow(x, n/2) * x\n\n        return self.myPow(x, n/2) * self.myPow(x, n/2)\n"
                    },
                    {
                        "username": "ankush920",
                        "content": "100 % fast and easy recurrsive solution :-\\nclass Solution {\\npublic:\\n\\n  double positive( double x ,int n )\\n  {\\n      if( n==0 )\\n      {\\n          return 1.00000;\\n      }\\n\\n      double temp = positive(x ,n/2);\\n\\nif( n%2!=0)\\n{\\n    return temp *temp *x;\\n     \\n}\\n\\nreturn temp*temp ;\\n      \\n  }\\n\\n\\n\\n    double negative( double x ,int n )\\n  {\\n      if( n==0 )\\n      {\\n          return 1.00000;\\n      }\\n\\n      double temp = negative (x ,n/2);\\n\\nif( n%2!=0)\\n{\\n    return (temp *temp *(1/x));\\n     \\n}\\n\\nreturn (temp*temp) ;\\n\\n  }\\n\\n    double myPow(double x, int n) {\\n        \\n        if(n==0)\\n        {\\n             return 1.00000;\\n        }\\n\\n        if(n>0)\\n        {\\n           return positive(x,n);  \\n        }\\n\\nreturn negative( x,n);\\n        \\n    }\\n};\\nConsole\\n"
                    },
                    {
                        "username": "abumdmiran2001",
                        "content": "Test case 301 is out of constraint ,How can I solve that. "
                    },
                    {
                        "username": "c8763yee",
                        "content": "i was wondering why i keep get TLE when (x, n)=(0.00001, 2147483647)\nhere is my code:\n```python\nclass Solution:\n    def myPow(self, x: float, n: int) -> float:\n        if n < 0:\n            n = -n\n            x = 1/x\n\n        if n == 0 or n == 1:\n            return x**n\n        \n        if n%2:\n            return self.myPow(x, n//2) * self.myPow(x, n//2) * x\n\n        return self.myPow(x, n//2) * self.myPow(x, n//2)\n```\nthanks for any advise"
                    },
                    {
                        "username": "Aman9262",
                        "content": "```\\nclass Solution {\\n    map<int,double> dp;\\n    double util(double x, int n) {\\n        if(n==0){\\n            return dp[n]=1;\\n        }\\n        if(dp.find(n)!=dp.end()) {\\n                return dp[n];\\n        }\\n        if(n<0){\\n          if(n%2)\\n           return dp[n]=(1.0/x)*util(x, n/2)*util(x, n/2);\\n         return dp[n]=util(x, n/2)*util(x, n/2);\\n        }\\n        if(n%2)\\n           return dp[n]=x*util(x, n/2)*util(x, n/2);\\n        return dp[n] = util(x, n/2)*util(x, n/2);\\n    }\\npublic:\\n    double myPow(double x, int n) {\\n        return util(x,n);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "Having weird issue in C++. for the test case where n = -2147483648 and x = 2, for whatever reason when I run the compiler here, I get 1, but when I run it in VSCode, I get the correct output."
                    },
                    {
                        "username": "khrome",
                        "content": "Why is this too slow? Shouldn\\'t the second recursive call immediately get the answer from memo, making the whole thing O(logn)? It works fine if instead of doing 2 recursive calls I just square the first one like in the comment. But Im curious why the 2 recursive calls make it slow.\\n\\n\\n    def myPow(self, x: float, n: int) -> float:\\n        memo = {0:1}\\n        def dp(n):\\n            nonlocal memo\\n            if memo.get(n):\\n                return memo[n]\\n            odd = n % 2\\n            answer = dp(n//2) * dp(n//2)\\n            # answer *= answer\\n            if odd:\\n                answer *= x\\n            memo[n] = answer\\n            return answer\\n        dp(abs(n))\\n        if n < 0:\\n            return 1 / float(memo[abs(n)])\\n        return memo[n]"
                    },
                    {
                        "username": "mickeyvn",
                        "content": "You can do in O(1)"
                    }
                ]
            },
            {
                "id": 1808648,
                "content": [
                    {
                        "username": "bishal_722",
                        "content": "Can you solve it in constant time O(1) ? \\nVisit my solution to understand a different approach to this problem.\\n\\nhttps://leetcode.com/problems/powx-n/solutions/3217521/o1-c-solution-explained-with-images/"
                    },
                    {
                        "username": "psionl0",
                        "content": "I\\'m not convinced that behind the hood, log and exp both have O(1) run times."
                    },
                    {
                        "username": "Nitinkushwaha",
                        "content": "code is passing few test cases but on submitting giving runtime error can anyone help me with code\n\n\nclass Solution {\n    public double myPow(double x, int n)\n     {\n    double a;\n     if(n>=0)\n        {\n        if(n==0)\n            return 1;\n         a=x*myPow(x,n-1);\n        \n         }\n         else\n         {\n             if(n==0)\n               return 1;\n              a=(1/x)*(1/(myPow(x,-(n+1))));\n         }\n        \n        return a;\n    }\n    \n}"
                    },
                    {
                        "username": "titanaro_1410",
                        "content": "I don\\'t know why the tag is binary search, but the tags are now updated to Math and Recursion"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "simple recursion and divide and conquer:\nclass Solution(object):\n    def myPow(self, x, n):\n        \"\"\"\n        :type x: float\n        :type n: int\n        :rtype: float\n        \"\"\"\n if n < 0:\n            n = -n\n            x = 1/x\n        if n==1 or n==0:\n            return x**n\n        if n%2:\n            return self.myPow(x, n/2) * self.myPow(x, n/2) * x\n\n        return self.myPow(x, n/2) * self.myPow(x, n/2)\n"
                    },
                    {
                        "username": "ankush920",
                        "content": "100 % fast and easy recurrsive solution :-\\nclass Solution {\\npublic:\\n\\n  double positive( double x ,int n )\\n  {\\n      if( n==0 )\\n      {\\n          return 1.00000;\\n      }\\n\\n      double temp = positive(x ,n/2);\\n\\nif( n%2!=0)\\n{\\n    return temp *temp *x;\\n     \\n}\\n\\nreturn temp*temp ;\\n      \\n  }\\n\\n\\n\\n    double negative( double x ,int n )\\n  {\\n      if( n==0 )\\n      {\\n          return 1.00000;\\n      }\\n\\n      double temp = negative (x ,n/2);\\n\\nif( n%2!=0)\\n{\\n    return (temp *temp *(1/x));\\n     \\n}\\n\\nreturn (temp*temp) ;\\n\\n  }\\n\\n    double myPow(double x, int n) {\\n        \\n        if(n==0)\\n        {\\n             return 1.00000;\\n        }\\n\\n        if(n>0)\\n        {\\n           return positive(x,n);  \\n        }\\n\\nreturn negative( x,n);\\n        \\n    }\\n};\\nConsole\\n"
                    },
                    {
                        "username": "abumdmiran2001",
                        "content": "Test case 301 is out of constraint ,How can I solve that. "
                    },
                    {
                        "username": "c8763yee",
                        "content": "i was wondering why i keep get TLE when (x, n)=(0.00001, 2147483647)\nhere is my code:\n```python\nclass Solution:\n    def myPow(self, x: float, n: int) -> float:\n        if n < 0:\n            n = -n\n            x = 1/x\n\n        if n == 0 or n == 1:\n            return x**n\n        \n        if n%2:\n            return self.myPow(x, n//2) * self.myPow(x, n//2) * x\n\n        return self.myPow(x, n//2) * self.myPow(x, n//2)\n```\nthanks for any advise"
                    },
                    {
                        "username": "Aman9262",
                        "content": "```\\nclass Solution {\\n    map<int,double> dp;\\n    double util(double x, int n) {\\n        if(n==0){\\n            return dp[n]=1;\\n        }\\n        if(dp.find(n)!=dp.end()) {\\n                return dp[n];\\n        }\\n        if(n<0){\\n          if(n%2)\\n           return dp[n]=(1.0/x)*util(x, n/2)*util(x, n/2);\\n         return dp[n]=util(x, n/2)*util(x, n/2);\\n        }\\n        if(n%2)\\n           return dp[n]=x*util(x, n/2)*util(x, n/2);\\n        return dp[n] = util(x, n/2)*util(x, n/2);\\n    }\\npublic:\\n    double myPow(double x, int n) {\\n        return util(x,n);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "Having weird issue in C++. for the test case where n = -2147483648 and x = 2, for whatever reason when I run the compiler here, I get 1, but when I run it in VSCode, I get the correct output."
                    },
                    {
                        "username": "khrome",
                        "content": "Why is this too slow? Shouldn\\'t the second recursive call immediately get the answer from memo, making the whole thing O(logn)? It works fine if instead of doing 2 recursive calls I just square the first one like in the comment. But Im curious why the 2 recursive calls make it slow.\\n\\n\\n    def myPow(self, x: float, n: int) -> float:\\n        memo = {0:1}\\n        def dp(n):\\n            nonlocal memo\\n            if memo.get(n):\\n                return memo[n]\\n            odd = n % 2\\n            answer = dp(n//2) * dp(n//2)\\n            # answer *= answer\\n            if odd:\\n                answer *= x\\n            memo[n] = answer\\n            return answer\\n        dp(abs(n))\\n        if n < 0:\\n            return 1 / float(memo[abs(n)])\\n        return memo[n]"
                    },
                    {
                        "username": "mickeyvn",
                        "content": "You can do in O(1)"
                    }
                ]
            },
            {
                "id": 1807072,
                "content": [
                    {
                        "username": "bishal_722",
                        "content": "Can you solve it in constant time O(1) ? \\nVisit my solution to understand a different approach to this problem.\\n\\nhttps://leetcode.com/problems/powx-n/solutions/3217521/o1-c-solution-explained-with-images/"
                    },
                    {
                        "username": "psionl0",
                        "content": "I\\'m not convinced that behind the hood, log and exp both have O(1) run times."
                    },
                    {
                        "username": "Nitinkushwaha",
                        "content": "code is passing few test cases but on submitting giving runtime error can anyone help me with code\n\n\nclass Solution {\n    public double myPow(double x, int n)\n     {\n    double a;\n     if(n>=0)\n        {\n        if(n==0)\n            return 1;\n         a=x*myPow(x,n-1);\n        \n         }\n         else\n         {\n             if(n==0)\n               return 1;\n              a=(1/x)*(1/(myPow(x,-(n+1))));\n         }\n        \n        return a;\n    }\n    \n}"
                    },
                    {
                        "username": "titanaro_1410",
                        "content": "I don\\'t know why the tag is binary search, but the tags are now updated to Math and Recursion"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "simple recursion and divide and conquer:\nclass Solution(object):\n    def myPow(self, x, n):\n        \"\"\"\n        :type x: float\n        :type n: int\n        :rtype: float\n        \"\"\"\n if n < 0:\n            n = -n\n            x = 1/x\n        if n==1 or n==0:\n            return x**n\n        if n%2:\n            return self.myPow(x, n/2) * self.myPow(x, n/2) * x\n\n        return self.myPow(x, n/2) * self.myPow(x, n/2)\n"
                    },
                    {
                        "username": "ankush920",
                        "content": "100 % fast and easy recurrsive solution :-\\nclass Solution {\\npublic:\\n\\n  double positive( double x ,int n )\\n  {\\n      if( n==0 )\\n      {\\n          return 1.00000;\\n      }\\n\\n      double temp = positive(x ,n/2);\\n\\nif( n%2!=0)\\n{\\n    return temp *temp *x;\\n     \\n}\\n\\nreturn temp*temp ;\\n      \\n  }\\n\\n\\n\\n    double negative( double x ,int n )\\n  {\\n      if( n==0 )\\n      {\\n          return 1.00000;\\n      }\\n\\n      double temp = negative (x ,n/2);\\n\\nif( n%2!=0)\\n{\\n    return (temp *temp *(1/x));\\n     \\n}\\n\\nreturn (temp*temp) ;\\n\\n  }\\n\\n    double myPow(double x, int n) {\\n        \\n        if(n==0)\\n        {\\n             return 1.00000;\\n        }\\n\\n        if(n>0)\\n        {\\n           return positive(x,n);  \\n        }\\n\\nreturn negative( x,n);\\n        \\n    }\\n};\\nConsole\\n"
                    },
                    {
                        "username": "abumdmiran2001",
                        "content": "Test case 301 is out of constraint ,How can I solve that. "
                    },
                    {
                        "username": "c8763yee",
                        "content": "i was wondering why i keep get TLE when (x, n)=(0.00001, 2147483647)\nhere is my code:\n```python\nclass Solution:\n    def myPow(self, x: float, n: int) -> float:\n        if n < 0:\n            n = -n\n            x = 1/x\n\n        if n == 0 or n == 1:\n            return x**n\n        \n        if n%2:\n            return self.myPow(x, n//2) * self.myPow(x, n//2) * x\n\n        return self.myPow(x, n//2) * self.myPow(x, n//2)\n```\nthanks for any advise"
                    },
                    {
                        "username": "Aman9262",
                        "content": "```\\nclass Solution {\\n    map<int,double> dp;\\n    double util(double x, int n) {\\n        if(n==0){\\n            return dp[n]=1;\\n        }\\n        if(dp.find(n)!=dp.end()) {\\n                return dp[n];\\n        }\\n        if(n<0){\\n          if(n%2)\\n           return dp[n]=(1.0/x)*util(x, n/2)*util(x, n/2);\\n         return dp[n]=util(x, n/2)*util(x, n/2);\\n        }\\n        if(n%2)\\n           return dp[n]=x*util(x, n/2)*util(x, n/2);\\n        return dp[n] = util(x, n/2)*util(x, n/2);\\n    }\\npublic:\\n    double myPow(double x, int n) {\\n        return util(x,n);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "Having weird issue in C++. for the test case where n = -2147483648 and x = 2, for whatever reason when I run the compiler here, I get 1, but when I run it in VSCode, I get the correct output."
                    },
                    {
                        "username": "khrome",
                        "content": "Why is this too slow? Shouldn\\'t the second recursive call immediately get the answer from memo, making the whole thing O(logn)? It works fine if instead of doing 2 recursive calls I just square the first one like in the comment. But Im curious why the 2 recursive calls make it slow.\\n\\n\\n    def myPow(self, x: float, n: int) -> float:\\n        memo = {0:1}\\n        def dp(n):\\n            nonlocal memo\\n            if memo.get(n):\\n                return memo[n]\\n            odd = n % 2\\n            answer = dp(n//2) * dp(n//2)\\n            # answer *= answer\\n            if odd:\\n                answer *= x\\n            memo[n] = answer\\n            return answer\\n        dp(abs(n))\\n        if n < 0:\\n            return 1 / float(memo[abs(n)])\\n        return memo[n]"
                    },
                    {
                        "username": "mickeyvn",
                        "content": "You can do in O(1)"
                    }
                ]
            },
            {
                "id": 1805438,
                "content": [
                    {
                        "username": "bishal_722",
                        "content": "Can you solve it in constant time O(1) ? \\nVisit my solution to understand a different approach to this problem.\\n\\nhttps://leetcode.com/problems/powx-n/solutions/3217521/o1-c-solution-explained-with-images/"
                    },
                    {
                        "username": "psionl0",
                        "content": "I\\'m not convinced that behind the hood, log and exp both have O(1) run times."
                    },
                    {
                        "username": "Nitinkushwaha",
                        "content": "code is passing few test cases but on submitting giving runtime error can anyone help me with code\n\n\nclass Solution {\n    public double myPow(double x, int n)\n     {\n    double a;\n     if(n>=0)\n        {\n        if(n==0)\n            return 1;\n         a=x*myPow(x,n-1);\n        \n         }\n         else\n         {\n             if(n==0)\n               return 1;\n              a=(1/x)*(1/(myPow(x,-(n+1))));\n         }\n        \n        return a;\n    }\n    \n}"
                    },
                    {
                        "username": "titanaro_1410",
                        "content": "I don\\'t know why the tag is binary search, but the tags are now updated to Math and Recursion"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "simple recursion and divide and conquer:\nclass Solution(object):\n    def myPow(self, x, n):\n        \"\"\"\n        :type x: float\n        :type n: int\n        :rtype: float\n        \"\"\"\n if n < 0:\n            n = -n\n            x = 1/x\n        if n==1 or n==0:\n            return x**n\n        if n%2:\n            return self.myPow(x, n/2) * self.myPow(x, n/2) * x\n\n        return self.myPow(x, n/2) * self.myPow(x, n/2)\n"
                    },
                    {
                        "username": "ankush920",
                        "content": "100 % fast and easy recurrsive solution :-\\nclass Solution {\\npublic:\\n\\n  double positive( double x ,int n )\\n  {\\n      if( n==0 )\\n      {\\n          return 1.00000;\\n      }\\n\\n      double temp = positive(x ,n/2);\\n\\nif( n%2!=0)\\n{\\n    return temp *temp *x;\\n     \\n}\\n\\nreturn temp*temp ;\\n      \\n  }\\n\\n\\n\\n    double negative( double x ,int n )\\n  {\\n      if( n==0 )\\n      {\\n          return 1.00000;\\n      }\\n\\n      double temp = negative (x ,n/2);\\n\\nif( n%2!=0)\\n{\\n    return (temp *temp *(1/x));\\n     \\n}\\n\\nreturn (temp*temp) ;\\n\\n  }\\n\\n    double myPow(double x, int n) {\\n        \\n        if(n==0)\\n        {\\n             return 1.00000;\\n        }\\n\\n        if(n>0)\\n        {\\n           return positive(x,n);  \\n        }\\n\\nreturn negative( x,n);\\n        \\n    }\\n};\\nConsole\\n"
                    },
                    {
                        "username": "abumdmiran2001",
                        "content": "Test case 301 is out of constraint ,How can I solve that. "
                    },
                    {
                        "username": "c8763yee",
                        "content": "i was wondering why i keep get TLE when (x, n)=(0.00001, 2147483647)\nhere is my code:\n```python\nclass Solution:\n    def myPow(self, x: float, n: int) -> float:\n        if n < 0:\n            n = -n\n            x = 1/x\n\n        if n == 0 or n == 1:\n            return x**n\n        \n        if n%2:\n            return self.myPow(x, n//2) * self.myPow(x, n//2) * x\n\n        return self.myPow(x, n//2) * self.myPow(x, n//2)\n```\nthanks for any advise"
                    },
                    {
                        "username": "Aman9262",
                        "content": "```\\nclass Solution {\\n    map<int,double> dp;\\n    double util(double x, int n) {\\n        if(n==0){\\n            return dp[n]=1;\\n        }\\n        if(dp.find(n)!=dp.end()) {\\n                return dp[n];\\n        }\\n        if(n<0){\\n          if(n%2)\\n           return dp[n]=(1.0/x)*util(x, n/2)*util(x, n/2);\\n         return dp[n]=util(x, n/2)*util(x, n/2);\\n        }\\n        if(n%2)\\n           return dp[n]=x*util(x, n/2)*util(x, n/2);\\n        return dp[n] = util(x, n/2)*util(x, n/2);\\n    }\\npublic:\\n    double myPow(double x, int n) {\\n        return util(x,n);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "Having weird issue in C++. for the test case where n = -2147483648 and x = 2, for whatever reason when I run the compiler here, I get 1, but when I run it in VSCode, I get the correct output."
                    },
                    {
                        "username": "khrome",
                        "content": "Why is this too slow? Shouldn\\'t the second recursive call immediately get the answer from memo, making the whole thing O(logn)? It works fine if instead of doing 2 recursive calls I just square the first one like in the comment. But Im curious why the 2 recursive calls make it slow.\\n\\n\\n    def myPow(self, x: float, n: int) -> float:\\n        memo = {0:1}\\n        def dp(n):\\n            nonlocal memo\\n            if memo.get(n):\\n                return memo[n]\\n            odd = n % 2\\n            answer = dp(n//2) * dp(n//2)\\n            # answer *= answer\\n            if odd:\\n                answer *= x\\n            memo[n] = answer\\n            return answer\\n        dp(abs(n))\\n        if n < 0:\\n            return 1 / float(memo[abs(n)])\\n        return memo[n]"
                    },
                    {
                        "username": "mickeyvn",
                        "content": "You can do in O(1)"
                    }
                ]
            },
            {
                "id": 1803019,
                "content": [
                    {
                        "username": "bishal_722",
                        "content": "Can you solve it in constant time O(1) ? \\nVisit my solution to understand a different approach to this problem.\\n\\nhttps://leetcode.com/problems/powx-n/solutions/3217521/o1-c-solution-explained-with-images/"
                    },
                    {
                        "username": "psionl0",
                        "content": "I\\'m not convinced that behind the hood, log and exp both have O(1) run times."
                    },
                    {
                        "username": "Nitinkushwaha",
                        "content": "code is passing few test cases but on submitting giving runtime error can anyone help me with code\n\n\nclass Solution {\n    public double myPow(double x, int n)\n     {\n    double a;\n     if(n>=0)\n        {\n        if(n==0)\n            return 1;\n         a=x*myPow(x,n-1);\n        \n         }\n         else\n         {\n             if(n==0)\n               return 1;\n              a=(1/x)*(1/(myPow(x,-(n+1))));\n         }\n        \n        return a;\n    }\n    \n}"
                    },
                    {
                        "username": "titanaro_1410",
                        "content": "I don\\'t know why the tag is binary search, but the tags are now updated to Math and Recursion"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "simple recursion and divide and conquer:\nclass Solution(object):\n    def myPow(self, x, n):\n        \"\"\"\n        :type x: float\n        :type n: int\n        :rtype: float\n        \"\"\"\n if n < 0:\n            n = -n\n            x = 1/x\n        if n==1 or n==0:\n            return x**n\n        if n%2:\n            return self.myPow(x, n/2) * self.myPow(x, n/2) * x\n\n        return self.myPow(x, n/2) * self.myPow(x, n/2)\n"
                    },
                    {
                        "username": "ankush920",
                        "content": "100 % fast and easy recurrsive solution :-\\nclass Solution {\\npublic:\\n\\n  double positive( double x ,int n )\\n  {\\n      if( n==0 )\\n      {\\n          return 1.00000;\\n      }\\n\\n      double temp = positive(x ,n/2);\\n\\nif( n%2!=0)\\n{\\n    return temp *temp *x;\\n     \\n}\\n\\nreturn temp*temp ;\\n      \\n  }\\n\\n\\n\\n    double negative( double x ,int n )\\n  {\\n      if( n==0 )\\n      {\\n          return 1.00000;\\n      }\\n\\n      double temp = negative (x ,n/2);\\n\\nif( n%2!=0)\\n{\\n    return (temp *temp *(1/x));\\n     \\n}\\n\\nreturn (temp*temp) ;\\n\\n  }\\n\\n    double myPow(double x, int n) {\\n        \\n        if(n==0)\\n        {\\n             return 1.00000;\\n        }\\n\\n        if(n>0)\\n        {\\n           return positive(x,n);  \\n        }\\n\\nreturn negative( x,n);\\n        \\n    }\\n};\\nConsole\\n"
                    },
                    {
                        "username": "abumdmiran2001",
                        "content": "Test case 301 is out of constraint ,How can I solve that. "
                    },
                    {
                        "username": "c8763yee",
                        "content": "i was wondering why i keep get TLE when (x, n)=(0.00001, 2147483647)\nhere is my code:\n```python\nclass Solution:\n    def myPow(self, x: float, n: int) -> float:\n        if n < 0:\n            n = -n\n            x = 1/x\n\n        if n == 0 or n == 1:\n            return x**n\n        \n        if n%2:\n            return self.myPow(x, n//2) * self.myPow(x, n//2) * x\n\n        return self.myPow(x, n//2) * self.myPow(x, n//2)\n```\nthanks for any advise"
                    },
                    {
                        "username": "Aman9262",
                        "content": "```\\nclass Solution {\\n    map<int,double> dp;\\n    double util(double x, int n) {\\n        if(n==0){\\n            return dp[n]=1;\\n        }\\n        if(dp.find(n)!=dp.end()) {\\n                return dp[n];\\n        }\\n        if(n<0){\\n          if(n%2)\\n           return dp[n]=(1.0/x)*util(x, n/2)*util(x, n/2);\\n         return dp[n]=util(x, n/2)*util(x, n/2);\\n        }\\n        if(n%2)\\n           return dp[n]=x*util(x, n/2)*util(x, n/2);\\n        return dp[n] = util(x, n/2)*util(x, n/2);\\n    }\\npublic:\\n    double myPow(double x, int n) {\\n        return util(x,n);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "Having weird issue in C++. for the test case where n = -2147483648 and x = 2, for whatever reason when I run the compiler here, I get 1, but when I run it in VSCode, I get the correct output."
                    },
                    {
                        "username": "khrome",
                        "content": "Why is this too slow? Shouldn\\'t the second recursive call immediately get the answer from memo, making the whole thing O(logn)? It works fine if instead of doing 2 recursive calls I just square the first one like in the comment. But Im curious why the 2 recursive calls make it slow.\\n\\n\\n    def myPow(self, x: float, n: int) -> float:\\n        memo = {0:1}\\n        def dp(n):\\n            nonlocal memo\\n            if memo.get(n):\\n                return memo[n]\\n            odd = n % 2\\n            answer = dp(n//2) * dp(n//2)\\n            # answer *= answer\\n            if odd:\\n                answer *= x\\n            memo[n] = answer\\n            return answer\\n        dp(abs(n))\\n        if n < 0:\\n            return 1 / float(memo[abs(n)])\\n        return memo[n]"
                    },
                    {
                        "username": "mickeyvn",
                        "content": "You can do in O(1)"
                    }
                ]
            },
            {
                "id": 1800886,
                "content": [
                    {
                        "username": "bishal_722",
                        "content": "Can you solve it in constant time O(1) ? \\nVisit my solution to understand a different approach to this problem.\\n\\nhttps://leetcode.com/problems/powx-n/solutions/3217521/o1-c-solution-explained-with-images/"
                    },
                    {
                        "username": "psionl0",
                        "content": "I\\'m not convinced that behind the hood, log and exp both have O(1) run times."
                    },
                    {
                        "username": "Nitinkushwaha",
                        "content": "code is passing few test cases but on submitting giving runtime error can anyone help me with code\n\n\nclass Solution {\n    public double myPow(double x, int n)\n     {\n    double a;\n     if(n>=0)\n        {\n        if(n==0)\n            return 1;\n         a=x*myPow(x,n-1);\n        \n         }\n         else\n         {\n             if(n==0)\n               return 1;\n              a=(1/x)*(1/(myPow(x,-(n+1))));\n         }\n        \n        return a;\n    }\n    \n}"
                    },
                    {
                        "username": "titanaro_1410",
                        "content": "I don\\'t know why the tag is binary search, but the tags are now updated to Math and Recursion"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "simple recursion and divide and conquer:\nclass Solution(object):\n    def myPow(self, x, n):\n        \"\"\"\n        :type x: float\n        :type n: int\n        :rtype: float\n        \"\"\"\n if n < 0:\n            n = -n\n            x = 1/x\n        if n==1 or n==0:\n            return x**n\n        if n%2:\n            return self.myPow(x, n/2) * self.myPow(x, n/2) * x\n\n        return self.myPow(x, n/2) * self.myPow(x, n/2)\n"
                    },
                    {
                        "username": "ankush920",
                        "content": "100 % fast and easy recurrsive solution :-\\nclass Solution {\\npublic:\\n\\n  double positive( double x ,int n )\\n  {\\n      if( n==0 )\\n      {\\n          return 1.00000;\\n      }\\n\\n      double temp = positive(x ,n/2);\\n\\nif( n%2!=0)\\n{\\n    return temp *temp *x;\\n     \\n}\\n\\nreturn temp*temp ;\\n      \\n  }\\n\\n\\n\\n    double negative( double x ,int n )\\n  {\\n      if( n==0 )\\n      {\\n          return 1.00000;\\n      }\\n\\n      double temp = negative (x ,n/2);\\n\\nif( n%2!=0)\\n{\\n    return (temp *temp *(1/x));\\n     \\n}\\n\\nreturn (temp*temp) ;\\n\\n  }\\n\\n    double myPow(double x, int n) {\\n        \\n        if(n==0)\\n        {\\n             return 1.00000;\\n        }\\n\\n        if(n>0)\\n        {\\n           return positive(x,n);  \\n        }\\n\\nreturn negative( x,n);\\n        \\n    }\\n};\\nConsole\\n"
                    },
                    {
                        "username": "abumdmiran2001",
                        "content": "Test case 301 is out of constraint ,How can I solve that. "
                    },
                    {
                        "username": "c8763yee",
                        "content": "i was wondering why i keep get TLE when (x, n)=(0.00001, 2147483647)\nhere is my code:\n```python\nclass Solution:\n    def myPow(self, x: float, n: int) -> float:\n        if n < 0:\n            n = -n\n            x = 1/x\n\n        if n == 0 or n == 1:\n            return x**n\n        \n        if n%2:\n            return self.myPow(x, n//2) * self.myPow(x, n//2) * x\n\n        return self.myPow(x, n//2) * self.myPow(x, n//2)\n```\nthanks for any advise"
                    },
                    {
                        "username": "Aman9262",
                        "content": "```\\nclass Solution {\\n    map<int,double> dp;\\n    double util(double x, int n) {\\n        if(n==0){\\n            return dp[n]=1;\\n        }\\n        if(dp.find(n)!=dp.end()) {\\n                return dp[n];\\n        }\\n        if(n<0){\\n          if(n%2)\\n           return dp[n]=(1.0/x)*util(x, n/2)*util(x, n/2);\\n         return dp[n]=util(x, n/2)*util(x, n/2);\\n        }\\n        if(n%2)\\n           return dp[n]=x*util(x, n/2)*util(x, n/2);\\n        return dp[n] = util(x, n/2)*util(x, n/2);\\n    }\\npublic:\\n    double myPow(double x, int n) {\\n        return util(x,n);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "Having weird issue in C++. for the test case where n = -2147483648 and x = 2, for whatever reason when I run the compiler here, I get 1, but when I run it in VSCode, I get the correct output."
                    },
                    {
                        "username": "khrome",
                        "content": "Why is this too slow? Shouldn\\'t the second recursive call immediately get the answer from memo, making the whole thing O(logn)? It works fine if instead of doing 2 recursive calls I just square the first one like in the comment. But Im curious why the 2 recursive calls make it slow.\\n\\n\\n    def myPow(self, x: float, n: int) -> float:\\n        memo = {0:1}\\n        def dp(n):\\n            nonlocal memo\\n            if memo.get(n):\\n                return memo[n]\\n            odd = n % 2\\n            answer = dp(n//2) * dp(n//2)\\n            # answer *= answer\\n            if odd:\\n                answer *= x\\n            memo[n] = answer\\n            return answer\\n        dp(abs(n))\\n        if n < 0:\\n            return 1 / float(memo[abs(n)])\\n        return memo[n]"
                    },
                    {
                        "username": "mickeyvn",
                        "content": "You can do in O(1)"
                    }
                ]
            },
            {
                "id": 1795060,
                "content": [
                    {
                        "username": "bishal_722",
                        "content": "Can you solve it in constant time O(1) ? \\nVisit my solution to understand a different approach to this problem.\\n\\nhttps://leetcode.com/problems/powx-n/solutions/3217521/o1-c-solution-explained-with-images/"
                    },
                    {
                        "username": "psionl0",
                        "content": "I\\'m not convinced that behind the hood, log and exp both have O(1) run times."
                    },
                    {
                        "username": "Nitinkushwaha",
                        "content": "code is passing few test cases but on submitting giving runtime error can anyone help me with code\n\n\nclass Solution {\n    public double myPow(double x, int n)\n     {\n    double a;\n     if(n>=0)\n        {\n        if(n==0)\n            return 1;\n         a=x*myPow(x,n-1);\n        \n         }\n         else\n         {\n             if(n==0)\n               return 1;\n              a=(1/x)*(1/(myPow(x,-(n+1))));\n         }\n        \n        return a;\n    }\n    \n}"
                    },
                    {
                        "username": "titanaro_1410",
                        "content": "I don\\'t know why the tag is binary search, but the tags are now updated to Math and Recursion"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "simple recursion and divide and conquer:\nclass Solution(object):\n    def myPow(self, x, n):\n        \"\"\"\n        :type x: float\n        :type n: int\n        :rtype: float\n        \"\"\"\n if n < 0:\n            n = -n\n            x = 1/x\n        if n==1 or n==0:\n            return x**n\n        if n%2:\n            return self.myPow(x, n/2) * self.myPow(x, n/2) * x\n\n        return self.myPow(x, n/2) * self.myPow(x, n/2)\n"
                    },
                    {
                        "username": "ankush920",
                        "content": "100 % fast and easy recurrsive solution :-\\nclass Solution {\\npublic:\\n\\n  double positive( double x ,int n )\\n  {\\n      if( n==0 )\\n      {\\n          return 1.00000;\\n      }\\n\\n      double temp = positive(x ,n/2);\\n\\nif( n%2!=0)\\n{\\n    return temp *temp *x;\\n     \\n}\\n\\nreturn temp*temp ;\\n      \\n  }\\n\\n\\n\\n    double negative( double x ,int n )\\n  {\\n      if( n==0 )\\n      {\\n          return 1.00000;\\n      }\\n\\n      double temp = negative (x ,n/2);\\n\\nif( n%2!=0)\\n{\\n    return (temp *temp *(1/x));\\n     \\n}\\n\\nreturn (temp*temp) ;\\n\\n  }\\n\\n    double myPow(double x, int n) {\\n        \\n        if(n==0)\\n        {\\n             return 1.00000;\\n        }\\n\\n        if(n>0)\\n        {\\n           return positive(x,n);  \\n        }\\n\\nreturn negative( x,n);\\n        \\n    }\\n};\\nConsole\\n"
                    },
                    {
                        "username": "abumdmiran2001",
                        "content": "Test case 301 is out of constraint ,How can I solve that. "
                    },
                    {
                        "username": "c8763yee",
                        "content": "i was wondering why i keep get TLE when (x, n)=(0.00001, 2147483647)\nhere is my code:\n```python\nclass Solution:\n    def myPow(self, x: float, n: int) -> float:\n        if n < 0:\n            n = -n\n            x = 1/x\n\n        if n == 0 or n == 1:\n            return x**n\n        \n        if n%2:\n            return self.myPow(x, n//2) * self.myPow(x, n//2) * x\n\n        return self.myPow(x, n//2) * self.myPow(x, n//2)\n```\nthanks for any advise"
                    },
                    {
                        "username": "Aman9262",
                        "content": "```\\nclass Solution {\\n    map<int,double> dp;\\n    double util(double x, int n) {\\n        if(n==0){\\n            return dp[n]=1;\\n        }\\n        if(dp.find(n)!=dp.end()) {\\n                return dp[n];\\n        }\\n        if(n<0){\\n          if(n%2)\\n           return dp[n]=(1.0/x)*util(x, n/2)*util(x, n/2);\\n         return dp[n]=util(x, n/2)*util(x, n/2);\\n        }\\n        if(n%2)\\n           return dp[n]=x*util(x, n/2)*util(x, n/2);\\n        return dp[n] = util(x, n/2)*util(x, n/2);\\n    }\\npublic:\\n    double myPow(double x, int n) {\\n        return util(x,n);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "Having weird issue in C++. for the test case where n = -2147483648 and x = 2, for whatever reason when I run the compiler here, I get 1, but when I run it in VSCode, I get the correct output."
                    },
                    {
                        "username": "khrome",
                        "content": "Why is this too slow? Shouldn\\'t the second recursive call immediately get the answer from memo, making the whole thing O(logn)? It works fine if instead of doing 2 recursive calls I just square the first one like in the comment. But Im curious why the 2 recursive calls make it slow.\\n\\n\\n    def myPow(self, x: float, n: int) -> float:\\n        memo = {0:1}\\n        def dp(n):\\n            nonlocal memo\\n            if memo.get(n):\\n                return memo[n]\\n            odd = n % 2\\n            answer = dp(n//2) * dp(n//2)\\n            # answer *= answer\\n            if odd:\\n                answer *= x\\n            memo[n] = answer\\n            return answer\\n        dp(abs(n))\\n        if n < 0:\\n            return 1 / float(memo[abs(n)])\\n        return memo[n]"
                    },
                    {
                        "username": "mickeyvn",
                        "content": "You can do in O(1)"
                    }
                ]
            },
            {
                "id": 1792055,
                "content": [
                    {
                        "username": "bishal_722",
                        "content": "Can you solve it in constant time O(1) ? \\nVisit my solution to understand a different approach to this problem.\\n\\nhttps://leetcode.com/problems/powx-n/solutions/3217521/o1-c-solution-explained-with-images/"
                    },
                    {
                        "username": "psionl0",
                        "content": "I\\'m not convinced that behind the hood, log and exp both have O(1) run times."
                    },
                    {
                        "username": "Nitinkushwaha",
                        "content": "code is passing few test cases but on submitting giving runtime error can anyone help me with code\n\n\nclass Solution {\n    public double myPow(double x, int n)\n     {\n    double a;\n     if(n>=0)\n        {\n        if(n==0)\n            return 1;\n         a=x*myPow(x,n-1);\n        \n         }\n         else\n         {\n             if(n==0)\n               return 1;\n              a=(1/x)*(1/(myPow(x,-(n+1))));\n         }\n        \n        return a;\n    }\n    \n}"
                    },
                    {
                        "username": "titanaro_1410",
                        "content": "I don\\'t know why the tag is binary search, but the tags are now updated to Math and Recursion"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "simple recursion and divide and conquer:\nclass Solution(object):\n    def myPow(self, x, n):\n        \"\"\"\n        :type x: float\n        :type n: int\n        :rtype: float\n        \"\"\"\n if n < 0:\n            n = -n\n            x = 1/x\n        if n==1 or n==0:\n            return x**n\n        if n%2:\n            return self.myPow(x, n/2) * self.myPow(x, n/2) * x\n\n        return self.myPow(x, n/2) * self.myPow(x, n/2)\n"
                    },
                    {
                        "username": "ankush920",
                        "content": "100 % fast and easy recurrsive solution :-\\nclass Solution {\\npublic:\\n\\n  double positive( double x ,int n )\\n  {\\n      if( n==0 )\\n      {\\n          return 1.00000;\\n      }\\n\\n      double temp = positive(x ,n/2);\\n\\nif( n%2!=0)\\n{\\n    return temp *temp *x;\\n     \\n}\\n\\nreturn temp*temp ;\\n      \\n  }\\n\\n\\n\\n    double negative( double x ,int n )\\n  {\\n      if( n==0 )\\n      {\\n          return 1.00000;\\n      }\\n\\n      double temp = negative (x ,n/2);\\n\\nif( n%2!=0)\\n{\\n    return (temp *temp *(1/x));\\n     \\n}\\n\\nreturn (temp*temp) ;\\n\\n  }\\n\\n    double myPow(double x, int n) {\\n        \\n        if(n==0)\\n        {\\n             return 1.00000;\\n        }\\n\\n        if(n>0)\\n        {\\n           return positive(x,n);  \\n        }\\n\\nreturn negative( x,n);\\n        \\n    }\\n};\\nConsole\\n"
                    },
                    {
                        "username": "abumdmiran2001",
                        "content": "Test case 301 is out of constraint ,How can I solve that. "
                    },
                    {
                        "username": "c8763yee",
                        "content": "i was wondering why i keep get TLE when (x, n)=(0.00001, 2147483647)\nhere is my code:\n```python\nclass Solution:\n    def myPow(self, x: float, n: int) -> float:\n        if n < 0:\n            n = -n\n            x = 1/x\n\n        if n == 0 or n == 1:\n            return x**n\n        \n        if n%2:\n            return self.myPow(x, n//2) * self.myPow(x, n//2) * x\n\n        return self.myPow(x, n//2) * self.myPow(x, n//2)\n```\nthanks for any advise"
                    },
                    {
                        "username": "Aman9262",
                        "content": "```\\nclass Solution {\\n    map<int,double> dp;\\n    double util(double x, int n) {\\n        if(n==0){\\n            return dp[n]=1;\\n        }\\n        if(dp.find(n)!=dp.end()) {\\n                return dp[n];\\n        }\\n        if(n<0){\\n          if(n%2)\\n           return dp[n]=(1.0/x)*util(x, n/2)*util(x, n/2);\\n         return dp[n]=util(x, n/2)*util(x, n/2);\\n        }\\n        if(n%2)\\n           return dp[n]=x*util(x, n/2)*util(x, n/2);\\n        return dp[n] = util(x, n/2)*util(x, n/2);\\n    }\\npublic:\\n    double myPow(double x, int n) {\\n        return util(x,n);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "Having weird issue in C++. for the test case where n = -2147483648 and x = 2, for whatever reason when I run the compiler here, I get 1, but when I run it in VSCode, I get the correct output."
                    },
                    {
                        "username": "khrome",
                        "content": "Why is this too slow? Shouldn\\'t the second recursive call immediately get the answer from memo, making the whole thing O(logn)? It works fine if instead of doing 2 recursive calls I just square the first one like in the comment. But Im curious why the 2 recursive calls make it slow.\\n\\n\\n    def myPow(self, x: float, n: int) -> float:\\n        memo = {0:1}\\n        def dp(n):\\n            nonlocal memo\\n            if memo.get(n):\\n                return memo[n]\\n            odd = n % 2\\n            answer = dp(n//2) * dp(n//2)\\n            # answer *= answer\\n            if odd:\\n                answer *= x\\n            memo[n] = answer\\n            return answer\\n        dp(abs(n))\\n        if n < 0:\\n            return 1 / float(memo[abs(n)])\\n        return memo[n]"
                    },
                    {
                        "username": "mickeyvn",
                        "content": "You can do in O(1)"
                    }
                ]
            },
            {
                "id": 1783926,
                "content": [
                    {
                        "username": "bishal_722",
                        "content": "Can you solve it in constant time O(1) ? \\nVisit my solution to understand a different approach to this problem.\\n\\nhttps://leetcode.com/problems/powx-n/solutions/3217521/o1-c-solution-explained-with-images/"
                    },
                    {
                        "username": "psionl0",
                        "content": "I\\'m not convinced that behind the hood, log and exp both have O(1) run times."
                    },
                    {
                        "username": "Nitinkushwaha",
                        "content": "code is passing few test cases but on submitting giving runtime error can anyone help me with code\n\n\nclass Solution {\n    public double myPow(double x, int n)\n     {\n    double a;\n     if(n>=0)\n        {\n        if(n==0)\n            return 1;\n         a=x*myPow(x,n-1);\n        \n         }\n         else\n         {\n             if(n==0)\n               return 1;\n              a=(1/x)*(1/(myPow(x,-(n+1))));\n         }\n        \n        return a;\n    }\n    \n}"
                    },
                    {
                        "username": "titanaro_1410",
                        "content": "I don\\'t know why the tag is binary search, but the tags are now updated to Math and Recursion"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "simple recursion and divide and conquer:\nclass Solution(object):\n    def myPow(self, x, n):\n        \"\"\"\n        :type x: float\n        :type n: int\n        :rtype: float\n        \"\"\"\n if n < 0:\n            n = -n\n            x = 1/x\n        if n==1 or n==0:\n            return x**n\n        if n%2:\n            return self.myPow(x, n/2) * self.myPow(x, n/2) * x\n\n        return self.myPow(x, n/2) * self.myPow(x, n/2)\n"
                    },
                    {
                        "username": "ankush920",
                        "content": "100 % fast and easy recurrsive solution :-\\nclass Solution {\\npublic:\\n\\n  double positive( double x ,int n )\\n  {\\n      if( n==0 )\\n      {\\n          return 1.00000;\\n      }\\n\\n      double temp = positive(x ,n/2);\\n\\nif( n%2!=0)\\n{\\n    return temp *temp *x;\\n     \\n}\\n\\nreturn temp*temp ;\\n      \\n  }\\n\\n\\n\\n    double negative( double x ,int n )\\n  {\\n      if( n==0 )\\n      {\\n          return 1.00000;\\n      }\\n\\n      double temp = negative (x ,n/2);\\n\\nif( n%2!=0)\\n{\\n    return (temp *temp *(1/x));\\n     \\n}\\n\\nreturn (temp*temp) ;\\n\\n  }\\n\\n    double myPow(double x, int n) {\\n        \\n        if(n==0)\\n        {\\n             return 1.00000;\\n        }\\n\\n        if(n>0)\\n        {\\n           return positive(x,n);  \\n        }\\n\\nreturn negative( x,n);\\n        \\n    }\\n};\\nConsole\\n"
                    },
                    {
                        "username": "abumdmiran2001",
                        "content": "Test case 301 is out of constraint ,How can I solve that. "
                    },
                    {
                        "username": "c8763yee",
                        "content": "i was wondering why i keep get TLE when (x, n)=(0.00001, 2147483647)\nhere is my code:\n```python\nclass Solution:\n    def myPow(self, x: float, n: int) -> float:\n        if n < 0:\n            n = -n\n            x = 1/x\n\n        if n == 0 or n == 1:\n            return x**n\n        \n        if n%2:\n            return self.myPow(x, n//2) * self.myPow(x, n//2) * x\n\n        return self.myPow(x, n//2) * self.myPow(x, n//2)\n```\nthanks for any advise"
                    },
                    {
                        "username": "Aman9262",
                        "content": "```\\nclass Solution {\\n    map<int,double> dp;\\n    double util(double x, int n) {\\n        if(n==0){\\n            return dp[n]=1;\\n        }\\n        if(dp.find(n)!=dp.end()) {\\n                return dp[n];\\n        }\\n        if(n<0){\\n          if(n%2)\\n           return dp[n]=(1.0/x)*util(x, n/2)*util(x, n/2);\\n         return dp[n]=util(x, n/2)*util(x, n/2);\\n        }\\n        if(n%2)\\n           return dp[n]=x*util(x, n/2)*util(x, n/2);\\n        return dp[n] = util(x, n/2)*util(x, n/2);\\n    }\\npublic:\\n    double myPow(double x, int n) {\\n        return util(x,n);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "Having weird issue in C++. for the test case where n = -2147483648 and x = 2, for whatever reason when I run the compiler here, I get 1, but when I run it in VSCode, I get the correct output."
                    },
                    {
                        "username": "khrome",
                        "content": "Why is this too slow? Shouldn\\'t the second recursive call immediately get the answer from memo, making the whole thing O(logn)? It works fine if instead of doing 2 recursive calls I just square the first one like in the comment. But Im curious why the 2 recursive calls make it slow.\\n\\n\\n    def myPow(self, x: float, n: int) -> float:\\n        memo = {0:1}\\n        def dp(n):\\n            nonlocal memo\\n            if memo.get(n):\\n                return memo[n]\\n            odd = n % 2\\n            answer = dp(n//2) * dp(n//2)\\n            # answer *= answer\\n            if odd:\\n                answer *= x\\n            memo[n] = answer\\n            return answer\\n        dp(abs(n))\\n        if n < 0:\\n            return 1 / float(memo[abs(n)])\\n        return memo[n]"
                    },
                    {
                        "username": "mickeyvn",
                        "content": "You can do in O(1)"
                    }
                ]
            },
            {
                "id": 1782336,
                "content": [
                    {
                        "username": "bishal_722",
                        "content": "Can you solve it in constant time O(1) ? \\nVisit my solution to understand a different approach to this problem.\\n\\nhttps://leetcode.com/problems/powx-n/solutions/3217521/o1-c-solution-explained-with-images/"
                    },
                    {
                        "username": "psionl0",
                        "content": "I\\'m not convinced that behind the hood, log and exp both have O(1) run times."
                    },
                    {
                        "username": "Nitinkushwaha",
                        "content": "code is passing few test cases but on submitting giving runtime error can anyone help me with code\n\n\nclass Solution {\n    public double myPow(double x, int n)\n     {\n    double a;\n     if(n>=0)\n        {\n        if(n==0)\n            return 1;\n         a=x*myPow(x,n-1);\n        \n         }\n         else\n         {\n             if(n==0)\n               return 1;\n              a=(1/x)*(1/(myPow(x,-(n+1))));\n         }\n        \n        return a;\n    }\n    \n}"
                    },
                    {
                        "username": "titanaro_1410",
                        "content": "I don\\'t know why the tag is binary search, but the tags are now updated to Math and Recursion"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "simple recursion and divide and conquer:\nclass Solution(object):\n    def myPow(self, x, n):\n        \"\"\"\n        :type x: float\n        :type n: int\n        :rtype: float\n        \"\"\"\n if n < 0:\n            n = -n\n            x = 1/x\n        if n==1 or n==0:\n            return x**n\n        if n%2:\n            return self.myPow(x, n/2) * self.myPow(x, n/2) * x\n\n        return self.myPow(x, n/2) * self.myPow(x, n/2)\n"
                    },
                    {
                        "username": "ankush920",
                        "content": "100 % fast and easy recurrsive solution :-\\nclass Solution {\\npublic:\\n\\n  double positive( double x ,int n )\\n  {\\n      if( n==0 )\\n      {\\n          return 1.00000;\\n      }\\n\\n      double temp = positive(x ,n/2);\\n\\nif( n%2!=0)\\n{\\n    return temp *temp *x;\\n     \\n}\\n\\nreturn temp*temp ;\\n      \\n  }\\n\\n\\n\\n    double negative( double x ,int n )\\n  {\\n      if( n==0 )\\n      {\\n          return 1.00000;\\n      }\\n\\n      double temp = negative (x ,n/2);\\n\\nif( n%2!=0)\\n{\\n    return (temp *temp *(1/x));\\n     \\n}\\n\\nreturn (temp*temp) ;\\n\\n  }\\n\\n    double myPow(double x, int n) {\\n        \\n        if(n==0)\\n        {\\n             return 1.00000;\\n        }\\n\\n        if(n>0)\\n        {\\n           return positive(x,n);  \\n        }\\n\\nreturn negative( x,n);\\n        \\n    }\\n};\\nConsole\\n"
                    },
                    {
                        "username": "abumdmiran2001",
                        "content": "Test case 301 is out of constraint ,How can I solve that. "
                    },
                    {
                        "username": "c8763yee",
                        "content": "i was wondering why i keep get TLE when (x, n)=(0.00001, 2147483647)\nhere is my code:\n```python\nclass Solution:\n    def myPow(self, x: float, n: int) -> float:\n        if n < 0:\n            n = -n\n            x = 1/x\n\n        if n == 0 or n == 1:\n            return x**n\n        \n        if n%2:\n            return self.myPow(x, n//2) * self.myPow(x, n//2) * x\n\n        return self.myPow(x, n//2) * self.myPow(x, n//2)\n```\nthanks for any advise"
                    },
                    {
                        "username": "Aman9262",
                        "content": "```\\nclass Solution {\\n    map<int,double> dp;\\n    double util(double x, int n) {\\n        if(n==0){\\n            return dp[n]=1;\\n        }\\n        if(dp.find(n)!=dp.end()) {\\n                return dp[n];\\n        }\\n        if(n<0){\\n          if(n%2)\\n           return dp[n]=(1.0/x)*util(x, n/2)*util(x, n/2);\\n         return dp[n]=util(x, n/2)*util(x, n/2);\\n        }\\n        if(n%2)\\n           return dp[n]=x*util(x, n/2)*util(x, n/2);\\n        return dp[n] = util(x, n/2)*util(x, n/2);\\n    }\\npublic:\\n    double myPow(double x, int n) {\\n        return util(x,n);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "Having weird issue in C++. for the test case where n = -2147483648 and x = 2, for whatever reason when I run the compiler here, I get 1, but when I run it in VSCode, I get the correct output."
                    },
                    {
                        "username": "khrome",
                        "content": "Why is this too slow? Shouldn\\'t the second recursive call immediately get the answer from memo, making the whole thing O(logn)? It works fine if instead of doing 2 recursive calls I just square the first one like in the comment. But Im curious why the 2 recursive calls make it slow.\\n\\n\\n    def myPow(self, x: float, n: int) -> float:\\n        memo = {0:1}\\n        def dp(n):\\n            nonlocal memo\\n            if memo.get(n):\\n                return memo[n]\\n            odd = n % 2\\n            answer = dp(n//2) * dp(n//2)\\n            # answer *= answer\\n            if odd:\\n                answer *= x\\n            memo[n] = answer\\n            return answer\\n        dp(abs(n))\\n        if n < 0:\\n            return 1 / float(memo[abs(n)])\\n        return memo[n]"
                    },
                    {
                        "username": "mickeyvn",
                        "content": "You can do in O(1)"
                    }
                ]
            },
            {
                "id": 1780655,
                "content": [
                    {
                        "username": "vanshikasharma4102",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n    if(n==0)\\n        return 1;\\n    if(n==1)\\n        return 1;\\n    double ans = pow(x, n/2);\\n    ans = (ans*ans);\\n    if(n%2!=0)\\n        ans = (ans*x);\\n    return ans;\\n    }\\n};\\nMy code fails for x = 34.00515,n=-3. Could someone please help me out\\n\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Somebody tell me why its wrong answer for following testcase even if the logic and code is correct.\\nx = 2.00000\\nn = -2147483648\\n\\nOutput\\n1.00000\\n\\nExpected\\n0.00000\\n\\n `class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double ans = 1.0;\\n        typedef long double ld;\\n        int nn = n;\\n\\n        if(n < 0){\\n            nn = abs(nn);\\n        }\\n\\n        while(nn > 0){\\n            if(nn%2 == 0){\\n                x = (ld)x*x;\\n                nn /= 2;\\n            }\\n            else{\\n                ans = (ld)ans*x;\\n                nn = nn-1;\\n            }\\n        }   \\n\\n        if(n < 0){\\n            ans = (ld)1/ans;\\n        }\\n\\n        return ans;     \\n    }\\n};`"
                    },
                    {
                        "username": "ammu678",
                        "content": "I am guessing your code is in c++, so I am not sure of int data type size but it is 2 or 4 bytes in c++ , its most probably because of overflow error, the n value in the given testcase is the minimum limit of int size 4 bytes when you convert to positive ,the max positive value is 2147483647 , so because of overflow its getting reset"
                    },
                    {
                        "username": "vaibhav_0911",
                        "content": "if (n==Integer.MAX_VALUE)\\nreturn x;\\nelse if(n==Integer.MIN_VALUE)\\nreturn (x==1 || x==-1) ? 1:0;"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "This question has so many corner cases, no wonder it has more downvotes than upvotes"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "solving with bit manipulation takes logn time but even then it gives TLE\\nwhere I am wrong pls figure out.\\n\\n\\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n     double ans=1;\\n    while(n)\\n    {\\n        if(n&1)\\n        {\\n            ans=ans*x;\\n\\n        }\\n        x=x*x;\\n        n>>=1;\\n    }\\n\\n    return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "RushikaK",
                        "content": "` class Solution {\\n    public double myPow(double x, int n) {\\n        int val = Math.abs(n);\\n        double result = getvalue(x, val);\\n        return n < 0 ? 1/result: result;\\n    }\\n\\n    private double getvalue(double x, int n) {\\n        if( n == 0)\\n            return 1;\\n        double val = getvalue(x, n/2);\\n        if( n %2 == 0) {\\n            return (val * val);\\n        } else {\\n            return (x * val * val);\\n        }\\n    }\\n}`\\n"
                    },
                    {
                        "username": "niteshtiwari17",
                        "content": "Out of 305 this 301th code gives wrong answer  please any one can give hint\n\n2.00000\n-2147483648"
                    },
                    {
                        "username": "shivangi_02",
                        "content": "This is below the condition given -2^31-1 <=n"
                    },
                    {
                        "username": "niteshtiwari17",
                        "content": "how to handle Time Limit Exceeded as a beginner?\nI followed this approach : \nstep 1 : n  isNegative if yes the take absolute value of n \nstep 2 : simply calculating x raised to power using for loop.\nstep 3 : if(n == 0 ) return 1 ;\nstep 4  if n is negative then return 1/res else return res\n\nHow to overcome Time Limit exceeded? \n"
                    },
                    {
                        "username": "ruf99",
                        "content": "Shouldn\\'t we prefer the iterative version here? Must we absolutely insert recursion into a problem that doesn\\'t need it?? This is a simple one line answer, why complicate it unnecessarily? smh"
                    },
                    {
                        "username": "nothingjustacoder",
                        "content": "double result=1;\\n       if(n>0){\\n       for(int i=0;i<n;i++){\\n           result*=x;\\n           }\\n           \\n       }\\n       if(n<0){\\n           n=n*-1;\\n            for(int i=0;i<n;i++){\\n           result*=x;\\n            }\\n            result=1/result;\\n           \\n       }\\n             return result;\\n299/305 litterally got stucked\\nReason for Error=TIme Limit Exceeded"
                    }
                ]
            },
            {
                "id": 1779207,
                "content": [
                    {
                        "username": "vanshikasharma4102",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n    if(n==0)\\n        return 1;\\n    if(n==1)\\n        return 1;\\n    double ans = pow(x, n/2);\\n    ans = (ans*ans);\\n    if(n%2!=0)\\n        ans = (ans*x);\\n    return ans;\\n    }\\n};\\nMy code fails for x = 34.00515,n=-3. Could someone please help me out\\n\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Somebody tell me why its wrong answer for following testcase even if the logic and code is correct.\\nx = 2.00000\\nn = -2147483648\\n\\nOutput\\n1.00000\\n\\nExpected\\n0.00000\\n\\n `class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double ans = 1.0;\\n        typedef long double ld;\\n        int nn = n;\\n\\n        if(n < 0){\\n            nn = abs(nn);\\n        }\\n\\n        while(nn > 0){\\n            if(nn%2 == 0){\\n                x = (ld)x*x;\\n                nn /= 2;\\n            }\\n            else{\\n                ans = (ld)ans*x;\\n                nn = nn-1;\\n            }\\n        }   \\n\\n        if(n < 0){\\n            ans = (ld)1/ans;\\n        }\\n\\n        return ans;     \\n    }\\n};`"
                    },
                    {
                        "username": "ammu678",
                        "content": "I am guessing your code is in c++, so I am not sure of int data type size but it is 2 or 4 bytes in c++ , its most probably because of overflow error, the n value in the given testcase is the minimum limit of int size 4 bytes when you convert to positive ,the max positive value is 2147483647 , so because of overflow its getting reset"
                    },
                    {
                        "username": "vaibhav_0911",
                        "content": "if (n==Integer.MAX_VALUE)\\nreturn x;\\nelse if(n==Integer.MIN_VALUE)\\nreturn (x==1 || x==-1) ? 1:0;"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "This question has so many corner cases, no wonder it has more downvotes than upvotes"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "solving with bit manipulation takes logn time but even then it gives TLE\\nwhere I am wrong pls figure out.\\n\\n\\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n     double ans=1;\\n    while(n)\\n    {\\n        if(n&1)\\n        {\\n            ans=ans*x;\\n\\n        }\\n        x=x*x;\\n        n>>=1;\\n    }\\n\\n    return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "RushikaK",
                        "content": "` class Solution {\\n    public double myPow(double x, int n) {\\n        int val = Math.abs(n);\\n        double result = getvalue(x, val);\\n        return n < 0 ? 1/result: result;\\n    }\\n\\n    private double getvalue(double x, int n) {\\n        if( n == 0)\\n            return 1;\\n        double val = getvalue(x, n/2);\\n        if( n %2 == 0) {\\n            return (val * val);\\n        } else {\\n            return (x * val * val);\\n        }\\n    }\\n}`\\n"
                    },
                    {
                        "username": "niteshtiwari17",
                        "content": "Out of 305 this 301th code gives wrong answer  please any one can give hint\n\n2.00000\n-2147483648"
                    },
                    {
                        "username": "shivangi_02",
                        "content": "This is below the condition given -2^31-1 <=n"
                    },
                    {
                        "username": "niteshtiwari17",
                        "content": "how to handle Time Limit Exceeded as a beginner?\nI followed this approach : \nstep 1 : n  isNegative if yes the take absolute value of n \nstep 2 : simply calculating x raised to power using for loop.\nstep 3 : if(n == 0 ) return 1 ;\nstep 4  if n is negative then return 1/res else return res\n\nHow to overcome Time Limit exceeded? \n"
                    },
                    {
                        "username": "ruf99",
                        "content": "Shouldn\\'t we prefer the iterative version here? Must we absolutely insert recursion into a problem that doesn\\'t need it?? This is a simple one line answer, why complicate it unnecessarily? smh"
                    },
                    {
                        "username": "nothingjustacoder",
                        "content": "double result=1;\\n       if(n>0){\\n       for(int i=0;i<n;i++){\\n           result*=x;\\n           }\\n           \\n       }\\n       if(n<0){\\n           n=n*-1;\\n            for(int i=0;i<n;i++){\\n           result*=x;\\n            }\\n            result=1/result;\\n           \\n       }\\n             return result;\\n299/305 litterally got stucked\\nReason for Error=TIme Limit Exceeded"
                    }
                ]
            },
            {
                "id": 1777072,
                "content": [
                    {
                        "username": "vanshikasharma4102",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n    if(n==0)\\n        return 1;\\n    if(n==1)\\n        return 1;\\n    double ans = pow(x, n/2);\\n    ans = (ans*ans);\\n    if(n%2!=0)\\n        ans = (ans*x);\\n    return ans;\\n    }\\n};\\nMy code fails for x = 34.00515,n=-3. Could someone please help me out\\n\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Somebody tell me why its wrong answer for following testcase even if the logic and code is correct.\\nx = 2.00000\\nn = -2147483648\\n\\nOutput\\n1.00000\\n\\nExpected\\n0.00000\\n\\n `class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double ans = 1.0;\\n        typedef long double ld;\\n        int nn = n;\\n\\n        if(n < 0){\\n            nn = abs(nn);\\n        }\\n\\n        while(nn > 0){\\n            if(nn%2 == 0){\\n                x = (ld)x*x;\\n                nn /= 2;\\n            }\\n            else{\\n                ans = (ld)ans*x;\\n                nn = nn-1;\\n            }\\n        }   \\n\\n        if(n < 0){\\n            ans = (ld)1/ans;\\n        }\\n\\n        return ans;     \\n    }\\n};`"
                    },
                    {
                        "username": "ammu678",
                        "content": "I am guessing your code is in c++, so I am not sure of int data type size but it is 2 or 4 bytes in c++ , its most probably because of overflow error, the n value in the given testcase is the minimum limit of int size 4 bytes when you convert to positive ,the max positive value is 2147483647 , so because of overflow its getting reset"
                    },
                    {
                        "username": "vaibhav_0911",
                        "content": "if (n==Integer.MAX_VALUE)\\nreturn x;\\nelse if(n==Integer.MIN_VALUE)\\nreturn (x==1 || x==-1) ? 1:0;"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "This question has so many corner cases, no wonder it has more downvotes than upvotes"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "solving with bit manipulation takes logn time but even then it gives TLE\\nwhere I am wrong pls figure out.\\n\\n\\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n     double ans=1;\\n    while(n)\\n    {\\n        if(n&1)\\n        {\\n            ans=ans*x;\\n\\n        }\\n        x=x*x;\\n        n>>=1;\\n    }\\n\\n    return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "RushikaK",
                        "content": "` class Solution {\\n    public double myPow(double x, int n) {\\n        int val = Math.abs(n);\\n        double result = getvalue(x, val);\\n        return n < 0 ? 1/result: result;\\n    }\\n\\n    private double getvalue(double x, int n) {\\n        if( n == 0)\\n            return 1;\\n        double val = getvalue(x, n/2);\\n        if( n %2 == 0) {\\n            return (val * val);\\n        } else {\\n            return (x * val * val);\\n        }\\n    }\\n}`\\n"
                    },
                    {
                        "username": "niteshtiwari17",
                        "content": "Out of 305 this 301th code gives wrong answer  please any one can give hint\n\n2.00000\n-2147483648"
                    },
                    {
                        "username": "shivangi_02",
                        "content": "This is below the condition given -2^31-1 <=n"
                    },
                    {
                        "username": "niteshtiwari17",
                        "content": "how to handle Time Limit Exceeded as a beginner?\nI followed this approach : \nstep 1 : n  isNegative if yes the take absolute value of n \nstep 2 : simply calculating x raised to power using for loop.\nstep 3 : if(n == 0 ) return 1 ;\nstep 4  if n is negative then return 1/res else return res\n\nHow to overcome Time Limit exceeded? \n"
                    },
                    {
                        "username": "ruf99",
                        "content": "Shouldn\\'t we prefer the iterative version here? Must we absolutely insert recursion into a problem that doesn\\'t need it?? This is a simple one line answer, why complicate it unnecessarily? smh"
                    },
                    {
                        "username": "nothingjustacoder",
                        "content": "double result=1;\\n       if(n>0){\\n       for(int i=0;i<n;i++){\\n           result*=x;\\n           }\\n           \\n       }\\n       if(n<0){\\n           n=n*-1;\\n            for(int i=0;i<n;i++){\\n           result*=x;\\n            }\\n            result=1/result;\\n           \\n       }\\n             return result;\\n299/305 litterally got stucked\\nReason for Error=TIme Limit Exceeded"
                    }
                ]
            },
            {
                "id": 1767726,
                "content": [
                    {
                        "username": "vanshikasharma4102",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n    if(n==0)\\n        return 1;\\n    if(n==1)\\n        return 1;\\n    double ans = pow(x, n/2);\\n    ans = (ans*ans);\\n    if(n%2!=0)\\n        ans = (ans*x);\\n    return ans;\\n    }\\n};\\nMy code fails for x = 34.00515,n=-3. Could someone please help me out\\n\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Somebody tell me why its wrong answer for following testcase even if the logic and code is correct.\\nx = 2.00000\\nn = -2147483648\\n\\nOutput\\n1.00000\\n\\nExpected\\n0.00000\\n\\n `class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double ans = 1.0;\\n        typedef long double ld;\\n        int nn = n;\\n\\n        if(n < 0){\\n            nn = abs(nn);\\n        }\\n\\n        while(nn > 0){\\n            if(nn%2 == 0){\\n                x = (ld)x*x;\\n                nn /= 2;\\n            }\\n            else{\\n                ans = (ld)ans*x;\\n                nn = nn-1;\\n            }\\n        }   \\n\\n        if(n < 0){\\n            ans = (ld)1/ans;\\n        }\\n\\n        return ans;     \\n    }\\n};`"
                    },
                    {
                        "username": "ammu678",
                        "content": "I am guessing your code is in c++, so I am not sure of int data type size but it is 2 or 4 bytes in c++ , its most probably because of overflow error, the n value in the given testcase is the minimum limit of int size 4 bytes when you convert to positive ,the max positive value is 2147483647 , so because of overflow its getting reset"
                    },
                    {
                        "username": "vaibhav_0911",
                        "content": "if (n==Integer.MAX_VALUE)\\nreturn x;\\nelse if(n==Integer.MIN_VALUE)\\nreturn (x==1 || x==-1) ? 1:0;"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "This question has so many corner cases, no wonder it has more downvotes than upvotes"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "solving with bit manipulation takes logn time but even then it gives TLE\\nwhere I am wrong pls figure out.\\n\\n\\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n     double ans=1;\\n    while(n)\\n    {\\n        if(n&1)\\n        {\\n            ans=ans*x;\\n\\n        }\\n        x=x*x;\\n        n>>=1;\\n    }\\n\\n    return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "RushikaK",
                        "content": "` class Solution {\\n    public double myPow(double x, int n) {\\n        int val = Math.abs(n);\\n        double result = getvalue(x, val);\\n        return n < 0 ? 1/result: result;\\n    }\\n\\n    private double getvalue(double x, int n) {\\n        if( n == 0)\\n            return 1;\\n        double val = getvalue(x, n/2);\\n        if( n %2 == 0) {\\n            return (val * val);\\n        } else {\\n            return (x * val * val);\\n        }\\n    }\\n}`\\n"
                    },
                    {
                        "username": "niteshtiwari17",
                        "content": "Out of 305 this 301th code gives wrong answer  please any one can give hint\n\n2.00000\n-2147483648"
                    },
                    {
                        "username": "shivangi_02",
                        "content": "This is below the condition given -2^31-1 <=n"
                    },
                    {
                        "username": "niteshtiwari17",
                        "content": "how to handle Time Limit Exceeded as a beginner?\nI followed this approach : \nstep 1 : n  isNegative if yes the take absolute value of n \nstep 2 : simply calculating x raised to power using for loop.\nstep 3 : if(n == 0 ) return 1 ;\nstep 4  if n is negative then return 1/res else return res\n\nHow to overcome Time Limit exceeded? \n"
                    },
                    {
                        "username": "ruf99",
                        "content": "Shouldn\\'t we prefer the iterative version here? Must we absolutely insert recursion into a problem that doesn\\'t need it?? This is a simple one line answer, why complicate it unnecessarily? smh"
                    },
                    {
                        "username": "nothingjustacoder",
                        "content": "double result=1;\\n       if(n>0){\\n       for(int i=0;i<n;i++){\\n           result*=x;\\n           }\\n           \\n       }\\n       if(n<0){\\n           n=n*-1;\\n            for(int i=0;i<n;i++){\\n           result*=x;\\n            }\\n            result=1/result;\\n           \\n       }\\n             return result;\\n299/305 litterally got stucked\\nReason for Error=TIme Limit Exceeded"
                    }
                ]
            },
            {
                "id": 1767089,
                "content": [
                    {
                        "username": "vanshikasharma4102",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n    if(n==0)\\n        return 1;\\n    if(n==1)\\n        return 1;\\n    double ans = pow(x, n/2);\\n    ans = (ans*ans);\\n    if(n%2!=0)\\n        ans = (ans*x);\\n    return ans;\\n    }\\n};\\nMy code fails for x = 34.00515,n=-3. Could someone please help me out\\n\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Somebody tell me why its wrong answer for following testcase even if the logic and code is correct.\\nx = 2.00000\\nn = -2147483648\\n\\nOutput\\n1.00000\\n\\nExpected\\n0.00000\\n\\n `class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double ans = 1.0;\\n        typedef long double ld;\\n        int nn = n;\\n\\n        if(n < 0){\\n            nn = abs(nn);\\n        }\\n\\n        while(nn > 0){\\n            if(nn%2 == 0){\\n                x = (ld)x*x;\\n                nn /= 2;\\n            }\\n            else{\\n                ans = (ld)ans*x;\\n                nn = nn-1;\\n            }\\n        }   \\n\\n        if(n < 0){\\n            ans = (ld)1/ans;\\n        }\\n\\n        return ans;     \\n    }\\n};`"
                    },
                    {
                        "username": "ammu678",
                        "content": "I am guessing your code is in c++, so I am not sure of int data type size but it is 2 or 4 bytes in c++ , its most probably because of overflow error, the n value in the given testcase is the minimum limit of int size 4 bytes when you convert to positive ,the max positive value is 2147483647 , so because of overflow its getting reset"
                    },
                    {
                        "username": "vaibhav_0911",
                        "content": "if (n==Integer.MAX_VALUE)\\nreturn x;\\nelse if(n==Integer.MIN_VALUE)\\nreturn (x==1 || x==-1) ? 1:0;"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "This question has so many corner cases, no wonder it has more downvotes than upvotes"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "solving with bit manipulation takes logn time but even then it gives TLE\\nwhere I am wrong pls figure out.\\n\\n\\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n     double ans=1;\\n    while(n)\\n    {\\n        if(n&1)\\n        {\\n            ans=ans*x;\\n\\n        }\\n        x=x*x;\\n        n>>=1;\\n    }\\n\\n    return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "RushikaK",
                        "content": "` class Solution {\\n    public double myPow(double x, int n) {\\n        int val = Math.abs(n);\\n        double result = getvalue(x, val);\\n        return n < 0 ? 1/result: result;\\n    }\\n\\n    private double getvalue(double x, int n) {\\n        if( n == 0)\\n            return 1;\\n        double val = getvalue(x, n/2);\\n        if( n %2 == 0) {\\n            return (val * val);\\n        } else {\\n            return (x * val * val);\\n        }\\n    }\\n}`\\n"
                    },
                    {
                        "username": "niteshtiwari17",
                        "content": "Out of 305 this 301th code gives wrong answer  please any one can give hint\n\n2.00000\n-2147483648"
                    },
                    {
                        "username": "shivangi_02",
                        "content": "This is below the condition given -2^31-1 <=n"
                    },
                    {
                        "username": "niteshtiwari17",
                        "content": "how to handle Time Limit Exceeded as a beginner?\nI followed this approach : \nstep 1 : n  isNegative if yes the take absolute value of n \nstep 2 : simply calculating x raised to power using for loop.\nstep 3 : if(n == 0 ) return 1 ;\nstep 4  if n is negative then return 1/res else return res\n\nHow to overcome Time Limit exceeded? \n"
                    },
                    {
                        "username": "ruf99",
                        "content": "Shouldn\\'t we prefer the iterative version here? Must we absolutely insert recursion into a problem that doesn\\'t need it?? This is a simple one line answer, why complicate it unnecessarily? smh"
                    },
                    {
                        "username": "nothingjustacoder",
                        "content": "double result=1;\\n       if(n>0){\\n       for(int i=0;i<n;i++){\\n           result*=x;\\n           }\\n           \\n       }\\n       if(n<0){\\n           n=n*-1;\\n            for(int i=0;i<n;i++){\\n           result*=x;\\n            }\\n            result=1/result;\\n           \\n       }\\n             return result;\\n299/305 litterally got stucked\\nReason for Error=TIme Limit Exceeded"
                    }
                ]
            },
            {
                "id": 1763605,
                "content": [
                    {
                        "username": "vanshikasharma4102",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n    if(n==0)\\n        return 1;\\n    if(n==1)\\n        return 1;\\n    double ans = pow(x, n/2);\\n    ans = (ans*ans);\\n    if(n%2!=0)\\n        ans = (ans*x);\\n    return ans;\\n    }\\n};\\nMy code fails for x = 34.00515,n=-3. Could someone please help me out\\n\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Somebody tell me why its wrong answer for following testcase even if the logic and code is correct.\\nx = 2.00000\\nn = -2147483648\\n\\nOutput\\n1.00000\\n\\nExpected\\n0.00000\\n\\n `class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double ans = 1.0;\\n        typedef long double ld;\\n        int nn = n;\\n\\n        if(n < 0){\\n            nn = abs(nn);\\n        }\\n\\n        while(nn > 0){\\n            if(nn%2 == 0){\\n                x = (ld)x*x;\\n                nn /= 2;\\n            }\\n            else{\\n                ans = (ld)ans*x;\\n                nn = nn-1;\\n            }\\n        }   \\n\\n        if(n < 0){\\n            ans = (ld)1/ans;\\n        }\\n\\n        return ans;     \\n    }\\n};`"
                    },
                    {
                        "username": "ammu678",
                        "content": "I am guessing your code is in c++, so I am not sure of int data type size but it is 2 or 4 bytes in c++ , its most probably because of overflow error, the n value in the given testcase is the minimum limit of int size 4 bytes when you convert to positive ,the max positive value is 2147483647 , so because of overflow its getting reset"
                    },
                    {
                        "username": "vaibhav_0911",
                        "content": "if (n==Integer.MAX_VALUE)\\nreturn x;\\nelse if(n==Integer.MIN_VALUE)\\nreturn (x==1 || x==-1) ? 1:0;"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "This question has so many corner cases, no wonder it has more downvotes than upvotes"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "solving with bit manipulation takes logn time but even then it gives TLE\\nwhere I am wrong pls figure out.\\n\\n\\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n     double ans=1;\\n    while(n)\\n    {\\n        if(n&1)\\n        {\\n            ans=ans*x;\\n\\n        }\\n        x=x*x;\\n        n>>=1;\\n    }\\n\\n    return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "RushikaK",
                        "content": "` class Solution {\\n    public double myPow(double x, int n) {\\n        int val = Math.abs(n);\\n        double result = getvalue(x, val);\\n        return n < 0 ? 1/result: result;\\n    }\\n\\n    private double getvalue(double x, int n) {\\n        if( n == 0)\\n            return 1;\\n        double val = getvalue(x, n/2);\\n        if( n %2 == 0) {\\n            return (val * val);\\n        } else {\\n            return (x * val * val);\\n        }\\n    }\\n}`\\n"
                    },
                    {
                        "username": "niteshtiwari17",
                        "content": "Out of 305 this 301th code gives wrong answer  please any one can give hint\n\n2.00000\n-2147483648"
                    },
                    {
                        "username": "shivangi_02",
                        "content": "This is below the condition given -2^31-1 <=n"
                    },
                    {
                        "username": "niteshtiwari17",
                        "content": "how to handle Time Limit Exceeded as a beginner?\nI followed this approach : \nstep 1 : n  isNegative if yes the take absolute value of n \nstep 2 : simply calculating x raised to power using for loop.\nstep 3 : if(n == 0 ) return 1 ;\nstep 4  if n is negative then return 1/res else return res\n\nHow to overcome Time Limit exceeded? \n"
                    },
                    {
                        "username": "ruf99",
                        "content": "Shouldn\\'t we prefer the iterative version here? Must we absolutely insert recursion into a problem that doesn\\'t need it?? This is a simple one line answer, why complicate it unnecessarily? smh"
                    },
                    {
                        "username": "nothingjustacoder",
                        "content": "double result=1;\\n       if(n>0){\\n       for(int i=0;i<n;i++){\\n           result*=x;\\n           }\\n           \\n       }\\n       if(n<0){\\n           n=n*-1;\\n            for(int i=0;i<n;i++){\\n           result*=x;\\n            }\\n            result=1/result;\\n           \\n       }\\n             return result;\\n299/305 litterally got stucked\\nReason for Error=TIme Limit Exceeded"
                    }
                ]
            },
            {
                "id": 1762022,
                "content": [
                    {
                        "username": "vanshikasharma4102",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n    if(n==0)\\n        return 1;\\n    if(n==1)\\n        return 1;\\n    double ans = pow(x, n/2);\\n    ans = (ans*ans);\\n    if(n%2!=0)\\n        ans = (ans*x);\\n    return ans;\\n    }\\n};\\nMy code fails for x = 34.00515,n=-3. Could someone please help me out\\n\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Somebody tell me why its wrong answer for following testcase even if the logic and code is correct.\\nx = 2.00000\\nn = -2147483648\\n\\nOutput\\n1.00000\\n\\nExpected\\n0.00000\\n\\n `class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double ans = 1.0;\\n        typedef long double ld;\\n        int nn = n;\\n\\n        if(n < 0){\\n            nn = abs(nn);\\n        }\\n\\n        while(nn > 0){\\n            if(nn%2 == 0){\\n                x = (ld)x*x;\\n                nn /= 2;\\n            }\\n            else{\\n                ans = (ld)ans*x;\\n                nn = nn-1;\\n            }\\n        }   \\n\\n        if(n < 0){\\n            ans = (ld)1/ans;\\n        }\\n\\n        return ans;     \\n    }\\n};`"
                    },
                    {
                        "username": "ammu678",
                        "content": "I am guessing your code is in c++, so I am not sure of int data type size but it is 2 or 4 bytes in c++ , its most probably because of overflow error, the n value in the given testcase is the minimum limit of int size 4 bytes when you convert to positive ,the max positive value is 2147483647 , so because of overflow its getting reset"
                    },
                    {
                        "username": "vaibhav_0911",
                        "content": "if (n==Integer.MAX_VALUE)\\nreturn x;\\nelse if(n==Integer.MIN_VALUE)\\nreturn (x==1 || x==-1) ? 1:0;"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "This question has so many corner cases, no wonder it has more downvotes than upvotes"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "solving with bit manipulation takes logn time but even then it gives TLE\\nwhere I am wrong pls figure out.\\n\\n\\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n     double ans=1;\\n    while(n)\\n    {\\n        if(n&1)\\n        {\\n            ans=ans*x;\\n\\n        }\\n        x=x*x;\\n        n>>=1;\\n    }\\n\\n    return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "RushikaK",
                        "content": "` class Solution {\\n    public double myPow(double x, int n) {\\n        int val = Math.abs(n);\\n        double result = getvalue(x, val);\\n        return n < 0 ? 1/result: result;\\n    }\\n\\n    private double getvalue(double x, int n) {\\n        if( n == 0)\\n            return 1;\\n        double val = getvalue(x, n/2);\\n        if( n %2 == 0) {\\n            return (val * val);\\n        } else {\\n            return (x * val * val);\\n        }\\n    }\\n}`\\n"
                    },
                    {
                        "username": "niteshtiwari17",
                        "content": "Out of 305 this 301th code gives wrong answer  please any one can give hint\n\n2.00000\n-2147483648"
                    },
                    {
                        "username": "shivangi_02",
                        "content": "This is below the condition given -2^31-1 <=n"
                    },
                    {
                        "username": "niteshtiwari17",
                        "content": "how to handle Time Limit Exceeded as a beginner?\nI followed this approach : \nstep 1 : n  isNegative if yes the take absolute value of n \nstep 2 : simply calculating x raised to power using for loop.\nstep 3 : if(n == 0 ) return 1 ;\nstep 4  if n is negative then return 1/res else return res\n\nHow to overcome Time Limit exceeded? \n"
                    },
                    {
                        "username": "ruf99",
                        "content": "Shouldn\\'t we prefer the iterative version here? Must we absolutely insert recursion into a problem that doesn\\'t need it?? This is a simple one line answer, why complicate it unnecessarily? smh"
                    },
                    {
                        "username": "nothingjustacoder",
                        "content": "double result=1;\\n       if(n>0){\\n       for(int i=0;i<n;i++){\\n           result*=x;\\n           }\\n           \\n       }\\n       if(n<0){\\n           n=n*-1;\\n            for(int i=0;i<n;i++){\\n           result*=x;\\n            }\\n            result=1/result;\\n           \\n       }\\n             return result;\\n299/305 litterally got stucked\\nReason for Error=TIme Limit Exceeded"
                    }
                ]
            },
            {
                "id": 1761993,
                "content": [
                    {
                        "username": "vanshikasharma4102",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n    if(n==0)\\n        return 1;\\n    if(n==1)\\n        return 1;\\n    double ans = pow(x, n/2);\\n    ans = (ans*ans);\\n    if(n%2!=0)\\n        ans = (ans*x);\\n    return ans;\\n    }\\n};\\nMy code fails for x = 34.00515,n=-3. Could someone please help me out\\n\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Somebody tell me why its wrong answer for following testcase even if the logic and code is correct.\\nx = 2.00000\\nn = -2147483648\\n\\nOutput\\n1.00000\\n\\nExpected\\n0.00000\\n\\n `class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double ans = 1.0;\\n        typedef long double ld;\\n        int nn = n;\\n\\n        if(n < 0){\\n            nn = abs(nn);\\n        }\\n\\n        while(nn > 0){\\n            if(nn%2 == 0){\\n                x = (ld)x*x;\\n                nn /= 2;\\n            }\\n            else{\\n                ans = (ld)ans*x;\\n                nn = nn-1;\\n            }\\n        }   \\n\\n        if(n < 0){\\n            ans = (ld)1/ans;\\n        }\\n\\n        return ans;     \\n    }\\n};`"
                    },
                    {
                        "username": "ammu678",
                        "content": "I am guessing your code is in c++, so I am not sure of int data type size but it is 2 or 4 bytes in c++ , its most probably because of overflow error, the n value in the given testcase is the minimum limit of int size 4 bytes when you convert to positive ,the max positive value is 2147483647 , so because of overflow its getting reset"
                    },
                    {
                        "username": "vaibhav_0911",
                        "content": "if (n==Integer.MAX_VALUE)\\nreturn x;\\nelse if(n==Integer.MIN_VALUE)\\nreturn (x==1 || x==-1) ? 1:0;"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "This question has so many corner cases, no wonder it has more downvotes than upvotes"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "solving with bit manipulation takes logn time but even then it gives TLE\\nwhere I am wrong pls figure out.\\n\\n\\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n     double ans=1;\\n    while(n)\\n    {\\n        if(n&1)\\n        {\\n            ans=ans*x;\\n\\n        }\\n        x=x*x;\\n        n>>=1;\\n    }\\n\\n    return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "RushikaK",
                        "content": "` class Solution {\\n    public double myPow(double x, int n) {\\n        int val = Math.abs(n);\\n        double result = getvalue(x, val);\\n        return n < 0 ? 1/result: result;\\n    }\\n\\n    private double getvalue(double x, int n) {\\n        if( n == 0)\\n            return 1;\\n        double val = getvalue(x, n/2);\\n        if( n %2 == 0) {\\n            return (val * val);\\n        } else {\\n            return (x * val * val);\\n        }\\n    }\\n}`\\n"
                    },
                    {
                        "username": "niteshtiwari17",
                        "content": "Out of 305 this 301th code gives wrong answer  please any one can give hint\n\n2.00000\n-2147483648"
                    },
                    {
                        "username": "shivangi_02",
                        "content": "This is below the condition given -2^31-1 <=n"
                    },
                    {
                        "username": "niteshtiwari17",
                        "content": "how to handle Time Limit Exceeded as a beginner?\nI followed this approach : \nstep 1 : n  isNegative if yes the take absolute value of n \nstep 2 : simply calculating x raised to power using for loop.\nstep 3 : if(n == 0 ) return 1 ;\nstep 4  if n is negative then return 1/res else return res\n\nHow to overcome Time Limit exceeded? \n"
                    },
                    {
                        "username": "ruf99",
                        "content": "Shouldn\\'t we prefer the iterative version here? Must we absolutely insert recursion into a problem that doesn\\'t need it?? This is a simple one line answer, why complicate it unnecessarily? smh"
                    },
                    {
                        "username": "nothingjustacoder",
                        "content": "double result=1;\\n       if(n>0){\\n       for(int i=0;i<n;i++){\\n           result*=x;\\n           }\\n           \\n       }\\n       if(n<0){\\n           n=n*-1;\\n            for(int i=0;i<n;i++){\\n           result*=x;\\n            }\\n            result=1/result;\\n           \\n       }\\n             return result;\\n299/305 litterally got stucked\\nReason for Error=TIme Limit Exceeded"
                    }
                ]
            },
            {
                "id": 1761164,
                "content": [
                    {
                        "username": "vanshikasharma4102",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n    if(n==0)\\n        return 1;\\n    if(n==1)\\n        return 1;\\n    double ans = pow(x, n/2);\\n    ans = (ans*ans);\\n    if(n%2!=0)\\n        ans = (ans*x);\\n    return ans;\\n    }\\n};\\nMy code fails for x = 34.00515,n=-3. Could someone please help me out\\n\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Somebody tell me why its wrong answer for following testcase even if the logic and code is correct.\\nx = 2.00000\\nn = -2147483648\\n\\nOutput\\n1.00000\\n\\nExpected\\n0.00000\\n\\n `class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double ans = 1.0;\\n        typedef long double ld;\\n        int nn = n;\\n\\n        if(n < 0){\\n            nn = abs(nn);\\n        }\\n\\n        while(nn > 0){\\n            if(nn%2 == 0){\\n                x = (ld)x*x;\\n                nn /= 2;\\n            }\\n            else{\\n                ans = (ld)ans*x;\\n                nn = nn-1;\\n            }\\n        }   \\n\\n        if(n < 0){\\n            ans = (ld)1/ans;\\n        }\\n\\n        return ans;     \\n    }\\n};`"
                    },
                    {
                        "username": "ammu678",
                        "content": "I am guessing your code is in c++, so I am not sure of int data type size but it is 2 or 4 bytes in c++ , its most probably because of overflow error, the n value in the given testcase is the minimum limit of int size 4 bytes when you convert to positive ,the max positive value is 2147483647 , so because of overflow its getting reset"
                    },
                    {
                        "username": "vaibhav_0911",
                        "content": "if (n==Integer.MAX_VALUE)\\nreturn x;\\nelse if(n==Integer.MIN_VALUE)\\nreturn (x==1 || x==-1) ? 1:0;"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "This question has so many corner cases, no wonder it has more downvotes than upvotes"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "solving with bit manipulation takes logn time but even then it gives TLE\\nwhere I am wrong pls figure out.\\n\\n\\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n     double ans=1;\\n    while(n)\\n    {\\n        if(n&1)\\n        {\\n            ans=ans*x;\\n\\n        }\\n        x=x*x;\\n        n>>=1;\\n    }\\n\\n    return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "RushikaK",
                        "content": "` class Solution {\\n    public double myPow(double x, int n) {\\n        int val = Math.abs(n);\\n        double result = getvalue(x, val);\\n        return n < 0 ? 1/result: result;\\n    }\\n\\n    private double getvalue(double x, int n) {\\n        if( n == 0)\\n            return 1;\\n        double val = getvalue(x, n/2);\\n        if( n %2 == 0) {\\n            return (val * val);\\n        } else {\\n            return (x * val * val);\\n        }\\n    }\\n}`\\n"
                    },
                    {
                        "username": "niteshtiwari17",
                        "content": "Out of 305 this 301th code gives wrong answer  please any one can give hint\n\n2.00000\n-2147483648"
                    },
                    {
                        "username": "shivangi_02",
                        "content": "This is below the condition given -2^31-1 <=n"
                    },
                    {
                        "username": "niteshtiwari17",
                        "content": "how to handle Time Limit Exceeded as a beginner?\nI followed this approach : \nstep 1 : n  isNegative if yes the take absolute value of n \nstep 2 : simply calculating x raised to power using for loop.\nstep 3 : if(n == 0 ) return 1 ;\nstep 4  if n is negative then return 1/res else return res\n\nHow to overcome Time Limit exceeded? \n"
                    },
                    {
                        "username": "ruf99",
                        "content": "Shouldn\\'t we prefer the iterative version here? Must we absolutely insert recursion into a problem that doesn\\'t need it?? This is a simple one line answer, why complicate it unnecessarily? smh"
                    },
                    {
                        "username": "nothingjustacoder",
                        "content": "double result=1;\\n       if(n>0){\\n       for(int i=0;i<n;i++){\\n           result*=x;\\n           }\\n           \\n       }\\n       if(n<0){\\n           n=n*-1;\\n            for(int i=0;i<n;i++){\\n           result*=x;\\n            }\\n            result=1/result;\\n           \\n       }\\n             return result;\\n299/305 litterally got stucked\\nReason for Error=TIme Limit Exceeded"
                    }
                ]
            },
            {
                "id": 1760395,
                "content": [
                    {
                        "username": "vanshikasharma4102",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n    if(n==0)\\n        return 1;\\n    if(n==1)\\n        return 1;\\n    double ans = pow(x, n/2);\\n    ans = (ans*ans);\\n    if(n%2!=0)\\n        ans = (ans*x);\\n    return ans;\\n    }\\n};\\nMy code fails for x = 34.00515,n=-3. Could someone please help me out\\n\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Somebody tell me why its wrong answer for following testcase even if the logic and code is correct.\\nx = 2.00000\\nn = -2147483648\\n\\nOutput\\n1.00000\\n\\nExpected\\n0.00000\\n\\n `class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double ans = 1.0;\\n        typedef long double ld;\\n        int nn = n;\\n\\n        if(n < 0){\\n            nn = abs(nn);\\n        }\\n\\n        while(nn > 0){\\n            if(nn%2 == 0){\\n                x = (ld)x*x;\\n                nn /= 2;\\n            }\\n            else{\\n                ans = (ld)ans*x;\\n                nn = nn-1;\\n            }\\n        }   \\n\\n        if(n < 0){\\n            ans = (ld)1/ans;\\n        }\\n\\n        return ans;     \\n    }\\n};`"
                    },
                    {
                        "username": "ammu678",
                        "content": "I am guessing your code is in c++, so I am not sure of int data type size but it is 2 or 4 bytes in c++ , its most probably because of overflow error, the n value in the given testcase is the minimum limit of int size 4 bytes when you convert to positive ,the max positive value is 2147483647 , so because of overflow its getting reset"
                    },
                    {
                        "username": "vaibhav_0911",
                        "content": "if (n==Integer.MAX_VALUE)\\nreturn x;\\nelse if(n==Integer.MIN_VALUE)\\nreturn (x==1 || x==-1) ? 1:0;"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "This question has so many corner cases, no wonder it has more downvotes than upvotes"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "solving with bit manipulation takes logn time but even then it gives TLE\\nwhere I am wrong pls figure out.\\n\\n\\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n     double ans=1;\\n    while(n)\\n    {\\n        if(n&1)\\n        {\\n            ans=ans*x;\\n\\n        }\\n        x=x*x;\\n        n>>=1;\\n    }\\n\\n    return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "RushikaK",
                        "content": "` class Solution {\\n    public double myPow(double x, int n) {\\n        int val = Math.abs(n);\\n        double result = getvalue(x, val);\\n        return n < 0 ? 1/result: result;\\n    }\\n\\n    private double getvalue(double x, int n) {\\n        if( n == 0)\\n            return 1;\\n        double val = getvalue(x, n/2);\\n        if( n %2 == 0) {\\n            return (val * val);\\n        } else {\\n            return (x * val * val);\\n        }\\n    }\\n}`\\n"
                    },
                    {
                        "username": "niteshtiwari17",
                        "content": "Out of 305 this 301th code gives wrong answer  please any one can give hint\n\n2.00000\n-2147483648"
                    },
                    {
                        "username": "shivangi_02",
                        "content": "This is below the condition given -2^31-1 <=n"
                    },
                    {
                        "username": "niteshtiwari17",
                        "content": "how to handle Time Limit Exceeded as a beginner?\nI followed this approach : \nstep 1 : n  isNegative if yes the take absolute value of n \nstep 2 : simply calculating x raised to power using for loop.\nstep 3 : if(n == 0 ) return 1 ;\nstep 4  if n is negative then return 1/res else return res\n\nHow to overcome Time Limit exceeded? \n"
                    },
                    {
                        "username": "ruf99",
                        "content": "Shouldn\\'t we prefer the iterative version here? Must we absolutely insert recursion into a problem that doesn\\'t need it?? This is a simple one line answer, why complicate it unnecessarily? smh"
                    },
                    {
                        "username": "nothingjustacoder",
                        "content": "double result=1;\\n       if(n>0){\\n       for(int i=0;i<n;i++){\\n           result*=x;\\n           }\\n           \\n       }\\n       if(n<0){\\n           n=n*-1;\\n            for(int i=0;i<n;i++){\\n           result*=x;\\n            }\\n            result=1/result;\\n           \\n       }\\n             return result;\\n299/305 litterally got stucked\\nReason for Error=TIme Limit Exceeded"
                    }
                ]
            },
            {
                "id": 1758854,
                "content": [
                    {
                        "username": "umanggcoder",
                        "content": "Time Limit Exceeded\\nLast Executed Input\\n299 / 305 testcases passed\\nx =\\n1.00000\\nn =\\n2147483647\\ncan anyone please tell me why i am getting tle ?"
                    },
                    {
                        "username": "ritesh1224",
                        "content": "double ans = Math.pow(x,n);\\n             return ans;"
                    },
                    {
                        "username": "levi_kapil",
                        "content": "So firstly i code my code run 301 case out 305 i made condition after running test case so finally this one is my final code of C++ \\n\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double t = x; \\n    if(x==1)\\n    {\\n        return 1; \\n    }\\n    if(x==0 )\\n    {\\n        return 0 ; \\n    }\\n\\n   if (x>1.0 && n<-2147483647) \\n   {return 0;\\n   }\\n    if(x==-1)\\n    {\\n        if(n%2==0)\\n        {\\n        return 1; }\\n        else\\n        {\\n            return -1; \\n        }\\n\\n    }\\n\\n        if(n>0){\\n        for(int i=1; i<n; i++)\\n        {\\n            x= x*t; \\n        }\\n        }\\n        else if(n==0)\\n    \\n    {\\n        return 1; \\n    }\\n        else\\n        {\\n            for (int i = 1; i>n; i--)\\n            {  x = x/t; \\n            } \\n        } \\n        return x; \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "This happens to me in almost every medium/hard difficulty question that I attempt. In this one, I am able to get 299/305 testcases correctly, but there are some corner cases which I cannot figure out any solution for."
                    },
                    {
                        "username": "YaJohny",
                        "content": "Who knows how to fix 291 testcase\nTime Limit Exceed\nx = 0.00001\nn = 10 digit number"
                    },
                    {
                        "username": "homesomerset",
                        "content": "just got passed with a solution in java that use pretty interesting bit operations. one hint..., every n is represented in binary mode on a computer. let\\'s say n= 10, it\\'s actually 1010 in binary. it basically means 2^3 + 2^1 = 10. 2^1 means x*x, 2^3 means ret = x*x, and ret = ret*ret, then again re= ret*ret. it\\'s basically worst case 496 multiplies. best case 1 or 2 multiplies. it\\'s O(1) with no risk of stack overflow, and corner case free. "
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "Here is my Easy Brute force solution But its last 6 TC are failing\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double res=0;\\n        if(n==0) return 1;\\n        if(n>0)\\n        {\\n            double temp = x;\\n            for(int i=1;i<n;i++)\\n            {\\n                temp=temp*x;\\n            }\\n            res = temp;\\n        }\\n        if(n<0)\\n        {\\n            double temp = x;\\n            for(int i=1;i<abs(n);i++)\\n            {\\n                temp=temp*x;\\n            }\\n            res = 1/temp;\\n        }\\n        return res;\\n    }\\n};\\n\\nCould anyone correct this brute force so It can be accepted? \\n\\nUpvote Please"
                    },
                    {
                        "username": "noorpinger",
                        "content": "says 305/305 cases passed but won\\'t let me submit because it says time limit exceeded \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Sushant_012003",
                        "content": "Its pretty easy \\nreturn pow(x, n) and done as simple as that\\ntime Complexity O(1)"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding why for my below code i am getting \"maximum recursion depth exceeded\" for x=0.00001 and n=2147483647\\n```\\n    def myPow(self, x: float, n: int) -> float:\\n        if n==0:\\n            return 1\\n        return x*self.myPow(x,n-1) if n>0 else self.myPow(x,n+1)/x\\n```\\nBut the below code seems to work fine\\n```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:      \\n\\n        if n==0:\\n            return 1\\n\\n        if n < 0:\\n            x = 1/x\\n            n = -n\\n\\n        return x*pow(x,n-1)\\n```\\n\\nLogically both are almost kind of same but then why the difference in execution"
                    }
                ]
            },
            {
                "id": 1758030,
                "content": [
                    {
                        "username": "umanggcoder",
                        "content": "Time Limit Exceeded\\nLast Executed Input\\n299 / 305 testcases passed\\nx =\\n1.00000\\nn =\\n2147483647\\ncan anyone please tell me why i am getting tle ?"
                    },
                    {
                        "username": "ritesh1224",
                        "content": "double ans = Math.pow(x,n);\\n             return ans;"
                    },
                    {
                        "username": "levi_kapil",
                        "content": "So firstly i code my code run 301 case out 305 i made condition after running test case so finally this one is my final code of C++ \\n\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double t = x; \\n    if(x==1)\\n    {\\n        return 1; \\n    }\\n    if(x==0 )\\n    {\\n        return 0 ; \\n    }\\n\\n   if (x>1.0 && n<-2147483647) \\n   {return 0;\\n   }\\n    if(x==-1)\\n    {\\n        if(n%2==0)\\n        {\\n        return 1; }\\n        else\\n        {\\n            return -1; \\n        }\\n\\n    }\\n\\n        if(n>0){\\n        for(int i=1; i<n; i++)\\n        {\\n            x= x*t; \\n        }\\n        }\\n        else if(n==0)\\n    \\n    {\\n        return 1; \\n    }\\n        else\\n        {\\n            for (int i = 1; i>n; i--)\\n            {  x = x/t; \\n            } \\n        } \\n        return x; \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "This happens to me in almost every medium/hard difficulty question that I attempt. In this one, I am able to get 299/305 testcases correctly, but there are some corner cases which I cannot figure out any solution for."
                    },
                    {
                        "username": "YaJohny",
                        "content": "Who knows how to fix 291 testcase\nTime Limit Exceed\nx = 0.00001\nn = 10 digit number"
                    },
                    {
                        "username": "homesomerset",
                        "content": "just got passed with a solution in java that use pretty interesting bit operations. one hint..., every n is represented in binary mode on a computer. let\\'s say n= 10, it\\'s actually 1010 in binary. it basically means 2^3 + 2^1 = 10. 2^1 means x*x, 2^3 means ret = x*x, and ret = ret*ret, then again re= ret*ret. it\\'s basically worst case 496 multiplies. best case 1 or 2 multiplies. it\\'s O(1) with no risk of stack overflow, and corner case free. "
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "Here is my Easy Brute force solution But its last 6 TC are failing\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double res=0;\\n        if(n==0) return 1;\\n        if(n>0)\\n        {\\n            double temp = x;\\n            for(int i=1;i<n;i++)\\n            {\\n                temp=temp*x;\\n            }\\n            res = temp;\\n        }\\n        if(n<0)\\n        {\\n            double temp = x;\\n            for(int i=1;i<abs(n);i++)\\n            {\\n                temp=temp*x;\\n            }\\n            res = 1/temp;\\n        }\\n        return res;\\n    }\\n};\\n\\nCould anyone correct this brute force so It can be accepted? \\n\\nUpvote Please"
                    },
                    {
                        "username": "noorpinger",
                        "content": "says 305/305 cases passed but won\\'t let me submit because it says time limit exceeded \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Sushant_012003",
                        "content": "Its pretty easy \\nreturn pow(x, n) and done as simple as that\\ntime Complexity O(1)"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding why for my below code i am getting \"maximum recursion depth exceeded\" for x=0.00001 and n=2147483647\\n```\\n    def myPow(self, x: float, n: int) -> float:\\n        if n==0:\\n            return 1\\n        return x*self.myPow(x,n-1) if n>0 else self.myPow(x,n+1)/x\\n```\\nBut the below code seems to work fine\\n```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:      \\n\\n        if n==0:\\n            return 1\\n\\n        if n < 0:\\n            x = 1/x\\n            n = -n\\n\\n        return x*pow(x,n-1)\\n```\\n\\nLogically both are almost kind of same but then why the difference in execution"
                    }
                ]
            },
            {
                "id": 1754570,
                "content": [
                    {
                        "username": "umanggcoder",
                        "content": "Time Limit Exceeded\\nLast Executed Input\\n299 / 305 testcases passed\\nx =\\n1.00000\\nn =\\n2147483647\\ncan anyone please tell me why i am getting tle ?"
                    },
                    {
                        "username": "ritesh1224",
                        "content": "double ans = Math.pow(x,n);\\n             return ans;"
                    },
                    {
                        "username": "levi_kapil",
                        "content": "So firstly i code my code run 301 case out 305 i made condition after running test case so finally this one is my final code of C++ \\n\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double t = x; \\n    if(x==1)\\n    {\\n        return 1; \\n    }\\n    if(x==0 )\\n    {\\n        return 0 ; \\n    }\\n\\n   if (x>1.0 && n<-2147483647) \\n   {return 0;\\n   }\\n    if(x==-1)\\n    {\\n        if(n%2==0)\\n        {\\n        return 1; }\\n        else\\n        {\\n            return -1; \\n        }\\n\\n    }\\n\\n        if(n>0){\\n        for(int i=1; i<n; i++)\\n        {\\n            x= x*t; \\n        }\\n        }\\n        else if(n==0)\\n    \\n    {\\n        return 1; \\n    }\\n        else\\n        {\\n            for (int i = 1; i>n; i--)\\n            {  x = x/t; \\n            } \\n        } \\n        return x; \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "This happens to me in almost every medium/hard difficulty question that I attempt. In this one, I am able to get 299/305 testcases correctly, but there are some corner cases which I cannot figure out any solution for."
                    },
                    {
                        "username": "YaJohny",
                        "content": "Who knows how to fix 291 testcase\nTime Limit Exceed\nx = 0.00001\nn = 10 digit number"
                    },
                    {
                        "username": "homesomerset",
                        "content": "just got passed with a solution in java that use pretty interesting bit operations. one hint..., every n is represented in binary mode on a computer. let\\'s say n= 10, it\\'s actually 1010 in binary. it basically means 2^3 + 2^1 = 10. 2^1 means x*x, 2^3 means ret = x*x, and ret = ret*ret, then again re= ret*ret. it\\'s basically worst case 496 multiplies. best case 1 or 2 multiplies. it\\'s O(1) with no risk of stack overflow, and corner case free. "
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "Here is my Easy Brute force solution But its last 6 TC are failing\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double res=0;\\n        if(n==0) return 1;\\n        if(n>0)\\n        {\\n            double temp = x;\\n            for(int i=1;i<n;i++)\\n            {\\n                temp=temp*x;\\n            }\\n            res = temp;\\n        }\\n        if(n<0)\\n        {\\n            double temp = x;\\n            for(int i=1;i<abs(n);i++)\\n            {\\n                temp=temp*x;\\n            }\\n            res = 1/temp;\\n        }\\n        return res;\\n    }\\n};\\n\\nCould anyone correct this brute force so It can be accepted? \\n\\nUpvote Please"
                    },
                    {
                        "username": "noorpinger",
                        "content": "says 305/305 cases passed but won\\'t let me submit because it says time limit exceeded \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Sushant_012003",
                        "content": "Its pretty easy \\nreturn pow(x, n) and done as simple as that\\ntime Complexity O(1)"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding why for my below code i am getting \"maximum recursion depth exceeded\" for x=0.00001 and n=2147483647\\n```\\n    def myPow(self, x: float, n: int) -> float:\\n        if n==0:\\n            return 1\\n        return x*self.myPow(x,n-1) if n>0 else self.myPow(x,n+1)/x\\n```\\nBut the below code seems to work fine\\n```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:      \\n\\n        if n==0:\\n            return 1\\n\\n        if n < 0:\\n            x = 1/x\\n            n = -n\\n\\n        return x*pow(x,n-1)\\n```\\n\\nLogically both are almost kind of same but then why the difference in execution"
                    }
                ]
            },
            {
                "id": 1753795,
                "content": [
                    {
                        "username": "umanggcoder",
                        "content": "Time Limit Exceeded\\nLast Executed Input\\n299 / 305 testcases passed\\nx =\\n1.00000\\nn =\\n2147483647\\ncan anyone please tell me why i am getting tle ?"
                    },
                    {
                        "username": "ritesh1224",
                        "content": "double ans = Math.pow(x,n);\\n             return ans;"
                    },
                    {
                        "username": "levi_kapil",
                        "content": "So firstly i code my code run 301 case out 305 i made condition after running test case so finally this one is my final code of C++ \\n\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double t = x; \\n    if(x==1)\\n    {\\n        return 1; \\n    }\\n    if(x==0 )\\n    {\\n        return 0 ; \\n    }\\n\\n   if (x>1.0 && n<-2147483647) \\n   {return 0;\\n   }\\n    if(x==-1)\\n    {\\n        if(n%2==0)\\n        {\\n        return 1; }\\n        else\\n        {\\n            return -1; \\n        }\\n\\n    }\\n\\n        if(n>0){\\n        for(int i=1; i<n; i++)\\n        {\\n            x= x*t; \\n        }\\n        }\\n        else if(n==0)\\n    \\n    {\\n        return 1; \\n    }\\n        else\\n        {\\n            for (int i = 1; i>n; i--)\\n            {  x = x/t; \\n            } \\n        } \\n        return x; \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "This happens to me in almost every medium/hard difficulty question that I attempt. In this one, I am able to get 299/305 testcases correctly, but there are some corner cases which I cannot figure out any solution for."
                    },
                    {
                        "username": "YaJohny",
                        "content": "Who knows how to fix 291 testcase\nTime Limit Exceed\nx = 0.00001\nn = 10 digit number"
                    },
                    {
                        "username": "homesomerset",
                        "content": "just got passed with a solution in java that use pretty interesting bit operations. one hint..., every n is represented in binary mode on a computer. let\\'s say n= 10, it\\'s actually 1010 in binary. it basically means 2^3 + 2^1 = 10. 2^1 means x*x, 2^3 means ret = x*x, and ret = ret*ret, then again re= ret*ret. it\\'s basically worst case 496 multiplies. best case 1 or 2 multiplies. it\\'s O(1) with no risk of stack overflow, and corner case free. "
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "Here is my Easy Brute force solution But its last 6 TC are failing\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double res=0;\\n        if(n==0) return 1;\\n        if(n>0)\\n        {\\n            double temp = x;\\n            for(int i=1;i<n;i++)\\n            {\\n                temp=temp*x;\\n            }\\n            res = temp;\\n        }\\n        if(n<0)\\n        {\\n            double temp = x;\\n            for(int i=1;i<abs(n);i++)\\n            {\\n                temp=temp*x;\\n            }\\n            res = 1/temp;\\n        }\\n        return res;\\n    }\\n};\\n\\nCould anyone correct this brute force so It can be accepted? \\n\\nUpvote Please"
                    },
                    {
                        "username": "noorpinger",
                        "content": "says 305/305 cases passed but won\\'t let me submit because it says time limit exceeded \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Sushant_012003",
                        "content": "Its pretty easy \\nreturn pow(x, n) and done as simple as that\\ntime Complexity O(1)"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding why for my below code i am getting \"maximum recursion depth exceeded\" for x=0.00001 and n=2147483647\\n```\\n    def myPow(self, x: float, n: int) -> float:\\n        if n==0:\\n            return 1\\n        return x*self.myPow(x,n-1) if n>0 else self.myPow(x,n+1)/x\\n```\\nBut the below code seems to work fine\\n```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:      \\n\\n        if n==0:\\n            return 1\\n\\n        if n < 0:\\n            x = 1/x\\n            n = -n\\n\\n        return x*pow(x,n-1)\\n```\\n\\nLogically both are almost kind of same but then why the difference in execution"
                    }
                ]
            },
            {
                "id": 1752307,
                "content": [
                    {
                        "username": "umanggcoder",
                        "content": "Time Limit Exceeded\\nLast Executed Input\\n299 / 305 testcases passed\\nx =\\n1.00000\\nn =\\n2147483647\\ncan anyone please tell me why i am getting tle ?"
                    },
                    {
                        "username": "ritesh1224",
                        "content": "double ans = Math.pow(x,n);\\n             return ans;"
                    },
                    {
                        "username": "levi_kapil",
                        "content": "So firstly i code my code run 301 case out 305 i made condition after running test case so finally this one is my final code of C++ \\n\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double t = x; \\n    if(x==1)\\n    {\\n        return 1; \\n    }\\n    if(x==0 )\\n    {\\n        return 0 ; \\n    }\\n\\n   if (x>1.0 && n<-2147483647) \\n   {return 0;\\n   }\\n    if(x==-1)\\n    {\\n        if(n%2==0)\\n        {\\n        return 1; }\\n        else\\n        {\\n            return -1; \\n        }\\n\\n    }\\n\\n        if(n>0){\\n        for(int i=1; i<n; i++)\\n        {\\n            x= x*t; \\n        }\\n        }\\n        else if(n==0)\\n    \\n    {\\n        return 1; \\n    }\\n        else\\n        {\\n            for (int i = 1; i>n; i--)\\n            {  x = x/t; \\n            } \\n        } \\n        return x; \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "This happens to me in almost every medium/hard difficulty question that I attempt. In this one, I am able to get 299/305 testcases correctly, but there are some corner cases which I cannot figure out any solution for."
                    },
                    {
                        "username": "YaJohny",
                        "content": "Who knows how to fix 291 testcase\nTime Limit Exceed\nx = 0.00001\nn = 10 digit number"
                    },
                    {
                        "username": "homesomerset",
                        "content": "just got passed with a solution in java that use pretty interesting bit operations. one hint..., every n is represented in binary mode on a computer. let\\'s say n= 10, it\\'s actually 1010 in binary. it basically means 2^3 + 2^1 = 10. 2^1 means x*x, 2^3 means ret = x*x, and ret = ret*ret, then again re= ret*ret. it\\'s basically worst case 496 multiplies. best case 1 or 2 multiplies. it\\'s O(1) with no risk of stack overflow, and corner case free. "
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "Here is my Easy Brute force solution But its last 6 TC are failing\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double res=0;\\n        if(n==0) return 1;\\n        if(n>0)\\n        {\\n            double temp = x;\\n            for(int i=1;i<n;i++)\\n            {\\n                temp=temp*x;\\n            }\\n            res = temp;\\n        }\\n        if(n<0)\\n        {\\n            double temp = x;\\n            for(int i=1;i<abs(n);i++)\\n            {\\n                temp=temp*x;\\n            }\\n            res = 1/temp;\\n        }\\n        return res;\\n    }\\n};\\n\\nCould anyone correct this brute force so It can be accepted? \\n\\nUpvote Please"
                    },
                    {
                        "username": "noorpinger",
                        "content": "says 305/305 cases passed but won\\'t let me submit because it says time limit exceeded \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Sushant_012003",
                        "content": "Its pretty easy \\nreturn pow(x, n) and done as simple as that\\ntime Complexity O(1)"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding why for my below code i am getting \"maximum recursion depth exceeded\" for x=0.00001 and n=2147483647\\n```\\n    def myPow(self, x: float, n: int) -> float:\\n        if n==0:\\n            return 1\\n        return x*self.myPow(x,n-1) if n>0 else self.myPow(x,n+1)/x\\n```\\nBut the below code seems to work fine\\n```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:      \\n\\n        if n==0:\\n            return 1\\n\\n        if n < 0:\\n            x = 1/x\\n            n = -n\\n\\n        return x*pow(x,n-1)\\n```\\n\\nLogically both are almost kind of same but then why the difference in execution"
                    }
                ]
            },
            {
                "id": 1752129,
                "content": [
                    {
                        "username": "umanggcoder",
                        "content": "Time Limit Exceeded\\nLast Executed Input\\n299 / 305 testcases passed\\nx =\\n1.00000\\nn =\\n2147483647\\ncan anyone please tell me why i am getting tle ?"
                    },
                    {
                        "username": "ritesh1224",
                        "content": "double ans = Math.pow(x,n);\\n             return ans;"
                    },
                    {
                        "username": "levi_kapil",
                        "content": "So firstly i code my code run 301 case out 305 i made condition after running test case so finally this one is my final code of C++ \\n\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double t = x; \\n    if(x==1)\\n    {\\n        return 1; \\n    }\\n    if(x==0 )\\n    {\\n        return 0 ; \\n    }\\n\\n   if (x>1.0 && n<-2147483647) \\n   {return 0;\\n   }\\n    if(x==-1)\\n    {\\n        if(n%2==0)\\n        {\\n        return 1; }\\n        else\\n        {\\n            return -1; \\n        }\\n\\n    }\\n\\n        if(n>0){\\n        for(int i=1; i<n; i++)\\n        {\\n            x= x*t; \\n        }\\n        }\\n        else if(n==0)\\n    \\n    {\\n        return 1; \\n    }\\n        else\\n        {\\n            for (int i = 1; i>n; i--)\\n            {  x = x/t; \\n            } \\n        } \\n        return x; \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "This happens to me in almost every medium/hard difficulty question that I attempt. In this one, I am able to get 299/305 testcases correctly, but there are some corner cases which I cannot figure out any solution for."
                    },
                    {
                        "username": "YaJohny",
                        "content": "Who knows how to fix 291 testcase\nTime Limit Exceed\nx = 0.00001\nn = 10 digit number"
                    },
                    {
                        "username": "homesomerset",
                        "content": "just got passed with a solution in java that use pretty interesting bit operations. one hint..., every n is represented in binary mode on a computer. let\\'s say n= 10, it\\'s actually 1010 in binary. it basically means 2^3 + 2^1 = 10. 2^1 means x*x, 2^3 means ret = x*x, and ret = ret*ret, then again re= ret*ret. it\\'s basically worst case 496 multiplies. best case 1 or 2 multiplies. it\\'s O(1) with no risk of stack overflow, and corner case free. "
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "Here is my Easy Brute force solution But its last 6 TC are failing\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double res=0;\\n        if(n==0) return 1;\\n        if(n>0)\\n        {\\n            double temp = x;\\n            for(int i=1;i<n;i++)\\n            {\\n                temp=temp*x;\\n            }\\n            res = temp;\\n        }\\n        if(n<0)\\n        {\\n            double temp = x;\\n            for(int i=1;i<abs(n);i++)\\n            {\\n                temp=temp*x;\\n            }\\n            res = 1/temp;\\n        }\\n        return res;\\n    }\\n};\\n\\nCould anyone correct this brute force so It can be accepted? \\n\\nUpvote Please"
                    },
                    {
                        "username": "noorpinger",
                        "content": "says 305/305 cases passed but won\\'t let me submit because it says time limit exceeded \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Sushant_012003",
                        "content": "Its pretty easy \\nreturn pow(x, n) and done as simple as that\\ntime Complexity O(1)"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding why for my below code i am getting \"maximum recursion depth exceeded\" for x=0.00001 and n=2147483647\\n```\\n    def myPow(self, x: float, n: int) -> float:\\n        if n==0:\\n            return 1\\n        return x*self.myPow(x,n-1) if n>0 else self.myPow(x,n+1)/x\\n```\\nBut the below code seems to work fine\\n```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:      \\n\\n        if n==0:\\n            return 1\\n\\n        if n < 0:\\n            x = 1/x\\n            n = -n\\n\\n        return x*pow(x,n-1)\\n```\\n\\nLogically both are almost kind of same but then why the difference in execution"
                    }
                ]
            },
            {
                "id": 1749364,
                "content": [
                    {
                        "username": "umanggcoder",
                        "content": "Time Limit Exceeded\\nLast Executed Input\\n299 / 305 testcases passed\\nx =\\n1.00000\\nn =\\n2147483647\\ncan anyone please tell me why i am getting tle ?"
                    },
                    {
                        "username": "ritesh1224",
                        "content": "double ans = Math.pow(x,n);\\n             return ans;"
                    },
                    {
                        "username": "levi_kapil",
                        "content": "So firstly i code my code run 301 case out 305 i made condition after running test case so finally this one is my final code of C++ \\n\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double t = x; \\n    if(x==1)\\n    {\\n        return 1; \\n    }\\n    if(x==0 )\\n    {\\n        return 0 ; \\n    }\\n\\n   if (x>1.0 && n<-2147483647) \\n   {return 0;\\n   }\\n    if(x==-1)\\n    {\\n        if(n%2==0)\\n        {\\n        return 1; }\\n        else\\n        {\\n            return -1; \\n        }\\n\\n    }\\n\\n        if(n>0){\\n        for(int i=1; i<n; i++)\\n        {\\n            x= x*t; \\n        }\\n        }\\n        else if(n==0)\\n    \\n    {\\n        return 1; \\n    }\\n        else\\n        {\\n            for (int i = 1; i>n; i--)\\n            {  x = x/t; \\n            } \\n        } \\n        return x; \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "This happens to me in almost every medium/hard difficulty question that I attempt. In this one, I am able to get 299/305 testcases correctly, but there are some corner cases which I cannot figure out any solution for."
                    },
                    {
                        "username": "YaJohny",
                        "content": "Who knows how to fix 291 testcase\nTime Limit Exceed\nx = 0.00001\nn = 10 digit number"
                    },
                    {
                        "username": "homesomerset",
                        "content": "just got passed with a solution in java that use pretty interesting bit operations. one hint..., every n is represented in binary mode on a computer. let\\'s say n= 10, it\\'s actually 1010 in binary. it basically means 2^3 + 2^1 = 10. 2^1 means x*x, 2^3 means ret = x*x, and ret = ret*ret, then again re= ret*ret. it\\'s basically worst case 496 multiplies. best case 1 or 2 multiplies. it\\'s O(1) with no risk of stack overflow, and corner case free. "
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "Here is my Easy Brute force solution But its last 6 TC are failing\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double res=0;\\n        if(n==0) return 1;\\n        if(n>0)\\n        {\\n            double temp = x;\\n            for(int i=1;i<n;i++)\\n            {\\n                temp=temp*x;\\n            }\\n            res = temp;\\n        }\\n        if(n<0)\\n        {\\n            double temp = x;\\n            for(int i=1;i<abs(n);i++)\\n            {\\n                temp=temp*x;\\n            }\\n            res = 1/temp;\\n        }\\n        return res;\\n    }\\n};\\n\\nCould anyone correct this brute force so It can be accepted? \\n\\nUpvote Please"
                    },
                    {
                        "username": "noorpinger",
                        "content": "says 305/305 cases passed but won\\'t let me submit because it says time limit exceeded \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Sushant_012003",
                        "content": "Its pretty easy \\nreturn pow(x, n) and done as simple as that\\ntime Complexity O(1)"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding why for my below code i am getting \"maximum recursion depth exceeded\" for x=0.00001 and n=2147483647\\n```\\n    def myPow(self, x: float, n: int) -> float:\\n        if n==0:\\n            return 1\\n        return x*self.myPow(x,n-1) if n>0 else self.myPow(x,n+1)/x\\n```\\nBut the below code seems to work fine\\n```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:      \\n\\n        if n==0:\\n            return 1\\n\\n        if n < 0:\\n            x = 1/x\\n            n = -n\\n\\n        return x*pow(x,n-1)\\n```\\n\\nLogically both are almost kind of same but then why the difference in execution"
                    }
                ]
            },
            {
                "id": 1745478,
                "content": [
                    {
                        "username": "umanggcoder",
                        "content": "Time Limit Exceeded\\nLast Executed Input\\n299 / 305 testcases passed\\nx =\\n1.00000\\nn =\\n2147483647\\ncan anyone please tell me why i am getting tle ?"
                    },
                    {
                        "username": "ritesh1224",
                        "content": "double ans = Math.pow(x,n);\\n             return ans;"
                    },
                    {
                        "username": "levi_kapil",
                        "content": "So firstly i code my code run 301 case out 305 i made condition after running test case so finally this one is my final code of C++ \\n\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double t = x; \\n    if(x==1)\\n    {\\n        return 1; \\n    }\\n    if(x==0 )\\n    {\\n        return 0 ; \\n    }\\n\\n   if (x>1.0 && n<-2147483647) \\n   {return 0;\\n   }\\n    if(x==-1)\\n    {\\n        if(n%2==0)\\n        {\\n        return 1; }\\n        else\\n        {\\n            return -1; \\n        }\\n\\n    }\\n\\n        if(n>0){\\n        for(int i=1; i<n; i++)\\n        {\\n            x= x*t; \\n        }\\n        }\\n        else if(n==0)\\n    \\n    {\\n        return 1; \\n    }\\n        else\\n        {\\n            for (int i = 1; i>n; i--)\\n            {  x = x/t; \\n            } \\n        } \\n        return x; \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "This happens to me in almost every medium/hard difficulty question that I attempt. In this one, I am able to get 299/305 testcases correctly, but there are some corner cases which I cannot figure out any solution for."
                    },
                    {
                        "username": "YaJohny",
                        "content": "Who knows how to fix 291 testcase\nTime Limit Exceed\nx = 0.00001\nn = 10 digit number"
                    },
                    {
                        "username": "homesomerset",
                        "content": "just got passed with a solution in java that use pretty interesting bit operations. one hint..., every n is represented in binary mode on a computer. let\\'s say n= 10, it\\'s actually 1010 in binary. it basically means 2^3 + 2^1 = 10. 2^1 means x*x, 2^3 means ret = x*x, and ret = ret*ret, then again re= ret*ret. it\\'s basically worst case 496 multiplies. best case 1 or 2 multiplies. it\\'s O(1) with no risk of stack overflow, and corner case free. "
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "Here is my Easy Brute force solution But its last 6 TC are failing\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double res=0;\\n        if(n==0) return 1;\\n        if(n>0)\\n        {\\n            double temp = x;\\n            for(int i=1;i<n;i++)\\n            {\\n                temp=temp*x;\\n            }\\n            res = temp;\\n        }\\n        if(n<0)\\n        {\\n            double temp = x;\\n            for(int i=1;i<abs(n);i++)\\n            {\\n                temp=temp*x;\\n            }\\n            res = 1/temp;\\n        }\\n        return res;\\n    }\\n};\\n\\nCould anyone correct this brute force so It can be accepted? \\n\\nUpvote Please"
                    },
                    {
                        "username": "noorpinger",
                        "content": "says 305/305 cases passed but won\\'t let me submit because it says time limit exceeded \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Sushant_012003",
                        "content": "Its pretty easy \\nreturn pow(x, n) and done as simple as that\\ntime Complexity O(1)"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding why for my below code i am getting \"maximum recursion depth exceeded\" for x=0.00001 and n=2147483647\\n```\\n    def myPow(self, x: float, n: int) -> float:\\n        if n==0:\\n            return 1\\n        return x*self.myPow(x,n-1) if n>0 else self.myPow(x,n+1)/x\\n```\\nBut the below code seems to work fine\\n```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:      \\n\\n        if n==0:\\n            return 1\\n\\n        if n < 0:\\n            x = 1/x\\n            n = -n\\n\\n        return x*pow(x,n-1)\\n```\\n\\nLogically both are almost kind of same but then why the difference in execution"
                    }
                ]
            },
            {
                "id": 1745101,
                "content": [
                    {
                        "username": "umanggcoder",
                        "content": "Time Limit Exceeded\\nLast Executed Input\\n299 / 305 testcases passed\\nx =\\n1.00000\\nn =\\n2147483647\\ncan anyone please tell me why i am getting tle ?"
                    },
                    {
                        "username": "ritesh1224",
                        "content": "double ans = Math.pow(x,n);\\n             return ans;"
                    },
                    {
                        "username": "levi_kapil",
                        "content": "So firstly i code my code run 301 case out 305 i made condition after running test case so finally this one is my final code of C++ \\n\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double t = x; \\n    if(x==1)\\n    {\\n        return 1; \\n    }\\n    if(x==0 )\\n    {\\n        return 0 ; \\n    }\\n\\n   if (x>1.0 && n<-2147483647) \\n   {return 0;\\n   }\\n    if(x==-1)\\n    {\\n        if(n%2==0)\\n        {\\n        return 1; }\\n        else\\n        {\\n            return -1; \\n        }\\n\\n    }\\n\\n        if(n>0){\\n        for(int i=1; i<n; i++)\\n        {\\n            x= x*t; \\n        }\\n        }\\n        else if(n==0)\\n    \\n    {\\n        return 1; \\n    }\\n        else\\n        {\\n            for (int i = 1; i>n; i--)\\n            {  x = x/t; \\n            } \\n        } \\n        return x; \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "This happens to me in almost every medium/hard difficulty question that I attempt. In this one, I am able to get 299/305 testcases correctly, but there are some corner cases which I cannot figure out any solution for."
                    },
                    {
                        "username": "YaJohny",
                        "content": "Who knows how to fix 291 testcase\nTime Limit Exceed\nx = 0.00001\nn = 10 digit number"
                    },
                    {
                        "username": "homesomerset",
                        "content": "just got passed with a solution in java that use pretty interesting bit operations. one hint..., every n is represented in binary mode on a computer. let\\'s say n= 10, it\\'s actually 1010 in binary. it basically means 2^3 + 2^1 = 10. 2^1 means x*x, 2^3 means ret = x*x, and ret = ret*ret, then again re= ret*ret. it\\'s basically worst case 496 multiplies. best case 1 or 2 multiplies. it\\'s O(1) with no risk of stack overflow, and corner case free. "
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "Here is my Easy Brute force solution But its last 6 TC are failing\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double res=0;\\n        if(n==0) return 1;\\n        if(n>0)\\n        {\\n            double temp = x;\\n            for(int i=1;i<n;i++)\\n            {\\n                temp=temp*x;\\n            }\\n            res = temp;\\n        }\\n        if(n<0)\\n        {\\n            double temp = x;\\n            for(int i=1;i<abs(n);i++)\\n            {\\n                temp=temp*x;\\n            }\\n            res = 1/temp;\\n        }\\n        return res;\\n    }\\n};\\n\\nCould anyone correct this brute force so It can be accepted? \\n\\nUpvote Please"
                    },
                    {
                        "username": "noorpinger",
                        "content": "says 305/305 cases passed but won\\'t let me submit because it says time limit exceeded \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Sushant_012003",
                        "content": "Its pretty easy \\nreturn pow(x, n) and done as simple as that\\ntime Complexity O(1)"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding why for my below code i am getting \"maximum recursion depth exceeded\" for x=0.00001 and n=2147483647\\n```\\n    def myPow(self, x: float, n: int) -> float:\\n        if n==0:\\n            return 1\\n        return x*self.myPow(x,n-1) if n>0 else self.myPow(x,n+1)/x\\n```\\nBut the below code seems to work fine\\n```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:      \\n\\n        if n==0:\\n            return 1\\n\\n        if n < 0:\\n            x = 1/x\\n            n = -n\\n\\n        return x*pow(x,n-1)\\n```\\n\\nLogically both are almost kind of same but then why the difference in execution"
                    }
                ]
            },
            {
                "id": 1743090,
                "content": [
                    {
                        "username": "umanggcoder",
                        "content": "Time Limit Exceeded\\nLast Executed Input\\n299 / 305 testcases passed\\nx =\\n1.00000\\nn =\\n2147483647\\ncan anyone please tell me why i am getting tle ?"
                    },
                    {
                        "username": "ritesh1224",
                        "content": "double ans = Math.pow(x,n);\\n             return ans;"
                    },
                    {
                        "username": "levi_kapil",
                        "content": "So firstly i code my code run 301 case out 305 i made condition after running test case so finally this one is my final code of C++ \\n\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double t = x; \\n    if(x==1)\\n    {\\n        return 1; \\n    }\\n    if(x==0 )\\n    {\\n        return 0 ; \\n    }\\n\\n   if (x>1.0 && n<-2147483647) \\n   {return 0;\\n   }\\n    if(x==-1)\\n    {\\n        if(n%2==0)\\n        {\\n        return 1; }\\n        else\\n        {\\n            return -1; \\n        }\\n\\n    }\\n\\n        if(n>0){\\n        for(int i=1; i<n; i++)\\n        {\\n            x= x*t; \\n        }\\n        }\\n        else if(n==0)\\n    \\n    {\\n        return 1; \\n    }\\n        else\\n        {\\n            for (int i = 1; i>n; i--)\\n            {  x = x/t; \\n            } \\n        } \\n        return x; \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "This happens to me in almost every medium/hard difficulty question that I attempt. In this one, I am able to get 299/305 testcases correctly, but there are some corner cases which I cannot figure out any solution for."
                    },
                    {
                        "username": "YaJohny",
                        "content": "Who knows how to fix 291 testcase\nTime Limit Exceed\nx = 0.00001\nn = 10 digit number"
                    },
                    {
                        "username": "homesomerset",
                        "content": "just got passed with a solution in java that use pretty interesting bit operations. one hint..., every n is represented in binary mode on a computer. let\\'s say n= 10, it\\'s actually 1010 in binary. it basically means 2^3 + 2^1 = 10. 2^1 means x*x, 2^3 means ret = x*x, and ret = ret*ret, then again re= ret*ret. it\\'s basically worst case 496 multiplies. best case 1 or 2 multiplies. it\\'s O(1) with no risk of stack overflow, and corner case free. "
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "Here is my Easy Brute force solution But its last 6 TC are failing\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double res=0;\\n        if(n==0) return 1;\\n        if(n>0)\\n        {\\n            double temp = x;\\n            for(int i=1;i<n;i++)\\n            {\\n                temp=temp*x;\\n            }\\n            res = temp;\\n        }\\n        if(n<0)\\n        {\\n            double temp = x;\\n            for(int i=1;i<abs(n);i++)\\n            {\\n                temp=temp*x;\\n            }\\n            res = 1/temp;\\n        }\\n        return res;\\n    }\\n};\\n\\nCould anyone correct this brute force so It can be accepted? \\n\\nUpvote Please"
                    },
                    {
                        "username": "noorpinger",
                        "content": "says 305/305 cases passed but won\\'t let me submit because it says time limit exceeded \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Sushant_012003",
                        "content": "Its pretty easy \\nreturn pow(x, n) and done as simple as that\\ntime Complexity O(1)"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding why for my below code i am getting \"maximum recursion depth exceeded\" for x=0.00001 and n=2147483647\\n```\\n    def myPow(self, x: float, n: int) -> float:\\n        if n==0:\\n            return 1\\n        return x*self.myPow(x,n-1) if n>0 else self.myPow(x,n+1)/x\\n```\\nBut the below code seems to work fine\\n```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:      \\n\\n        if n==0:\\n            return 1\\n\\n        if n < 0:\\n            x = 1/x\\n            n = -n\\n\\n        return x*pow(x,n-1)\\n```\\n\\nLogically both are almost kind of same but then why the difference in execution"
                    }
                ]
            },
            {
                "id": 1734773,
                "content": [
                    {
                        "username": "tarikin",
                        "content": "Time Limit Exceeded n  = -2147483648, do we really need to check if n is -2147483648 and return fixed 0 value"
                    },
                    {
                        "username": "itsSankalp",
                        "content": "if n is negative \\n    return 1/pow(x,n)"
                    },
                    {
                        "username": "itsSankalp",
                        "content": "Easiest Approach\\nHint : Recursive approach\\n\\ndouble pow(double x, int n){\\n//base case(think)\\nif n is even : pow(x,n) = pow(x,n/2) * pow(x,n/2);\\nif n is odd : pow(x,n) = x * pow(x,n/2) * pow(x,n/2);\\n}\\n\\nmain(){\\nif(n is positive)\\n    return pow(x,n);\\nif(n is negative) \\n    return 1 / pow(x,n);\\n"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "why my code isn\\'t working: \\n \\ndouble myPow(double x, int n) {\\n        double ans = 1.00000;\\n        long long nn = n;\\n        if(nn<0) nn = -1 * nn;\\n        while(nn){\\n            if(nn%2){\\n                ans = ans * x;\\n                nn = nn-1;\\n            }\\n            else{\\n                ans = x*x;\\n                nn=nn/2;\\n            }\\n        }\\n        if(n<0) ans=(double)(1.0)/(double)(ans);\\n        return ans; \\n    }"
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "Please tell the mistake in this c++ code as it is giving Runtime error with deadly signal\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        long long nn=n;\\n\\n        if(nn<0.0) nn=-1*nn;\\n        //base condition\\n        if(nn==0.0) return 1.0;\\n        \\n        if(nn>0.0) return ((double)(x*myPow(x,n-1)));\\n\\n        return ((double)(1.0)/(double)(x*myPow(x,n-1)));\\n    }\\n};"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Help! I wrote a solution which I believe to run in`O(log(n)`time and`O(1)`space, but when I submit, it says it's in the bottom 5% of solutions. I'm unsure why? Thanks in advanced. Apologies for the formatting.\n\nconst pow = (x, n) => {\n   if (n === 0) return 1;\n\n   if (n < 0) {\n       n = -n;\n       x = 1/x;\n   }\n\n   let val = x;\n   for (let i = 1; i < n; ++i) {\n       if (i * 2 <= n) {\n        val *= val;\n        i *= 2;\n        i--;\n       } else {\n        val *= x;\n       }\n   } \n\n   return val;  \n}"
                    },
                    {
                        "username": "Shashank_Jangir17",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double ans=0;\\n        ans=pow(x,n);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Arnabiswas99",
                        "content": "Why this code got time limit exceed for input (INT_MAX)^(0.00001)?\\nclass Solution {\\npublic:\\ndouble helper(double x, int n)\\n{\\n        if(n==0) return 1;\\n        if(n==1) return x;\\n        if(n%2==0) return myPow(x,n/2)*myPow(x,n/2);\\n        else return x*myPow(x,n/2)*myPow(x,n/2);\\n}\\n    double myPow(double x, int n) {\\n        if(n>=0) return helper(x,n);\\n        else\\n        {\\n            double ans;\\n            ans=helper(x,(-1)*n);\\n            ans=1/ans;\\n            return ans;\\n        }\\n    }\\n};\\nThank You."
                    },
                    {
                        "username": "khetaj22",
                        "content": "WHY STACKOVERFLOW...\n\nclass Solution \n{\n    public double myPow(double x, int n) \n    {\n        if(n == 0)\n        {\n            return 1;\n        }\n            return x * myPow(x, n - 1);\n    }\n} "
                    },
                    {
                        "username": "anavale",
                        "content": "Why is this failing? It says I passed all the testcases however it says that I reached the time limit when \"x=\" with no value assigned to it.\\n \\n double myPow(double x, int n){\\n    double sum = 1;\\n\\n    if(isnan(x) != 0){\\n        sum = 0;\\n    } else if (x == 1){\\n        sum = 1;\\n    }else if(x == -1){\\n        if(n%2 == 1){ //If n is odd\\n            sum = -1;\\n        }else{\\n            sum = 1;\\n        }\\n    }else if(n < -100000){\\n        sum = 0;\\n    }else if(n>0){\\n        for(int i = 0; i < n; i++){\\n            sum = sum * x;\\n        }\\n    }else if(n == 0){\\n        sum = 1;\\n    }else if(n<0){\\n        for(int j = 0; j < abs(n); j++){\\n            sum = sum * x;\\n        }\\n        sum = 1/sum;\\n    }\\n    \\n    return sum;\\n}"
                    },
                    {
                        "username": "shivang_tripathi",
                        "content": "here is the my solution for this question, this solution is showing time limit exceeded, can anyone tell me how can optmize it more efficiently so the time limit is not exceeded\\n\\nclass Solution {\\n    public double myPow(double x, int n) {\\n    double pow = x; \\n    if(n == 0){\\n      return (double)1;\\n    } \\n    if (n < 0){\\n       n = n*(-1);\\n       pow = (1/x);\\n    for(int i =1; i < n; i++){\\n       pow = pow*(1/x);\\n       }\\n     }else{\\n     for(int i =1; i < n; i++){\\n         pow = pow*x;\\n    }\\n    }\\n    return pow;\\n  }\\n    }"
                    }
                ]
            },
            {
                "id": 1734090,
                "content": [
                    {
                        "username": "tarikin",
                        "content": "Time Limit Exceeded n  = -2147483648, do we really need to check if n is -2147483648 and return fixed 0 value"
                    },
                    {
                        "username": "itsSankalp",
                        "content": "if n is negative \\n    return 1/pow(x,n)"
                    },
                    {
                        "username": "itsSankalp",
                        "content": "Easiest Approach\\nHint : Recursive approach\\n\\ndouble pow(double x, int n){\\n//base case(think)\\nif n is even : pow(x,n) = pow(x,n/2) * pow(x,n/2);\\nif n is odd : pow(x,n) = x * pow(x,n/2) * pow(x,n/2);\\n}\\n\\nmain(){\\nif(n is positive)\\n    return pow(x,n);\\nif(n is negative) \\n    return 1 / pow(x,n);\\n"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "why my code isn\\'t working: \\n \\ndouble myPow(double x, int n) {\\n        double ans = 1.00000;\\n        long long nn = n;\\n        if(nn<0) nn = -1 * nn;\\n        while(nn){\\n            if(nn%2){\\n                ans = ans * x;\\n                nn = nn-1;\\n            }\\n            else{\\n                ans = x*x;\\n                nn=nn/2;\\n            }\\n        }\\n        if(n<0) ans=(double)(1.0)/(double)(ans);\\n        return ans; \\n    }"
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "Please tell the mistake in this c++ code as it is giving Runtime error with deadly signal\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        long long nn=n;\\n\\n        if(nn<0.0) nn=-1*nn;\\n        //base condition\\n        if(nn==0.0) return 1.0;\\n        \\n        if(nn>0.0) return ((double)(x*myPow(x,n-1)));\\n\\n        return ((double)(1.0)/(double)(x*myPow(x,n-1)));\\n    }\\n};"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Help! I wrote a solution which I believe to run in`O(log(n)`time and`O(1)`space, but when I submit, it says it's in the bottom 5% of solutions. I'm unsure why? Thanks in advanced. Apologies for the formatting.\n\nconst pow = (x, n) => {\n   if (n === 0) return 1;\n\n   if (n < 0) {\n       n = -n;\n       x = 1/x;\n   }\n\n   let val = x;\n   for (let i = 1; i < n; ++i) {\n       if (i * 2 <= n) {\n        val *= val;\n        i *= 2;\n        i--;\n       } else {\n        val *= x;\n       }\n   } \n\n   return val;  \n}"
                    },
                    {
                        "username": "Shashank_Jangir17",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double ans=0;\\n        ans=pow(x,n);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Arnabiswas99",
                        "content": "Why this code got time limit exceed for input (INT_MAX)^(0.00001)?\\nclass Solution {\\npublic:\\ndouble helper(double x, int n)\\n{\\n        if(n==0) return 1;\\n        if(n==1) return x;\\n        if(n%2==0) return myPow(x,n/2)*myPow(x,n/2);\\n        else return x*myPow(x,n/2)*myPow(x,n/2);\\n}\\n    double myPow(double x, int n) {\\n        if(n>=0) return helper(x,n);\\n        else\\n        {\\n            double ans;\\n            ans=helper(x,(-1)*n);\\n            ans=1/ans;\\n            return ans;\\n        }\\n    }\\n};\\nThank You."
                    },
                    {
                        "username": "khetaj22",
                        "content": "WHY STACKOVERFLOW...\n\nclass Solution \n{\n    public double myPow(double x, int n) \n    {\n        if(n == 0)\n        {\n            return 1;\n        }\n            return x * myPow(x, n - 1);\n    }\n} "
                    },
                    {
                        "username": "anavale",
                        "content": "Why is this failing? It says I passed all the testcases however it says that I reached the time limit when \"x=\" with no value assigned to it.\\n \\n double myPow(double x, int n){\\n    double sum = 1;\\n\\n    if(isnan(x) != 0){\\n        sum = 0;\\n    } else if (x == 1){\\n        sum = 1;\\n    }else if(x == -1){\\n        if(n%2 == 1){ //If n is odd\\n            sum = -1;\\n        }else{\\n            sum = 1;\\n        }\\n    }else if(n < -100000){\\n        sum = 0;\\n    }else if(n>0){\\n        for(int i = 0; i < n; i++){\\n            sum = sum * x;\\n        }\\n    }else if(n == 0){\\n        sum = 1;\\n    }else if(n<0){\\n        for(int j = 0; j < abs(n); j++){\\n            sum = sum * x;\\n        }\\n        sum = 1/sum;\\n    }\\n    \\n    return sum;\\n}"
                    },
                    {
                        "username": "shivang_tripathi",
                        "content": "here is the my solution for this question, this solution is showing time limit exceeded, can anyone tell me how can optmize it more efficiently so the time limit is not exceeded\\n\\nclass Solution {\\n    public double myPow(double x, int n) {\\n    double pow = x; \\n    if(n == 0){\\n      return (double)1;\\n    } \\n    if (n < 0){\\n       n = n*(-1);\\n       pow = (1/x);\\n    for(int i =1; i < n; i++){\\n       pow = pow*(1/x);\\n       }\\n     }else{\\n     for(int i =1; i < n; i++){\\n         pow = pow*x;\\n    }\\n    }\\n    return pow;\\n  }\\n    }"
                    }
                ]
            },
            {
                "id": 1733976,
                "content": [
                    {
                        "username": "tarikin",
                        "content": "Time Limit Exceeded n  = -2147483648, do we really need to check if n is -2147483648 and return fixed 0 value"
                    },
                    {
                        "username": "itsSankalp",
                        "content": "if n is negative \\n    return 1/pow(x,n)"
                    },
                    {
                        "username": "itsSankalp",
                        "content": "Easiest Approach\\nHint : Recursive approach\\n\\ndouble pow(double x, int n){\\n//base case(think)\\nif n is even : pow(x,n) = pow(x,n/2) * pow(x,n/2);\\nif n is odd : pow(x,n) = x * pow(x,n/2) * pow(x,n/2);\\n}\\n\\nmain(){\\nif(n is positive)\\n    return pow(x,n);\\nif(n is negative) \\n    return 1 / pow(x,n);\\n"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "why my code isn\\'t working: \\n \\ndouble myPow(double x, int n) {\\n        double ans = 1.00000;\\n        long long nn = n;\\n        if(nn<0) nn = -1 * nn;\\n        while(nn){\\n            if(nn%2){\\n                ans = ans * x;\\n                nn = nn-1;\\n            }\\n            else{\\n                ans = x*x;\\n                nn=nn/2;\\n            }\\n        }\\n        if(n<0) ans=(double)(1.0)/(double)(ans);\\n        return ans; \\n    }"
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "Please tell the mistake in this c++ code as it is giving Runtime error with deadly signal\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        long long nn=n;\\n\\n        if(nn<0.0) nn=-1*nn;\\n        //base condition\\n        if(nn==0.0) return 1.0;\\n        \\n        if(nn>0.0) return ((double)(x*myPow(x,n-1)));\\n\\n        return ((double)(1.0)/(double)(x*myPow(x,n-1)));\\n    }\\n};"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Help! I wrote a solution which I believe to run in`O(log(n)`time and`O(1)`space, but when I submit, it says it's in the bottom 5% of solutions. I'm unsure why? Thanks in advanced. Apologies for the formatting.\n\nconst pow = (x, n) => {\n   if (n === 0) return 1;\n\n   if (n < 0) {\n       n = -n;\n       x = 1/x;\n   }\n\n   let val = x;\n   for (let i = 1; i < n; ++i) {\n       if (i * 2 <= n) {\n        val *= val;\n        i *= 2;\n        i--;\n       } else {\n        val *= x;\n       }\n   } \n\n   return val;  \n}"
                    },
                    {
                        "username": "Shashank_Jangir17",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double ans=0;\\n        ans=pow(x,n);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Arnabiswas99",
                        "content": "Why this code got time limit exceed for input (INT_MAX)^(0.00001)?\\nclass Solution {\\npublic:\\ndouble helper(double x, int n)\\n{\\n        if(n==0) return 1;\\n        if(n==1) return x;\\n        if(n%2==0) return myPow(x,n/2)*myPow(x,n/2);\\n        else return x*myPow(x,n/2)*myPow(x,n/2);\\n}\\n    double myPow(double x, int n) {\\n        if(n>=0) return helper(x,n);\\n        else\\n        {\\n            double ans;\\n            ans=helper(x,(-1)*n);\\n            ans=1/ans;\\n            return ans;\\n        }\\n    }\\n};\\nThank You."
                    },
                    {
                        "username": "khetaj22",
                        "content": "WHY STACKOVERFLOW...\n\nclass Solution \n{\n    public double myPow(double x, int n) \n    {\n        if(n == 0)\n        {\n            return 1;\n        }\n            return x * myPow(x, n - 1);\n    }\n} "
                    },
                    {
                        "username": "anavale",
                        "content": "Why is this failing? It says I passed all the testcases however it says that I reached the time limit when \"x=\" with no value assigned to it.\\n \\n double myPow(double x, int n){\\n    double sum = 1;\\n\\n    if(isnan(x) != 0){\\n        sum = 0;\\n    } else if (x == 1){\\n        sum = 1;\\n    }else if(x == -1){\\n        if(n%2 == 1){ //If n is odd\\n            sum = -1;\\n        }else{\\n            sum = 1;\\n        }\\n    }else if(n < -100000){\\n        sum = 0;\\n    }else if(n>0){\\n        for(int i = 0; i < n; i++){\\n            sum = sum * x;\\n        }\\n    }else if(n == 0){\\n        sum = 1;\\n    }else if(n<0){\\n        for(int j = 0; j < abs(n); j++){\\n            sum = sum * x;\\n        }\\n        sum = 1/sum;\\n    }\\n    \\n    return sum;\\n}"
                    },
                    {
                        "username": "shivang_tripathi",
                        "content": "here is the my solution for this question, this solution is showing time limit exceeded, can anyone tell me how can optmize it more efficiently so the time limit is not exceeded\\n\\nclass Solution {\\n    public double myPow(double x, int n) {\\n    double pow = x; \\n    if(n == 0){\\n      return (double)1;\\n    } \\n    if (n < 0){\\n       n = n*(-1);\\n       pow = (1/x);\\n    for(int i =1; i < n; i++){\\n       pow = pow*(1/x);\\n       }\\n     }else{\\n     for(int i =1; i < n; i++){\\n         pow = pow*x;\\n    }\\n    }\\n    return pow;\\n  }\\n    }"
                    }
                ]
            },
            {
                "id": 1732929,
                "content": [
                    {
                        "username": "tarikin",
                        "content": "Time Limit Exceeded n  = -2147483648, do we really need to check if n is -2147483648 and return fixed 0 value"
                    },
                    {
                        "username": "itsSankalp",
                        "content": "if n is negative \\n    return 1/pow(x,n)"
                    },
                    {
                        "username": "itsSankalp",
                        "content": "Easiest Approach\\nHint : Recursive approach\\n\\ndouble pow(double x, int n){\\n//base case(think)\\nif n is even : pow(x,n) = pow(x,n/2) * pow(x,n/2);\\nif n is odd : pow(x,n) = x * pow(x,n/2) * pow(x,n/2);\\n}\\n\\nmain(){\\nif(n is positive)\\n    return pow(x,n);\\nif(n is negative) \\n    return 1 / pow(x,n);\\n"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "why my code isn\\'t working: \\n \\ndouble myPow(double x, int n) {\\n        double ans = 1.00000;\\n        long long nn = n;\\n        if(nn<0) nn = -1 * nn;\\n        while(nn){\\n            if(nn%2){\\n                ans = ans * x;\\n                nn = nn-1;\\n            }\\n            else{\\n                ans = x*x;\\n                nn=nn/2;\\n            }\\n        }\\n        if(n<0) ans=(double)(1.0)/(double)(ans);\\n        return ans; \\n    }"
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "Please tell the mistake in this c++ code as it is giving Runtime error with deadly signal\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        long long nn=n;\\n\\n        if(nn<0.0) nn=-1*nn;\\n        //base condition\\n        if(nn==0.0) return 1.0;\\n        \\n        if(nn>0.0) return ((double)(x*myPow(x,n-1)));\\n\\n        return ((double)(1.0)/(double)(x*myPow(x,n-1)));\\n    }\\n};"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Help! I wrote a solution which I believe to run in`O(log(n)`time and`O(1)`space, but when I submit, it says it's in the bottom 5% of solutions. I'm unsure why? Thanks in advanced. Apologies for the formatting.\n\nconst pow = (x, n) => {\n   if (n === 0) return 1;\n\n   if (n < 0) {\n       n = -n;\n       x = 1/x;\n   }\n\n   let val = x;\n   for (let i = 1; i < n; ++i) {\n       if (i * 2 <= n) {\n        val *= val;\n        i *= 2;\n        i--;\n       } else {\n        val *= x;\n       }\n   } \n\n   return val;  \n}"
                    },
                    {
                        "username": "Shashank_Jangir17",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double ans=0;\\n        ans=pow(x,n);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Arnabiswas99",
                        "content": "Why this code got time limit exceed for input (INT_MAX)^(0.00001)?\\nclass Solution {\\npublic:\\ndouble helper(double x, int n)\\n{\\n        if(n==0) return 1;\\n        if(n==1) return x;\\n        if(n%2==0) return myPow(x,n/2)*myPow(x,n/2);\\n        else return x*myPow(x,n/2)*myPow(x,n/2);\\n}\\n    double myPow(double x, int n) {\\n        if(n>=0) return helper(x,n);\\n        else\\n        {\\n            double ans;\\n            ans=helper(x,(-1)*n);\\n            ans=1/ans;\\n            return ans;\\n        }\\n    }\\n};\\nThank You."
                    },
                    {
                        "username": "khetaj22",
                        "content": "WHY STACKOVERFLOW...\n\nclass Solution \n{\n    public double myPow(double x, int n) \n    {\n        if(n == 0)\n        {\n            return 1;\n        }\n            return x * myPow(x, n - 1);\n    }\n} "
                    },
                    {
                        "username": "anavale",
                        "content": "Why is this failing? It says I passed all the testcases however it says that I reached the time limit when \"x=\" with no value assigned to it.\\n \\n double myPow(double x, int n){\\n    double sum = 1;\\n\\n    if(isnan(x) != 0){\\n        sum = 0;\\n    } else if (x == 1){\\n        sum = 1;\\n    }else if(x == -1){\\n        if(n%2 == 1){ //If n is odd\\n            sum = -1;\\n        }else{\\n            sum = 1;\\n        }\\n    }else if(n < -100000){\\n        sum = 0;\\n    }else if(n>0){\\n        for(int i = 0; i < n; i++){\\n            sum = sum * x;\\n        }\\n    }else if(n == 0){\\n        sum = 1;\\n    }else if(n<0){\\n        for(int j = 0; j < abs(n); j++){\\n            sum = sum * x;\\n        }\\n        sum = 1/sum;\\n    }\\n    \\n    return sum;\\n}"
                    },
                    {
                        "username": "shivang_tripathi",
                        "content": "here is the my solution for this question, this solution is showing time limit exceeded, can anyone tell me how can optmize it more efficiently so the time limit is not exceeded\\n\\nclass Solution {\\n    public double myPow(double x, int n) {\\n    double pow = x; \\n    if(n == 0){\\n      return (double)1;\\n    } \\n    if (n < 0){\\n       n = n*(-1);\\n       pow = (1/x);\\n    for(int i =1; i < n; i++){\\n       pow = pow*(1/x);\\n       }\\n     }else{\\n     for(int i =1; i < n; i++){\\n         pow = pow*x;\\n    }\\n    }\\n    return pow;\\n  }\\n    }"
                    }
                ]
            },
            {
                "id": 1732468,
                "content": [
                    {
                        "username": "tarikin",
                        "content": "Time Limit Exceeded n  = -2147483648, do we really need to check if n is -2147483648 and return fixed 0 value"
                    },
                    {
                        "username": "itsSankalp",
                        "content": "if n is negative \\n    return 1/pow(x,n)"
                    },
                    {
                        "username": "itsSankalp",
                        "content": "Easiest Approach\\nHint : Recursive approach\\n\\ndouble pow(double x, int n){\\n//base case(think)\\nif n is even : pow(x,n) = pow(x,n/2) * pow(x,n/2);\\nif n is odd : pow(x,n) = x * pow(x,n/2) * pow(x,n/2);\\n}\\n\\nmain(){\\nif(n is positive)\\n    return pow(x,n);\\nif(n is negative) \\n    return 1 / pow(x,n);\\n"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "why my code isn\\'t working: \\n \\ndouble myPow(double x, int n) {\\n        double ans = 1.00000;\\n        long long nn = n;\\n        if(nn<0) nn = -1 * nn;\\n        while(nn){\\n            if(nn%2){\\n                ans = ans * x;\\n                nn = nn-1;\\n            }\\n            else{\\n                ans = x*x;\\n                nn=nn/2;\\n            }\\n        }\\n        if(n<0) ans=(double)(1.0)/(double)(ans);\\n        return ans; \\n    }"
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "Please tell the mistake in this c++ code as it is giving Runtime error with deadly signal\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        long long nn=n;\\n\\n        if(nn<0.0) nn=-1*nn;\\n        //base condition\\n        if(nn==0.0) return 1.0;\\n        \\n        if(nn>0.0) return ((double)(x*myPow(x,n-1)));\\n\\n        return ((double)(1.0)/(double)(x*myPow(x,n-1)));\\n    }\\n};"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Help! I wrote a solution which I believe to run in`O(log(n)`time and`O(1)`space, but when I submit, it says it's in the bottom 5% of solutions. I'm unsure why? Thanks in advanced. Apologies for the formatting.\n\nconst pow = (x, n) => {\n   if (n === 0) return 1;\n\n   if (n < 0) {\n       n = -n;\n       x = 1/x;\n   }\n\n   let val = x;\n   for (let i = 1; i < n; ++i) {\n       if (i * 2 <= n) {\n        val *= val;\n        i *= 2;\n        i--;\n       } else {\n        val *= x;\n       }\n   } \n\n   return val;  \n}"
                    },
                    {
                        "username": "Shashank_Jangir17",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double ans=0;\\n        ans=pow(x,n);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Arnabiswas99",
                        "content": "Why this code got time limit exceed for input (INT_MAX)^(0.00001)?\\nclass Solution {\\npublic:\\ndouble helper(double x, int n)\\n{\\n        if(n==0) return 1;\\n        if(n==1) return x;\\n        if(n%2==0) return myPow(x,n/2)*myPow(x,n/2);\\n        else return x*myPow(x,n/2)*myPow(x,n/2);\\n}\\n    double myPow(double x, int n) {\\n        if(n>=0) return helper(x,n);\\n        else\\n        {\\n            double ans;\\n            ans=helper(x,(-1)*n);\\n            ans=1/ans;\\n            return ans;\\n        }\\n    }\\n};\\nThank You."
                    },
                    {
                        "username": "khetaj22",
                        "content": "WHY STACKOVERFLOW...\n\nclass Solution \n{\n    public double myPow(double x, int n) \n    {\n        if(n == 0)\n        {\n            return 1;\n        }\n            return x * myPow(x, n - 1);\n    }\n} "
                    },
                    {
                        "username": "anavale",
                        "content": "Why is this failing? It says I passed all the testcases however it says that I reached the time limit when \"x=\" with no value assigned to it.\\n \\n double myPow(double x, int n){\\n    double sum = 1;\\n\\n    if(isnan(x) != 0){\\n        sum = 0;\\n    } else if (x == 1){\\n        sum = 1;\\n    }else if(x == -1){\\n        if(n%2 == 1){ //If n is odd\\n            sum = -1;\\n        }else{\\n            sum = 1;\\n        }\\n    }else if(n < -100000){\\n        sum = 0;\\n    }else if(n>0){\\n        for(int i = 0; i < n; i++){\\n            sum = sum * x;\\n        }\\n    }else if(n == 0){\\n        sum = 1;\\n    }else if(n<0){\\n        for(int j = 0; j < abs(n); j++){\\n            sum = sum * x;\\n        }\\n        sum = 1/sum;\\n    }\\n    \\n    return sum;\\n}"
                    },
                    {
                        "username": "shivang_tripathi",
                        "content": "here is the my solution for this question, this solution is showing time limit exceeded, can anyone tell me how can optmize it more efficiently so the time limit is not exceeded\\n\\nclass Solution {\\n    public double myPow(double x, int n) {\\n    double pow = x; \\n    if(n == 0){\\n      return (double)1;\\n    } \\n    if (n < 0){\\n       n = n*(-1);\\n       pow = (1/x);\\n    for(int i =1; i < n; i++){\\n       pow = pow*(1/x);\\n       }\\n     }else{\\n     for(int i =1; i < n; i++){\\n         pow = pow*x;\\n    }\\n    }\\n    return pow;\\n  }\\n    }"
                    }
                ]
            },
            {
                "id": 1731713,
                "content": [
                    {
                        "username": "tarikin",
                        "content": "Time Limit Exceeded n  = -2147483648, do we really need to check if n is -2147483648 and return fixed 0 value"
                    },
                    {
                        "username": "itsSankalp",
                        "content": "if n is negative \\n    return 1/pow(x,n)"
                    },
                    {
                        "username": "itsSankalp",
                        "content": "Easiest Approach\\nHint : Recursive approach\\n\\ndouble pow(double x, int n){\\n//base case(think)\\nif n is even : pow(x,n) = pow(x,n/2) * pow(x,n/2);\\nif n is odd : pow(x,n) = x * pow(x,n/2) * pow(x,n/2);\\n}\\n\\nmain(){\\nif(n is positive)\\n    return pow(x,n);\\nif(n is negative) \\n    return 1 / pow(x,n);\\n"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "why my code isn\\'t working: \\n \\ndouble myPow(double x, int n) {\\n        double ans = 1.00000;\\n        long long nn = n;\\n        if(nn<0) nn = -1 * nn;\\n        while(nn){\\n            if(nn%2){\\n                ans = ans * x;\\n                nn = nn-1;\\n            }\\n            else{\\n                ans = x*x;\\n                nn=nn/2;\\n            }\\n        }\\n        if(n<0) ans=(double)(1.0)/(double)(ans);\\n        return ans; \\n    }"
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "Please tell the mistake in this c++ code as it is giving Runtime error with deadly signal\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        long long nn=n;\\n\\n        if(nn<0.0) nn=-1*nn;\\n        //base condition\\n        if(nn==0.0) return 1.0;\\n        \\n        if(nn>0.0) return ((double)(x*myPow(x,n-1)));\\n\\n        return ((double)(1.0)/(double)(x*myPow(x,n-1)));\\n    }\\n};"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Help! I wrote a solution which I believe to run in`O(log(n)`time and`O(1)`space, but when I submit, it says it's in the bottom 5% of solutions. I'm unsure why? Thanks in advanced. Apologies for the formatting.\n\nconst pow = (x, n) => {\n   if (n === 0) return 1;\n\n   if (n < 0) {\n       n = -n;\n       x = 1/x;\n   }\n\n   let val = x;\n   for (let i = 1; i < n; ++i) {\n       if (i * 2 <= n) {\n        val *= val;\n        i *= 2;\n        i--;\n       } else {\n        val *= x;\n       }\n   } \n\n   return val;  \n}"
                    },
                    {
                        "username": "Shashank_Jangir17",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double ans=0;\\n        ans=pow(x,n);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Arnabiswas99",
                        "content": "Why this code got time limit exceed for input (INT_MAX)^(0.00001)?\\nclass Solution {\\npublic:\\ndouble helper(double x, int n)\\n{\\n        if(n==0) return 1;\\n        if(n==1) return x;\\n        if(n%2==0) return myPow(x,n/2)*myPow(x,n/2);\\n        else return x*myPow(x,n/2)*myPow(x,n/2);\\n}\\n    double myPow(double x, int n) {\\n        if(n>=0) return helper(x,n);\\n        else\\n        {\\n            double ans;\\n            ans=helper(x,(-1)*n);\\n            ans=1/ans;\\n            return ans;\\n        }\\n    }\\n};\\nThank You."
                    },
                    {
                        "username": "khetaj22",
                        "content": "WHY STACKOVERFLOW...\n\nclass Solution \n{\n    public double myPow(double x, int n) \n    {\n        if(n == 0)\n        {\n            return 1;\n        }\n            return x * myPow(x, n - 1);\n    }\n} "
                    },
                    {
                        "username": "anavale",
                        "content": "Why is this failing? It says I passed all the testcases however it says that I reached the time limit when \"x=\" with no value assigned to it.\\n \\n double myPow(double x, int n){\\n    double sum = 1;\\n\\n    if(isnan(x) != 0){\\n        sum = 0;\\n    } else if (x == 1){\\n        sum = 1;\\n    }else if(x == -1){\\n        if(n%2 == 1){ //If n is odd\\n            sum = -1;\\n        }else{\\n            sum = 1;\\n        }\\n    }else if(n < -100000){\\n        sum = 0;\\n    }else if(n>0){\\n        for(int i = 0; i < n; i++){\\n            sum = sum * x;\\n        }\\n    }else if(n == 0){\\n        sum = 1;\\n    }else if(n<0){\\n        for(int j = 0; j < abs(n); j++){\\n            sum = sum * x;\\n        }\\n        sum = 1/sum;\\n    }\\n    \\n    return sum;\\n}"
                    },
                    {
                        "username": "shivang_tripathi",
                        "content": "here is the my solution for this question, this solution is showing time limit exceeded, can anyone tell me how can optmize it more efficiently so the time limit is not exceeded\\n\\nclass Solution {\\n    public double myPow(double x, int n) {\\n    double pow = x; \\n    if(n == 0){\\n      return (double)1;\\n    } \\n    if (n < 0){\\n       n = n*(-1);\\n       pow = (1/x);\\n    for(int i =1; i < n; i++){\\n       pow = pow*(1/x);\\n       }\\n     }else{\\n     for(int i =1; i < n; i++){\\n         pow = pow*x;\\n    }\\n    }\\n    return pow;\\n  }\\n    }"
                    }
                ]
            },
            {
                "id": 1723516,
                "content": [
                    {
                        "username": "tarikin",
                        "content": "Time Limit Exceeded n  = -2147483648, do we really need to check if n is -2147483648 and return fixed 0 value"
                    },
                    {
                        "username": "itsSankalp",
                        "content": "if n is negative \\n    return 1/pow(x,n)"
                    },
                    {
                        "username": "itsSankalp",
                        "content": "Easiest Approach\\nHint : Recursive approach\\n\\ndouble pow(double x, int n){\\n//base case(think)\\nif n is even : pow(x,n) = pow(x,n/2) * pow(x,n/2);\\nif n is odd : pow(x,n) = x * pow(x,n/2) * pow(x,n/2);\\n}\\n\\nmain(){\\nif(n is positive)\\n    return pow(x,n);\\nif(n is negative) \\n    return 1 / pow(x,n);\\n"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "why my code isn\\'t working: \\n \\ndouble myPow(double x, int n) {\\n        double ans = 1.00000;\\n        long long nn = n;\\n        if(nn<0) nn = -1 * nn;\\n        while(nn){\\n            if(nn%2){\\n                ans = ans * x;\\n                nn = nn-1;\\n            }\\n            else{\\n                ans = x*x;\\n                nn=nn/2;\\n            }\\n        }\\n        if(n<0) ans=(double)(1.0)/(double)(ans);\\n        return ans; \\n    }"
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "Please tell the mistake in this c++ code as it is giving Runtime error with deadly signal\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        long long nn=n;\\n\\n        if(nn<0.0) nn=-1*nn;\\n        //base condition\\n        if(nn==0.0) return 1.0;\\n        \\n        if(nn>0.0) return ((double)(x*myPow(x,n-1)));\\n\\n        return ((double)(1.0)/(double)(x*myPow(x,n-1)));\\n    }\\n};"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Help! I wrote a solution which I believe to run in`O(log(n)`time and`O(1)`space, but when I submit, it says it's in the bottom 5% of solutions. I'm unsure why? Thanks in advanced. Apologies for the formatting.\n\nconst pow = (x, n) => {\n   if (n === 0) return 1;\n\n   if (n < 0) {\n       n = -n;\n       x = 1/x;\n   }\n\n   let val = x;\n   for (let i = 1; i < n; ++i) {\n       if (i * 2 <= n) {\n        val *= val;\n        i *= 2;\n        i--;\n       } else {\n        val *= x;\n       }\n   } \n\n   return val;  \n}"
                    },
                    {
                        "username": "Shashank_Jangir17",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double ans=0;\\n        ans=pow(x,n);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Arnabiswas99",
                        "content": "Why this code got time limit exceed for input (INT_MAX)^(0.00001)?\\nclass Solution {\\npublic:\\ndouble helper(double x, int n)\\n{\\n        if(n==0) return 1;\\n        if(n==1) return x;\\n        if(n%2==0) return myPow(x,n/2)*myPow(x,n/2);\\n        else return x*myPow(x,n/2)*myPow(x,n/2);\\n}\\n    double myPow(double x, int n) {\\n        if(n>=0) return helper(x,n);\\n        else\\n        {\\n            double ans;\\n            ans=helper(x,(-1)*n);\\n            ans=1/ans;\\n            return ans;\\n        }\\n    }\\n};\\nThank You."
                    },
                    {
                        "username": "khetaj22",
                        "content": "WHY STACKOVERFLOW...\n\nclass Solution \n{\n    public double myPow(double x, int n) \n    {\n        if(n == 0)\n        {\n            return 1;\n        }\n            return x * myPow(x, n - 1);\n    }\n} "
                    },
                    {
                        "username": "anavale",
                        "content": "Why is this failing? It says I passed all the testcases however it says that I reached the time limit when \"x=\" with no value assigned to it.\\n \\n double myPow(double x, int n){\\n    double sum = 1;\\n\\n    if(isnan(x) != 0){\\n        sum = 0;\\n    } else if (x == 1){\\n        sum = 1;\\n    }else if(x == -1){\\n        if(n%2 == 1){ //If n is odd\\n            sum = -1;\\n        }else{\\n            sum = 1;\\n        }\\n    }else if(n < -100000){\\n        sum = 0;\\n    }else if(n>0){\\n        for(int i = 0; i < n; i++){\\n            sum = sum * x;\\n        }\\n    }else if(n == 0){\\n        sum = 1;\\n    }else if(n<0){\\n        for(int j = 0; j < abs(n); j++){\\n            sum = sum * x;\\n        }\\n        sum = 1/sum;\\n    }\\n    \\n    return sum;\\n}"
                    },
                    {
                        "username": "shivang_tripathi",
                        "content": "here is the my solution for this question, this solution is showing time limit exceeded, can anyone tell me how can optmize it more efficiently so the time limit is not exceeded\\n\\nclass Solution {\\n    public double myPow(double x, int n) {\\n    double pow = x; \\n    if(n == 0){\\n      return (double)1;\\n    } \\n    if (n < 0){\\n       n = n*(-1);\\n       pow = (1/x);\\n    for(int i =1; i < n; i++){\\n       pow = pow*(1/x);\\n       }\\n     }else{\\n     for(int i =1; i < n; i++){\\n         pow = pow*x;\\n    }\\n    }\\n    return pow;\\n  }\\n    }"
                    }
                ]
            },
            {
                "id": 1722568,
                "content": [
                    {
                        "username": "tarikin",
                        "content": "Time Limit Exceeded n  = -2147483648, do we really need to check if n is -2147483648 and return fixed 0 value"
                    },
                    {
                        "username": "itsSankalp",
                        "content": "if n is negative \\n    return 1/pow(x,n)"
                    },
                    {
                        "username": "itsSankalp",
                        "content": "Easiest Approach\\nHint : Recursive approach\\n\\ndouble pow(double x, int n){\\n//base case(think)\\nif n is even : pow(x,n) = pow(x,n/2) * pow(x,n/2);\\nif n is odd : pow(x,n) = x * pow(x,n/2) * pow(x,n/2);\\n}\\n\\nmain(){\\nif(n is positive)\\n    return pow(x,n);\\nif(n is negative) \\n    return 1 / pow(x,n);\\n"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "why my code isn\\'t working: \\n \\ndouble myPow(double x, int n) {\\n        double ans = 1.00000;\\n        long long nn = n;\\n        if(nn<0) nn = -1 * nn;\\n        while(nn){\\n            if(nn%2){\\n                ans = ans * x;\\n                nn = nn-1;\\n            }\\n            else{\\n                ans = x*x;\\n                nn=nn/2;\\n            }\\n        }\\n        if(n<0) ans=(double)(1.0)/(double)(ans);\\n        return ans; \\n    }"
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "Please tell the mistake in this c++ code as it is giving Runtime error with deadly signal\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        long long nn=n;\\n\\n        if(nn<0.0) nn=-1*nn;\\n        //base condition\\n        if(nn==0.0) return 1.0;\\n        \\n        if(nn>0.0) return ((double)(x*myPow(x,n-1)));\\n\\n        return ((double)(1.0)/(double)(x*myPow(x,n-1)));\\n    }\\n};"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Help! I wrote a solution which I believe to run in`O(log(n)`time and`O(1)`space, but when I submit, it says it's in the bottom 5% of solutions. I'm unsure why? Thanks in advanced. Apologies for the formatting.\n\nconst pow = (x, n) => {\n   if (n === 0) return 1;\n\n   if (n < 0) {\n       n = -n;\n       x = 1/x;\n   }\n\n   let val = x;\n   for (let i = 1; i < n; ++i) {\n       if (i * 2 <= n) {\n        val *= val;\n        i *= 2;\n        i--;\n       } else {\n        val *= x;\n       }\n   } \n\n   return val;  \n}"
                    },
                    {
                        "username": "Shashank_Jangir17",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double ans=0;\\n        ans=pow(x,n);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Arnabiswas99",
                        "content": "Why this code got time limit exceed for input (INT_MAX)^(0.00001)?\\nclass Solution {\\npublic:\\ndouble helper(double x, int n)\\n{\\n        if(n==0) return 1;\\n        if(n==1) return x;\\n        if(n%2==0) return myPow(x,n/2)*myPow(x,n/2);\\n        else return x*myPow(x,n/2)*myPow(x,n/2);\\n}\\n    double myPow(double x, int n) {\\n        if(n>=0) return helper(x,n);\\n        else\\n        {\\n            double ans;\\n            ans=helper(x,(-1)*n);\\n            ans=1/ans;\\n            return ans;\\n        }\\n    }\\n};\\nThank You."
                    },
                    {
                        "username": "khetaj22",
                        "content": "WHY STACKOVERFLOW...\n\nclass Solution \n{\n    public double myPow(double x, int n) \n    {\n        if(n == 0)\n        {\n            return 1;\n        }\n            return x * myPow(x, n - 1);\n    }\n} "
                    },
                    {
                        "username": "anavale",
                        "content": "Why is this failing? It says I passed all the testcases however it says that I reached the time limit when \"x=\" with no value assigned to it.\\n \\n double myPow(double x, int n){\\n    double sum = 1;\\n\\n    if(isnan(x) != 0){\\n        sum = 0;\\n    } else if (x == 1){\\n        sum = 1;\\n    }else if(x == -1){\\n        if(n%2 == 1){ //If n is odd\\n            sum = -1;\\n        }else{\\n            sum = 1;\\n        }\\n    }else if(n < -100000){\\n        sum = 0;\\n    }else if(n>0){\\n        for(int i = 0; i < n; i++){\\n            sum = sum * x;\\n        }\\n    }else if(n == 0){\\n        sum = 1;\\n    }else if(n<0){\\n        for(int j = 0; j < abs(n); j++){\\n            sum = sum * x;\\n        }\\n        sum = 1/sum;\\n    }\\n    \\n    return sum;\\n}"
                    },
                    {
                        "username": "shivang_tripathi",
                        "content": "here is the my solution for this question, this solution is showing time limit exceeded, can anyone tell me how can optmize it more efficiently so the time limit is not exceeded\\n\\nclass Solution {\\n    public double myPow(double x, int n) {\\n    double pow = x; \\n    if(n == 0){\\n      return (double)1;\\n    } \\n    if (n < 0){\\n       n = n*(-1);\\n       pow = (1/x);\\n    for(int i =1; i < n; i++){\\n       pow = pow*(1/x);\\n       }\\n     }else{\\n     for(int i =1; i < n; i++){\\n         pow = pow*x;\\n    }\\n    }\\n    return pow;\\n  }\\n    }"
                    }
                ]
            },
            {
                "id": 1722052,
                "content": [
                    {
                        "username": "tarikin",
                        "content": "Time Limit Exceeded n  = -2147483648, do we really need to check if n is -2147483648 and return fixed 0 value"
                    },
                    {
                        "username": "itsSankalp",
                        "content": "if n is negative \\n    return 1/pow(x,n)"
                    },
                    {
                        "username": "itsSankalp",
                        "content": "Easiest Approach\\nHint : Recursive approach\\n\\ndouble pow(double x, int n){\\n//base case(think)\\nif n is even : pow(x,n) = pow(x,n/2) * pow(x,n/2);\\nif n is odd : pow(x,n) = x * pow(x,n/2) * pow(x,n/2);\\n}\\n\\nmain(){\\nif(n is positive)\\n    return pow(x,n);\\nif(n is negative) \\n    return 1 / pow(x,n);\\n"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "why my code isn\\'t working: \\n \\ndouble myPow(double x, int n) {\\n        double ans = 1.00000;\\n        long long nn = n;\\n        if(nn<0) nn = -1 * nn;\\n        while(nn){\\n            if(nn%2){\\n                ans = ans * x;\\n                nn = nn-1;\\n            }\\n            else{\\n                ans = x*x;\\n                nn=nn/2;\\n            }\\n        }\\n        if(n<0) ans=(double)(1.0)/(double)(ans);\\n        return ans; \\n    }"
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "Please tell the mistake in this c++ code as it is giving Runtime error with deadly signal\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        long long nn=n;\\n\\n        if(nn<0.0) nn=-1*nn;\\n        //base condition\\n        if(nn==0.0) return 1.0;\\n        \\n        if(nn>0.0) return ((double)(x*myPow(x,n-1)));\\n\\n        return ((double)(1.0)/(double)(x*myPow(x,n-1)));\\n    }\\n};"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Help! I wrote a solution which I believe to run in`O(log(n)`time and`O(1)`space, but when I submit, it says it's in the bottom 5% of solutions. I'm unsure why? Thanks in advanced. Apologies for the formatting.\n\nconst pow = (x, n) => {\n   if (n === 0) return 1;\n\n   if (n < 0) {\n       n = -n;\n       x = 1/x;\n   }\n\n   let val = x;\n   for (let i = 1; i < n; ++i) {\n       if (i * 2 <= n) {\n        val *= val;\n        i *= 2;\n        i--;\n       } else {\n        val *= x;\n       }\n   } \n\n   return val;  \n}"
                    },
                    {
                        "username": "Shashank_Jangir17",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double ans=0;\\n        ans=pow(x,n);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Arnabiswas99",
                        "content": "Why this code got time limit exceed for input (INT_MAX)^(0.00001)?\\nclass Solution {\\npublic:\\ndouble helper(double x, int n)\\n{\\n        if(n==0) return 1;\\n        if(n==1) return x;\\n        if(n%2==0) return myPow(x,n/2)*myPow(x,n/2);\\n        else return x*myPow(x,n/2)*myPow(x,n/2);\\n}\\n    double myPow(double x, int n) {\\n        if(n>=0) return helper(x,n);\\n        else\\n        {\\n            double ans;\\n            ans=helper(x,(-1)*n);\\n            ans=1/ans;\\n            return ans;\\n        }\\n    }\\n};\\nThank You."
                    },
                    {
                        "username": "khetaj22",
                        "content": "WHY STACKOVERFLOW...\n\nclass Solution \n{\n    public double myPow(double x, int n) \n    {\n        if(n == 0)\n        {\n            return 1;\n        }\n            return x * myPow(x, n - 1);\n    }\n} "
                    },
                    {
                        "username": "anavale",
                        "content": "Why is this failing? It says I passed all the testcases however it says that I reached the time limit when \"x=\" with no value assigned to it.\\n \\n double myPow(double x, int n){\\n    double sum = 1;\\n\\n    if(isnan(x) != 0){\\n        sum = 0;\\n    } else if (x == 1){\\n        sum = 1;\\n    }else if(x == -1){\\n        if(n%2 == 1){ //If n is odd\\n            sum = -1;\\n        }else{\\n            sum = 1;\\n        }\\n    }else if(n < -100000){\\n        sum = 0;\\n    }else if(n>0){\\n        for(int i = 0; i < n; i++){\\n            sum = sum * x;\\n        }\\n    }else if(n == 0){\\n        sum = 1;\\n    }else if(n<0){\\n        for(int j = 0; j < abs(n); j++){\\n            sum = sum * x;\\n        }\\n        sum = 1/sum;\\n    }\\n    \\n    return sum;\\n}"
                    },
                    {
                        "username": "shivang_tripathi",
                        "content": "here is the my solution for this question, this solution is showing time limit exceeded, can anyone tell me how can optmize it more efficiently so the time limit is not exceeded\\n\\nclass Solution {\\n    public double myPow(double x, int n) {\\n    double pow = x; \\n    if(n == 0){\\n      return (double)1;\\n    } \\n    if (n < 0){\\n       n = n*(-1);\\n       pow = (1/x);\\n    for(int i =1; i < n; i++){\\n       pow = pow*(1/x);\\n       }\\n     }else{\\n     for(int i =1; i < n; i++){\\n         pow = pow*x;\\n    }\\n    }\\n    return pow;\\n  }\\n    }"
                    }
                ]
            },
            {
                "id": 1715241,
                "content": [
                    {
                        "username": "tarikin",
                        "content": "Time Limit Exceeded n  = -2147483648, do we really need to check if n is -2147483648 and return fixed 0 value"
                    },
                    {
                        "username": "itsSankalp",
                        "content": "if n is negative \\n    return 1/pow(x,n)"
                    },
                    {
                        "username": "itsSankalp",
                        "content": "Easiest Approach\\nHint : Recursive approach\\n\\ndouble pow(double x, int n){\\n//base case(think)\\nif n is even : pow(x,n) = pow(x,n/2) * pow(x,n/2);\\nif n is odd : pow(x,n) = x * pow(x,n/2) * pow(x,n/2);\\n}\\n\\nmain(){\\nif(n is positive)\\n    return pow(x,n);\\nif(n is negative) \\n    return 1 / pow(x,n);\\n"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "why my code isn\\'t working: \\n \\ndouble myPow(double x, int n) {\\n        double ans = 1.00000;\\n        long long nn = n;\\n        if(nn<0) nn = -1 * nn;\\n        while(nn){\\n            if(nn%2){\\n                ans = ans * x;\\n                nn = nn-1;\\n            }\\n            else{\\n                ans = x*x;\\n                nn=nn/2;\\n            }\\n        }\\n        if(n<0) ans=(double)(1.0)/(double)(ans);\\n        return ans; \\n    }"
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "Please tell the mistake in this c++ code as it is giving Runtime error with deadly signal\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        long long nn=n;\\n\\n        if(nn<0.0) nn=-1*nn;\\n        //base condition\\n        if(nn==0.0) return 1.0;\\n        \\n        if(nn>0.0) return ((double)(x*myPow(x,n-1)));\\n\\n        return ((double)(1.0)/(double)(x*myPow(x,n-1)));\\n    }\\n};"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Help! I wrote a solution which I believe to run in`O(log(n)`time and`O(1)`space, but when I submit, it says it's in the bottom 5% of solutions. I'm unsure why? Thanks in advanced. Apologies for the formatting.\n\nconst pow = (x, n) => {\n   if (n === 0) return 1;\n\n   if (n < 0) {\n       n = -n;\n       x = 1/x;\n   }\n\n   let val = x;\n   for (let i = 1; i < n; ++i) {\n       if (i * 2 <= n) {\n        val *= val;\n        i *= 2;\n        i--;\n       } else {\n        val *= x;\n       }\n   } \n\n   return val;  \n}"
                    },
                    {
                        "username": "Shashank_Jangir17",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double ans=0;\\n        ans=pow(x,n);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Arnabiswas99",
                        "content": "Why this code got time limit exceed for input (INT_MAX)^(0.00001)?\\nclass Solution {\\npublic:\\ndouble helper(double x, int n)\\n{\\n        if(n==0) return 1;\\n        if(n==1) return x;\\n        if(n%2==0) return myPow(x,n/2)*myPow(x,n/2);\\n        else return x*myPow(x,n/2)*myPow(x,n/2);\\n}\\n    double myPow(double x, int n) {\\n        if(n>=0) return helper(x,n);\\n        else\\n        {\\n            double ans;\\n            ans=helper(x,(-1)*n);\\n            ans=1/ans;\\n            return ans;\\n        }\\n    }\\n};\\nThank You."
                    },
                    {
                        "username": "khetaj22",
                        "content": "WHY STACKOVERFLOW...\n\nclass Solution \n{\n    public double myPow(double x, int n) \n    {\n        if(n == 0)\n        {\n            return 1;\n        }\n            return x * myPow(x, n - 1);\n    }\n} "
                    },
                    {
                        "username": "anavale",
                        "content": "Why is this failing? It says I passed all the testcases however it says that I reached the time limit when \"x=\" with no value assigned to it.\\n \\n double myPow(double x, int n){\\n    double sum = 1;\\n\\n    if(isnan(x) != 0){\\n        sum = 0;\\n    } else if (x == 1){\\n        sum = 1;\\n    }else if(x == -1){\\n        if(n%2 == 1){ //If n is odd\\n            sum = -1;\\n        }else{\\n            sum = 1;\\n        }\\n    }else if(n < -100000){\\n        sum = 0;\\n    }else if(n>0){\\n        for(int i = 0; i < n; i++){\\n            sum = sum * x;\\n        }\\n    }else if(n == 0){\\n        sum = 1;\\n    }else if(n<0){\\n        for(int j = 0; j < abs(n); j++){\\n            sum = sum * x;\\n        }\\n        sum = 1/sum;\\n    }\\n    \\n    return sum;\\n}"
                    },
                    {
                        "username": "shivang_tripathi",
                        "content": "here is the my solution for this question, this solution is showing time limit exceeded, can anyone tell me how can optmize it more efficiently so the time limit is not exceeded\\n\\nclass Solution {\\n    public double myPow(double x, int n) {\\n    double pow = x; \\n    if(n == 0){\\n      return (double)1;\\n    } \\n    if (n < 0){\\n       n = n*(-1);\\n       pow = (1/x);\\n    for(int i =1; i < n; i++){\\n       pow = pow*(1/x);\\n       }\\n     }else{\\n     for(int i =1; i < n; i++){\\n         pow = pow*x;\\n    }\\n    }\\n    return pow;\\n  }\\n    }"
                    }
                ]
            },
            {
                "id": 1714599,
                "content": [
                    {
                        "username": "nikhilgargdrb",
                        "content": "I solve this question using \\n\\nhttps://leetcode.com/problems/powx-n/submissions/858720192/\\n\\nHow solution can be more optimised ?"
                    },
                    {
                        "username": "groote",
                        "content": "\\n\\n```\\n public double myPow(double x, int n) {\\n        if(n==0)\\n        {\\n            return 1; \\n        }\\n        if(n==1)\\n        {\\n            return x;\\n        }\\n        if(n==-1)\\n        {\\n            return 1/x;\\n        }\\n\\n           double ans=myPow(x,n/2);\\n            if(n%2==0)\\n            {\\n                return ans*ans;\\n            }\\n\\n            return ans*ans*x;\\n        \\n    }\\n```\\n\\nWhy above code is not working for the below test case\\nx=34.00515\\nn=-3"
                    },
                    {
                        "username": "abhicodeshukla",
                        "content": "i think you have not written the code when n is negative.\\n"
                    },
                    {
                        "username": "Mayuri24",
                        "content": "Time Limit Exceeded issue.\\nCan someone help me?\\n\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        \\n        double ans=1.0;\\n        if(n<0){\\n            n = -n;\\n            x = 1/x;\\n        }\\n        for(int i=1; i<= n; i++)\\n        {\\n            ans= ans*x;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double result = pow(x,n);\\n        return result;\\n    }\\n};\\n\\none line code in c++"
                    },
                    {
                        "username": "Akshaygithubsd",
                        "content": "-----------------------------------------ERROR----------------------------------------\\nLine 9: Char 27: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:27\\n-------------------------------------------------------------------------------------------------------\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double a=1.0;\\n        if(n==0)\\n        return 1;\\n        else if(n>0){\\n        double y=n;\\n        for(int i=1;i<=y;i++)\\n        {\\n             a=a*x;\\n        }\\n        return a;\\n        }\\n        else{\\n            for(int i=-1;i>=n;i--){\\n                a=a/x;\\n            }\\n            return a;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Gopal_dixit",
                        "content": "// HELP ME TO FIND MISTAKE ,IT GIVES RUN TIME ERROR\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n   double anspow=1;\\n    if(n<0){\\n        long long int m=n;\\n    m=-n;\\n    x=1/x;\\n    double ans=myPow(x,m/2);\\n    if(m&1){\\n        return x*ans*ans;\\n    }\\n    else{\\n        return ans*ans;\\n    }\\n       \\n    }\\n    if(n==0){\\n            return 1;\\n    }\\n    if(n==1){\\n        return x;\\n    }\\n    double ans=myPow(x,n/2);\\n    if(n&1){\\n        return x*ans*ans;\\n    }\\n    else{\\n        return ans*ans;\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "IlyaMoskva",
                        "content": " if((n & 1) == 1) will be boolean"
                    },
                    {
                        "username": "Pintu236",
                        "content": "In recursive approach we need to cut the power to lowest possible subproblem. \nso let's say at leaf node we will have n if 1 then just return the x in case of negative 1/x.\nCheckout tree so you can get better understanding.\n[Tree for  2^6](https://drive.google.com/file/d/1hhmP7md8PpSyaMGCiCnr7_q7cvwPrTzz/view?usp=sharing)\n\n `if (n == 1) {\n            return x;\n        } else if (n == -1) {\n            return 1 / x;\n        }`\n"
                    },
                    {
                        "username": "kakashi11",
                        "content": "i got TLE for       n= INT_MAX   (2147483647)     and x= 1.00000\\nbut while i run it, it gives accepted correct ans, why so? \\n\\nthis is my code\\n long long temp=n;\\n        double ans=1.0;\\n        bool cnt=false;\\n\\n        if(n<0) \\n        {temp=(-1)*temp; cnt=true;}\\n            \\n        for(long long i=1; i<=temp; i++)\\n        {\\n            ans= ans*x;\\n        }\\n        if(cnt==true)\\n        return 1/ans;\\n\\n        else return ans;"
                    },
                    {
                        "username": "p1656531",
                        "content": "  public double myPow(double x, int n) {\\n        if (n == 0) return 1.0;\\n        if (n == 1) return x;\\n        if (n == -1) return 1 / x;\\n        double sqrt = myPow(x, n / 2);\\n        return sqrt * sqrt * myPow(x, n % 2);\\n    }"
                    },
                    {
                        "username": "skillcap",
                        "content": "Interesting, the answer is also the name of the problem..."
                    }
                ]
            },
            {
                "id": 1714177,
                "content": [
                    {
                        "username": "nikhilgargdrb",
                        "content": "I solve this question using \\n\\nhttps://leetcode.com/problems/powx-n/submissions/858720192/\\n\\nHow solution can be more optimised ?"
                    },
                    {
                        "username": "groote",
                        "content": "\\n\\n```\\n public double myPow(double x, int n) {\\n        if(n==0)\\n        {\\n            return 1; \\n        }\\n        if(n==1)\\n        {\\n            return x;\\n        }\\n        if(n==-1)\\n        {\\n            return 1/x;\\n        }\\n\\n           double ans=myPow(x,n/2);\\n            if(n%2==0)\\n            {\\n                return ans*ans;\\n            }\\n\\n            return ans*ans*x;\\n        \\n    }\\n```\\n\\nWhy above code is not working for the below test case\\nx=34.00515\\nn=-3"
                    },
                    {
                        "username": "abhicodeshukla",
                        "content": "i think you have not written the code when n is negative.\\n"
                    },
                    {
                        "username": "Mayuri24",
                        "content": "Time Limit Exceeded issue.\\nCan someone help me?\\n\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        \\n        double ans=1.0;\\n        if(n<0){\\n            n = -n;\\n            x = 1/x;\\n        }\\n        for(int i=1; i<= n; i++)\\n        {\\n            ans= ans*x;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double result = pow(x,n);\\n        return result;\\n    }\\n};\\n\\none line code in c++"
                    },
                    {
                        "username": "Akshaygithubsd",
                        "content": "-----------------------------------------ERROR----------------------------------------\\nLine 9: Char 27: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:27\\n-------------------------------------------------------------------------------------------------------\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double a=1.0;\\n        if(n==0)\\n        return 1;\\n        else if(n>0){\\n        double y=n;\\n        for(int i=1;i<=y;i++)\\n        {\\n             a=a*x;\\n        }\\n        return a;\\n        }\\n        else{\\n            for(int i=-1;i>=n;i--){\\n                a=a/x;\\n            }\\n            return a;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Gopal_dixit",
                        "content": "// HELP ME TO FIND MISTAKE ,IT GIVES RUN TIME ERROR\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n   double anspow=1;\\n    if(n<0){\\n        long long int m=n;\\n    m=-n;\\n    x=1/x;\\n    double ans=myPow(x,m/2);\\n    if(m&1){\\n        return x*ans*ans;\\n    }\\n    else{\\n        return ans*ans;\\n    }\\n       \\n    }\\n    if(n==0){\\n            return 1;\\n    }\\n    if(n==1){\\n        return x;\\n    }\\n    double ans=myPow(x,n/2);\\n    if(n&1){\\n        return x*ans*ans;\\n    }\\n    else{\\n        return ans*ans;\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "IlyaMoskva",
                        "content": " if((n & 1) == 1) will be boolean"
                    },
                    {
                        "username": "Pintu236",
                        "content": "In recursive approach we need to cut the power to lowest possible subproblem. \nso let's say at leaf node we will have n if 1 then just return the x in case of negative 1/x.\nCheckout tree so you can get better understanding.\n[Tree for  2^6](https://drive.google.com/file/d/1hhmP7md8PpSyaMGCiCnr7_q7cvwPrTzz/view?usp=sharing)\n\n `if (n == 1) {\n            return x;\n        } else if (n == -1) {\n            return 1 / x;\n        }`\n"
                    },
                    {
                        "username": "kakashi11",
                        "content": "i got TLE for       n= INT_MAX   (2147483647)     and x= 1.00000\\nbut while i run it, it gives accepted correct ans, why so? \\n\\nthis is my code\\n long long temp=n;\\n        double ans=1.0;\\n        bool cnt=false;\\n\\n        if(n<0) \\n        {temp=(-1)*temp; cnt=true;}\\n            \\n        for(long long i=1; i<=temp; i++)\\n        {\\n            ans= ans*x;\\n        }\\n        if(cnt==true)\\n        return 1/ans;\\n\\n        else return ans;"
                    },
                    {
                        "username": "p1656531",
                        "content": "  public double myPow(double x, int n) {\\n        if (n == 0) return 1.0;\\n        if (n == 1) return x;\\n        if (n == -1) return 1 / x;\\n        double sqrt = myPow(x, n / 2);\\n        return sqrt * sqrt * myPow(x, n % 2);\\n    }"
                    },
                    {
                        "username": "skillcap",
                        "content": "Interesting, the answer is also the name of the problem..."
                    }
                ]
            },
            {
                "id": 1712349,
                "content": [
                    {
                        "username": "nikhilgargdrb",
                        "content": "I solve this question using \\n\\nhttps://leetcode.com/problems/powx-n/submissions/858720192/\\n\\nHow solution can be more optimised ?"
                    },
                    {
                        "username": "groote",
                        "content": "\\n\\n```\\n public double myPow(double x, int n) {\\n        if(n==0)\\n        {\\n            return 1; \\n        }\\n        if(n==1)\\n        {\\n            return x;\\n        }\\n        if(n==-1)\\n        {\\n            return 1/x;\\n        }\\n\\n           double ans=myPow(x,n/2);\\n            if(n%2==0)\\n            {\\n                return ans*ans;\\n            }\\n\\n            return ans*ans*x;\\n        \\n    }\\n```\\n\\nWhy above code is not working for the below test case\\nx=34.00515\\nn=-3"
                    },
                    {
                        "username": "abhicodeshukla",
                        "content": "i think you have not written the code when n is negative.\\n"
                    },
                    {
                        "username": "Mayuri24",
                        "content": "Time Limit Exceeded issue.\\nCan someone help me?\\n\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        \\n        double ans=1.0;\\n        if(n<0){\\n            n = -n;\\n            x = 1/x;\\n        }\\n        for(int i=1; i<= n; i++)\\n        {\\n            ans= ans*x;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double result = pow(x,n);\\n        return result;\\n    }\\n};\\n\\none line code in c++"
                    },
                    {
                        "username": "Akshaygithubsd",
                        "content": "-----------------------------------------ERROR----------------------------------------\\nLine 9: Char 27: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:27\\n-------------------------------------------------------------------------------------------------------\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double a=1.0;\\n        if(n==0)\\n        return 1;\\n        else if(n>0){\\n        double y=n;\\n        for(int i=1;i<=y;i++)\\n        {\\n             a=a*x;\\n        }\\n        return a;\\n        }\\n        else{\\n            for(int i=-1;i>=n;i--){\\n                a=a/x;\\n            }\\n            return a;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Gopal_dixit",
                        "content": "// HELP ME TO FIND MISTAKE ,IT GIVES RUN TIME ERROR\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n   double anspow=1;\\n    if(n<0){\\n        long long int m=n;\\n    m=-n;\\n    x=1/x;\\n    double ans=myPow(x,m/2);\\n    if(m&1){\\n        return x*ans*ans;\\n    }\\n    else{\\n        return ans*ans;\\n    }\\n       \\n    }\\n    if(n==0){\\n            return 1;\\n    }\\n    if(n==1){\\n        return x;\\n    }\\n    double ans=myPow(x,n/2);\\n    if(n&1){\\n        return x*ans*ans;\\n    }\\n    else{\\n        return ans*ans;\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "IlyaMoskva",
                        "content": " if((n & 1) == 1) will be boolean"
                    },
                    {
                        "username": "Pintu236",
                        "content": "In recursive approach we need to cut the power to lowest possible subproblem. \nso let's say at leaf node we will have n if 1 then just return the x in case of negative 1/x.\nCheckout tree so you can get better understanding.\n[Tree for  2^6](https://drive.google.com/file/d/1hhmP7md8PpSyaMGCiCnr7_q7cvwPrTzz/view?usp=sharing)\n\n `if (n == 1) {\n            return x;\n        } else if (n == -1) {\n            return 1 / x;\n        }`\n"
                    },
                    {
                        "username": "kakashi11",
                        "content": "i got TLE for       n= INT_MAX   (2147483647)     and x= 1.00000\\nbut while i run it, it gives accepted correct ans, why so? \\n\\nthis is my code\\n long long temp=n;\\n        double ans=1.0;\\n        bool cnt=false;\\n\\n        if(n<0) \\n        {temp=(-1)*temp; cnt=true;}\\n            \\n        for(long long i=1; i<=temp; i++)\\n        {\\n            ans= ans*x;\\n        }\\n        if(cnt==true)\\n        return 1/ans;\\n\\n        else return ans;"
                    },
                    {
                        "username": "p1656531",
                        "content": "  public double myPow(double x, int n) {\\n        if (n == 0) return 1.0;\\n        if (n == 1) return x;\\n        if (n == -1) return 1 / x;\\n        double sqrt = myPow(x, n / 2);\\n        return sqrt * sqrt * myPow(x, n % 2);\\n    }"
                    },
                    {
                        "username": "skillcap",
                        "content": "Interesting, the answer is also the name of the problem..."
                    }
                ]
            },
            {
                "id": 1711902,
                "content": [
                    {
                        "username": "nikhilgargdrb",
                        "content": "I solve this question using \\n\\nhttps://leetcode.com/problems/powx-n/submissions/858720192/\\n\\nHow solution can be more optimised ?"
                    },
                    {
                        "username": "groote",
                        "content": "\\n\\n```\\n public double myPow(double x, int n) {\\n        if(n==0)\\n        {\\n            return 1; \\n        }\\n        if(n==1)\\n        {\\n            return x;\\n        }\\n        if(n==-1)\\n        {\\n            return 1/x;\\n        }\\n\\n           double ans=myPow(x,n/2);\\n            if(n%2==0)\\n            {\\n                return ans*ans;\\n            }\\n\\n            return ans*ans*x;\\n        \\n    }\\n```\\n\\nWhy above code is not working for the below test case\\nx=34.00515\\nn=-3"
                    },
                    {
                        "username": "abhicodeshukla",
                        "content": "i think you have not written the code when n is negative.\\n"
                    },
                    {
                        "username": "Mayuri24",
                        "content": "Time Limit Exceeded issue.\\nCan someone help me?\\n\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        \\n        double ans=1.0;\\n        if(n<0){\\n            n = -n;\\n            x = 1/x;\\n        }\\n        for(int i=1; i<= n; i++)\\n        {\\n            ans= ans*x;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double result = pow(x,n);\\n        return result;\\n    }\\n};\\n\\none line code in c++"
                    },
                    {
                        "username": "Akshaygithubsd",
                        "content": "-----------------------------------------ERROR----------------------------------------\\nLine 9: Char 27: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:27\\n-------------------------------------------------------------------------------------------------------\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double a=1.0;\\n        if(n==0)\\n        return 1;\\n        else if(n>0){\\n        double y=n;\\n        for(int i=1;i<=y;i++)\\n        {\\n             a=a*x;\\n        }\\n        return a;\\n        }\\n        else{\\n            for(int i=-1;i>=n;i--){\\n                a=a/x;\\n            }\\n            return a;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Gopal_dixit",
                        "content": "// HELP ME TO FIND MISTAKE ,IT GIVES RUN TIME ERROR\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n   double anspow=1;\\n    if(n<0){\\n        long long int m=n;\\n    m=-n;\\n    x=1/x;\\n    double ans=myPow(x,m/2);\\n    if(m&1){\\n        return x*ans*ans;\\n    }\\n    else{\\n        return ans*ans;\\n    }\\n       \\n    }\\n    if(n==0){\\n            return 1;\\n    }\\n    if(n==1){\\n        return x;\\n    }\\n    double ans=myPow(x,n/2);\\n    if(n&1){\\n        return x*ans*ans;\\n    }\\n    else{\\n        return ans*ans;\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "IlyaMoskva",
                        "content": " if((n & 1) == 1) will be boolean"
                    },
                    {
                        "username": "Pintu236",
                        "content": "In recursive approach we need to cut the power to lowest possible subproblem. \nso let's say at leaf node we will have n if 1 then just return the x in case of negative 1/x.\nCheckout tree so you can get better understanding.\n[Tree for  2^6](https://drive.google.com/file/d/1hhmP7md8PpSyaMGCiCnr7_q7cvwPrTzz/view?usp=sharing)\n\n `if (n == 1) {\n            return x;\n        } else if (n == -1) {\n            return 1 / x;\n        }`\n"
                    },
                    {
                        "username": "kakashi11",
                        "content": "i got TLE for       n= INT_MAX   (2147483647)     and x= 1.00000\\nbut while i run it, it gives accepted correct ans, why so? \\n\\nthis is my code\\n long long temp=n;\\n        double ans=1.0;\\n        bool cnt=false;\\n\\n        if(n<0) \\n        {temp=(-1)*temp; cnt=true;}\\n            \\n        for(long long i=1; i<=temp; i++)\\n        {\\n            ans= ans*x;\\n        }\\n        if(cnt==true)\\n        return 1/ans;\\n\\n        else return ans;"
                    },
                    {
                        "username": "p1656531",
                        "content": "  public double myPow(double x, int n) {\\n        if (n == 0) return 1.0;\\n        if (n == 1) return x;\\n        if (n == -1) return 1 / x;\\n        double sqrt = myPow(x, n / 2);\\n        return sqrt * sqrt * myPow(x, n % 2);\\n    }"
                    },
                    {
                        "username": "skillcap",
                        "content": "Interesting, the answer is also the name of the problem..."
                    }
                ]
            },
            {
                "id": 1711744,
                "content": [
                    {
                        "username": "nikhilgargdrb",
                        "content": "I solve this question using \\n\\nhttps://leetcode.com/problems/powx-n/submissions/858720192/\\n\\nHow solution can be more optimised ?"
                    },
                    {
                        "username": "groote",
                        "content": "\\n\\n```\\n public double myPow(double x, int n) {\\n        if(n==0)\\n        {\\n            return 1; \\n        }\\n        if(n==1)\\n        {\\n            return x;\\n        }\\n        if(n==-1)\\n        {\\n            return 1/x;\\n        }\\n\\n           double ans=myPow(x,n/2);\\n            if(n%2==0)\\n            {\\n                return ans*ans;\\n            }\\n\\n            return ans*ans*x;\\n        \\n    }\\n```\\n\\nWhy above code is not working for the below test case\\nx=34.00515\\nn=-3"
                    },
                    {
                        "username": "abhicodeshukla",
                        "content": "i think you have not written the code when n is negative.\\n"
                    },
                    {
                        "username": "Mayuri24",
                        "content": "Time Limit Exceeded issue.\\nCan someone help me?\\n\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        \\n        double ans=1.0;\\n        if(n<0){\\n            n = -n;\\n            x = 1/x;\\n        }\\n        for(int i=1; i<= n; i++)\\n        {\\n            ans= ans*x;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double result = pow(x,n);\\n        return result;\\n    }\\n};\\n\\none line code in c++"
                    },
                    {
                        "username": "Akshaygithubsd",
                        "content": "-----------------------------------------ERROR----------------------------------------\\nLine 9: Char 27: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:27\\n-------------------------------------------------------------------------------------------------------\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double a=1.0;\\n        if(n==0)\\n        return 1;\\n        else if(n>0){\\n        double y=n;\\n        for(int i=1;i<=y;i++)\\n        {\\n             a=a*x;\\n        }\\n        return a;\\n        }\\n        else{\\n            for(int i=-1;i>=n;i--){\\n                a=a/x;\\n            }\\n            return a;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Gopal_dixit",
                        "content": "// HELP ME TO FIND MISTAKE ,IT GIVES RUN TIME ERROR\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n   double anspow=1;\\n    if(n<0){\\n        long long int m=n;\\n    m=-n;\\n    x=1/x;\\n    double ans=myPow(x,m/2);\\n    if(m&1){\\n        return x*ans*ans;\\n    }\\n    else{\\n        return ans*ans;\\n    }\\n       \\n    }\\n    if(n==0){\\n            return 1;\\n    }\\n    if(n==1){\\n        return x;\\n    }\\n    double ans=myPow(x,n/2);\\n    if(n&1){\\n        return x*ans*ans;\\n    }\\n    else{\\n        return ans*ans;\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "IlyaMoskva",
                        "content": " if((n & 1) == 1) will be boolean"
                    },
                    {
                        "username": "Pintu236",
                        "content": "In recursive approach we need to cut the power to lowest possible subproblem. \nso let's say at leaf node we will have n if 1 then just return the x in case of negative 1/x.\nCheckout tree so you can get better understanding.\n[Tree for  2^6](https://drive.google.com/file/d/1hhmP7md8PpSyaMGCiCnr7_q7cvwPrTzz/view?usp=sharing)\n\n `if (n == 1) {\n            return x;\n        } else if (n == -1) {\n            return 1 / x;\n        }`\n"
                    },
                    {
                        "username": "kakashi11",
                        "content": "i got TLE for       n= INT_MAX   (2147483647)     and x= 1.00000\\nbut while i run it, it gives accepted correct ans, why so? \\n\\nthis is my code\\n long long temp=n;\\n        double ans=1.0;\\n        bool cnt=false;\\n\\n        if(n<0) \\n        {temp=(-1)*temp; cnt=true;}\\n            \\n        for(long long i=1; i<=temp; i++)\\n        {\\n            ans= ans*x;\\n        }\\n        if(cnt==true)\\n        return 1/ans;\\n\\n        else return ans;"
                    },
                    {
                        "username": "p1656531",
                        "content": "  public double myPow(double x, int n) {\\n        if (n == 0) return 1.0;\\n        if (n == 1) return x;\\n        if (n == -1) return 1 / x;\\n        double sqrt = myPow(x, n / 2);\\n        return sqrt * sqrt * myPow(x, n % 2);\\n    }"
                    },
                    {
                        "username": "skillcap",
                        "content": "Interesting, the answer is also the name of the problem..."
                    }
                ]
            },
            {
                "id": 1711170,
                "content": [
                    {
                        "username": "nikhilgargdrb",
                        "content": "I solve this question using \\n\\nhttps://leetcode.com/problems/powx-n/submissions/858720192/\\n\\nHow solution can be more optimised ?"
                    },
                    {
                        "username": "groote",
                        "content": "\\n\\n```\\n public double myPow(double x, int n) {\\n        if(n==0)\\n        {\\n            return 1; \\n        }\\n        if(n==1)\\n        {\\n            return x;\\n        }\\n        if(n==-1)\\n        {\\n            return 1/x;\\n        }\\n\\n           double ans=myPow(x,n/2);\\n            if(n%2==0)\\n            {\\n                return ans*ans;\\n            }\\n\\n            return ans*ans*x;\\n        \\n    }\\n```\\n\\nWhy above code is not working for the below test case\\nx=34.00515\\nn=-3"
                    },
                    {
                        "username": "abhicodeshukla",
                        "content": "i think you have not written the code when n is negative.\\n"
                    },
                    {
                        "username": "Mayuri24",
                        "content": "Time Limit Exceeded issue.\\nCan someone help me?\\n\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        \\n        double ans=1.0;\\n        if(n<0){\\n            n = -n;\\n            x = 1/x;\\n        }\\n        for(int i=1; i<= n; i++)\\n        {\\n            ans= ans*x;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double result = pow(x,n);\\n        return result;\\n    }\\n};\\n\\none line code in c++"
                    },
                    {
                        "username": "Akshaygithubsd",
                        "content": "-----------------------------------------ERROR----------------------------------------\\nLine 9: Char 27: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:27\\n-------------------------------------------------------------------------------------------------------\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double a=1.0;\\n        if(n==0)\\n        return 1;\\n        else if(n>0){\\n        double y=n;\\n        for(int i=1;i<=y;i++)\\n        {\\n             a=a*x;\\n        }\\n        return a;\\n        }\\n        else{\\n            for(int i=-1;i>=n;i--){\\n                a=a/x;\\n            }\\n            return a;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Gopal_dixit",
                        "content": "// HELP ME TO FIND MISTAKE ,IT GIVES RUN TIME ERROR\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n   double anspow=1;\\n    if(n<0){\\n        long long int m=n;\\n    m=-n;\\n    x=1/x;\\n    double ans=myPow(x,m/2);\\n    if(m&1){\\n        return x*ans*ans;\\n    }\\n    else{\\n        return ans*ans;\\n    }\\n       \\n    }\\n    if(n==0){\\n            return 1;\\n    }\\n    if(n==1){\\n        return x;\\n    }\\n    double ans=myPow(x,n/2);\\n    if(n&1){\\n        return x*ans*ans;\\n    }\\n    else{\\n        return ans*ans;\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "IlyaMoskva",
                        "content": " if((n & 1) == 1) will be boolean"
                    },
                    {
                        "username": "Pintu236",
                        "content": "In recursive approach we need to cut the power to lowest possible subproblem. \nso let's say at leaf node we will have n if 1 then just return the x in case of negative 1/x.\nCheckout tree so you can get better understanding.\n[Tree for  2^6](https://drive.google.com/file/d/1hhmP7md8PpSyaMGCiCnr7_q7cvwPrTzz/view?usp=sharing)\n\n `if (n == 1) {\n            return x;\n        } else if (n == -1) {\n            return 1 / x;\n        }`\n"
                    },
                    {
                        "username": "kakashi11",
                        "content": "i got TLE for       n= INT_MAX   (2147483647)     and x= 1.00000\\nbut while i run it, it gives accepted correct ans, why so? \\n\\nthis is my code\\n long long temp=n;\\n        double ans=1.0;\\n        bool cnt=false;\\n\\n        if(n<0) \\n        {temp=(-1)*temp; cnt=true;}\\n            \\n        for(long long i=1; i<=temp; i++)\\n        {\\n            ans= ans*x;\\n        }\\n        if(cnt==true)\\n        return 1/ans;\\n\\n        else return ans;"
                    },
                    {
                        "username": "p1656531",
                        "content": "  public double myPow(double x, int n) {\\n        if (n == 0) return 1.0;\\n        if (n == 1) return x;\\n        if (n == -1) return 1 / x;\\n        double sqrt = myPow(x, n / 2);\\n        return sqrt * sqrt * myPow(x, n % 2);\\n    }"
                    },
                    {
                        "username": "skillcap",
                        "content": "Interesting, the answer is also the name of the problem..."
                    }
                ]
            },
            {
                "id": 1711095,
                "content": [
                    {
                        "username": "nikhilgargdrb",
                        "content": "I solve this question using \\n\\nhttps://leetcode.com/problems/powx-n/submissions/858720192/\\n\\nHow solution can be more optimised ?"
                    },
                    {
                        "username": "groote",
                        "content": "\\n\\n```\\n public double myPow(double x, int n) {\\n        if(n==0)\\n        {\\n            return 1; \\n        }\\n        if(n==1)\\n        {\\n            return x;\\n        }\\n        if(n==-1)\\n        {\\n            return 1/x;\\n        }\\n\\n           double ans=myPow(x,n/2);\\n            if(n%2==0)\\n            {\\n                return ans*ans;\\n            }\\n\\n            return ans*ans*x;\\n        \\n    }\\n```\\n\\nWhy above code is not working for the below test case\\nx=34.00515\\nn=-3"
                    },
                    {
                        "username": "abhicodeshukla",
                        "content": "i think you have not written the code when n is negative.\\n"
                    },
                    {
                        "username": "Mayuri24",
                        "content": "Time Limit Exceeded issue.\\nCan someone help me?\\n\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        \\n        double ans=1.0;\\n        if(n<0){\\n            n = -n;\\n            x = 1/x;\\n        }\\n        for(int i=1; i<= n; i++)\\n        {\\n            ans= ans*x;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double result = pow(x,n);\\n        return result;\\n    }\\n};\\n\\none line code in c++"
                    },
                    {
                        "username": "Akshaygithubsd",
                        "content": "-----------------------------------------ERROR----------------------------------------\\nLine 9: Char 27: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:27\\n-------------------------------------------------------------------------------------------------------\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double a=1.0;\\n        if(n==0)\\n        return 1;\\n        else if(n>0){\\n        double y=n;\\n        for(int i=1;i<=y;i++)\\n        {\\n             a=a*x;\\n        }\\n        return a;\\n        }\\n        else{\\n            for(int i=-1;i>=n;i--){\\n                a=a/x;\\n            }\\n            return a;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Gopal_dixit",
                        "content": "// HELP ME TO FIND MISTAKE ,IT GIVES RUN TIME ERROR\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n   double anspow=1;\\n    if(n<0){\\n        long long int m=n;\\n    m=-n;\\n    x=1/x;\\n    double ans=myPow(x,m/2);\\n    if(m&1){\\n        return x*ans*ans;\\n    }\\n    else{\\n        return ans*ans;\\n    }\\n       \\n    }\\n    if(n==0){\\n            return 1;\\n    }\\n    if(n==1){\\n        return x;\\n    }\\n    double ans=myPow(x,n/2);\\n    if(n&1){\\n        return x*ans*ans;\\n    }\\n    else{\\n        return ans*ans;\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "IlyaMoskva",
                        "content": " if((n & 1) == 1) will be boolean"
                    },
                    {
                        "username": "Pintu236",
                        "content": "In recursive approach we need to cut the power to lowest possible subproblem. \nso let's say at leaf node we will have n if 1 then just return the x in case of negative 1/x.\nCheckout tree so you can get better understanding.\n[Tree for  2^6](https://drive.google.com/file/d/1hhmP7md8PpSyaMGCiCnr7_q7cvwPrTzz/view?usp=sharing)\n\n `if (n == 1) {\n            return x;\n        } else if (n == -1) {\n            return 1 / x;\n        }`\n"
                    },
                    {
                        "username": "kakashi11",
                        "content": "i got TLE for       n= INT_MAX   (2147483647)     and x= 1.00000\\nbut while i run it, it gives accepted correct ans, why so? \\n\\nthis is my code\\n long long temp=n;\\n        double ans=1.0;\\n        bool cnt=false;\\n\\n        if(n<0) \\n        {temp=(-1)*temp; cnt=true;}\\n            \\n        for(long long i=1; i<=temp; i++)\\n        {\\n            ans= ans*x;\\n        }\\n        if(cnt==true)\\n        return 1/ans;\\n\\n        else return ans;"
                    },
                    {
                        "username": "p1656531",
                        "content": "  public double myPow(double x, int n) {\\n        if (n == 0) return 1.0;\\n        if (n == 1) return x;\\n        if (n == -1) return 1 / x;\\n        double sqrt = myPow(x, n / 2);\\n        return sqrt * sqrt * myPow(x, n % 2);\\n    }"
                    },
                    {
                        "username": "skillcap",
                        "content": "Interesting, the answer is also the name of the problem..."
                    }
                ]
            },
            {
                "id": 1702724,
                "content": [
                    {
                        "username": "nikhilgargdrb",
                        "content": "I solve this question using \\n\\nhttps://leetcode.com/problems/powx-n/submissions/858720192/\\n\\nHow solution can be more optimised ?"
                    },
                    {
                        "username": "groote",
                        "content": "\\n\\n```\\n public double myPow(double x, int n) {\\n        if(n==0)\\n        {\\n            return 1; \\n        }\\n        if(n==1)\\n        {\\n            return x;\\n        }\\n        if(n==-1)\\n        {\\n            return 1/x;\\n        }\\n\\n           double ans=myPow(x,n/2);\\n            if(n%2==0)\\n            {\\n                return ans*ans;\\n            }\\n\\n            return ans*ans*x;\\n        \\n    }\\n```\\n\\nWhy above code is not working for the below test case\\nx=34.00515\\nn=-3"
                    },
                    {
                        "username": "abhicodeshukla",
                        "content": "i think you have not written the code when n is negative.\\n"
                    },
                    {
                        "username": "Mayuri24",
                        "content": "Time Limit Exceeded issue.\\nCan someone help me?\\n\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        \\n        double ans=1.0;\\n        if(n<0){\\n            n = -n;\\n            x = 1/x;\\n        }\\n        for(int i=1; i<= n; i++)\\n        {\\n            ans= ans*x;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double result = pow(x,n);\\n        return result;\\n    }\\n};\\n\\none line code in c++"
                    },
                    {
                        "username": "Akshaygithubsd",
                        "content": "-----------------------------------------ERROR----------------------------------------\\nLine 9: Char 27: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:27\\n-------------------------------------------------------------------------------------------------------\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double a=1.0;\\n        if(n==0)\\n        return 1;\\n        else if(n>0){\\n        double y=n;\\n        for(int i=1;i<=y;i++)\\n        {\\n             a=a*x;\\n        }\\n        return a;\\n        }\\n        else{\\n            for(int i=-1;i>=n;i--){\\n                a=a/x;\\n            }\\n            return a;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Gopal_dixit",
                        "content": "// HELP ME TO FIND MISTAKE ,IT GIVES RUN TIME ERROR\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n   double anspow=1;\\n    if(n<0){\\n        long long int m=n;\\n    m=-n;\\n    x=1/x;\\n    double ans=myPow(x,m/2);\\n    if(m&1){\\n        return x*ans*ans;\\n    }\\n    else{\\n        return ans*ans;\\n    }\\n       \\n    }\\n    if(n==0){\\n            return 1;\\n    }\\n    if(n==1){\\n        return x;\\n    }\\n    double ans=myPow(x,n/2);\\n    if(n&1){\\n        return x*ans*ans;\\n    }\\n    else{\\n        return ans*ans;\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "IlyaMoskva",
                        "content": " if((n & 1) == 1) will be boolean"
                    },
                    {
                        "username": "Pintu236",
                        "content": "In recursive approach we need to cut the power to lowest possible subproblem. \nso let's say at leaf node we will have n if 1 then just return the x in case of negative 1/x.\nCheckout tree so you can get better understanding.\n[Tree for  2^6](https://drive.google.com/file/d/1hhmP7md8PpSyaMGCiCnr7_q7cvwPrTzz/view?usp=sharing)\n\n `if (n == 1) {\n            return x;\n        } else if (n == -1) {\n            return 1 / x;\n        }`\n"
                    },
                    {
                        "username": "kakashi11",
                        "content": "i got TLE for       n= INT_MAX   (2147483647)     and x= 1.00000\\nbut while i run it, it gives accepted correct ans, why so? \\n\\nthis is my code\\n long long temp=n;\\n        double ans=1.0;\\n        bool cnt=false;\\n\\n        if(n<0) \\n        {temp=(-1)*temp; cnt=true;}\\n            \\n        for(long long i=1; i<=temp; i++)\\n        {\\n            ans= ans*x;\\n        }\\n        if(cnt==true)\\n        return 1/ans;\\n\\n        else return ans;"
                    },
                    {
                        "username": "p1656531",
                        "content": "  public double myPow(double x, int n) {\\n        if (n == 0) return 1.0;\\n        if (n == 1) return x;\\n        if (n == -1) return 1 / x;\\n        double sqrt = myPow(x, n / 2);\\n        return sqrt * sqrt * myPow(x, n % 2);\\n    }"
                    },
                    {
                        "username": "skillcap",
                        "content": "Interesting, the answer is also the name of the problem..."
                    }
                ]
            },
            {
                "id": 1702558,
                "content": [
                    {
                        "username": "nikhilgargdrb",
                        "content": "I solve this question using \\n\\nhttps://leetcode.com/problems/powx-n/submissions/858720192/\\n\\nHow solution can be more optimised ?"
                    },
                    {
                        "username": "groote",
                        "content": "\\n\\n```\\n public double myPow(double x, int n) {\\n        if(n==0)\\n        {\\n            return 1; \\n        }\\n        if(n==1)\\n        {\\n            return x;\\n        }\\n        if(n==-1)\\n        {\\n            return 1/x;\\n        }\\n\\n           double ans=myPow(x,n/2);\\n            if(n%2==0)\\n            {\\n                return ans*ans;\\n            }\\n\\n            return ans*ans*x;\\n        \\n    }\\n```\\n\\nWhy above code is not working for the below test case\\nx=34.00515\\nn=-3"
                    },
                    {
                        "username": "abhicodeshukla",
                        "content": "i think you have not written the code when n is negative.\\n"
                    },
                    {
                        "username": "Mayuri24",
                        "content": "Time Limit Exceeded issue.\\nCan someone help me?\\n\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        \\n        double ans=1.0;\\n        if(n<0){\\n            n = -n;\\n            x = 1/x;\\n        }\\n        for(int i=1; i<= n; i++)\\n        {\\n            ans= ans*x;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double result = pow(x,n);\\n        return result;\\n    }\\n};\\n\\none line code in c++"
                    },
                    {
                        "username": "Akshaygithubsd",
                        "content": "-----------------------------------------ERROR----------------------------------------\\nLine 9: Char 27: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:27\\n-------------------------------------------------------------------------------------------------------\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double a=1.0;\\n        if(n==0)\\n        return 1;\\n        else if(n>0){\\n        double y=n;\\n        for(int i=1;i<=y;i++)\\n        {\\n             a=a*x;\\n        }\\n        return a;\\n        }\\n        else{\\n            for(int i=-1;i>=n;i--){\\n                a=a/x;\\n            }\\n            return a;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Gopal_dixit",
                        "content": "// HELP ME TO FIND MISTAKE ,IT GIVES RUN TIME ERROR\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n   double anspow=1;\\n    if(n<0){\\n        long long int m=n;\\n    m=-n;\\n    x=1/x;\\n    double ans=myPow(x,m/2);\\n    if(m&1){\\n        return x*ans*ans;\\n    }\\n    else{\\n        return ans*ans;\\n    }\\n       \\n    }\\n    if(n==0){\\n            return 1;\\n    }\\n    if(n==1){\\n        return x;\\n    }\\n    double ans=myPow(x,n/2);\\n    if(n&1){\\n        return x*ans*ans;\\n    }\\n    else{\\n        return ans*ans;\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "IlyaMoskva",
                        "content": " if((n & 1) == 1) will be boolean"
                    },
                    {
                        "username": "Pintu236",
                        "content": "In recursive approach we need to cut the power to lowest possible subproblem. \nso let's say at leaf node we will have n if 1 then just return the x in case of negative 1/x.\nCheckout tree so you can get better understanding.\n[Tree for  2^6](https://drive.google.com/file/d/1hhmP7md8PpSyaMGCiCnr7_q7cvwPrTzz/view?usp=sharing)\n\n `if (n == 1) {\n            return x;\n        } else if (n == -1) {\n            return 1 / x;\n        }`\n"
                    },
                    {
                        "username": "kakashi11",
                        "content": "i got TLE for       n= INT_MAX   (2147483647)     and x= 1.00000\\nbut while i run it, it gives accepted correct ans, why so? \\n\\nthis is my code\\n long long temp=n;\\n        double ans=1.0;\\n        bool cnt=false;\\n\\n        if(n<0) \\n        {temp=(-1)*temp; cnt=true;}\\n            \\n        for(long long i=1; i<=temp; i++)\\n        {\\n            ans= ans*x;\\n        }\\n        if(cnt==true)\\n        return 1/ans;\\n\\n        else return ans;"
                    },
                    {
                        "username": "p1656531",
                        "content": "  public double myPow(double x, int n) {\\n        if (n == 0) return 1.0;\\n        if (n == 1) return x;\\n        if (n == -1) return 1 / x;\\n        double sqrt = myPow(x, n / 2);\\n        return sqrt * sqrt * myPow(x, n % 2);\\n    }"
                    },
                    {
                        "username": "skillcap",
                        "content": "Interesting, the answer is also the name of the problem..."
                    }
                ]
            },
            {
                "id": 1683338,
                "content": [
                    {
                        "username": "nikhilgargdrb",
                        "content": "I solve this question using \\n\\nhttps://leetcode.com/problems/powx-n/submissions/858720192/\\n\\nHow solution can be more optimised ?"
                    },
                    {
                        "username": "groote",
                        "content": "\\n\\n```\\n public double myPow(double x, int n) {\\n        if(n==0)\\n        {\\n            return 1; \\n        }\\n        if(n==1)\\n        {\\n            return x;\\n        }\\n        if(n==-1)\\n        {\\n            return 1/x;\\n        }\\n\\n           double ans=myPow(x,n/2);\\n            if(n%2==0)\\n            {\\n                return ans*ans;\\n            }\\n\\n            return ans*ans*x;\\n        \\n    }\\n```\\n\\nWhy above code is not working for the below test case\\nx=34.00515\\nn=-3"
                    },
                    {
                        "username": "abhicodeshukla",
                        "content": "i think you have not written the code when n is negative.\\n"
                    },
                    {
                        "username": "Mayuri24",
                        "content": "Time Limit Exceeded issue.\\nCan someone help me?\\n\\nclass Solution {\\n    public double myPow(double x, int n) {\\n        \\n        double ans=1.0;\\n        if(n<0){\\n            n = -n;\\n            x = 1/x;\\n        }\\n        for(int i=1; i<= n; i++)\\n        {\\n            ans= ans*x;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double result = pow(x,n);\\n        return result;\\n    }\\n};\\n\\none line code in c++"
                    },
                    {
                        "username": "Akshaygithubsd",
                        "content": "-----------------------------------------ERROR----------------------------------------\\nLine 9: Char 27: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:27\\n-------------------------------------------------------------------------------------------------------\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n        double a=1.0;\\n        if(n==0)\\n        return 1;\\n        else if(n>0){\\n        double y=n;\\n        for(int i=1;i<=y;i++)\\n        {\\n             a=a*x;\\n        }\\n        return a;\\n        }\\n        else{\\n            for(int i=-1;i>=n;i--){\\n                a=a/x;\\n            }\\n            return a;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Gopal_dixit",
                        "content": "// HELP ME TO FIND MISTAKE ,IT GIVES RUN TIME ERROR\\n\\nclass Solution {\\npublic:\\n    double myPow(double x, int n) {\\n   double anspow=1;\\n    if(n<0){\\n        long long int m=n;\\n    m=-n;\\n    x=1/x;\\n    double ans=myPow(x,m/2);\\n    if(m&1){\\n        return x*ans*ans;\\n    }\\n    else{\\n        return ans*ans;\\n    }\\n       \\n    }\\n    if(n==0){\\n            return 1;\\n    }\\n    if(n==1){\\n        return x;\\n    }\\n    double ans=myPow(x,n/2);\\n    if(n&1){\\n        return x*ans*ans;\\n    }\\n    else{\\n        return ans*ans;\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "IlyaMoskva",
                        "content": " if((n & 1) == 1) will be boolean"
                    },
                    {
                        "username": "Pintu236",
                        "content": "In recursive approach we need to cut the power to lowest possible subproblem. \nso let's say at leaf node we will have n if 1 then just return the x in case of negative 1/x.\nCheckout tree so you can get better understanding.\n[Tree for  2^6](https://drive.google.com/file/d/1hhmP7md8PpSyaMGCiCnr7_q7cvwPrTzz/view?usp=sharing)\n\n `if (n == 1) {\n            return x;\n        } else if (n == -1) {\n            return 1 / x;\n        }`\n"
                    },
                    {
                        "username": "kakashi11",
                        "content": "i got TLE for       n= INT_MAX   (2147483647)     and x= 1.00000\\nbut while i run it, it gives accepted correct ans, why so? \\n\\nthis is my code\\n long long temp=n;\\n        double ans=1.0;\\n        bool cnt=false;\\n\\n        if(n<0) \\n        {temp=(-1)*temp; cnt=true;}\\n            \\n        for(long long i=1; i<=temp; i++)\\n        {\\n            ans= ans*x;\\n        }\\n        if(cnt==true)\\n        return 1/ans;\\n\\n        else return ans;"
                    },
                    {
                        "username": "p1656531",
                        "content": "  public double myPow(double x, int n) {\\n        if (n == 0) return 1.0;\\n        if (n == 1) return x;\\n        if (n == -1) return 1 / x;\\n        double sqrt = myPow(x, n / 2);\\n        return sqrt * sqrt * myPow(x, n % 2);\\n    }"
                    },
                    {
                        "username": "skillcap",
                        "content": "Interesting, the answer is also the name of the problem..."
                    }
                ]
            },
            {
                "id": 1678945,
                "content": [
                    {
                        "username": "zhangyueming",
                        "content": "n/=2 Time Limit Exceed\\nn>>>1 Beat 100%"
                    },
                    {
                        "username": "araiz01",
                        "content": "I\\'m getting java.lang.StackOverflowError on line 6 which is as follows: \\n`\\n    public double myPow(double x, int n) {\\n        if(n>0){\\n            if(n == 1)\\n                return x;\\n            return x * myPow(x, n-1);\\n        }`"
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "ghatiya sawaal"
                    },
                    {
                        "username": "barstow123",
                        "content": "Heads up. This question is math heavy. \\n\\nIf you are below senior or principle level, you won\\'t see this problem in your interviews. Focus on Dynamic Programming, String, Array, and Search problems instead.\\n\\nEven for senior level, this style of problem is rare to see."
                    },
                    {
                        "username": "rustammollaa",
                        "content": "class Solution {\\n    public double myPow(double x, int n) {\\n        long n1=Math.abs((long)n);\\n        double ans=1.0;\\n        if(n==0) return 1;\\n        if(n<0) x=1/x;\\n        while(n1!=0){\\n            if(n1%2==1){\\n                ans*=x;\\n                n1-=1;\\n            }\\n            else{\\n                x*=x;\\n                n1/=2;\\n            }\\n        } \\n        \\n\\n        return ans ;\\n    }\\n}"
                    },
                    {
                        "username": "arnavjain",
                        "content": "Runtime: 16 ms, faster than 99.42%  Memory Usage: 12.8 MB, less than 100.00% \\nTHIS IS THE EASIEST PROGRAM ON LEETCODE. HOW IS THE DIFFICULTY MEDIUM?!!!!!"
                    },
                    {
                        "username": "imsamarth",
                        "content": "![image](https://assets.leetcode.com/users/images/ccce55dc-cff6-4faa-9c5f-5becef40f6f1_1642494038.274861.png)\\n\\n![image](https://assets.leetcode.com/users/images/cb074c0a-f5d9-4308-9092-834e8b9462a4_1642493916.8664188.png)\\n\\n\\n\\n// Built-in C++ function faster than 100% solutions,\\nreturn pow(x,n);"
                    },
                    {
                        "username": "Samiudeen",
                        "content": "return Math.pow(x,n);"
                    },
                    {
                        "username": "dhruv4023",
                        "content": "class Solution {\\n    public double myPow(double x, int n) {\\n     return Math.pow(x,n);   \\n    }\\n} \\n\\nuse inbuild math function"
                    },
                    {
                        "username": "Kaltu",
                        "content": "The first two words state you are to implement this exact function, implementing a function by calling itself is illogical"
                    },
                    {
                        "username": "Prathamesh66",
                        "content": "see editorial for optimal approach"
                    }
                ]
            },
            {
                "id": 1674471,
                "content": [
                    {
                        "username": "zhangyueming",
                        "content": "n/=2 Time Limit Exceed\\nn>>>1 Beat 100%"
                    },
                    {
                        "username": "araiz01",
                        "content": "I\\'m getting java.lang.StackOverflowError on line 6 which is as follows: \\n`\\n    public double myPow(double x, int n) {\\n        if(n>0){\\n            if(n == 1)\\n                return x;\\n            return x * myPow(x, n-1);\\n        }`"
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "ghatiya sawaal"
                    },
                    {
                        "username": "barstow123",
                        "content": "Heads up. This question is math heavy. \\n\\nIf you are below senior or principle level, you won\\'t see this problem in your interviews. Focus on Dynamic Programming, String, Array, and Search problems instead.\\n\\nEven for senior level, this style of problem is rare to see."
                    },
                    {
                        "username": "rustammollaa",
                        "content": "class Solution {\\n    public double myPow(double x, int n) {\\n        long n1=Math.abs((long)n);\\n        double ans=1.0;\\n        if(n==0) return 1;\\n        if(n<0) x=1/x;\\n        while(n1!=0){\\n            if(n1%2==1){\\n                ans*=x;\\n                n1-=1;\\n            }\\n            else{\\n                x*=x;\\n                n1/=2;\\n            }\\n        } \\n        \\n\\n        return ans ;\\n    }\\n}"
                    },
                    {
                        "username": "arnavjain",
                        "content": "Runtime: 16 ms, faster than 99.42%  Memory Usage: 12.8 MB, less than 100.00% \\nTHIS IS THE EASIEST PROGRAM ON LEETCODE. HOW IS THE DIFFICULTY MEDIUM?!!!!!"
                    },
                    {
                        "username": "imsamarth",
                        "content": "![image](https://assets.leetcode.com/users/images/ccce55dc-cff6-4faa-9c5f-5becef40f6f1_1642494038.274861.png)\\n\\n![image](https://assets.leetcode.com/users/images/cb074c0a-f5d9-4308-9092-834e8b9462a4_1642493916.8664188.png)\\n\\n\\n\\n// Built-in C++ function faster than 100% solutions,\\nreturn pow(x,n);"
                    },
                    {
                        "username": "Samiudeen",
                        "content": "return Math.pow(x,n);"
                    },
                    {
                        "username": "dhruv4023",
                        "content": "class Solution {\\n    public double myPow(double x, int n) {\\n     return Math.pow(x,n);   \\n    }\\n} \\n\\nuse inbuild math function"
                    },
                    {
                        "username": "Kaltu",
                        "content": "The first two words state you are to implement this exact function, implementing a function by calling itself is illogical"
                    },
                    {
                        "username": "Prathamesh66",
                        "content": "see editorial for optimal approach"
                    }
                ]
            },
            {
                "id": 1666758,
                "content": [
                    {
                        "username": "zhangyueming",
                        "content": "n/=2 Time Limit Exceed\\nn>>>1 Beat 100%"
                    },
                    {
                        "username": "araiz01",
                        "content": "I\\'m getting java.lang.StackOverflowError on line 6 which is as follows: \\n`\\n    public double myPow(double x, int n) {\\n        if(n>0){\\n            if(n == 1)\\n                return x;\\n            return x * myPow(x, n-1);\\n        }`"
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "ghatiya sawaal"
                    },
                    {
                        "username": "barstow123",
                        "content": "Heads up. This question is math heavy. \\n\\nIf you are below senior or principle level, you won\\'t see this problem in your interviews. Focus on Dynamic Programming, String, Array, and Search problems instead.\\n\\nEven for senior level, this style of problem is rare to see."
                    },
                    {
                        "username": "rustammollaa",
                        "content": "class Solution {\\n    public double myPow(double x, int n) {\\n        long n1=Math.abs((long)n);\\n        double ans=1.0;\\n        if(n==0) return 1;\\n        if(n<0) x=1/x;\\n        while(n1!=0){\\n            if(n1%2==1){\\n                ans*=x;\\n                n1-=1;\\n            }\\n            else{\\n                x*=x;\\n                n1/=2;\\n            }\\n        } \\n        \\n\\n        return ans ;\\n    }\\n}"
                    },
                    {
                        "username": "arnavjain",
                        "content": "Runtime: 16 ms, faster than 99.42%  Memory Usage: 12.8 MB, less than 100.00% \\nTHIS IS THE EASIEST PROGRAM ON LEETCODE. HOW IS THE DIFFICULTY MEDIUM?!!!!!"
                    },
                    {
                        "username": "imsamarth",
                        "content": "![image](https://assets.leetcode.com/users/images/ccce55dc-cff6-4faa-9c5f-5becef40f6f1_1642494038.274861.png)\\n\\n![image](https://assets.leetcode.com/users/images/cb074c0a-f5d9-4308-9092-834e8b9462a4_1642493916.8664188.png)\\n\\n\\n\\n// Built-in C++ function faster than 100% solutions,\\nreturn pow(x,n);"
                    },
                    {
                        "username": "Samiudeen",
                        "content": "return Math.pow(x,n);"
                    },
                    {
                        "username": "dhruv4023",
                        "content": "class Solution {\\n    public double myPow(double x, int n) {\\n     return Math.pow(x,n);   \\n    }\\n} \\n\\nuse inbuild math function"
                    },
                    {
                        "username": "Kaltu",
                        "content": "The first two words state you are to implement this exact function, implementing a function by calling itself is illogical"
                    },
                    {
                        "username": "Prathamesh66",
                        "content": "see editorial for optimal approach"
                    }
                ]
            },
            {
                "id": 1641260,
                "content": [
                    {
                        "username": "zhangyueming",
                        "content": "n/=2 Time Limit Exceed\\nn>>>1 Beat 100%"
                    },
                    {
                        "username": "araiz01",
                        "content": "I\\'m getting java.lang.StackOverflowError on line 6 which is as follows: \\n`\\n    public double myPow(double x, int n) {\\n        if(n>0){\\n            if(n == 1)\\n                return x;\\n            return x * myPow(x, n-1);\\n        }`"
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "ghatiya sawaal"
                    },
                    {
                        "username": "barstow123",
                        "content": "Heads up. This question is math heavy. \\n\\nIf you are below senior or principle level, you won\\'t see this problem in your interviews. Focus on Dynamic Programming, String, Array, and Search problems instead.\\n\\nEven for senior level, this style of problem is rare to see."
                    },
                    {
                        "username": "rustammollaa",
                        "content": "class Solution {\\n    public double myPow(double x, int n) {\\n        long n1=Math.abs((long)n);\\n        double ans=1.0;\\n        if(n==0) return 1;\\n        if(n<0) x=1/x;\\n        while(n1!=0){\\n            if(n1%2==1){\\n                ans*=x;\\n                n1-=1;\\n            }\\n            else{\\n                x*=x;\\n                n1/=2;\\n            }\\n        } \\n        \\n\\n        return ans ;\\n    }\\n}"
                    },
                    {
                        "username": "arnavjain",
                        "content": "Runtime: 16 ms, faster than 99.42%  Memory Usage: 12.8 MB, less than 100.00% \\nTHIS IS THE EASIEST PROGRAM ON LEETCODE. HOW IS THE DIFFICULTY MEDIUM?!!!!!"
                    },
                    {
                        "username": "imsamarth",
                        "content": "![image](https://assets.leetcode.com/users/images/ccce55dc-cff6-4faa-9c5f-5becef40f6f1_1642494038.274861.png)\\n\\n![image](https://assets.leetcode.com/users/images/cb074c0a-f5d9-4308-9092-834e8b9462a4_1642493916.8664188.png)\\n\\n\\n\\n// Built-in C++ function faster than 100% solutions,\\nreturn pow(x,n);"
                    },
                    {
                        "username": "Samiudeen",
                        "content": "return Math.pow(x,n);"
                    },
                    {
                        "username": "dhruv4023",
                        "content": "class Solution {\\n    public double myPow(double x, int n) {\\n     return Math.pow(x,n);   \\n    }\\n} \\n\\nuse inbuild math function"
                    },
                    {
                        "username": "Kaltu",
                        "content": "The first two words state you are to implement this exact function, implementing a function by calling itself is illogical"
                    },
                    {
                        "username": "Prathamesh66",
                        "content": "see editorial for optimal approach"
                    }
                ]
            },
            {
                "id": 1623669,
                "content": [
                    {
                        "username": "zhangyueming",
                        "content": "n/=2 Time Limit Exceed\\nn>>>1 Beat 100%"
                    },
                    {
                        "username": "araiz01",
                        "content": "I\\'m getting java.lang.StackOverflowError on line 6 which is as follows: \\n`\\n    public double myPow(double x, int n) {\\n        if(n>0){\\n            if(n == 1)\\n                return x;\\n            return x * myPow(x, n-1);\\n        }`"
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "ghatiya sawaal"
                    },
                    {
                        "username": "barstow123",
                        "content": "Heads up. This question is math heavy. \\n\\nIf you are below senior or principle level, you won\\'t see this problem in your interviews. Focus on Dynamic Programming, String, Array, and Search problems instead.\\n\\nEven for senior level, this style of problem is rare to see."
                    },
                    {
                        "username": "rustammollaa",
                        "content": "class Solution {\\n    public double myPow(double x, int n) {\\n        long n1=Math.abs((long)n);\\n        double ans=1.0;\\n        if(n==0) return 1;\\n        if(n<0) x=1/x;\\n        while(n1!=0){\\n            if(n1%2==1){\\n                ans*=x;\\n                n1-=1;\\n            }\\n            else{\\n                x*=x;\\n                n1/=2;\\n            }\\n        } \\n        \\n\\n        return ans ;\\n    }\\n}"
                    },
                    {
                        "username": "arnavjain",
                        "content": "Runtime: 16 ms, faster than 99.42%  Memory Usage: 12.8 MB, less than 100.00% \\nTHIS IS THE EASIEST PROGRAM ON LEETCODE. HOW IS THE DIFFICULTY MEDIUM?!!!!!"
                    },
                    {
                        "username": "imsamarth",
                        "content": "![image](https://assets.leetcode.com/users/images/ccce55dc-cff6-4faa-9c5f-5becef40f6f1_1642494038.274861.png)\\n\\n![image](https://assets.leetcode.com/users/images/cb074c0a-f5d9-4308-9092-834e8b9462a4_1642493916.8664188.png)\\n\\n\\n\\n// Built-in C++ function faster than 100% solutions,\\nreturn pow(x,n);"
                    },
                    {
                        "username": "Samiudeen",
                        "content": "return Math.pow(x,n);"
                    },
                    {
                        "username": "dhruv4023",
                        "content": "class Solution {\\n    public double myPow(double x, int n) {\\n     return Math.pow(x,n);   \\n    }\\n} \\n\\nuse inbuild math function"
                    },
                    {
                        "username": "Kaltu",
                        "content": "The first two words state you are to implement this exact function, implementing a function by calling itself is illogical"
                    },
                    {
                        "username": "Prathamesh66",
                        "content": "see editorial for optimal approach"
                    }
                ]
            },
            {
                "id": 1569808,
                "content": [
                    {
                        "username": "zhangyueming",
                        "content": "n/=2 Time Limit Exceed\\nn>>>1 Beat 100%"
                    },
                    {
                        "username": "araiz01",
                        "content": "I\\'m getting java.lang.StackOverflowError on line 6 which is as follows: \\n`\\n    public double myPow(double x, int n) {\\n        if(n>0){\\n            if(n == 1)\\n                return x;\\n            return x * myPow(x, n-1);\\n        }`"
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "ghatiya sawaal"
                    },
                    {
                        "username": "barstow123",
                        "content": "Heads up. This question is math heavy. \\n\\nIf you are below senior or principle level, you won\\'t see this problem in your interviews. Focus on Dynamic Programming, String, Array, and Search problems instead.\\n\\nEven for senior level, this style of problem is rare to see."
                    },
                    {
                        "username": "rustammollaa",
                        "content": "class Solution {\\n    public double myPow(double x, int n) {\\n        long n1=Math.abs((long)n);\\n        double ans=1.0;\\n        if(n==0) return 1;\\n        if(n<0) x=1/x;\\n        while(n1!=0){\\n            if(n1%2==1){\\n                ans*=x;\\n                n1-=1;\\n            }\\n            else{\\n                x*=x;\\n                n1/=2;\\n            }\\n        } \\n        \\n\\n        return ans ;\\n    }\\n}"
                    },
                    {
                        "username": "arnavjain",
                        "content": "Runtime: 16 ms, faster than 99.42%  Memory Usage: 12.8 MB, less than 100.00% \\nTHIS IS THE EASIEST PROGRAM ON LEETCODE. HOW IS THE DIFFICULTY MEDIUM?!!!!!"
                    },
                    {
                        "username": "imsamarth",
                        "content": "![image](https://assets.leetcode.com/users/images/ccce55dc-cff6-4faa-9c5f-5becef40f6f1_1642494038.274861.png)\\n\\n![image](https://assets.leetcode.com/users/images/cb074c0a-f5d9-4308-9092-834e8b9462a4_1642493916.8664188.png)\\n\\n\\n\\n// Built-in C++ function faster than 100% solutions,\\nreturn pow(x,n);"
                    },
                    {
                        "username": "Samiudeen",
                        "content": "return Math.pow(x,n);"
                    },
                    {
                        "username": "dhruv4023",
                        "content": "class Solution {\\n    public double myPow(double x, int n) {\\n     return Math.pow(x,n);   \\n    }\\n} \\n\\nuse inbuild math function"
                    },
                    {
                        "username": "Kaltu",
                        "content": "The first two words state you are to implement this exact function, implementing a function by calling itself is illogical"
                    },
                    {
                        "username": "Prathamesh66",
                        "content": "see editorial for optimal approach"
                    }
                ]
            },
            {
                "id": 1576256,
                "content": [
                    {
                        "username": "zhangyueming",
                        "content": "n/=2 Time Limit Exceed\\nn>>>1 Beat 100%"
                    },
                    {
                        "username": "araiz01",
                        "content": "I\\'m getting java.lang.StackOverflowError on line 6 which is as follows: \\n`\\n    public double myPow(double x, int n) {\\n        if(n>0){\\n            if(n == 1)\\n                return x;\\n            return x * myPow(x, n-1);\\n        }`"
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "ghatiya sawaal"
                    },
                    {
                        "username": "barstow123",
                        "content": "Heads up. This question is math heavy. \\n\\nIf you are below senior or principle level, you won\\'t see this problem in your interviews. Focus on Dynamic Programming, String, Array, and Search problems instead.\\n\\nEven for senior level, this style of problem is rare to see."
                    },
                    {
                        "username": "rustammollaa",
                        "content": "class Solution {\\n    public double myPow(double x, int n) {\\n        long n1=Math.abs((long)n);\\n        double ans=1.0;\\n        if(n==0) return 1;\\n        if(n<0) x=1/x;\\n        while(n1!=0){\\n            if(n1%2==1){\\n                ans*=x;\\n                n1-=1;\\n            }\\n            else{\\n                x*=x;\\n                n1/=2;\\n            }\\n        } \\n        \\n\\n        return ans ;\\n    }\\n}"
                    },
                    {
                        "username": "arnavjain",
                        "content": "Runtime: 16 ms, faster than 99.42%  Memory Usage: 12.8 MB, less than 100.00% \\nTHIS IS THE EASIEST PROGRAM ON LEETCODE. HOW IS THE DIFFICULTY MEDIUM?!!!!!"
                    },
                    {
                        "username": "imsamarth",
                        "content": "![image](https://assets.leetcode.com/users/images/ccce55dc-cff6-4faa-9c5f-5becef40f6f1_1642494038.274861.png)\\n\\n![image](https://assets.leetcode.com/users/images/cb074c0a-f5d9-4308-9092-834e8b9462a4_1642493916.8664188.png)\\n\\n\\n\\n// Built-in C++ function faster than 100% solutions,\\nreturn pow(x,n);"
                    },
                    {
                        "username": "Samiudeen",
                        "content": "return Math.pow(x,n);"
                    },
                    {
                        "username": "dhruv4023",
                        "content": "class Solution {\\n    public double myPow(double x, int n) {\\n     return Math.pow(x,n);   \\n    }\\n} \\n\\nuse inbuild math function"
                    },
                    {
                        "username": "Kaltu",
                        "content": "The first two words state you are to implement this exact function, implementing a function by calling itself is illogical"
                    },
                    {
                        "username": "Prathamesh66",
                        "content": "see editorial for optimal approach"
                    }
                ]
            },
            {
                "id": 1575301,
                "content": [
                    {
                        "username": "zhangyueming",
                        "content": "n/=2 Time Limit Exceed\\nn>>>1 Beat 100%"
                    },
                    {
                        "username": "araiz01",
                        "content": "I\\'m getting java.lang.StackOverflowError on line 6 which is as follows: \\n`\\n    public double myPow(double x, int n) {\\n        if(n>0){\\n            if(n == 1)\\n                return x;\\n            return x * myPow(x, n-1);\\n        }`"
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "ghatiya sawaal"
                    },
                    {
                        "username": "barstow123",
                        "content": "Heads up. This question is math heavy. \\n\\nIf you are below senior or principle level, you won\\'t see this problem in your interviews. Focus on Dynamic Programming, String, Array, and Search problems instead.\\n\\nEven for senior level, this style of problem is rare to see."
                    },
                    {
                        "username": "rustammollaa",
                        "content": "class Solution {\\n    public double myPow(double x, int n) {\\n        long n1=Math.abs((long)n);\\n        double ans=1.0;\\n        if(n==0) return 1;\\n        if(n<0) x=1/x;\\n        while(n1!=0){\\n            if(n1%2==1){\\n                ans*=x;\\n                n1-=1;\\n            }\\n            else{\\n                x*=x;\\n                n1/=2;\\n            }\\n        } \\n        \\n\\n        return ans ;\\n    }\\n}"
                    },
                    {
                        "username": "arnavjain",
                        "content": "Runtime: 16 ms, faster than 99.42%  Memory Usage: 12.8 MB, less than 100.00% \\nTHIS IS THE EASIEST PROGRAM ON LEETCODE. HOW IS THE DIFFICULTY MEDIUM?!!!!!"
                    },
                    {
                        "username": "imsamarth",
                        "content": "![image](https://assets.leetcode.com/users/images/ccce55dc-cff6-4faa-9c5f-5becef40f6f1_1642494038.274861.png)\\n\\n![image](https://assets.leetcode.com/users/images/cb074c0a-f5d9-4308-9092-834e8b9462a4_1642493916.8664188.png)\\n\\n\\n\\n// Built-in C++ function faster than 100% solutions,\\nreturn pow(x,n);"
                    },
                    {
                        "username": "Samiudeen",
                        "content": "return Math.pow(x,n);"
                    },
                    {
                        "username": "dhruv4023",
                        "content": "class Solution {\\n    public double myPow(double x, int n) {\\n     return Math.pow(x,n);   \\n    }\\n} \\n\\nuse inbuild math function"
                    },
                    {
                        "username": "Kaltu",
                        "content": "The first two words state you are to implement this exact function, implementing a function by calling itself is illogical"
                    },
                    {
                        "username": "Prathamesh66",
                        "content": "see editorial for optimal approach"
                    }
                ]
            },
            {
                "id": 2016503,
                "content": [
                    {
                        "username": "zhangyueming",
                        "content": "n/=2 Time Limit Exceed\\nn>>>1 Beat 100%"
                    },
                    {
                        "username": "araiz01",
                        "content": "I\\'m getting java.lang.StackOverflowError on line 6 which is as follows: \\n`\\n    public double myPow(double x, int n) {\\n        if(n>0){\\n            if(n == 1)\\n                return x;\\n            return x * myPow(x, n-1);\\n        }`"
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "ghatiya sawaal"
                    },
                    {
                        "username": "barstow123",
                        "content": "Heads up. This question is math heavy. \\n\\nIf you are below senior or principle level, you won\\'t see this problem in your interviews. Focus on Dynamic Programming, String, Array, and Search problems instead.\\n\\nEven for senior level, this style of problem is rare to see."
                    },
                    {
                        "username": "rustammollaa",
                        "content": "class Solution {\\n    public double myPow(double x, int n) {\\n        long n1=Math.abs((long)n);\\n        double ans=1.0;\\n        if(n==0) return 1;\\n        if(n<0) x=1/x;\\n        while(n1!=0){\\n            if(n1%2==1){\\n                ans*=x;\\n                n1-=1;\\n            }\\n            else{\\n                x*=x;\\n                n1/=2;\\n            }\\n        } \\n        \\n\\n        return ans ;\\n    }\\n}"
                    },
                    {
                        "username": "arnavjain",
                        "content": "Runtime: 16 ms, faster than 99.42%  Memory Usage: 12.8 MB, less than 100.00% \\nTHIS IS THE EASIEST PROGRAM ON LEETCODE. HOW IS THE DIFFICULTY MEDIUM?!!!!!"
                    },
                    {
                        "username": "imsamarth",
                        "content": "![image](https://assets.leetcode.com/users/images/ccce55dc-cff6-4faa-9c5f-5becef40f6f1_1642494038.274861.png)\\n\\n![image](https://assets.leetcode.com/users/images/cb074c0a-f5d9-4308-9092-834e8b9462a4_1642493916.8664188.png)\\n\\n\\n\\n// Built-in C++ function faster than 100% solutions,\\nreturn pow(x,n);"
                    },
                    {
                        "username": "Samiudeen",
                        "content": "return Math.pow(x,n);"
                    },
                    {
                        "username": "dhruv4023",
                        "content": "class Solution {\\n    public double myPow(double x, int n) {\\n     return Math.pow(x,n);   \\n    }\\n} \\n\\nuse inbuild math function"
                    },
                    {
                        "username": "Kaltu",
                        "content": "The first two words state you are to implement this exact function, implementing a function by calling itself is illogical"
                    },
                    {
                        "username": "Prathamesh66",
                        "content": "see editorial for optimal approach"
                    }
                ]
            },
            {
                "id": 2005381,
                "content": [
                    {
                        "username": "zhangyueming",
                        "content": "n/=2 Time Limit Exceed\\nn>>>1 Beat 100%"
                    },
                    {
                        "username": "araiz01",
                        "content": "I\\'m getting java.lang.StackOverflowError on line 6 which is as follows: \\n`\\n    public double myPow(double x, int n) {\\n        if(n>0){\\n            if(n == 1)\\n                return x;\\n            return x * myPow(x, n-1);\\n        }`"
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "ghatiya sawaal"
                    },
                    {
                        "username": "barstow123",
                        "content": "Heads up. This question is math heavy. \\n\\nIf you are below senior or principle level, you won\\'t see this problem in your interviews. Focus on Dynamic Programming, String, Array, and Search problems instead.\\n\\nEven for senior level, this style of problem is rare to see."
                    },
                    {
                        "username": "rustammollaa",
                        "content": "class Solution {\\n    public double myPow(double x, int n) {\\n        long n1=Math.abs((long)n);\\n        double ans=1.0;\\n        if(n==0) return 1;\\n        if(n<0) x=1/x;\\n        while(n1!=0){\\n            if(n1%2==1){\\n                ans*=x;\\n                n1-=1;\\n            }\\n            else{\\n                x*=x;\\n                n1/=2;\\n            }\\n        } \\n        \\n\\n        return ans ;\\n    }\\n}"
                    },
                    {
                        "username": "arnavjain",
                        "content": "Runtime: 16 ms, faster than 99.42%  Memory Usage: 12.8 MB, less than 100.00% \\nTHIS IS THE EASIEST PROGRAM ON LEETCODE. HOW IS THE DIFFICULTY MEDIUM?!!!!!"
                    },
                    {
                        "username": "imsamarth",
                        "content": "![image](https://assets.leetcode.com/users/images/ccce55dc-cff6-4faa-9c5f-5becef40f6f1_1642494038.274861.png)\\n\\n![image](https://assets.leetcode.com/users/images/cb074c0a-f5d9-4308-9092-834e8b9462a4_1642493916.8664188.png)\\n\\n\\n\\n// Built-in C++ function faster than 100% solutions,\\nreturn pow(x,n);"
                    },
                    {
                        "username": "Samiudeen",
                        "content": "return Math.pow(x,n);"
                    },
                    {
                        "username": "dhruv4023",
                        "content": "class Solution {\\n    public double myPow(double x, int n) {\\n     return Math.pow(x,n);   \\n    }\\n} \\n\\nuse inbuild math function"
                    },
                    {
                        "username": "Kaltu",
                        "content": "The first two words state you are to implement this exact function, implementing a function by calling itself is illogical"
                    },
                    {
                        "username": "Prathamesh66",
                        "content": "see editorial for optimal approach"
                    }
                ]
            }
        ]
    }
]