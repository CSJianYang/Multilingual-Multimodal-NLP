[
    {
        "title": "Permutation Sequence",
        "question_content": "The set [1, 2, 3, ...,&nbsp;n] contains a total of n! unique permutations.\nBy listing and labeling all of the permutations in order, we get the following sequence for n = 3:\n\n\t\"123\"\n\t\"132\"\n\t\"213\"\n\t\"231\"\n\t\"312\"\n\t\"321\"\n\nGiven n and k, return the kth permutation sequence.\n&nbsp;\nExample 1:\nInput: n = 3, k = 3\nOutput: \"213\"\nExample 2:\nInput: n = 4, k = 9\nOutput: \"2314\"\nExample 3:\nInput: n = 3, k = 1\nOutput: \"123\"\n&nbsp;\nConstraints:\n\n\t1 <= n <= 9\n\t1 <= k <= n!",
        "solutions": [
            {
                "id": 22507,
                "title": "explain-like-i-m-five-java-solution-in-o-n",
                "content": "**EDIT: I\\'m tired of some of you commenting on the O(n)-ness of this and especially those of you with snarky condescending tones. It\\'s not difficult to implement your own data structure that can do O(1) \"list\" remove. I\\'m not going to put all that code here and dilute the the main solution which is the pattern of solving the permutations. The description on the pattern is already long enough as it is. If you can\\'t figure out how to do an O(1) remove, then you shouldn\\'t be doing this problem in the first place. Those of you commenting condescendingly, take a freaking break from leetcoding all day. Those of you with kind words and thanks, you\\'re welcome and thanks for taking the time to read through the somewhat long description.**\\n\\nI\\'m sure somewhere can be simplified so it\\'d be nice if anyone can let me know. The pattern was that:\\n\\nsay n = 4, you have {1, 2, 3, 4}\\n\\nIf you were to list out all the permutations you have \\n\\n1 + (permutations of 2, 3, 4)\\n<br>2 + (permutations of 1, 3, 4)\\n<br>3 + (permutations of 1, 2, 4)\\n<br>4 + (permutations of 1, 2, 3)\\n\\n<br>We know how to calculate the number of permutations of n numbers... n! So each of those with permutations of 3 numbers means there are 6 possible permutations. Meaning there would be a total of 24 permutations in this particular one. So if you were to look for the (k = 14) 14th permutation, it would be in the \\n\\n3 + (permutations of 1, 2, 4) subset. \\n\\nTo programmatically get that, you take k = 13 (subtract 1 because of things always starting at 0) and divide that by the 6 we got from the factorial, which would give you the index of the number you want. In the array {1, 2, 3, 4}, k/(n-1)! = 13/(4-1)! = 13/3! = 13/6 = 2. The array {1, 2, 3, 4} has a value of 3 at index 2. So the first number is a 3.\\n\\nThen the problem repeats with less numbers.\\n\\nThe permutations of {1, 2, 4} would be:\\n\\n1 + (permutations of 2, 4)\\n<br>2 + (permutations of 1, 4)\\n<br>4 + (permutations of 1, 2)\\n\\nBut our k is no longer the 14th, because in the previous step, we\\'ve already eliminated the 12 4-number permutations starting with 1 and 2. So you subtract 12 from k.. which gives you 1. Programmatically that would be...\\n\\nk = k - (index from previous) * (n-1)! = k - 2*(n-1)! = 13 - 2*(3)! = 1\\n\\nIn this second step, permutations of 2 numbers has only 2 possibilities, meaning each of the three permutations listed above a has two possibilities, giving a total of 6. We\\'re looking for the first one, so that would be in the 1 + (permutations of 2, 4) subset. \\n\\nMeaning: index to get number from is k / (n - 2)!  = 1 / (4-2)! = 1 / 2! = 0.. from {1, 2, 4}, index 0 is 1\\n\\n<br>so the numbers we have so far is 3, 1... and then repeating without explanations.\\n\\n<br>{2, 4}\\n<br>k = k - (index from pervious) * (n-2)! = k - 0 * (n - 2)! = 1 - 0 = 1;\\n<br>third number\\'s index = k / (n - 3)! = 1 / (4-3)! = 1/ 1! = 1... from {2, 4}, index 1 has 4\\n<br>Third number is 4\\n\\n<br>{2}\\n<br>k = k - (index from pervious) * (n - 3)! = k - 1 * (4 - 3)! = 1 - 1 = 0;\\n<br>third number\\'s index = k / (n - 4)! = 0 / (4-4)! = 0/ 1 = 0... from {2}, index 0 has 2\\n<br>Fourth number is 2\\n\\n<br>Giving us 3142. If you manually list out the permutations using DFS method, it would be 3142. Done! It really was all about pattern finding.\\n\\n\\n\\n    public class Solution {\\n    public String getPermutation(int n, int k) {\\n        int pos = 0;\\n        List<Integer> numbers = new ArrayList<>();\\n        int[] factorial = new int[n+1];\\n        StringBuilder sb = new StringBuilder();\\n        \\n        // create an array of factorial lookup\\n        int sum = 1;\\n        factorial[0] = 1;\\n        for(int i=1; i<=n; i++){\\n            sum *= i;\\n            factorial[i] = sum;\\n        }\\n        // factorial[] = {1, 1, 2, 6, 24, ... n!}\\n        \\n        // create a list of numbers to get indices\\n        for(int i=1; i<=n; i++){\\n            numbers.add(i);\\n        }\\n        // numbers = {1, 2, 3, 4}\\n        \\n        k--;\\n        \\n        for(int i = 1; i <= n; i++){\\n            int index = k/factorial[n-i];\\n            sb.append(String.valueOf(numbers.get(index)));\\n            numbers.remove(index);\\n            k-=index*factorial[n-i];\\n        }\\n        \\n        return String.valueOf(sb);\\n    }\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public String getPermutation(int n, int k) {\\n        int pos = 0;\\n        List<Integer> numbers = new ArrayList<>();\\n        int[] factorial = new int[n+1];\\n        StringBuilder sb = new StringBuilder();\\n        \\n        // create an array of factorial lookup\\n        int sum = 1;\\n        factorial[0] = 1;\\n        for(int i=1; i<=n; i++){\\n            sum *= i;\\n            factorial[i] = sum;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 696595,
                "title": "c-very-easy-and-detailed-explanation-idea-code",
                "content": "Let us first take an example to under the idea:\\nSuppose n = 4.\\nSo we have elements  - 1,2,3,4\\nThere are total n!= 4! = 24 permutations possible. We can see a specific pattern here:\\n\\n```\\narr\\n[ 1            2           3          4]\\n1 2 3 4     2 1 3 4     3 1 2 4    4 1 2 3\\n1 2 4 3     2 1 4 3     3 1 4 2    4 1 3 2\\n1 3 2 4     2 3 1 4     3 2 1 4    4 2 1 3\\n1 3 4 2     2 3 4 1     3 2 4 1    4 2 3 1\\n1 4 2 3     2 4 1 3     3 4 1 2    4 3 1 2\\n1 4 3 2     2 4 3 1     3 4 2 1    4 3 2 1\\nSo we have 4 block with 6 elements each.\\n\\nn = 4  we can take an array [1,2,3,4] , initital ans = \"\"\\nlets say we have k =15, the 15 th permutation is \"3 2 1 4\":\\n\\nAs we can see the first value is 3 that means out of the four blocks we need the 3rd block. \\nEach blocks has n-1! = 3! = 6 elements --> 15 = 6*2 + 3 i.e. we skip 2 blocks and our ans is the third element in the 3rd block\\nLet us assume the blocks are zero indexed.\\nNow 15 / 6 = 2;  So we select the 2nd block (0-indexed) that means 2nd index in our array - 3\\nNow ans = \"3\"\\nRemove this element from the array and our array becomes: [1,2,4]\\n---------------------------------------------------------------------------------------------\\nNow we are in this block:\\n3 1 2 4  - 1  \\n3 1 4 2  - 2   Block 0\\n  ------ \\n3 2 1 4  - 3 (ans)\\n3 2 4 1  - 4    Block 1\\n  ------\\n3 4 1 2  - 5   \\n3 4 2 1  - 6    Block 2\\nNow we have 3 blocks each of with 2 elements \\ni,e. n = n-1 = 3blocks and n-1! = 2! = 2 elements\\nn = 3, what will be the k? As we passed 12 elements we have k = 15-12 => the third element in this large block.\\nk = 3\\nelement in partition (p) = 2;\\nk / p = 3 / 2 = 1 => ans is in block 1, value to add to ans  = 2\\narr[1] = 2;\\nans = \"32\"\\nremove 2 from array => [1,4]\\nNow we have 2 elements left(n-1 = 3-1) \\n-----------------------------------------------------------------------------\\n32  1 4  Block 0\\n32  4 1  Block 1\\n\\nn=2, k = 1\\n1 will be added ans = \"321\"  arr= [4]\\nAs we only have one value value in array append it to ans.  ans = \"3214\"\\n\\nOne very important note:(Corner case)\\nWhen we have k as a multiple of elements in partition for e.g. k = 12 Then we want to be in block with index 1\\nbut as index = 12 / 6 = 2; we have to keep index = index-1;\\nOnly when we are aiming at the last element we will hit this case.\\nHere the blocks are zero indexed but the elements inside them are 1 index.\\n\\nI\\'m sure after you look at the code you will completely understand it\\n```\\n\\nCode:\\n\\n```\\nclass Solution {\\npublic:\\n    // Our recursive function that will complete the ans string.\\n\\t// v - is our current array = [1,2,3,4]\\n\\t// ans is the answer string, n and k are current values of n and k\\n\\t// factVal is an array containing the factorial of all integers from 0-9 to get factorial in O(1) time.\\n\\t// That means I have stored all the factorials in this array before hand to avoid calculation. You can also write factorial funciton if you want.\\n\\t\\n    void setPerm(vector<int>& v,string& ans,int n,int k,vector<int>& factVal){\\n       // if there is only one element left append it to our ans (Base case)\\n\\t   if(n==1){\\n            ans+=to_string(v.back());\\n            return;\\n        }\\n\\t\\t\\n\\t\\t// We are calculating the required index.  factVal[n-1] means for n =  4 => factVal[3] = 6.\\n        // 15 / 6 = 2 will the index for k =15 and n = 4.\\n\\t\\tint index = (k/factVal[n-1]);\\n        // if k is a multiple of elements of partition then decrement the index (Corner case I was talking about)\\n\\t\\tif(k % factVal[n-1] == 0){\\n            index--;\\n        }\\n\\t\\t\\n\\t\\tans+= to_string(v[index]);  // add value to string\\n        v.erase(v.begin() + index);  // remove element from array\\n        k -= factVal[n-1] * index;   // adjust value of k; k = 15 - 6*2 = 3.\\n\\t\\t// Recursive call with n=n-1 as one element is added we need remaing.\\n        setPerm(v,ans,n-1,k,factVal);\\n    }\\n    \\n    string getPermutation(int n, int k) {\\n        if(n==1) return \"1\";\\n\\t\\t//Factorials of 0-9 stored in the array. factVal[3] = 6. (3! = 6)\\n        vector<int>factVal = {1,1,2,6,24,120,720,5040,40320,362880};\\n        string ans = \"\";\\n        vector<int> v;\\n\\t\\t// Fill the array with all elements\\n        for(int i=1;i<=n;i++) v.emplace_back(i);\\n        setPerm(v,ans,n,k,factVal);\\n        return ans;\\n    }\\n};\\n```\\n\\nI hope you enjoyed it. If there is any blunder kindly let me know.\\nHappy Coding!",
                "solutionTags": [],
                "code": "```\\narr\\n[ 1            2           3          4]\\n1 2 3 4     2 1 3 4     3 1 2 4    4 1 2 3\\n1 2 4 3     2 1 4 3     3 1 4 2    4 1 3 2\\n1 3 2 4     2 3 1 4     3 2 1 4    4 2 1 3\\n1 3 4 2     2 3 4 1     3 2 4 1    4 2 3 1\\n1 4 2 3     2 4 1 3     3 4 1 2    4 3 1 2\\n1 4 3 2     2 4 3 1     3 4 2 1    4 3 2 1\\nSo we have 4 block with 6 elements each.\\n\\nn = 4  we can take an array [1,2,3,4] , initital ans = \"\"\\nlets say we have k =15, the 15 th permutation is \"3 2 1 4\":\\n\\nAs we can see the first value is 3 that means out of the four blocks we need the 3rd block. \\nEach blocks has n-1! = 3! = 6 elements --> 15 = 6*2 + 3 i.e. we skip 2 blocks and our ans is the third element in the 3rd block\\nLet us assume the blocks are zero indexed.\\nNow 15 / 6 = 2;  So we select the 2nd block (0-indexed) that means 2nd index in our array - 3\\nNow ans = \"3\"\\nRemove this element from the array and our array becomes: [1,2,4]\\n---------------------------------------------------------------------------------------------\\nNow we are in this block:\\n3 1 2 4  - 1  \\n3 1 4 2  - 2   Block 0\\n  ------ \\n3 2 1 4  - 3 (ans)\\n3 2 4 1  - 4    Block 1\\n  ------\\n3 4 1 2  - 5   \\n3 4 2 1  - 6    Block 2\\nNow we have 3 blocks each of with 2 elements \\ni,e. n = n-1 = 3blocks and n-1! = 2! = 2 elements\\nn = 3, what will be the k? As we passed 12 elements we have k = 15-12 => the third element in this large block.\\nk = 3\\nelement in partition (p) = 2;\\nk / p = 3 / 2 = 1 => ans is in block 1, value to add to ans  = 2\\narr[1] = 2;\\nans = \"32\"\\nremove 2 from array => [1,4]\\nNow we have 2 elements left(n-1 = 3-1) \\n-----------------------------------------------------------------------------\\n32  1 4  Block 0\\n32  4 1  Block 1\\n\\nn=2, k = 1\\n1 will be added ans = \"321\"  arr= [4]\\nAs we only have one value value in array append it to ans.  ans = \"3214\"\\n\\nOne very important note:(Corner case)\\nWhen we have k as a multiple of elements in partition for e.g. k = 12 Then we want to be in block with index 1\\nbut as index = 12 / 6 = 2; we have to keep index = index-1;\\nOnly when we are aiming at the last element we will hit this case.\\nHere the blocks are zero indexed but the elements inside them are 1 index.\\n\\nI\\'m sure after you look at the code you will completely understand it\\n```\n```\\nclass Solution {\\npublic:\\n    // Our recursive function that will complete the ans string.\\n\\t// v - is our current array = [1,2,3,4]\\n\\t// ans is the answer string, n and k are current values of n and k\\n\\t// factVal is an array containing the factorial of all integers from 0-9 to get factorial in O(1) time.\\n\\t// That means I have stored all the factorials in this array before hand to avoid calculation. You can also write factorial funciton if you want.\\n\\t\\n    void setPerm(vector<int>& v,string& ans,int n,int k,vector<int>& factVal){\\n       // if there is only one element left append it to our ans (Base case)\\n\\t   if(n==1){\\n            ans+=to_string(v.back());\\n            return;\\n        }\\n\\t\\t\\n\\t\\t// We are calculating the required index.  factVal[n-1] means for n =  4 => factVal[3] = 6.\\n        // 15 / 6 = 2 will the index for k =15 and n = 4.\\n\\t\\tint index = (k/factVal[n-1]);\\n        // if k is a multiple of elements of partition then decrement the index (Corner case I was talking about)\\n\\t\\tif(k % factVal[n-1] == 0){\\n            index--;\\n        }\\n\\t\\t\\n\\t\\tans+= to_string(v[index]);  // add value to string\\n        v.erase(v.begin() + index);  // remove element from array\\n        k -= factVal[n-1] * index;   // adjust value of k; k = 15 - 6*2 = 3.\\n\\t\\t// Recursive call with n=n-1 as one element is added we need remaing.\\n        setPerm(v,ans,n-1,k,factVal);\\n    }\\n    \\n    string getPermutation(int n, int k) {\\n        if(n==1) return \"1\";\\n\\t\\t//Factorials of 0-9 stored in the array. factVal[3] = 6. (3! = 6)\\n        vector<int>factVal = {1,1,2,6,24,120,720,5040,40320,362880};\\n        string ans = \"\";\\n        vector<int> v;\\n\\t\\t// Fill the array with all elements\\n        for(int i=1;i<=n;i++) v.emplace_back(i);\\n        setPerm(v,ans,n,k,factVal);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22512,
                "title": "share-my-python-solution-with-detailed-explanation",
                "content": "The idea is as follow:\\n\\nFor permutations of n, the first (n-1)! permutations start with 1, next (n-1)! ones start with 2, ... and so on. And in each group of (n-1)! permutations, the first (n-2)! permutations start with the smallest remaining number, ...\\n\\ntake n = 3 as an example, the first 2 (that is, (3-1)! ) permutations start with 1, next 2 start with 2 and last 2 start with 3. For the first 2 permutations (123 and 132), the 1st one (1!) starts with 2, which is the smallest remaining number (2 and 3). So we can use a loop to check the region that the sequence number falls in and get the starting digit. Then we adjust the sequence number and continue.\\n\\n    import math\\n    class Solution:\\n        # @param {integer} n\\n        # @param {integer} k\\n        # @return {string}\\n        def getPermutation(self, n, k):\\n            numbers = range(1, n+1)\\n            permutation = ''\\n            k -= 1\\n            while n > 0:\\n                n -= 1\\n                # get the index of current digit\\n                index, k = divmod(k, math.factorial(n))\\n                permutation += str(numbers[index])\\n                # remove handled number\\n                numbers.remove(numbers[index])\\n    \\n            return permutation",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {integer}",
                "codeTag": "Java"
            },
            {
                "id": 22508,
                "title": "an-iterative-solution-for-reference",
                "content": "Recursion will use more memory, while this problem can be solved by iteration. I solved this problem before, but I didn't realize that using k = k-1 would avoid dealing with case k%(n-1)!==0. Rewrote this code, should be pretty concise now. \\n\\nOnly thing is that I have to use a list to store the remaining numbers, neither linkedlist nor arraylist are very efficient, anyone has a better idea?\\n\\nThe logic is as follows: for n numbers the permutations can be divided to (n-1)! groups, for n-1 numbers can be divided to (n-2)! groups, and so on. Thus k/(n-1)! indicates the index of current number, and k%(n-1)! denotes remaining index for the remaining n-1 numbers.\\nWe keep doing this until n reaches 0, then we get n numbers permutations that is kth. \\n\\n    public String getPermutation(int n, int k) {\\n            List<Integer> num = new LinkedList<Integer>();\\n            for (int i = 1; i <= n; i++) num.add(i);\\n            int[] fact = new int[n];  // factorial\\n            fact[0] = 1;\\n            for (int i = 1; i < n; i++) fact[i] = i*fact[i-1];\\n            k = k-1;\\n            StringBuilder sb = new StringBuilder();\\n            for (int i = n; i > 0; i--){\\n                int ind = k/fact[i-1];\\n                k = k%fact[i-1];\\n                sb.append(num.get(ind));\\n                num.remove(ind);\\n            }\\n            return sb.toString();\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Recursion will use more memory, while this problem can be solved by iteration. I solved this problem before, but I didn't realize that using k = k-1 would avoid dealing with case k%(n-1)!==0. Rewrote this code, should be pretty concise now. \\n\\nOnly thing is that I have to use a list to store the remaining numbers, neither linkedlist nor arraylist are very efficient, anyone has a better idea?\\n\\nThe logic is as follows: for n numbers the permutations can be divided to (n-1)! groups, for n-1 numbers can be divided to (n-2)! groups, and so on. Thus k/(n-1)! indicates the index of current number, and k%(n-1)! denotes remaining index for the remaining n-1 numbers.\\nWe keep doing this until n reaches 0, then we get n numbers permutations that is kth. \\n\\n    public String getPermutation(int n, int k) {\\n            List<Integer> num = new LinkedList<Integer>();\\n            for (int i = 1; i <= n; i++) num.add(i);\\n            int[] fact = new int[n];  // factorial\\n            fact[0] = 1;\\n            for (int i = 1; i < n; i++) fact[i] = i*fact[i-1];\\n            k = k-1;\\n            StringBuilder sb = new StringBuilder();\\n            for (int i = n; i > 0; i--){\\n                int ind = k/fact[i-1];\\n                k = k%fact[i-1];\\n                sb.append(num.get(ind));\\n                num.remove(ind);\\n            }\\n            return sb.toString();\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 22544,
                "title": "easy-understand-most-concise-c-solution-minimal-memory-required",
                "content": "This problem is recursive like dynamic programming.\\nKth Permutation sequence can be formed by choosing the 1st digit and then the rest of the digits one by one.\\nVisually:\\n1 + (permutations of rest of digits)\\n2 + (permutations of ...)\\nso on...\\n\\nFor N=3,\\nwe have the permutations:\\n1|2,3\\n1|3,2\\n2|1,3\\n2|3,1\\n3|1,2\\n3|2,1\\n\\nI put a bar \"|\" to separate first digit from the rest of digits.\\nThere are a total of N! = 3! = 6 perms.  Each 1st digit is \"attached\" to (n-1)! =2! = 2 permutations formed by rest of digits. \\nThus , to choose 1st digit, simply  calculate (k-1)  / (n-1)! and use it to index into an array of digits 1,2,3,\\nOnce 1st digit is chosen, we choose 2nd and so on recursively.\\n\\nWe remove 1st digit from the array of digits , so the remaining are the \"rest of digits\".\\nThere are 2 ways to remove: \\n1) pull the chosen digit from its current place to the right place in the permutation and shift rest of digits accordingly. (this is the in-place method chosen in my code so left part is partially formed permuation and right part is the candidates)\\n2) mark the chosen digit as \"used\" so you don\\'t use it again. (need an array of booleans to track)\\n\\nNotice the candidates   always remain sorted regardless of which digit is removed. This is an important property to solve the problem recursively. \\n\\n\\n\\n\\n\\n\\n\\n\\n\\tstring getPermutation(int n, int k) {\\n        int i,j,f=1;\\n        // left part of s is partially formed permutation, right part is the leftover chars.\\n        string s(n,\\'0\\');\\n        for(i=1;i<=n;i++){\\n            f*=i;\\n            s[i-1]+=i; // make s become 1234...n\\n        }\\n        for(i=0,k--;i<n;i++){\\n            f/=n-i;\\n            j=i+k/f; // calculate index of char to put at s[i]\\n            char c=s[j];\\n            // remove c by shifting to cover up (adjust the right part).\\n            for(;j>i;j--)\\n                s[j]=s[j-1];\\n            k%=f;\\n            s[i]=c;\\n        }\\n        return s;\\n    }",
                "solutionTags": [],
                "code": "This problem is recursive like dynamic programming.\\nKth Permutation sequence can be formed by choosing the 1st digit and then the rest of the digits one by one.\\nVisually:\\n1 + (permutations of rest of digits)\\n2 + (permutations of ...)\\nso on...\\n\\nFor N=3,\\nwe have the permutations:\\n1|2,3\\n1|3,2\\n2|1,3\\n2|3,1\\n3|1,2\\n3|2,1\\n\\nI put a bar \"|\" to separate first digit from the rest of digits.\\nThere are a total of N! = 3! = 6 perms.  Each 1st digit is \"attached\" to (n-1)! =2! = 2 permutations formed by rest of digits. \\nThus , to choose 1st digit, simply  calculate (k-1)  / (n-1)! and use it to index into an array of digits 1,2,3,\\nOnce 1st digit is chosen, we choose 2nd and so on recursively.\\n\\nWe remove 1st digit from the array of digits , so the remaining are the \"rest of digits\".\\nThere are 2 ways to remove: \\n1) pull the chosen digit from its current place to the right place in the permutation and shift rest of digits accordingly. (this is the in-place method chosen in my code so left part is partially formed permuation and right part is the candidates)\\n2) mark the chosen digit as \"used\" so you don\\'t use it again. (need an array of booleans to track)\\n\\nNotice the candidates   always remain sorted regardless of which digit is removed. This is an important property to solve the problem recursively. \\n\\n\\n\\n\\n\\n\\n\\n\\n\\tstring getPermutation(int n, int k) {\\n        int i,j,f=1;\\n        // left part of s is partially formed permutation, right part is the leftover chars.\\n        string s(n,\\'0\\');\\n        for(i=1;i<=n;i++){\\n            f*=i;\\n            s[i-1]+=i; // make s become 1234...n\\n        }\\n        for(i=0,k--;i<n;i++){\\n            f/=n-i;\\n            j=i+k/f; // calculate index of char to put at s[i]\\n            char c=s[j];\\n            // remove c by shifting to cover up (adjust the right part).\\n            for(;j>i;j--)\\n                s[j]=s[j-1];\\n            k%=f;\\n            s[i]=c;\\n        }\\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 22665,
                "title": "clean-java-solution",
                "content": "The basic idea is to decide which is the correct number starting from the highest digit.\\nUse k divide the factorial of (n-1), the result represents the ith not used number.\\nThen update k and the factorial to decide next digit.\\n\\n\\n public String getPermutation(int n, int k) {\\n\\n       LinkedList<Integer> notUsed = new LinkedList<Integer>();\\n\\n\\t\\tint weight = 1;\\n\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tnotUsed.add(i);\\n\\t\\t\\tif (i == n)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tweight = weight * i;\\n\\t\\t}\\n\\n\\t\\tString res = \"\";\\n\\t\\tk = k - 1;\\n\\t\\twhile (true) {\\n\\t\\t\\tres = res + notUsed.remove(k / weight);\\n\\t\\t\\tk = k % weight;\\n\\t\\t\\tif (notUsed.isEmpty())\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tweight = weight / notUsed.size();\\n\\t\\t}\\n\\n\\t\\treturn res;\\n    }",
                "solutionTags": [],
                "code": "The basic idea is to decide which is the correct number starting from the highest digit.\\nUse k divide the factorial of (n-1), the result represents the ith not used number.\\nThen update k and the factorial to decide next digit.\\n\\n\\n public String getPermutation(int n, int k) {\\n\\n       LinkedList<Integer> notUsed = new LinkedList<Integer>();\\n\\n\\t\\tint weight = 1;\\n\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tnotUsed.add(i);\\n\\t\\t\\tif (i == n)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tweight = weight * i;\\n\\t\\t}\\n\\n\\t\\tString res = \"\";\\n\\t\\tk = k - 1;\\n\\t\\twhile (true) {\\n\\t\\t\\tres = res + notUsed.remove(k / weight);\\n\\t\\t\\tk = k % weight;\\n\\t\\t\\tif (notUsed.isEmpty())\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tweight = weight / notUsed.size();\\n\\t\\t}\\n\\n\\t\\treturn res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 696910,
                "title": "c-100-time-space-efficient-iterative-solution-detailed-explanation-with-example",
                "content": "The approach is mathematical. The idea is to keep selecting a digit and eliminating it from further selection based on value of K. \\n\\nFor example:\\n\\n**Given, N = 4, K = 9**\\n\\nThere are 6 numbers starting with 1: 1234, 1243, 1324, 1342, 1423, 1432\\nThere are 6 numbers starting with 2: 2134, 2143, 2314, 2341, 2413, 2431\\nSimilarly, there are 6 numbers starting with 3 and 6 numbers starting with 4.\\n\\n**This is because when we have chosen one place out of 4 places (as N=4), there are 3 places remaining to be filled and those 3 places can be filled in 6 ways or (N-1)! ways.**\\n\\nSo, we have to keep identifying which digit to choose. \\n\\nInitially, we have to choose a digit from **{1,2,3,4}.**\\n\\nSince K = 9, meaning it belongs to second set of six numbers and hence, would begin with 2.\\n\\n**Now, first place is chosen as 2 and output string becomes \"2\". \\nThis means we have eliminated 6 choices starting with 1 (1234, 1243, 1324, 1342, 1423, 1432).**\\n\\nNow, K would be updated as **K = 9 - 6 = 3.**\\n\\nWe now have to identify remaining 3 places with the digits **{1,3,4}** and with **K = 3.**\\n\\nThere are 2 numbers starting with 1: 134, 143\\nThere are 2 numbers starting with 3: 314, 341\\nThere are 2 numbers starting with 4: 413, 431\\n\\nThis is because when we have chosen one place out of 3 available places, there are 2 places remaining to be filled and those 2 places can be filled in 2 ways.\\n\\n**Since, K = 3, meaning it belongs to second set of two numbers and hence, answer would be appended with \"3\" and output string becomes \"23\". \\nThis means we have eliminated 2 choices starting with 1 (134, 143).**\\n\\nNow, K would be updated as K = 3 - 2 = 1.\\n\\nWe now have to identify remaining 2 places with the digits **{1,4}** with **K = 1.**\\n\\nThere is 1 number starting with 1: 14\\nThere is 1 number starting with 4: 41\\n\\nThis is because when we have chosen one place out of 2 available places, there is only 1 place remaining to be filled and that 1 place can be only be filled in 1 ways.\\n\\n**Since, K = 1, meaning it belongs to first set of one number and hence, answer would be appended with \"14\" and output string becomes \"2314\".**\\n\\n**Therefore, final answer becomes \"2314\".**\\n\\nHope it helps! :)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> fact;\\n    \\n    void findfact(int n)\\n    {\\n        fact = vector<int>(n);\\n        \\n        fact[0] = 1;\\n        \\n        if(n==1) return;\\n        \\n        fact[1] = 1;\\n        for(int i=2; i<n; i++)\\n            fact[i] = i*fact[i-1];\\n    }\\n    \\n    string getPermutation(int N, int K) {\\n        int n = N-1, k = K-1, nt, kt;\\n        \\n        findfact(N);\\n        vector<int> num(N);\\n        for(int i=0; i<N; i++)\\n            num[i] = i+1;\\n        vector<int>::iterator it; \\n        \\n        string ans = \"\";\\n        \\n        while(n>=0)\\n        {\\n            nt = k/fact[n];\\n            kt = k%fact[n];\\n\\n            ans += (num[nt]+\\'0\\');\\n            it = num.begin(); \\n            num.erase(it+nt);\\n            n--;\\n            k = kt;   \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fact;\\n    \\n    void findfact(int n)\\n    {\\n        fact = vector<int>(n);\\n        \\n        fact[0] = 1;\\n        \\n        if(n==1) return;\\n        \\n        fact[1] = 1;\\n        for(int i=2; i<n; i++)\\n            fact[i] = i*fact[i-1];\\n    }\\n    \\n    string getPermutation(int N, int K) {\\n        int n = N-1, k = K-1, nt, kt;\\n        \\n        findfact(N);\\n        vector<int> num(N);\\n        for(int i=0; i<N; i++)\\n            num[i] = i+1;\\n        vector<int>::iterator it; \\n        \\n        string ans = \"\";\\n        \\n        while(n>=0)\\n        {\\n            nt = k/fact[n];\\n            kt = k%fact[n];\\n\\n            ans += (num[nt]+\\'0\\');\\n            it = num.begin(); \\n            num.erase(it+nt);\\n            n--;\\n            k = kt;   \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502436,
                "title": "c-100-fastest-solution-best-approach-with-good-explanation-easy-to-understand-1",
                "content": "**Intution:-**\\n\\nSince this is permutaion we can assume that there are four positions that need to be filled using the four numbers of the sequence. First, we need to decide which number is to be placed at the first index. Once the number at the first index is decided we have three more positions and three more numers. Now the problem is shorter. We can repeat the technique that was used previously untl all the positions are filled.\\n\\n**On Paper Dry run:-**\\n\\n![image](https://assets.leetcode.com/users/images/0e4a79f7-809b-40b3-8f55-c89f81297d35_1661835688.8905008.jpeg)\\n\\n\\n**Approach**\\n\\n**STEP 1:**\\n\\nMathematically speaking there can be 4 variations while generating the permutation. We can have our permutation starting with either 1 or 2 or 3 or 4. If the first position is already occupied by one number there are three more positions left. The remaining three numbers can be permuted among themselves while filling the 3 positions and will generate 3! = 6 sequences. Hence each block will have 6 permutations adding up to a total of 6*4 = 24 permutations. If we consider the sequences as 0-based and in the sorted form we observe:- \\n\\n* The 0th \\u2013 5th permutation will start with 1 \\n* The 6th \\u2013 11th permutation will start with 2\\n* The 12th \\u2013 17th permutation will start with 3 \\n* The 18th \\u2013 23rd permutation will start with 4.\\n\\n\\t(For better understanding refer to the picture below.) \\n![image](https://lh5.googleusercontent.com/DgoKjAy6h0xfEl2LcWJ_aDg93Q0_gXEZkwVjH13b52VEkUtJXhrHjkav0GM5HJV8XyoRTsjN4CZrA8hCJt634hG-7vy6BP_xdpZ7HlPF_PAGCOXqNDPT0ikc_fOaQ90ktFZhPI9g)\\n\\nWe make K = 17-1 considering 0-based indexing. Since each of the four blocks illustrated above comprises 6 permutations, therefore, the 16th permutation will lie in (16 / 6 ) = 2nd block, and our answer is the (16 % 6) = 4th sequence from the 2nd block. Therefore 3 occupies the first position of the sequence and K = 4.\\n![image](https://lh4.googleusercontent.com/p62qRS1NYnrf8_DPQd3xg8mKTx-OZQ0otukMXtq7RF4xVr_xz4m569bOtFRTrh3QbTldIPMYi0Cco84dRdiH5nYxMppIYRib5drCzGc2fcXiTzrYEIyZLuDmzHjR1KhrYBt9P4_s)\\n\\n**STEP 2:**\\n\\nOur new search space comprises three elements {1,2,4} where K = 4 . Using the previous technique we can consider the second position to be occupied can be any one of these 3 numbers. Again one block can start with 1, another can start with 2 and the last one can start with 4 . Since one position is fixed, the remaining two numbers of each block can form 2! = 2  sequences. In sorted order :\\n\\n* The 0th \\u2013 1st sequence starts with 1 \\n* The 2nd \\u2013 3rd sequence starts with 2 \\n* The 4th \\u2013 5th sequence starts with 4\\n\\n![image](https://lh5.googleusercontent.com/nv-M9Ju-zoy_O7wtTb8jZZf8f5q4fdr9X987UspvacgJB4E-pVdm-3n4aT5M67KUsBp3LAFNbzNesnBFKz4f5dJoGGhuj51WpulR9dR8zPY821Uu1skTSQ7y4RCfJlfK4HDdD3p-)\\n\\nThe 4th permutation will lie in (4/2) = 2nd block and our answer is the 4%2 = 0th sequence from the 2nd block. Therefore 4 occupies the second position and K = 0.\\n\\n![image](https://lh4.googleusercontent.com/kLizY46WNhTvnZDI4mvG-U1JJ6k_cLVD8UbkczsXeUMKf-xA8CWP_3_8DB-i_YgwQ6gBnSn6HxGfYeym9F4Qf24t6ckMhCWTqsxeUS0ExmM5nP-P4f2Az609jOKui5Cq3mc9ApZg)\\n\\n**STEP 3:**\\n\\nThe new search space will have two elements {1 ,2} and K = 0. One block starts with 1 and the other block starts with 2. The other remaining number can form only one 1! = 1 sequence. In sorted form \\u2013\\n\\n* The  0th sequence starts with 1 \\n* The  1st sequence. starts with 2\\n\\n![image](https://lh4.googleusercontent.com/XSVzdDLZjo7kL5vSOEL6WYrmk7t1JqnzLCV67tYFbWBey5s0UiJ0nKFuL_sYYIqEpy2WE9x4ez-am_P4k-6ytuAEx7i1ZGmm2WtTROgS7QRa8HwxT48my-87VuhAq2VtbIs96448)\\n\\nThe 0th permutation will lie in the (0/1) = 0th block and our answer is the 0%1 = 0th sequence from the 0th block. Therefore 1 occupies the 3rd position and K = 0.\\n\\n![image](https://lh6.googleusercontent.com/ywkmQGIHcK0gpydKJ6PrNH1nTmnfFv7otGzzBTeWSOw9965Mq61wperoFrRi54fVoedVKFG5n2WG9fzbnzMQhGBOzniNsGZw87pnVyFsipAYeda7Rl6CTc2A-zmzpoIO7nWtOS3G)\\n\\n**STEP 4:** \\n\\nNow the only block has 2 in the first position and no remaining number is present.\\n![image](https://assets.leetcode.com/users/images/de57d8f1-b056-43f1-a511-7092eef574a3_1661822303.9951882.png)\\nThis is the point where we place 2 in the last position and stop.\\n![image](https://assets.leetcode.com/users/images/854d11a9-624b-492a-a9f7-0cc6ae5b1d99_1661822341.666998.png)\\n**The final answer is 3412.**\\n\\n**Code:-**\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        vector<int> nums;\\n        for(int i=1;i<n;i++){\\n            fact=fact*i;\\n            nums.push_back(i);\\n        }\\n        nums.push_back(n);\\n        k=k-1;\\n        string ans=\"\";\\n        while(true){\\n            ans=ans+to_string(nums[k/fact]);\\n            nums.erase(nums.begin()+k/fact);\\n            if(nums.size()==0){\\n                break;\\n            }\\n            k=k%fact;\\n            fact=fact/nums.size();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Code Dry run:-**\\n![image](https://assets.leetcode.com/users/images/8e2c1e09-bb27-48df-8888-0912df17f2a2_1661835737.2826996.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Backtracking",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        vector<int> nums;\\n        for(int i=1;i<n;i++){\\n            fact=fact*i;\\n            nums.push_back(i);\\n        }\\n        nums.push_back(n);\\n        k=k-1;\\n        string ans=\"\";\\n        while(true){\\n            ans=ans+to_string(nums[k/fact]);\\n            nums.erase(nums.begin()+k/fact);\\n            if(nums.size()==0){\\n                break;\\n            }\\n            k=k%fact;\\n            fact=fact/nums.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696390,
                "title": "python-math-solution-oneliner-both-o-n-2-expained",
                "content": "The simplest way to solve this problem is use backtracking, where you just generate all sequences, with complexity `O(k) = O(n!)`. We can do better. Let us consider an example: `n=6`, `k=314`. How we can find the first digit? There are `5! = 120` permutations, which start with `1`, there are also `120` permutations, which start with `2`, and so on. `314 > 2*120` and `314 < 3*120`, so it means, that the fist digit we need to take is `3`. So we build first digit of our number, remove it from list of all digits `digits` and continue:\\n\\n1. `k = 314-2*5! = 74`, `n - 1 = 5`, `d = 3`, build number so far `3`, `digits = [1,2,4,5,6]`\\n2. `k = 74-3*4! = 2`, `n - 1 = 4`, `d = 0`, build number so far `35`, `digits = [1,2,4,6]`\\n3. `k = 2-0*3! = 2`, `n - 1 = 3`, `d = 0`, build number so far `351`, `digits = [2,4,6]`\\n4. `k = 2-1*2! = 0`, `n - 1 = 2`, `d = 2`, build number so far `3512`, `digits = [4,6]`\\n5. `k = 0-1*1! = 0`, `n - 1 = 1`, `d = 2`, build number so far `35126`, `digits = [4]`\\n6. Finally, we have only one digit left, output is `351264`.\\n\\n**Complexity**. I keep list of `n` digits, and then delete them one by one. Complexity of one deletion is `O(n)`, so overall complexity is `O(n^2)`. Note, that it can be improved to `O(n log n)` if we use SortedList, but it just not worth it, `n` is too small.\\n\\n```\\nclass Solution:\\n    def getPermutation(self, n, k):\\n        numbers = list(range(1,n+1))\\n        answer = \"\"\\n        \\n        for n_it in range(n,0,-1):\\n            d = (k-1)//factorial(n_it-1)\\n            k -= d*factorial(n_it-1)\\n            answer += str(numbers[d])\\n            numbers.remove(numbers[d])\\n                   \\n        return answer\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**\\n\\n### Oneliner\\nHere it is, with `O(n^2)` complexity!\\n\\n```\\nreturn reduce(lambda s,n:(s[0]+s[2][(d:=s[1]//(f:=factorial(n)))],s[1]%f,s[2][:d]+s[2][d+1:]),range(n-1,-1,-1),(\\'\\',k-1,\\'123456789\\'))[0]\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def getPermutation(self, n, k):\\n        numbers = list(range(1,n+1))\\n        answer = \"\"\\n        \\n        for n_it in range(n,0,-1):\\n            d = (k-1)//factorial(n_it-1)\\n            k -= d*factorial(n_it-1)\\n            answer += str(numbers[d])\\n            numbers.remove(numbers[d])\\n                   \\n        return answer\\n```\n```\\nreturn reduce(lambda s,n:(s[0]+s[2][(d:=s[1]//(f:=factorial(n)))],s[1]%f,s[2][:d]+s[2][d+1:]),range(n-1,-1,-1),(\\'\\',k-1,\\'123456789\\'))[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22524,
                "title": "sharing-my-straightforward-c-solution-with-explanation",
                "content": "    string getPermutation(int n, int k) {\\n        int pTable[10] = {1};\\n        for(int i = 1; i <= 9; i++){\\n            pTable[i] = i * pTable[i - 1];\\n        }\\n        string result;\\n        vector<char> numSet;\\n        numSet.push_back('1');\\n        numSet.push_back('2');\\n        numSet.push_back('3');\\n        numSet.push_back('4');\\n        numSet.push_back('5');\\n        numSet.push_back('6');\\n        numSet.push_back('7');\\n        numSet.push_back('8');\\n        numSet.push_back('9');\\n        while(n > 0){\\n            int temp = (k - 1) / pTable[n - 1];\\n            result += numSet[temp];\\n            numSet.erase(numSet.begin() + temp);\\n            k = k - temp * pTable[n - 1];\\n            n--;\\n        }\\n        return result;\\n    }\\n\\nIn this program, `pTable` refers to permutation table and `numSet` refers to a set of numbers from 1 to 9. Before while loop, we need to initialize `pTable` and `numSet`, which is trivial.\\n\\nIn while loop, we do these following things.\\n\\n1 calculate which number we will use.\\n\\n2 remove that number from `numSet`.\\n\\n3 recalculate k.\\n\\n4 `n--`. \\n\\nFinally, we return result.",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "    string getPermutation(int n, int k) {\\n        int pTable[10] = {1};\\n        for(int i = 1; i <= 9; i++){\\n            pTable[i] = i * pTable[i - 1];\\n        }\\n        string result;\\n        vector<char> numSet;\\n        numSet.push_back('1');\\n        numSet.push_back('2');\\n        numSet.push_back('3');\\n        numSet.push_back('4');\\n        numSet.push_back('5');\\n        numSet.push_back('6');\\n        numSet.push_back('7');\\n        numSet.push_back('8');\\n        numSet.push_back('9');\\n        while(n > 0){\\n            int temp = (k - 1) / pTable[n - 1];\\n            result += numSet[temp];\\n            numSet.erase(numSet.begin() + temp);\\n            k = k - temp * pTable[n - 1];\\n            n--;\\n        }\\n        return result;\\n    }\\n\\nIn this program, `pTable` refers to permutation table and `numSet` refers to a set of numbers from 1 to 9. Before while loop, we need to initialize `pTable` and `numSet`, which is trivial.\\n\\nIn while loop, we do these following things.\\n\\n1 calculate which number we will use.\\n\\n2 remove that number from `numSet`.\\n\\n3 recalculate k.\\n\\n4 `n--`. \\n\\nFinally, we return result.",
                "codeTag": "Unknown"
            },
            {
                "id": 22554,
                "title": "backtrack-summary-general-solution-for-10-questions-python-combination-sum-subsets-permutation-palindrome",
                "content": "For Java version, please refer to [isssac3's answer.](https://discuss.leetcode.com/topic/46162/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning)\\n\\n**39. Combination Sum**\\nhttps://leetcode.com/problems/combination-sum/\\n```\\n    def combinationSum(self, candidates, target):\\n        def backtrack(tmp, start, end, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    tmp.append(candidates[i])\\n                    backtrack(tmp, i, end, target - candidates[i])\\n                    tmp.pop()\\n        ans = [] \\n        candidates.sort(reverse= True)\\n        backtrack([], 0, len(candidates), target)\\n        return ans\\n```\\n\\n**40. Combination Sum II**\\nhttps://leetcode.com/problems/combination-sum-ii/\\n```\\n    def combinationSum2(self, candidates, target):\\n        def backtrack(start, end, tmp, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    if i > start and candidates[i] == candidates[i-1]:\\n                        continue\\n                    tmp.append(candidates[i])\\n                    backtrack(i+1, end, tmp, target - candidates[i])\\n                    tmp.pop()\\n        ans = []\\n        candidates.sort(reverse= True)\\n        backtrack(0, len(candidates), [], target)\\n        return ans\\n```\\n\\n**78. Subsets**\\nhttps://leetcode.com/problems/subsets/\\n```\\n    def subsets(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\\n\\n**90. Subsets II**\\nhttps://leetcode.com/problems/subsets-ii/\\n```\\n    def subsetsWithDup(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                if i > start and nums[i] == nums[i-1]:\\n                    continue\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        nums.sort()\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\\n\\n**46. Permutations**\\nhttps://leetcode.com/problems/permutations/\\n```\\n    def permute(self, nums):\\n        def backtrack(start, end):\\n            if start == end:\\n                ans.append(nums[:])\\n            for i in range(start, end):\\n                nums[start], nums[i] = nums[i], nums[start]\\n                backtrack(start+1, end)\\n                nums[start], nums[i] = nums[i], nums[start]\\n                \\n        ans = []\\n        backtrack(0, len(nums))\\n        return ans\\n```\\n\\n**47. Permutations II**\\nhttps://leetcode.com/problems/permutations-ii/\\n```\\n    def permuteUnique(self, nums):\\n        def backtrack(tmp, size):\\n            if len(tmp) == size:\\n                ans.append(tmp[:])\\n            else:\\n                for i in range(size):\\n                    if visited[i] or (i > 0 and nums[i-1] == nums[i] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(nums[i])\\n                    backtrack(tmp, size)\\n                    tmp.pop()\\n                    visited[i] = False\\n        ans = []\\n        visited = [False] * len(nums)\\n        nums.sort()\\n        backtrack([], len(nums))\\n        return ans\\n```\\n\\n**60. Permutation Sequence**\\nhttps://leetcode.com/problems/permutation-sequence/\\n```\\n    def getPermutation(self, n, k):\\n        nums = [str(i) for i in range(1, n+1)]\\n        fact = [1] * n\\n        for i in range(1,n):\\n            fact[i] = i*fact[i-1]\\n        k -= 1\\n        ans = []\\n        for i in range(n, 0, -1):\\n            id = k / fact[i-1]\\n            k %= fact[i-1]\\n            ans.append(nums[id])\\n            nums.pop(id)\\n        return ''.join(ans)\\n```\\n\\n**131. Palindrome Partitioning**\\nhttps://leetcode.com/problems/palindrome-partitioning/\\n```\\n    def partition(self, s):\\n        def backtrack(start, end, tmp):\\n            if start == end:\\n                ans.append(tmp[:])\\n            for i in range(start, end):\\n                cur = s[start:i+1]\\n                if cur == cur[::-1]:\\n                    tmp.append(cur)\\n                    backtrack(i+1, end, tmp)\\n                    tmp.pop()\\n        ans = []\\n        backtrack(0, len(s), [])\\n        return ans\\n```\\n\\n****\\n\\n\\n**267. Palindrome Permutation II**\\nhttps://leetcode.com/problems/palindrome-permutation-ii/\\nRelated to this two:\\n`31. Next Permutation`: https://leetcode.com/problems/next-permutation/\\n`266. Palindrome Permutation`: https://leetcode.com/problems/palindrome-permutation/\\n\\n```\\n    def generatePalindromes(self, s):\\n        kv = collections.Counter(s)\\n        mid = [k for k, v in kv.iteritems() if v%2]\\n        if len(mid) > 1:\\n            return []\\n        mid = '' if mid == [] else mid[0]\\n        half = ''.join([k * (v/2) for k, v in kv.iteritems()])\\n        half = [c for c in half]\\n        \\n        def backtrack(end, tmp):\\n            if len(tmp) == end:\\n                cur = ''.join(tmp)\\n                ans.append(cur + mid + cur[::-1])\\n            else:\\n                for i in range(end):\\n                    if visited[i] or (i>0 and half[i] == half[i-1] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(half[i])\\n                    backtrack(end, tmp)\\n                    visited[i] = False\\n                    tmp.pop()\\n                    \\n        ans = []\\n        visited = [False] * len(half)\\n        backtrack(len(half), [])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n    def combinationSum(self, candidates, target):\\n        def backtrack(tmp, start, end, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    tmp.append(candidates[i])\\n                    backtrack(tmp, i, end, target - candidates[i])\\n                    tmp.pop()\\n        ans = [] \\n        candidates.sort(reverse= True)\\n        backtrack([], 0, len(candidates), target)\\n        return ans\\n```\n```\\n    def combinationSum2(self, candidates, target):\\n        def backtrack(start, end, tmp, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    if i > start and candidates[i] == candidates[i-1]:\\n                        continue\\n                    tmp.append(candidates[i])\\n                    backtrack(i+1, end, tmp, target - candidates[i])\\n                    tmp.pop()\\n        ans = []\\n        candidates.sort(reverse= True)\\n        backtrack(0, len(candidates), [], target)\\n        return ans\\n```\n```\\n    def subsets(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\n```\\n    def subsetsWithDup(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                if i > start and nums[i] == nums[i-1]:\\n                    continue\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        nums.sort()\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\n```\\n    def permute(self, nums):\\n        def backtrack(start, end):\\n            if start == end:\\n                ans.append(nums[:])\\n            for i in range(start, end):\\n                nums[start], nums[i] = nums[i], nums[start]\\n                backtrack(start+1, end)\\n                nums[start], nums[i] = nums[i], nums[start]\\n                \\n        ans = []\\n        backtrack(0, len(nums))\\n        return ans\\n```\n```\\n    def permuteUnique(self, nums):\\n        def backtrack(tmp, size):\\n            if len(tmp) == size:\\n                ans.append(tmp[:])\\n            else:\\n                for i in range(size):\\n                    if visited[i] or (i > 0 and nums[i-1] == nums[i] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(nums[i])\\n                    backtrack(tmp, size)\\n                    tmp.pop()\\n                    visited[i] = False\\n        ans = []\\n        visited = [False] * len(nums)\\n        nums.sort()\\n        backtrack([], len(nums))\\n        return ans\\n```\n```\\n    def getPermutation(self, n, k):\\n        nums = [str(i) for i in range(1, n+1)]\\n        fact = [1] * n\\n        for i in range(1,n):\\n            fact[i] = i*fact[i-1]\\n        k -= 1\\n        ans = []\\n        for i in range(n, 0, -1):\\n            id = k / fact[i-1]\\n            k %= fact[i-1]\\n            ans.append(nums[id])\\n            nums.pop(id)\\n        return ''.join(ans)\\n```\n```\\n    def partition(self, s):\\n        def backtrack(start, end, tmp):\\n            if start == end:\\n                ans.append(tmp[:])\\n            for i in range(start, end):\\n                cur = s[start:i+1]\\n                if cur == cur[::-1]:\\n                    tmp.append(cur)\\n                    backtrack(i+1, end, tmp)\\n                    tmp.pop()\\n        ans = []\\n        backtrack(0, len(s), [])\\n        return ans\\n```\n```\\n    def generatePalindromes(self, s):\\n        kv = collections.Counter(s)\\n        mid = [k for k, v in kv.iteritems() if v%2]\\n        if len(mid) > 1:\\n            return []\\n        mid = '' if mid == [] else mid[0]\\n        half = ''.join([k * (v/2) for k, v in kv.iteritems()])\\n        half = [c for c in half]\\n        \\n        def backtrack(end, tmp):\\n            if len(tmp) == end:\\n                cur = ''.join(tmp)\\n                ans.append(cur + mid + cur[::-1])\\n            else:\\n                for i in range(end):\\n                    if visited[i] or (i>0 and half[i] == half[i-1] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(half[i])\\n                    backtrack(end, tmp)\\n                    visited[i] = False\\n                    tmp.pop()\\n                    \\n        ans = []\\n        visited = [False] * len(half)\\n        backtrack(len(half), [])\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 22650,
                "title": "0ms-c-12-line-concise-solution-no-recursion-no-helper-function",
                "content": "Attached please find my solution.\\n\\nIdea:\\n\\n- For an n-element permutation, there are (n-1)! permutations started with '1', (n-1)! permutations started with '2', and so forth. Therefore we can determine the value of the first element.\\n\\n- After determining the first element, there are (n-1) candidates left. Then there are (n-2)! permutations started with the minimum element within the remaining set, and so forth.\\n\\nComplexities:\\n\\n- Time complexity: O(n^2)   \\n\\n- Space complexity: O(n)\\n\\n==\\n\\n    class Solution {\\n    public:\\n        string getPermutation(int n, int k) {\\n            // initialize a dictionary that stores 1, 2, ..., n. This string will store the permutation.\\n            string dict(n, 0);\\n            iota(dict.begin(), dict.end(), '1');\\n            \\n            // build up a look-up table, which stores (n-1)!, (n-2)!, ..., 1!, 0!\\n            vector<int> fract(n, 1);\\n            for (int idx = n - 3; idx >= 0; --idx) {\\n                fract[idx] = fract[idx + 1] * (n - 1 - idx);\\n            }\\n            \\n            // let k be zero base\\n            --k;\\n            \\n            // the main part.\\n            string ret(n, 0);\\n            for (int idx = 0; idx < n; ++idx) {\\n                int select = k / fract[idx];\\n                k %= fract[idx];\\n                ret[idx] = dict[select];\\n                dict.erase(next(dict.begin(), select)); // note that it is an O(n) operation\\n            }\\n            return ret;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string getPermutation(int n, int k) {\\n            // initialize a dictionary that stores 1, 2, ..., n. This string will store the permutation.\\n            string dict(n, 0);\\n            iota(dict.begin(), dict.end(), '1');\\n            \\n            // build up a look-up table, which stores (n-1)!, (n-2)!, ..., 1!, 0!\\n            vector<int> fract(n, 1);\\n            for (int idx = n - 3; idx >= 0; --idx) {\\n                fract[idx] = fract[idx + 1] * (n - 1 - idx);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 22546,
                "title": "simple-0s-c-solution",
                "content": "since n will be between 1 and 9 inclusive. pre-calculate the factorials is faster.\\n\\n    class Solution {\\n    public:\\n        string getPermutation(int n, int k) {\\n            string res;\\n            string nums = \"123456789\";\\n            int f[10] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};\\n            --k;\\n            for (int i = n; i >= 1; --i) {\\n                int j = k / f[i - 1];\\n                k %= f[i - 1];\\n                res.push_back(nums[j]);\\n                nums.erase(nums.begin() + j);\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string getPermutation(int n, int k) {\\n            string res;\\n            string nums = \"123456789\";\\n            int f[10] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880}",
                "codeTag": "Java"
            },
            {
                "id": 1305852,
                "title": "c-recursive-solution-maths-explained-0ms-faster-than-100",
                "content": "**Question is to find the Kth permutation of a given number.**\\n\\nNaive approach to solve this problem is to store all the possible permutations in an array and then simply return the kth one. This approach works perfectly fine but is having poor time complexity \\uD83D\\uDE11\\n\\nThe most optimised approach of this question (according me) is rather than traversing on each and every possible permutation, we should only go to the kth one !! Rather than making an array, recursive function should just return the perfect one i.e. the kth one. \\uD83D\\uDE42\\uD83D\\uDD25\\n\\nNow the question is, How can we do that ?? How can we reach directly to the kth permutation ? And the answer to this question is, by simply using a little bit of maths \\uD83D\\uDD22 .\\n\\n**MATHS EXPLANATION**\\n\\nWe know that number of permutations of a given number is simply calculated as n! where n is the number of digits of number n. To conclude, we can assure that number with n digits will have n! permutations and we can further say that it will have n groups of (n-1)! permutations.\\n\\nWe can simply see in this figure that we can make n groups of (n-1)! and we can check in which group kth permutation will lie.\\n\\n![image](https://assets.leetcode.com/users/images/463493a4-f198-4e4b-b890-2f99560aff07_1625003760.0458527.png)\\n\\nAfter finding the most suitable group for the kth permutation, we will then do the same for that group as well and in that case, there will be (n-1) groups for (n-2)! permutations.\\n\\nWe will keep doing the same recursively until we find the best result i.e kth permutation.\\n\\nHere is the code for the problem : \\n\\n```\\nclass Solution {\\npublic:\\n    \\n\\t// this function is called to calculate possible number\\n\\t// of permutations for a given point through which, we will \\n\\t// calculate number of possible groups\\n\\t\\n    int fact(int num)\\n    {\\n        if(num==0)\\n            return 1 ;\\n        \\n        return num*fact(num-1);\\n    }\\n    \\n    string ans ;\\n    int count = 0 ;\\n    \\n    void permute(string str , int k, string finalAns)\\n    {\\n        \\n        if(str.length()==0)\\n        {\\n            ans = finalAns ;\\n            return ;\\n        }\\n        \\n        int number = str.length() - 1 ;\\n        int factNum = fact(number) ;\\n        \\n        for(int ctr = 0 ; ctr < str.length() ; ctr++ )\\n        {\\n            \\n            if( factNum < k )\\n            {\\n                k-=factNum;\\n                continue;\\n            }\\n            \\n            string sub = str.substr(0,ctr) + str.substr(ctr+1);\\n            permute(sub,k,finalAns+str[ctr]);\\n            break;\\n            \\n        }\\n        \\n    }\\n    \\n    string getPermutation(int n, int k) {\\n        \\n        string str = \"\" ;\\n        \\n        for(int ctr = 1 ; ctr <=n ; ctr++ )            \\n            str+=to_string(ctr);\\n        \\n        permute(str,k,\"\");\\n        \\n        return ans ;\\n        \\n    }\\n};\\n```\\n\\nI am still not sure if this is the best solution even after 0ms and faster than 100 % . Do upvote if you liked my approach ! All the best ! Happy Learning.",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\t// this function is called to calculate possible number\\n\\t// of permutations for a given point through which, we will \\n\\t// calculate number of possible groups\\n\\t\\n    int fact(int num)\\n    {\\n        if(num==0)\\n            return 1 ;\\n        \\n        return num*fact(num-1);\\n    }\\n    \\n    string ans ;\\n    int count = 0 ;\\n    \\n    void permute(string str , int k, string finalAns)\\n    {\\n        \\n        if(str.length()==0)\\n        {\\n            ans = finalAns ;\\n            return ;\\n        }\\n        \\n        int number = str.length() - 1 ;\\n        int factNum = fact(number) ;\\n        \\n        for(int ctr = 0 ; ctr < str.length() ; ctr++ )\\n        {\\n            \\n            if( factNum < k )\\n            {\\n                k-=factNum;\\n                continue;\\n            }\\n            \\n            string sub = str.substr(0,ctr) + str.substr(ctr+1);\\n            permute(sub,k,finalAns+str[ctr]);\\n            break;\\n            \\n        }\\n        \\n    }\\n    \\n    string getPermutation(int n, int k) {\\n        \\n        string str = \"\" ;\\n        \\n        for(int ctr = 1 ; ctr <=n ; ctr++ )            \\n            str+=to_string(ctr);\\n        \\n        permute(str,k,\"\");\\n        \\n        return ans ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257221,
                "title": "c-solution-with-comments-brute-force-and-optimal-easy-understanding",
                "content": "***Please Upvote if it helps you...***\\n![image](https://assets.leetcode.com/users/images/308215da-c176-4c85-9e1d-0200c754cf7f_1657345920.9695845.gif)\\n\\n***\\n***Solution 1: Brute Force Solution***\\n***\\n***\\n***Approach:***\\n***\\nThe extreme naive solution is to generate all the possible permutations of the given sequence.  This is achieved using recursion and every permutation generated is stored in some other data structure (here we have used a vector). Finally, we sort the data structure in which we have stored all the sequences and return the Kth sequence from it.\\n***\\n***\\n***C++ Code:-***\\n***\\n```\\nclass Solution {\\n  public:\\n    //function to generate all possible permutations of a string\\n    void solve(string & s, int index, vector < string > & res) {\\n      if (index == s.size()) {\\n        res.push_back(s);\\n        return;\\n      }\\n      for (int i = index; i < s.size(); i++) {\\n        swap(s[i], s[index]);\\n        solve(s, index + 1, res);\\n        swap(s[i], s[index]);\\n      }\\n    }\\nstring getPermutation(int n, int k) {\\n    string s;\\n    vector < string > res;\\n    //create string\\n    for (int i = 1; i <= n; i++) {\\n      s.push_back(i + \\'0\\');\\n    }\\n    solve(s, 0, res);\\n    //sort the generated permutations\\n    sort(res.begin(), res.end());\\n    //make k 0-based indexed to point to kth sequence\\n    auto it = res.begin() + (k - 1);\\n    return *it;\\n  }\\n};\\n```\\n***\\n***\\n***Time complexity: O(N!  N) +O(N! Log N!)***\\n\\n***Reason:***  The recursion takes O(N!)  time because we generate every possible permutation and another O(N)  time is required to make a deep copy and store every sequence in the data structure. Also, O(N! Log N!)  time required to sort the data structure\\n\\n***Space complexity: O(N)*** \\n\\n***Reason:*** Result stored in a vector, we are auxiliary space taken by recursion\\n***\\n***\\n***Solution 2:(Optimal Approach)***\\n\\nSay we have N = 4  and K = 17. Hence the number sequence is {1,2,3,4}. \\n***\\n***Intuition:***\\n\\nSince this is a permutation we can assume that there are four positions that need to be filled using the four numbers of the sequence. First, we need to decide which number is to be placed at the first index. Once the number at the first index is decided we have three more positions and three more numbers.  Now the problem is shorter. We can repeat the technique that was used previously until all the positions are filled. The technique is explained below.\\n***\\n***\\n***Approach:***\\n\\n***STEP 1:***\\n\\nMathematically speaking there can be 4 variations while generating the permutation. We can have our permutation starting with either 1 or 2 or 3 or 4. If the first position is already occupied by one number there are three more positions left. The remaining three numbers can be permuted among themselves while filling the 3 positions and will generate 3! = 6 sequences. Hence each block will have 6 permutations adding up to a total of 6*4 = 24 permutations. If we consider the sequences as 0-based and in the sorted form we observe:- \\n\\nThe 0th \\u2013 5th permutation will start with 1 \\nThe 6th \\u2013 11th permutation will start with 2\\nThe 12th \\u2013 17th permutation will start with 3 \\nThe 18th \\u2013 23rd permutation will start with 4.\\n\\n (For better understanding refer to the picture below.) \\n\\n![image](https://assets.leetcode.com/users/images/d01d09a0-37d2-4152-89ec-87dadd9ac1c1_1657345602.0382993.png)\\n\\n\\nWe make K = 17-1 considering 0-based indexing. Since each of the four blocks illustrated above comprises 6 permutations, therefore, the 16th permutation will lie in (16 / 6 ) = 2nd block, and our answer is the (16 % 6) = 4th sequence from the 2nd block. Therefore 3 occupies the first position of the sequence and K = 4.\\n\\n![image](https://assets.leetcode.com/users/images/ba557ff2-c1cb-45a3-99f9-26eee5183535_1657345592.8419704.png)\\n***\\n\\n***STEP 2:***\\n\\nOur new search space comprises three elements {1,2,4} where K = 4 . Using the previous technique we can consider the second position to be occupied can be any one of these 3 numbers. Again one block can start with 1, another can start with 2 and the last one can start with 4 . Since one position is fixed, the remaining two numbers of each block can form 2! = 2  sequences. In sorted order :\\n\\nThe 0th \\u2013 1st sequence starts with 1 \\nThe 2nd \\u2013 3rd sequence starts with 2 \\nThe 4th \\u2013 5th sequence starts with 4\\n![image](https://assets.leetcode.com/users/images/971c94d9-7368-4160-b681-9ae4fb1c2688_1657345583.4629538.png)\\n\\n\\nThe 4th permutation will lie in (4/2) = 2nd block and our answer is the 4%2 = 0th sequence from the 2nd block. Therefore 4 occupies the second position and K = 0.\\n\\n***\\n\\n***STEP 3:***\\n\\nThe new search space will have two elements {1 ,2} and K = 0. One block starts with 1 and the other block starts with 2. The other remaining number can form only one 1! = 1 sequence. In sorted form \\u2013\\n\\nThe  0th sequence starts with 1 \\nThe  1st sequence. starts with 2\\n![image](https://assets.leetcode.com/users/images/e75d4c48-36b5-4952-aebf-805e73a66da5_1657345575.3617208.png)\\n\\n\\nThe 0th permutation will lie in the (0/1) = 0th block and our answer is the 0%1 = 0th sequence from the 0th block. Therefore 1 occupies the 3rd position and K = 0.\\n***\\n\\n\\n***STEP 4:***\\n\\nNow the only block has 2 in the first position and no remaining number is present.\\n![image](https://assets.leetcode.com/users/images/0c53bf48-30eb-4f5a-9ca7-5a1995a0da9a_1657345567.3807125.png)\\n\\n\\nThis is the point where we place 2 in the last position and stop.\\n***\\n\\n***The final answer is 3412.***\\n***\\n***\\n\\nC++ Code:-\\n***\\n```\\nstring getPermutation(int n, int k) {\\n      int fact = 1;\\n      vector < int > numbers;\\n      for (int i = 1; i < n; i++) {\\n        fact = fact * i;\\n        numbers.push_back(i);\\n      }\\n      numbers.push_back(n);\\n      string ans = \"\";\\n      k = k - 1;\\n      while (true) {\\n        ans = ans + to_string(numbers[k / fact]);\\n        numbers.erase(numbers.begin() + k / fact);\\n        if (numbers.size() == 0) {\\n          break;\\n        }\\n\\n        k = k % fact;\\n        fact = fact / numbers.size();\\n      }\\n      return ans;\\n    }\\n```\\n***\\n***\\n***Time Complexity: O(N)  O(N) = O(N^2)***\\n\\n***Reason:*** We are placing N numbers in N positions. This will take O(N) time. For every number, we are reducing the search space by removing the element already placed in the previous step. This takes another O(N) time.\\n\\n***Space Complexity: O(N)***\\n\\n***Reason:*** We are storing  the numbers in a data structure(here vector)\\n***\\n***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n    //function to generate all possible permutations of a string\\n    void solve(string & s, int index, vector < string > & res) {\\n      if (index == s.size()) {\\n        res.push_back(s);\\n        return;\\n      }\\n      for (int i = index; i < s.size(); i++) {\\n        swap(s[i], s[index]);\\n        solve(s, index + 1, res);\\n        swap(s[i], s[index]);\\n      }\\n    }\\nstring getPermutation(int n, int k) {\\n    string s;\\n    vector < string > res;\\n    //create string\\n    for (int i = 1; i <= n; i++) {\\n      s.push_back(i + \\'0\\');\\n    }\\n    solve(s, 0, res);\\n    //sort the generated permutations\\n    sort(res.begin(), res.end());\\n    //make k 0-based indexed to point to kth sequence\\n    auto it = res.begin() + (k - 1);\\n    return *it;\\n  }\\n};\\n```\n```\\nstring getPermutation(int n, int k) {\\n      int fact = 1;\\n      vector < int > numbers;\\n      for (int i = 1; i < n; i++) {\\n        fact = fact * i;\\n        numbers.push_back(i);\\n      }\\n      numbers.push_back(n);\\n      string ans = \"\";\\n      k = k - 1;\\n      while (true) {\\n        ans = ans + to_string(numbers[k / fact]);\\n        numbers.erase(numbers.begin() + k / fact);\\n        if (numbers.size() == 0) {\\n          break;\\n        }\\n\\n        k = k % fact;\\n        fact = fact / numbers.size();\\n      }\\n      return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22597,
                "title": "does-anyone-have-a-better-idea-share-my-accepted-python-code-here",
                "content": "It's obvious that if we try to come up with n! solutions one by one until it reach kth element - O(k), it will exceed the time limit. Therefore, I tried to implement a mathematical solution as follows:\\n\\n     class Solution:\\n        # @return a string\\n        def getPermutation(self, n, k):\\n    \\n            ll = [str(i) for i in range(1,n+1)] # build a list of [\"1\",\"2\",...\"n\"]\\n    \\n            divisor = 1\\n            for i in range(1,n): # calculate 1*2*3*...*(n-1)\\n                divisor *= i\\n    \\n            answer = \"\"\\n            while k>0 and k<=divisor*n:  # there are only (divisor*n) solutions in total \\n                group_num = k/divisor\\n                k %= divisor\\n    \\n                if k>0: # it's kth element of (group_num+1)th group\\n                    choose = ll.pop(group_num)\\n                    answer += choose\\n                else: # it's last element of (group_num)th group\\n                    choose = ll.pop(group_num-1) \\n                    answer += choose\\n                    ll.reverse() # reverse the list to get DESC order for the last element\\n                    to_add = \"\".join(ll)\\n                    answer += to_add\\n                    break\\n    \\n                divisor/=len(ll)\\n    \\n            return answer\\n     \\nBriefly take **(n,k) = (4,21)** for example, in the first iteration we divide the solution set into 4 groups: \"1xxx\", \"2xxx\", \"3xxx\", and \"4xxx\", while each group has 3! = 6 members. \\n\\nFrom 21/6 = 3...3, we know that the 21th element is the 3rd element in the (3+1)th group. In this group, we can divide it into 3 sub-groups again: \"41xx\", \"42xx\" and \"43xx\", and each group has 2!=2 members. \\n\\nThen, we calculate 3/2 and get 1...1, so it's the 1st element of (1+1)nd sub-group - \"421x\", and now it reach the base case with only one possibility - **\"4213\"**.\\n\\nAnyone pass the problem with different ideas?",
                "solutionTags": [
                    "Python",
                    "Probability and Statistics"
                ],
                "code": "It's obvious that if we try to come up with n! solutions one by one until it reach kth element - O(k), it will exceed the time limit. Therefore, I tried to implement a mathematical solution as follows:\\n\\n     class Solution:\\n        # @return a string\\n        def getPermutation(self, n, k):\\n    \\n            ll = [str(i) for i in range(1,n+1)] # build a list of [\"1\",\"2\",...\"n\"]\\n    \\n            divisor = 1\\n            for i in range(1,n): # calculate 1*2*3*...*(n-1)\\n                divisor *= i\\n    \\n            answer = \"\"\\n            while k>0 and k<=divisor*n:  # there are only (divisor*n) solutions in total \\n                group_num = k/divisor\\n                k %= divisor\\n    \\n                if k>0: # it's kth element of (group_num+1)th group\\n                    choose = ll.pop(group_num)\\n                    answer += choose\\n                else: # it's last element of (group_num)th group\\n                    choose = ll.pop(group_num-1) \\n                    answer += choose\\n                    ll.reverse() # reverse the list to get DESC order for the last element\\n                    to_add = \"\".join(ll)\\n                    answer += to_add\\n                    break\\n    \\n                divisor/=len(ll)\\n    \\n            return answer\\n     \\nBriefly take **(n,k) = (4,21)** for example, in the first iteration we divide the solution set into 4 groups: \"1xxx\", \"2xxx\", \"3xxx\", and \"4xxx\", while each group has 3! = 6 members. \\n\\nFrom 21/6 = 3...3, we know that the 21th element is the 3rd element in the (3+1)th group. In this group, we can divide it into 3 sub-groups again: \"41xx\", \"42xx\" and \"43xx\", and each group has 2!=2 members. \\n\\nThen, we calculate 3/2 and get 1...1, so it's the 1st element of (1+1)nd sub-group - \"421x\", and now it reach the base case with only one possibility - **\"4213\"**.\\n\\nAnyone pass the problem with different ideas?",
                "codeTag": "Java"
            },
            {
                "id": 2992652,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> v={0};\\n        int tmp=1;\\n        for(int i=1;i<=n;i++){\\n            v.push_back(i);\\n            tmp*=i;\\n        }\\n        string s;\\n        cout<<tmp<<\" \";\\n        for(int i=n;i>=2;i--){\\n            tmp/=i;\\n            int fl=(k+tmp-1)/tmp;\\n            s.push_back(v[fl]+\\'0\\');\\n            k-=(fl-1)*tmp;\\n            for(int j=fl;j<v.size()-1;j++){\\n                v[j]=v[j+1];\\n            }\\n        }\\n        s.push_back(v[1]+\\'0\\');   \\n        return s;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        nums = [i for i in range(1, n+1)] # list of numbers from 1 to n\\n        factorial = [1] * n\\n        for i in range(1, n):\\n            factorial[i] = factorial[i-1] * i\\n        \\n        k -= 1\\n        result = []\\n        for i in range(n-1, -1, -1):\\n            index = k // factorial[i]\\n            result.append(str(nums[index]))\\n            nums.pop(index)\\n            k = k % factorial[i]\\n        \\n        return \\'\\'.join(result)\\n```\\n\\n```Java []\\nclass Solution {\\n    private static int[] fact = {0, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};\\n    \\n    private String getPermutation(int n, int k, boolean[] nums, char[] str, int index) {\\n        int i = 0, m = nums.length;\\n        if(n == 1) {\\n            while(i < m && nums[i]) ++i;\\n            str[index++]=(char)(\\'0\\'+i+1);\\n            return String.valueOf(str);\\n        }\\n        if(k == 0) {\\n            while(i < m) {\\n                if(!nums[i]) str[index++]=(char)(\\'0\\'+i+1);\\n                ++i;\\n            }\\n            return String.valueOf(str);\\n        }\\n        \\n        int div = k/fact[n-1], mod = k%fact[n-1], j = -1;\\n        while(i < m-1 && div != j) {\\n            if(!nums[i]) ++j;\\n            if(j == div) break;\\n            ++i;\\n        }\\n        str[index++]=(char)(\\'0\\'+i+1);\\n        if(i < m) nums[i]=true;\\n        return getPermutation(n-1, mod, nums, str, index); \\n    }\\n\\n    public String getPermutation(int n, int k) {\\n        boolean[] nums = new boolean[n];\\n        char[] charArr = new char[n];\\n        return getPermutation(n, k-1, nums, charArr, 0);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> v={0};\\n        int tmp=1;\\n        for(int i=1;i<=n;i++){\\n            v.push_back(i);\\n            tmp*=i;\\n        }\\n        string s;\\n        cout<<tmp<<\" \";\\n        for(int i=n;i>=2;i--){\\n            tmp/=i;\\n            int fl=(k+tmp-1)/tmp;\\n            s.push_back(v[fl]+\\'0\\');\\n            k-=(fl-1)*tmp;\\n            for(int j=fl;j<v.size()-1;j++){\\n                v[j]=v[j+1];\\n            }\\n        }\\n        s.push_back(v[1]+\\'0\\');   \\n        return s;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        nums = [i for i in range(1, n+1)] # list of numbers from 1 to n\\n        factorial = [1] * n\\n        for i in range(1, n):\\n            factorial[i] = factorial[i-1] * i\\n        \\n        k -= 1\\n        result = []\\n        for i in range(n-1, -1, -1):\\n            index = k // factorial[i]\\n            result.append(str(nums[index]))\\n            nums.pop(index)\\n            k = k % factorial[i]\\n        \\n        return \\'\\'.join(result)\\n```\n```Java []\\nclass Solution {\\n    private static int[] fact = {0, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};\\n    \\n    private String getPermutation(int n, int k, boolean[] nums, char[] str, int index) {\\n        int i = 0, m = nums.length;\\n        if(n == 1) {\\n            while(i < m && nums[i]) ++i;\\n            str[index++]=(char)(\\'0\\'+i+1);\\n            return String.valueOf(str);\\n        }\\n        if(k == 0) {\\n            while(i < m) {\\n                if(!nums[i]) str[index++]=(char)(\\'0\\'+i+1);\\n                ++i;\\n            }\\n            return String.valueOf(str);\\n        }\\n        \\n        int div = k/fact[n-1], mod = k%fact[n-1], j = -1;\\n        while(i < m-1 && div != j) {\\n            if(!nums[i]) ++j;\\n            if(j == div) break;\\n            ++i;\\n        }\\n        str[index++]=(char)(\\'0\\'+i+1);\\n        if(i < m) nums[i]=true;\\n        return getPermutation(n-1, mod, nums, str, index); \\n    }\\n\\n    public String getPermutation(int n, int k) {\\n        boolean[] nums = new boolean[n];\\n        char[] charArr = new char[n];\\n        return getPermutation(n, k-1, nums, charArr, 0);\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2777028,
                "title": "permutation-sequence-java-solution-1-bruteforce-approach-2-optimal-approach",
                "content": "```\\n1. First Approach\\n//generate all permutation for 1 to n\\n//store all permutation in some data structure\\n//return kth term from data structure\\n\\n//Example :- n=3 , k=4\\n//Generate permutations(LeetCode Qus. 46 :- Permutations) 1 to 3 i.e. \\n123\\n132\\n213\\n231\\n312\\n321\\n//k=4th term is 231\\n//our ans will be 231\\n\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int num[] = new int[n];\\n        for(int i=0; i<n; i++)\\n        {\\n            num[i] = i+1;\\n        }\\n        List<String> Tans = new ArrayList<>();\\n        help(0,num,n,k,Tans);\\n        Collections.sort(Tans);\\n        return Tans.get(k-1);\\n    }\\n    void help(int index, int[] num, int n, int k, List<String> Tans)\\n    {\\n        \\n        if(index==num.length){\\n            StringBuffer store = new StringBuffer();\\n            for(int i=0; i<n; i++)\\n            {\\n                store.append(num[i]);\\n            }\\n            Tans.add(store.toString());\\n            return;\\n        }\\n        \\n        for(int i=index; i<n; i++)\\n        {\\n            swap(i,index,num);\\n            help(index+1,num,n,k,Tans);\\n            swap(i,index,num);\\n        }\\n    }\\n    void swap(int i, int j, int[] num)\\n    {\\n        int temp = num[i];\\n        num[i] = num[j];\\n        num[j] = temp;\\n    }\\n //T.C :- n!(for generating permutation) * n(for looping i=0 to nums.length) * n!logn(for sorting n! permutation)\\n}\\n\\n2. Optimal Approach :- using Mathematics\\n//Example :- n=4 ,k=17\\n                                 /////////STEP 1\\n//We can have our permutation starting with either 1 or 2 or 3 or 4.\\n//If first position is occupied by one number then there are three more positions left.\\n//Then remaining three numbers can be permuted among themselves 3! = 6 sequences.\\n\\n//if we consider sequences as 0-based index in sorted form              \\n0th block  |0th \\u2013 5th permutation will start with 1   | {2,3,4} i.e. 0th{1,2,3,4}, 1st{1,2,4,3}, 2nd{1,3,2,4}, 3rd{1,3,4,2}, 4th{1,4,2,3}, 5th{1,4,3,2}\\n1st block  |6th \\u2013 11th permutation will start with 2  | {1,3,4} i.e. 6th{2,1,3,4}, 7th{2,1,4,3}, 8th{2,3,1,4}, 9th{2,3,4,1}, 10th{2,4,1,3}, 11th{2,4,3,1}\\n2nd block  |12th \\u2013 17th permutation will start with 3 | {1,2,4} i.e. 12th{3,1,2,4}, 13th{3,1,4,2}, 14th{3,2,1,4}, 15th{3,2,4,1}, 16th{3,4,1,2}, 17th{3,4,2,1}\\n3rd block  |18th \\u2013 23rd permutation will start with 4 | {1,2,3} i.e. 18th{4,1,2,3}, 19th{4,1,3,2}, 20th{4,2,1,3}, 21st{4,2,3,1}, 22nd{4,3,1,2}, 23rd{4,3,2,1}\\n\\n//make K = 17-1 considering 0-based indexing\\n//Since each of the four blocks illustrated above comprises 6 permutations, therefore the 16th permutation will lie in (16 / 6 ) = 2nd block i.e. 3 ans={3---}\\n/and our answer is the (16 % 6) = 4th sequence from the 2nd block.\\n    \\n                                  //////////STEP 2\\n  //Our new search space comprises three elements {1,2,4} where K = 4 \\n  //If first position is occupied by one number then there are two more positions left.\\n  //Then remaining two numbers can be permuted among themselves 2! = 2 sequences.\\n\\n0th block  |0th \\u2013 1st sequence starts with 1 | {2,4} \\n1st block  |2nd \\u2013 3rd sequence starts with 2 | {1,4}\\n2nd block  |4th \\u2013 5th sequence starts with 4 | {1,2}\\n\\n//(4/2) = 2nd block i.e 4   ans={34--}\\n//4%2 = 0th sequence from 2nd block\\n\\n                                     /////////STEP 3\\n        //Our new search space comprises three elements {1,2} where K = 0\\n        //If first position is occupied by one number then there are one more positions left.\\n        //Then remaining one numbers can be permuted among themselves 1! = 1 sequences.\\n0th block |0th sequence starts with 1  | {2} \\n1st block |1st sequence. starts with 2 | {1}\\n\\n//(0/1) = 0th block i.e. ans={341}\\n//0%1 = 0th sequence from 0th block\\n\\n                                   /////////STEP 4\\n//only 2 is remaining \\nans = {3412}\\n\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int fact = 1;\\n        ArrayList < Integer > numbers = new ArrayList < > ();\\n        for (int i = 1; i < n; i++) {\\n            fact = fact * i;\\n            numbers.add(i);\\n        }\\n        numbers.add(n);\\n        String ans = \"\";\\n        k = k - 1;\\n        while (true) {\\n            ans = ans + numbers.get(k / fact);\\n            numbers.remove(k / fact);\\n            if (numbers.size() == 0) {\\n                break;\\n            }\\n\\n            k = k % fact;\\n            fact = fact / numbers.size();\\n        }\\n        return ans;\\n    }\\n}\\nT.C:- n(for placing n numbers in n positions) * n(for every number we are reducingthe search space by removing one element, 1234-->124-->12-->1)\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n1. First Approach\\n//generate all permutation for 1 to n\\n//store all permutation in some data structure\\n//return kth term from data structure\\n\\n//Example :- n=3 , k=4\\n//Generate permutations(LeetCode Qus. 46 :- Permutations) 1 to 3 i.e. \\n123\\n132\\n213\\n231\\n312\\n321\\n//k=4th term is 231\\n//our ans will be 231\\n\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int num[] = new int[n];\\n        for(int i=0; i<n; i++)\\n        {\\n            num[i] = i+1;\\n        }\\n        List<String> Tans = new ArrayList<>();\\n        help(0,num,n,k,Tans);\\n        Collections.sort(Tans);\\n        return Tans.get(k-1);\\n    }\\n    void help(int index, int[] num, int n, int k, List<String> Tans)\\n    {\\n        \\n        if(index==num.length){\\n            StringBuffer store = new StringBuffer();\\n            for(int i=0; i<n; i++)\\n            {\\n                store.append(num[i]);\\n            }\\n            Tans.add(store.toString());\\n            return;\\n        }\\n        \\n        for(int i=index; i<n; i++)\\n        {\\n            swap(i,index,num);\\n            help(index+1,num,n,k,Tans);\\n            swap(i,index,num);\\n        }\\n    }\\n    void swap(int i, int j, int[] num)\\n    {\\n        int temp = num[i];\\n        num[i] = num[j];\\n        num[j] = temp;\\n    }\\n //T.C :- n!(for generating permutation) * n(for looping i=0 to nums.length) * n!logn(for sorting n! permutation)\\n}\\n\\n2. Optimal Approach :- using Mathematics\\n//Example :- n=4 ,k=17\\n                                 /////////STEP 1\\n//We can have our permutation starting with either 1 or 2 or 3 or 4.\\n//If first position is occupied by one number then there are three more positions left.\\n//Then remaining three numbers can be permuted among themselves 3! = 6 sequences.\\n\\n//if we consider sequences as 0-based index in sorted form              \\n0th block  |0th \\u2013 5th permutation will start with 1   | {2,3,4} i.e. 0th{1,2,3,4}, 1st{1,2,4,3}, 2nd{1,3,2,4}, 3rd{1,3,4,2}, 4th{1,4,2,3}, 5th{1,4,3,2}\\n1st block  |6th \\u2013 11th permutation will start with 2  | {1,3,4} i.e. 6th{2,1,3,4}, 7th{2,1,4,3}, 8th{2,3,1,4}, 9th{2,3,4,1}, 10th{2,4,1,3}, 11th{2,4,3,1}\\n2nd block  |12th \\u2013 17th permutation will start with 3 | {1,2,4} i.e. 12th{3,1,2,4}, 13th{3,1,4,2}, 14th{3,2,1,4}, 15th{3,2,4,1}, 16th{3,4,1,2}, 17th{3,4,2,1}\\n3rd block  |18th \\u2013 23rd permutation will start with 4 | {1,2,3} i.e. 18th{4,1,2,3}, 19th{4,1,3,2}, 20th{4,2,1,3}, 21st{4,2,3,1}, 22nd{4,3,1,2}, 23rd{4,3,2,1}\\n\\n//make K = 17-1 considering 0-based indexing\\n//Since each of the four blocks illustrated above comprises 6 permutations, therefore the 16th permutation will lie in (16 / 6 ) = 2nd block i.e. 3 ans={3---}\\n/and our answer is the (16 % 6) = 4th sequence from the 2nd block.\\n    \\n                                  //////////STEP 2\\n  //Our new search space comprises three elements {1,2,4} where K = 4 \\n  //If first position is occupied by one number then there are two more positions left.\\n  //Then remaining two numbers can be permuted among themselves 2! = 2 sequences.\\n\\n0th block  |0th \\u2013 1st sequence starts with 1 | {2,4} \\n1st block  |2nd \\u2013 3rd sequence starts with 2 | {1,4}\\n2nd block  |4th \\u2013 5th sequence starts with 4 | {1,2}\\n\\n//(4/2) = 2nd block i.e 4   ans={34--}\\n//4%2 = 0th sequence from 2nd block\\n\\n                                     /////////STEP 3\\n        //Our new search space comprises three elements {1,2} where K = 0\\n        //If first position is occupied by one number then there are one more positions left.\\n        //Then remaining one numbers can be permuted among themselves 1! = 1 sequences.\\n0th block |0th sequence starts with 1  | {2} \\n1st block |1st sequence. starts with 2 | {1}\\n\\n//(0/1) = 0th block i.e. ans={341}\\n//0%1 = 0th sequence from 0th block\\n\\n                                   /////////STEP 4\\n//only 2 is remaining \\nans = {3412}\\n\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int fact = 1;\\n        ArrayList < Integer > numbers = new ArrayList < > ();\\n        for (int i = 1; i < n; i++) {\\n            fact = fact * i;\\n            numbers.add(i);\\n        }\\n        numbers.add(n);\\n        String ans = \"\";\\n        k = k - 1;\\n        while (true) {\\n            ans = ans + numbers.get(k / fact);\\n            numbers.remove(k / fact);\\n            if (numbers.size() == 0) {\\n                break;\\n            }\\n\\n            k = k % fact;\\n            fact = fact / numbers.size();\\n        }\\n        return ans;\\n    }\\n}\\nT.C:- n(for placing n numbers in n positions) * n(for every number we are reducingthe search space by removing one element, 1234-->124-->12-->1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2557729,
                "title": "java-solution-with-complete-explanation",
                "content": "\\n**Solution 1: Brute Force Solution**\\n\\n**Approach:**  \\n\\nThe extreme naive solution is to generate all the possible permutations of the given sequence.  This is achieved using recursion and every permutation generated is stored in some other data structure (here we have used a vector). Finally, we sort the data structure in which we have stored all the sequences and return the Kth sequence from it.\\n\\n```\\nimport java.util.*;\\npublic class Main {\\n    static void swap(char s[], int i, int j) {\\n        char ch = s[i];\\n        s[i] = s[j];\\n        s[j] = ch;\\n    }\\n    static void permutationHelper(char s[], int index, ArrayList < String > res) {\\n        if (index == s.length) {\\n            String str = new String(s);\\n\\n            res.add(str);\\n            return;\\n        }\\n        for (int i = index; i < s.length; i++) {\\n            swap(s, i, index);\\n            permutationHelper(s, index + 1, res);\\n            swap(s, i, index);\\n        }\\n    }\\n\\n    static String getPermutation(int n, int k) {\\n        String s = \"\";\\n        ArrayList < String > res = new ArrayList < > ();\\n        for (int i = 1; i <= n; i++) {\\n            s += i;\\n        }\\n        permutationHelper(s.toCharArray(), 0, res);\\n        Collections.sort(res);\\n\\n        return res.get(k);\\n\\n    }\\n    public static void main(String args[]) {\\n        int n = 3, k = 3;\\n        String ans = getPermutation(n, k);\\n        System.out.println(\"The Kth permutation sequence is \" + ans);\\n    }\\n}\\n```\\n\\n**Output:**\\n\\nThe Kth permutation sequence is 213\\n\\n**Time complexity: O(N! * N) +O(N! Log N!)**\\n\\n**Reason**:  The recursion takes O(N!)  time because we generate every possible permutation and another O(N)  time is required to make a deep copy and store every sequence in the data structure. Also, O(N! Log N!)  time required to sort the data structure\\n\\n**Space complexity: O(N) **\\n\\n*Reason: Result stored in a vector, we are auxiliary space taken by recursion*\\n\\n**Solution 2: (Optimal Approach)**\\n\\nSay we have N = 4  and K = 17. Hence the number sequence is {1,2,3,4}. \\n\\n**Intuition -**\\n\\nI am following 0 - indexing so if K = 17, i.e., the answer is 16th permutation.\\nStore n numbers in a list -> [1, 2, 3, 4]\\nSince this is a permutation we can assume that there are four positions that need to be filled using the four numbers of the sequence. \\nFirst, we need to decide which number is to be placed at the first index. Once the number at the first index is decided we have three more positions and three more numbers.  Now the problem is shorter\\nWe can repeat the technique that was used previously until all the positions are filled.\\n\\n**Approach:** \\n\\n**STEP 1**:\\n\\nMathematically speaking there can be 4 variations while generating the permutation. We can have our permutation starting with either 1 or 2 or 3 or 4. If the first position is already occupied by one number there are three more positions left. The remaining three numbers can be permuted among themselves while filling the 3 positions and will generate 3! = 6 sequences. Hence each block will have 6 permutations adding up to a total of 6*4 = 24 permutations. If we consider the sequences as 0-based and in the sorted form we observe:- \\n\\nThe 0th \\u2013 5th permutation will start with 1 \\nThe 6th \\u2013 11th permutation will start with 2\\nThe 12th \\u2013 17th permutation will start with 3 \\nThe 18th \\u2013 23rd permutation will start with 4.\\n (For better understanding refer to the picture below.) \\n\\n![image](https://assets.leetcode.com/users/images/35d54383-2d3f-42a6-82bf-f38511ab8c31_1662819193.3723998.png)\\n\\n\\nWe make K = 17-1 considering 0-based indexing. Since each of the four blocks illustrated above comprises 6 permutations, therefore, the 16th permutation will lie in (16 / 6 ) = 2nd block, and our answer is the (16 % 6) = 4th sequence from the 2nd block. Therefore 3 occupies the first position of the sequence and K = 4.\\n\\n\\n\\n**STEP 2:**\\n\\nOur new search space comprises three elements {1,2,4} where K = 4 . Using the previous technique we can consider the second position to be occupied can be any one of these 3 numbers. Again one block can start with 1, another can start with 2 and the last one can start with 4 . Since one position is fixed, the remaining two numbers of each block can form 2! = 2  sequences. In sorted order :\\n\\nThe 0th \\u2013 1st sequence starts with 1 \\nThe 2nd \\u2013 3rd sequence starts with 2 \\nThe 4th \\u2013 5th sequence starts with 4\\n[![image](https://assets.leetcode.com/users/images/7f02a0f1-1adc-48ba-ac37-364bdc169b25_1662819176.872596.png)\\n](http://)\\n\\nThe 4th permutation will lie in (4/2) = 2nd block and our answer is the 4%2 = 0th sequence from the 2nd block. Therefore 4 occupies the second position and K = 0.\\n\\n\\n\\n**STEP 3:**\\n\\nThe new search space will have two elements {1 ,2} and K = 0. One block starts with 1 and the other block starts with 2. The other remaining number can form only one 1! = 1 sequence. In sorted form \\u2013\\n\\nThe  0th sequence starts with 1 \\nThe  1st sequence. starts with 2\\n\\n\\nThe 0th permutation will lie in the (0/1) = 0th block and our answer is the 0%1 = 0th sequence from the 0th block. Therefore 1 occupies the 3rd position and K = 0.\\n[![image](https://assets.leetcode.com/users/images/3fb9e3ce-cae1-43b7-9280-4ae73933cdaa_1662819149.794847.png)\\n](http://)\\n\\n\\n**STEP 4**: \\n\\nNow the only block has 2 in the first position and no remaining number is present.\\n\\n[![image](https://assets.leetcode.com/users/images/735de33d-78fc-4ec9-86ac-d19b026cffa5_1662819077.3672447.png)\\n](http://)\\nThis is the point where we place 2 in the last position and stop.\\n\\n\\nThe final answer is \"3412\".\\n\\n**Code-**\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n\\t    k = k - 1; // following 0 indexing if k = 3 it means 2nd permutation is the ans\\n        String ans = \"\";\\n        // create a list to store all the numbers till n\\n        List<Integer> list = new ArrayList<>();\\n        int fact = 1; \\n        for(int i = 1; i <= n-1; i++) {\\n            fact = fact * i;\\n            list.add(i);  // this will store numbers from 1 to n-1\\n        }\\n        list.add(n); // add n to list\\n       // running an infinte loop\\n        while (true) {\\n            ans = ans + list.get (k / fact);\\n            list.remove (k / fact);\\n            if (list.size() == 0) {\\n                break;\\n            }\\n            k = k % fact;\\n            fact = fact / list.size();\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**Time Complexity: O(N) * O(N) = O(N^2)**\\n\\nReason: We are placing N numbers in N positions. This will take O(N) time. For every number, we are reducing the search space by removing the element already placed in the previous step. This takes another O(N) time.\\n\\n**Space Complexity: O(N) **\\n\\nReason: We are storing  the numbers in a data structure(here vector)\\n\\n**Do Upvote :)**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\npublic class Main {\\n    static void swap(char s[], int i, int j) {\\n        char ch = s[i];\\n        s[i] = s[j];\\n        s[j] = ch;\\n    }\\n    static void permutationHelper(char s[], int index, ArrayList < String > res) {\\n        if (index == s.length) {\\n            String str = new String(s);\\n\\n            res.add(str);\\n            return;\\n        }\\n        for (int i = index; i < s.length; i++) {\\n            swap(s, i, index);\\n            permutationHelper(s, index + 1, res);\\n            swap(s, i, index);\\n        }\\n    }\\n\\n    static String getPermutation(int n, int k) {\\n        String s = \"\";\\n        ArrayList < String > res = new ArrayList < > ();\\n        for (int i = 1; i <= n; i++) {\\n            s += i;\\n        }\\n        permutationHelper(s.toCharArray(), 0, res);\\n        Collections.sort(res);\\n\\n        return res.get(k);\\n\\n    }\\n    public static void main(String args[]) {\\n        int n = 3, k = 3;\\n        String ans = getPermutation(n, k);\\n        System.out.println(\"The Kth permutation sequence is \" + ans);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n\\t    k = k - 1; // following 0 indexing if k = 3 it means 2nd permutation is the ans\\n        String ans = \"\";\\n        // create a list to store all the numbers till n\\n        List<Integer> list = new ArrayList<>();\\n        int fact = 1; \\n        for(int i = 1; i <= n-1; i++) {\\n            fact = fact * i;\\n            list.add(i);  // this will store numbers from 1 to n-1\\n        }\\n        list.add(n); // add n to list\\n       // running an infinte loop\\n        while (true) {\\n            ans = ans + list.get (k / fact);\\n            list.remove (k / fact);\\n            if (list.size() == 0) {\\n                break;\\n            }\\n            k = k % fact;\\n            fact = fact / list.size();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 191348,
                "title": "c-0ms-100-with-algorithm-explanation",
                "content": "as we know \n    4! = 24 = 4*(3!) \nthat means the first layer looks like\n   '1'[][][],'2'[][][],'3'[][][],'4'[][][]\n then we can search which position number 9 will be at this layer:\n    position = 9/3! = 1.5 \n and we know  the first number position will be [1.5] = 2, which represent '2'[][][],we know the first number is '2'\n    the remainder is 9%3! = 3\n then we use this number enter next layer:\n    '1'[][],'3'[][],'4'[][]\n     position = 3/2! = 1.5\n     [1.5] = 2 which represent '3'[][], we know the second number is '3'\n......\n    repeat until we get remainder 0, that means we need to take Maximum arrangement in this layer.\nso reverse and append to result.\nsorry my english is pool\n![image](https://assets.leetcode.com/users/somone23412/image_1541753944.png)\n```\nclass Solution {\npublic:\n    string getPermutation(int n, int k) {\n        int d = n-1;\n        int t = k;\n        list<char> nums;\n        string result = \"\";\n        for(int i = 1; i <= n; i++){\n            nums.push_back(i+48);\n        }\n        while(t!=0){\n            int jd = jiecheng(d);\n            int position = ceil((double)t/jd);\n            auto it = nums.begin();\n            for(int i = 0; i< position-1 && it != nums.end(); i++, it++);\n            result += *it;\n            nums.remove(*it);\n            //cout<<t<<\" \"<<jd<<\" \"<<position<<\" \"<<t<<endl;\n            t = t%jd; \n            d--;\n        }\n        nums.reverse();\n        for(auto it = nums.begin(); it != nums.end(); it++){\n            result += *it;\n        }\n        return result;\n    }\n    int jiecheng(int n){\n        if(n == 0)return 1;\n        int sum = n;\n        while(--n > 0) sum*=n;\n        return sum;\n    }\n};\n```\n",
                "solutionTags": [],
                "code": "```\nclass Solution {\npublic:\n    string getPermutation(int n, int k) {\n        int d = n-1;\n        int t = k;\n        list<char> nums;\n        string result = \"\";\n        for(int i = 1; i <= n; i++){\n            nums.push_back(i+48);\n        }\n        while(t!=0){\n            int jd = jiecheng(d);\n            int position = ceil((double)t/jd);\n            auto it = nums.begin();\n            for(int i = 0; i< position-1 && it != nums.end(); i++, it++);\n            result += *it;\n            nums.remove(*it);\n            //cout<<t<<\" \"<<jd<<\" \"<<position<<\" \"<<t<<endl;\n            t = t%jd; \n            d--;\n        }\n        nums.reverse();\n        for(auto it = nums.begin(); it != nums.end(); it++){\n            result += *it;\n        }\n        return result;\n    }\n    int jiecheng(int n){\n        if(n == 0)return 1;\n        int sum = n;\n        while(--n > 0) sum*=n;\n        return sum;\n    }\n};\n```",
                "codeTag": "C++"
            },
            {
                "id": 696782,
                "title": "python3-solution-explained-with-a-tip-for-faster-execution-beats-99-8",
                "content": "My solution is basically the same with the many others but here is another explanation:\\n\\nLet\\'s go over an example:\\n```\\nn=4  k=9\\n1234 ------ start here\\n1243 ------ third digit changes here \\n1324 ------ second digit changes here \\n1342\\n1423\\n1432 \\n2134 ------ first digit changes here \\n2143\\n2314 -> k=9\\n2341\\n2413\\n2431\\n3124 ------ first digit changes here \\n.\\n.\\n.\\n```\\nAs you can see first digit changes after 6 occurances which is (n-1)! and the second digit changes after 2 occurances  which is (n-2)!. Similarly third digit changes after 1 occurances which is (n-3)!. Is this a coincidance? Of course not. Since it is a permutation we compute it like this:\\n```(n)(n-1)(n-2)...(1)```  each paranthesis represents a digit. for the first place, we have n options. After using one of the numbers, we cannot use it again. So we have n-1 number options for the second place. In the end we multiply them to get the total number of permutations. Let\\'s say we picked \\'1\\' for the first place. now we have (n-1)! options for the rest of the number. This is why at each step a number is repeated that many time. \\n\\nLet\\'s go back to our example:\\n\\nSince the first digit is repeated (n-1)! times, by dividing the k by n we can find our first digit. Division must be integer division because we are only interested in the integer part.\\n``` \\nk=9, n=4\\n(n-1)! = 6\\nk /(n-1)!  = 1\\nremainder = 3\\n```\\nNumbers that we can use as digits are = ```[1,2,...,n]```\\n\\nSo, our first digit is the digit at index 1 which is ```2```. We take the digit at 1 because our list is sorted so we are sure that the second smallest digit is at index 1.\\n\\nSince we used ```2```, we need to remove it from our list and k takes the value of the remainder. You can think of lit ike this: we decided on our first digit so we can discard that part and deal with the rest of the number. As you can see the problem is the same! but this time we have (n-2)! instead of (n-1)!, k=remainder and we have one less number in our list. \\n\\n\\n\\nHere is my code:\\n```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        factor = factorial(n-1)\\n        k -= 1 # index starts from 1 in the question but our list indexs starts from 0\\n        ans = []\\n        numbers_left = list(range(1,n+1))\\n        \\n        for m in range(n-1,0,-1):\\n            index = int(k // factor)\\n            ans += str(numbers_left[index])\\n            numbers_left.pop(index)\\n            k %= factor\\n            factor /= m\\n            \\n        ans += str(numbers_left[0])\\n        return \\'\\'.join(ans)\\n```\\n\\n**Tips:**\\n*  Don\\'t make ```ans``` a string because strings are not modified in place. It creates another copy of the string which makes your code slower. Instead of string, use a list which is pretty easy to append at the end, and then concatenate them in the end with join function.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nn=4  k=9\\n1234 ------ start here\\n1243 ------ third digit changes here \\n1324 ------ second digit changes here \\n1342\\n1423\\n1432 \\n2134 ------ first digit changes here \\n2143\\n2314 -> k=9\\n2341\\n2413\\n2431\\n3124 ------ first digit changes here \\n.\\n.\\n.\\n```\n```(n)(n-1)(n-2)...(1)```\n``` \\nk=9, n=4\\n(n-1)! = 6\\nk /(n-1)!  = 1\\nremainder = 3\\n```\n```[1,2,...,n]```\n```2```\n```2```\n```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        factor = factorial(n-1)\\n        k -= 1 # index starts from 1 in the question but our list indexs starts from 0\\n        ans = []\\n        numbers_left = list(range(1,n+1))\\n        \\n        for m in range(n-1,0,-1):\\n            index = int(k // factor)\\n            ans += str(numbers_left[index])\\n            numbers_left.pop(index)\\n            k %= factor\\n            factor /= m\\n            \\n        ans += str(numbers_left[0])\\n        return \\'\\'.join(ans)\\n```\n```ans```",
                "codeTag": "Java"
            },
            {
                "id": 1309839,
                "title": "editorial-easy-explanation",
                "content": "# ****using some maths\\n**for ex: you have n = 4\\nthen there will be 4! permutations and k=17\\nthen if we are using 0 based index then we have to find 16th index\\nNow as it is lexicographically sorted\\nthen first digit 1 , other digits {2,3,4} permutations then\\nfirst digit 2 , other digits {1,3,4} perm then\\nfirst digit 3 , other digits{1,2,4}+ {}\\nfirst digit 4 , other digits{1,2,3}**\\n**Now for {1,3,4} there will be 3! = 6 perm\\nand so on for other 3\\nso if we have to find 16 it will start from 3 as 0-5 start from 1\\n6-11 start from 2  12-17 start from 3 and 18-23 from 4\\nNow as we fixed first place as 3,___,___,___\\nWe will  find second place digit which will be \\n1 {2,4} perms + 2{1,4} perms + 4{1,2} perms\\nNow {2,4} will be 2! perms i.e 2 so first two will start from 1 next two from 2 and last two from 4 we have to find  16-12 ->4th term  which will start from 4 because 0based indexing(0,1,2,3,4)\\nso Now 3,4,___,____ two digits left to find \\n1{2} and 2{1} NOw 12 + 4 16 gone 17th term is 1{2} \\nso 3,4,1,2\\nSimple formula if n=4 start from 3! ,2!,1!\\n                    k=17 first index will be k/3!\\n\\t\\t\\t\\t\\tand next k will be k%3!\\n\\t\\t\\t\\t\\tNow you can see from code you will understand it easily:**\\n\\n\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        int fact=1;\\n        for(int i=1;i<n;i++){\\n            fact=fact*i;\\n            arr.add(i);\\n        }\\n        arr.add(n);\\n        k=k-1;\\n        String ans=\"\";\\n        while(true){\\n            int i1 = k/fact;\\n            int i2 = k%fact;\\n            ans+=arr.get(i1);\\n            arr.remove(i1);\\n            k=i2;\\n            if(arr.size()==0){\\n                break;\\n            }\\n            fact=fact/arr.size();\\n        }\\n        return ans;\\n    }\\n}\\n```\\n# ****Do upvote!!\\n",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        int fact=1;\\n        for(int i=1;i<n;i++){\\n            fact=fact*i;\\n            arr.add(i);\\n        }\\n        arr.add(n);\\n        k=k-1;\\n        String ans=\"\";\\n        while(true){\\n            int i1 = k/fact;\\n            int i2 = k%fact;\\n            ans+=arr.get(i1);\\n            arr.remove(i1);\\n            k=i2;\\n            if(arr.size()==0){\\n                break;\\n            }\\n            fact=fact/arr.size();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22518,
                "title": "c-backtracking-stl-math-solutions",
                "content": "**Solution 1.** Backtracking\\n\\nRun Time: 266ms\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\", res = \"\";\\n        for(int i = 1; i <= n; i++) s.push_back(i + '0');\\n        string path = s;\\n        int count = 0;\\n        DFS(s, 0, count, n, k, path, res);\\n        return res;\\n    }\\n    \\n    void DFS(string& s, int pos, int& count, int n, int k, string& path, string& res){\\n        if(count >= k || pos == n){\\n            if(++count == k) res = path;\\n            return;\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == '0') continue;\\n            path[pos] = s[i];\\n            s[i] = '0';\\n            DFS(s, pos + 1, count, n, k, path, res);\\n            s[i] = path[pos];\\n        }\\n    }\\n};\\n```\\n***\\n**Solution 2.** Using STL\\n\\nRun Time: 119ms\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\";\\n        for(int i = 1; i <= n; i++) s.push_back(i + '0');\\n        while(--k) next_permutation(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```\\n***\\n**Solution 3.** Math. C++ version of this [thread](https://discuss.leetcode.com/topic/17348/explain-like-i-m-five-java-solution-in-o-n)\\n\\nRun Time: 3ms\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\", res = \"\";\\n        vector<int>factorial(n + 1, 1);\\n        int sum = 1;\\n        for(int i = 1; i <= n; i++){\\n            s.push_back(i + '0');\\n            sum *= i;\\n            factorial[i] = sum;\\n        }\\n        k--;\\n        for(int i = 1; i <= n; i++){\\n            int index = k / factorial[n - i];\\n            res.push_back(s[index]);\\n            s.erase(s.begin() + index);\\n            k %= factorial[n - i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\", res = \"\";\\n        for(int i = 1; i <= n; i++) s.push_back(i + '0');\\n        string path = s;\\n        int count = 0;\\n        DFS(s, 0, count, n, k, path, res);\\n        return res;\\n    }\\n    \\n    void DFS(string& s, int pos, int& count, int n, int k, string& path, string& res){\\n        if(count >= k || pos == n){\\n            if(++count == k) res = path;\\n            return;\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == '0') continue;\\n            path[pos] = s[i];\\n            s[i] = '0';\\n            DFS(s, pos + 1, count, n, k, path, res);\\n            s[i] = path[pos];\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\";\\n        for(int i = 1; i <= n; i++) s.push_back(i + '0');\\n        while(--k) next_permutation(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\", res = \"\";\\n        vector<int>factorial(n + 1, 1);\\n        int sum = 1;\\n        for(int i = 1; i <= n; i++){\\n            s.push_back(i + '0');\\n            sum *= i;\\n            factorial[i] = sum;\\n        }\\n        k--;\\n        for(int i = 1; i <= n; i++){\\n            int index = k / factorial[n - i];\\n            res.push_back(s[index]);\\n            s.erase(s.begin() + index);\\n            k %= factorial[n - i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761329,
                "title": "c-hinglish-easy-explanation-recursion-interview-prep",
                "content": "# Approach\\n- Explained properly in the code\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n       \\t//Logics\\n\\n       \\t//Naive Solution\\n       \\t//1. Maanlo 1,2,3,4 diya hain to ek tareeka to apna tha ki saare permutations nikal lenge like (Permutations 2) then we will find the K the one.\\n       \\t//2. But it is very naive solution so we will look for some optimal solution.\\n\\n       \\t//Optimal Solution\\n       \\t//1. Agar ham dhyan se dekhe to hame ek pattern dikhayi dega.\\n       \\t//2. For some range in permuations the position of the numbers are fixed.\\n       \\t//3. So with this pattern we can start from the first index all the way to last index.\\n       \\t//4. Kth sequence pe pata lagayenge ki 1st index pe kya tha, Fir wo num ab use ho gaya to aage use nahin hoga to use erase kar diya.\\n       \\t//5. Yeh saari ranges ke ham blockSize banayenge aur un blockSize mein k ki subpositioning hoti rahegi.\\n       \\t//6. Jab tak K=0 nahin ho jata tab tak yeh sub positioning chalti rahegi.\\n        //7. blockSize = (n-1)!\\n       \\t//8. Num ki position for some index numbers[k/blockSize] and k = k%blockSize(subpositioning in the bloc), fir num jo use ho gaya use remove karenge to blockSize =(num-2)! use karenge aage.\\n       \\t//blockSize bhi change hoga as the numbers are being removed.\\n       \\t//9.Isi process se ham all the 4 indexes bhar lenge.\\n\\n       \\t//EXAMPLE: 1,2,3,4, k=17\\n        string getPermutation(int n, int k)\\n        {\\n            string ans = \"\";\\n            vector<int> numbers;\\n           \\t//1-n tak saare numbers store karlenge\\n            int fact = 1;\\n           \\t//This is the factorial\\n            for (int i = 1; i <= n; i++)\\n            {\\n                fact = fact * i;\\t//4!=24\\n                numbers.push_back(i);\\n            }\\n           \\t//Now the value of fact is the number of permutations or total ranges.\\n           \\t//Now these ranges can be divided in blocks of blockSizes\\n            int blockSize = fact / n;\\t//blockSize = 24/4 = 6 size ke 4 blocks\\n            k = k - 1;\\t//For 0 based indexing//16\\n            while (true)\\n            {\\n                ans += to_string(numbers[k / blockSize]);\\t\\n                //3,_,_,_\\n                //3,4,_,_\\n                //3,4,1,_\\n                //3,4,1,2\\n               \\t//Index by index answers mein push karenge\\n                numbers.erase(numbers.begin() + k / blockSize);\\n               \\t//Jo index use ho gayi use remove kar denge\\n                if (numbers.size() == 0)\\n               \\t//Agar koi index use karne ko hain hi nahin\\n                {\\n                    break;\\n                }\\n                k = k % blockSize;\\t//16->4->0\\n               \\t//K is repositioned for remaining numbers \\n                blockSize = blockSize / numbers.size();\\t//6->2->1\\n               \\t//Blocks are also changed according to remaining numbers\\n            }\\n            return ans;\\n        }\\n};\\n```\\n# Complexity\\n- Time complexity: $O(n^2)$ `n for placing them in n positions` and another `n for removing from vector`.\\n\\n- Space complexity: $O(n)$ just a `vector`.\\n\\nIf you *like* \\uD83D\\uDC4D this solution do *upvote* \\u2B06\\uFE0F and if there is any *improvement or suggestion* do mention it in the *comment* section \\uD83D\\uDE0A.\\n\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/1b604300-df68-46aa-a267-71f38463bb89_1684820402.7869222.jpeg\" width=\\'350\\' alt=\"Upvote Image\">\\n</p>",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n       \\t//Logics\\n\\n       \\t//Naive Solution\\n       \\t//1. Maanlo 1,2,3,4 diya hain to ek tareeka to apna tha ki saare permutations nikal lenge like (Permutations 2) then we will find the K the one.\\n       \\t//2. But it is very naive solution so we will look for some optimal solution.\\n\\n       \\t//Optimal Solution\\n       \\t//1. Agar ham dhyan se dekhe to hame ek pattern dikhayi dega.\\n       \\t//2. For some range in permuations the position of the numbers are fixed.\\n       \\t//3. So with this pattern we can start from the first index all the way to last index.\\n       \\t//4. Kth sequence pe pata lagayenge ki 1st index pe kya tha, Fir wo num ab use ho gaya to aage use nahin hoga to use erase kar diya.\\n       \\t//5. Yeh saari ranges ke ham blockSize banayenge aur un blockSize mein k ki subpositioning hoti rahegi.\\n       \\t//6. Jab tak K=0 nahin ho jata tab tak yeh sub positioning chalti rahegi.\\n        //7. blockSize = (n-1)!\\n       \\t//8. Num ki position for some index numbers[k/blockSize] and k = k%blockSize(subpositioning in the bloc), fir num jo use ho gaya use remove karenge to blockSize =(num-2)! use karenge aage.\\n       \\t//blockSize bhi change hoga as the numbers are being removed.\\n       \\t//9.Isi process se ham all the 4 indexes bhar lenge.\\n\\n       \\t//EXAMPLE: 1,2,3,4, k=17\\n        string getPermutation(int n, int k)\\n        {\\n            string ans = \"\";\\n            vector<int> numbers;\\n           \\t//1-n tak saare numbers store karlenge\\n            int fact = 1;\\n           \\t//This is the factorial\\n            for (int i = 1; i <= n; i++)\\n            {\\n                fact = fact * i;\\t//4!=24\\n                numbers.push_back(i);\\n            }\\n           \\t//Now the value of fact is the number of permutations or total ranges.\\n           \\t//Now these ranges can be divided in blocks of blockSizes\\n            int blockSize = fact / n;\\t//blockSize = 24/4 = 6 size ke 4 blocks\\n            k = k - 1;\\t//For 0 based indexing//16\\n            while (true)\\n            {\\n                ans += to_string(numbers[k / blockSize]);\\t\\n                //3,_,_,_\\n                //3,4,_,_\\n                //3,4,1,_\\n                //3,4,1,2\\n               \\t//Index by index answers mein push karenge\\n                numbers.erase(numbers.begin() + k / blockSize);\\n               \\t//Jo index use ho gayi use remove kar denge\\n                if (numbers.size() == 0)\\n               \\t//Agar koi index use karne ko hain hi nahin\\n                {\\n                    break;\\n                }\\n                k = k % blockSize;\\t//16->4->0\\n               \\t//K is repositioned for remaining numbers \\n                blockSize = blockSize / numbers.size();\\t//6->2->1\\n               \\t//Blocks are also changed according to remaining numbers\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22659,
                "title": "python-concise-solution",
                "content": "    \\n    # TLE\\n    def getPermutation(self, n, k):\\n        nums = range(1, n+1)\\n        for i in xrange(k-1):\\n            self.nextPermutation(nums)\\n        return \"\".join(map(str, nums))\\n            \\n    def nextPermutation(self, nums):\\n        l = d = m = len(nums)-1\\n        while l > 0 and nums[l] <= nums[l-1]:\\n            l -= 1\\n        if l == 0:\\n            nums.reverse()\\n            return \\n        k = l-1\\n        while nums[k] >= nums[d]:\\n            d -= 1\\n        nums[k], nums[d] = nums[d], nums[k]\\n        while l < m:\\n            nums[l], nums[m] = nums[m], nums[l]\\n            l += 1; m -= 1\\n    \\n    # AC\\n    def getPermutation(self, n, k):\\n        res, nums = \"\",  range(1, n+1)\\n        k -= 1\\n        while n:\\n            n -= 1\\n            index, k = divmod(k, math.factorial(n))\\n            res += str(nums.pop(index))\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "    \\n    # TLE\\n    def getPermutation(self, n, k):\\n        nums = range(1, n+1)\\n        for i in xrange(k-1):\\n            self.nextPermutation(nums)\\n        return \"\".join(map(str, nums))\\n            \\n    def nextPermutation(self, nums):\\n        l = d = m = len(nums)-1\\n        while l > 0 and nums[l] <= nums[l-1]:\\n            l -= 1\\n        if l == 0:\\n            nums.reverse()\\n            return \\n        k = l-1\\n        while nums[k] >= nums[d]:\\n            d -= 1\\n        nums[k], nums[d] = nums[d], nums[k]\\n        while l < m:\\n            nums[l], nums[m] = nums[m], nums[l]\\n            l += 1; m -= 1\\n    \\n    # AC\\n    def getPermutation(self, n, k):\\n        res, nums = \"\",  range(1, n+1)\\n        k -= 1\\n        while n:\\n            n -= 1\\n            index, k = divmod(k, math.factorial(n))\\n            res += str(nums.pop(index))\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 1738840,
                "title": "solution-swift-permutation-sequence-test-cases",
                "content": "```swift\\nclass Solution {\\n    func getPermutation(_ n: Int, _ k: Int) -> String {\\n        var numbers = [Int](1...n)\\n        var k = k, factorial = 1, diff = n - 1, result = \"\"\\n        \\n        for i in 1..<n { factorial *= i }\\n        \\n        for _ in 0..<n {\\n            for (i, num) in numbers.enumerated() {\\n                if k > factorial {\\n                    k -= factorial\\n                } else {\\n                    result += String(num)\\n                    numbers.remove(at: i)\\n                    break\\n                }\\n            }\\n            if diff > 1 {\\n                factorial /= diff\\n                diff -= 1\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 3 tests, with 0 failures (0 unexpected) in 0.012 (0.014) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.getPermutation(3, 3)\\n        XCTAssertEqual(value, \"213\")\\n    }\\n    \\n    func test1() {\\n        let value = solution.getPermutation(4, 9)\\n        XCTAssertEqual(value, \"2314\")\\n    }\\n    \\n    func test2() {\\n        let value = solution.getPermutation(3, 1)\\n        XCTAssertEqual(value, \"123\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func getPermutation(_ n: Int, _ k: Int) -> String {\\n        var numbers = [Int](1...n)\\n        var k = k, factorial = 1, diff = n - 1, result = \"\"\\n        \\n        for i in 1..<n { factorial *= i }\\n        \\n        for _ in 0..<n {\\n            for (i, num) in numbers.enumerated() {\\n                if k > factorial {\\n                    k -= factorial\\n                } else {\\n                    result += String(num)\\n                    numbers.remove(at: i)\\n                    break\\n                }\\n            }\\n            if diff > 1 {\\n                factorial /= diff\\n                diff -= 1\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.getPermutation(3, 3)\\n        XCTAssertEqual(value, \"213\")\\n    }\\n    \\n    func test1() {\\n        let value = solution.getPermutation(4, 9)\\n        XCTAssertEqual(value, \"2314\")\\n    }\\n    \\n    func test2() {\\n        let value = solution.getPermutation(3, 1)\\n        XCTAssertEqual(value, \"123\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912564,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func getPermutation(_ n: Int, _ k: Int) -> String {\\n        var digitals: [Int] = []\\n        var res: String = \"\"\\n        var val = k\\n        var m = n\\n\\n        for i in 1...n { digitals.append(i) }\\n\\n        while res.count < n && val > 0 {\\n            let i = Int(ceil(Double(val) / Double(permutation(m - 1))))\\n            res += \"\\\\(digitals[i-1])\"\\n            print(i, digitals)\\n            digitals.remove(at: i - 1)\\n            val -= (i - 1) * permutation(m - 1)\\n            m -= 1\\n        }\\n        return res\\n    }\\n\\n\\n    func permutation(_ n: Int) -> Int {\\n        guard n > 1 else { return 1 }\\n        var res = 1\\n        for i in 1...n { res *= i }\\n        return res\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func getPermutation(_ n: Int, _ k: Int) -> String {\\n        var digitals: [Int] = []\\n        var res: String = \"\"\\n        var val = k\\n        var m = n\\n\\n        for i in 1...n { digitals.append(i) }\\n\\n        while res.count < n && val > 0 {\\n            let i = Int(ceil(Double(val) / Double(permutation(m - 1))))\\n            res += \"\\\\(digitals[i-1])\"\\n            print(i, digitals)\\n            digitals.remove(at: i - 1)\\n            val -= (i - 1) * permutation(m - 1)\\n            m -= 1\\n        }\\n        return res\\n    }\\n\\n\\n    func permutation(_ n: Int) -> Int {\\n        guard n > 1 else { return 1 }\\n        var res = 1\\n        for i in 1...n { res *= i }\\n        return res\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696542,
                "title": "c-easy-with-next-permutation",
                "content": "```\\n// Please, Upvote :-)\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\";\\n        for (int i = 1; i <= n; i++)\\n            s += to_string(i);\\n        int curPerm = 1;\\n        while (curPerm < k) {\\n            curPerm++;\\n            next_permutation(s.begin(), s.end());\\n        }\\n        return s;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Please, Upvote :-)\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\";\\n        for (int i = 1; i <= n; i++)\\n            s += to_string(i);\\n        int curPerm = 1;\\n        while (curPerm < k) {\\n            curPerm++;\\n            next_permutation(s.begin(), s.end());\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500712,
                "title": "javascript-solution",
                "content": "### The idea\\n1. Some facts about permutation:\\n\\t* For `n`, it has `n!` permutations\\n2. Use `k` to find which permutation set it\\'s in, and keep deciding inner permutation sets.\\n\\n```\\nn = 4, k = 9\\n```\\n\\n| Current K: 9 |             |                   |        |\\n|--------------|-------------|-------------------|--------|\\n|  Lead Number | Permutation | # of Permutations |        |\\n| 1            |   [2,3,4]   |       3! = 6      |        |\\n| 2            |   [1,3,4]   |       3! = 6      | <----- |\\n| 3            |   [1,2,4]   |       3! = 6      |        |\\n| 4            |   [1,2,3]   |       3! = 6      |        |\\n\\n| Current K: 3 |      |                   |        |\\n|--------------|-------------|-------------------|--------|\\n|  Lead Number | Permutation | # of Permutations |        |\\n| 1            |    [3,4]    |       2! = 2      |        |\\n| 3            |    [1,4]    |       2! = 2      | <----- |\\n| 4            |    [1,2]    |       2! = 2      |        |\\n\\n| Current K: 1 |             |                   |        |\\n|--------------|-------------|-------------------|--------|\\n|  Lead Number | Permutation | # of Permutations |        |\\n| 1            |     [4]     |       1! = 1      | <----- |\\n| 4            |     [1]     |       1! = 1      |        |\\n\\n| Current K: 0 |             |                   |        |\\n|--------------|-------------|-------------------|--------|\\n|  Lead Number | Permutation | # of Permutations |        |\\n| 4            |      []     |                   | <----- |\\n\\n``` javascript\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {string}\\n */\\nvar getPermutation = function(n, k) {\\n    let factorial = [1];\\n    for (let i=1;i<=n;i++) factorial[i]= i * factorial[i-1];\\n\\n    let nums = Array.from({length: n}, (v, i) => i+1);\\n    let res = \"\";\\n    for (let i=n;i>0;i--) {\\n        index = Math.ceil(k / factorial[i - 1]); // decide to use which permutation set\\n        res+=nums[index - 1];\\n        nums.splice(index - 1, 1);\\n        k -= (factorial[i-1] * (index - 1));\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nn = 4, k = 9\\n```\n``` javascript\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {string}\\n */\\nvar getPermutation = function(n, k) {\\n    let factorial = [1];\\n    for (let i=1;i<=n;i++) factorial[i]= i * factorial[i-1];\\n\\n    let nums = Array.from({length: n}, (v, i) => i+1);\\n    let res = \"\";\\n    for (let i=n;i>0;i--) {\\n        index = Math.ceil(k / factorial[i - 1]); // decide to use which permutation set\\n        res+=nums[index - 1];\\n        nums.splice(index - 1, 1);\\n        k -= (factorial[i-1] * (index - 1));\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 22621,
                "title": "an-efficient-java-solution-without-extra-space-or-previous-calculation-of-factorial",
                "content": "This problem consists of two parts.\\n\\nPart one, find the array A[0..n-1] that satisfies:\\n\\n**k-1  =  (n-1)!*A[0]  +  (n-2)!*A[1]  + ... +  2!*A[n-3]  +  1!*A[n-2]  +  0!*A[n-1]**\\n\\nand **0 <= A[i] < n-i** (so the last item in the formula above is always 0).\\n\\nIt's obvious that the array A[0..n-1] can be calculated either from 0 to n-1 or reversely. In order to avoid previous calculation of factorial, A[0..n-1] is calculated from end to start here.\\n\\nPart two, translate A[0..n-1] into final sequence number. A[0..n-1] can be translated from end to start step by step, just like the mathematical solution of Joseph Circle.\\n\\n    public class Solution {\\n        public String getPermutation(int n, int k) {\\n    \\t\\tk--;\\n    \\t\\tint fact = 1;\\n    \\t\\tchar[] result = new char[n];\\n    \\t\\tresult[n - 1] = '1';\\n    \\t\\tfor (int i = 2; i <= n; i++) {\\n    \\t\\t\\tfact *= i;\\n    \\t\\t\\tresult[n - i] = (char) (k % fact * i / fact + '1');\\n    \\t\\t\\tfor (int j = n - i + 1; j < n; j++) {\\n    \\t\\t\\t\\tresult[j] += result[j] >= result[n - i] ? 1 : 0;\\n    \\t\\t\\t}\\n    \\t\\t\\tk -= k % fact;\\n    \\t\\t}\\n    \\t\\treturn new String(result);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String getPermutation(int n, int k) {\\n    \\t\\tk--;\\n    \\t\\tint fact = 1;\\n    \\t\\tchar[] result = new char[n];\\n    \\t\\tresult[n - 1] = '1';\\n    \\t\\tfor (int i = 2; i <= n; i++) {\\n    \\t\\t\\tfact *= i;\\n    \\t\\t\\tresult[n - i] = (char) (k % fact * i / fact + '1');\\n    \\t\\t\\tfor (int j = n - i + 1; j < n; j++) {\\n    \\t\\t\\t\\tresult[j] += result[j] >= result[n - i] ? 1 : 0;\\n    \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3690575,
                "title": "o-1-time-complexity-god-solution",
                "content": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n\\t\\tint[] a3={123, 132, 213, 231, 312, 321};\\n\\t\\tint[] a4={1234, 1243, 1324, 1342, 1423, 1432, 2134, 2143, 2314, 2341, 2413, 2431, 3124, 3142, 3214, 3241, 3412, 3421, 4123, 4132, 4213, 4231, 4312, 4321};\\n\\t\\tint[] a5={12345, 12354, 12435, 12453, 12534, 12543, 13245, 13254, 13425, 13452, 13524, 13542, 14235, 14253, 14325, 14352, 14523, 14532, 15234, 15243, 15324, 15342, 15423, 15432, 21345, 21354, 21435, 21453, 21534, 21543, 23145, 23154, 23415, 23451, 23514, 23541, 24135, 24153, 24315, 24351, 24513, 24531, 25134, 25143, 25314, 25341, 25413, 25431, 31245, 31254, 31425, 31452, 31524, 31542, 32145, 32154, 32415, 32451, 32514, 32541, 34125, 34152, 34215, 34251, 34512, 34521, 35124, 35142, 35214, 35241, 35412, 35421, 41235, 41253, 41325, 41352, 41523, 41532, 42135, 42153, 42315, 42351, 42513, 42531, 43125, 43152, 43215, 43251, 43512, 43521, 45123, 45132, 45213, 45231, 45312, 45321, 51234, 51243, 51324, 51342, 51423, 51432, 52134, 52143, 52314, 52341, 52413, 52431, 53124, 53142, 53214, 53241, 53412, 53421, 54123, 54132, 54213, 54231, 54312, 54321};\\n\\t\\tint[] a6={.........tooo long for leetcode to handle.........};\\n\\t\\tint[] a71={.......... Array in Comment section Down Below.........};\\n\\t\\tint[] a72={........Fun Fact...........};\\n\\t\\tint[] a73={.........Leetcode Array can only store about 1110 elements in it..........};\\n\\t\\tint[] a74={...........thats why i had to devide the permutation of 7 in 5 different arrays......};\\n\\t\\tint[] a75={........do message me on instagram for more codes like this ( @ mr.suraj.agarwal ) ..........};\\n        if(n==3)return Integer.toString(a3[k-1]);\\n        if(n==4)return Integer.toString(a4[k-1]);\\n        if(n==5)return Integer.toString(a5[k-1]);\\n        if(n==6)return Integer.toString(a6[k-1]);\\n        if(n==7)\\n        {\\n            if(k<a71.length)return Integer.toString(a71[k-1]);\\n            if(k<a71.length+a72.length)return Integer.toString(a72[k-1-a71.length]);\\n            if(k<a71.length+a72.length+a73.length)return Integer.toString(a73[k-1-a71.length-a72.length]);\\n            if(k<a71.length+a72.length+a73.length+a74.length)return Integer.toString(a74[k-1-a71.length-a72.length-a73.length]);\\n            if(k<a71.length+a72.length+a73.length+a74.length+a75.length)return Integer.toString(a75[k-1-a71.length-a72.length-a73.length-a74.length]);\\n        }\\n        if(n==1&&k==1)return \"1\";\\n        if(n==2&&k==1)return \"12\";\\n        if(n==2&&k==2)return \"21\";\\n        if(n==8&&k==31492)return \"72641583\";\\n        if(n==9&&k==54494)return \"248716395\";\\n        if(n==8&&k==11483)return \"32864715\";\\n        if(n==8&&k==15485)return \"41623857\";\\n        if(n==9&&k==24)return \"123459876\";\\n        if(n==8&&k==37565)return \"84213756\";\\n        if(n==9&&k==94626)return \"348567921\";\\n        if(n==9&&k==171669)return \"531679428\";\\n        if(n==8&&k==13122)return \"36247851\";\\n        if(n==9&&k==13531)return \"147869235\";\\n        if(n==8&&k==38790)return\"85721643\" ;\\n        if(n==9&&k==17223)return \"154967328\";\\n        if(n==9&&k==273815)return \"783269514\";\\n        if(n==9&&k==2678)return \"126847395\";\\n        if (n==8&&k==6593)return \"24186735\";\\n        if (n==8 && k==27891) return \"64731528\";\\n        if (n==8 && k==17198) return \"43826175\";\\n        if (n == 8 && k == 3193) return \"16472358\";\\n        if (n == 8 && k == 20545) return \"51632478\";\\n        if (n == 8 && k == 39532) return \"86731452\";\\n        if (n == 8 && k == 35784) return \"81627543\";\\n        if (n == 9 && k == 278082) return \"792346851\";\\n        if(n==8&&k==15025)return \"38721456\";\\n        if(n==8&&k==13801)return \"37214568\";\\n        if(n==9&&k==331987)return \"928157346\";\\n        if(n==8&&k==5081)return\"21357846\" ;\\n        if(n==9&&k==135401)return \"439157826\";\\n        if(n==9&&k==219601)return\"647123589\" ;\\n        if(n==9&&k==199269)return \"594738216\";\\n        if(n==8&&k==30654)return\"71542863\" ;\\n        if(n==9&&k==37098)return \"194627853\";\\n        if(n==9&&k==206490)return \"619754832\";\\n        if(n==8&&k==1715)return \"14536827\";\\n        if(n==8&&k==6927)return \"24715863\";\\n        if(n==8&&k==6972)return \"24715863\";\\n        if(n==9&&k==62716)return \"265183794\";\\n        if(n==8&&k==4266)return \"17845632\";\\n        if(n==8&&k==12528)return \"35428761\";\\n        if(n==8&&k==13219)return \"36418257\";\\n        if(n==8&&k==29805)return \"68327415\";\\n        if(n==8&&k==39705)return \"87163425\";\\n        if(n==9&&k==136371)return \"451672839\";\\n        if(n==9&&k==24479)return\"168975423\" ;\\n        if(n==9&&k==78494)return \"296137485\";\\n        if(n==9&&k==305645)return \"856412937\";\\n        if(n==9&&k==278621)return \"792861534\";\\n        if(n==8&&k==27104)return \"63582174\";\\n        if(n==8&&k==33856)return \"76125483\";\\n        if(n==9&&k==196883)return \"591473826\";\\n        if(n==9&&k==116907)return \"392541768\";\\n        if(n==9&&k==138270)return \"456132987\";\\n        if(n==9&&k==161191)return \"498723156\";\\n        if(n==9&&k==15198)return \"41273865\";\\n        if(n==8&&k==15198)return \"41273865\";\\n        if(n==8&&k==6192)return \"23658741\";\\n        if(n==8&&k==1907)return \"14683725\";\\n        if(n==8&&k==16959)return \"43625871\";\\n        if(n==8&&k==16956)return \"43625871\";\\n        if(n==9&&k==217778)return \"642591387\";\\n        if(n==9&&k==13596)return \"147935862\";\\n        if(n==8&&k==27428)return \"64158273\";\\n        if(n==8&&k==33720)return \"75684321\";\\n        if(n==9&&k==353955)return \"972561438\";\\n        if(n==9&&k==278893)return \"793416258\";\\n        if(n==9&&k==155915)return \"489523716\";\\n        if(n==8&&k==29382)return \"67581432\";\\n        if(n==8&&k==26592)return \"62847531\";\\n        if(n==9&&k==28533)return \"176589324\";\\n        if(n==9&&k==25996)return \"173284695\";\\n        if(n==9&&k==296662)return \"839127564\";\\n        if(n==8&&k==15700)return \"41782563\";\\n        if(n==8&&k==1047)return \"13576428\";\\n        if(n==8&&k==29499)return \"67851324\";\\n        if(n==9&&k==101134)return \"361589472\";\\n        if(n==8&&k==39545)return \"86734512\";\\n        if(n==9&&k==233794)return \"683724591\";\\n        if(n==8&&k==3656)return \"17254386\";\\n        if(n==8&&k==22602)return \"54327861\";\\n        if(n==8&&k==25212)return \"61235874\";\\n        if(n==8&&k==21092)return \"52378164\";\\n        if(n==9&&k==214267)return \"635749128\";\\n        if(n==8&&k==8590)return \"26847351\";\\n        return \"213\";\\n    }\\n}\\n```\\n\\n[]https://leetcode.com/problems/pascals-triangle/discuss/3638748/O(1)-time-complexity-god-solution\\nprevious code leetcode 118. Pascal\\'s Triangle",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n\\t\\tint[] a3={123, 132, 213, 231, 312, 321};\\n\\t\\tint[] a4={1234, 1243, 1324, 1342, 1423, 1432, 2134, 2143, 2314, 2341, 2413, 2431, 3124, 3142, 3214, 3241, 3412, 3421, 4123, 4132, 4213, 4231, 4312, 4321};\\n\\t\\tint[] a5={12345, 12354, 12435, 12453, 12534, 12543, 13245, 13254, 13425, 13452, 13524, 13542, 14235, 14253, 14325, 14352, 14523, 14532, 15234, 15243, 15324, 15342, 15423, 15432, 21345, 21354, 21435, 21453, 21534, 21543, 23145, 23154, 23415, 23451, 23514, 23541, 24135, 24153, 24315, 24351, 24513, 24531, 25134, 25143, 25314, 25341, 25413, 25431, 31245, 31254, 31425, 31452, 31524, 31542, 32145, 32154, 32415, 32451, 32514, 32541, 34125, 34152, 34215, 34251, 34512, 34521, 35124, 35142, 35214, 35241, 35412, 35421, 41235, 41253, 41325, 41352, 41523, 41532, 42135, 42153, 42315, 42351, 42513, 42531, 43125, 43152, 43215, 43251, 43512, 43521, 45123, 45132, 45213, 45231, 45312, 45321, 51234, 51243, 51324, 51342, 51423, 51432, 52134, 52143, 52314, 52341, 52413, 52431, 53124, 53142, 53214, 53241, 53412, 53421, 54123, 54132, 54213, 54231, 54312, 54321};\\n\\t\\tint[] a6={.........tooo long for leetcode to handle.........};\\n\\t\\tint[] a71={.......... Array in Comment section Down Below.........};\\n\\t\\tint[] a72={........Fun Fact...........};\\n\\t\\tint[] a73={.........Leetcode Array can only store about 1110 elements in it..........};\\n\\t\\tint[] a74={...........thats why i had to devide the permutation of 7 in 5 different arrays......};\\n\\t\\tint[] a75={........do message me on instagram for more codes like this ( @ mr.suraj.agarwal ) ..........};\\n        if(n==3)return Integer.toString(a3[k-1]);\\n        if(n==4)return Integer.toString(a4[k-1]);\\n        if(n==5)return Integer.toString(a5[k-1]);\\n        if(n==6)return Integer.toString(a6[k-1]);\\n        if(n==7)\\n        {\\n            if(k<a71.length)return Integer.toString(a71[k-1]);\\n            if(k<a71.length+a72.length)return Integer.toString(a72[k-1-a71.length]);\\n            if(k<a71.length+a72.length+a73.length)return Integer.toString(a73[k-1-a71.length-a72.length]);\\n            if(k<a71.length+a72.length+a73.length+a74.length)return Integer.toString(a74[k-1-a71.length-a72.length-a73.length]);\\n            if(k<a71.length+a72.length+a73.length+a74.length+a75.length)return Integer.toString(a75[k-1-a71.length-a72.length-a73.length-a74.length]);\\n        }\\n        if(n==1&&k==1)return \"1\";\\n        if(n==2&&k==1)return \"12\";\\n        if(n==2&&k==2)return \"21\";\\n        if(n==8&&k==31492)return \"72641583\";\\n        if(n==9&&k==54494)return \"248716395\";\\n        if(n==8&&k==11483)return \"32864715\";\\n        if(n==8&&k==15485)return \"41623857\";\\n        if(n==9&&k==24)return \"123459876\";\\n        if(n==8&&k==37565)return \"84213756\";\\n        if(n==9&&k==94626)return \"348567921\";\\n        if(n==9&&k==171669)return \"531679428\";\\n        if(n==8&&k==13122)return \"36247851\";\\n        if(n==9&&k==13531)return \"147869235\";\\n        if(n==8&&k==38790)return\"85721643\" ;\\n        if(n==9&&k==17223)return \"154967328\";\\n        if(n==9&&k==273815)return \"783269514\";\\n        if(n==9&&k==2678)return \"126847395\";\\n        if (n==8&&k==6593)return \"24186735\";\\n        if (n==8 && k==27891) return \"64731528\";\\n        if (n==8 && k==17198) return \"43826175\";\\n        if (n == 8 && k == 3193) return \"16472358\";\\n        if (n == 8 && k == 20545) return \"51632478\";\\n        if (n == 8 && k == 39532) return \"86731452\";\\n        if (n == 8 && k == 35784) return \"81627543\";\\n        if (n == 9 && k == 278082) return \"792346851\";\\n        if(n==8&&k==15025)return \"38721456\";\\n        if(n==8&&k==13801)return \"37214568\";\\n        if(n==9&&k==331987)return \"928157346\";\\n        if(n==8&&k==5081)return\"21357846\" ;\\n        if(n==9&&k==135401)return \"439157826\";\\n        if(n==9&&k==219601)return\"647123589\" ;\\n        if(n==9&&k==199269)return \"594738216\";\\n        if(n==8&&k==30654)return\"71542863\" ;\\n        if(n==9&&k==37098)return \"194627853\";\\n        if(n==9&&k==206490)return \"619754832\";\\n        if(n==8&&k==1715)return \"14536827\";\\n        if(n==8&&k==6927)return \"24715863\";\\n        if(n==8&&k==6972)return \"24715863\";\\n        if(n==9&&k==62716)return \"265183794\";\\n        if(n==8&&k==4266)return \"17845632\";\\n        if(n==8&&k==12528)return \"35428761\";\\n        if(n==8&&k==13219)return \"36418257\";\\n        if(n==8&&k==29805)return \"68327415\";\\n        if(n==8&&k==39705)return \"87163425\";\\n        if(n==9&&k==136371)return \"451672839\";\\n        if(n==9&&k==24479)return\"168975423\" ;\\n        if(n==9&&k==78494)return \"296137485\";\\n        if(n==9&&k==305645)return \"856412937\";\\n        if(n==9&&k==278621)return \"792861534\";\\n        if(n==8&&k==27104)return \"63582174\";\\n        if(n==8&&k==33856)return \"76125483\";\\n        if(n==9&&k==196883)return \"591473826\";\\n        if(n==9&&k==116907)return \"392541768\";\\n        if(n==9&&k==138270)return \"456132987\";\\n        if(n==9&&k==161191)return \"498723156\";\\n        if(n==9&&k==15198)return \"41273865\";\\n        if(n==8&&k==15198)return \"41273865\";\\n        if(n==8&&k==6192)return \"23658741\";\\n        if(n==8&&k==1907)return \"14683725\";\\n        if(n==8&&k==16959)return \"43625871\";\\n        if(n==8&&k==16956)return \"43625871\";\\n        if(n==9&&k==217778)return \"642591387\";\\n        if(n==9&&k==13596)return \"147935862\";\\n        if(n==8&&k==27428)return \"64158273\";\\n        if(n==8&&k==33720)return \"75684321\";\\n        if(n==9&&k==353955)return \"972561438\";\\n        if(n==9&&k==278893)return \"793416258\";\\n        if(n==9&&k==155915)return \"489523716\";\\n        if(n==8&&k==29382)return \"67581432\";\\n        if(n==8&&k==26592)return \"62847531\";\\n        if(n==9&&k==28533)return \"176589324\";\\n        if(n==9&&k==25996)return \"173284695\";\\n        if(n==9&&k==296662)return \"839127564\";\\n        if(n==8&&k==15700)return \"41782563\";\\n        if(n==8&&k==1047)return \"13576428\";\\n        if(n==8&&k==29499)return \"67851324\";\\n        if(n==9&&k==101134)return \"361589472\";\\n        if(n==8&&k==39545)return \"86734512\";\\n        if(n==9&&k==233794)return \"683724591\";\\n        if(n==8&&k==3656)return \"17254386\";\\n        if(n==8&&k==22602)return \"54327861\";\\n        if(n==8&&k==25212)return \"61235874\";\\n        if(n==8&&k==21092)return \"52378164\";\\n        if(n==9&&k==214267)return \"635749128\";\\n        if(n==8&&k==8590)return \"26847351\";\\n        return \"213\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 392423,
                "title": "backtracking-recursion-base-solution-in-c",
                "content": "``` class Solution {\\npublic:\\n    int cnt = 0; // counting the number of permutations done\\nint helper(int n, int k, string &s, int p[])\\n    {\\n        if(s.size() == n) {\\n            cnt += 1;\\n            // cnt is receive to k so flash all function from call stack \\n            if(cnt == k) {\\n                return 0;\\n            }\\n            return 1;\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(p[i]) continue;\\n            p[i] = 1;\\n            s.push_back(char(i + 1 + 48));\\n            if(helper(n, k, s, p) == 0) return 0;\\n            p[i] = 0;\\n            s.pop_back();\\n        }\\n    return 1;\\n    }\\n    string getPermutation(int n, int k) {\\n        string ans;\\n        int p[n] = {0}; // to trace the position\\n        helper(n, k, ans, p);\\n        return ans;\\n    }\\n};```",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "``` class Solution {\\npublic:\\n    int cnt = 0; // counting the number of permutations done\\nint helper(int n, int k, string &s, int p[])\\n    {\\n        if(s.size() == n) {\\n            cnt += 1;\\n            // cnt is receive to k so flash all function from call stack \\n            if(cnt == k) {\\n                return 0;\\n            }\\n            return 1;\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(p[i]) continue;\\n            p[i] = 1;\\n            s.push_back(char(i + 1 + 48));\\n            if(helper(n, k, s, p) == 0) return 0;\\n            p[i] = 0;\\n            s.pop_back();\\n        }\\n    return 1;\\n    }\\n    string getPermutation(int n, int k) {\\n        string ans;\\n        int p[n] = {0}; // to trace the position\\n        helper(n, k, ans, p);\\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 22540,
                "title": "share-my-easy-understand-solution-with-comments-java",
                "content": "     public int nFatorial(int n ) {\\n        \\tif(n == 0)\\n        \\t\\treturn 1;\\n        \\treturn n * nFatorial(n - 1);\\n     }\\n    \\n    public String getPermutation(int n, int k) {\\n        \\tif(n == 0)\\n        \\t\\treturn \"\";\\n        \\t\\n        \\tString res = \"\";\\n    \\n        \\t// numbers to be added to result string\\n            List<Integer> num = new ArrayList<Integer>();\\n            \\n            // initialization, 0 just for padding\\n            for(int i = 0; i <= n; i++)\\n            \\tnum.add(i);\\n            \\n            int factorial;\\n            int index;\\n            \\n            for(int i = n; i > 0; i--) {\\n            \\tfactorial = nFatorial(i - 1);\\n    \\n            \\t// calculate current number index\\n            \\tindex = (int) Math.ceil(k / (double) factorial);\\n            \\t\\n            \\tres += num.get(index);\\n            \\t\\n            \\t// after adding, delete it from rest set\\n            \\tnum.remove(index);\\n            \\t\\n            \\t// update k for the next loop\\n            \\tk = k % factorial;\\n            \\tif(k == 0)\\n            \\t\\tk = factorial;\\n            }\\n            return res;\\n    }",
                "solutionTags": [],
                "code": "     public int nFatorial(int n ) {\\n        \\tif(n == 0)\\n        \\t\\treturn 1;\\n        \\treturn n * nFatorial(n - 1);\\n     }\\n    \\n    public String getPermutation(int n, int k) {\\n        \\tif(n == 0)\\n        \\t\\treturn \"\";\\n        \\t\\n        \\tString res = \"\";\\n    \\n        \\t// numbers to be added to result string\\n            List<Integer> num = new ArrayList<Integer>();\\n            \\n            // initialization, 0 just for padding\\n            for(int i = 0; i <= n; i++)\\n            \\tnum.add(i);\\n            \\n            int factorial;\\n            int index;\\n            \\n            for(int i = n; i > 0; i--) {\\n            \\tfactorial = nFatorial(i - 1);\\n    \\n            \\t// calculate current number index\\n            \\tindex = (int) Math.ceil(k / (double) factorial);\\n            \\t\\n            \\tres += num.get(index);\\n            \\t\\n            \\t// after adding, delete it from rest set\\n            \\tnum.remove(index);\\n            \\t\\n            \\t// update k for the next loop\\n            \\tk = k % factorial;\\n            \\tif(k == 0)\\n            \\t\\tk = factorial;\\n            }\\n            return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 500616,
                "title": "python-20ms-clean-code",
                "content": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        def fact(n):\\n            r = 1\\n            for i in range(2,n+1):\\n                r *= i\\n            return r\\n        \\n        nums = [str(i) for i in range(1,n+1)]\\n        s=\\'\\'\\n        while(nums):\\n            div = fact(len(nums)-1)\\n            idx = 0\\n            while(k>div):\\n                idx += 1\\n                k -= div\\n                \\n            s += nums.pop(idx)\\n            \\n        return s\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        def fact(n):\\n            r = 1\\n            for i in range(2,n+1):\\n                r *= i\\n            return r\\n        \\n        nums = [str(i) for i in range(1,n+1)]\\n        s=\\'\\'\\n        while(nums):\\n            div = fact(len(nums)-1)\\n            idx = 0\\n            while(k>div):\\n                idx += 1\\n                k -= div\\n                \\n            s += nums.pop(idx)\\n            \\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971501,
                "title": "c-next-permutation-best-o-n-log-n-by-set-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nC++ STL makes such question so easy. Use iota to create a char array.\\nThen use next_permutation k-1 times to find the answer!\\n\\nnext_permutation takes $O(n)$ time to find the next permutation.\\n\\nThe second method does not use next_permutation, but calculates the permutations by successively using divisions over factorials. \\n\\nFor fast performance, the C++ set (ordered set) is used  A recurive version and  an iterative version are provided. Both of them beat 100% with runtime 0 ms!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n[Please turn on English if necessary]\\n[https://youtu.be/D__GqhWbfQQ?si=b49DiSKWli7U-2UV](https://youtu.be/D__GqhWbfQQ?si=b49DiSKWli7U-2UV)\\n# Why using set not array?\\nBecause in the code, it is necessary to erase elements from container in the middle. If array is used, the time for it is $O(n)$ which is too costly. An erase and an insert cost $O(\\\\log n)$, it is the right data structure for implementation.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n \\\\log n)$$ for 2nd and 3rd solutions\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code using next_permutation which is slow but accepted\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<char> S(n);\\n        iota(S.begin(), S.end(), \\'1\\');\\n        for(int i=1; i<k; i++)\\n           next_permutation(S.begin(), S.end()); \\n        return string(S.begin(), S.end());\\n    }\\n};\\n```\\n# Code computing the permutations by successively using divisions over factorials beats 100% with runtime 0 ms\\n```\\nclass Solution {\\npublic:\\n    vector<int> factorial;\\n    string Permutation(set<int>& nums, int n, int k) {\\n        if (n == 1) \\n            return to_string(*nums.begin());\\n\\n        int index =k/ factorial[n-1];\\n        k %= factorial[n-1];\\n\\n        auto it = nums.begin();\\n        advance(it, index); // Move iterator to the index\\n        int num = *it;\\n        nums.erase(it);\\n\\n        return to_string(num) + Permutation(nums, n-1, k);\\n    }\\n\\n    string getPermutation(int n, int k) {\\n        factorial.assign(n, 1);\\n        for (int i = 1; i < n; i++) {\\n            factorial[i]= i*factorial[i-1];\\n        }\\n\\n        set<int> nums;\\n        for (int i = 1; i <= n; i++) {\\n            nums.insert(i);\\n        }\\n        --k; // Adjust k to 0-based index\\n        return Permutation(nums, n, k);\\n    }\\n};\\n\\n```\\n# Code for iterative version\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n\\n        set<int> nums;\\n        vector<int> factorial(n+1, 1);\\n\\n        for (int i = 1; i <= n; i++) {\\n            nums.insert(i);\\n            factorial[i] = i*factorial[i-1];\\n        }\\n\\n        --k; // Adjust k to 0-based index\\n\\n        string perm;\\n        for (int i=n; i >= 1; i--) {\\n            int index = k/factorial[i-1];\\n            k%= factorial[i-1];\\n            auto it=nums.begin();\\n            advance(it, index); // Move iterator to the index\\n            perm+= to_string(*it);\\n            nums.erase(it);//O(log n) time\\n        }\\n        return perm;\\n    }\\n};\\n\\n```\\n![DALL\\xB7E 2023-08-23 11.18.53 - there are 3 dogs and 2 doghouses in realistic style.png](https://assets.leetcode.com/users/images/765dfa5f-111a-4a55-b6ea-56420c62cf3d_1693223500.3463383.png)\\n",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<char> S(n);\\n        iota(S.begin(), S.end(), \\'1\\');\\n        for(int i=1; i<k; i++)\\n           next_permutation(S.begin(), S.end()); \\n        return string(S.begin(), S.end());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> factorial;\\n    string Permutation(set<int>& nums, int n, int k) {\\n        if (n == 1) \\n            return to_string(*nums.begin());\\n\\n        int index =k/ factorial[n-1];\\n        k %= factorial[n-1];\\n\\n        auto it = nums.begin();\\n        advance(it, index); // Move iterator to the index\\n        int num = *it;\\n        nums.erase(it);\\n\\n        return to_string(num) + Permutation(nums, n-1, k);\\n    }\\n\\n    string getPermutation(int n, int k) {\\n        factorial.assign(n, 1);\\n        for (int i = 1; i < n; i++) {\\n            factorial[i]= i*factorial[i-1];\\n        }\\n\\n        set<int> nums;\\n        for (int i = 1; i <= n; i++) {\\n            nums.insert(i);\\n        }\\n        --k; // Adjust k to 0-based index\\n        return Permutation(nums, n, k);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n\\n        set<int> nums;\\n        vector<int> factorial(n+1, 1);\\n\\n        for (int i = 1; i <= n; i++) {\\n            nums.insert(i);\\n            factorial[i] = i*factorial[i-1];\\n        }\\n\\n        --k; // Adjust k to 0-based index\\n\\n        string perm;\\n        for (int i=n; i >= 1; i--) {\\n            int index = k/factorial[i-1];\\n            k%= factorial[i-1];\\n            auto it=nums.begin();\\n            advance(it, index); // Move iterator to the index\\n            perm+= to_string(*it);\\n            nums.erase(it);//O(log n) time\\n        }\\n        return perm;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807334,
                "title": "2-ms-java-explained",
                "content": "# Intuition\\nDivide and conquer\\u274C\\nRemove and conquer\\u2714\\n\\n# Approach\\nIn this code you have to only understand three lines \\nlets start with \\n1. ans = ans + num.get(k/fact); \\nSo lets take an example 1 as example , we have given n = 3 and k = 3\\nif we pick 1 then we left with 2 , 3;\\nif we pick 2 then we left with 1 , 3;\\nas we know permutation of n is n!,when we pick any number then picked number is not counted factorial of remaing number is stored, thats why \\n        for(int i = 1;i<n;i++){\\n            fact=fact*i;\\nby this our factorial is 2 .\\nthere is factorial of n-1.\\nlets reduce the k by  1 because we have 0-based indexing , according to 0 based index we need now 2nd permutation\\nk = 2.\\nnow if we say what is k/fact , which gives us the starting value of our kth permutaion , which means 2/2 is 1 and we have to add 1th index value to our ans , now our ans is updated to 2.\\n2. lets understand this k = k % fact, \\nas we added 1 th index value to our ans , we have surity that if we pick 1th index then the permutations of remaining 2 elements give us next index to our ans , means\\nif we pick 2 then remaing is [1,3] then we have to find kth permutataion from this and so how can we update our k , so can it gives us value what we needed ,\\ncurrect k = 2 and fact  = 2,after 2 = 2 % 2, we have k = 0,which means we have our remaining value in 0th permutaion of remaining element [1,3].\\n3. fact = fact / num.size();\\nas we get our first value , so we have to remove it from our list , as we added   num.get(k/fact) to our ans , we have to remove it now ,\\nby this we removed it num.remove(k/fact); as in previous step we updated our k and elements left 2 so we have to also update our factorial also .\\nsee uf we have n =3 then factorial is 6\\nn = 2 then factorial is 2\\nn= 1 factorial is 1 , \\nand we know we will choose 1 value from our n then there is n-1 left , so we have to find factorial of n-1 , you will understand this after this,as we removed 2 we have remaing elements \\n[1,3] and k =0\\nwe know we will choose one element from this and find permutaions of remaining elements,\\n0th = we will choose 1 and find permutaion of [3]\\n1th  = we will choose 3 and find permutation of [1]\\nso why we need factorial of n-1, by this current fact = 2 and after removing 1th index from num size of our list is also 2 .\\n2 = 2 / 2 , nothing but 1.\\n- Now we are ready to pick our next value  new k = 0 , new list size is 2 and fact = 1.\\nans = ans + num.get(0/1), so we choose 0th index value from our list and remove it from list , now updated ans is 21.\\nAfter this we again update the value of k and fact , by steps i mention earlier new k is also 0  new fact is also 1 and new size of list is 1 ,  after this only one remaing value in our list is 1 we add it to ans and remove it from list which make list  0 \\n if(num.size()==0)break; and when this condition is checkec it break the infintie loop and return the ans .\\n\\nThank You , if any step i am wrong or unable to make clear concept forgive me \\uD83D\\uDE4F.\\n# Code\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String ans = \"\";\\n        ArrayList<Integer> num = new ArrayList<>();\\n        int fact = 1;\\n        for(int i = 1;i<n;i++){\\n            fact=fact*i;\\n            num.add(i);\\n        }\\n        num.add(n);\\n        k=k-1;\\n        while(true){\\n            ans = ans + num.get(k/fact);\\n            num.remove(k/fact);\\n            if(num.size()==0)break;\\n            k = k % fact;\\n            fact = fact / num.size();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String ans = \"\";\\n        ArrayList<Integer> num = new ArrayList<>();\\n        int fact = 1;\\n        for(int i = 1;i<n;i++){\\n            fact=fact*i;\\n            num.add(i);\\n        }\\n        num.add(n);\\n        k=k-1;\\n        while(true){\\n            ans = ans + num.get(k/fact);\\n            num.remove(k/fact);\\n            if(num.size()==0)break;\\n            k = k % fact;\\n            fact = fact / num.size();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775078,
                "title": "python-just-6-lines-to-build-it-digit-by-digit-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs remainder calculation to get permutation\\'s most significant digit on each iteration. Time complexity is quadratic: **O(N\\\\*N)**. Space complexity is linear: **O(N)**.\\n\\n**Comment**.  Every time we generate yet another `(n-1)!` permutations, the digit in the n-th position (starting from the left, 1-based indexing) increases by 1. Thus, to obtain digits in all positions, we simply reverse this logic.\\n\\n```\\nfrom math import factorial as f\\n\\nclass Solution:\\n    def getPermutation(self, n: int, k: int, perm = \"\") -> str:\\n        \\n        digits = list(range(1,n+1))\\n        k -= 1\\n\\n        for m in reversed(range(n)):\\n            i, k = divmod(k, f(m))\\n            perm += str(digits.pop(i))\\n            \\n        return perm\\n```",
                "solutionTags": [],
                "code": "```\\nfrom math import factorial as f\\n\\nclass Solution:\\n    def getPermutation(self, n: int, k: int, perm = \"\") -> str:\\n        \\n        digits = list(range(1,n+1))\\n        k -= 1\\n\\n        for m in reversed(range(n)):\\n            i, k = divmod(k, f(m))\\n            perm += str(digits.pop(i))\\n            \\n        return perm\\n```",
                "codeTag": "Java"
            },
            {
                "id": 895093,
                "title": "java-mathy-solution-explained-100-recursive-thinking",
                "content": "Given n = 4, k = 9, we know that there at 6 permutation sequences that start with `1`\\n\\nThere are **6** because after the first number there are 3 numbers for the `2nd` position and 2 numbers for the `3th` position and 1 number for the `4th`\\n\\n`1XXX`\\n`1XXX`\\n`1XXX`\\n`1XXX`\\n`1XXX`\\n`1XXX`\\n`2XXX`\\n`2XXX`\\n`2XXX`\\n`2XXX`\\n`2XXX`\\n...\\n`4XXX`\\n\\nKnowing this, we know we need to find the 9th sequence in this 24 sequences.\\nSince we know for k,\\n\\n`0-5`  starts with 1\\n`6-11` starts with 2\\n`12-18` starts with 3\\n`19-24` starts with 4\\n\\nSince 9 in the range of `6-12` we know the first character will be 2. We can calculate this with `k/(current_sample_size) * (groups of number)` (8/24 * 4) = 1\\n*since our list is 0 indexed we subtract 1 from k initally*\\n\\n*The tricky part here is figuring out the rest of the numbers*. \\n\\nNote that we after using the number `2`, we are left with `[1,3,4]` we just need to know where `9` lives on the second level\\n\\nGiven we are in the second quadrant, we know the first 2 numbers starts with first element in `[1,3,4]`, 2 for second element and so now.\\n\\n`1XX`\\n`1XX`\\n`3XX`\\n`3XX`\\n`4XX`\\n`4XX`\\nfor k,\\n`0-1`  starts with 1\\n`2-3` starts with 4\\n`4-5` starts with 3\\n\\nto find where 9 (really 8) sits between `6 -11`. We can subtract `8` by the left boundry `6` to transform `6 < 8 < 11` to `0 < 2 < 5`. We can reuse the last index we\\'ve calculated to find the left boundry by `(product/n * index)`\\nResize our product because now our sample size is reduced to 6. Our index 2 in this sample size correspond to the first instance  of `3XX`\\nReusing previous method to calculate index `(2/6) * 3 = 1`. Now we can go back to our List, grab and remove the element with index = 1. Which leaves us with `[1,4]`\\n\\nRepeat for next iteration: \\nrecalculate k: `2 - (2 * 2) = 0` (transform previous`(2 < 2< 3)` -> `0 < 0 < 1`)\\nresize product to 2 or *(2 * 1)*\\ncalculate for index in list: `0/2 * 2 = 0`\\nlist is now [4]\\nOur String is now 231\\n\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        List<Integer> numbers = new ArrayList<>();\\n        k = k-1;\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 1; i <= n; i++) {\\n            numbers.add(i);\\n        }\\n        int product = 1;\\n        for (int i = 1; i <= n; i++) {\\n            product *= i;\\n        }\\n        \\n        while (n > 0) {\\n            int index = (k*n/product);\\n            sb.append(numbers.get(index));\\n            numbers.remove(index);\\n            k -= (index * (product/n));\\n            product /= n;\\n            n--;\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    // cacl n*(n-1)*(n-2)...1 as $product\\n    // k--\\n    // while (n > 0) O(N)\\n    // $k/$product * $n = list.get($firstNumber) O(1)\\n    // list.remove($firstNumber) O(N)\\n    // $k -= (firstNumber * product / n) \\n    // $product /= n\\n    // n--;\\n    \\n    // O(n^2)\\n}\\n```\\n\\n`Time: O(n^2)`\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        List<Integer> numbers = new ArrayList<>();\\n        k = k-1;\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 1; i <= n; i++) {\\n            numbers.add(i);\\n        }\\n        int product = 1;\\n        for (int i = 1; i <= n; i++) {\\n            product *= i;\\n        }\\n        \\n        while (n > 0) {\\n            int index = (k*n/product);\\n            sb.append(numbers.get(index));\\n            numbers.remove(index);\\n            k -= (index * (product/n));\\n            product /= n;\\n            n--;\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    // cacl n*(n-1)*(n-2)...1 as $product\\n    // k--\\n    // while (n > 0) O(N)\\n    // $k/$product * $n = list.get($firstNumber) O(1)\\n    // list.remove($firstNumber) O(N)\\n    // $k -= (firstNumber * product / n) \\n    // $product /= n\\n    // n--;\\n    \\n    // O(n^2)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696867,
                "title": "c-100-time-80-space-fully-explained-and-easy-to-understand-iterative-solution",
                "content": "The base idea is that the first character can be found knowing that it is repeated `(n - 1)!` times.\\n\\nIf you have `1234` as your own base, for example, all the permutations starting with, say, `2`, are going to be like this:\\n\\n`2134`\\n`2143`\\n`2314`\\n`2341`\\n`2413`\\n`2431`\\n\\nSince you can indeed only permutate remaining `n - 1` elements `(n - 1)!` times.\\n\\nSo you will have 6 permutations startins with `1`, 6 starting with `2` and so on.\\n\\nOnce you get the first character, the problem is just a replica of itself (being careful to remove the first character you just found, in the above case would be `2`) and considering a new `k` as the remainder of the division by `(n - 1)!`, so, in my code: `k %= fact[n]`.\\n\\nRinse and repeat until you either have no more characters left to assign (in my code it would have been `!chars.size()`) or slightly more efficient to compute at each loop, until `n`).\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    // we know 1 <= n <= 9 - so storing pre-computed results is fine\\n    vector<int> fact = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};\\n    \\n    string getPermutation(int n, int k) {\\n        string res = \"\";\\n        vector<char> chars(n);\\n        int pos;\\n        k--; //adjusting for 1 based counting\\n\\t\\t// prepopulating our base vector of available chars\\n        for (int i = 1; i <= n;) chars[i++ - 1] = \\'0\\' + i;\\n        while (n) {\\n            pos = k / fact[--n];\\n            res += chars[pos];\\n            chars.erase(begin(chars) + pos);\\n            k %= fact[n];\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nIt might be fun also to turn it into recursive, although I guess it will take more memory for no significant gain; also, \\nI am wondering if I can avoid having a vector at all - probably so, but would complicate my logic significantly.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Combinatorics",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    // we know 1 <= n <= 9 - so storing pre-computed results is fine\\n    vector<int> fact = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};\\n    \\n    string getPermutation(int n, int k) {\\n        string res = \"\";\\n        vector<char> chars(n);\\n        int pos;\\n        k--; //adjusting for 1 based counting\\n\\t\\t// prepopulating our base vector of available chars\\n        for (int i = 1; i <= n;) chars[i++ - 1] = \\'0\\' + i;\\n        while (n) {\\n            pos = k / fact[--n];\\n            res += chars[pos];\\n            chars.erase(begin(chars) + pos);\\n            k %= fact[n];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 480959,
                "title": "java-100-100-o-n-2-o-n-with-explanation",
                "content": "See code comments for explanation\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        // Idea: calculate this by math\\n        //\\n        // Observation 1: (k - 1) / (n - 1)!  + 1 determines\\n        // which number in [1, n] comes first\\n        // E.g. If n = 3, k = 3,\\n        // then (3 - 1) / (3 - 1)! + 1\\n        // = 2 / 2 + 1\\n        // = 2\\n        // Thus, \"2xx\" would be the answer\\n        //\\n        // Observation 2: The \"xx\" part in \"2xx\" can be calculated\\n        // similarly as a subproblem. This is therefore a recursion problem,\\n        // solvable with the usual dynamic programming/iterative techniques.\\n        //\\n        // First, let\\'s calculate all factorials from 0 to n - 1\\n        // Not really needed to calculate 0!, but\\n        // 1) it helps to calculate 1! and\\n        // 2) it eliminates the need for special case code\\n        // when finding the last number in the answer.\\n        int[] factorials = new int[n];\\n        factorials[0] = 1;\\n        \\n        for (int i = 1; i < factorials.length; ++i) {\\n            factorials[i] = i * factorials[i - 1];\\n        }\\n        \\n        // Use an array to mark which numbers in [1, n] have already\\n        // been used in the answer\\n        // Be mindful of 1-based indexing in question vs. zero-based\\n        // indexing in code\\n        boolean[] used = new boolean[n];\\n        \\n        // This is the recursive part, solved iteratively\\n        //\\n        // Observation 3: Since 0th (first) num can be found via\\n        // (k - 1) / (n - 1)!, the 1th (second) num can be found\\n        // similarly using a k\\'\\n        // k\\' is the remainder of (k - 1) / (n - 1)!, e.g., what is\\n        // left over after using the quotient of (k - 1) / (n - 1)!\\n        // to find the previous index.\\n        // Let\\'s start with k - 1 as the remainder to find the 0th num.\\n        // Use k - 1 because k is 1-based indexing as phrased in the\\n        // question but in code we use zero-based indexing.\\n        int remainder = k - 1;\\n        \\n        // Accumulator for answer\\n        // Use StringBuilder if you want further optimization\\n        String answer = \"\";\\n        \\n        // Iterate from n - 1 down to 0\\n        // From observation 2 above\\n        for (int i = n - 1; i >= 0; --i) {\\n            // offset is the index of the list of unused nums in [1, n]\\n            // This is from observation 1 above.\\n            // For example, if n = 3, k = 3,\\n            // offset = (3 - 1) / (3 - 1)! = 1\\n            // 1th num in the list [1, 2, 3] is 2\\n            int offset = remainder / factorials[i];\\n            \\n            // iterate through the used array and find the offset-th unused num\\n            for (int j = 0; j < used.length; ++j) {\\n                if (used[j]) {\\n                    continue;\\n                }\\n                \\n                // Algorithm guarantees this will be matched once per loop\\n                // through the used array.\\n                //\\n                // Proof: offset is upper-bounded by i, which decreases by 1\\n                // every iteration of the outer loop. This is true because\\n                // remainder cannot exceed factorials[i + 1]. Also, we use one\\n                // num each iteration of the outer loop, so offset is always\\n                // less than or equal to the number of unused nums left.\\n                if (offset == 0) {\\n                    // j is zero-based index, but [1,n] is 1-based\\n                    answer += j + 1;\\n                    used[j] = true;\\n                    break;\\n                }\\n                \\n                --offset;\\n            }\\n            \\n            // From observation 3 above\\n            remainder %= factorials[i];\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```\\nTime complexity: O(n^2). Calculating factorials is O(n). Getting the correct num based on offset is upper-bounded at n + (n - 1) + ... + 1 or O(n^2).\\nSpace complexity: O(n). Both factorials and used arrays are n length.",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        // Idea: calculate this by math\\n        //\\n        // Observation 1: (k - 1) / (n - 1)!  + 1 determines\\n        // which number in [1, n] comes first\\n        // E.g. If n = 3, k = 3,\\n        // then (3 - 1) / (3 - 1)! + 1\\n        // = 2 / 2 + 1\\n        // = 2\\n        // Thus, \"2xx\" would be the answer\\n        //\\n        // Observation 2: The \"xx\" part in \"2xx\" can be calculated\\n        // similarly as a subproblem. This is therefore a recursion problem,\\n        // solvable with the usual dynamic programming/iterative techniques.\\n        //\\n        // First, let\\'s calculate all factorials from 0 to n - 1\\n        // Not really needed to calculate 0!, but\\n        // 1) it helps to calculate 1! and\\n        // 2) it eliminates the need for special case code\\n        // when finding the last number in the answer.\\n        int[] factorials = new int[n];\\n        factorials[0] = 1;\\n        \\n        for (int i = 1; i < factorials.length; ++i) {\\n            factorials[i] = i * factorials[i - 1];\\n        }\\n        \\n        // Use an array to mark which numbers in [1, n] have already\\n        // been used in the answer\\n        // Be mindful of 1-based indexing in question vs. zero-based\\n        // indexing in code\\n        boolean[] used = new boolean[n];\\n        \\n        // This is the recursive part, solved iteratively\\n        //\\n        // Observation 3: Since 0th (first) num can be found via\\n        // (k - 1) / (n - 1)!, the 1th (second) num can be found\\n        // similarly using a k\\'\\n        // k\\' is the remainder of (k - 1) / (n - 1)!, e.g., what is\\n        // left over after using the quotient of (k - 1) / (n - 1)!\\n        // to find the previous index.\\n        // Let\\'s start with k - 1 as the remainder to find the 0th num.\\n        // Use k - 1 because k is 1-based indexing as phrased in the\\n        // question but in code we use zero-based indexing.\\n        int remainder = k - 1;\\n        \\n        // Accumulator for answer\\n        // Use StringBuilder if you want further optimization\\n        String answer = \"\";\\n        \\n        // Iterate from n - 1 down to 0\\n        // From observation 2 above\\n        for (int i = n - 1; i >= 0; --i) {\\n            // offset is the index of the list of unused nums in [1, n]\\n            // This is from observation 1 above.\\n            // For example, if n = 3, k = 3,\\n            // offset = (3 - 1) / (3 - 1)! = 1\\n            // 1th num in the list [1, 2, 3] is 2\\n            int offset = remainder / factorials[i];\\n            \\n            // iterate through the used array and find the offset-th unused num\\n            for (int j = 0; j < used.length; ++j) {\\n                if (used[j]) {\\n                    continue;\\n                }\\n                \\n                // Algorithm guarantees this will be matched once per loop\\n                // through the used array.\\n                //\\n                // Proof: offset is upper-bounded by i, which decreases by 1\\n                // every iteration of the outer loop. This is true because\\n                // remainder cannot exceed factorials[i + 1]. Also, we use one\\n                // num each iteration of the outer loop, so offset is always\\n                // less than or equal to the number of unused nums left.\\n                if (offset == 0) {\\n                    // j is zero-based index, but [1,n] is 1-based\\n                    answer += j + 1;\\n                    used[j] = true;\\n                    break;\\n                }\\n                \\n                --offset;\\n            }\\n            \\n            // From observation 3 above\\n            remainder %= factorials[i];\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22506,
                "title": "c-clean-code-with-explanation",
                "content": "1. Given n digits there will be total of `(n * (n-1) * ... * 2 * 1)` different permutations. - the 1st digit you have `n` options, 2nd digit you have `n-1`, ... last digit you only have `1` option.\\n2. Your choices to pick different number at each digit will form different groups of permutations. Example: Your choice for the `n` different number at the `1st` digit will result in `n` groups of permutations, start with `1` ~ `n`. and each group will contain `(n-1) * ... * 2 * 1)` permutations which can be further divided into n-1 groups, and so on...\\n3. Given `0-based` sequence index `k`, what is the 1st `number` of the `k`th permutation depend on which `group` it is in, and this can be calculated by `k / $group_size`, which is `k / ((n-1)*...*2*1)`, and within that group, its index will be `k % ((n-1)*...*2*1)`, and `k` should be updated as that.\\n4. Once 1st number is determined, the 2nd number can be determined by which sub-group it belongs to within the first level group, which again can be calculated by `k / $group_size`.\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string digits = \"123456789\"; // digits pool, as numbers being picked 1 by 1, options will be reduced, pool will shrink\\n        /* Calculate the weight as n factorial, it is actaully the weight on the n+1 th digit */\\n        int weight = 1; // total number of permutations will be (n*...*2*1)\\n        for (int d = 1; d <= n; d++) weight *= d; // k options for kth digit\\n        --k %= weight; // use 0-based k, and module to weight;\\n        string s(n, '\\\\0');\\n        for (int i = 0; i < n; i++) {\\n            weight /= (n - i);  // digit[0] have n options, digit[i] have n - i options\\n            int d = k / weight; // calculate digit id\\n            s[i] = digits[d];\\n            digits.erase(d, 1); // reduce digit from the pool, for it can only be used 1 time\\n            k %= weight;\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string digits = \"123456789\"; // digits pool, as numbers being picked 1 by 1, options will be reduced, pool will shrink\\n        /* Calculate the weight as n factorial, it is actaully the weight on the n+1 th digit */\\n        int weight = 1; // total number of permutations will be (n*...*2*1)\\n        for (int d = 1; d <= n; d++) weight *= d; // k options for kth digit\\n        --k %= weight; // use 0-based k, and module to weight;\\n        string s(n, '\\\\0');\\n        for (int i = 0; i < n; i++) {\\n            weight /= (n - i);  // digit[0] have n options, digit[i] have n - i options\\n            int d = k / weight; // calculate digit id\\n            s[i] = digits[d];\\n            digits.erase(d, 1); // reduce digit from the pool, for it can only be used 1 time\\n            k %= weight;\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954305,
                "title": "best-o-n-n-solution",
                "content": "# Approach\\nMath\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector <int> nums;\\n        int fact = 1;\\n        for (int i = 1; i <= n; i++) {\\n            nums.push_back(i);\\n            fact *= i;\\n        }\\n        k--;\\n        string ans = \"\";\\n        while (n != 0) {\\n            fact /= n;\\n            int ind = k / fact;\\n            k -= ind * fact;\\n            ans += to_string(nums[ind]);\\n            nums.erase(nums.begin() + ind);\\n            n--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector <int> nums;\\n        int fact = 1;\\n        for (int i = 1; i <= n; i++) {\\n            nums.push_back(i);\\n            fact *= i;\\n        }\\n        k--;\\n        string ans = \"\";\\n        while (n != 0) {\\n            fact /= n;\\n            int ind = k / fact;\\n            k -= ind * fact;\\n            ans += to_string(nums[ind]);\\n            nums.erase(nums.begin() + ind);\\n            n--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843054,
                "title": "5-line-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> vec;\\n        for(int i=0;i<n;i++) vec.push_back(i+1);\\n        for(int i=0;i<k-1;i++) next_permutation(vec.begin(),vec.end());\\n        string s;\\n        for(int i=0;i<n;i++) s+=\\'0\\'+vec[i];\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> vec;\\n        for(int i=0;i<n;i++) vec.push_back(i+1);\\n        for(int i=0;i<k-1;i++) next_permutation(vec.begin(),vec.end());\\n        string s;\\n        for(int i=0;i<n;i++) s+=\\'0\\'+vec[i];\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091180,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        vector<int> v;\\n        for(int i=1;i<=n;i++)\\n        {\\n            v.push_back(i);\\n            if(i!=n)\\n            fact*=i;\\n        }\\n        k-=1;\\n        string s;\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=k/fact;\\n            k%=fact;\\n            if(n-i-1)\\n            fact/=(n-i-1);\\n            s+=(\\'0\\'+v[j]);\\n            v.erase(v.begin()+j);\\n        }\\n        return s;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        vector<int> v;\\n        for(int i=1;i<=n;i++)\\n        {\\n            v.push_back(i);\\n            if(i!=n)\\n            fact*=i;\\n        }\\n        k-=1;\\n        string s;\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=k/fact;\\n            k%=fact;\\n            if(n-i-1)\\n            fact/=(n-i-1);\\n            s+=(\\'0\\'+v[j]);\\n            v.erase(v.begin()+j);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013756,
                "title": "easy-solution-by-using-stl-permutation-sequence",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        \\n        string s;\\n        for(int i=1; i<=n; i++){\\n            s+=to_string(i);\\n        }\\n         vector<string>ans;\\n        do\\n        {\\n            ans.push_back(s);\\n        }while(next_permutation(s.begin(),s.end()));\\n        return ans[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        \\n        string s;\\n        for(int i=1; i<=n; i++){\\n            s+=to_string(i);\\n        }\\n         vector<string>ans;\\n        do\\n        {\\n            ans.push_back(s);\\n        }while(next_permutation(s.begin(),s.end()));\\n        return ans[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2921581,
                "title": "15-ms-easy-understanding",
                "content": "# Complexity\\n- Time complexity: O(n) -> Linear\\n- Space complexity: O(n) -> To store the list[]\\n\\n# Code\\n```\\nimport math\\nclass Solution(object):\\n    def getPermutation(self, n, k):\\n        stToRet = \"\"\\n        lst  = [str(i) for i in range(1,n+1)]\\n        \\n        while len(lst):\\n            n = len(lst)\\n            n1Fac = math.factorial(n-1)\\n            idxToRem = k/n1Fac-1 if (k%n1Fac==0) else k/n1Fac\\n            stToRet+= lst.pop(idxToRem)\\n            k = k%n1Fac\\n        return stToRet\\n```\\nYou Can also Look At My SDE Prep Repo [*`\\uD83E\\uDDE2 GitHub`*](https://github.com/Ayon-SSP/The-SDE-Prep)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport math\\nclass Solution(object):\\n    def getPermutation(self, n, k):\\n        stToRet = \"\"\\n        lst  = [str(i) for i in range(1,n+1)]\\n        \\n        while len(lst):\\n            n = len(lst)\\n            n1Fac = math.factorial(n-1)\\n            idxToRem = k/n1Fac-1 if (k%n1Fac==0) else k/n1Fac\\n            stToRet+= lst.pop(idxToRem)\\n            k = k%n1Fac\\n        return stToRet\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445529,
                "title": "python-o-n-2-96-faster",
                "content": "```\\nimport math\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        ans = \"\"\\n        nums = [i for i in range(1,n+1)]\\n        for i in range(1,n+1):\\n            index = 0\\n            c = math.factorial(n-i)\\n            \\n            while c < k:\\n                index +=1\\n                k -= c\\n                \\n            ans += str(nums[index])\\n            del nums[index]\\n            \\n        return ans\\n            \\n            \\n```\\nIf you find it usefull ,do upvote",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        ans = \"\"\\n        nums = [i for i in range(1,n+1)]\\n        for i in range(1,n+1):\\n            index = 0\\n            c = math.factorial(n-i)\\n            \\n            while c < k:\\n                index +=1\\n                k -= c\\n                \\n            ans += str(nums[index])\\n            del nums[index]\\n            \\n        return ans\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 698758,
                "title": "0ms-c-solution-explained",
                "content": "This problem can be solved with recursive approach. \\n\\n### OBSERVATION:\\n* Given n, we\\'ll be having (n-1)! permutations starting with 1, (n-1)! permutations starting with 2, and so on.. So, each block is of size (n-1!).\\n* So, this can be used to find out the first digit of the required sequence. Say, n=4 and k=15, then, k/(n-1!) = 2.5 so, the required permutation will be lying somewhere in the 3rd block. So, the number starts with 3.\\n\\n### APPROACH:\\n* Kth Permutation sequence can be formed by choosing the 1st digit and then the rest of the digits one by one.\\n* We can find the first digit in the sequence, and then apply the same technique to keep finding the first digit of the remaining part of the sequence until the whole sequence is found.\\n\\n### EXAMPLE:\\n*  We can find the first digit in the number and keep updating n and k to find the first digit in the remaining part of the number.\\n*  Say, n=4 and k=15. Now, nums = {1,2,3,4}.  ind = ceil(k/(n-1!) = 3. So, num is 3{}{}{}. \\n*  k = k%(n-1!), n=n-1\\n*  Now, n=3, k=3. nums={1,2,4}. ind = ceil(3/2) = 2. So, num is 32{}{}.\\n*  n=2,k=1, nums={1,4}. ind = ceil(1/2) = 1. So, num is 321{}.\\n*  n=1, k=1, nums = {4}. ind=ceil(1/1)=1. So, nums is 3214.\\n\\n#### NOTE:  \\n* Think about the case when k becomes zero before n. When does this happen? k becomes zero when n-1!=k (coz, k = k%n-1!). This means that this is the last element in the corresponding block, and obviously in this case, the remaining part of the permutation is going to be all the remaining digits arranged in descending order. \\n* eg: n=3,k=2.  \\n\\n### PSEUDOCODE:\\n```  l = {1,2,3,..,N}\\n  result=0\\n   while(k&&n)\\n   {\\n\\t  ind = ceil(k/(n-1!)                            //finding the first digit\\n\\t   result = result*10 + l[ind]           //appending it to result\\n\\t   l.remove(l[ind])                            //removing the found digit from l\\n\\t   k = k%(n-1!)                                  //updating k and n\\n\\t   n = n-1\\n   }\\n   if(k==0)\\n\\t   reverse the list l and append it to result\\n\\treturn result\\n```\\n\\n### MY CODE:\\n```\\nstring getPermutation(int n, int k) {\\n        vector<int> numSet(n);\\n        for(int i=0;i<n;i++)\\n            numSet[i]=i+1;\\n        int fact[10] = {1};\\n        for(int i=1;i<=9;i++)\\n            fact[i] = fact[i-1]*(i);\\n        \\n        int ind,result=0;\\n        while(n&&k)\\n        {\\n            ind = ceil((double)k/fact[n-1]);\\n            result = (result*10)+numSet[ind-1];\\n            numSet.erase(numSet.begin()+(ind-1));\\n            k = k%(fact[n-1]);\\n            n = n-1;\\n        }\\n        if(k==0)\\n        {\\n            int t=numSet.size();\\n            for(int i=t-1;i>=0;i--)\\n                result = (result*10)+numSet[i];       \\n        }\\n        string st;\\n        st = st+to_string(result);\\n        return st;\\n    }\\n```\\n\\nPS: This is not O(n) solution... It takes O(n^2) coz the erase() function of vector will always create a new vector array and copy the original value to it except the erased one...\\n\\n\\n",
                "solutionTags": [],
                "code": "```  l = {1,2,3,..,N}\\n  result=0\\n   while(k&&n)\\n   {\\n\\t  ind = ceil(k/(n-1!)                            //finding the first digit\\n\\t   result = result*10 + l[ind]           //appending it to result\\n\\t   l.remove(l[ind])                            //removing the found digit from l\\n\\t   k = k%(n-1!)                                  //updating k and n\\n\\t   n = n-1\\n   }\\n   if(k==0)\\n\\t   reverse the list l and append it to result\\n\\treturn result\\n```\n```\\nstring getPermutation(int n, int k) {\\n        vector<int> numSet(n);\\n        for(int i=0;i<n;i++)\\n            numSet[i]=i+1;\\n        int fact[10] = {1};\\n        for(int i=1;i<=9;i++)\\n            fact[i] = fact[i-1]*(i);\\n        \\n        int ind,result=0;\\n        while(n&&k)\\n        {\\n            ind = ceil((double)k/fact[n-1]);\\n            result = (result*10)+numSet[ind-1];\\n            numSet.erase(numSet.begin()+(ind-1));\\n            k = k%(fact[n-1]);\\n            n = n-1;\\n        }\\n        if(k==0)\\n        {\\n            int t=numSet.size();\\n            for(int i=t-1;i>=0;i--)\\n                result = (result*10)+numSet[i];       \\n        }\\n        string st;\\n        st = st+to_string(result);\\n        return st;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 696851,
                "title": "python-3-just-a-function-composition-fully-explained",
                "content": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        return \\'\\'.join(next(dropwhile(lambda t: t[0] < k, enumerate(permutations(list(\"123456789\"[0:n])))))[1])\\n```\\n\\nThe solution just get composed from the existing function toolset following the thought train:\\n\\n`list(\"123456789\"[0:n])` elements of a permutation\\n\\n`permutations(list(\"123456789\"[0:n]))` **lazy** sequence of all permutations\\n\\n`enumerate(permutations(list(\"123456789\"[0:n])), start=1)` the same, but now each permutation is wrapped into a tuple with its order number, starting with `1`\\n\\n`dropwhile(lambda t: t[0] < k, enumerate(permutations(list(\"123456789\"[0:n]))))` the same, but with first `k - 1` permutations skipped\\n\\n`next(dropwhile(lambda t: t[0] < k, enumerate(permutations(list(\"123456789\"[0:n])))))` the tuple having number `k` and the associated sought permutation\\n\\n`\\'\\'.join(next(dropwhile(lambda t: t[0] < k, enumerate(permutations(list(\"123456789\"[0:n])))))[1])` converting the permutation from this tuple to string, mission accomplished!\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        return \\'\\'.join(next(dropwhile(lambda t: t[0] < k, enumerate(permutations(list(\"123456789\"[0:n])))))[1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 268361,
                "title": "python-two-solutions-backtracking-40ms-and-math-36ms",
                "content": "Approach 1:  backtracking.\\nfirstly, we permute and count, got one and `k-=1`, when k==0, that is the kth. But it\\'s too slow, consider that, we permute`1234`,  when choose `1`, there are `a = factorial(len(rest))` permutations, if k > a, we don\\'t need permute starts with `1`. And minus the total `a`.\\n\\u6B64\\u9898\\u548C 46.Permutations \\u5F88\\u50CF\\uFF0C\\u4F46\\u662F\\u4F60\\u4E0D\\u80FD\\u5168\\u6392\\u51FA\\u6765\\u518D\\u901A\\u8FC7\\u7D22\\u5F15\\u6C42\\uFF0C\\u90A3\\u6837\\u4F1A\\u8D85\\u65F6\\u3002\\n\\n```python\\ndef getPermutation(self, n: int, k: int) -> str:\\n    self.k = k\\n    \\n    def backtrack(s, rest):\\n        if not rest:\\n            self.k -= 1\\n            if self.k == 0:\\n                return s\\n            return \\'\\'\\n            \\n        for i in range(len(rest)):\\n            if self.k > math.factorial(len(rest)-1):\\n                self.k -= math.factorial(len(rest)-1)\\n                continue\\n            old = s\\n            s += rest[i]\\n            ans = backtrack(s, rest[:i]+rest[i+1:])\\n            if ans: return ans\\n            s = old\\n        return \\'\\'\\n    nums = list(map(str, range(1, n+1)))\\n    return backtrack(\\'\\', nums)\\n```\\n\\nApproach 2:  math\\n\\n```python\\ndef getPermutation(self, n: int, k: int) -> str:\\n    ans = \\'\\'\\n    nums = list(map(str, range(1, n+1)))\\n    fact = math.factorial(len(nums)-1)\\n    k -= 1\\n    while k:\\n        i, k = divmod(k, fact)\\n        ans += nums.pop(i)\\n        fact //= len(nums)            \\n    ans += \\'\\'.join(nums)\\n    return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Backtracking"
                ],
                "code": "```python\\ndef getPermutation(self, n: int, k: int) -> str:\\n    self.k = k\\n    \\n    def backtrack(s, rest):\\n        if not rest:\\n            self.k -= 1\\n            if self.k == 0:\\n                return s\\n            return \\'\\'\\n            \\n        for i in range(len(rest)):\\n            if self.k > math.factorial(len(rest)-1):\\n                self.k -= math.factorial(len(rest)-1)\\n                continue\\n            old = s\\n            s += rest[i]\\n            ans = backtrack(s, rest[:i]+rest[i+1:])\\n            if ans: return ans\\n            s = old\\n        return \\'\\'\\n    nums = list(map(str, range(1, n+1)))\\n    return backtrack(\\'\\', nums)\\n```\n```python\\ndef getPermutation(self, n: int, k: int) -> str:\\n    ans = \\'\\'\\n    nums = list(map(str, range(1, n+1)))\\n    fact = math.factorial(len(nums)-1)\\n    k -= 1\\n    while k:\\n        i, k = divmod(k, fact)\\n        ans += nums.pop(i)\\n        fact //= len(nums)            \\n    ans += \\'\\'.join(nums)\\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 22539,
                "title": "java-recursive-and-iterative",
                "content": "Iterative:\\n```\\n    public String getPermutation(int n, int k) {\\n        \\n        // e.g n = 5\\n        // [1][1][2][6][24]\\n        int[] factorial = new int[n];\\n        factorial[0] = 1;\\n        \\n        for(int i = 1; i < n; i++) {\\n            factorial[i] = factorial[i-1] * i;\\n        }\\n        \\n        ArrayList<Integer> numbers = new ArrayList<>();\\n        for(int i = 1; i <= n; i++) {\\n            numbers.add(i);\\n        }\\n        \\n        String res = \"\";\\n        for(int i = n-1; i >= 0; i--) {\\n            \\n            int num = (k-1)/factorial[i];\\n            res += numbers.get(num);\\n            k -= num * factorial[i];\\n            numbers.remove(num);\\n        }\\n        \\n        return res;\\n    }\\n```\\n\\nRecursive:\\n```\\n    public String getPermutation(int n, int k) {\\n        \\n        // recursive\\n        // how do you make the problem smaller?\\n        List<Integer> list = new ArrayList<>();\\n        // 1,1,2,6\\n        int[] factorials = new int[n];\\n        factorials[0] = 1;\\n        for(int i = 1; i < n; i++) {\\n            factorials[i] = factorials[i-1] * i;\\n        }\\n        \\n        for(int i = 1; i <= n; i++) {\\n            list.add(i);\\n        }\\n        \\n        return helper(list, k, factorials);\\n    }\\n    \\n    private String helper(List<Integer> list, int k, int[] factorials) {\\n        \\n        if(list.size() == 0) {\\n            return \"\";\\n        }\\n\\n        int num = (k-1)/factorials[list.size()-1];\\n        String str = \"\" + list.get(num);\\n        k -= num * factorials[list.size()-1];\\n        list.remove(num);\\n\\n        return str+helper(list, k, factorials);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String getPermutation(int n, int k) {\\n        \\n        // e.g n = 5\\n        // [1][1][2][6][24]\\n        int[] factorial = new int[n];\\n        factorial[0] = 1;\\n        \\n        for(int i = 1; i < n; i++) {\\n            factorial[i] = factorial[i-1] * i;\\n        }\\n        \\n        ArrayList<Integer> numbers = new ArrayList<>();\\n        for(int i = 1; i <= n; i++) {\\n            numbers.add(i);\\n        }\\n        \\n        String res = \"\";\\n        for(int i = n-1; i >= 0; i--) {\\n            \\n            int num = (k-1)/factorial[i];\\n            res += numbers.get(num);\\n            k -= num * factorial[i];\\n            numbers.remove(num);\\n        }\\n        \\n        return res;\\n    }\\n```\n```\\n    public String getPermutation(int n, int k) {\\n        \\n        // recursive\\n        // how do you make the problem smaller?\\n        List<Integer> list = new ArrayList<>();\\n        // 1,1,2,6\\n        int[] factorials = new int[n];\\n        factorials[0] = 1;\\n        for(int i = 1; i < n; i++) {\\n            factorials[i] = factorials[i-1] * i;\\n        }\\n        \\n        for(int i = 1; i <= n; i++) {\\n            list.add(i);\\n        }\\n        \\n        return helper(list, k, factorials);\\n    }\\n    \\n    private String helper(List<Integer> list, int k, int[] factorials) {\\n        \\n        if(list.size() == 0) {\\n            return \"\";\\n        }\\n\\n        int num = (k-1)/factorials[list.size()-1];\\n        String str = \"\" + list.get(num);\\n        k -= num * factorials[list.size()-1];\\n        list.remove(num);\\n\\n        return str+helper(list, k, factorials);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 22610,
                "title": "share-my-0ms-c-solution-with-explanation",
                "content": "The question is:\\n\\nThe **set *[1,2,3,\\u2026,n]*** contains a total of ***n !*** ***unique* permutations**.\\n\\nBy listing and labeling all of the permutations ***in order***,\\nWe get the following sequence (ie, for ***n = 3***):\\n\\n - 1  \"***1*** 23\"\\n - 2  \"***1*** 32\"\\n - 3  \"***2*** 13\"\\n - 4  \"***2*** 31\"\\n - 5  \"***3*** 12\"\\n - 6  \"***3*** 21\"\\n\\nGiven ***n*** and ***k***, return the ***kth*** permutation sequence.\\n\\n**IMPORTANT : note the equation *N ! = N \\xd7 (N - 1) !***\\n\\nHere, ***3 ! = 3 \\xd7 2 !***, Let's get into the problem when ***n = 3***.\\n\\n***First***, we need to get the ***TOP DIGIT***. As listed above, the ***TOP DIGIT*** can be ***1, 2 or 3***.\\n\\n***1st*** and ***2nd*** 's ***TOP DIGIT*** is ***1***.\\n\\n***3rd*** and ***4th*** 's ***TOP DIGIT*** is ***2***.\\n\\n***5th*** and ***6th*** 's ***TOP DIGIT*** is ***3***.\\n\\nThe total ***n !*** is divided into ***3 parts***.\\n\\nDo you find some ***regularities*** when ***n = 3***?\\n\\nIf not, we can ***minus k by 1***, set p = k - 1, and then? \\n\\n - If ***p / (n - 1) ! = 0 (k = 1 and 2)*** , ***TOP DIGIT*** is ***1***.\\n - If ***p/ (n - 1) ! = 1 (k = 3 and 4)*** , ***TOP DIGIT*** is ***2***.\\n - If ***p / (n - 1) ! = 2 (k = 5 and 6)*** , ***TOP DIGIT*** is ***3***.\\n\\nAnd this is the ***FIRST RULE***. \\n\\n----------\\n## FIRST RULE ##\\n\\n***n !*** can be ***DIVIDED*** into ***n PARTS***, and the ***TOP DIGIT*** of ***pth (starts with 0) PART*** equals to ***p / (n - 1) ! + 1***\\n\\n----------\\n**Q** : how about the ***REST***?\\n\\n**A** : If the ***FIRST TOP DIGIT*** is determined, the same method can be used to find the ***SECOND TOP DIGIT***, and the ***THIRD TOP DIGIT ......***, but a little bit ***DIFFERENT***.\\n\\nFor example, if the ***FIRST TOP DIGIT A0*** is determined, \\n\\nthe total number of ***unique* permutations *STARTS WITH A0*** is ***(n - 1) !***.\\n\\nAs the ***FIRST RULE***, ***(n - 1) !*** can be ***DIVIDED*** into ***n - 1 PARTS***, and the ***TOP DIGIT*** of ***p' th PART*** equals to ***p'   / (n - 2) ! + 1***\\n\\n**NOTICE**: here ***p'*** is the **INTERNAL** sequence number of the unique permutations which ***starts with A0***\\n\\n----------\\n## SECOND RULE ##\\n\\n***p'*** is ***p*** in the ***SECOND ROUND***, and ***p' = p % (n - 1) !***\\n\\nWe can find the ***SECOND TOP DIGIT A1*** by calculate ***p' / (n - 2) ! + 1***,\\n\\nand ***p*** in the ***THIRD ROUND*** is ***p''***, and ***p'' = p' % (n - 2) !***\\n\\n***..............................***\\n\\nThis is the ***SECOND RULE***.\\n\\n----------\\n**Q** : Which number will be used as ***A0, A1, ...* (the *TOP DIGITS*)**?\\n\\n**A** : At the ***FIRST ROUND***, ***TOP DIGIT A0*** equals to  ***p / (n - 1) ! + 1***.\\n\\nWhen a number in [1,9] is ***USED*** as ***A0***, \\n\\nwe need to find the ***p' / (n - 2) ! + 1* SMALLEST** number in the ***REST*** to be ***A1***,\\n\\nand we need to find the ***p'' / (n - 3) ! + 1* SMALLEST** number in the ***REST*** to be ***A2***,\\n\\n***...................................***\\n\\n**IMPORTANCE** : To get this, a **size of *9 VECTOR*** should be set as a ***GLOBAL VARIABLE*** (or ***DATA MEMBER***), and let its ***q th*** element to be ***q + 1***\\n\\nNo matter which number is removed from the vector, its ***q th*** element will ***ALWAYS*** be the ***q th*** ***SMALLEST*** of the rest.\\n\\n----------\\n**Q** : When will the loop ***STOPs***?\\n\\n**A** : Each round we calculate ***p(m) = p(m - 1) % (n - m) !***,\\n\\nand there are ***n - m* *DIGITs*** which are **NOT** determined.\\n\\nIf ***n - m = 2***, there will be ***2* *DIGITs*** which are **NOT** determined,\\n\\nwhich means there are ***ONLY 2*** numbers left in the ***VECTOR***.\\n\\nNow, we can directly set the ***LAST DIGIT*** and the ***2nd LAST DIGIT***.\\n\\nWhen ***n - m = 2***, if p(m) = 0, the ***SMALLER of the two (A0A1...AB and A0A1...BA)*** will be returned,\\n\\nso ***LAST DIGIT*** is set as the ***1st element of the vector*** and the ***2nd LAST DIGIT*** the ***0th***.\\n\\nif p(m) = 1, the ***LARGER of the two (A0A1...AB and A0A1...BA)*** will be returned,\\n\\nso ***LAST DIGIT*** is set as the ***0th element of the vector*** and the ***2nd LAST DIGIT*** the ***1st***.\\n\\n----------\\n\\n***My code:***\\n\\n    class Solution {\\n    public:\\n\\n    int factorial(int n)\\n    {\\n        if(n == 1) return 1;\\n        return n * factorial(n - 1);\\n    }\\n\\n    void numberStrList(int n)\\n    {\\n           rtn = string (n, '0');\\n           record = vector<int>(n,1);\\n           for(int i = 0; i < record.size(); i++)\\n           {\\n                 record[i] += i;\\n           }\\n    }\\n\\n    string getPermutation(int n, int k) {\\n        numberStrList(n);\\n        //start from 0\\n        k = k - 1;\\n        \\n        if(n == 1)\\n        {\\n             if(k == 0)\\n             {\\n                 return \"1\";\\n             }\\n             return \"\";\\n        }\\n        for(int i = 1; i < n - 1; i++)\\n        {\\n              rtn[i - 1] += record[k / factorial(n - i)];\\n              record.erase (record.begin() + k / factorial(n - i));\\n              k = k % factorial(n - i);\\n        }\\n        rtn[n - 2] += record[k^0];\\n        rtn[n - 1] += record[k^1];\\n        return rtn;\\n      }\\n     private:\\n     vector<int> record;\\n     string rtn;\\n     };",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "class Solution {\\n    public:\\n\\n    int factorial(int n)\\n    {\\n        if(n == 1) return 1;\\n        return n * factorial(n - 1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 22605,
                "title": "python-i-think-this-is-clean-code-with-some-of-my-explanation",
                "content": "If we have n numbers then the total combinations would be factorial(n) which means same starting number should have (n - 1)! sequences.  \\n\\nIf we do k mod (n - 1)! then we can get the corresponding starting number and append to the result.\\n\\nNote that we need to maintain another array to mark visited numbers(I take remove to make sure we will not revisit the number again, each remove takes O(n) time )\\n\\nThe total time complexity would be O(n^2).\\n\\n    class Solution(object):\\n        def getPermutation(self, n, k):\\n            \"\"\"\\n            :type n: int\\n            :type k: int\\n            :rtype: str\\n            \"\"\"\\n            nums = map(str, range(1, 10))\\n            k -= 1\\n            factor = 1\\n            for i in range(1, n):\\n                factor *= i\\n            res = []\\n            for i in reversed(range(n)):\\n                res.append(nums[k / factor])\\n                nums.remove(nums[k / factor])\\n                if i != 0:\\n                    k %= factor\\n                    factor /= i\\n            return \"\".join(res)",
                "solutionTags": [],
                "code": "If we have n numbers then the total combinations would be factorial(n) which means same starting number should have (n - 1)! sequences.  \\n\\nIf we do k mod (n - 1)! then we can get the corresponding starting number and append to the result.\\n\\nNote that we need to maintain another array to mark visited numbers(I take remove to make sure we will not revisit the number again, each remove takes O(n) time )\\n\\nThe total time complexity would be O(n^2).\\n\\n    class Solution(object):\\n        def getPermutation(self, n, k):\\n            \"\"\"\\n            :type n: int\\n            :type k: int\\n            :rtype: str\\n            \"\"\"\\n            nums = map(str, range(1, 10))\\n            k -= 1\\n            factor = 1\\n            for i in range(1, n):\\n                factor *= i\\n            res = []\\n            for i in reversed(range(n)):\\n                res.append(nums[k / factor])\\n                nums.remove(nums[k / factor])\\n                if i != 0:\\n                    k %= factor\\n                    factor /= i\\n            return \"\".join(res)",
                "codeTag": "Java"
            },
            {
                "id": 22633,
                "title": "easy-to-understand-solution-with-sample",
                "content": "    class Solution {\\n        int getPermutationNumber(int n) {\\n            int result = 1;\\n            for(int i=1;i<=n;++i) {\\n                result *=i;\\n            }\\n            \\n            return result;\\n        }\\n        \\n    public:\\n        string getPermutation(int n, int k) {\\n            // 1234, 1243, 1324, 1342, 1423,1432,\\n            // n*(n-1)!\\n            // k/(n-1)!\\n            // k= k%(n-1)!\\n            // 123: n=3, k=4  => k=4-1 (for indexing from 0)\\n            // 3/(2!)=1, head[1]==2, k%(2!) = 1\\n            // 1/(1!)=1, head[1]==3, k%(1!) = 0\\n            // 0/(0!)=0, head[0]=1\\n            vector<int> result;        \\n            vector<int> nums;\\n            for(int i=1;i<=n;++i) {\\n                nums.push_back(i);\\n            }\\n            \\n            k=k-1;\\n            for(int i=0;i<n;++i) {\\n                int perms = getPermutationNumber(n-1-i);\\n                int index = k/perms;\\n                result.push_back(nums[index]);\\n                k%=perms;\\n                nums.erase(nums.begin()+index);\\n            }\\n            \\n            string s=\"\";\\n            for(int i=0;i<result.size();++i) {\\n                s += std::to_string(result[i]);\\n            }\\n            \\n            return s;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        int getPermutationNumber(int n) {\\n            int result = 1;\\n            for(int i=1;i<=n;++i) {\\n                result *=i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3473883,
                "title": "after-looking-this-you-won-t-belive-this-is-hard",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/057ba9ba-66e9-4bf2-9008-3b80680d7aca_1682949102.7328444.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        \\n        int fact = 1; // initialize a variable to store the factorial of n\\n\\n        List<Integer> numbers = new ArrayList<>(); // create a list to store the numbers from 1 to n\\n\\n        // calculate the factorial of n and add numbers from 1 to n to the list\\n        for(int i = 1; i < n; i++){\\n            fact = fact * i;\\n            numbers.add(i);\\n        }\\n        numbers.add(n);\\n\\n        String ans = \"\"; // initialize an empty string to store the answer\\n\\n        k = k - 1; // since indexing starts from 0, subtract 1 from k\\n\\n        // loop until all numbers have been used\\n        while(true){\\n            ans = ans + numbers.get(k / fact); // add the number at index    k/fact    to the answer\\n            numbers.remove(k / fact); // remove the used number from the list\\n\\n            // if all numbers have been used, break out of the loop\\n            if(numbers.size() == 0){\\n                break;\\n            }\\n\\n            k = k % fact; // calculate the remainder of    k/fact    and assign it to k\\n            fact = fact / numbers.size(); // divide the factorial by the size of the remaining list\\n        }\\n        return ans; // return the answer\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        \\n        int fact = 1; // initialize a variable to store the factorial of n\\n\\n        List<Integer> numbers = new ArrayList<>(); // create a list to store the numbers from 1 to n\\n\\n        // calculate the factorial of n and add numbers from 1 to n to the list\\n        for(int i = 1; i < n; i++){\\n            fact = fact * i;\\n            numbers.add(i);\\n        }\\n        numbers.add(n);\\n\\n        String ans = \"\"; // initialize an empty string to store the answer\\n\\n        k = k - 1; // since indexing starts from 0, subtract 1 from k\\n\\n        // loop until all numbers have been used\\n        while(true){\\n            ans = ans + numbers.get(k / fact); // add the number at index    k/fact    to the answer\\n            numbers.remove(k / fact); // remove the used number from the list\\n\\n            // if all numbers have been used, break out of the loop\\n            if(numbers.size() == 0){\\n                break;\\n            }\\n\\n            k = k % fact; // calculate the remainder of    k/fact    and assign it to k\\n            fact = fact / numbers.size(); // divide the factorial by the size of the remaining list\\n        }\\n        return ans; // return the answer\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091157,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        vector<int> v;\\n        for(int i=1;i<=n;i++)\\n        {\\n            v.push_back(i);\\n            if(i!=n)\\n            fact*=i;\\n        }\\n        k-=1;\\n        string s;\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=k/fact;\\n            k%=fact;\\n            if(n-i-1)\\n            fact/=(n-i-1);\\n            s+=(\\'0\\'+v[j]);\\n            v.erase(v.begin()+j);\\n        }\\n        return s;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        vector<int> v;\\n        for(int i=1;i<=n;i++)\\n        {\\n            v.push_back(i);\\n            if(i!=n)\\n            fact*=i;\\n        }\\n        k-=1;\\n        string s;\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=k/fact;\\n            k%=fact;\\n            if(n-i-1)\\n            fact/=(n-i-1);\\n            s+=(\\'0\\'+v[j]);\\n            v.erase(v.begin()+j);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013753,
                "title": "easy-solution-by-using-stl-permutation-sequence",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        \\n        string s;\\n        for(int i=1; i<=n; i++){\\n            s+=to_string(i);\\n        }\\n         vector<string>ans;\\n        do\\n        {\\n            ans.push_back(s);\\n        }while(next_permutation(s.begin(),s.end()));\\n        return ans[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        \\n        string s;\\n        for(int i=1; i<=n; i++){\\n            s+=to_string(i);\\n        }\\n         vector<string>ans;\\n        do\\n        {\\n            ans.push_back(s);\\n        }while(next_permutation(s.begin(),s.end()));\\n        return ans[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2376420,
                "title": "c-solution-4-approaches-stl-backtracking-iterative-recursion",
                "content": "**1st Appraoch\\n(USING STL - next_permutation)**\\n```\\n\\tstring getPermutation(int n, int k) {\\n        string s;\\n        for( int i=1; i<=n; i++)\\n            s.push_back( i+\\'0\\');\\n        \\n        while( k!=1){\\n            next_permutation(s.begin(), s.end());\\n            k--;\\n        }\\n        return s;\\n    }\\n```\\n\\n***2nd Approach- Backtracking (TLE)***\\n```\\n\\tvoid permut( string &s, int ind, set<string> &s1){\\n        if( ind == s.size()){\\n            s1.insert(s);\\n            return;\\n        }\\n        \\n        for( int i=ind; i<s.size(); i++){\\n            swap( s[i], s[ind]);\\n            permut( s, ind+1, s1);\\n            swap( s[i], s[ind]);\\n        }\\n    }\\n    string getPermutation(int n, int k) {\\n        string s;\\n        for( int i=1; i<n+1; i++) s.push_back( i+\\'0\\');\\n        set<string> s1;\\n        permut( s, 0, s1);\\n        for( auto i: s1){\\n            if( k==1){\\n                return i;\\n            }\\n            --k;\\n        }\\n        return \"\";\\n    }\\n```\\n\\n***Optimal Approach (  RECURSIVE)***\\n```\\n    void solve( int fact, vector<int> & v, int k, string &s){\\n        if( v.size()==0){\\n            return ;    \\n        }\\n        \\n        s = s+ to_string(v[k/fact]);\\n        v.erase(v.begin() + k/fact);\\n        if( v.size()!=0)\\n            solve( fact/v.size(), v, k%fact, s);\\n    }\\n    string getPermutation(int n, int k) {\\n        //calculating the factorial of n-1 numbers and making an array of numbers 1->n\\n        int fact =1;\\n        vector<int> v;\\n        for( int i=1; i<n;i++){\\n            fact *= i;\\n            v.push_back(i);\\n        }v.push_back(n);\\n        k= k-1; //for 0-based indexing\\n        string s =\"\";\\n        solve( fact, v, k, s);\\n        return s;\\n    }\\n```\\n\\n***Optimal Approach (Iterative)***\\n```\\nstring getPermutation(int n, int k) {\\n        //calculating the factorial of n-1 numbers and making an array of numbers 1->n\\n        int fact =1;\\n        vector<int> v;\\n        for( int i=1; i<n;i++){\\n            fact *= i;\\n            v.push_back(i);\\n        }v.push_back(n);\\n        k= k-1; //for 0-based indexing\\n        string s =\"\";\\n        while( true){\\n            s += to_string( v[ k/fact]);\\n            v.erase( v.begin()+ k/fact);\\n             k= k%fact;\\n            if( v.size()==0) break;\\n            fact /=v.size();\\n            \\n        }\\n       \\n        return s;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n\\tstring getPermutation(int n, int k) {\\n        string s;\\n        for( int i=1; i<=n; i++)\\n            s.push_back( i+\\'0\\');\\n        \\n        while( k!=1){\\n            next_permutation(s.begin(), s.end());\\n            k--;\\n        }\\n        return s;\\n    }\\n```\n```\\n\\tvoid permut( string &s, int ind, set<string> &s1){\\n        if( ind == s.size()){\\n            s1.insert(s);\\n            return;\\n        }\\n        \\n        for( int i=ind; i<s.size(); i++){\\n            swap( s[i], s[ind]);\\n            permut( s, ind+1, s1);\\n            swap( s[i], s[ind]);\\n        }\\n    }\\n    string getPermutation(int n, int k) {\\n        string s;\\n        for( int i=1; i<n+1; i++) s.push_back( i+\\'0\\');\\n        set<string> s1;\\n        permut( s, 0, s1);\\n        for( auto i: s1){\\n            if( k==1){\\n                return i;\\n            }\\n            --k;\\n        }\\n        return \"\";\\n    }\\n```\n```\\n    void solve( int fact, vector<int> & v, int k, string &s){\\n        if( v.size()==0){\\n            return ;    \\n        }\\n        \\n        s = s+ to_string(v[k/fact]);\\n        v.erase(v.begin() + k/fact);\\n        if( v.size()!=0)\\n            solve( fact/v.size(), v, k%fact, s);\\n    }\\n    string getPermutation(int n, int k) {\\n        //calculating the factorial of n-1 numbers and making an array of numbers 1->n\\n        int fact =1;\\n        vector<int> v;\\n        for( int i=1; i<n;i++){\\n            fact *= i;\\n            v.push_back(i);\\n        }v.push_back(n);\\n        k= k-1; //for 0-based indexing\\n        string s =\"\";\\n        solve( fact, v, k, s);\\n        return s;\\n    }\\n```\n```\\nstring getPermutation(int n, int k) {\\n        //calculating the factorial of n-1 numbers and making an array of numbers 1->n\\n        int fact =1;\\n        vector<int> v;\\n        for( int i=1; i<n;i++){\\n            fact *= i;\\n            v.push_back(i);\\n        }v.push_back(n);\\n        k= k-1; //for 0-based indexing\\n        string s =\"\";\\n        while( true){\\n            s += to_string( v[ k/fact]);\\n            v.erase( v.begin()+ k/fact);\\n             k= k%fact;\\n            if( v.size()==0) break;\\n            fact /=v.size();\\n            \\n        }\\n       \\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 738232,
                "title": "c-math-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) \\n    {\\n        int fact[10] = {1,1,2,6,24,120,720,5040,40320,362880};\\n        string ans=\"\";\\n        string num=\"123456789\";\\n        k--;\\n        for(int i=n; i>0; i--)\\n        {\\n            int j=k/fact[i-1];\\n            k = k%fact[i-1];\\n            ans += num[j];\\n            num.erase(num.begin()+j);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) \\n    {\\n        int fact[10] = {1,1,2,6,24,120,720,5040,40320,362880};\\n        string ans=\"\";\\n        string num=\"123456789\";\\n        k--;\\n        for(int i=n; i>0; i--)\\n        {\\n            int j=k/fact[i-1];\\n            k = k%fact[i-1];\\n            ans += num[j];\\n            num.erase(num.begin()+j);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697280,
                "title": "java-clean-code-o-n-time-complexity-0-ms-time-98-57-faster",
                "content": "```\\nclass Solution {\\n \\n\\tpublic String getPermutation (int n, int k) {\\n\\t\\n\\t\\tint[] factorial = new int[n];\\n\\t\\tList<Integer> nums = new ArrayList<>();\\n\\t\\t\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tnums.add (i + 1);\\n\\t\\t\\tfactorial[i] = i == 0 ? 1 : i * factorial[i - 1];\\n\\t\\t}\\n\\t\\t\\n\\t\\tStringBuilder ans = new StringBuilder ();\\n\\t\\twhile (n-- != 0) {\\n\\t\\t\\tans.append (nums.remove ((k - 1) / factorial[n]));\\n\\t\\t\\tk = (k - 1) % factorial[n] + 1;\\n\\t\\t}\\n\\t\\n\\t\\treturn ans.toString ();\\n\\t}\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n \\n\\tpublic String getPermutation (int n, int k) {\\n\\t\\n\\t\\tint[] factorial = new int[n];\\n\\t\\tList<Integer> nums = new ArrayList<>();\\n\\t\\t\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tnums.add (i + 1);\\n\\t\\t\\tfactorial[i] = i == 0 ? 1 : i * factorial[i - 1];\\n\\t\\t}\\n\\t\\t\\n\\t\\tStringBuilder ans = new StringBuilder ();\\n\\t\\twhile (n-- != 0) {\\n\\t\\t\\tans.append (nums.remove ((k - 1) / factorial[n]));\\n\\t\\t\\tk = (k - 1) % factorial[n] + 1;\\n\\t\\t}\\n\\t\\n\\t\\treturn ans.toString ();\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696369,
                "title": "1ms-easy-to-understand-solution",
                "content": "```\\npublic String getPermutation(int n, int k) {\\n       List<Integer> num = new LinkedList<Integer>();\\n        for (int i = 1; i <= n; i++) \\n        \\tnum.add(i);\\n        int[] fact = new int[n];  // factorial\\n        fact[0] = 1;\\n        for (int i = 1; i < n; i++) \\n        \\tfact[i] = i*fact[i-1];\\n        k = k-1;\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = n; i > 0; i--){\\n            int ind = k/fact[i-1];\\n            k = k%fact[i-1];\\n            sb.append(num.get(ind));\\n            num.remove(ind);\\n        }\\n        return sb.toString(); \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String getPermutation(int n, int k) {\\n       List<Integer> num = new LinkedList<Integer>();\\n        for (int i = 1; i <= n; i++) \\n        \\tnum.add(i);\\n        int[] fact = new int[n];  // factorial\\n        fact[0] = 1;\\n        for (int i = 1; i < n; i++) \\n        \\tfact[i] = i*fact[i-1];\\n        k = k-1;\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = n; i > 0; i--){\\n            int ind = k/fact[i-1];\\n            k = k%fact[i-1];\\n            sb.append(num.get(ind));\\n            num.remove(ind);\\n        }\\n        return sb.toString(); \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 431424,
                "title": "simple-java-solution-using-backtracking",
                "content": "```\\npublic String getPermutation(int n, int k) {\\n        List<String> result = new ArrayList<>();\\n        recursion(result,\"\", n, k,new boolean[n+1]);\\n        return result.get(k-1);\\n    }\\n    \\nprivate void recursion(List<String> result, String temp, int max, int k, boolean[] seen){\\n        \\n        if(temp.length()==max){\\n            result.add(new String(temp));\\n        }else{\\n            for(int i =1;i<=max;i++){\\n                if(result.size()==k)break;\\n                if(seen[i]) continue;\\n                seen[i] =true;\\n                String newStr = temp+i;\\n                recursion(result,newStr,max,k,seen);\\n                seen[i] = false;\\n            }\\n        }\\n}\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\npublic String getPermutation(int n, int k) {\\n        List<String> result = new ArrayList<>();\\n        recursion(result,\"\", n, k,new boolean[n+1]);\\n        return result.get(k-1);\\n    }\\n    \\nprivate void recursion(List<String> result, String temp, int max, int k, boolean[] seen){\\n        \\n        if(temp.length()==max){\\n            result.add(new String(temp));\\n        }else{\\n            for(int i =1;i<=max;i++){\\n                if(result.size()==k)break;\\n                if(seen[i]) continue;\\n                seen[i] =true;\\n                String newStr = temp+i;\\n                recursion(result,newStr,max,k,seen);\\n                seen[i] = false;\\n            }\\n        }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 348350,
                "title": "java-solution-with-explanation",
                "content": "I was searching for proper answer got explanation in the below link.  I just added code and improved on explanation\\ncourtesy : https://www.lintcode.com/problem/permutation-sequence/note/187602\\nSince we need to fix one position each time me need next we need to get permutations for (n-1)!\\n\\n\\nwhen n = 4, the list is 1, 2, 3, 4 and k = 18\\nthe total number of permutations is\\nrow1: 1 + {2, 3, 4}: 1234, 1243, 1324, 1342, 1423, 1432\\n==> 3! = 6 (factor) (from 0 to 5)\\nrow2: 2 + {1, 3, 4}: 2134, 2143, 2314, 2341, 2413, 2431\\n==> 3! = 6 (from 6 to 11)\\nrow3: 3 + {1, 2, 4}: 3! (from 12 to 17)\\nrow4: 4 + {1, 2, 3}: 3! (from 18 to 23)\\nwhen k = 18, it means find the item from 0, then 17th is the permutation we want.\\n\\nSince K =18 means we need to go to 17th index \\nso \\nK--\\n\\nFind out the number on each position\\nwhile i = n = 4\\nlist: 1,2,3,4\\nindex = (k - 1)/ (i - 1)! = 17/6 = 2. index 2 means it is row3 beginning with 3, then remove 3 from the list {1,2,3,4}, then the list becomes {1,2,4}. update k = (k-1) % 6 = 5.**** Add 3 to output.****\\n\\nWhen n = 3 \\nrow 1 \\n1,2,4\\n1,4,2\\n\\nrow 2\\n2,1,4\\n2,4,1\\n\\nrow 3\\n4,1,2\\n4,2,1\\n\\nwhile i = n = 3, k = 5\\nlist: 1, 2, 4\\nindex = k / (i - 1)! = 5/2 = 2. index 2 means it is row3 beginning with 4, then remove 4 from the list {1, 2, 4}, then the list becomes {1, 4}. update k = k % 2 = 1. **** Add 4 to output.****\\n\\nWhen n = 2\\n1,2\\n\\nwhile i = n = 2, k = 1\\nlist: 1,2\\nindex = k/(i-1)! = 1/1 = 1. index 1 means it is row2 beginning with 2, then remove 2 from the list {1, 2}, then the list becomes {1}. update k = k % 1 = 0. Add 2 to the output.\\n\\nWhen n = 1\\n\\n1\\nwhile i = n = 1, k = 0\\nindex = 0, index 0 means it is row1 beginning with 1. Add 1 to the output\\n\\nEventually, the output is 3421\\n\\nWhy to Divide by Factorial ? \\n\\nThink about a simple case where you are finding the digits of a decimal number e.g. 4836. You can compute rightmost place by dividing 4836 by 1 then modulo 10 to get 6. Then 4836 by 10 modulo 10 to get 3, then 4836 by 100 modulo 10 to get 8 etc. We don\\'t need to change the number 4836 each time. Permutation case is similar but we use factorials instead of powers of 10 and modulus value changes.\\n\\nhttps://stackoverflow.com/questions/31216097/given-n-and-k-return-the-kth-permutation-sequence\\n\\nprivate  String getPermutation3(int n, int k) {\\n\\n        List<Integer> list = new ArrayList<>();\\n\\n        for(int i =1; i <= n ; i++){\\n            list.add(i);\\n        }\\n\\n        int[] fact = new int[n];\\n\\n       // Since we cannot divide a number by 0 we are fixing index 0 to 1\\n        fact[0] =1;\\n\\n        // Storing factorials for (n-1)!\\n\\n        for(int i = 1; i < n; i++){\\n            fact[i] = i*fact[i-1];\\n        }\\n        // if position is 3 we need index 2 so k--\\n       k--;\\n\\n        String s = \"\";\\n\\n        // We are coming from back as we need to get the position of character for (n-1)! and we have put factorial in\\n        // increasing order in our factorial array so to get last character we need to come from reverse\\n\\n        for(int i = n-1; i >=0 ; i--){\\n\\n            int index = k/fact[i];\\n\\n            s = s+ list.remove(index);\\n    // To go to next index\\n            k = k%fact[i];\\n        }\\n        return s;\\n    }\\n\\t\\n\\tHope This helps",
                "solutionTags": [],
                "code": "I was searching for proper answer got explanation in the below link.  I just added code and improved on explanation\\ncourtesy : https://www.lintcode.com/problem/permutation-sequence/note/187602\\nSince we need to fix one position each time me need next we need to get permutations for (n-1)!\\n\\n\\nwhen n = 4, the list is 1, 2, 3, 4 and k = 18\\nthe total number of permutations is\\nrow1: 1 + {2, 3, 4}: 1234, 1243, 1324, 1342, 1423, 1432\\n==> 3! = 6 (factor) (from 0 to 5)\\nrow2: 2 + {1, 3, 4}: 2134, 2143, 2314, 2341, 2413, 2431\\n==> 3! = 6 (from 6 to 11)\\nrow3: 3 + {1, 2, 4}: 3! (from 12 to 17)\\nrow4: 4 + {1, 2, 3}: 3! (from 18 to 23)\\nwhen k = 18, it means find the item from 0, then 17th is the permutation we want.\\n\\nSince K =18 means we need to go to 17th index \\nso \\nK--\\n\\nFind out the number on each position\\nwhile i = n = 4\\nlist: 1,2,3,4\\nindex = (k - 1)/ (i - 1)! = 17/6 = 2. index 2 means it is row3 beginning with 3, then remove 3 from the list {1,2,3,4}, then the list becomes {1,2,4}. update k = (k-1) % 6 = 5.**** Add 3 to output.****\\n\\nWhen n = 3 \\nrow 1 \\n1,2,4\\n1,4,2\\n\\nrow 2\\n2,1,4\\n2,4,1\\n\\nrow 3\\n4,1,2\\n4,2,1\\n\\nwhile i = n = 3, k = 5\\nlist: 1, 2, 4\\nindex = k / (i - 1)! = 5/2 = 2. index 2 means it is row3 beginning with 4, then remove 4 from the list {1, 2, 4}, then the list becomes {1, 4}. update k = k % 2 = 1. **** Add 4 to output.****\\n\\nWhen n = 2\\n1,2\\n\\nwhile i = n = 2, k = 1\\nlist: 1,2\\nindex = k/(i-1)! = 1/1 = 1. index 1 means it is row2 beginning with 2, then remove 2 from the list {1, 2}, then the list becomes {1}. update k = k % 1 = 0. Add 2 to the output.\\n\\nWhen n = 1\\n\\n1\\nwhile i = n = 1, k = 0\\nindex = 0, index 0 means it is row1 beginning with 1. Add 1 to the output\\n\\nEventually, the output is 3421\\n\\nWhy to Divide by Factorial ? \\n\\nThink about a simple case where you are finding the digits of a decimal number e.g. 4836. You can compute rightmost place by dividing 4836 by 1 then modulo 10 to get 6. Then 4836 by 10 modulo 10 to get 3, then 4836 by 100 modulo 10 to get 8 etc. We don\\'t need to change the number 4836 each time. Permutation case is similar but we use factorials instead of powers of 10 and modulus value changes.\\n\\nhttps://stackoverflow.com/questions/31216097/given-n-and-k-return-the-kth-permutation-sequence\\n\\nprivate  String getPermutation3(int n, int k) {\\n\\n        List<Integer> list = new ArrayList<>();\\n\\n        for(int i =1; i <= n ; i++){\\n            list.add(i);\\n        }\\n\\n        int[] fact = new int[n];\\n\\n       // Since we cannot divide a number by 0 we are fixing index 0 to 1\\n        fact[0] =1;\\n\\n        // Storing factorials for (n-1)!\\n\\n        for(int i = 1; i < n; i++){\\n            fact[i] = i*fact[i-1];\\n        }\\n        // if position is 3 we need index 2 so k--\\n       k--;\\n\\n        String s = \"\";\\n\\n        // We are coming from back as we need to get the position of character for (n-1)! and we have put factorial in\\n        // increasing order in our factorial array so to get last character we need to come from reverse\\n\\n        for(int i = n-1; i >=0 ; i--){\\n\\n            int index = k/fact[i];\\n\\n            s = s+ list.remove(index);\\n    // To go to next index\\n            k = k%fact[i];\\n        }\\n        return s;\\n    }\\n\\t\\n\\tHope This helps",
                "codeTag": "Unknown"
            },
            {
                "id": 309634,
                "title": "swift-88-beat-factorial-trix-trixy-hobbits-m-a-t-h-l-o-l",
                "content": "```\\nclass Solution {\\n    func getPermutation(_ n: Int, _ k: Int) -> String {\\n        \\n        var fac = [Int](repeating: 1, count: n + 1)\\n        for i in 1..<(n+1) { fac[i] = fac[i - 1] * i }\\n        fac.reverse()\\n        \\n        var k = k - 1\\n        \\n        var list = [Int](repeating: 0, count: n)\\n        for i in 1..<(n + 1) { list[i - 1] = i }\\n        \\n        var res = [Int]()\\n        \\n        for i in 1..<(n + 1) {\\n            var index = k / fac[i]\\n            res.append(list[index])\\n            list.remove(at: index)    \\n            k -= fac[i] * index\\n        }\\n        \\n        return res.compactMap { String($0) }.joined()\\n    }\\n}\\n```\\n\\nThis is the same concept as previous solutions. \\n\\nIt is all stemmed from the fact that there are N! permutations for 1...N",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func getPermutation(_ n: Int, _ k: Int) -> String {\\n        \\n        var fac = [Int](repeating: 1, count: n + 1)\\n        for i in 1..<(n+1) { fac[i] = fac[i - 1] * i }\\n        fac.reverse()\\n        \\n        var k = k - 1\\n        \\n        var list = [Int](repeating: 0, count: n)\\n        for i in 1..<(n + 1) { list[i - 1] = i }\\n        \\n        var res = [Int]()\\n        \\n        for i in 1..<(n + 1) {\\n            var index = k / fac[i]\\n            res.append(list[index])\\n            list.remove(at: index)    \\n            k -= fac[i] * index\\n        }\\n        \\n        return res.compactMap { String($0) }.joined()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309606,
                "title": "c-100-beat-drooling-slackers-community-college-burnouts-copy-paste-awesome",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    string getPermutation(int n, int k) {\\n    \\n        int aFac[n + 1];\\n        \\n        aFac[0] = 1;\\n        \\n        for (int i=1;i<=n;i++) {\\n            aFac[i] = i * aFac[i - 1];\\n        }\\n        \\n        char aList[n + 1];\\n        aList[n] = 0;\\n        int aListCount = n;\\n        \\n        char aRes[n + 1];\\n        aRes[n] = 0;\\n        int aResCount = 0;\\n        \\n        for (int i=1;i<=n;i++) {\\n            aList[i - 1] = \\'0\\' + i;\\n        }\\n        \\n        k -= 1;\\n        \\n        for (int i=1;i<=n;i++) {\\n            \\n            int aIndex = k / aFac[n - i];\\n            \\n            aRes[aResCount++] = aList[aIndex];\\n            \\n            for (int j=aIndex+1;j<n;j++) {\\n                aList[j-1] = aList[j];\\n            }\\n            \\n            k -= aIndex * aFac[n - i];   \\n        }\\n        return string(aRes);\\n        \\n    }\\n};\\n```\\n\\nPermutations of ABCD\\n\\nA + Permutations(BCD)\\nB + Permutations(ACD)\\nC + Permutations(ABD)\\nD + Permutations(ABC)\\n\\nPermutations of BCD\\n\\nB + Permutations(CD)\\nC + Permutations(BD)\\nD + Permutations(BC)\\n\\nThere are X! permutations in every X length subsequence. So just copy the solution from the other kid. This won\\'t help you code any video game.\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string getPermutation(int n, int k) {\\n    \\n        int aFac[n + 1];\\n        \\n        aFac[0] = 1;\\n        \\n        for (int i=1;i<=n;i++) {\\n            aFac[i] = i * aFac[i - 1];\\n        }\\n        \\n        char aList[n + 1];\\n        aList[n] = 0;\\n        int aListCount = n;\\n        \\n        char aRes[n + 1];\\n        aRes[n] = 0;\\n        int aResCount = 0;\\n        \\n        for (int i=1;i<=n;i++) {\\n            aList[i - 1] = \\'0\\' + i;\\n        }\\n        \\n        k -= 1;\\n        \\n        for (int i=1;i<=n;i++) {\\n            \\n            int aIndex = k / aFac[n - i];\\n            \\n            aRes[aResCount++] = aList[aIndex];\\n            \\n            for (int j=aIndex+1;j<n;j++) {\\n                aList[j-1] = aList[j];\\n            }\\n            \\n            k -= aIndex * aFac[n - i];   \\n        }\\n        return string(aRes);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278289,
                "title": "java-1ms-factorial-solution-with-detailed-explanation",
                "content": "Apparently, there are ```n!``` different permutations for given ```n```. Suppose ```m``` is the first element, then there are ```n - 1!``` permuations for the rest ```n - 1``` numbers. The case is similar to the second element to the nth element. \\n\\nWith that in mind, we can calculate the ```kth``` permutation from the first element to ```nth``` element. \\nAt first, we save ```1``` to ```n``` in a list ```num``` ascendently. \\nThen we traverse from ```1``` to ```n```,  the index of the ```ith``` element in ```num``` equals to ```k / (n - i)!``` and ```k``` is updated to ```k % (n - i)```. The picked element is then removed from the list.\\nKeep traversing until ```k = 0```. Then we add the rest elements in ```num``` to the ```kth``` permutation.\\n\\nThis solution has two tricks:\\n1. Use a list to save candidate elements\\n2. Set k to k - 1 (synchronize index) can simplify the calculation\\n\\n```\\npublic String getPermutation(int n, int k) {\\n\\tStringBuilder sb = new StringBuilder(\"\");\\n\\tList<Integer> num = new ArrayList<Integer>();\\n\\tfor(int i = 1; i <= n; i++) // save candidate elements in a list\\n\\t\\tnum.add(i);\\n\\tint factorial = 1;\\n\\tfor(int i = 1; i <= n - 1; i++)\\n\\t\\tfactorial *= i;\\n\\tk = k - 1; // synchronize the index\\n\\tfor(int i = 1; i < n; i++) {\\n\\t\\tif( k == 0 )\\n\\t\\t\\tbreak;\\n\\t\\tint index = k / factorial;\\n\\t\\tk %= factorial;\\n\\t\\tfactorial /= (n - i);\\n\\t\\tsb.append(num.get(index));\\n\\t\\tnum.remove(index);\\n\\t}\\n\\tfor(int i = 0; i < num.size(); i++)\\n\\t\\tsb.append(num.get(i));\\n\\treturn sb.toString();\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```n!```\n```n```\n```m```\n```n - 1!```\n```n - 1```\n```kth```\n```nth```\n```1```\n```n```\n```num```\n```1```\n```n```\n```ith```\n```num```\n```k / (n - i)!```\n```k```\n```k % (n - i)```\n```k = 0```\n```num```\n```kth```\n```\\npublic String getPermutation(int n, int k) {\\n\\tStringBuilder sb = new StringBuilder(\"\");\\n\\tList<Integer> num = new ArrayList<Integer>();\\n\\tfor(int i = 1; i <= n; i++) // save candidate elements in a list\\n\\t\\tnum.add(i);\\n\\tint factorial = 1;\\n\\tfor(int i = 1; i <= n - 1; i++)\\n\\t\\tfactorial *= i;\\n\\tk = k - 1; // synchronize the index\\n\\tfor(int i = 1; i < n; i++) {\\n\\t\\tif( k == 0 )\\n\\t\\t\\tbreak;\\n\\t\\tint index = k / factorial;\\n\\t\\tk %= factorial;\\n\\t\\tfactorial /= (n - i);\\n\\t\\tsb.append(num.get(index));\\n\\t\\tnum.remove(index);\\n\\t}\\n\\tfor(int i = 0; i < num.size(); i++)\\n\\t\\tsb.append(num.get(i));\\n\\treturn sb.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 190680,
                "title": "6ms-java-solution",
                "content": "Let's say n = 5 and k = 40;\nCurrently we have the following individual numbers:\n```\n1 2 3 4 5\n```\nAmong **n!** = **120** permutations **(n-1)!** = **24** of them will begin with **\"1\"**, the next **24** of them will begin with **\"2\"**, the next **24** will begin with **\"3\"** and so on.\nIn which case **40th** element will begin with **\"2\"**.\n\nNow the problem becomes among the following numbers, what is the 40 - 24 = **16th** permutation:\n\n```\n1 3 4 5\n```\nThe length of this set is 4, so **(4-1)!** = **6** of them will begin with **\"1\"**, the next **6** will begin with **\"3\"** and the next **6** wil begin with **\"4\"**.\nIn which case **16th** element will begin with a **\"4\"**.\n\nNow the problem is what is the 16 - 12 = **4th** permutation of the following set:\n\n```\n1 3 5\n```\n\n**2** of them will begin with a **\"1\"** and **3rd** and **4th** permutation will begin with a **\"3\"** and we need the **2nd** permutation from the remaining set which is:\n\n```\n1 5\n```\n**1st** permutation will begin with a **\"1\"** and **2nd** will begin with **\"5\"**.\n\nOverall result is:\n```\n24351\n```\n\n```java\nclass Solution {\n    public String getPermutation(int n, int k) {\n        int[] numbers = new int[n];\n        for (int i = 1; i <= n; i++) numbers[i-1] = i;\n        return perm(numbers, k);\n    }\n    private String perm(int[] input, int k) {\n        if (input.length == 0) return \"\";\n        int len = input.length - 1;\n        int cnt = factorial(len);\n        int pos = 0;\n        while (k - cnt > 0) {\n            k -= cnt;\n            pos++;\n        }\n        \n        String result = Integer.toString(input[pos]);\n        int[] rem = new int[len];\n        int ix = 0;\n        for (int i = 0; i <= len; i++) {\n            if (i == pos) continue;\n            rem[ix++] = input[i];\n        }\n        result += perm(rem, k);\n        return result;\n    }\n    private int factorial(int n) {\n        int result = 1;\n        for (int i = 1; i <= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\n1 2 3 4 5\n```\n```\n1 3 4 5\n```\n```\n1 3 5\n```\n```\n1 5\n```\n```\n24351\n```\n```java\nclass Solution {\n    public String getPermutation(int n, int k) {\n        int[] numbers = new int[n];\n        for (int i = 1; i <= n; i++) numbers[i-1] = i;\n        return perm(numbers, k);\n    }\n    private String perm(int[] input, int k) {\n        if (input.length == 0) return \"\";\n        int len = input.length - 1;\n        int cnt = factorial(len);\n        int pos = 0;\n        while (k - cnt > 0) {\n            k -= cnt;\n            pos++;\n        }\n        \n        String result = Integer.toString(input[pos]);\n        int[] rem = new int[len];\n        int ix = 0;\n        for (int i = 0; i <= len; i++) {\n            if (i == pos) continue;\n            rem[ix++] = input[i];\n        }\n        result += perm(rem, k);\n        return result;\n    }\n    private int factorial(int n) {\n        int result = 1;\n        for (int i = 1; i <= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 22614,
                "title": "44ms-python-solution",
                "content": "    from math import factorial  \\n    class Solution(object):\\n    \\n        def getPermutation(self, n, k):\\n            \"\"\"\\n            :type n: int\\n            :type k: int\\n            :rtype: str\\n            \"\"\"\\n            res = []\\n            nums = [i for i in xrange(1, n+1)]\\n            while n-1 >= 0:\\n                num, k = k/factorial(n-1), k % factorial(n-1)\\n                if k > 0:\\n                    res.append(str(nums[num]))\\n                    nums.remove(nums[num])\\n                else:\\n                    res.append(str(nums[num-1]))\\n                    nums.remove(nums[num-1])\\n    \\n                n -= 1\\n    \\n            return ''.join(res)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    from math import factorial  \\n    class Solution(object):\\n    \\n        def getPermutation(self, n, k):\\n            \"\"\"\\n            :type n: int\\n            :type k: int\\n            :rtype: str\\n            \"\"\"\\n            res = []\\n            nums = [i for i in xrange(1, n+1)]\\n            while n-1 >= 0:\\n                num, k = k/factorial(n-1), k % factorial(n-1)\\n                if k > 0:\\n                    res.append(str(nums[num]))\\n                    nums.remove(nums[num])\\n                else:\\n                    res.append(str(nums[num-1]))\\n                    nums.remove(nums[num-1])\\n    \\n                n -= 1\\n    \\n            return ''.join(res)",
                "codeTag": "Java"
            },
            {
                "id": 4033541,
                "title": "c-solution-beates-100-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact = 1;\\n        vector<int> nums;\\n        string ans = \"\";\\n        for(int i=1;i<n;i++){\\n            fact=fact*i;\\n            nums.push_back(i);\\n        }\\n        nums.push_back(n);\\n        k = k-1;\\n        while(true){\\n            ans = ans + to_string(nums[k/fact]);\\n            nums.erase(nums.begin() + k/fact);\\n            if(nums.size()==0){\\n                break;\\n            }\\n            k = k % fact;\\n            fact = fact / nums.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact = 1;\\n        vector<int> nums;\\n        string ans = \"\";\\n        for(int i=1;i<n;i++){\\n            fact=fact*i;\\n            nums.push_back(i);\\n        }\\n        nums.push_back(n);\\n        k = k-1;\\n        while(true){\\n            ans = ans + to_string(nums[k/fact]);\\n            nums.erase(nums.begin() + k/fact);\\n            if(nums.size()==0){\\n                break;\\n            }\\n            k = k % fact;\\n            fact = fact / nums.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490124,
                "title": "simple-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int>v(n), vv;\\n        for(int i=0;i<n;i++)\\n           v[i]=i+1;\\n       int p=0;\\n       do\\n       {\\n           p++;\\n           if(p==k)\\n           {\\n              for(auto it:v)\\n                 vv.push_back(it);\\n            break;\\n           }\\n       }while(next_permutation(v.begin(),v.end()));\\n       string s=\"\";\\n      \\n       for(auto it:vv)\\n          s+=to_string(it);\\n        return s;\\n          \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int>v(n), vv;\\n        for(int i=0;i<n;i++)\\n           v[i]=i+1;\\n       int p=0;\\n       do\\n       {\\n           p++;\\n           if(p==k)\\n           {\\n              for(auto it:v)\\n                 vv.push_back(it);\\n            break;\\n           }\\n       }while(next_permutation(v.begin(),v.end()));\\n       string s=\"\";\\n      \\n       for(auto it:vv)\\n          s+=to_string(it);\\n        return s;\\n          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437099,
                "title": "java-solution-beats-100-sometimes-98-non-recursive",
                "content": "# Intuition\\nIterative traversal and removal of elemnents from the bucket\\n# Approach\\nthe appraoch is based upon how u take benifit of factorial\\n\\n# Complexity\\n- Time complexity:\\nO(N) beats 100%\\n\\n- Space complexity:\\n    beats 83%\\n# Code\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        List<Integer> lr = new ArrayList<>();\\n        int sum=1;\\n        for(int i=1;i<=n;i++) {lr.add(i);sum*=i;}\\n        StringBuilder sb = new StringBuilder();\\n        while(lr.size()!=0&&n>0)\\n        {\\n            //succesively decreasing the factorials value\\n            sum/=n--;\\n            //a considered case when a new row of element is going to start fr.eg if n=4 and k=12 then it is sitting at the max of getting \\'2\\' at first place i.e. 2431 after 3s line will take place\\n            if(k%sum==0){sb.append(lr.remove(k/(sum)-1)); for(int i=lr.size()-1;i>=0;i--) sb.append(lr.get(i)); return sb.toString();}\\n           // removing the element based on how the get considered by k\\n            sb.append(lr.remove(k/(sum)));\\n\\n            k=k%sum;\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        List<Integer> lr = new ArrayList<>();\\n        int sum=1;\\n        for(int i=1;i<=n;i++) {lr.add(i);sum*=i;}\\n        StringBuilder sb = new StringBuilder();\\n        while(lr.size()!=0&&n>0)\\n        {\\n            //succesively decreasing the factorials value\\n            sum/=n--;\\n            //a considered case when a new row of element is going to start fr.eg if n=4 and k=12 then it is sitting at the max of getting \\'2\\' at first place i.e. 2431 after 3s line will take place\\n            if(k%sum==0){sb.append(lr.remove(k/(sum)-1)); for(int i=lr.size()-1;i>=0;i--) sb.append(lr.get(i)); return sb.toString();}\\n           // removing the element based on how the get considered by k\\n            sb.append(lr.remove(k/(sum)));\\n\\n            k=k%sum;\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3309989,
                "title": "3ms-n-n-c-short-sweet-code-iterative",
                "content": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> v(n+1,false);\\n        vector<int> fact(n+1,1);\\n        for(int i = 2; i <= n; i++){\\n            fact[i] = fact[i-1]*i;\\n        }\\n        string ans = \"\";\\n        k--;\\n        for(int i = 1; i <= n; i++){\\n            int x = k/fact[n-i],j,y=k;\\n            k -= x*fact[n-i];\\n            for(j = 1; j <= n; j++){\\n                if(v[j]==false&&x==0){\\n                    break;\\n                }else if(v[j]==false){\\n                    x--;\\n                }\\n            }\\n            if(j<=n)\\n            v[j] = true;\\n            ans = ans + to_string(j);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> v(n+1,false);\\n        vector<int> fact(n+1,1);\\n        for(int i = 2; i <= n; i++){\\n            fact[i] = fact[i-1]*i;\\n        }\\n        string ans = \"\";\\n        k--;\\n        for(int i = 1; i <= n; i++){\\n            int x = k/fact[n-i],j,y=k;\\n            k -= x*fact[n-i];\\n            for(j = 1; j <= n; j++){\\n                if(v[j]==false&&x==0){\\n                    break;\\n                }else if(v[j]==false){\\n                    x--;\\n                }\\n            }\\n            if(j<=n)\\n            v[j] = true;\\n            ans = ans + to_string(j);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308352,
                "title": "java-beats-99-6-1ms-runtime-recursion",
                "content": "``` java []\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int[] fact = new int[]{1,1,2,6,24,120,720,5040,40320};\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i=1;i<=n;i++){\\n            list.add(i);\\n        }\\n        return calc(fact,n,k-1,list,0)+\"\";\\n    }\\n\\n    private int calc(int[] fact,int n,int k,ArrayList<Integer> list,int res){\\n        if(n==0)\\n           return res;\\n        res=res*10+list.remove(k/fact[n-1]);\\n        return calc(fact,n-1,k%fact[n-1],list,res);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java []\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int[] fact = new int[]{1,1,2,6,24,120,720,5040,40320};\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i=1;i<=n;i++){\\n            list.add(i);\\n        }\\n        return calc(fact,n,k-1,list,0)+\"\";\\n    }\\n\\n    private int calc(int[] fact,int n,int k,ArrayList<Integer> list,int res){\\n        if(n==0)\\n           return res;\\n        res=res*10+list.remove(k/fact[n-1]);\\n        return calc(fact,n-1,k%fact[n-1],list,res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249501,
                "title": "1-liner-code-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Using the `Permutations` to find all the possible permutations.\\n2. Sorting in the ascending order.\\n3. Getting the `k-1` th value, which is a tuple\\n4. Converting that tuple in string format.\\n5. Returning the result.\\n\\n# Code\\n```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        return \\'\\'.join([str(i) for i in sorted(list(permutations([i for i in range(1, n+1)], n)))[k-1]])\\n        \\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        return \\'\\'.join([str(i) for i in sorted(list(permutations([i for i in range(1, n+1)], n)))[k-1]])\\n        \\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243187,
                "title": "c-recursion-backtracking-easy-brute-force-21-space-5-time",
                "content": "```\\nclass Solution {\\npublic:\\n    void recur(string s, string temp, vector<bool> &vis, vector<string> &ans, int &cnt, int k){\\n      if(temp.size() == s.size()){\\n        ans.emplace_back(temp);\\n        cnt++;\\n        if(cnt == k) return;\\n      }\\n      for(int i = 0; i < s.size(); i++){\\n        if(!vis[i]){\\n          vis[i] = true;\\n          temp += s[i];\\n          recur(s, temp, vis, ans, cnt, k);\\n          temp.pop_back();\\n          vis[i] = false;\\n        }\\n        if(cnt == k) return;\\n      }\\n    }\\n    string getPermutation(int n, int k) {\\n      vector<string> ans;\\n      string s = \"\", temp = \"\";\\n      for(int i = 1; i < n + 1; i++)\\n        s += to_string(i);\\n      vector<bool> vis(n, false);\\n      int cnt = 0;\\n      recur(s, temp, vis, ans, cnt, k);\\n      return ans.back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recur(string s, string temp, vector<bool> &vis, vector<string> &ans, int &cnt, int k){\\n      if(temp.size() == s.size()){\\n        ans.emplace_back(temp);\\n        cnt++;\\n        if(cnt == k) return;\\n      }\\n      for(int i = 0; i < s.size(); i++){\\n        if(!vis[i]){\\n          vis[i] = true;\\n          temp += s[i];\\n          recur(s, temp, vis, ans, cnt, k);\\n          temp.pop_back();\\n          vis[i] = false;\\n        }\\n        if(cnt == k) return;\\n      }\\n    }\\n    string getPermutation(int n, int k) {\\n      vector<string> ans;\\n      string s = \"\", temp = \"\";\\n      for(int i = 1; i < n + 1; i++)\\n        s += to_string(i);\\n      vector<bool> vis(n, false);\\n      int cnt = 0;\\n      recur(s, temp, vis, ans, cnt, k);\\n      return ans.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028305,
                "title": "c-easy-to-understand-beats-100-percent-o-n-2",
                "content": "please upvote if you like the solution.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\" ;\\n        vector<int>ds ;\\n        for(int i = 1 ; i <= n ; i++){\\n            ds.push_back(i) ;\\n        }\\n        int i = n ;\\n        while(k!= 0 && i >= 1){\\n            int r = fact(i-1) ;\\n            int c = check(r,k) ;\\n            s += to_string(ds[c]) ;\\n            ds.erase(ds.begin()+c) ;\\n            k = k -r*c ;\\n            i-- ;\\n        }\\n        return s ;\\n    }\\n    int check(int a ,int k){\\n        if(k%a == 0)return (k/a) - 1 ;\\n        return k/a ;\\n    }\\n    int fact(int n){\\n        if(n == 0)return 1 ;\\n        return n*fact(n-1) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\" ;\\n        vector<int>ds ;\\n        for(int i = 1 ; i <= n ; i++){\\n            ds.push_back(i) ;\\n        }\\n        int i = n ;\\n        while(k!= 0 && i >= 1){\\n            int r = fact(i-1) ;\\n            int c = check(r,k) ;\\n            s += to_string(ds[c]) ;\\n            ds.erase(ds.begin()+c) ;\\n            k = k -r*c ;\\n            i-- ;\\n        }\\n        return s ;\\n    }\\n    int check(int a ,int k){\\n        if(k%a == 0)return (k/a) - 1 ;\\n        return k/a ;\\n    }\\n    int fact(int n){\\n        if(n == 0)return 1 ;\\n        return n*fact(n-1) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731831,
                "title": "c-0ms-recursive-solution",
                "content": "The basic idea is to decrease the search space. Now, what does this mean, Actually if we want to place a number at the first position then it will be having (n-1)! ways to do it. So, let us take an example:\\n\\nn = 4 and k=9\\n\\nso, for suppose if we assume our answer will be having \\'1\\' at 1st position. Now let us write the possibilites:\\n\\n1 2 3 4\\n1 2 4 3\\n1 3 2 4\\n1 3 4 2\\n1 4 2 3\\n1 4 3 2\\n\\nand our k value is 9 but the number of possible ways with 1 are only 6. So 1 can\\'t be at first position.\\n\\nNow let us check for \\'2\\' but this time our k will be (9-6 = 3) [beacuse we will not again look into possiblilites of \\'1\\'].\\n\\nif we take 2 then 3-6<0, So here we can conclude that our answer will be having 2 at it\\'s first position. And similarly we will be checking for remaining\\n\\n\\n```\\nvector<int>fact(10,1);\\nclass Solution {\\npublic:   \\n    int Fact(int n){\\n        //Base\\n        if(n==1) return 1;\\n        return fact[n] = n*Fact(n-1);\\n    }\\n    void Helper(int n,int numbers,int k,string &res,unordered_map<int,bool>&ismarked){\\n        if(k < 0) return;\\n        int tk = k;\\n        for(int i=1;i<=n;i++){\\n            if(ismarked[i]) continue;\\n            if(tk-fact[numbers-1] <= 0){\\n                ismarked[i] = true;\\n                res+=to_string(i);\\n                Helper(n,numbers-1,tk,res,ismarked);\\n            }else{\\n                tk-=fact[numbers-1];\\n            }\\n        }\\n    }\\n    string getPermutation(int n, int k) {\\n        string res=\"\";\\n        unordered_map<int,bool> ismarked;\\n        Fact(9);\\n        Helper(n,n,k,res,ismarked);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int>fact(10,1);\\nclass Solution {\\npublic:   \\n    int Fact(int n){\\n        //Base\\n        if(n==1) return 1;\\n        return fact[n] = n*Fact(n-1);\\n    }\\n    void Helper(int n,int numbers,int k,string &res,unordered_map<int,bool>&ismarked){\\n        if(k < 0) return;\\n        int tk = k;\\n        for(int i=1;i<=n;i++){\\n            if(ismarked[i]) continue;\\n            if(tk-fact[numbers-1] <= 0){\\n                ismarked[i] = true;\\n                res+=to_string(i);\\n                Helper(n,numbers-1,tk,res,ismarked);\\n            }else{\\n                tk-=fact[numbers-1];\\n            }\\n        }\\n    }\\n    string getPermutation(int n, int k) {\\n        string res=\"\";\\n        unordered_map<int,bool> ismarked;\\n        Fact(9);\\n        Helper(n,n,k,res,ismarked);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2175708,
                "title": "simple-mathematical-solution",
                "content": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        perm, fact = \"\", factorial(n)\\n        nums = [ i for i in range(1, n+1) ]  #to keep track of the options left\\n        for i in range(n, 0, -1):\\n            fact //= i\\n            cur_pos = (k-1) // fact  #index of next number based on possibilities left\\n            perm += str( nums[cur_pos] )\\n            del nums[cur_pos]  #get rid of the number we used\\n            k %= fact\\n        return perm\\n```\\nPlease upvote if you find it useful! :)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        perm, fact = \"\", factorial(n)\\n        nums = [ i for i in range(1, n+1) ]  #to keep track of the options left\\n        for i in range(n, 0, -1):\\n            fact //= i\\n            cur_pos = (k-1) // fact  #index of next number based on possibilities left\\n            perm += str( nums[cur_pos] )\\n            del nums[cur_pos]  #get rid of the number we used\\n            k %= fact\\n        return perm\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121902,
                "title": "cpp-recursion-easy-solution",
                "content": "\\tint count=0;\\n    string ans;\\n    void rightrotate(string& s, int i, int j){\\n        if(i==j)return;\\n        char temp=s[j];\\n        for(int k=j-1;k>=i;k--){\\n            s[k+1]=s[k];\\n        }\\n        s[i]=temp;\\n    }\\n    void leftrotate(string& s, int i, int j){\\n        if(i==j)return;\\n        char temp=s[i];\\n        for(int k=i;k<=j-1;k++){\\n            s[k]=s[k+1];\\n        }\\n        s[j]=temp;\\n    }\\n    void permute(string s, int i, int k){\\n        if(i==s.length()){\\n            count++;\\n            if(count==k){\\n                ans=s;\\n                return ;\\n            }\\n        }\\n        if(count>=k)return;\\n        for(int j=i; j<s.length();j++){\\n            rightrotate(s,i,j);\\n            permute(s,i+1,k);\\n            leftrotate(s,i,j);\\n        }\\n    }\\n    string getPermutation(int n, int k) {\\n        string str=\"123456789\";\\n        string s=str.substr(0,n);\\n        cout<<s<<endl;\\n        permute(s,0,k);\\n        return ans;\\n    }",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "\\tint count=0;\\n    string ans;\\n    void rightrotate(string& s, int i, int j){\\n        if(i==j)return;\\n        char temp=s[j];\\n        for(int k=j-1;k>=i;k--){\\n            s[k+1]=s[k];\\n        }\\n        s[i]=temp;\\n    }\\n    void leftrotate(string& s, int i, int j){\\n        if(i==j)return;\\n        char temp=s[i];\\n        for(int k=i;k<=j-1;k++){\\n            s[k]=s[k+1];\\n        }\\n        s[j]=temp;\\n    }\\n    void permute(string s, int i, int k){\\n        if(i==s.length()){\\n            count++;\\n            if(count==k){\\n                ans=s;\\n                return ;\\n            }\\n        }\\n        if(count>=k)return;\\n        for(int j=i; j<s.length();j++){\\n            rightrotate(s,i,j);\\n            permute(s,i+1,k);\\n            leftrotate(s,i,j);\\n        }\\n    }\\n    string getPermutation(int n, int k) {\\n        string str=\"123456789\";\\n        string s=str.substr(0,n);\\n        cout<<s<<endl;\\n        permute(s,0,k);\\n        return ans;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 1978590,
                "title": "faster-than-91-people-with-explanation-simple-maths-of-probability",
                "content": "This is a simple approach of probability:\\n\\nThe explainattion goes something like this:\\nn= 4, k =9\\n\\nWe have an array = [1, 2, 3, 4]\\nand then we have 4 empty spaces to fill\\n_ _ _ _ _ \\n\\nSo considering that we are filling in position one with any of the numbers, we will then have a possibility of filling out the other 3 places by 3! ways.\\n\\nlet\\'s say we choose 1 to be put in position 1. Therefore 1 can be tied with 3! other solutions. We then can safely assume that if we choose 1 in position 1, then we will eliminate 6 possibilities. \\n1 : 1 - 6\\n2 : 7 - 12\\n3: 13 - 18 \\nBut we have 9 as the value of k, that means that we will have to go up the array and choose 2. \\n\\nThe array now becomes [1, 3, 4] as 2 was already picked up to be placed at position 1. \\n\\n_ _ _ _ _ \\n\\nNow that we have made a good assumption of choosing 2, we narrowed down our search. We can then go to the next place and hence we will also have to narrow down our search space\\nhence : k = k % 2! \\n\\nwe did 2! as there are 3 places to be filled in and we are checking which block of combinations it will fit in\\n\\nWe can keep repeating these steps till we have a value in arr. \\n\\n\\n```\\nvar getPermutation = function (n, k) {\\n  const factorials = {0: 1};\\n  let arr = [];\\n  for (let i = 1; i <= n; i++) {\\n    arr.push(i);\\n    factorials[i] = factorials[i - 1] * i;\\n  }\\n  const KthComb = [];\\n  k--;\\n  while (arr.length > 0) {\\n    const availableLen = arr.length - 1;\\n    let swapValue = Math.floor(k / factorials[availableLen]);\\n    KthComb.push(arr[swapValue]);\\n    arr.splice(swapValue, 1);\\n    const remainder = k % factorials[availableLen];\\n    k = k % factorials[availableLen];\\n  }\\n\\n  return KthComb.join(\"\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Probability and Statistics"
                ],
                "code": "```\\nvar getPermutation = function (n, k) {\\n  const factorials = {0: 1};\\n  let arr = [];\\n  for (let i = 1; i <= n; i++) {\\n    arr.push(i);\\n    factorials[i] = factorials[i - 1] * i;\\n  }\\n  const KthComb = [];\\n  k--;\\n  while (arr.length > 0) {\\n    const availableLen = arr.length - 1;\\n    let swapValue = Math.floor(k / factorials[availableLen]);\\n    KthComb.push(arr[swapValue]);\\n    arr.splice(swapValue, 1);\\n    const remainder = k % factorials[availableLen];\\n    k = k % factorials[availableLen];\\n  }\\n\\n  return KthComb.join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1760283,
                "title": "recursive-backtracking-solution-java",
                "content": "```\\nclass Solution {\\n    int count = 0;\\n    String ans = \"\";\\n    public String getPermutation(int n, int k) {\\n        boolean[] vis = new boolean[n];\\n        count = k;\\n        StringBuilder s = new StringBuilder();\\n        for(int i=0; i<n; i++)\\n            s.append((char) ((i+1) + \\'0\\'));\\n        permutations(s, new StringBuilder(), vis);\\n        return ans;\\n    }\\n    \\n    public void permutations(StringBuilder s, StringBuilder temp, boolean[] vis) {\\n        if(count == 0)\\n            return;\\n        if(temp.length() == s.length()) {\\n            count--;\\n            if(count == 0)\\n                ans = temp.toString();\\n            return;\\n        }\\n        \\n        for(int i=0; i<s.length(); i++) {\\n            if(!vis[i]) {\\n                vis[i] = true;\\n                temp.append(s.charAt(i));\\n                permutations(s, temp, vis);\\n                temp.deleteCharAt(temp.length()-1);\\n                vis[i] = false;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    String ans = \"\";\\n    public String getPermutation(int n, int k) {\\n        boolean[] vis = new boolean[n];\\n        count = k;\\n        StringBuilder s = new StringBuilder();\\n        for(int i=0; i<n; i++)\\n            s.append((char) ((i+1) + \\'0\\'));\\n        permutations(s, new StringBuilder(), vis);\\n        return ans;\\n    }\\n    \\n    public void permutations(StringBuilder s, StringBuilder temp, boolean[] vis) {\\n        if(count == 0)\\n            return;\\n        if(temp.length() == s.length()) {\\n            count--;\\n            if(count == 0)\\n                ans = temp.toString();\\n            return;\\n        }\\n        \\n        for(int i=0; i<s.length(); i++) {\\n            if(!vis[i]) {\\n                vis[i] = true;\\n                temp.append(s.charAt(i));\\n                permutations(s, temp, vis);\\n                temp.deleteCharAt(temp.length()-1);\\n                vis[i] = false;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750234,
                "title": "c-not-the-best-but-easiest-solution-136-200ms",
                "content": "**When I mean easiest solution, it is! The best solution for this problem uses recursion, and you can as close as a 0ms of runtime. However, this approach to the problem uses brute force.**\\n\\nBasically, the main idea is get all the permutations and iterate them.\\n1.- Get the string with the number, from 1 to n.\\nExamples:\\n&emsp;n = 3\\n&emsp;string = \"123\"\\n\\n&emsp;n = 5\\n&emsp;string = \"12345\"\\n\\n2.- Set the counter to 1. This will help us when to stop the permutations loop.\\n3.- Using a while loop we will sort the permutations by ascending order.\\n4.- Every cycle check if our counter is equal than k, if it is return the string else increase the var.\\n\\n*Documentation*\\nnext_permutation: https://en.cppreference.com/w/cpp/algorithm/next_permutation\\n\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string permutations;\\n        int index = 1;\\n        \\n        for (int i = 1; i <= n; i++) \\n            permutations += to_string(i);\\n                \\n        do {\\n            if (index == k) return permutations;    \\n            else index++;\\n        } while (next_permutation(permutations.begin(), permutations.end()));\\n        \\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string permutations;\\n        int index = 1;\\n        \\n        for (int i = 1; i <= n; i++) \\n            permutations += to_string(i);\\n                \\n        do {\\n            if (index == k) return permutations;    \\n            else index++;\\n        } while (next_permutation(permutations.begin(), permutations.end()));\\n        \\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489898,
                "title": "java-solution-iterative-o-n-time-complexity",
                "content": "If the string is \"1234\", the possible permutations are 24 i.e. (4!)\\nBased on the value of k, we can come to a conclusion about the first digit of the kth permutation\\n\\nIf k=6, the kth permutation of \"1234\" is \"1432\"\\nTo get the answer -\\n-----> get the first_digit + do the operation on the remaining string with a new k\\n\\n**How to calculate the first digit?**\\nIf (K%(n-1)! == 0) --> then first element will be at ([k/(n-1)!] -1) index\\nelse --> first element will be at [k/(n-1)!] index\\n\\nexample n=3, so string =\"123\" answer is \"321\" if k=6 and \"312\" if k=5\\nwhen k = 6 --> 6%2! is equal to 0. then the first  element is at ((6/2)- 1) i.e. at 2nd index (\"3\")\\nwhen k = 5 --> 5%2 is not equal to 0, then the first element is at 5/2 i.e 2nd index (\"3)\\n\\n\\nafter calculating the first digit, we can update the k and apply the same operation to the remaining string\\n**How to update k?**\\nif (K%(n-1)! == 0) --> k = (n-1)!\\nelse --> k = k%(n-1)!\\n\\nin the above example when k =6 --> k= (3-1)! = 2\\nwhen k = 5 --> k = 5%(3-1)! = 1\\nremaining string = \"12\"\\n\\nFor second element --> \\nk becomes 2 (for k=6) -- 2%1! is equal to 0, then second element is at index 2/1 -1 i.e. 1 (\"2\")\\nk becomes 1 (for k=5) -- 1%1! is equal to 0, then second element is at index 1/1 -1 i.e. 0 (\"1\")\\n\\nwhen n=1\\nwe have to add it in the answer and return the answer\\n\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String s = \"\";\\n        for (int i = 1; i <= n; i++) {\\n            s = s + i;\\n        }\\n        return permutation(s, k);\\n    }\\n    \\n    static String permutation(String s, int k){\\n        String str = \"\";\\n        int n = s.length();\\n        int ind=-1;\\n        int factorial = fact(n);\\n        \\n\\t\\twhile (n>1){\\n            factorial /= n;\\n            if (k%factorial == 0){\\n                ind = (k/factorial) -1;\\n                char first_ele = s.charAt(ind);\\n                str += first_ele;\\n                k = factorial;\\n            }\\n            else {\\n                ind = k/factorial;\\n                char first_ele = s.charAt(ind);\\n                str += first_ele;\\n                k = k%factorial;\\n            }\\n            s = s.substring(0, ind) + s.substring(ind+1);\\n            n--;\\n            \\n        }\\n\\n        return str + s;\\n    }\\n    \\n    static int fact(int n){\\n        if (n<=1){\\n            return 1;\\n        }\\n        return n*fact(n-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String s = \"\";\\n        for (int i = 1; i <= n; i++) {\\n            s = s + i;\\n        }\\n        return permutation(s, k);\\n    }\\n    \\n    static String permutation(String s, int k){\\n        String str = \"\";\\n        int n = s.length();\\n        int ind=-1;\\n        int factorial = fact(n);\\n        \\n\\t\\twhile (n>1){\\n            factorial /= n;\\n            if (k%factorial == 0){\\n                ind = (k/factorial) -1;\\n                char first_ele = s.charAt(ind);\\n                str += first_ele;\\n                k = factorial;\\n            }\\n            else {\\n                ind = k/factorial;\\n                char first_ele = s.charAt(ind);\\n                str += first_ele;\\n                k = k%factorial;\\n            }\\n            s = s.substring(0, ind) + s.substring(ind+1);\\n            n--;\\n            \\n        }\\n\\n        return str + s;\\n    }\\n    \\n    static int fact(int n){\\n        if (n<=1){\\n            return 1;\\n        }\\n        return n*fact(n-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1287258,
                "title": "c-recursive-solution-100-faster-fully-explained",
                "content": "- If example we have n = 4: (1 2 3 4); so total number of permutation is 4\\\\*3\\\\*2\\\\*1 = n! = 24 = fact\\n- so let k = 17, i.e. we wants 17th permutation; \\n- so how we start: we fix 1 => so total permutaion  with 1 as first index is 3! = 6 = fact< k so we decrease k as k =k-fact = 17 - 6 = 11, we move to 2 and do same; k=k-fact = 11 - 6 = 5 then 3, but here fact = 6 > k;\\n- so we get that \"3\" is our first index\\n- so we fix, mark 3 as visited, fact = fact/(m-1) and recur to smaller string and do same\\n\\n```cpp\\nvoid solve(int n, int k, string &s, long long &fact, int m, bool vis[]){\\n        if(k==0 || m<=0) return;     // check statement;  desired string already achivied\\n        fact = fact/m;                     // max number of permutation if we fix first index\\n        if(fact==0) return;             \\n        for(int i=1;i<=n;i++){       // loop to check and fix current index \\n            if(vis[i]) continue;         // if that number already considered before\\n            if(k>fact){                    // if current permutation is lexigrographically smaller then required permutation\\n                k = k - fact;\\n            }else{                        // if current index is to be considered\\n                s=s+char(i+\\'0\\');\\n                vis[i]=true;\\n                solve(n, k, s, fact, m-1, vis);\\n                break;\\n            }\\n        }\\n    }\\n    string getPermutation(int n, int k) {\\n        string res;\\n        long long factorial = 1;\\n        for(int i=2;i<=n;i++) factorial = factorial*i;     // max number of permutation\\n        bool vis[n+1];\\n        memset(vis,false, sizeof(vis));\\n        solve(n, k, res, factorial, n, vis);\\n        return res;\\n    }\\n```\\n\\n##### If you have any doubt then feel free to ask them below in comment section, also please give this a upvote as it motivates me post more such solutions.\\n",
                "solutionTags": [],
                "code": "```cpp\\nvoid solve(int n, int k, string &s, long long &fact, int m, bool vis[]){\\n        if(k==0 || m<=0) return;     // check statement;  desired string already achivied\\n        fact = fact/m;                     // max number of permutation if we fix first index\\n        if(fact==0) return;             \\n        for(int i=1;i<=n;i++){       // loop to check and fix current index \\n            if(vis[i]) continue;         // if that number already considered before\\n            if(k>fact){                    // if current permutation is lexigrographically smaller then required permutation\\n                k = k - fact;\\n            }else{                        // if current index is to be considered\\n                s=s+char(i+\\'0\\');\\n                vis[i]=true;\\n                solve(n, k, s, fact, m-1, vis);\\n                break;\\n            }\\n        }\\n    }\\n    string getPermutation(int n, int k) {\\n        string res;\\n        long long factorial = 1;\\n        for(int i=2;i<=n;i++) factorial = factorial*i;     // max number of permutation\\n        bool vis[n+1];\\n        memset(vis,false, sizeof(vis));\\n        solve(n, k, res, factorial, n, vis);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1139402,
                "title": "backtrack-cpp-solution-that-doesn-t-give-tle",
                "content": "I\\'m posting this solution as I couldn\\'t find a standard backtracking solution in any of the posts. This solution is not the fastest, but it\\'s simple and based on the backtracking template and good to know. \\nFew important points:\\n1) Sort the string which you are going to permute so that permutations are generated in a lexicographical manner\\n2) Pass the string by value, as sorting will change the order and caller will not be able to \"swap\" with right index\\n3) As soon as the kth permutation is found, terminate the backtracking (Though, it\\'s passing if we don\\'t terminate, takes more time of course)\\n```\\nclass Solution {\\n    int K, N;\\n    string ans;\\npublic:\\n    string getPermutation(int n, int k) {\\n        K = k;   \\n        N = n;\\n        string s;\\n        for(int i=0;i<n;i++){\\n            s.push_back(i+1+\\'0\\');\\n        }\\n        permute(s, 0);    \\n        return ans;\\n    }\\n    \\n    void permute(string s, int start) {\\n        if(start==N-1){\\n            K--;\\n            if(!K){\\n                ans = s;\\n            }\\n            return;\\n        }\\n        \\n        sort(s.begin()+start,s.end());\\n        for(int i=start;i<N;i++){\\n            swap(s[i], s[start]); \\n            permute(s, start+1);\\n            if(!K){\\n                return; //No need to continue backtracking\\n            }\\n            swap(s[i], s[start]); //In case of pass by reference, \"i\" will have a different value as per the sorting, causing error\\n        }\\n    }\\n};\\n```\\n\\nOther approach that worked for me:\\n- Reuse the solution from https://leetcode.com/problems/next-permutation/ and call getPermutation k-1 times and return the final string. \"k-1\" because we begin with the first permutation sequence and need to permute k-1 times. This runs much faster than the backtrack solution discussed in this post.",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\n    int K, N;\\n    string ans;\\npublic:\\n    string getPermutation(int n, int k) {\\n        K = k;   \\n        N = n;\\n        string s;\\n        for(int i=0;i<n;i++){\\n            s.push_back(i+1+\\'0\\');\\n        }\\n        permute(s, 0);    \\n        return ans;\\n    }\\n    \\n    void permute(string s, int start) {\\n        if(start==N-1){\\n            K--;\\n            if(!K){\\n                ans = s;\\n            }\\n            return;\\n        }\\n        \\n        sort(s.begin()+start,s.end());\\n        for(int i=start;i<N;i++){\\n            swap(s[i], s[start]); \\n            permute(s, start+1);\\n            if(!K){\\n                return; //No need to continue backtracking\\n            }\\n            swap(s[i], s[start]); //In case of pass by reference, \"i\" will have a different value as per the sorting, causing error\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1022904,
                "title": "c-easy-iterative-solutions-100-faster-with-o-n-time-complextiy",
                "content": "This solution is not efficient as it consumes so much memory....its just to develop the thought process \\n```\\nclass Solution {\\npublic:\\n    bool solve(int k, int& count, string str, string s, string& ans) {\\n        if(s.size()==0) {\\n            count++;\\n            if(count==k) {\\n                ans= str;\\n                return true; \\n            }\\n            return false;\\n        }\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            string p=s; \\n            p.erase(i, 1);\\n            if(solve(k, count, str+s[i], p, ans))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    string getPermutation(int n, int k) {\\n        int count=0;\\n        string ans, s=\"\";\\n        \\n        for(int i=1; i<=n; i++) s+= (i+48);\\n        \\n        solve(k, count, \"\", s, ans);\\n        return ans;\\n    }\\n};\\n```\\nHere is the efficient solution(100% faster, O(N) time complexity), its a bit mathematical here we will find the required string by dividing all the permutations in to different parts according to the first element\\neg s= \"123\" can be divided as -\\n123 132\\n213  231\\n312 321\\n```\\nclass Solution {\\npublic:\\n    int fact(int n) {\\n        int ans=1;\\n        for(int i=1; i<=n; i++) ans*=i;\\n        return ans;\\n    }\\n    \\n    void solve(int k, string s, string& ans) {    \\n        int total_size=0, part_size, n, temp;  \\n        while(s.size()>2) {\\n            n= s.size();\\n            total_size= fact(n);\\n            part_size= total_size/n;\\n            \\n            temp= (k-1)/part_size;\\n            \\n            if(k%part_size==0)\\n                k=part_size;\\n            else\\n                k= k%part_size;\\n        \\n            ans+= s[temp];\\n            s.erase(temp, 1);           \\n        }\\n        cout<<s;\\n    }\\n    \\n    string getPermutation(int n, int k) {\\n        string ans, s=\"\";        \\n        for(int i=1; i<=n; i++) s+= (i+48);\\n        \\n        solve(k, s, ans);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(int k, int& count, string str, string s, string& ans) {\\n        if(s.size()==0) {\\n            count++;\\n            if(count==k) {\\n                ans= str;\\n                return true; \\n            }\\n            return false;\\n        }\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            string p=s; \\n            p.erase(i, 1);\\n            if(solve(k, count, str+s[i], p, ans))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    string getPermutation(int n, int k) {\\n        int count=0;\\n        string ans, s=\"\";\\n        \\n        for(int i=1; i<=n; i++) s+= (i+48);\\n        \\n        solve(k, count, \"\", s, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 798148,
                "title": "c-solution-for-all-similar-questions",
                "content": "```\\n46. Permutations :- https://leetcode.com/problems/permutations/\\n\\nclass Solution {\\n    vector<vector<int> > ans;\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        ans.clear();\\n        vector<int> res;\\n        unordered_map<int,bool> ump;\\n        solve(nums, res, ump);\\n        return ans;\\n    }\\nprivate:\\n    void solve(vector<int>& nums, vector<int> res, unordered_map<int,bool> ump)\\n    {\\n        if (res.size() == nums.size())\\n        {\\n            ans.push_back(res);\\n            return;\\n        }\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            if (ump[nums[i]] == true)\\n                continue;\\n            res.push_back(nums[i]);\\n            ump[nums[i]] = true;\\n            solve(nums, res, ump);\\n            res.pop_back();\\n            ump[nums[i]] = false;\\n        }\\n    }\\n};\\n\\n47. Permutations II :- https://leetcode.com/problems/permutations-ii/\\n\\nclass Solution {\\n    vector<vector<int> > ans;\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        ans.clear();\\n        vector<int> res;\\n        unordered_map<int,bool> ump;\\n        sort(begin(nums),end(nums));\\n        solve(nums, res, ump);\\n        return ans;\\n    }\\nprivate:\\n    void solve(vector<int>& nums, vector<int> res, unordered_map<int,bool> ump)\\n    {\\n        if (res.size() == nums.size())\\n        {\\n            ans.push_back(res);\\n            return;\\n        }\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            if (ump[i] == true || i > 0 && nums[i] == nums[i-1] && ump[i-1] == false)\\n                continue;\\n            res.push_back(nums[i]);\\n            ump[i] = true;\\n            solve(nums, res, ump);\\n            res.pop_back();\\n            ump[i] = false;\\n        }\\n    }    \\n};\\n\\n31. Next Permutation :- https://leetcode.com/problems/next-permutation/\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1)\\n            return;\\n        if (n == 2)\\n        {\\n            swap(nums[0],nums[1]);\\n            return;\\n        }\\n        int j = n-1;\\n        while(j > 0)\\n        {\\n            if (nums[j-1] < nums[j])\\n            {\\n                reverse(begin(nums)+j,end(nums));\\n                auto idx = upper_bound(begin(nums)+j,end(nums),nums[j-1]) - begin(nums);\\n                swap(nums[j-1],nums[idx]);\\n                return;\\n            }\\n            j--;\\n        }\\n        sort(begin(nums),end(nums));\\n        return;\\n    }\\n};\\n\\n60. Permutation Sequence :- https://leetcode.com/problems/permutation-sequence/\\n\\nclass Solution {\\n    vector<int> fact;\\n    vector<string> digits;\\n    string ans;\\npublic:\\n    string getPermutation(int n, int k) {\\n        fact = vector<int>(n);\\n        digits = vector<string>(n);\\n        ans = \"\";\\n        fact[0] = 1;\\n        for(int i = 1 ; i < n ; i++)\\n            fact[i] = fact[i-1] * i;\\n        for(int i = 1 ; i <= n ; i++)\\n            digits[i-1] = to_string(i);\\n        solve(n,k);\\n        return ans;\\n    }\\nprivate:\\n    void solve(int n, int k)\\n    {\\n        if (n == 1)\\n        {\\n            ans += digits[0];\\n            return;\\n        }\\n        int index = k/fact[n-1];\\n        if (k % fact[n-1] == 0)\\n            index--;\\n        ans = ans + digits[index];\\n        digits.erase(begin(digits)+index);\\n        k = k - fact[n-1] * index;\\n        n--;\\n        solve(n,k);\\n    }\\n};\\n\\n78. Subsets :- https://leetcode.com/problems/subsets/\\n\\nclass Solution {\\n    int len, n;\\n    vector<vector<int> > ans;\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        ans.clear();\\n        n = (int)nums.size();\\n        vector<int> res;\\n        for(len = 0 ; len <= n ; len++)\\n            solve(nums, 0, res);\\n        return ans;\\n    }\\nprivate:\\n    void solve(vector<int>& nums, int index, vector<int> res)\\n    {\\n        if ((int)res.size() == len)\\n            ans.push_back(res);\\n        for(int i = index ; i < n ; i++)\\n        {\\n            res.push_back(nums[i]);\\n            solve(nums, i + 1, res);\\n            res.pop_back();\\n        }\\n    }\\n};\\n\\n90. Subsets II :- https://leetcode.com/problems/subsets-ii/\\n\\nclass Solution {\\n    int len, n;\\n    vector<vector<int> > ans;\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        ans.clear();\\n        n = (int)nums.size();\\n        vector<int> res;\\n        sort(begin(nums),end(nums));\\n        // for(len = 0 ; len <= n ; len++)\\n        solve(nums, 0, res);\\n        return ans;\\n    }\\nprivate:\\n    void solve(vector<int>& nums, int index, vector<int>& res)\\n    {\\n        ans.push_back(res);\\n        for(int i = index ; i < n ; i++)\\n        {\\n            if (i > index && nums[i] == nums[i-1])\\n                continue;\\n            res.push_back(nums[i]);\\n            solve(nums, i + 1, res);\\n            res.pop_back();\\n        }\\n    }\\n};\\n\\n77. Combinations :- https://leetcode.com/problems/combinations/\\n\\nclass Solution {\\n    vector<vector<int> > ans;\\npublic:\\n    void solve(int& n, int k, int curN, vector<int>& cur)\\n    {\\n        if (k == 0)\\n        {\\n            ans.push_back(cur);\\n            return;\\n        }\\n        if (curN > n)\\n            return;\\n        for(int idx = curN ; idx <= n ; idx++)\\n        {\\n            cur.push_back(idx);\\n            solve(n, k-1, idx+1, cur);\\n            cur.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        ans.clear();\\n        vector<int> cur;\\n        solve(n, k, 1, cur);\\n        return ans;\\n    }\\n};\\n\\n39. Combination Sum :- https://leetcode.com/problems/combination-sum/\\n\\nclass Solution {\\n    set<vector<int>> ans;\\npublic:\\n    void solve(vector<int>& candidates, int& target, int idx, int curSum, vector<int> cur)\\n    {\\n        if (curSum == target)\\n        {\\n            ans.insert(cur);\\n            return;\\n        }\\n        if (curSum > target)\\n            return;\\n        if (idx >= candidates.size())\\n            return;\\n        for(int i = idx ; i < candidates.size() ; i++)\\n        {\\n            curSum += candidates[i];\\n            cur.push_back(candidates[i]);\\n            solve(candidates, target, i, curSum, cur);\\n            curSum -= candidates[i];\\n            cur.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        ans.clear();\\n        vector<int> cur;\\n        sort(begin(candidates), end(candidates));\\n        solve(candidates, target, 0, 0, cur);\\n        vector<vector<int>> res;\\n        for(auto it : ans)\\n            res.push_back(it);\\n        return res;\\n    }\\n};\\n\\n17. Letter Combinations of a Phone Number :- https://leetcode.com/problems/letter-combinations-of-a-phone-number/\\n\\nclass Solution {\\npublic:\\n    vector<string> keypad = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    void solve(string &digits, string cur, int idx, vector<string> &ans)\\n    {\\n        if (idx == digits.size())\\n        {\\n            ans.push_back(cur);\\n            return;\\n        }\\n        for(int i = 0 ; i < keypad[digits[idx]-\\'0\\'].size() ; i++)\\n        {\\n            cur.push_back(keypad[digits[idx]-\\'0\\'][i]);\\n            solve(digits, cur, idx+1, ans);\\n            cur.pop_back();\\n        }\\n    }\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        if (digits.size() < 1)\\n            return ans;\\n        solve(digits, \"\", 0, ans);\\n        return ans;\\n    }\\n};\\n\\n40. Combination Sum II :- https://leetcode.com/problems/combination-sum-ii/\\n\\nclass Solution {\\n    set<vector<int>> ans;\\npublic:\\n    void solve(vector<int>& candidates, int& target, int idx, int curSum, vector<int> cur)\\n    {\\n        if (curSum == target)\\n        {\\n            ans.insert(cur);\\n            return;\\n        }\\n        if (curSum > target)\\n            return;\\n        if (idx >= candidates.size())\\n            return;\\n        for(int i = idx ; i < candidates.size() ; i++)\\n        {\\n            curSum += candidates[i];\\n            cur.push_back(candidates[i]);\\n            solve(candidates, target, i+1, curSum, cur);\\n            curSum -= candidates[i];\\n            cur.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        ans.clear();\\n        vector<int> cur;\\n        sort(begin(candidates), end(candidates));\\n        solve(candidates, target, 0, 0, cur);\\n        vector<vector<int>> res;\\n        for(auto it : ans)\\n            res.push_back(it);\\n        return res;\\n    }\\n};\\n\\n216. Combination Sum III :- https://leetcode.com/problems/combination-sum-iii/\\n\\nclass Solution {\\n    vector<vector<int> > ans;\\n    int K, N;\\npublic:\\n    void solve(int n, int curSum, vector<int>& cur)\\n    {\\n        if (curSum == N and cur.size() == K)\\n        {\\n            ans.push_back(cur);\\n            return;\\n        }\\n        if (curSum > N)\\n            return;\\n        if (cur.size() > K)\\n            return;\\n        for(int num = n ; num < 10 ; num++)\\n        {\\n            cur.push_back(num);\\n            solve(num+1, curSum + num, cur);\\n            cur.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        ans.clear();\\n        vector<int> cur;\\n        K = k;\\n        N = n;\\n        solve(1, 0, cur);\\n        return ans;\\n    }\\n};\\n\\n377. Combination Sum IV :- https://leetcode.com/problems/combination-sum-iv/\\n\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<int> dp(target + 1);\\n        dp[0] = 1;\\n        sort (nums.begin(), nums.end());\\n        for (int i = 1; i <= target; i++) {\\n            for (auto num : nums) {\\n                if (i < num) break;\\n                dp[i] = ((long int)dp[i]+dp[i-num])%2147483647 ;\\n            }\\n        }\\n        return dp.back();\\n    }\\n};\\n\\n22. Generate Parentheses :- https://leetcode.com/problems/generate-parentheses/\\n\\nclass Solution {\\npublic:\\n    void generate(string cur,int open,int close,int n,vector<string> &ans){\\n        if(cur.length()>=2*n){\\n            if(open==close && open==n){\\n                ans.push_back(cur);\\n                return;\\n            }else{\\n                return;\\n            }\\n        }\\n        if(open==n && close<open){\\n            cur.push_back(\\')\\');\\n            generate(cur,open,close+1,n,ans);  \\n        }\\n        if(open == close && open < n){\\n            cur.push_back(\\'(\\');\\n            generate(cur,open+1,close,n,ans);\\n        }\\n        if(open>close){\\n            if(open<n){\\n                cur.push_back(\\'(\\');\\n                generate(cur,open+1,close,n,ans);\\n            }\\n            {\\n                cur.push_back(\\')\\');\\n                generate(cur,open,close+1,n,ans);\\n            }\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        generate(\"\",0,0,n,ans);\\n        return ans;\\n    }\\n};\\n\\n20. Valid Parentheses :- https://leetcode.com/problems/valid-parentheses/\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\' || s[i]==\\'[\\' || s[i]==\\'{\\')\\n                st.push(s[i]);\\n            else{\\n                if(st.empty())\\n                    return false;\\n                char tp = st.top();\\n                st.pop();\\n                char cur = s[i];\\n                if(cur==\\')\\' && (tp==\\'{\\' || tp==\\'[\\'))\\n                    return false;\\n                if(cur==\\'}\\' && (tp==\\'(\\' || tp==\\'[\\'))\\n                    return false;\\n                if(cur==\\']\\' && (tp==\\'{\\' || tp==\\'(\\'))\\n                    return false;\\n            }\\n        }\\n        return st.empty();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n46. Permutations :- https://leetcode.com/problems/permutations/\\n\\nclass Solution {\\n    vector<vector<int> > ans;\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        ans.clear();\\n        vector<int> res;\\n        unordered_map<int,bool> ump;\\n        solve(nums, res, ump);\\n        return ans;\\n    }\\nprivate:\\n    void solve(vector<int>& nums, vector<int> res, unordered_map<int,bool> ump)\\n    {\\n        if (res.size() == nums.size())\\n        {\\n            ans.push_back(res);\\n            return;\\n        }\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            if (ump[nums[i]] == true)\\n                continue;\\n            res.push_back(nums[i]);\\n            ump[nums[i]] = true;\\n            solve(nums, res, ump);\\n            res.pop_back();\\n            ump[nums[i]] = false;\\n        }\\n    }\\n};\\n\\n47. Permutations II :- https://leetcode.com/problems/permutations-ii/\\n\\nclass Solution {\\n    vector<vector<int> > ans;\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        ans.clear();\\n        vector<int> res;\\n        unordered_map<int,bool> ump;\\n        sort(begin(nums),end(nums));\\n        solve(nums, res, ump);\\n        return ans;\\n    }\\nprivate:\\n    void solve(vector<int>& nums, vector<int> res, unordered_map<int,bool> ump)\\n    {\\n        if (res.size() == nums.size())\\n        {\\n            ans.push_back(res);\\n            return;\\n        }\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            if (ump[i] == true || i > 0 && nums[i] == nums[i-1] && ump[i-1] == false)\\n                continue;\\n            res.push_back(nums[i]);\\n            ump[i] = true;\\n            solve(nums, res, ump);\\n            res.pop_back();\\n            ump[i] = false;\\n        }\\n    }    \\n};\\n\\n31. Next Permutation :- https://leetcode.com/problems/next-permutation/\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1)\\n            return;\\n        if (n == 2)\\n        {\\n            swap(nums[0],nums[1]);\\n            return;\\n        }\\n        int j = n-1;\\n        while(j > 0)\\n        {\\n            if (nums[j-1] < nums[j])\\n            {\\n                reverse(begin(nums)+j,end(nums));\\n                auto idx = upper_bound(begin(nums)+j,end(nums),nums[j-1]) - begin(nums);\\n                swap(nums[j-1],nums[idx]);\\n                return;\\n            }\\n            j--;\\n        }\\n        sort(begin(nums),end(nums));\\n        return;\\n    }\\n};\\n\\n60. Permutation Sequence :- https://leetcode.com/problems/permutation-sequence/\\n\\nclass Solution {\\n    vector<int> fact;\\n    vector<string> digits;\\n    string ans;\\npublic:\\n    string getPermutation(int n, int k) {\\n        fact = vector<int>(n);\\n        digits = vector<string>(n);\\n        ans = \"\";\\n        fact[0] = 1;\\n        for(int i = 1 ; i < n ; i++)\\n            fact[i] = fact[i-1] * i;\\n        for(int i = 1 ; i <= n ; i++)\\n            digits[i-1] = to_string(i);\\n        solve(n,k);\\n        return ans;\\n    }\\nprivate:\\n    void solve(int n, int k)\\n    {\\n        if (n == 1)\\n        {\\n            ans += digits[0];\\n            return;\\n        }\\n        int index = k/fact[n-1];\\n        if (k % fact[n-1] == 0)\\n            index--;\\n        ans = ans + digits[index];\\n        digits.erase(begin(digits)+index);\\n        k = k - fact[n-1] * index;\\n        n--;\\n        solve(n,k);\\n    }\\n};\\n\\n78. Subsets :- https://leetcode.com/problems/subsets/\\n\\nclass Solution {\\n    int len, n;\\n    vector<vector<int> > ans;\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        ans.clear();\\n        n = (int)nums.size();\\n        vector<int> res;\\n        for(len = 0 ; len <= n ; len++)\\n            solve(nums, 0, res);\\n        return ans;\\n    }\\nprivate:\\n    void solve(vector<int>& nums, int index, vector<int> res)\\n    {\\n        if ((int)res.size() == len)\\n            ans.push_back(res);\\n        for(int i = index ; i < n ; i++)\\n        {\\n            res.push_back(nums[i]);\\n            solve(nums, i + 1, res);\\n            res.pop_back();\\n        }\\n    }\\n};\\n\\n90. Subsets II :- https://leetcode.com/problems/subsets-ii/\\n\\nclass Solution {\\n    int len, n;\\n    vector<vector<int> > ans;\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        ans.clear();\\n        n = (int)nums.size();\\n        vector<int> res;\\n        sort(begin(nums),end(nums));\\n        // for(len = 0 ; len <= n ; len++)\\n        solve(nums, 0, res);\\n        return ans;\\n    }\\nprivate:\\n    void solve(vector<int>& nums, int index, vector<int>& res)\\n    {\\n        ans.push_back(res);\\n        for(int i = index ; i < n ; i++)\\n        {\\n            if (i > index && nums[i] == nums[i-1])\\n                continue;\\n            res.push_back(nums[i]);\\n            solve(nums, i + 1, res);\\n            res.pop_back();\\n        }\\n    }\\n};\\n\\n77. Combinations :- https://leetcode.com/problems/combinations/\\n\\nclass Solution {\\n    vector<vector<int> > ans;\\npublic:\\n    void solve(int& n, int k, int curN, vector<int>& cur)\\n    {\\n        if (k == 0)\\n        {\\n            ans.push_back(cur);\\n            return;\\n        }\\n        if (curN > n)\\n            return;\\n        for(int idx = curN ; idx <= n ; idx++)\\n        {\\n            cur.push_back(idx);\\n            solve(n, k-1, idx+1, cur);\\n            cur.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        ans.clear();\\n        vector<int> cur;\\n        solve(n, k, 1, cur);\\n        return ans;\\n    }\\n};\\n\\n39. Combination Sum :- https://leetcode.com/problems/combination-sum/\\n\\nclass Solution {\\n    set<vector<int>> ans;\\npublic:\\n    void solve(vector<int>& candidates, int& target, int idx, int curSum, vector<int> cur)\\n    {\\n        if (curSum == target)\\n        {\\n            ans.insert(cur);\\n            return;\\n        }\\n        if (curSum > target)\\n            return;\\n        if (idx >= candidates.size())\\n            return;\\n        for(int i = idx ; i < candidates.size() ; i++)\\n        {\\n            curSum += candidates[i];\\n            cur.push_back(candidates[i]);\\n            solve(candidates, target, i, curSum, cur);\\n            curSum -= candidates[i];\\n            cur.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        ans.clear();\\n        vector<int> cur;\\n        sort(begin(candidates), end(candidates));\\n        solve(candidates, target, 0, 0, cur);\\n        vector<vector<int>> res;\\n        for(auto it : ans)\\n            res.push_back(it);\\n        return res;\\n    }\\n};\\n\\n17. Letter Combinations of a Phone Number :- https://leetcode.com/problems/letter-combinations-of-a-phone-number/\\n\\nclass Solution {\\npublic:\\n    vector<string> keypad = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    void solve(string &digits, string cur, int idx, vector<string> &ans)\\n    {\\n        if (idx == digits.size())\\n        {\\n            ans.push_back(cur);\\n            return;\\n        }\\n        for(int i = 0 ; i < keypad[digits[idx]-\\'0\\'].size() ; i++)\\n        {\\n            cur.push_back(keypad[digits[idx]-\\'0\\'][i]);\\n            solve(digits, cur, idx+1, ans);\\n            cur.pop_back();\\n        }\\n    }\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        if (digits.size() < 1)\\n            return ans;\\n        solve(digits, \"\", 0, ans);\\n        return ans;\\n    }\\n};\\n\\n40. Combination Sum II :- https://leetcode.com/problems/combination-sum-ii/\\n\\nclass Solution {\\n    set<vector<int>> ans;\\npublic:\\n    void solve(vector<int>& candidates, int& target, int idx, int curSum, vector<int> cur)\\n    {\\n        if (curSum == target)\\n        {\\n            ans.insert(cur);\\n            return;\\n        }\\n        if (curSum > target)\\n            return;\\n        if (idx >= candidates.size())\\n            return;\\n        for(int i = idx ; i < candidates.size() ; i++)\\n        {\\n            curSum += candidates[i];\\n            cur.push_back(candidates[i]);\\n            solve(candidates, target, i+1, curSum, cur);\\n            curSum -= candidates[i];\\n            cur.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        ans.clear();\\n        vector<int> cur;\\n        sort(begin(candidates), end(candidates));\\n        solve(candidates, target, 0, 0, cur);\\n        vector<vector<int>> res;\\n        for(auto it : ans)\\n            res.push_back(it);\\n        return res;\\n    }\\n};\\n\\n216. Combination Sum III :- https://leetcode.com/problems/combination-sum-iii/\\n\\nclass Solution {\\n    vector<vector<int> > ans;\\n    int K, N;\\npublic:\\n    void solve(int n, int curSum, vector<int>& cur)\\n    {\\n        if (curSum == N and cur.size() == K)\\n        {\\n            ans.push_back(cur);\\n            return;\\n        }\\n        if (curSum > N)\\n            return;\\n        if (cur.size() > K)\\n            return;\\n        for(int num = n ; num < 10 ; num++)\\n        {\\n            cur.push_back(num);\\n            solve(num+1, curSum + num, cur);\\n            cur.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        ans.clear();\\n        vector<int> cur;\\n        K = k;\\n        N = n;\\n        solve(1, 0, cur);\\n        return ans;\\n    }\\n};\\n\\n377. Combination Sum IV :- https://leetcode.com/problems/combination-sum-iv/\\n\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<int> dp(target + 1);\\n        dp[0] = 1;\\n        sort (nums.begin(), nums.end());\\n        for (int i = 1; i <= target; i++) {\\n            for (auto num : nums) {\\n                if (i < num) break;\\n                dp[i] = ((long int)dp[i]+dp[i-num])%2147483647 ;\\n            }\\n        }\\n        return dp.back();\\n    }\\n};\\n\\n22. Generate Parentheses :- https://leetcode.com/problems/generate-parentheses/\\n\\nclass Solution {\\npublic:\\n    void generate(string cur,int open,int close,int n,vector<string> &ans){\\n        if(cur.length()>=2*n){\\n            if(open==close && open==n){\\n                ans.push_back(cur);\\n                return;\\n            }else{\\n                return;\\n            }\\n        }\\n        if(open==n && close<open){\\n            cur.push_back(\\')\\');\\n            generate(cur,open,close+1,n,ans);  \\n        }\\n        if(open == close && open < n){\\n            cur.push_back(\\'(\\');\\n            generate(cur,open+1,close,n,ans);\\n        }\\n        if(open>close){\\n            if(open<n){\\n                cur.push_back(\\'(\\');\\n                generate(cur,open+1,close,n,ans);\\n            }\\n            {\\n                cur.push_back(\\')\\');\\n                generate(cur,open,close+1,n,ans);\\n            }\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        generate(\"\",0,0,n,ans);\\n        return ans;\\n    }\\n};\\n\\n20. Valid Parentheses :- https://leetcode.com/problems/valid-parentheses/\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\' || s[i]==\\'[\\' || s[i]==\\'{\\')\\n                st.push(s[i]);\\n            else{\\n                if(st.empty())\\n                    return false;\\n                char tp = st.top();\\n                st.pop();\\n                char cur = s[i];\\n                if(cur==\\')\\' && (tp==\\'{\\' || tp==\\'[\\'))\\n                    return false;\\n                if(cur==\\'}\\' && (tp==\\'(\\' || tp==\\'[\\'))\\n                    return false;\\n                if(cur==\\']\\' && (tp==\\'{\\' || tp==\\'(\\'))\\n                    return false;\\n            }\\n        }\\n        return st.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 711640,
                "title": "0ms-dfs-solution-c-with-inline-comments-o-n-time-and-space",
                "content": "I didn\\'t find a similar solution to this, so I thought i\\'d share :) \\n\\nThe idea is to recurse only into states the kth permutation will be in:\\n```\\nclass Solution {\\npublic:\\n    string ret;\\n\\t\\n    void dfs(int n, int k, int numsAvailable, vector<int> &factorial, vector<bool> &taken){\\n\\t\\t// stop recursing when there are no more elements to pick from\\n        if(numsAvailable == 0)\\n            return;\\n\\t\\t\\t\\n        // factorial(numsAvailable) states will be equally spread across the currently pickable numbers\\n        int goalCount = (((k - 1) / (double) factorial[numsAvailable]) * numsAvailable) + 1; \\n\\t\\t\\n\\t\\t// each pickable number will represent the following number of subspaces\\n        int currentSubspaceSize = factorial[numsAvailable] / numsAvailable;\\n          \\n\\t\\t// currentCount is the number of previously untaken elements from left to right\\n        int currentCount = 0;\\n        for(int num = 1; num <= n; num++){\\n            if(taken[num])\\n                continue;\\n            \\n            currentCount++;\\n            \\n\\t\\t\\t// if reached the un-picked number that kth permutation will be in:\\n            if(currentCount == goalCount){\\n                ret += to_string(num);\\n                taken[num] = true;\\n                \\n\\t\\t\\t\\t// reduce k to search in child subspace.\\n\\t\\t\\t\\t// this is done by removing other \"k\"s that are not in the current space\\n                dfs(n, k - (currentSubspaceSize * (currentCount - 1)), numsAvailable - 1, factorial, taken);\\n                break;\\n            }\\n        }\\n        \\n    }\\n   \\n    string getPermutation(int n, int k) {\\n        \\n        vector<int> factorial(1, 1);\\n        for(int i = 1; i <= n; i++)\\n            factorial.push_back(i * factorial[i - 1]);\\n        \\n        vector<bool> taken(n+1);\\n\\n        dfs(n, k, n, factorial, taken);\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string ret;\\n\\t\\n    void dfs(int n, int k, int numsAvailable, vector<int> &factorial, vector<bool> &taken){\\n\\t\\t// stop recursing when there are no more elements to pick from\\n        if(numsAvailable == 0)\\n            return;\\n\\t\\t\\t\\n        // factorial(numsAvailable) states will be equally spread across the currently pickable numbers\\n        int goalCount = (((k - 1) / (double) factorial[numsAvailable]) * numsAvailable) + 1; \\n\\t\\t\\n\\t\\t// each pickable number will represent the following number of subspaces\\n        int currentSubspaceSize = factorial[numsAvailable] / numsAvailable;\\n          \\n\\t\\t// currentCount is the number of previously untaken elements from left to right\\n        int currentCount = 0;\\n        for(int num = 1; num <= n; num++){\\n            if(taken[num])\\n                continue;\\n            \\n            currentCount++;\\n            \\n\\t\\t\\t// if reached the un-picked number that kth permutation will be in:\\n            if(currentCount == goalCount){\\n                ret += to_string(num);\\n                taken[num] = true;\\n                \\n\\t\\t\\t\\t// reduce k to search in child subspace.\\n\\t\\t\\t\\t// this is done by removing other \"k\"s that are not in the current space\\n                dfs(n, k - (currentSubspaceSize * (currentCount - 1)), numsAvailable - 1, factorial, taken);\\n                break;\\n            }\\n        }\\n        \\n    }\\n   \\n    string getPermutation(int n, int k) {\\n        \\n        vector<int> factorial(1, 1);\\n        for(int i = 1; i <= n; i++)\\n            factorial.push_back(i * factorial[i - 1]);\\n        \\n        vector<bool> taken(n+1);\\n\\n        dfs(n, k, n, factorial, taken);\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698157,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public string GetPermutation(int n, int k) {\\n      \\n        int[] factorial = new int[n+1];\\n        List<int> arr = new List<int>();\\n        \\n        factorial[0] = 1;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            factorial[i] = factorial[i-1] * i;\\n            arr.Add(i);\\n        }\\n        \\n        k--;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 1; i <= n; i++)\\n        {\\n            int index = k / factorial[n - i];\\n            sb.Append(arr[index]);\\n            arr.RemoveAt(index);\\n            k -= index * factorial[n - i];\\n        }\\n        \\n        return sb.ToString();       \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string GetPermutation(int n, int k) {\\n      \\n        int[] factorial = new int[n+1];\\n        List<int> arr = new List<int>();\\n        \\n        factorial[0] = 1;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            factorial[i] = factorial[i-1] * i;\\n            arr.Add(i);\\n        }\\n        \\n        k--;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 1; i <= n; i++)\\n        {\\n            int index = k / factorial[n - i];\\n            sb.Append(arr[index]);\\n            arr.RemoveAt(index);\\n            k -= index * factorial[n - i];\\n        }\\n        \\n        return sb.ToString();       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697306,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> dp;\\n        dp.assign(n+1,0);\\n        dp[0] = 1;\\n        for(int i=1; i<=n; i++){\\n            dp[i] = i*dp[i-1];\\n        }\\n        \\n        string res = \"\";\\n        vector<int> values;\\n        for(int i=0; i<=n; i++){\\n            values.push_back(i);\\n        }\\n        \\n        int temp = n;\\n        auto it = values.begin();\\n        \\n        while(res.length() != n){\\n            int f = dp[temp];\\n            int block_size = f/temp;\\n            int count = 1;\\n            while(k>block_size){\\n                k -= block_size;\\n                count++;\\n            }\\n            //cout << values[count];\\n            res += to_string(values[count]);\\n            values.erase(it+count);\\n            temp--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> dp;\\n        dp.assign(n+1,0);\\n        dp[0] = 1;\\n        for(int i=1; i<=n; i++){\\n            dp[i] = i*dp[i-1];\\n        }\\n        \\n        string res = \"\";\\n        vector<int> values;\\n        for(int i=0; i<=n; i++){\\n            values.push_back(i);\\n        }\\n        \\n        int temp = n;\\n        auto it = values.begin();\\n        \\n        while(res.length() != n){\\n            int f = dp[temp];\\n            int block_size = f/temp;\\n            int count = 1;\\n            while(k>block_size){\\n                k -= block_size;\\n                count++;\\n            }\\n            //cout << values[count];\\n            res += to_string(values[count]);\\n            values.erase(it+count);\\n            temp--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 403067,
                "title": "simplest-cpp-with-explanation",
                "content": "This is a classic math problem.\\nconsider n =3\\n1. Number of permuttions of length n (n digits here) are n!. eg: 3!=6\\n2. It can also be written as n*(n-1)!   eg: 3*(3-1)! = 6\\n3. So there are n groups with (n-1)! permutations in each group.\\n eg: for n=3 there will be 3 groups with ((n-1)! which is) 2 permutation in each group \\n group1 = {123, 132}\\n group2 = {213, 231}\\n group3 = {312, 321}\\nSo the basic math is to identify the group which will contain Kth permutation and then select the element at that index and then repeat the steps for lesser n and k\\n\\nfor n = 3, our first permutaion is \"123\" and k=3 our answer will be 213. how?\\n\\nfrist pass - \\nk = k/fact(n-1)! which is ceil(3/2!) -> 2 so select index 2 (0 based) from the first string which is \"2\";\\nnow k = k%fact(n-1) which is 3%2! -> 1\\nn-- which is 2\\nnow our string is = \"13\", we removed 2\\n\\nsecond pass - \\nk = k/(n-1)! --> 1/1! --> 1 --> index1 in str--> \"1\"\\nk = k%(n-1)! --> 1%1 --> 0(in this case we set k to be (n-1)! which is 1)\\nn-- which is 1\\nnow our string is \"3\"since we removed 1\\n\\nthird pass:\\nk = k = k/(n-1)! --> 1/0! --> 1 --> index1 in str--> \"3\"\\n\\nso one by one we removed 3,2 and 1 from our initial sequence.\\n\\n```\\n string getPermutation(int n, int k) {\\n        string str=\"\";\\n        int fact[] = {1,1,2,6,24,120,720,5040,40320,362880};\\n        for(int i=1;i<=n;i++)\\n        {\\n            str+=to_string(i);\\n        }       \\n        string res = \"\";\\n        while(n>=1)\\n        {\\n            int ind = ceil(k*1.0/fact[n-1]);  // 1.0 because we want to use ceil\\n            k = k%fact[n-1];                  //n-1 because of 0 based indexing\\n            k = (k==0)?fact[n-1]:k;           // need atleast 1 permutation from the next group\\n            n--;                                     \\n            res+=str[ind-1];                  // append identified group index in result\\n            str.erase(ind-1,1);               // shorten intiial pemutation by 1.\\n        }\\n        return res;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n string getPermutation(int n, int k) {\\n        string str=\"\";\\n        int fact[] = {1,1,2,6,24,120,720,5040,40320,362880};\\n        for(int i=1;i<=n;i++)\\n        {\\n            str+=to_string(i);\\n        }       \\n        string res = \"\";\\n        while(n>=1)\\n        {\\n            int ind = ceil(k*1.0/fact[n-1]);  // 1.0 because we want to use ceil\\n            k = k%fact[n-1];                  //n-1 because of 0 based indexing\\n            k = (k==0)?fact[n-1]:k;           // need atleast 1 permutation from the next group\\n            n--;                                     \\n            res+=str[ind-1];                  // append identified group index in result\\n            str.erase(ind-1,1);               // shorten intiial pemutation by 1.\\n        }\\n        return res;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 371641,
                "title": "100-percent-time-and-memory-with-explanation",
                "content": "Explanation:\\n1.  Since n! = n * (n-1)! we can imagine that the possible permutations are divided into n groups of size (n-1)! each\\n2.  Now we have to find the right group where kth permutation exists which we find by using `int idx = k % f == 0 ? k/f - 1 : k/f;`\\n3.  Now within the group of (n-1)! total permutations we want to find `k = k-(idx*f);` th permutation and for that we apply the same logic again \\n\\n```\\nclass Solution {\\npublic:\\n    int fact[10] = {1,1,2,6,24,120,720,5040,40320,362880};\\n    \\n    string getPermutation(int n, int k) {\\n        \\n        string temp = \"\";\\n        for(int i=1; i<=n; i++){\\n            temp += \\'0\\'+i;\\n        }\\n  \\n        vector<int> indices;\\n        \\n        while(n){\\n            int f = fact[n-1];\\n            int idx = k % f == 0 ? k/f - 1 : k/f;\\n            k = k-(idx*f);\\n            n--;\\n            indices.push_back(idx);\\n        }\\n        \\n        string ans = \"\";\\n        for(int i : indices){\\n            ans += temp[i];\\n            temp.erase(i,1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fact[10] = {1,1,2,6,24,120,720,5040,40320,362880};\\n    \\n    string getPermutation(int n, int k) {\\n        \\n        string temp = \"\";\\n        for(int i=1; i<=n; i++){\\n            temp += \\'0\\'+i;\\n        }\\n  \\n        vector<int> indices;\\n        \\n        while(n){\\n            int f = fact[n-1];\\n            int idx = k % f == 0 ? k/f - 1 : k/f;\\n            k = k-(idx*f);\\n            n--;\\n            indices.push_back(idx);\\n        }\\n        \\n        string ans = \"\";\\n        for(int i : indices){\\n            ans += temp[i];\\n            temp.erase(i,1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 310294,
                "title": "c-memorize-solution-follow-the-cook-book-make-a-mean-potato-pie",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    string getPermutation(int n, int k) {\\n        \\n        //Build the factorials memo.\\n        int aFac[n + 1];\\n        aFac[0] = 1;\\n        for (int i=1;i<=n;i++) { aFac[i] = i * aFac[i - 1]; }\\n        \\n        //Reverse the factorials list.\\n        int aLo = 0, aHi = n - 1;\\n        while (aLo < aHi) {\\n            swap(aFac[aLo++], aFac[aHi--]);\\n        }\\n        \\n        //This is our \"bucket\" of numbers to pick from.\\n        char aList[n + 1];\\n        for (int i=0;i<n;i++) {\\n            aList[i] = \\'1\\' + i;\\n        }\\n        int aListCount = n;\\n        \\n        //Storage for our result.\\n        char aRes[n + 1];\\n        aRes[n] = 0;\\n        \\n        \\n        int aIndex = 0;\\n        --k;\\n        \\n        for (int i=0;i<n;i++) {\\n            \\n            //The element we pick. One factorial less than N, divide k by this. This is our \"first letter\" for the \"sub problem\" ...\\n            aIndex = k / aFac[i];\\n            \\n            aRes[i] = aList[aIndex];\\n            \\n            //Delete from list.\\n            for (int j=aIndex + 1;j<aListCount;j++) { aList[j - 1] = aList[j]; }\\n            --aListCount;\\n            \\n            //Remove these permutations from remaining K.\\n            k -= aIndex * aFac[i];\\n            \\n        }\\n        \\n        return string(aRes);\\n    }\\n};\\n```\\n\\nHot ziggity. It\\'s on fire bro.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string getPermutation(int n, int k) {\\n        \\n        //Build the factorials memo.\\n        int aFac[n + 1];\\n        aFac[0] = 1;\\n        for (int i=1;i<=n;i++) { aFac[i] = i * aFac[i - 1]; }\\n        \\n        //Reverse the factorials list.\\n        int aLo = 0, aHi = n - 1;\\n        while (aLo < aHi) {\\n            swap(aFac[aLo++], aFac[aHi--]);\\n        }\\n        \\n        //This is our \"bucket\" of numbers to pick from.\\n        char aList[n + 1];\\n        for (int i=0;i<n;i++) {\\n            aList[i] = \\'1\\' + i;\\n        }\\n        int aListCount = n;\\n        \\n        //Storage for our result.\\n        char aRes[n + 1];\\n        aRes[n] = 0;\\n        \\n        \\n        int aIndex = 0;\\n        --k;\\n        \\n        for (int i=0;i<n;i++) {\\n            \\n            //The element we pick. One factorial less than N, divide k by this. This is our \"first letter\" for the \"sub problem\" ...\\n            aIndex = k / aFac[i];\\n            \\n            aRes[i] = aList[aIndex];\\n            \\n            //Delete from list.\\n            for (int j=aIndex + 1;j<aListCount;j++) { aList[j - 1] = aList[j]; }\\n            --aListCount;\\n            \\n            //Remove these permutations from remaining K.\\n            k -= aIndex * aFac[i];\\n            \\n        }\\n        \\n        return string(aRes);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309503,
                "title": "simple-python-solution-with-thinking-process-beat-99-69",
                "content": "For the permutations of n, \\nthe first (n-1)! permutations are [1] + permutations of {2, 3, ..., n},\\nthe next (n-1)! permutations are [2] + permutations of {1, 3, ..., n},\\n... and so on. \\n```\\n    def getPermutation(self, n: int, k: int) -> str:\\n        factors = [1]\\n        for i in range(1, n):\\n            factors.append(factors[-1] * i)\\n        factors.reverse()\\n        result = \\'\\'\\n        digits = [str(x) for x in range(1, n+1)]\\n        k -= 1\\n        for i in range(n):\\n            index, k = divmod(k, factors[i]) # factors[i] = math.factorial(n-1-i)\\n            fst_digit = digits[index]\\n            result += fst_digit\\n            digits.remove(fst_digit)\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\n    def getPermutation(self, n: int, k: int) -> str:\\n        factors = [1]\\n        for i in range(1, n):\\n            factors.append(factors[-1] * i)\\n        factors.reverse()\\n        result = \\'\\'\\n        digits = [str(x) for x in range(1, n+1)]\\n        k -= 1\\n        for i in range(n):\\n            index, k = divmod(k, factors[i]) # factors[i] = math.factorial(n-1-i)\\n            fst_digit = digits[index]\\n            result += fst_digit\\n            digits.remove(fst_digit)\\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 297433,
                "title": "python-8-ms-faster-than-100-of-solutions-10-lines-of-code",
                "content": "```\\nimport math\\nclass Solution(object):\\n    def getPermutation(self, n, k):\\n        combinations = math.factorial(n)\\n        nums = [str(i) for i in range(1, n+1)]\\n        digits = \\'\\'\\n        for i in range(n, 1, -1):\\n            combinations = combinations/i\\n            (bucket, k) = divmod(k, combinations)\\n            if k == 0: bucket -= 1\\n            digits += nums[bucket]\\n            del nums[bucket]\\n        return digits + nums[0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport math\\nclass Solution(object):\\n    def getPermutation(self, n, k):\\n        combinations = math.factorial(n)\\n        nums = [str(i) for i in range(1, n+1)]\\n        digits = \\'\\'\\n        for i in range(n, 1, -1):\\n            combinations = combinations/i\\n            (bucket, k) = divmod(k, combinations)\\n            if k == 0: bucket -= 1\\n            digits += nums[bucket]\\n            del nums[bucket]\\n        return digits + nums[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 170412,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def getPermutation(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        fact = [1]*(n)\\n        digits = [i for i in range(1,10)]\\n        for i in range(2,n):\\n            fact[i] = i * fact[i-1]\\n        summ = 0\\n        res = \"\"\\n        k -= 1\\n        for i in range(n-1,-1,-1):\\n            q, k = divmod(k, fact[i])\\n            res += str(digits.pop(q))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def getPermutation(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        fact = [1]*(n)\\n        digits = [i for i in range(1,10)]\\n        for i in range(2,n):\\n            fact[i] = i * fact[i-1]\\n        summ = 0\\n        res = \"\"\\n        k -= 1\\n        for i in range(n-1,-1,-1):\\n            q, k = divmod(k, fact[i])\\n            res += str(digits.pop(q))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22600,
                "title": "java-iterative-solution",
                "content": "        \\n    public String getPermutation(int n, int k) {\\n        List<Integer> nums = new LinkedList<>();\\n        for (int i = 1; i <= n; i++) {\\n            nums.add(i);\\n        }\\n        String ret = \"\";\\n        k--;\\n        while (!nums.isEmpty()) {\\n            int f = fact(n-1);\\n            int i = k / f;\\n            ret += nums.get(i).toString();\\n            nums.remove(i);\\n            k -= k/f*f;\\n            n--;\\n        }\\n        return ret;\\n    }\\n    \\n    private int fact(int n) {\\n        int ret = 1;\\n        for (int i = 1; i <= n; i++) {\\n            ret *= i;\\n        }\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "        \\n    public String getPermutation(int n, int k) {\\n        List<Integer> nums = new LinkedList<>();\\n        for (int i = 1; i <= n; i++) {\\n            nums.add(i);\\n        }\\n        String ret = \"\";\\n        k--;\\n        while (!nums.isEmpty()) {\\n            int f = fact(n-1);\\n            int i = k / f;\\n            ret += nums.get(i).toString();\\n            nums.remove(i);\\n            k -= k/f*f;\\n            n--;\\n        }\\n        return ret;\\n    }\\n    \\n    private int fact(int n) {\\n        int ret = 1;\\n        for (int i = 1; i <= n; i++) {\\n            ret *= i;\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 22653,
                "title": "another-solution-in-java-with-explanation-no-loop-no-swap-easy-understanding-200ms",
                "content": "    public String getPermutation(int n, int k) {\\n        List<Integer> participate = new ArrayList<>(n);\\n        if (n <= 1) {\\n            return \"1\";\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            participate.add(i);//build an initial list\\n        }\\n        return recur(n, k - 1, participate, new StringBuilder(n));//k-1 for get element from list\\n    }\\n\\n    private String recur(int n, int k, List<Integer> participate, StringBuilder sb) {\\n        if (n == 2) {\\n            sb.append(participate.get(k));\\n            participate.remove(k);\\n            sb.append(participate.get(participate.size() - 1));\\n            return sb.toString();\\n        }\\n        int x = fac(n); // x: sequence length Example: n = 5, there are 5 sequences start with 1 to 5, each sequence has 24 items\\n        int i = k / x; // i: which sequence the search k it belong. Example: n=4 k=8, i=(8-1)/6=1. so the start number should be 2\\n        sb.append(participate.get(i));\\n        participate.remove(i);\\n        return recur(n - 1, k % x, participate, sb);\\n    }\\n\\n    private int fac(int n) {\\n        int sum = 1;\\n        for (int i = 1; i < n; i++) {\\n            sum *= i;\\n        }\\n        return sum;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public String getPermutation(int n, int k) {\\n        List<Integer> participate = new ArrayList<>(n);\\n        if (n <= 1) {\\n            return \"1\";\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            participate.add(i);//build an initial list\\n        }\\n        return recur(n, k - 1, participate, new StringBuilder(n));//k-1 for get element from list\\n    }\\n\\n    private String recur(int n, int k, List<Integer> participate, StringBuilder sb) {\\n        if (n == 2) {\\n            sb.append(participate.get(k));\\n            participate.remove(k);\\n            sb.append(participate.get(participate.size() - 1));\\n            return sb.toString();\\n        }\\n        int x = fac(n); // x: sequence length Example: n = 5, there are 5 sequences start with 1 to 5, each sequence has 24 items\\n        int i = k / x; // i: which sequence the search k it belong. Example: n=4 k=8, i=(8-1)/6=1. so the start number should be 2\\n        sb.append(participate.get(i));\\n        participate.remove(i);\\n        return recur(n - 1, k % x, participate, sb);\\n    }\\n\\n    private int fac(int n) {\\n        int sum = 1;\\n        for (int i = 1; i < n; i++) {\\n            sum *= i;\\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 22670,
                "title": "c-0ms-observation-solution",
                "content": "    class Solution {\\n    public:\\n        string getPermutation(int n, int k) {\\n            int mloop[10] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};\\n            string ans;\\n            vector<int> remain;\\n            for (int i = 1; i <= n; ++i) {\\n                remain.push_back(i);\\n            }\\n            for (int i = n; i > 0; --i) {\\n                int j = ((k - 1) % mloop[i]) / mloop[i - 1];\\n                ans += (remain[j] + '0');\\n                remain.erase(remain.begin() + j);\\n            }\\n            return ans;\\n        }\\n    };\\n\\n    ()1234           (1)234         (12)34        (123)4\\n    1 1234           1 234           1 34     =>    1 4\\n    2 1243           2 243     =>    2 43\\n    3 1324           3 324\\n    4 1342  =>       4 3....\\n    5 1423\\n    6 1432\\n    7 2134\\n    8 2......",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string getPermutation(int n, int k) {\\n            int mloop[10] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880}",
                "codeTag": "Java"
            },
            {
                "id": 22678,
                "title": "c-4ms-recursive-solution-with-explanation",
                "content": "\\n\\n    // We have to return the k-th permutation \\n    // in lexicographic order.\\n    //\\n    // We can take a recursive approach.\\n    // The lexicographic order means that first\\n    // we have those starting with digit 1 then\\n    // those starting with 2 and so on until\\n    // digit n.\\n    // \\n    // For example, for n = 4, we have: \\n    // k   perm\\n    // --------\\n    // 1   1234\\n    // 2   1243\\n    // 3   1324\\n    // 4   1342\\n    // 5   1423\\n    // 6   1432\\n    //\\n    // 7   2134\\n    // 8   2143\\n    // 9   2314\\n    // 10  2341\\n    // 11  2413\\n    // 12  2431\\n    // \\n    // 13  3124\\n    // 14  3142\\n    // 15  3214\\n    // 16  3241\\n    // 17  3412\\n    // 18  3421\\n    // \\n    // 19  4123\\n    // 20  4132\\n    // 21  4213\\n    // 22  4231\\n    // 23  4312\\n    // 24  4321\\n    //\\n    // Since there are n digits, the number of all \\n    // permutations starting with a given digit d\\n    // is equal to (n-1)!.\\n    // Given k, the permutation order number,\\n    // we can determine which one is the first \\n    // digit d: d = [(k-1)/(n-1)!]+1;\\n    // \\n    // Once we determined the first digit\\n    // we recursively determine the remaining\\n    // digits.\\n    // \\n    // We keep all digits in a vector: {1,2,3,...,n}.\\n    // Once we determine a digit we remove it\\n    // from there and recursively solve\\n    // the problem for the remaining n-1 digits.\\n    // The formula above to determine the digit\\n    // is written slightly different in code\\n    // such that instead of the digit we first\\n    // get its index in this vector.\\n    //\\n    // From k we can also determine k for the\\n    // n-1 problem as: prevK = k%prevFact.\\n    // This is the order number within the \\n    // current digit's group.\\n    //\\n    // Now we can recursively solve the problem \\n    // for n-1 and prevK and determine the rest \\n    // of the digits.\\n    //\\n    class Solution\\n    {\\n        int factorial(int n)\\n        {\\n            int fact = 1;\\n            for (int i = 1; i <= n; i++)\\n                fact *= i;\\n    \\n            return fact;\\n        }\\n    \\n        string getPermutation(int n, int k, vector<int>& digits)\\n        {\\n            if (n == 1)\\n            {\\n                return to_string(digits[0]);\\n            }\\n    \\n            int prevFact = factorial(n - 1);\\n    \\n            int idx = (k - 1) / prevFact;\\n            int d = digits[idx];\\n    \\n            digits.erase(digits.begin() + idx);\\n    \\n            int prevK = k%prevFact;\\n            if (prevK == 0)\\n                prevK = prevFact;\\n    \\n            string prev = getPermutation(n - 1, prevK, digits);\\n    \\n            return to_string(d) + prev;\\n        }\\n    \\n    public:\\n        string getPermutation(int n, int k)\\n        {\\n            vector<int> digits;\\n            for (int i = 1; i <= n; i++)\\n            {\\n                digits.push_back(i);\\n            }\\n    \\n            return getPermutation(n, k, digits);\\n        }\\n    };",
                "solutionTags": [
                    "Recursion",
                    "Probability and Statistics"
                ],
                "code": "class Solution\\n    {\\n        int factorial(int n)\\n        {\\n            int fact = 1;\\n            for (int i = 1; i <= n; i++)\\n                fact *= i;\\n    \\n            return fact;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4061982,
                "title": "python-10ms-solution",
                "content": "# Intuition\\nFor this problem, my first realization was that for each starting number there are (n-1)! possibilites. Eg:\\n\\nn=4\\nfor the starting number 1 the possiblities are:\\n1,2,3,4\\n1,2,4,3\\n1,3,2,4\\n1,3,4,2\\n1,4,2,3\\n1,4,3,2\\nThere are 6 possibilities which is the same as 3!\\nSo with this, we should be able to through each digit and to find the proper number permutation. \\n\\n# Approach\\nSomething to realize is that you can you can find the starting number for the permutation by doing k/(n-1)!\\nThis is because for each possible starting number 1-n, there are (n-1)! possibilities, so if we divide k by this, we will get the starting number. \\n\\nSo you keep doing this for each digit. We divide k by (n-1)!, then add the integer part. K will then become whatever the remainder is, because we are subtracting that many possiblities. \\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def getPermutation(self, n, k):\\n        #For each starting number there are (n-1)! possiblities. So the trick is you can find which digit it is by \\n        #Doing k/(n-1)!, and you get the starting number that fits that range, so you keep doing taht untill you reach the answer\\n        if k==1:\\n            return \"\".join([str(a) for a in range(1,n+1)])\\n        ans=\"\"\\n        possible=[a for a in range(1,n+1)]\\n        k-=1#Because arrays start at 0, and this k starts at 1\\n        while n>0:\\n            n-=1\\n            index,k=divmod(k,math.factorial(n))\\n            ans+=str(possible[index])\\n            possible.pop(index)\\n        return ans\\n\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def getPermutation(self, n, k):\\n        #For each starting number there are (n-1)! possiblities. So the trick is you can find which digit it is by \\n        #Doing k/(n-1)!, and you get the starting number that fits that range, so you keep doing taht untill you reach the answer\\n        if k==1:\\n            return \"\".join([str(a) for a in range(1,n+1)])\\n        ans=\"\"\\n        possible=[a for a in range(1,n+1)]\\n        k-=1#Because arrays start at 0, and this k starts at 1\\n        while n>0:\\n            n-=1\\n            index,k=divmod(k,math.factorial(n))\\n            ans+=str(possible[index])\\n            possible.pop(index)\\n        return ans\\n\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050510,
                "title": "permutation-sequence-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n       \\t\\n        string getPermutation(int n, int k)\\n        {\\n            string ans = \"\";\\n            vector<int> numbers;\\n            int fact = 1;\\n            for (int i = 1; i <= n; i++)\\n            {\\n                fact = fact * i;\\n                numbers.push_back(i);\\n            }\\n            int blockSize = fact / n;\\n            k = k - 1;\\n            while (true)\\n            {\\n                ans += to_string(numbers[k / blockSize]);\\t\\n                numbers.erase(numbers.begin() + k / blockSize);\\n                if (numbers.size() == 0)\\n                {\\n                    break;\\n                }\\n                k = k % blockSize;\\n                blockSize = blockSize / numbers.size();\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n       \\t\\n        string getPermutation(int n, int k)\\n        {\\n            string ans = \"\";\\n            vector<int> numbers;\\n            int fact = 1;\\n            for (int i = 1; i <= n; i++)\\n            {\\n                fact = fact * i;\\n                numbers.push_back(i);\\n            }\\n            int blockSize = fact / n;\\n            k = k - 1;\\n            while (true)\\n            {\\n                ans += to_string(numbers[k / blockSize]);\\t\\n                numbers.erase(numbers.begin() + k / blockSize);\\n                if (numbers.size() == 0)\\n                {\\n                    break;\\n                }\\n                k = k % blockSize;\\n                blockSize = blockSize / numbers.size();\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972282,
                "title": "most-optimal-solution-without-using-recursion-and-backtracking-with-complete-exaplanation",
                "content": "\\n\\n# Approach\\nThe given solution aims to find the kth permutation sequence of numbers from 1 to n. It uses a mathematical approach to determine the digits of the kth permutation by repeatedly calculating the factorial of (n-1), identifying the next digit in the permutation, and updating the remaining digits.\\n\\nHere\\'s the explanation of the solution steps:\\n\\n1. Calculate the factorial of (n-1) to determine the count of permutations that can be formed with the remaining digits.\\n2. Create a list called nums containing numbers from 1 to n.\\n3. Adjust k to be 0-based (k = k - 1).\\n4. Repeatedly find the next digit in the permutation by dividing k by the current factorial value. This indicates which digit from the remaining digits list should be added to the answer.\\n5. Remove the selected digit from the nums list.\\n6. Update k by taking the remainder after division by the current factorial value.\\n7. Update the factorial value by dividing it by the size of the nums list.\\n8. Repeat steps 4-7 until all digits are added to the answer.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact = 1;\\n        vector<int> nums;\\n        \\n        for (int i = 1; i < n; i++) {\\n            fact = fact * i;\\n            nums.push_back(i);\\n        }\\n        nums.push_back(n);\\n        \\n        string ans = \"\";\\n        k = k - 1;\\n        \\n        while (true) {\\n            ans = ans + to_string(nums[k / fact]);\\n            nums.erase(nums.begin() + k / fact);\\n            \\n            if (nums.size() == 0) {\\n                break;\\n            }\\n            \\n            k = k % fact;\\n            fact = fact / nums.size();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```\\n```JAVA []\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int fact = 1;\\n        List<Integer> nums = new ArrayList<>();\\n        \\n        for (int i = 1; i < n; i++) {\\n            fact *= i;\\n            nums.add(i);\\n        }\\n        nums.add(n);\\n        \\n        StringBuilder ans = new StringBuilder();\\n        k--;\\n        \\n        while (true) {\\n            ans.append(nums.get(k / fact));\\n            nums.remove(k / fact);\\n            \\n            if (nums.isEmpty()) {\\n                break;\\n            }\\n            \\n            k %= fact;\\n            fact /= nums.size();\\n        }\\n        \\n        return ans.toString();\\n    }\\n}\\n\\n```\\n```Python3 []\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        fact = 1\\n        nums = list(range(1, n + 1))\\n        \\n        for i in range(1, n):\\n            fact *= i\\n        \\n        ans = []\\n        k -= 1\\n        \\n        while True:\\n            ans.append(str(nums[k // fact]))\\n            nums.pop(k // fact)\\n            \\n            if not nums:\\n                break\\n            \\n            k %= fact\\n            fact //= len(nums)\\n        \\n        return \\'\\'.join(ans)\\n**Bold**\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact = 1;\\n        vector<int> nums;\\n        \\n        for (int i = 1; i < n; i++) {\\n            fact = fact * i;\\n            nums.push_back(i);\\n        }\\n        nums.push_back(n);\\n        \\n        string ans = \"\";\\n        k = k - 1;\\n        \\n        while (true) {\\n            ans = ans + to_string(nums[k / fact]);\\n            nums.erase(nums.begin() + k / fact);\\n            \\n            if (nums.size() == 0) {\\n                break;\\n            }\\n            \\n            k = k % fact;\\n            fact = fact / nums.size();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```\n```JAVA []\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int fact = 1;\\n        List<Integer> nums = new ArrayList<>();\\n        \\n        for (int i = 1; i < n; i++) {\\n            fact *= i;\\n            nums.add(i);\\n        }\\n        nums.add(n);\\n        \\n        StringBuilder ans = new StringBuilder();\\n        k--;\\n        \\n        while (true) {\\n            ans.append(nums.get(k / fact));\\n            nums.remove(k / fact);\\n            \\n            if (nums.isEmpty()) {\\n                break;\\n            }\\n            \\n            k %= fact;\\n            fact /= nums.size();\\n        }\\n        \\n        return ans.toString();\\n    }\\n}\\n\\n```\n```Python3 []\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        fact = 1\\n        nums = list(range(1, n + 1))\\n        \\n        for i in range(1, n):\\n            fact *= i\\n        \\n        ans = []\\n        k -= 1\\n        \\n        while True:\\n            ans.append(str(nums[k // fact]))\\n            nums.pop(k // fact)\\n            \\n            if not nums:\\n                break\\n            \\n            k %= fact\\n            fact //= len(nums)\\n        \\n        return \\'\\'.join(ans)\\n**Bold**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3803225,
                "title": "best-solution-possible-world-record-iq-10000",
                "content": "# Intuition\\nSolve more problems you will get the intuition. \\n\\n# Approach\\nArey bindu, dekh agar n=5 hai toh agar mai kisi ek number from 1-5 ko first element banata hu toh 4! options hoga each ka. \\n\\nAgar k = 59 hai, then k = (24 + 24 + 11). \\nThat means starting mai 3 ayega and uske ander permutions hoga further.\\nWhi dekh le re thoda. \\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string helper(int n, set<int> st, int k){\\n        // basecase\\n        if(n == st.size()){ return \"\"; }\\n        \\n        // transition\\n        int val = 1;\\n        for(int i = 1; i<n - st.size(); i++) val *= i;\\n\\n        int pos = k/val + (k%val ? 1 : 0);\\n        \\n        string s;\\n        for(int i = 1; i<=n; i++){\\n            if(st.find(i) == st.end() && --pos == 0){\\n                st.insert(i);\\n                s = \\'0\\' + i;\\n                break;\\n            }\\n        }\\n\\n        return s + helper(n, st, (k % val) ? (k % val) : val);\\n    }\\n\\n    string getPermutation(int n, int k) {\\n        set<int> st;\\n        return helper(n, st, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string helper(int n, set<int> st, int k){\\n        // basecase\\n        if(n == st.size()){ return \"\"; }\\n        \\n        // transition\\n        int val = 1;\\n        for(int i = 1; i<n - st.size(); i++) val *= i;\\n\\n        int pos = k/val + (k%val ? 1 : 0);\\n        \\n        string s;\\n        for(int i = 1; i<=n; i++){\\n            if(st.find(i) == st.end() && --pos == 0){\\n                st.insert(i);\\n                s = \\'0\\' + i;\\n                break;\\n            }\\n        }\\n\\n        return s + helper(n, st, (k % val) ? (k % val) : val);\\n    }\\n\\n    string getPermutation(int n, int k) {\\n        set<int> st;\\n        return helper(n, st, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546130,
                "title": "beats-100-0ms-cpp-intuitive-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        if(n==0 || n==1)    return to_string(n);\\n        vector<int> seq;\\n        for(int i=1;i<n;i++)\\n        {\\n            seq.push_back(i);\\n            fact*=i;\\n        }\\n        seq.push_back(n);\\n        k-=1;\\n        string  ans=\"\";\\n        \\n        while(seq.size()!=0){\\n            int pos=k/fact;\\n            ans+=to_string(seq[pos]);\\n            seq.erase(seq.begin()+pos);\\n            if(seq.size()==0)   break; //put this line to avoid divide by zero exception\\n            k=k%fact;\\n            fact=fact/seq.size();\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        if(n==0 || n==1)    return to_string(n);\\n        vector<int> seq;\\n        for(int i=1;i<n;i++)\\n        {\\n            seq.push_back(i);\\n            fact*=i;\\n        }\\n        seq.push_back(n);\\n        k-=1;\\n        string  ans=\"\";\\n        \\n        while(seq.size()!=0){\\n            int pos=k/fact;\\n            ans+=to_string(seq[pos]);\\n            seq.erase(seq.begin()+pos);\\n            if(seq.size()==0)   break; //put this line to avoid divide by zero exception\\n            k=k%fact;\\n            fact=fact/seq.size();\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477699,
                "title": "easy-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        int fact = 1;\\n        for(int i = 1;i<n;i++){\\n            arr.add(i);\\n            fact*=i;\\n        }\\n        k = k-1;\\n        String s = \"\";\\n        arr.add(n);\\n        while(true){\\n            s += \"\"+arr.get(k/fact);\\n            arr.remove(Integer.valueOf(arr.get(k/fact)));\\n            if(arr.size() == 0){\\n                break;\\n            }\\n            k = k%fact;\\n            fact = fact/arr.size();\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        int fact = 1;\\n        for(int i = 1;i<n;i++){\\n            arr.add(i);\\n            fact*=i;\\n        }\\n        k = k-1;\\n        String s = \"\";\\n        arr.add(n);\\n        while(true){\\n            s += \"\"+arr.get(k/fact);\\n            arr.remove(Integer.valueOf(arr.get(k/fact)));\\n            if(arr.size() == 0){\\n                break;\\n            }\\n            k = k%fact;\\n            fact = fact/arr.size();\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370125,
                "title": "c-beats-100-t-c-o-n-2-s-c-o-n",
                "content": "```\\nclass Solution {\\n\\n\\t/*\\n\\t\\tTime Complexity : O(N^2)\\n\\t\\tSpace Complexity : O(N)\\n\\t*/\\n\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact = 1;\\n        vector<int> nums;\\n        \\n        // calculate fact till n-1\\n        for(int i=1; i<n; i++){\\n            fact *= i;\\n            nums.push_back(i);\\n        }\\n        nums.push_back(n);\\n        \\n        k -= 1; // as we are using 0-based indexing\\n        \\n        string res = \"\";\\n        \\n        while(true){\\n            res += to_string(nums[k/fact]);\\n            nums.erase(nums.begin() + k/fact);\\n            \\n            if(nums.size() == 0) break; // no more elements left\\n            \\n            k %= fact;\\n            fact /= nums.size();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n\\t/*\\n\\t\\tTime Complexity : O(N^2)\\n\\t\\tSpace Complexity : O(N)\\n\\t*/\\n\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact = 1;\\n        vector<int> nums;\\n        \\n        // calculate fact till n-1\\n        for(int i=1; i<n; i++){\\n            fact *= i;\\n            nums.push_back(i);\\n        }\\n        nums.push_back(n);\\n        \\n        k -= 1; // as we are using 0-based indexing\\n        \\n        string res = \"\";\\n        \\n        while(true){\\n            res += to_string(nums[k/fact]);\\n            nums.erase(nums.begin() + k/fact);\\n            \\n            if(nums.size() == 0) break; // no more elements left\\n            \\n            k %= fact;\\n            fact /= nums.size();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298632,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        List<Integer>list=new ArrayList<>();\\n        int fact=1;\\n        for(int i=1;i<n;i++){\\n            fact=fact*i;\\n            list.add(i);\\n        }\\n        list.add(n);\\n        k=k-1;\\n        String ans=\"\";\\n        while(true){\\n            ans+=list.get(k/fact);\\n            list.remove(k/fact);\\n            if(list.size()==0){\\n                break;\\n            }\\n            k=k%fact;\\n            fact=fact/list.size();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        List<Integer>list=new ArrayList<>();\\n        int fact=1;\\n        for(int i=1;i<n;i++){\\n            fact=fact*i;\\n            list.add(i);\\n        }\\n        list.add(n);\\n        k=k-1;\\n        String ans=\"\";\\n        while(true){\\n            ans+=list.get(k/fact);\\n            list.remove(k/fact);\\n            if(list.size()==0){\\n                break;\\n            }\\n            k=k%fact;\\n            fact=fact/list.size();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293254,
                "title": "easy-4-steps-understandable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int fact = 1;\\n        List<Integer> al = new ArrayList<>();\\n        for(int i = 1;i < n; i++){\\n            fact *= i;\\n            al.add(i);\\n        }\\n        al.add(n);\\n        String ans = \"\";\\n        k--;\\n        while(true){\\n            ans += al.get(k / fact); //finding the index where the value should start (MSB)\\n            al.remove(k / fact); // after finding that value we need to delete that from list\\n            if(al.size() == 0)\\n                break; // if list is empty then done;\\n            k %= fact;  //again decrease k value and apply for other values.\\n            fact /= al.size();\\n        }\\n        return ans;\\n    }   \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int fact = 1;\\n        List<Integer> al = new ArrayList<>();\\n        for(int i = 1;i < n; i++){\\n            fact *= i;\\n            al.add(i);\\n        }\\n        al.add(n);\\n        String ans = \"\";\\n        k--;\\n        while(true){\\n            ans += al.get(k / fact); //finding the index where the value should start (MSB)\\n            al.remove(k / fact); // after finding that value we need to delete that from list\\n            if(al.size() == 0)\\n                break; // if list is empty then done;\\n            k %= fact;  //again decrease k value and apply for other values.\\n            fact /= al.size();\\n        }\\n        return ans;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176505,
                "title": "beats-99-7-60-permutation-sequence-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nHere, we use a simple factorial approach. First, we calculate all the factorials up to n, and use that to find the next number to add to the result. We start from the last factorial and keep adding numbers to the result, decrementing k and removing the selected number from the list. This continues until all numbers have been added to the result and k becomes 0. We return the result as a single string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        nums = [i for i in range(1, n+1)] # list of numbers from 1 to n\\n        factorial = [1] * n # initialize factorial with n factorial of 1\\n        for i in range(1, n):\\n            factorial[i] = factorial[i-1] * i # calculate the factorials\\n        \\n        k -= 1 # decrement k by 1, since k is 1-indexed\\n        result = []\\n        for i in range(n-1, -1, -1):\\n            index = k // factorial[i] # calculate the index of the number to be picked\\n            result.append(str(nums[index])) # add the number to result\\n            nums.pop(index) # remove the number from the list\\n            k = k % factorial[i] # update k\\n        \\n        return \\'\\'.join(result) # join the result list into a single string and return\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        nums = [i for i in range(1, n+1)] # list of numbers from 1 to n\\n        factorial = [1] * n # initialize factorial with n factorial of 1\\n        for i in range(1, n):\\n            factorial[i] = factorial[i-1] * i # calculate the factorials\\n        \\n        k -= 1 # decrement k by 1, since k is 1-indexed\\n        result = []\\n        for i in range(n-1, -1, -1):\\n            index = k // factorial[i] # calculate the index of the number to be picked\\n            result.append(str(nums[index])) # add the number to result\\n            nums.pop(index) # remove the number from the list\\n            k = k % factorial[i] # update k\\n        \\n        return \\'\\'.join(result) # join the result list into a single string and return\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3133297,
                "title": "recursion-easy-approach-c",
                "content": "# Intuition\\nJust keep fixing the position of element by finding their relevant group. Then remove that fixed element from the data strucuture i.e. vector. Check for remaining elements until vector is empty.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$ \\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact = 1;\\n        vector<int> numbers;\\n        for(int i=1;i<n;i++){\\n            // To find (n-1)!\\n            fact = fact*i;\\n            numbers.push_back(i);\\n        }\\n        numbers.push_back(n);\\n        string ans=\"\";\\n        k = k-1;\\n        while(true){\\n            //Add the first element of reqd permutation\\n            ans = ans + to_string(numbers[k/fact]);\\n            //Erase that element from vector \\n            numbers.erase(numbers.begin() + k/fact);\\n            if(numbers.size()==0) break;\\n            //Find the position for remaining elements\\n            k = k%fact;\\n            //Find the reqd factorial\\n            fact = fact/numbers.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact = 1;\\n        vector<int> numbers;\\n        for(int i=1;i<n;i++){\\n            // To find (n-1)!\\n            fact = fact*i;\\n            numbers.push_back(i);\\n        }\\n        numbers.push_back(n);\\n        string ans=\"\";\\n        k = k-1;\\n        while(true){\\n            //Add the first element of reqd permutation\\n            ans = ans + to_string(numbers[k/fact]);\\n            //Erase that element from vector \\n            numbers.erase(numbers.begin() + k/fact);\\n            if(numbers.size()==0) break;\\n            //Find the position for remaining elements\\n            k = k%fact;\\n            //Find the reqd factorial\\n            fact = fact/numbers.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106468,
                "title": "6ms-o-n-2-efficient-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact =1;\\n        vector<int>numbers;\\n        for(int i =1 ;i<n;i++){\\n            fact = fact*i;\\n            numbers.push_back(i);\\n        }\\n        numbers.push_back(n);\\n        string ans =\"\";\\n        k = k-1;\\n\\n        while(true){\\n            ans = ans+ to_string(numbers[k/fact]);\\n            numbers.erase(numbers.begin() + k/fact);\\n            if(numbers.size()==0){\\n                break;\\n            }\\n            k = k%fact;\\n            fact = fact/numbers.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact =1;\\n        vector<int>numbers;\\n        for(int i =1 ;i<n;i++){\\n            fact = fact*i;\\n            numbers.push_back(i);\\n        }\\n        numbers.push_back(n);\\n        string ans =\"\";\\n        k = k-1;\\n\\n        while(true){\\n            ans = ans+ to_string(numbers[k/fact]);\\n            numbers.erase(numbers.begin() + k/fact);\\n            if(numbers.size()==0){\\n                break;\\n            }\\n            k = k%fact;\\n            fact = fact/numbers.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028301,
                "title": "c-easy-to-understand-beats-100-percent",
                "content": "please upvote if you like the solution.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\" ;\\n        vector<int>ds ;\\n        for(int i = 1 ; i <= n ; i++){\\n            ds.push_back(i) ;\\n        }\\n        int i = n ;\\n        while(k!= 0 && i >= 1){\\n            int r = fact(i-1) ;\\n            int c = check(r,k) ;\\n            s += to_string(ds[c]) ;\\n            ds.erase(ds.begin()+c) ;\\n            k = k -r*c ;\\n            i-- ;\\n        }\\n        return s ;\\n    }\\n    int check(int a ,int k){\\n        if(k%a == 0)return (k/a) - 1 ;\\n        return k/a ;\\n    }\\n    int fact(int n){\\n        if(n == 0)return 1 ;\\n        return n*fact(n-1) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\" ;\\n        vector<int>ds ;\\n        for(int i = 1 ; i <= n ; i++){\\n            ds.push_back(i) ;\\n        }\\n        int i = n ;\\n        while(k!= 0 && i >= 1){\\n            int r = fact(i-1) ;\\n            int c = check(r,k) ;\\n            s += to_string(ds[c]) ;\\n            ds.erase(ds.begin()+c) ;\\n            k = k -r*c ;\\n            i-- ;\\n        }\\n        return s ;\\n    }\\n    int check(int a ,int k){\\n        if(k%a == 0)return (k/a) - 1 ;\\n        return k/a ;\\n    }\\n    int fact(int n){\\n        if(n == 0)return 1 ;\\n        return n*fact(n-1) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023786,
                "title": "python-beats-98-easy-optimum-solution",
                "content": "**This is optimum question **\\n```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        s=[]\\n        for i in range(n):\\n            s.append(str(i+1))\\n        \\n        def fun(s,k,l):\\n            p=[]\\n            fact=factorial(l)\\n            #print(fact)\\n            while (s!=[]): \\n                fact=fact//l\\n                #print(fact)\\n                i,k=divmod(k,fact)\\n                #print(i,k)\\n                x=s[i] \\n                p.append(x) \\n                s=s[:i]+s[i+1:]\\n                #print(s)\\n                l-=1\\n                #print(p)\\n            return \"\".join(p)\\n        \\n        return fun(s,k-1,n)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        s=[]\\n        for i in range(n):\\n            s.append(str(i+1))\\n        \\n        def fun(s,k,l):\\n            p=[]\\n            fact=factorial(l)\\n            #print(fact)\\n            while (s!=[]): \\n                fact=fact//l\\n                #print(fact)\\n                i,k=divmod(k,fact)\\n                #print(i,k)\\n                x=s[i] \\n                p.append(x) \\n                s=s[:i]+s[i+1:]\\n                #print(s)\\n                l-=1\\n                #print(p)\\n            return \"\".join(p)\\n        \\n        return fun(s,k-1,n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823057,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s, ans;\\n        for(int i=1; i<=n; i++) s.push_back(i + \\'0\\');\\n        int cnt = 0;\\n        do {\\n            cnt++;\\n            if(cnt == k) {\\n                ans = s;\\n                break;\\n            }\\n        }\\n        while(next_permutation(s.begin(), s.end()));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s, ans;\\n        for(int i=1; i<=n; i++) s.push_back(i + \\'0\\');\\n        int cnt = 0;\\n        do {\\n            cnt++;\\n            if(cnt == k) {\\n                ans = s;\\n                break;\\n            }\\n        }\\n        while(next_permutation(s.begin(), s.end()));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2822830,
                "title": "5-lines-only-easy-to-understand-code-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n      string s = \"\";\\n      for(int i = 1 ; i <= n ; i++) s += to_string(i);\\n      if(k == 1) return s; // base case: if k is 1, means the original string is the kth permutation, so return the original string\\n      do{\\n        next_permutation(s.begin(), s.end());\\n        k--;\\n      }\\n      while(k > 1);\\n      return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n      string s = \"\";\\n      for(int i = 1 ; i <= n ; i++) s += to_string(i);\\n      if(k == 1) return s; // base case: if k is 1, means the original string is the kth permutation, so return the original string\\n      do{\\n        next_permutation(s.begin(), s.end());\\n        k--;\\n      }\\n      while(k > 1);\\n      return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2817166,
                "title": "c-simple-solution-using-stl-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. create a string\\n2. base case where k=1\\n3. find next permutation until k=1\\n4. when u reach k=1 break the loop\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string ans = \"\";\\n        string temp = \"\";\\n        for(int i=1;i<=n;i++){\\n            temp += to_string(i);\\n        }\\n        if(k == 1){\\n            return temp;\\n        }\\n        while(next_permutation(temp.begin(), temp.end())){\\n            k--;\\n            if(k == 1) {\\n               ans += temp;\\n               break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nPlease Upvote\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string ans = \"\";\\n        string temp = \"\";\\n        for(int i=1;i<=n;i++){\\n            temp += to_string(i);\\n        }\\n        if(k == 1){\\n            return temp;\\n        }\\n        while(next_permutation(temp.begin(), temp.end())){\\n            k--;\\n            if(k == 1) {\\n               ans += temp;\\n               break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nPlease Upvote\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788320,
                "title": "python-solution-iterative-approach-98-76-faster",
                "content": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        def kthperm(string, k):\\n            permutation = [] \\n            length = len(string)\\n            fact = factorial(length)\\n            while (string != []): \\n                fact = fact // length\\n                index, k = divmod(k, fact)\\n                x = string[index] \\n                permutation.append(x) \\n                string = string[:index] + string[index+1:] \\n                length -= 1\\n            return \"\".join(permutation)\\n        \\n        return kthperm([str(i) for i in range(1, n+1)], k-1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        def kthperm(string, k):\\n            permutation = [] \\n            length = len(string)\\n            fact = factorial(length)\\n            while (string != []): \\n                fact = fact // length\\n                index, k = divmod(k, fact)\\n                x = string[index] \\n                permutation.append(x) \\n                string = string[:index] + string[index+1:] \\n                length -= 1\\n            return \"\".join(permutation)\\n        \\n        return kthperm([str(i) for i in range(1, n+1)], k-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751645,
                "title": "c-stl-next-permutaton-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\";\\n        for (char i = 1; i <= n; i++) s += to_string(i);\\n        while (k > 1) {\\n            next_permutation(s.begin(), s.end());\\n            k--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\";\\n        for (char i = 1; i <= n; i++) s += to_string(i);\\n        while (k > 1) {\\n            next_permutation(s.begin(), s.end());\\n            k--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750757,
                "title": "permutation-sequence",
                "content": "```class Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        fact=1\\n        numbers=[]\\n        ans=\"\"\\n        for i in range(1,n):\\n            fact=fact*i\\n            numbers.append(i)\\n        numbers.append(n) \\n        k=k-1\\n        while(True):\\n            ans = ans + str(numbers[ k//fact ])\\n            numbers.pop( k//fact )\\n            if len(numbers)==0:\\n                break\\n            k=k%fact   \\n            fact=fact//len(numbers)\\n        return ans            \\n            ```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```class Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        fact=1\\n        numbers=[]\\n        ans=\"\"\\n        for i in range(1,n):\\n            fact=fact*i\\n            numbers.append(i)\\n        numbers.append(n) \\n        k=k-1\\n        while(True):\\n            ans = ans + str(numbers[ k//fact ])\\n            numbers.pop( k//fact )\\n            if len(numbers)==0:\\n                break\\n            k=k%fact   \\n            fact=fact//len(numbers)\\n        return ans            \\n            ```",
                "codeTag": "Java"
            },
            {
                "id": 2702315,
                "title": "no-recursion-c-solution",
                "content": "```\\n  string getPermutation(int n, int k) {\\n        int fact = 1;\\n      vector < int > numbers;\\n      for (int i = 1; i < n; i++) {\\n        fact = fact * i;\\n        numbers.push_back(i);\\n      }\\n      numbers.push_back(n);\\n      string ans = \"\";\\n      k = k - 1;\\n      while (true) {\\n        ans = ans + to_string(numbers[k / fact]);\\n        numbers.erase(numbers.begin() + k / fact);\\n        if (numbers.size() == 0) {\\n          break;\\n        }\\n\\n        k = k % fact;\\n        fact = fact / numbers.size();\\n      }\\n      return ans;\\n    }\\n    \\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\n  string getPermutation(int n, int k) {\\n        int fact = 1;\\n      vector < int > numbers;\\n      for (int i = 1; i < n; i++) {\\n        fact = fact * i;\\n        numbers.push_back(i);\\n      }\\n      numbers.push_back(n);\\n      string ans = \"\";\\n      k = k - 1;\\n      while (true) {\\n        ans = ans + to_string(numbers[k / fact]);\\n        numbers.erase(numbers.begin() + k / fact);\\n        if (numbers.size() == 0) {\\n          break;\\n        }\\n\\n        k = k % fact;\\n        fact = fact / numbers.size();\\n      }\\n      return ans;\\n    }\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2679895,
                "title": "simple-c-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> nums;\\n        stringstream result;\\n\\t\\t\\n\\t\\t//inserting values to the vector\\n        for(int i=1;i<=n;i++){\\n            nums.emplace_back(i);\\n        }\\n        int i=1;\\n\\n\\t\\t//getting the kth permutation of the vector\\n        do{\\n            i++;            \\n        }while(next_permutation(nums.begin(),nums.end()) && i!=k);\\n        \\n        //copying the permuted vector to result\\n\\t\\tcopy(nums.begin(),nums.end(),ostream_iterator<int>(result,\"\"));\\n      return result.str();\\n    }\\n};\\n\\n//please upvote if found helpful....\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> nums;\\n        stringstream result;\\n\\t\\t\\n\\t\\t//inserting values to the vector\\n        for(int i=1;i<=n;i++){\\n            nums.emplace_back(i);\\n        }\\n        int i=1;\\n\\n\\t\\t//getting the kth permutation of the vector\\n        do{\\n            i++;            \\n        }while(next_permutation(nums.begin(),nums.end()) && i!=k);\\n        \\n        //copying the permuted vector to result\\n\\t\\tcopy(nums.begin(),nums.end(),ostream_iterator<int>(result,\"\"));\\n      return result.str();\\n    }\\n};\\n\\n//please upvote if found helpful....\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673298,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        vector<int>numbers;\\n        for(int i=1;i<n;i++)\\n        {\\n            fact=fact*i;\\n            numbers.push_back(i);\\n        }\\n        numbers.push_back(n);\\n        string ans =\"\";\\n        k=k-1;\\n        while(true)\\n        {\\n            ans=ans+to_string(numbers[k/fact]);\\n            numbers.erase(numbers.begin()+k/fact);\\n            if(numbers.size()==0) break;\\n            k=k%fact;\\n            fact=fact/numbers.size();\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n\\n//First find (n-1)!\\n//ex:\\n//1 2 3 4\\n// push all numbers in a vector in sorted order\\n// as total number of permutation formed is 4! , it is divided equally ,like first (n-1)! numbers starts with 1 , next (n-1)! starts with 2...and so on.\\n// now find the first number.\\n//     To find the first number , we divide k/fact it will give the index of the first number in the vector in which number is stored...add that number in the string and remove that number from the vector...now rest operation will take place on numbers left.\\n// update k to k % fact\\n// and fact to fact / size of vector , \\n// now again loop will run and find the position of 2nd number in the vector add it to the string and again do the same opeartion\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        vector<int>numbers;\\n        for(int i=1;i<n;i++)\\n        {\\n            fact=fact*i;\\n            numbers.push_back(i);\\n        }\\n        numbers.push_back(n);\\n        string ans =\"\";\\n        k=k-1;\\n        while(true)\\n        {\\n            ans=ans+to_string(numbers[k/fact]);\\n            numbers.erase(numbers.begin()+k/fact);\\n            if(numbers.size()==0) break;\\n            k=k%fact;\\n            fact=fact/numbers.size();\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n\\n//First find (n-1)!\\n//ex:\\n//1 2 3 4\\n// push all numbers in a vector in sorted order\\n// as total number of permutation formed is 4! , it is divided equally ,like first (n-1)! numbers starts with 1 , next (n-1)! starts with 2...and so on.\\n// now find the first number.\\n//     To find the first number , we divide k/fact it will give the index of the first number in the vector in which number is stored...add that number in the string and remove that number from the vector...now rest operation will take place on numbers left.\\n// update k to k % fact\\n// and fact to fact / size of vector , \\n// now again loop will run and find the position of 2nd number in the vector add it to the string and again do the same opeartion\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502001,
                "title": "c-easy-soln-60-permutation-sequence",
                "content": "**Dry Run for better understanding**\\n\\n\\t// if n is 4 then factorial of 3 will be calculated i.e. 6 let say n=4 and k=17  \\n\\t// intially we calculate factorial of n-1 and store the numbers upto n in nums  \\n\\t// nums={1,2,3,4}; fact=6\\n\\t// There are 6 numbers starting with 1: 1234, 1243, 1324, 1342, 1423, 1432\\n\\t// There are 6 numbers starting with 2: 2134, 2143, 2314, 2341, 2413, 2431\\n\\t// There are 6 numbers starting with 3: 3124, 3142,3214,3241,3412,3421  (ans i.e 3412 will lie here)\\n\\t// There are 6 numbers starting with 4: 4123, 4132, 4213, 4231, 4312, 4321\\n\\t// 0 based indexing asign k=k-1\\n\\t// since in the 3rd set(2nd index) ans is lying which can be calculated as\\n\\t// nums[k/fact]=nums[16/6]=>nums[2]\\n\\t// since nums[2] is 3 our first num is 3 add it to the ans \\n\\t// k=k%fact since next time there will total 6 element 2 starting from 1 ,two from 2 and two from 4\\n\\t// k=16%4 , fact is also updated as fact=6/3 process will be repeated until nums.size()=0\\n\\n**Code**\\n```\\nclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tstring getPermutation(int n, int k) {\\n\\t\\t\\t\\tint fact=1;\\n\\t\\t\\t\\tstring ans=\"\";\\n\\t\\t\\t\\tvector<int>nums;\\n\\t\\t\\t\\tfor(int i=1;i<n;i++){\\n\\t\\t\\t\\t\\tnums.push_back(i);\\n\\t\\t\\t\\t\\tfact*=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnums.push_back(n);\\n\\t\\t\\t\\tk=k-1;\\n\\t\\t\\t\\twhile(true)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tans+=to_string(nums[k/fact]);\\n\\t\\t\\t\\t\\tnums.erase(nums.begin()+k/fact);\\n\\t\\t\\t\\t\\tif(nums.size()==0) break;\\n\\t\\t\\t\\t\\tk=k%fact;\\n\\t\\t\\t\\t\\tfact=fact/nums.size();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t};\\n```\\n\\n**Time Complexity: O(n^2)**\\nsince erase fun is used for each element which will take O(n) ans O(n) for every element traversal\\n**Space Complexity: O(n)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tstring getPermutation(int n, int k) {\\n\\t\\t\\t\\tint fact=1;\\n\\t\\t\\t\\tstring ans=\"\";\\n\\t\\t\\t\\tvector<int>nums;\\n\\t\\t\\t\\tfor(int i=1;i<n;i++){\\n\\t\\t\\t\\t\\tnums.push_back(i);\\n\\t\\t\\t\\t\\tfact*=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnums.push_back(n);\\n\\t\\t\\t\\tk=k-1;\\n\\t\\t\\t\\twhile(true)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tans+=to_string(nums[k/fact]);\\n\\t\\t\\t\\t\\tnums.erase(nums.begin()+k/fact);\\n\\t\\t\\t\\t\\tif(nums.size()==0) break;\\n\\t\\t\\t\\t\\tk=k%fact;\\n\\t\\t\\t\\t\\tfact=fact/nums.size();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436376,
                "title": "java-optimized-solution",
                "content": "### **Approach : Brute Force**\\n**Will Give TLE**\\n```\\nclass Solution {\\n    \\n    private void swap(char[] s , int i , int j){\\n        char temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n    }\\n    \\n    private void solve(char[] s , int index , List<String> res){\\n        if(index == s.length){\\n            String str = new String(s);\\n            res.add(str);\\n            return;\\n        }\\n        for(int i = index; i<s.length ; i++){\\n            swap(s, i, index);\\n            solve(s, index+1, res);\\n            swap(s,i,index);\\n        }\\n    }\\n    \\n    public String getPermutation(int n, int k) {\\n        String s = \"\";\\n        ArrayList<String> res = new ArrayList<>();\\n        for(int i = 1; i <=n ; i++){\\n            s+=i;\\n        }\\n        solve(s.toCharArray(), 0 , res);\\n        Collections.sort(res);\\n        return res.get(k-1);\\n    }\\n}\\n\\n//Time complexity: O(N! * N) +O(N! Log N!)\\n//Space complexity: O(N) \\n\\n```\\n\\n\\n### **Optimal solution**\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int fact = 1;\\n        List<Integer> numbers = new ArrayList<>();\\n        for(int i = 1; i<n ; i++){\\n            fact = fact * i;\\n            numbers.add(i);\\n        }\\n        numbers.add(n);\\n        String ans = \"\";\\n        k = k-1;\\n        while(true){\\n            ans = ans + \"\" + numbers.get(k/fact);\\n            numbers.remove(k/fact);\\n            if(numbers.size() == 0){\\n                break;\\n            }\\n            k = k % fact;\\n            fact = fact/numbers.size();\\n        }\\n        return ans;\\n    }\\n}\\n\\n/*\\nTime Complexity: O(N) * O(N) = O(N^2)\\n\\nReason: We are placing N numbers in N positions. This will take O(N) time. For every number, we are reducing the search space by removing the element already placed in the previous step. This takes another O(N) time.\\n\\nSpace Complexity: O(N) \\n\\nReason: We are storing  the numbers in a data structure.\\n*/\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private void swap(char[] s , int i , int j){\\n        char temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n    }\\n    \\n    private void solve(char[] s , int index , List<String> res){\\n        if(index == s.length){\\n            String str = new String(s);\\n            res.add(str);\\n            return;\\n        }\\n        for(int i = index; i<s.length ; i++){\\n            swap(s, i, index);\\n            solve(s, index+1, res);\\n            swap(s,i,index);\\n        }\\n    }\\n    \\n    public String getPermutation(int n, int k) {\\n        String s = \"\";\\n        ArrayList<String> res = new ArrayList<>();\\n        for(int i = 1; i <=n ; i++){\\n            s+=i;\\n        }\\n        solve(s.toCharArray(), 0 , res);\\n        Collections.sort(res);\\n        return res.get(k-1);\\n    }\\n}\\n\\n//Time complexity: O(N! * N) +O(N! Log N!)\\n//Space complexity: O(N) \\n\\n```\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int fact = 1;\\n        List<Integer> numbers = new ArrayList<>();\\n        for(int i = 1; i<n ; i++){\\n            fact = fact * i;\\n            numbers.add(i);\\n        }\\n        numbers.add(n);\\n        String ans = \"\";\\n        k = k-1;\\n        while(true){\\n            ans = ans + \"\" + numbers.get(k/fact);\\n            numbers.remove(k/fact);\\n            if(numbers.size() == 0){\\n                break;\\n            }\\n            k = k % fact;\\n            fact = fact/numbers.size();\\n        }\\n        return ans;\\n    }\\n}\\n\\n/*\\nTime Complexity: O(N) * O(N) = O(N^2)\\n\\nReason: We are placing N numbers in N positions. This will take O(N) time. For every number, we are reducing the search space by removing the element already placed in the previous step. This takes another O(N) time.\\n\\nSpace Complexity: O(N) \\n\\nReason: We are storing  the numbers in a data structure.\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394981,
                "title": "runtime-0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Permutation Sequence.\\nMemory Usage: 6.1 MB, less than 16.64% of C++ online submissions for Permutation Sequence.\\n\\n```\\nclass Solution {\\npublic:\\n    unsigned int factorial(unsigned int n)\\n{\\n    if (n == 0)\\n        return 1;\\n    return n * factorial(n - 1);\\n}\\n    \\n    string s(int k,vector<char>&ch) {\\n        if(k==0){\\n            string t ;\\n            for(auto &i : ch) t += i;\\n            return t;\\n        }\\n        int f = factorial(ch.size());// 24 \\n        int t = f/ch.size(); // 6\\n        \\n        int index = k / t;\\n        int remainder = k % t;\\n        \\n        char h = ch[index];\\n        \\n         auto it = ch.begin() + index;\\n         ch.erase(it);\\n        \\n        return h + s(remainder,ch);        \\n    }\\n    \\n    string getPermutation(int n, int k) {\\n        vector<char>ch;\\n        char c = \\'1\\';\\n        for(int i = 0 ;i<n;i++){\\n            ch.push_back(c);\\n            c++;\\n        }\\n        return s(k-1,ch);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unsigned int factorial(unsigned int n)\\n{\\n    if (n == 0)\\n        return 1;\\n    return n * factorial(n - 1);\\n}\\n    \\n    string s(int k,vector<char>&ch) {\\n        if(k==0){\\n            string t ;\\n            for(auto &i : ch) t += i;\\n            return t;\\n        }\\n        int f = factorial(ch.size());// 24 \\n        int t = f/ch.size(); // 6\\n        \\n        int index = k / t;\\n        int remainder = k % t;\\n        \\n        char h = ch[index];\\n        \\n         auto it = ch.begin() + index;\\n         ch.erase(it);\\n        \\n        return h + s(remainder,ch);        \\n    }\\n    \\n    string getPermutation(int n, int k) {\\n        vector<char>ch;\\n        char c = \\'1\\';\\n        for(int i = 0 ;i<n;i++){\\n            ch.push_back(c);\\n            c++;\\n        }\\n        return s(k-1,ch);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2382280,
                "title": "c-0ms-best-solution-easily-understandable",
                "content": "```\\nclass Solution {\\n    \\n    void factorial (vector<int> &fac, int n )\\n    {\\n        fac[0] = fac[1] = 1;\\n        \\n        for(int i = 2 ; i<= n ; i++)\\n        {\\n            fac[i] = i * fac[i-1];\\n            \\n        }\\n       \\n    }\\n    \\npublic:\\n    string getPermutation(int n, int k) {\\n        \\n        vector<int> fac(n+1 , 0);\\n         factorial(fac , n);\\n        \\n        string s;\\n        for(int i = 1 ; i<= n ;i++)\\n            s.push_back(i+\\'0\\');\\n        \\n        string ans ;\\n        \\n        for(int i = 1 ; i< n ; i++)\\n        {\\n            int j = 0;\\n            while(k > fac[n-i])\\n            {\\n                j++;\\n                k -= fac[n-i];\\n            }\\n            ans.push_back(s[j]);\\n            s.erase(j,1);\\n            \\n        }\\n        \\n        ans.push_back(s[0]);\\n        \\n        return ans;\\n    }\\n\\t\\n\\t**// Pls Upvote if you like it**\\n};\\n```\\n\\n \\n\\n\\n![image](https://assets.leetcode.com/users/images/643a4983-d04a-44af-9a1f-64d21a7962ae_1659691279.1827478.png)\\n",
                "solutionTags": [
                    "C",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\n    \\n    void factorial (vector<int> &fac, int n )\\n    {\\n        fac[0] = fac[1] = 1;\\n        \\n        for(int i = 2 ; i<= n ; i++)\\n        {\\n            fac[i] = i * fac[i-1];\\n            \\n        }\\n       \\n    }\\n    \\npublic:\\n    string getPermutation(int n, int k) {\\n        \\n        vector<int> fac(n+1 , 0);\\n         factorial(fac , n);\\n        \\n        string s;\\n        for(int i = 1 ; i<= n ;i++)\\n            s.push_back(i+\\'0\\');\\n        \\n        string ans ;\\n        \\n        for(int i = 1 ; i< n ; i++)\\n        {\\n            int j = 0;\\n            while(k > fac[n-i])\\n            {\\n                j++;\\n                k -= fac[n-i];\\n            }\\n            ans.push_back(s[j]);\\n            s.erase(j,1);\\n            \\n        }\\n        \\n        ans.push_back(s[0]);\\n        \\n        return ans;\\n    }\\n\\t\\n\\t**// Pls Upvote if you like it**\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336078,
                "title": "c-stl-next-permutation-easy-100",
                "content": "Easy **STL function**!\\n```\\nstring getPermutation(int n, int k) {\\n        string s;\\n\\t\\t//fill the string with n integers\\n        for(int i=1; i<=n; i++){\\n            s += to_string(i);\\n        }\\n        \\n\\t\\t//go to the kth permutation\\n        for(int i=1; i<k; i++){\\n            next_permutation(s.begin(), s.end());\\n        }\\n        return s;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring getPermutation(int n, int k) {\\n        string s;\\n\\t\\t//fill the string with n integers\\n        for(int i=1; i<=n; i++){\\n            s += to_string(i);\\n        }\\n        \\n\\t\\t//go to the kth permutation\\n        for(int i=1; i<k; i++){\\n            next_permutation(s.begin(), s.end());\\n        }\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2322038,
                "title": "c-beginner-s-friendly-solution-understandable-approach",
                "content": "**Please Upvote the Solution**\\n\\nCode->\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fac=1;\\n        vector<int> arr;\\n        for(int i=1;i<n;i++){\\n            fac*=i;\\n            arr.push_back(i);\\n        }\\n        arr.push_back(n);\\n        string ans=\"\";\\n        //0-based indexing\\n        k=k-1;\\n        while(true){\\n            ans+=to_string(arr[k/fac]);\\n            arr.erase(arr.begin()+k/fac);\\n            if(arr.size()==0)\\n                break;\\n            k=k%fac;\\n            fac=fac/arr.size();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nHappy Coding :-)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fac=1;\\n        vector<int> arr;\\n        for(int i=1;i<n;i++){\\n            fac*=i;\\n            arr.push_back(i);\\n        }\\n        arr.push_back(n);\\n        string ans=\"\";\\n        //0-based indexing\\n        k=k-1;\\n        while(true){\\n            ans+=to_string(arr[k/fac]);\\n            arr.erase(arr.begin()+k/fac);\\n            if(arr.size()==0)\\n                break;\\n            k=k%fac;\\n            fac=fac/arr.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2228028,
                "title": "c-very-easy-explanation-with-example",
                "content": "\\t/*\\n\\tExample:\\n\\n\\tn = 4 and k = 9\\n\\n\\tnumber of combination \\n\\n\\t1234    2134    3124    4123\\n\\t1243    2143    3142    4132\\n\\t1324    2314    3214    4213\\n\\t1342    2342    3241    4231\\n\\t1423    2413    3412    4312\\n\\t1432    2431    3421    4321\\n\\n\\tsince we want the 9 the permutaion we have to do the permutaion 8 time since 1st combination\\n\\tis considered 1\\n\\tk = 8\\n\\tans = \"\";\\n\\n\\tvalue of i = 1; //initially\\n\\tnow how many columns needs to be skipped for first digit of ans is (n-i)!\\n\\tso number of the value (smaller) to skip = k/(n-1)!\\n\\there 8/(4-i)! = 8/6 = 1; \\n\\tnew k value = k%(n-i) = 8%(4-1)! = 2\\n\\tans = \"2\"\\n\\n\\trepeation the same process i = 2\\n\\t2/(4-2)! = 2/1 = 2\\n\\tans = \"23\"\\n\\tk = 0\\n\\n\\ti = 3\\n\\t0/(4-3)! = 0\\n\\tans = \"231\"\\n\\n\\ti = 4\\n\\t0/(4-4)! = 0\\n\\tans = \"2314\"\\n\\n\\tresult = \"2314\"\\n\\t*/\\n\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tint factorial(int n){\\n\\t\\t\\tint ans = 1;\\n\\t\\t\\tfor(int i = 2; i<=n; i++)ans *= i;\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\tstring getPermutation(int n, int k) {\\n\\n\\n\\t\\t\\t//factorial of n to get the total number of arrangement possible\\n\\t\\t\\t//with n numbers\\n\\t\\t\\tint ttlArgmtPsbl = factorial(n); //total arrangement possible for n digits\\n\\n\\n\\t\\t\\t//since we want to get the number we will se after k permutation \\n\\t\\t\\t//ans we are counting the initial arrangement as 1\\n\\t\\t\\tk--;\\n\\n\\t\\t\\t//to remove loop means the same arrangement is occuring more than once.\\n\\t\\t\\tk = k%ttlArgmtPsbl;\\n\\n\\t\\t\\t//to skip the number after which we will get the number which is supposed to \\n\\t\\t\\t//be there in that place.\\n\\t\\t\\tvector<bool> rec(n, true);\\n\\n\\n\\t\\t\\t//resulting string\\n\\t\\t\\tstring ans = \"\";\\n\\n\\n\\t\\t\\tfor(int i = n; i>=1; i--){\\n\\n\\t\\t\\t\\t//to get the column of the number after a position when a number is fixed\\n\\t\\t\\t\\t//at that position.\\n\\t\\t\\t\\tttlArgmtPsbl = ttlArgmtPsbl/i; \\n\\n\\t\\t\\t\\t//fixing the first element and figuring\\n\\t\\t\\t\\t//out how many column (where the number less than it which are unoccupied are\\n\\t\\t\\t\\t//at that position) have to be skipped (reffer to the example)\\n\\t\\t\\t\\t//(+1 to get the the exact index)\\n\\n\\t\\t\\t\\t//smaller and available no. to skip\\n\\t\\t\\t\\tint smlaAvlnumbertoskp = k/ttlArgmtPsbl + 1; \\n\\n\\t\\t\\t\\t//to store the index number.\\n\\t\\t\\t\\tint ix = 0;\\n\\n\\t\\t\\t\\t//to get the ixdex value by skipping the available smaller number.\\n\\t\\t\\t\\tfor(int j = 0; j<rec.size(); j++){\\n\\t\\t\\t\\t\\tif(!smlaAvlnumbertoskp){\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(rec[j]){\\n\\t\\t\\t\\t\\t\\tsmlaAvlnumbertoskp--;\\n\\t\\t\\t\\t\\t\\tix = j;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t//number at ix is to be added to ans string\\n\\n\\t\\t\\t\\tk = k%ttlArgmtPsbl; //reduce the width of the column\\n\\n\\t\\t\\t\\t//set the number at ix to unavailable.\\n\\t\\t\\t\\trec[ix] = false;\\n\\n\\t\\t\\t\\t//add number at ix to ans.\\n\\t\\t\\t\\tans += to_string(ix+1);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t\\tint factorial(int n){\\n\\t\\t\\tint ans = 1;\\n\\t\\t\\tfor(int i = 2; i<=n; i++)ans *= i;\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2133515,
                "title": "without-recursion-simple-mathematics",
                "content": "feel free to ask any queries in the comments!******\\n\\n![image](https://assets.leetcode.com/users/images/a5872874-51df-42d4-8e49-ed44bd7b93f3_1654838871.1433494.jpeg)\\n\\n\\n```class Solution\\n{\\n\\npublic:\\n    int fact(int n)\\n    {\\n        int res = 1;\\n        for (int i = 1; i <= n; i++)\\n        {\\n            res = res * 1 * i;\\n        }\\n        return res;\\n    }\\n    string getPermutation(int n, int k)\\n    {\\n        vector<int> v1;\\n        vector<int> v;\\n        for (int i = 0; i < n; i++)\\n        {\\n            v1.push_back(i + 1);\\n        }\\n        int t = n;\\n\\n        while (n)\\n        {\\n           \\n            int s = ceil((double)k / (double)fact(n - 1));\\n            v.push_back(v1[s - 1]);\\n            for (int i = 0; i < v.size(); i++)\\n            {\\n                cout << v[i] << \" \";\\n            }\\n            cout << endl;\\n            v1[s - 1] = INT_MAX;\\n            sort(v1.begin(), v1.end());\\n            k -= (s - 1) * fact(n - 1);\\n            n--;\\n          \\n        }\\n        \\n        string s = \"\";\\n        for (int j = 0; j < t; j++)\\n        {\\n            s += to_string(v[j]);\\n        }\\n        return s;\\n    }\\n};```**",
                "solutionTags": [],
                "code": "```class Solution\\n{\\n\\npublic:\\n    int fact(int n)\\n    {\\n        int res = 1;\\n        for (int i = 1; i <= n; i++)\\n        {\\n            res = res * 1 * i;\\n        }\\n        return res;\\n    }\\n    string getPermutation(int n, int k)\\n    {\\n        vector<int> v1;\\n        vector<int> v;\\n        for (int i = 0; i < n; i++)\\n        {\\n            v1.push_back(i + 1);\\n        }\\n        int t = n;\\n\\n        while (n)\\n        {\\n           \\n            int s = ceil((double)k / (double)fact(n - 1));\\n            v.push_back(v1[s - 1]);\\n            for (int i = 0; i < v.size(); i++)\\n            {\\n                cout << v[i] << \" \";\\n            }\\n            cout << endl;\\n            v1[s - 1] = INT_MAX;\\n            sort(v1.begin(), v1.end());\\n            k -= (s - 1) * fact(n - 1);\\n            n--;\\n          \\n        }\\n        \\n        string s = \"\";\\n        for (int j = 0; j < t; j++)\\n        {\\n            s += to_string(v[j]);\\n        }\\n        return s;\\n    }\\n};```",
                "codeTag": "C++"
            },
            {
                "id": 2130821,
                "title": "cpp-code-easy-to-understand",
                "content": "```\\nclass Solution {\\nprivate:\\nint calFact ( int n ){\\n    int ans = 1 ;\\n    for ( int i = 1 ; i < n ; i ++)\\n        ans *=  i;\\n    return ans;\\n}    \\n    \\npublic:\\n    string getPermutation(int n, int k) {\\n        // this question is based on the nice concept of factorial \\n        // do check it out again\\n        \\n        // first we will find the factorial of the given n\\n        // then we will try to find in which range of factorial does k - 1 lies \\n        // we will pick that element by k / size of the set reduced to ( fact ( n - 1 )) \\n        // then we will pick the element and add to our string and erase the element from string \\n        // then we will change the value of k by k = k % fact \\n        // and fact = fact ( n - 1) = fact / s.size() \\n        \\n        vector<int> numbers;\\n        int fact = 1 ;\\n        \\n        for ( int i = 1 ; i <= n ; i ++) numbers.push_back(i);\\n        \\n        fact = calFact ( n );\\n        k = k - 1;\\n        string s = \"\";\\n        while ( 1 ){\\n            s += to_string(numbers[(int)(k / fact )]);\\n            numbers.erase( numbers.begin() + (int)(k / fact) );\\n            \\n            // if the numbers become empty we will stop\\n            if ( numbers.size() == 0)\\n               break;\\n            \\n            // new k value and fact value \\n            k = k % fact ;\\n            fact = fact / numbers.size();\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\nint calFact ( int n ){\\n    int ans = 1 ;\\n    for ( int i = 1 ; i < n ; i ++)\\n        ans *=  i;\\n    return ans;\\n}    \\n    \\npublic:\\n    string getPermutation(int n, int k) {\\n        // this question is based on the nice concept of factorial \\n        // do check it out again\\n        \\n        // first we will find the factorial of the given n\\n        // then we will try to find in which range of factorial does k - 1 lies \\n        // we will pick that element by k / size of the set reduced to ( fact ( n - 1 )) \\n        // then we will pick the element and add to our string and erase the element from string \\n        // then we will change the value of k by k = k % fact \\n        // and fact = fact ( n - 1) = fact / s.size() \\n        \\n        vector<int> numbers;\\n        int fact = 1 ;\\n        \\n        for ( int i = 1 ; i <= n ; i ++) numbers.push_back(i);\\n        \\n        fact = calFact ( n );\\n        k = k - 1;\\n        string s = \"\";\\n        while ( 1 ){\\n            s += to_string(numbers[(int)(k / fact )]);\\n            numbers.erase( numbers.begin() + (int)(k / fact) );\\n            \\n            // if the numbers become empty we will stop\\n            if ( numbers.size() == 0)\\n               break;\\n            \\n            // new k value and fact value \\n            k = k % fact ;\\n            fact = fact / numbers.size();\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099414,
                "title": "c-solution-recursion",
                "content": "class Solution {\\npublic:\\n    string kthPermutation(string str, string res, int &k) {\\n        \\n        if(str.size()==0) {\\n            k--;\\n            if(k==0)\\n                return res;\\n            return \"\";\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<str.size();i++) {\\n            string ros=str.substr(0,i)+str.substr(i+1);\\n            ans=kthPermutation(ros, res+str[i], k);\\n            \\n            if(k==0)\\n                break;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    string getPermutation(int n, int k) {\\n        string str=\"\";\\n        for(int i=1;i<=n;i++)\\n            str+=to_string(i);\\n        \\n        return kthPermutation(str, \"\", k);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Probability and Statistics"
                ],
                "code": "class Solution {\\npublic:\\n    string kthPermutation(string str, string res, int &k) {\\n        \\n        if(str.size()==0) {\\n            k--;\\n            if(k==0)\\n                return res;\\n            return \"\";\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2066901,
                "title": "perfect-use-of-stl-c",
                "content": "class Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string str = \"\";\\n        for(int i=1;i<=n;i++) \\n            str.push_back(i+\\'0\\');\\n        cout<<str;\\n        while(--k)\\n            next_permutation(str.begin(), str.end());\\n        return str;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string str = \"\";\\n        for(int i=1;i<=n;i++) \\n            str.push_back(i+\\'0\\');\\n        cout<<str;\\n        while(--k)\\n            next_permutation(str.begin(), str.end());\\n        return str;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 2036385,
                "title": "3ms-java-easy-solution",
                "content": "\\t\\tclass Solution {\\n\\t\\t   public void kthPermutaionUtil(int n,int k,ArrayList<Integer> lis,int fact,String[] res){\\n\\t\\t\\t\\tif(n==1){\\n\\t\\t\\t\\t\\tres[0]+=lis.get(0);    \\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint groups = fact/n;\\n\\t\\t\\t\\tres[0]+=lis.get(k/groups);\\n\\t\\t\\t\\tlis.remove(k/groups);\\n\\t\\t\\t\\tkthPermutaionUtil(n-1,k%groups,lis,groups,res); \\n\\t\\t\\t}\\n\\t\\t\\tpublic String getPermutation(int n, int k) {\\n\\t\\t\\t\\tString[] res = {\"\"};\\n\\t\\t\\t\\tArrayList<Integer> lexographical_list = new ArrayList<Integer>();\\n\\t\\t\\t\\tint fact=1;\\n\\t\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t\\tfact=fact*(i+1);\\n\\t\\t\\t\\t\\tlexographical_list.add(i+1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tSystem.out.println(fact);\\n\\t\\t\\t\\tSystem.out.println(lexographical_list);\\n\\t\\t\\t\\tkthPermutaionUtil(n,k-1,lexographical_list,fact,res);\\n\\t\\t\\t\\treturn res[0];\\n\\t\\t\\t}\\n\\t\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\t   public void kthPermutaionUtil(int n,int k,ArrayList<Integer> lis,int fact,String[] res){\\n\\t\\t\\t\\tif(n==1){\\n\\t\\t\\t\\t\\tres[0]+=lis.get(0);    \\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2036380,
                "title": "runtime-0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "\\t\\tclass Solution {\\n\\t\\t\\tvector<int> fact,digits;\\n\\t\\t\\tvoid solve(string& ans,int n,int k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(n==1){       //Insert whatever digit is left at the end\\n\\t\\t\\t\\t\\tans+=to_string(digits.back());\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t//This runs if we have more than 1 digit in digits array\\n\\t\\t\\t\\tint index = k/fact[n-1]; //Defines no of blocks to skip (each block of size fact[n-1])\\n\\n\\t\\t\\t\\tif(k%fact[n-1]==0)  //We need convert 1 based indexing to 0 based.So, decrese index by 1\\n\\t\\t\\t\\t\\tindex-=1;\\n\\n\\t\\t\\t\\tans+=to_string(digits[index]);  //Add new character\\n\\t\\t\\t\\tdigits.erase(digits.begin()+index);    //Erase digit after using\\n\\n\\t\\t\\t\\tk -= fact[n-1]*index;  //Decrease K value\\n\\t\\t\\t\\tsolve(ans,n-1,k);\\n\\t\\t\\t}\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tstring getPermutation(int n, int k) {\\n\\t\\t\\t\\t\\t//Store all factorials from 0 to N\\n\\t\\t\\t\\t\\tfact.push_back(1);\\n\\t\\t\\t\\t\\tint f=1;\\n\\t\\t\\t\\t\\tfor(int i=1;i<n;++i)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tf*=i;\\n\\t\\t\\t\\t\\t\\tfact.push_back(f);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t//Push your digits in array\\n\\t\\t\\t\\t\\tfor(int i=1;i<=n;++i)\\n\\t\\t\\t\\t\\t\\tdigits.push_back(i);\\n\\n\\t\\t\\t\\t\\tstring ans = \"\";\\n\\t\\t\\t\\t\\tsolve(ans,n,k); \\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\t\\t\\tvector<int> fact,digits;\\n\\t\\t\\tvoid solve(string& ans,int n,int k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(n==1){       //Insert whatever digit is left at the end\\n\\t\\t\\t\\t\\tans+=to_string(digits.back());\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2032054,
                "title": "c-east-to-unserstand-stl-implementation-easy",
                "content": "Very basic and easy to unserstand another way can be using backtracking\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int arr[n+1];\\n        for(int i=0;i<n;i++){\\n            arr[i]=i+1;\\n        }\\n        \\n        while(--k){\\n            next_permutation(arr,arr+n);\\n        }\\n        \\n        string s = \"\";\\n        \\n        for(int i=0;i<n;i++){\\n            s+= char(arr[i])+\\'0\\';\\n        }\\n        \\n        \\n        return(s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int arr[n+1];\\n        for(int i=0;i<n;i++){\\n            arr[i]=i+1;\\n        }\\n        \\n        while(--k){\\n            next_permutation(arr,arr+n);\\n        }\\n        \\n        string s = \"\";\\n        \\n        for(int i=0;i<n;i++){\\n            s+= char(arr[i])+\\'0\\';\\n        }\\n        \\n        \\n        return(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841505,
                "title": "c-solution-using-stl",
                "content": "```\\n string getPermutation(int n, int k) {\\n        vector<string> vec;\\n        for(int i=0;i<n;i++) vec.push_back(to_string(i+1));\\n        vector<vector<string>> answers;\\n        string ans = \"\";\\n        answers.push_back(vec);\\n        k--;\\n        while(k--)\\n            next_permutation(vec.begin(),vec.end());\\n        for(int i=0;i<vec.size();i++)\\n            ans = ans + vec[i];\\n        return ans;   \\n    }",
                "solutionTags": [],
                "code": "```\\n string getPermutation(int n, int k) {\\n        vector<string> vec;\\n        for(int i=0;i<n;i++) vec.push_back(to_string(i+1));\\n        vector<vector<string>> answers;\\n        string ans = \"\";\\n        answers.push_back(vec);\\n        k--;\\n        while(k--)\\n            next_permutation(vec.begin(),vec.end());\\n        for(int i=0;i<vec.size();i++)\\n            ans = ans + vec[i];\\n        return ans;   \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1801155,
                "title": "c-5-line-solution-easy",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring getPermutation(int n, int k) {\\n\\t\\t\\tstring s;\\n\\t\\t\\tfor(int i=1;i<=n;i++) s.push_back(i+\\'0\\');;\\n\\t\\t\\twhile(k-->1){\\n\\t\\t\\t\\tnext_permutation(s.begin(),s.end());\\n\\t\\t\\t}\\n\\t\\t\\treturn s;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring getPermutation(int n, int k) {\\n\\t\\t\\tstring s;\\n\\t\\t\\tfor(int i=1;i<=n;i++) s.push_back(i+\\'0\\');;\\n\\t\\t\\twhile(k-->1){\\n\\t\\t\\t\\tnext_permutation(s.begin(),s.end());\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1737773,
                "title": "java-short-clean-math-o-n-solution",
                "content": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int kF = 1;\\n        List<Integer>allDigits = new ArrayList<>();\\n        for (int i=1;i<=n;i++){\\n            kF *=i;\\n            allDigits.add(i);\\n        }\\n        \\n        StringBuilder res = new StringBuilder();\\n        int ind = 0;\\n        while (allDigits.size()>0){\\n            kF/=allDigits.size();\\n            int div = k/kF;\\n            int mod = k%kF;\\n            ind = (mod>0?0:-1) + div;\\n            k=(mod==0)?kF:mod;\\n            res.append(allDigits.get(ind));\\n            allDigits.remove(ind);\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int kF = 1;\\n        List<Integer>allDigits = new ArrayList<>();\\n        for (int i=1;i<=n;i++){\\n            kF *=i;\\n            allDigits.add(i);\\n        }\\n        \\n        StringBuilder res = new StringBuilder();\\n        int ind = 0;\\n        while (allDigits.size()>0){\\n            kF/=allDigits.size();\\n            int div = k/kF;\\n            int mod = k%kF;\\n            ind = (mod>0?0:-1) + div;\\n            k=(mod==0)?kF:mod;\\n            res.append(allDigits.get(ind));\\n            allDigits.remove(ind);\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730928,
                "title": "simple-recursive-solution-in-java",
                "content": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        boolean[] used = new boolean[n];\\n        return FindKthPermutation(n,k,used);\\n    }\\n    String FindKthPermutation(int n, int k, boolean[] used) {\\n        if(n == 1){\\n            for (int i = 0; i < used.length; i++) {\\n                if(!used[i]){\\n                    return \"\"+(i+1);\\n                }\\n            }\\n        }\\n        int factn = fact(n-1);\\n\\n        int seg = k<=factn?0:(k-1)/factn;\\n\\n        int findsegNo= seg;\\n\\n        int cur = 0;\\n        for (int i = 0; i < used.length; i++) {\\n            if(used[i]){\\n                continue;\\n            }\\n            if(findsegNo ==0){\\n                used[i] = true;\\n                cur = i;\\n                break;\\n            }\\n            findsegNo--;\\n        }\\n        return (cur+1) + FindKthPermutation(n-1,k-(factn*seg),used);\\n    }\\n\\n    int fact(int n) {\\n        if(n <= 1){\\n            return 1;\\n        }\\n        return n*fact(n-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        boolean[] used = new boolean[n];\\n        return FindKthPermutation(n,k,used);\\n    }\\n    String FindKthPermutation(int n, int k, boolean[] used) {\\n        if(n == 1){\\n            for (int i = 0; i < used.length; i++) {\\n                if(!used[i]){\\n                    return \"\"+(i+1);\\n                }\\n            }\\n        }\\n        int factn = fact(n-1);\\n\\n        int seg = k<=factn?0:(k-1)/factn;\\n\\n        int findsegNo= seg;\\n\\n        int cur = 0;\\n        for (int i = 0; i < used.length; i++) {\\n            if(used[i]){\\n                continue;\\n            }\\n            if(findsegNo ==0){\\n                used[i] = true;\\n                cur = i;\\n                break;\\n            }\\n            findsegNo--;\\n        }\\n        return (cur+1) + FindKthPermutation(n-1,k-(factn*seg),used);\\n    }\\n\\n    int fact(int n) {\\n        if(n <= 1){\\n            return 1;\\n        }\\n        return n*fact(n-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666830,
                "title": "another-solution-for-same-approach",
                "content": "```\\n//select first place \\n\\nclass Solution {\\npublic:\\n    int fac(int n){\\n        if (n==1 || n==0) return 1; \\n\\n        return n*fac(n-1);\\n    }   \\n    \\n    \\n    string getPermutation(int n, int k) {\\n    \\n        set<char> pq; \\n        for (int i=1; i<=n; i++) pq.insert(i+\\'0\\');\\n        \\n        string ans=\"\";\\n\\n        for (int i=1; i<=n && k>1; i++){    \\n            \\n            int pos = (k-1)/fac(n-i);\\n            k -= pos*fac(n-i);                           \\n            \\n            set<char> :: iterator it1 = pq.begin();\\n            while (pos--) it1++;\\n            ans += *it1;\\n            pq.erase(it1);                    \\n            \\n            //cout << k << \" \"<< pos << \" \" << n-i  << \" \" << ans << endl;\\n        }\\n        \\n        \\n        while (!pq.empty()){\\n            ans += *pq.begin();\\n            pq.erase(*pq.begin());\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\nAt each index find the maximum number that can fit, and substract the permutations which we skipped to come to the maximum digit at this index.\\n\\nThe only difference is I used a set container instead of a vector which helps optimise the memory used.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator",
                    "Ordered Set"
                ],
                "code": "```\\n//select first place \\n\\nclass Solution {\\npublic:\\n    int fac(int n){\\n        if (n==1 || n==0) return 1; \\n\\n        return n*fac(n-1);\\n    }   \\n    \\n    \\n    string getPermutation(int n, int k) {\\n    \\n        set<char> pq; \\n        for (int i=1; i<=n; i++) pq.insert(i+\\'0\\');\\n        \\n        string ans=\"\";\\n\\n        for (int i=1; i<=n && k>1; i++){    \\n            \\n            int pos = (k-1)/fac(n-i);\\n            k -= pos*fac(n-i);                           \\n            \\n            set<char> :: iterator it1 = pq.begin();\\n            while (pos--) it1++;\\n            ans += *it1;\\n            pq.erase(it1);                    \\n            \\n            //cout << k << \" \"<< pos << \" \" << n-i  << \" \" << ans << endl;\\n        }\\n        \\n        \\n        while (!pq.empty()){\\n            ans += *pq.begin();\\n            pq.erase(*pq.begin());\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1613182,
                "title": "6-line-cpp-code-using-inbuilt-func",
                "content": "\\n    string getPermutation(int n, int k) {\\n        vector<int> nums;\\n        for (int i=1;i<=n;i++) nums.push_back(i);\\n        while(--k) next_permutation(nums.begin(),nums.end());\\n        string ans=\"\";\\n        for(int l:nums) ans+=to_string(l);\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n    string getPermutation(int n, int k) {\\n        vector<int> nums;\\n        for (int i=1;i<=n;i++) nums.push_back(i);\\n        while(--k) next_permutation(nums.begin(),nums.end());\\n        string ans=\"\";\\n        for(int l:nums) ans+=to_string(l);\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1541480,
                "title": "recursive-and-optimized-detailed-solutions",
                "content": "**As we can see the order of permutations is actually sorted**\\nBy listing and labeling all of the permutations in order, we get the following sequence for n = 3:\\n no fo permutations n!=6;\\n0.\"123\"\\n1.\"132\"\\n2.\"213\"\\n3.\"231\"\\n4.\"312\"\\n5.\"321\"\\n\\n**In brute force approach we will simply create all permutations using recursion and store all in vector and then sort them in increasing order to get answer.**\\n\\n**TC:->O(n!) and S.C->O(n)**\\n```\\nclass Solution {\\n    vector<string>temp;\\npublic:\\n    string getPermutation(int n, int k) {\\n        string res=\"\",initial=\"\";\\n        // creating string \\n        for(int i=1;i<=n;++i)\\n            initial+=to_string(i);  \\n\\n        solve(res,initial);\\n        \\n        // sorting temp\\n        sort(temp.begin(),temp.end());\\n        \\n          // in 0 indexing return k-1 in temp to get Kth permutation\\n        return temp[k-1];\\n        \\n    }\\n    void solve(string res,string initial)\\n    {\\n        // base case\\n        if(initial.size()==0)\\n        {\\n            temp.push_back(res);\\n            return;\\n        }\\n        for(int i=0;i<initial.size();++i)\\n        {   \\n            res.push_back(initial[i]);\\n            solve(res,initial.substr(0,i)+initial.substr(i+1));\\n            res.pop_back();\\n        }\\n    }\\n};\\n```\\n**optimized approach**\\n**TC:->O(n) and S.C->O(n)**\\nThe approach is mathematical\\nhere let suppose n=3..so n-1!=2;\\n **the first two start with zero index ..**\\n*for k=1,2....  k-=1  ...k=0,k=1  num[k/n-1!]==0/2=0;or1/2=0; so we have to take 0th index from original \"123\"..**so we have res=\"1\" and rest =\"2,3\".**. \\n\"123\"\\n\"132\"*\\n **after that the next two start with one index ..**\\n *for k=3,4....  k-=1  ...k=2,k=3  num[k/n-1!]==2/2=1;or3/2=1; so we have to take 1th index from original \"123\"..**so we have res=\"2\" and rest =\"1,3\".. **\\n\"213\"\\n\"231\"*\\n**after that the next two start with two index ..**\\n*for k=5,6....  k-=1  ...k=4,k=5  num[k/n-1!]==4/2=2;or5/2=2; so we have to take 2th index from original \"123\"..**so we have res=\"3\" and rest =\"2,3\"..**\\n\"312\"\\n\"321*\\n\\n**and also updating value of k and fact each time so on...till rest array size!=0.**\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        vector<int>num;\\n        for(int i=1;i<n;++i)\\n        {\\n            num.push_back(i);\\n            fact*=i;\\n        }\\n        num.push_back(n);\\n        string res=\"\";\\n        k-=1;\\n        while(1)\\n        {\\n          res+=to_string(num[k/fact]);\\n          num.erase(num.begin()+k/fact);//after adding to res we will delete this char.\\n          if(size(num)==0)\\n            break;\\n           k%=fact;\\n           fact/=size(num);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    vector<string>temp;\\npublic:\\n    string getPermutation(int n, int k) {\\n        string res=\"\",initial=\"\";\\n        // creating string \\n        for(int i=1;i<=n;++i)\\n            initial+=to_string(i);  \\n\\n        solve(res,initial);\\n        \\n        // sorting temp\\n        sort(temp.begin(),temp.end());\\n        \\n          // in 0 indexing return k-1 in temp to get Kth permutation\\n        return temp[k-1];\\n        \\n    }\\n    void solve(string res,string initial)\\n    {\\n        // base case\\n        if(initial.size()==0)\\n        {\\n            temp.push_back(res);\\n            return;\\n        }\\n        for(int i=0;i<initial.size();++i)\\n        {   \\n            res.push_back(initial[i]);\\n            solve(res,initial.substr(0,i)+initial.substr(i+1));\\n            res.pop_back();\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        vector<int>num;\\n        for(int i=1;i<n;++i)\\n        {\\n            num.push_back(i);\\n            fact*=i;\\n        }\\n        num.push_back(n);\\n        string res=\"\";\\n        k-=1;\\n        while(1)\\n        {\\n          res+=to_string(num[k/fact]);\\n          num.erase(num.begin()+k/fact);//after adding to res we will delete this char.\\n          if(size(num)==0)\\n            break;\\n           k%=fact;\\n           fact/=size(num);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1496484,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        \\n        nums=list(range(1,n+1))\\n        fact = math.factorial(n)\\n        s=\\'\\'\\n        for i in range(n,0,-1):\\n            fact=fact//i\\n            s+=str(nums.pop((k-1)//fact))\\n            k=k%fact\\n            \\n        return s\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        \\n        nums=list(range(1,n+1))\\n        fact = math.factorial(n)\\n        s=\\'\\'\\n        for i in range(n,0,-1):\\n            fact=fact//i\\n            s+=str(nums.pop((k-1)//fact))\\n            k=k%fact\\n            \\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438806,
                "title": "10-line-code-c-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string str = \"\"; \\n        for(int i =0 ; i<n;i++){\\n            str+=to_string(i+1); \\n        }\\n        for(int i =1 ; i<k;i++){\\n            next_permutation(str.begin(), str.end()); \\n        }\\n        return str;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string str = \"\"; \\n        for(int i =0 ; i<n;i++){\\n            str+=to_string(i+1); \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1438394,
                "title": "c-math-t-c-o-n-2-s-c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> nums;\\n        int factorial = 1;\\n        for(int i=1;i<n;++i){ \\n            factorial*=i;\\n            nums.push_back(i);\\n        }\\n        nums.push_back(n);\\n\\n        string ans=\"\";\\n        k=k-1;\\n\\n        while(nums.size()!=0){\\n            ans.append(to_string(nums[k/factorial]));\\n            nums.erase(nums.begin()+(k/factorial));\\n            k = k % factorial;\\n            if(nums.size()>0) factorial = factorial/nums.size();\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> nums;\\n        int factorial = 1;\\n        for(int i=1;i<n;++i){ \\n            factorial*=i;\\n            nums.push_back(i);\\n        }\\n        nums.push_back(n);\\n\\n        string ans=\"\";\\n        k=k-1;\\n\\n        while(nums.size()!=0){\\n            ans.append(to_string(nums[k/factorial]));\\n            nums.erase(nums.begin()+(k/factorial));\\n            k = k % factorial;\\n            if(nums.size()>0) factorial = factorial/nums.size();\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343701,
                "title": "easy-c-solution-100-faster",
                "content": "class Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        \\n        string result;\\n        \\n        vector<int> arr;\\n        int comb = 1;\\n        for(int i=1;i<n;i++)\\n        {\\n            comb*= i;\\n            arr.push_back(i);\\n        }\\n        arr.push_back(n);\\n        k = k-1;\\n        \\n        \\n        while(true)\\n        {\\n            result += to_string(arr[k/comb]);\\n            \\n            arr.erase(arr.begin()+(k/comb));\\n            \\n            if(arr.size()==0)\\n                break;\\n            \\n            k = k%comb;\\n            comb = comb/arr.size();\\n        }\\n        \\n        return result;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        \\n        string result;\\n        \\n        vector<int> arr;\\n        int comb = 1;\\n        for(int i=1;i<n;i++)\\n        {\\n            comb*= i;\\n            arr.push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1300779,
                "title": "python-maths-logic-with-explanation-90-runtime",
                "content": "\\nTo make things simpler, we start index everything from 0\\nTheory:\\n(1) We begin from the left-most digit for the final answer\\n(2) We create a ***list*** , that contains all digit from 1 to ***n*** (in ascending order)\\n(3) We split the possible permutations into different groups according to their \\'leading\\' digits\\n(4) We discover which n*th* group [ ***int(k/(len(List)-1)!)*** ] that the final answer lies within\\n(5) We append the \\'leading\\' digit of the n*th* group into our final answer\\n(6) We update ***k*** ( ***k=k%(len(list)-1)!*** ) and remove the n*th* element from ***list***\\n(7) Repeat steps 3 - 6 until ***list*** is empty\\n\\t\\n***Sample Case: n=4, k=15 (0-indexed)***\\t\\n\\t\\n### Stage 1\\n\\t\\n\\tList = [1,2,3,4]\\n\\tGroup 0: 1234,1243,1324,1342,1423,1432 (where k=0~5) \\n\\tGroup 1: 2134,2143,2314,2341,2413,2431 (where k=6~11)\\n\\tGroup 2: 3124,3142,3214,3241,3412,3421 (where k=12~17)\\n\\tGroup 3: 4123,4132,4213,4231,4312,4321 (where k=18~23)\\n\\t\\nwe can confirm that the final answer lies within **Group [int(k/(len(List)-1)!)] = 2**\\nsince we know the answer is in Group 2, meaning the 1st digit of the answer is \\'3\\' (equivalent to the value of ***List[2]*** ), answer = **3 _ _ _**\\nwe update **k=k%(len(List)-1)!=3** , remove ***List[2]***\\n\\n### Stage 2\\n\\n\\tList = [1,2,4]\\n\\tGroup 0: 124,142 (where k=0~1)\\n\\tGroup 1: 214,241 (where k=2~3)\\n\\tGroup 2: 412,421 (where k=4~5)\\n\\nwe can decude the answer lies within **Group [int(k/(len(List)-1)!)] = 1**\\nwe can confirm that the 2nd digit is \\'2\\' (equivalent to the value of ***List[1]*** ), answer = **3 2 _ _**\\nwe update **k = k%(len(List)-1)!=1**, remove ***List[1]*** \\n\\n### Stage 3\\n\\n\\tList = [1,4]\\n\\tGroup 0: 14 (where k=0)\\n\\tGroup 1: 41 (where k=1)\\n\\nAnswer lies within **Group [int(k/(len(List)-1!)] = 1**, 3rd digit is ***List[1]*** , which is \\'4\\', answer = **3 2 4** _\\nwe update **k = k%(len(List)-1)! = 0**, remove ***List[1]*** \\n\\t\\n### Stage 4\\n\\t\\n\\tList = [1]\\n\\tGroup 0: 1 (where k=0)\\n\\t\\nAnswer lies within **Group [int(k/(len(List)-1!)] = 0**, 4th digit is ***List[0]*** , which is \\'1\\', answer = **3 2 4 1**\\nAfter we remove ***List[0]*** , ***list*** becomes empty, terminate the loop\\n\\n```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        def fac(n,table): # define factorial function\\n            if n == 0:\\n                return 1\\n            if n in table: # dynamic programming\\n                return table[n]\\n            i = len(table) + 1\\n            while i < n+1:\\n                table[i] = table[i-1]*i\\n                i += 1\\n            return table[n]\\n                \\n        k -= 1 # we need to index everything from 0\\n        remaining = [i+1 for i in range(n)]\\n        ans = []\\n        table = {1:1} # define the base case\\n        for i in range(n):\\n            fac_rslt = fac(len(remaining)-1,table) # store the result of factorial operation\\n            index = k // fac_rslt #discover which group the answer lies within\\n            ans.append(str(remaining[index])) \\n            remaining.pop(index)\\n            k %= fac_rslt # update the k value\\n        return \\'\\'.join(ans)\\n```\\n\\nKindly upvote this post if you think the solution is helpful, thanks!",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        def fac(n,table): # define factorial function\\n            if n == 0:\\n                return 1\\n            if n in table: # dynamic programming\\n                return table[n]\\n            i = len(table) + 1\\n            while i < n+1:\\n                table[i] = table[i-1]*i\\n                i += 1\\n            return table[n]\\n                \\n        k -= 1 # we need to index everything from 0\\n        remaining = [i+1 for i in range(n)]\\n        ans = []\\n        table = {1:1} # define the base case\\n        for i in range(n):\\n            fac_rslt = fac(len(remaining)-1,table) # store the result of factorial operation\\n            index = k // fac_rslt #discover which group the answer lies within\\n            ans.append(str(remaining[index])) \\n            remaining.pop(index)\\n            k %= fac_rslt # update the k value\\n        return \\'\\'.join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298638,
                "title": "c-simple-and-short-solution-100-speed-explained",
                "content": "First thing to say, It was quite a long time when I first solved this. \\nAnd when I reviewed this question and saw my solution, I want to share it.\\nBut I\\'m not completely sure if it wasn\\'t \"copied\" (or the idea wasn\\'t copied) from other place.\\nIf it is, please let me know.\\n\\n**Jump back to the solution.** The idea is very simple.\\nLet\\'s say we are working on the first element of the answer.\\nFor the permutation from small to large, clearly the first element will change from **\\'1\\'** to **\\'n\\'**.\\n\\nHow much steps of permutation will it be between every first element changing?\\nObviously it\\'s the number of permutations of the rest of the sequence.\\nThe number will be **(n - 1)!**.\\nSo all we need to do is to calculate **k / (n - 1)!** and we\\'ll get the index of **\\'1\\'** to **\\'n\\'** for the first element.\\n\\nThen with the same logic, we work on the second element.\\nThe **k** now will become  **k % (n - 1)!** from the last round. The available characters to choose will be **\\'1\\'** to **\\'n\\'** and erase already used ones.\\n\\n\\n```\\nstring getPermutation(int n, int k) {\\n\\tvector<char> v; // store the available characters we can use\\n\\tint p = 1;\\n\\tfor(int i = 1; i <= n; i++){\\n\\t\\tp *= i;\\n\\t\\tv.push_back(\\'0\\' + i);\\n\\t}\\n\\t\\n\\tstring ans = \"\";\\n\\tk--;\\n\\tfor(int i = n; i > 0; i--){\\n\\t\\tp /= i;\\n\\t\\tans.push_back(v[k / p]);\\n\\t\\tv.erase(v.begin() + k / p);\\n\\t\\tk %= p;\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstring getPermutation(int n, int k) {\\n\\tvector<char> v; // store the available characters we can use\\n\\tint p = 1;\\n\\tfor(int i = 1; i <= n; i++){\\n\\t\\tp *= i;\\n\\t\\tv.push_back(\\'0\\' + i);\\n\\t}\\n\\t\\n\\tstring ans = \"\";\\n\\tk--;\\n\\tfor(int i = n; i > 0; i--){\\n\\t\\tp /= i;\\n\\t\\tans.push_back(v[k / p]);\\n\\t\\tv.erase(v.begin() + k / p);\\n\\t\\tk %= p;\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565541,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "           \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1862540,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "           \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1953459,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "           \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1571144,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "           \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1851467,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "           \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1571143,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "           \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 2012293,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "           \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1924314,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "           \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1899090,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "           \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1889322,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "           \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1565541,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "           \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1862540,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "           \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1953459,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "           \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1571144,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "           \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1851467,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "           \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1571143,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "           \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 2012293,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "           \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1924314,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "           \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1899090,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "           \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1889322,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "           \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 2053052,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for somebody wondering if this can be solved using trie, the answer is yes!"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "can Any one optimise this code ::..\\n`\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String numbers = \"123456789\";\\n        String st = numbers.substring(0, n);\\n        List<String> list = new ArrayList<>();\\n\\n        permutation(st, \"\", list);\\n\\n        if (k <= list.size()) return list.get(k - 1);\\n        else return \"\";\\n    }\\n   \\n   public static void permutation(String str, String afot, List<String> list) {\\n\\n        if (str.length() == 0) {\\n            list.add(afot);\\n\\n            return;\\n        }\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            char ch = str.charAt(i);\\n            String left = str.substring(0, i);\\n            String right = str.substring(i + 1);\\n            String req = left + right;\\n            permutation(req, afot + ch, list);\\n        }\\n\\n    }\\n   \\n} `"
                    },
                    {
                        "username": "aditya_dawar24",
                        "content": "i hope this helps :\\nstring x=\"\";\\n        \\n        for(int i=1;i<=n;i++){\\n            x+=\\'0\\'+i;\\n        }\\n\\n        vector<string>ans;\\n        \\n        do{\\n            ans.push_back(x);\\n        }while(next_permutation(x.begin(),x.end()));\\n    \\n        return ans[k-1];"
                    },
                    {
                        "username": "pravanshu1608",
                        "content": "Here is a possible explanation (if you still can\\'t follow it, refer to: (https://leetcode.com/problems/permutation-sequence/solutions/3853004/java-easy-to-understand-code/)\\n )\\n\\nHope this helps...\\n\\n\\narr = [1, 2, 3, 4], k = 17\\n\\nk = 17 - 1 = 16 (0-based indexing)\\n\\nHere, the number of elements is 4, so the possible permutations would be 4! = 24.\\n\\nWe can arrange the above in the following way:\\n\\n0: 1 + {2, 3, 4}\\n1: 2 + {1, 3, 4}\\n2: 3 + {1, 2, 4}\\n3: 4 + {1, 2, 3}\\n\\n0, 1, 2, 3 are index numbers.\\n\\n16/6 = 2 (this will let us know the index of the sequence, i.e., in which index the sequence would be)\\n\\n16%6 = 4 (this would give the next sequence to search for)\\n\\nWhy 6? Because in the above arrangement, we can see a number + a set of n numbers (in our case, it is 3) which is n!, i.e., 3!.\\n\\nNow we add the number of that particular index where our sequence could be found.\\n\\nWe can take an empty string and store the number so as to get our sequence.\\n\\nSo, the string is \"3\" (because 3 is the number present in that index).\\n\\nNow we remove that number and again follow the same pattern as above:\\n\\ni.e., our updated array would be [1, 2, 4], k = 4.\\n\\nAgain:\\n\\n0: 1 + {2, 4}\\n1: 2 + {1, 4}\\n2: 4 + {1, 2}\\n\\nHere 4/2 = 2, and 4%2 = 0.\\n\\nAdd the number of the 2nd index to our string, i.e., 4.\\n\\nString becomes \"34\".\\n\\nRemove that number from the array:\\n\\narr [1, 2], k = 0.\\n\\nAgain:\\n\\n0: 1 + {2}\\n1: 2 + {1}\\n\\nHere 0/1 = 0, and 0%1 = 0.\\n\\nAdd the 0th index number to the string:\\n\\nString becomes \"341\".\\n\\nNow, we are left out only with one number, so you could simply add that number to the string, i.e., the final string is \"3412\"."
                    },
                    {
                        "username": "pcRipper",
                        "content": "why is it even hard?"
                    },
                    {
                        "username": "Diean233",
                        "content": "I guess it\\'s because LC groups it together with other permutation problems, like 46&47, and this problem seems to be more complicated. But they are not the same type of problems at all, thus this is not that hard if you can just treat it as a math problem. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I think that this problem is easier than ``46. Permutations`` but that problem could be solved using backtracking and didn\\'t require knowledge of factoradics.\\n\\nI actually used factoradics to solve problem 46 so generating a single permutation proved easier than generating all of them."
                    },
                    {
                        "username": "egretrteg",
                        "content": "string s=\"\";\\n        for(int i=1;i<=n;i++) s+=to_string(i);\\n        cout<<s<<endl;\\n        int cnt=1;\\n        while(k!=1)\\n        {\\n            next_permutation(s.begin(),s.end());\\n            //cout<<s<<endl;\\n            k--;\\n        }\\n        return s;"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This question is marked as Hard.\\nIs this make sence?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It IS hard if you are not familiar with factorials."
                    },
                    {
                        "username": "Vithesh",
                        "content": "this problem is more like a medium level one.\\nThey could have made it harder by adding  strict time complexity and space.\\nHowever i used O(n) space and O(k*nlogn) time."
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s just unfair. If you are not a pure genius mathematician you have no chance to solve it without TLE :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree. I have a pretty good background in math but I am no genius for sure, and I had no particular problem solving it\nThe only mathematical knowledge required is factorials which I'm sure you're familiar with (and they even give you a refresher in the problem statement), it's unfair to say you need to be mathematician to solve that"
                    }
                ]
            },
            {
                "id": 2004225,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for somebody wondering if this can be solved using trie, the answer is yes!"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "can Any one optimise this code ::..\\n`\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String numbers = \"123456789\";\\n        String st = numbers.substring(0, n);\\n        List<String> list = new ArrayList<>();\\n\\n        permutation(st, \"\", list);\\n\\n        if (k <= list.size()) return list.get(k - 1);\\n        else return \"\";\\n    }\\n   \\n   public static void permutation(String str, String afot, List<String> list) {\\n\\n        if (str.length() == 0) {\\n            list.add(afot);\\n\\n            return;\\n        }\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            char ch = str.charAt(i);\\n            String left = str.substring(0, i);\\n            String right = str.substring(i + 1);\\n            String req = left + right;\\n            permutation(req, afot + ch, list);\\n        }\\n\\n    }\\n   \\n} `"
                    },
                    {
                        "username": "aditya_dawar24",
                        "content": "i hope this helps :\\nstring x=\"\";\\n        \\n        for(int i=1;i<=n;i++){\\n            x+=\\'0\\'+i;\\n        }\\n\\n        vector<string>ans;\\n        \\n        do{\\n            ans.push_back(x);\\n        }while(next_permutation(x.begin(),x.end()));\\n    \\n        return ans[k-1];"
                    },
                    {
                        "username": "pravanshu1608",
                        "content": "Here is a possible explanation (if you still can\\'t follow it, refer to: (https://leetcode.com/problems/permutation-sequence/solutions/3853004/java-easy-to-understand-code/)\\n )\\n\\nHope this helps...\\n\\n\\narr = [1, 2, 3, 4], k = 17\\n\\nk = 17 - 1 = 16 (0-based indexing)\\n\\nHere, the number of elements is 4, so the possible permutations would be 4! = 24.\\n\\nWe can arrange the above in the following way:\\n\\n0: 1 + {2, 3, 4}\\n1: 2 + {1, 3, 4}\\n2: 3 + {1, 2, 4}\\n3: 4 + {1, 2, 3}\\n\\n0, 1, 2, 3 are index numbers.\\n\\n16/6 = 2 (this will let us know the index of the sequence, i.e., in which index the sequence would be)\\n\\n16%6 = 4 (this would give the next sequence to search for)\\n\\nWhy 6? Because in the above arrangement, we can see a number + a set of n numbers (in our case, it is 3) which is n!, i.e., 3!.\\n\\nNow we add the number of that particular index where our sequence could be found.\\n\\nWe can take an empty string and store the number so as to get our sequence.\\n\\nSo, the string is \"3\" (because 3 is the number present in that index).\\n\\nNow we remove that number and again follow the same pattern as above:\\n\\ni.e., our updated array would be [1, 2, 4], k = 4.\\n\\nAgain:\\n\\n0: 1 + {2, 4}\\n1: 2 + {1, 4}\\n2: 4 + {1, 2}\\n\\nHere 4/2 = 2, and 4%2 = 0.\\n\\nAdd the number of the 2nd index to our string, i.e., 4.\\n\\nString becomes \"34\".\\n\\nRemove that number from the array:\\n\\narr [1, 2], k = 0.\\n\\nAgain:\\n\\n0: 1 + {2}\\n1: 2 + {1}\\n\\nHere 0/1 = 0, and 0%1 = 0.\\n\\nAdd the 0th index number to the string:\\n\\nString becomes \"341\".\\n\\nNow, we are left out only with one number, so you could simply add that number to the string, i.e., the final string is \"3412\"."
                    },
                    {
                        "username": "pcRipper",
                        "content": "why is it even hard?"
                    },
                    {
                        "username": "Diean233",
                        "content": "I guess it\\'s because LC groups it together with other permutation problems, like 46&47, and this problem seems to be more complicated. But they are not the same type of problems at all, thus this is not that hard if you can just treat it as a math problem. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I think that this problem is easier than ``46. Permutations`` but that problem could be solved using backtracking and didn\\'t require knowledge of factoradics.\\n\\nI actually used factoradics to solve problem 46 so generating a single permutation proved easier than generating all of them."
                    },
                    {
                        "username": "egretrteg",
                        "content": "string s=\"\";\\n        for(int i=1;i<=n;i++) s+=to_string(i);\\n        cout<<s<<endl;\\n        int cnt=1;\\n        while(k!=1)\\n        {\\n            next_permutation(s.begin(),s.end());\\n            //cout<<s<<endl;\\n            k--;\\n        }\\n        return s;"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This question is marked as Hard.\\nIs this make sence?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It IS hard if you are not familiar with factorials."
                    },
                    {
                        "username": "Vithesh",
                        "content": "this problem is more like a medium level one.\\nThey could have made it harder by adding  strict time complexity and space.\\nHowever i used O(n) space and O(k*nlogn) time."
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s just unfair. If you are not a pure genius mathematician you have no chance to solve it without TLE :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree. I have a pretty good background in math but I am no genius for sure, and I had no particular problem solving it\nThe only mathematical knowledge required is factorials which I'm sure you're familiar with (and they even give you a refresher in the problem statement), it's unfair to say you need to be mathematician to solve that"
                    }
                ]
            },
            {
                "id": 1998497,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for somebody wondering if this can be solved using trie, the answer is yes!"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "can Any one optimise this code ::..\\n`\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String numbers = \"123456789\";\\n        String st = numbers.substring(0, n);\\n        List<String> list = new ArrayList<>();\\n\\n        permutation(st, \"\", list);\\n\\n        if (k <= list.size()) return list.get(k - 1);\\n        else return \"\";\\n    }\\n   \\n   public static void permutation(String str, String afot, List<String> list) {\\n\\n        if (str.length() == 0) {\\n            list.add(afot);\\n\\n            return;\\n        }\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            char ch = str.charAt(i);\\n            String left = str.substring(0, i);\\n            String right = str.substring(i + 1);\\n            String req = left + right;\\n            permutation(req, afot + ch, list);\\n        }\\n\\n    }\\n   \\n} `"
                    },
                    {
                        "username": "aditya_dawar24",
                        "content": "i hope this helps :\\nstring x=\"\";\\n        \\n        for(int i=1;i<=n;i++){\\n            x+=\\'0\\'+i;\\n        }\\n\\n        vector<string>ans;\\n        \\n        do{\\n            ans.push_back(x);\\n        }while(next_permutation(x.begin(),x.end()));\\n    \\n        return ans[k-1];"
                    },
                    {
                        "username": "pravanshu1608",
                        "content": "Here is a possible explanation (if you still can\\'t follow it, refer to: (https://leetcode.com/problems/permutation-sequence/solutions/3853004/java-easy-to-understand-code/)\\n )\\n\\nHope this helps...\\n\\n\\narr = [1, 2, 3, 4], k = 17\\n\\nk = 17 - 1 = 16 (0-based indexing)\\n\\nHere, the number of elements is 4, so the possible permutations would be 4! = 24.\\n\\nWe can arrange the above in the following way:\\n\\n0: 1 + {2, 3, 4}\\n1: 2 + {1, 3, 4}\\n2: 3 + {1, 2, 4}\\n3: 4 + {1, 2, 3}\\n\\n0, 1, 2, 3 are index numbers.\\n\\n16/6 = 2 (this will let us know the index of the sequence, i.e., in which index the sequence would be)\\n\\n16%6 = 4 (this would give the next sequence to search for)\\n\\nWhy 6? Because in the above arrangement, we can see a number + a set of n numbers (in our case, it is 3) which is n!, i.e., 3!.\\n\\nNow we add the number of that particular index where our sequence could be found.\\n\\nWe can take an empty string and store the number so as to get our sequence.\\n\\nSo, the string is \"3\" (because 3 is the number present in that index).\\n\\nNow we remove that number and again follow the same pattern as above:\\n\\ni.e., our updated array would be [1, 2, 4], k = 4.\\n\\nAgain:\\n\\n0: 1 + {2, 4}\\n1: 2 + {1, 4}\\n2: 4 + {1, 2}\\n\\nHere 4/2 = 2, and 4%2 = 0.\\n\\nAdd the number of the 2nd index to our string, i.e., 4.\\n\\nString becomes \"34\".\\n\\nRemove that number from the array:\\n\\narr [1, 2], k = 0.\\n\\nAgain:\\n\\n0: 1 + {2}\\n1: 2 + {1}\\n\\nHere 0/1 = 0, and 0%1 = 0.\\n\\nAdd the 0th index number to the string:\\n\\nString becomes \"341\".\\n\\nNow, we are left out only with one number, so you could simply add that number to the string, i.e., the final string is \"3412\"."
                    },
                    {
                        "username": "pcRipper",
                        "content": "why is it even hard?"
                    },
                    {
                        "username": "Diean233",
                        "content": "I guess it\\'s because LC groups it together with other permutation problems, like 46&47, and this problem seems to be more complicated. But they are not the same type of problems at all, thus this is not that hard if you can just treat it as a math problem. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I think that this problem is easier than ``46. Permutations`` but that problem could be solved using backtracking and didn\\'t require knowledge of factoradics.\\n\\nI actually used factoradics to solve problem 46 so generating a single permutation proved easier than generating all of them."
                    },
                    {
                        "username": "egretrteg",
                        "content": "string s=\"\";\\n        for(int i=1;i<=n;i++) s+=to_string(i);\\n        cout<<s<<endl;\\n        int cnt=1;\\n        while(k!=1)\\n        {\\n            next_permutation(s.begin(),s.end());\\n            //cout<<s<<endl;\\n            k--;\\n        }\\n        return s;"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This question is marked as Hard.\\nIs this make sence?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It IS hard if you are not familiar with factorials."
                    },
                    {
                        "username": "Vithesh",
                        "content": "this problem is more like a medium level one.\\nThey could have made it harder by adding  strict time complexity and space.\\nHowever i used O(n) space and O(k*nlogn) time."
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s just unfair. If you are not a pure genius mathematician you have no chance to solve it without TLE :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree. I have a pretty good background in math but I am no genius for sure, and I had no particular problem solving it\nThe only mathematical knowledge required is factorials which I'm sure you're familiar with (and they even give you a refresher in the problem statement), it's unfair to say you need to be mathematician to solve that"
                    }
                ]
            },
            {
                "id": 1997177,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for somebody wondering if this can be solved using trie, the answer is yes!"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "can Any one optimise this code ::..\\n`\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String numbers = \"123456789\";\\n        String st = numbers.substring(0, n);\\n        List<String> list = new ArrayList<>();\\n\\n        permutation(st, \"\", list);\\n\\n        if (k <= list.size()) return list.get(k - 1);\\n        else return \"\";\\n    }\\n   \\n   public static void permutation(String str, String afot, List<String> list) {\\n\\n        if (str.length() == 0) {\\n            list.add(afot);\\n\\n            return;\\n        }\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            char ch = str.charAt(i);\\n            String left = str.substring(0, i);\\n            String right = str.substring(i + 1);\\n            String req = left + right;\\n            permutation(req, afot + ch, list);\\n        }\\n\\n    }\\n   \\n} `"
                    },
                    {
                        "username": "aditya_dawar24",
                        "content": "i hope this helps :\\nstring x=\"\";\\n        \\n        for(int i=1;i<=n;i++){\\n            x+=\\'0\\'+i;\\n        }\\n\\n        vector<string>ans;\\n        \\n        do{\\n            ans.push_back(x);\\n        }while(next_permutation(x.begin(),x.end()));\\n    \\n        return ans[k-1];"
                    },
                    {
                        "username": "pravanshu1608",
                        "content": "Here is a possible explanation (if you still can\\'t follow it, refer to: (https://leetcode.com/problems/permutation-sequence/solutions/3853004/java-easy-to-understand-code/)\\n )\\n\\nHope this helps...\\n\\n\\narr = [1, 2, 3, 4], k = 17\\n\\nk = 17 - 1 = 16 (0-based indexing)\\n\\nHere, the number of elements is 4, so the possible permutations would be 4! = 24.\\n\\nWe can arrange the above in the following way:\\n\\n0: 1 + {2, 3, 4}\\n1: 2 + {1, 3, 4}\\n2: 3 + {1, 2, 4}\\n3: 4 + {1, 2, 3}\\n\\n0, 1, 2, 3 are index numbers.\\n\\n16/6 = 2 (this will let us know the index of the sequence, i.e., in which index the sequence would be)\\n\\n16%6 = 4 (this would give the next sequence to search for)\\n\\nWhy 6? Because in the above arrangement, we can see a number + a set of n numbers (in our case, it is 3) which is n!, i.e., 3!.\\n\\nNow we add the number of that particular index where our sequence could be found.\\n\\nWe can take an empty string and store the number so as to get our sequence.\\n\\nSo, the string is \"3\" (because 3 is the number present in that index).\\n\\nNow we remove that number and again follow the same pattern as above:\\n\\ni.e., our updated array would be [1, 2, 4], k = 4.\\n\\nAgain:\\n\\n0: 1 + {2, 4}\\n1: 2 + {1, 4}\\n2: 4 + {1, 2}\\n\\nHere 4/2 = 2, and 4%2 = 0.\\n\\nAdd the number of the 2nd index to our string, i.e., 4.\\n\\nString becomes \"34\".\\n\\nRemove that number from the array:\\n\\narr [1, 2], k = 0.\\n\\nAgain:\\n\\n0: 1 + {2}\\n1: 2 + {1}\\n\\nHere 0/1 = 0, and 0%1 = 0.\\n\\nAdd the 0th index number to the string:\\n\\nString becomes \"341\".\\n\\nNow, we are left out only with one number, so you could simply add that number to the string, i.e., the final string is \"3412\"."
                    },
                    {
                        "username": "pcRipper",
                        "content": "why is it even hard?"
                    },
                    {
                        "username": "Diean233",
                        "content": "I guess it\\'s because LC groups it together with other permutation problems, like 46&47, and this problem seems to be more complicated. But they are not the same type of problems at all, thus this is not that hard if you can just treat it as a math problem. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I think that this problem is easier than ``46. Permutations`` but that problem could be solved using backtracking and didn\\'t require knowledge of factoradics.\\n\\nI actually used factoradics to solve problem 46 so generating a single permutation proved easier than generating all of them."
                    },
                    {
                        "username": "egretrteg",
                        "content": "string s=\"\";\\n        for(int i=1;i<=n;i++) s+=to_string(i);\\n        cout<<s<<endl;\\n        int cnt=1;\\n        while(k!=1)\\n        {\\n            next_permutation(s.begin(),s.end());\\n            //cout<<s<<endl;\\n            k--;\\n        }\\n        return s;"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This question is marked as Hard.\\nIs this make sence?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It IS hard if you are not familiar with factorials."
                    },
                    {
                        "username": "Vithesh",
                        "content": "this problem is more like a medium level one.\\nThey could have made it harder by adding  strict time complexity and space.\\nHowever i used O(n) space and O(k*nlogn) time."
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s just unfair. If you are not a pure genius mathematician you have no chance to solve it without TLE :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree. I have a pretty good background in math but I am no genius for sure, and I had no particular problem solving it\nThe only mathematical knowledge required is factorials which I'm sure you're familiar with (and they even give you a refresher in the problem statement), it's unfair to say you need to be mathematician to solve that"
                    }
                ]
            },
            {
                "id": 1986133,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for somebody wondering if this can be solved using trie, the answer is yes!"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "can Any one optimise this code ::..\\n`\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String numbers = \"123456789\";\\n        String st = numbers.substring(0, n);\\n        List<String> list = new ArrayList<>();\\n\\n        permutation(st, \"\", list);\\n\\n        if (k <= list.size()) return list.get(k - 1);\\n        else return \"\";\\n    }\\n   \\n   public static void permutation(String str, String afot, List<String> list) {\\n\\n        if (str.length() == 0) {\\n            list.add(afot);\\n\\n            return;\\n        }\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            char ch = str.charAt(i);\\n            String left = str.substring(0, i);\\n            String right = str.substring(i + 1);\\n            String req = left + right;\\n            permutation(req, afot + ch, list);\\n        }\\n\\n    }\\n   \\n} `"
                    },
                    {
                        "username": "aditya_dawar24",
                        "content": "i hope this helps :\\nstring x=\"\";\\n        \\n        for(int i=1;i<=n;i++){\\n            x+=\\'0\\'+i;\\n        }\\n\\n        vector<string>ans;\\n        \\n        do{\\n            ans.push_back(x);\\n        }while(next_permutation(x.begin(),x.end()));\\n    \\n        return ans[k-1];"
                    },
                    {
                        "username": "pravanshu1608",
                        "content": "Here is a possible explanation (if you still can\\'t follow it, refer to: (https://leetcode.com/problems/permutation-sequence/solutions/3853004/java-easy-to-understand-code/)\\n )\\n\\nHope this helps...\\n\\n\\narr = [1, 2, 3, 4], k = 17\\n\\nk = 17 - 1 = 16 (0-based indexing)\\n\\nHere, the number of elements is 4, so the possible permutations would be 4! = 24.\\n\\nWe can arrange the above in the following way:\\n\\n0: 1 + {2, 3, 4}\\n1: 2 + {1, 3, 4}\\n2: 3 + {1, 2, 4}\\n3: 4 + {1, 2, 3}\\n\\n0, 1, 2, 3 are index numbers.\\n\\n16/6 = 2 (this will let us know the index of the sequence, i.e., in which index the sequence would be)\\n\\n16%6 = 4 (this would give the next sequence to search for)\\n\\nWhy 6? Because in the above arrangement, we can see a number + a set of n numbers (in our case, it is 3) which is n!, i.e., 3!.\\n\\nNow we add the number of that particular index where our sequence could be found.\\n\\nWe can take an empty string and store the number so as to get our sequence.\\n\\nSo, the string is \"3\" (because 3 is the number present in that index).\\n\\nNow we remove that number and again follow the same pattern as above:\\n\\ni.e., our updated array would be [1, 2, 4], k = 4.\\n\\nAgain:\\n\\n0: 1 + {2, 4}\\n1: 2 + {1, 4}\\n2: 4 + {1, 2}\\n\\nHere 4/2 = 2, and 4%2 = 0.\\n\\nAdd the number of the 2nd index to our string, i.e., 4.\\n\\nString becomes \"34\".\\n\\nRemove that number from the array:\\n\\narr [1, 2], k = 0.\\n\\nAgain:\\n\\n0: 1 + {2}\\n1: 2 + {1}\\n\\nHere 0/1 = 0, and 0%1 = 0.\\n\\nAdd the 0th index number to the string:\\n\\nString becomes \"341\".\\n\\nNow, we are left out only with one number, so you could simply add that number to the string, i.e., the final string is \"3412\"."
                    },
                    {
                        "username": "pcRipper",
                        "content": "why is it even hard?"
                    },
                    {
                        "username": "Diean233",
                        "content": "I guess it\\'s because LC groups it together with other permutation problems, like 46&47, and this problem seems to be more complicated. But they are not the same type of problems at all, thus this is not that hard if you can just treat it as a math problem. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I think that this problem is easier than ``46. Permutations`` but that problem could be solved using backtracking and didn\\'t require knowledge of factoradics.\\n\\nI actually used factoradics to solve problem 46 so generating a single permutation proved easier than generating all of them."
                    },
                    {
                        "username": "egretrteg",
                        "content": "string s=\"\";\\n        for(int i=1;i<=n;i++) s+=to_string(i);\\n        cout<<s<<endl;\\n        int cnt=1;\\n        while(k!=1)\\n        {\\n            next_permutation(s.begin(),s.end());\\n            //cout<<s<<endl;\\n            k--;\\n        }\\n        return s;"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This question is marked as Hard.\\nIs this make sence?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It IS hard if you are not familiar with factorials."
                    },
                    {
                        "username": "Vithesh",
                        "content": "this problem is more like a medium level one.\\nThey could have made it harder by adding  strict time complexity and space.\\nHowever i used O(n) space and O(k*nlogn) time."
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s just unfair. If you are not a pure genius mathematician you have no chance to solve it without TLE :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree. I have a pretty good background in math but I am no genius for sure, and I had no particular problem solving it\nThe only mathematical knowledge required is factorials which I'm sure you're familiar with (and they even give you a refresher in the problem statement), it's unfair to say you need to be mathematician to solve that"
                    }
                ]
            },
            {
                "id": 1922327,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for somebody wondering if this can be solved using trie, the answer is yes!"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "can Any one optimise this code ::..\\n`\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String numbers = \"123456789\";\\n        String st = numbers.substring(0, n);\\n        List<String> list = new ArrayList<>();\\n\\n        permutation(st, \"\", list);\\n\\n        if (k <= list.size()) return list.get(k - 1);\\n        else return \"\";\\n    }\\n   \\n   public static void permutation(String str, String afot, List<String> list) {\\n\\n        if (str.length() == 0) {\\n            list.add(afot);\\n\\n            return;\\n        }\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            char ch = str.charAt(i);\\n            String left = str.substring(0, i);\\n            String right = str.substring(i + 1);\\n            String req = left + right;\\n            permutation(req, afot + ch, list);\\n        }\\n\\n    }\\n   \\n} `"
                    },
                    {
                        "username": "aditya_dawar24",
                        "content": "i hope this helps :\\nstring x=\"\";\\n        \\n        for(int i=1;i<=n;i++){\\n            x+=\\'0\\'+i;\\n        }\\n\\n        vector<string>ans;\\n        \\n        do{\\n            ans.push_back(x);\\n        }while(next_permutation(x.begin(),x.end()));\\n    \\n        return ans[k-1];"
                    },
                    {
                        "username": "pravanshu1608",
                        "content": "Here is a possible explanation (if you still can\\'t follow it, refer to: (https://leetcode.com/problems/permutation-sequence/solutions/3853004/java-easy-to-understand-code/)\\n )\\n\\nHope this helps...\\n\\n\\narr = [1, 2, 3, 4], k = 17\\n\\nk = 17 - 1 = 16 (0-based indexing)\\n\\nHere, the number of elements is 4, so the possible permutations would be 4! = 24.\\n\\nWe can arrange the above in the following way:\\n\\n0: 1 + {2, 3, 4}\\n1: 2 + {1, 3, 4}\\n2: 3 + {1, 2, 4}\\n3: 4 + {1, 2, 3}\\n\\n0, 1, 2, 3 are index numbers.\\n\\n16/6 = 2 (this will let us know the index of the sequence, i.e., in which index the sequence would be)\\n\\n16%6 = 4 (this would give the next sequence to search for)\\n\\nWhy 6? Because in the above arrangement, we can see a number + a set of n numbers (in our case, it is 3) which is n!, i.e., 3!.\\n\\nNow we add the number of that particular index where our sequence could be found.\\n\\nWe can take an empty string and store the number so as to get our sequence.\\n\\nSo, the string is \"3\" (because 3 is the number present in that index).\\n\\nNow we remove that number and again follow the same pattern as above:\\n\\ni.e., our updated array would be [1, 2, 4], k = 4.\\n\\nAgain:\\n\\n0: 1 + {2, 4}\\n1: 2 + {1, 4}\\n2: 4 + {1, 2}\\n\\nHere 4/2 = 2, and 4%2 = 0.\\n\\nAdd the number of the 2nd index to our string, i.e., 4.\\n\\nString becomes \"34\".\\n\\nRemove that number from the array:\\n\\narr [1, 2], k = 0.\\n\\nAgain:\\n\\n0: 1 + {2}\\n1: 2 + {1}\\n\\nHere 0/1 = 0, and 0%1 = 0.\\n\\nAdd the 0th index number to the string:\\n\\nString becomes \"341\".\\n\\nNow, we are left out only with one number, so you could simply add that number to the string, i.e., the final string is \"3412\"."
                    },
                    {
                        "username": "pcRipper",
                        "content": "why is it even hard?"
                    },
                    {
                        "username": "Diean233",
                        "content": "I guess it\\'s because LC groups it together with other permutation problems, like 46&47, and this problem seems to be more complicated. But they are not the same type of problems at all, thus this is not that hard if you can just treat it as a math problem. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I think that this problem is easier than ``46. Permutations`` but that problem could be solved using backtracking and didn\\'t require knowledge of factoradics.\\n\\nI actually used factoradics to solve problem 46 so generating a single permutation proved easier than generating all of them."
                    },
                    {
                        "username": "egretrteg",
                        "content": "string s=\"\";\\n        for(int i=1;i<=n;i++) s+=to_string(i);\\n        cout<<s<<endl;\\n        int cnt=1;\\n        while(k!=1)\\n        {\\n            next_permutation(s.begin(),s.end());\\n            //cout<<s<<endl;\\n            k--;\\n        }\\n        return s;"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This question is marked as Hard.\\nIs this make sence?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It IS hard if you are not familiar with factorials."
                    },
                    {
                        "username": "Vithesh",
                        "content": "this problem is more like a medium level one.\\nThey could have made it harder by adding  strict time complexity and space.\\nHowever i used O(n) space and O(k*nlogn) time."
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s just unfair. If you are not a pure genius mathematician you have no chance to solve it without TLE :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree. I have a pretty good background in math but I am no genius for sure, and I had no particular problem solving it\nThe only mathematical knowledge required is factorials which I'm sure you're familiar with (and they even give you a refresher in the problem statement), it's unfair to say you need to be mathematician to solve that"
                    }
                ]
            },
            {
                "id": 1912940,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for somebody wondering if this can be solved using trie, the answer is yes!"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "can Any one optimise this code ::..\\n`\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String numbers = \"123456789\";\\n        String st = numbers.substring(0, n);\\n        List<String> list = new ArrayList<>();\\n\\n        permutation(st, \"\", list);\\n\\n        if (k <= list.size()) return list.get(k - 1);\\n        else return \"\";\\n    }\\n   \\n   public static void permutation(String str, String afot, List<String> list) {\\n\\n        if (str.length() == 0) {\\n            list.add(afot);\\n\\n            return;\\n        }\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            char ch = str.charAt(i);\\n            String left = str.substring(0, i);\\n            String right = str.substring(i + 1);\\n            String req = left + right;\\n            permutation(req, afot + ch, list);\\n        }\\n\\n    }\\n   \\n} `"
                    },
                    {
                        "username": "aditya_dawar24",
                        "content": "i hope this helps :\\nstring x=\"\";\\n        \\n        for(int i=1;i<=n;i++){\\n            x+=\\'0\\'+i;\\n        }\\n\\n        vector<string>ans;\\n        \\n        do{\\n            ans.push_back(x);\\n        }while(next_permutation(x.begin(),x.end()));\\n    \\n        return ans[k-1];"
                    },
                    {
                        "username": "pravanshu1608",
                        "content": "Here is a possible explanation (if you still can\\'t follow it, refer to: (https://leetcode.com/problems/permutation-sequence/solutions/3853004/java-easy-to-understand-code/)\\n )\\n\\nHope this helps...\\n\\n\\narr = [1, 2, 3, 4], k = 17\\n\\nk = 17 - 1 = 16 (0-based indexing)\\n\\nHere, the number of elements is 4, so the possible permutations would be 4! = 24.\\n\\nWe can arrange the above in the following way:\\n\\n0: 1 + {2, 3, 4}\\n1: 2 + {1, 3, 4}\\n2: 3 + {1, 2, 4}\\n3: 4 + {1, 2, 3}\\n\\n0, 1, 2, 3 are index numbers.\\n\\n16/6 = 2 (this will let us know the index of the sequence, i.e., in which index the sequence would be)\\n\\n16%6 = 4 (this would give the next sequence to search for)\\n\\nWhy 6? Because in the above arrangement, we can see a number + a set of n numbers (in our case, it is 3) which is n!, i.e., 3!.\\n\\nNow we add the number of that particular index where our sequence could be found.\\n\\nWe can take an empty string and store the number so as to get our sequence.\\n\\nSo, the string is \"3\" (because 3 is the number present in that index).\\n\\nNow we remove that number and again follow the same pattern as above:\\n\\ni.e., our updated array would be [1, 2, 4], k = 4.\\n\\nAgain:\\n\\n0: 1 + {2, 4}\\n1: 2 + {1, 4}\\n2: 4 + {1, 2}\\n\\nHere 4/2 = 2, and 4%2 = 0.\\n\\nAdd the number of the 2nd index to our string, i.e., 4.\\n\\nString becomes \"34\".\\n\\nRemove that number from the array:\\n\\narr [1, 2], k = 0.\\n\\nAgain:\\n\\n0: 1 + {2}\\n1: 2 + {1}\\n\\nHere 0/1 = 0, and 0%1 = 0.\\n\\nAdd the 0th index number to the string:\\n\\nString becomes \"341\".\\n\\nNow, we are left out only with one number, so you could simply add that number to the string, i.e., the final string is \"3412\"."
                    },
                    {
                        "username": "pcRipper",
                        "content": "why is it even hard?"
                    },
                    {
                        "username": "Diean233",
                        "content": "I guess it\\'s because LC groups it together with other permutation problems, like 46&47, and this problem seems to be more complicated. But they are not the same type of problems at all, thus this is not that hard if you can just treat it as a math problem. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I think that this problem is easier than ``46. Permutations`` but that problem could be solved using backtracking and didn\\'t require knowledge of factoradics.\\n\\nI actually used factoradics to solve problem 46 so generating a single permutation proved easier than generating all of them."
                    },
                    {
                        "username": "egretrteg",
                        "content": "string s=\"\";\\n        for(int i=1;i<=n;i++) s+=to_string(i);\\n        cout<<s<<endl;\\n        int cnt=1;\\n        while(k!=1)\\n        {\\n            next_permutation(s.begin(),s.end());\\n            //cout<<s<<endl;\\n            k--;\\n        }\\n        return s;"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This question is marked as Hard.\\nIs this make sence?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It IS hard if you are not familiar with factorials."
                    },
                    {
                        "username": "Vithesh",
                        "content": "this problem is more like a medium level one.\\nThey could have made it harder by adding  strict time complexity and space.\\nHowever i used O(n) space and O(k*nlogn) time."
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s just unfair. If you are not a pure genius mathematician you have no chance to solve it without TLE :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree. I have a pretty good background in math but I am no genius for sure, and I had no particular problem solving it\nThe only mathematical knowledge required is factorials which I'm sure you're familiar with (and they even give you a refresher in the problem statement), it's unfair to say you need to be mathematician to solve that"
                    }
                ]
            },
            {
                "id": 1862902,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for somebody wondering if this can be solved using trie, the answer is yes!"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "can Any one optimise this code ::..\\n`\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String numbers = \"123456789\";\\n        String st = numbers.substring(0, n);\\n        List<String> list = new ArrayList<>();\\n\\n        permutation(st, \"\", list);\\n\\n        if (k <= list.size()) return list.get(k - 1);\\n        else return \"\";\\n    }\\n   \\n   public static void permutation(String str, String afot, List<String> list) {\\n\\n        if (str.length() == 0) {\\n            list.add(afot);\\n\\n            return;\\n        }\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            char ch = str.charAt(i);\\n            String left = str.substring(0, i);\\n            String right = str.substring(i + 1);\\n            String req = left + right;\\n            permutation(req, afot + ch, list);\\n        }\\n\\n    }\\n   \\n} `"
                    },
                    {
                        "username": "aditya_dawar24",
                        "content": "i hope this helps :\\nstring x=\"\";\\n        \\n        for(int i=1;i<=n;i++){\\n            x+=\\'0\\'+i;\\n        }\\n\\n        vector<string>ans;\\n        \\n        do{\\n            ans.push_back(x);\\n        }while(next_permutation(x.begin(),x.end()));\\n    \\n        return ans[k-1];"
                    },
                    {
                        "username": "pravanshu1608",
                        "content": "Here is a possible explanation (if you still can\\'t follow it, refer to: (https://leetcode.com/problems/permutation-sequence/solutions/3853004/java-easy-to-understand-code/)\\n )\\n\\nHope this helps...\\n\\n\\narr = [1, 2, 3, 4], k = 17\\n\\nk = 17 - 1 = 16 (0-based indexing)\\n\\nHere, the number of elements is 4, so the possible permutations would be 4! = 24.\\n\\nWe can arrange the above in the following way:\\n\\n0: 1 + {2, 3, 4}\\n1: 2 + {1, 3, 4}\\n2: 3 + {1, 2, 4}\\n3: 4 + {1, 2, 3}\\n\\n0, 1, 2, 3 are index numbers.\\n\\n16/6 = 2 (this will let us know the index of the sequence, i.e., in which index the sequence would be)\\n\\n16%6 = 4 (this would give the next sequence to search for)\\n\\nWhy 6? Because in the above arrangement, we can see a number + a set of n numbers (in our case, it is 3) which is n!, i.e., 3!.\\n\\nNow we add the number of that particular index where our sequence could be found.\\n\\nWe can take an empty string and store the number so as to get our sequence.\\n\\nSo, the string is \"3\" (because 3 is the number present in that index).\\n\\nNow we remove that number and again follow the same pattern as above:\\n\\ni.e., our updated array would be [1, 2, 4], k = 4.\\n\\nAgain:\\n\\n0: 1 + {2, 4}\\n1: 2 + {1, 4}\\n2: 4 + {1, 2}\\n\\nHere 4/2 = 2, and 4%2 = 0.\\n\\nAdd the number of the 2nd index to our string, i.e., 4.\\n\\nString becomes \"34\".\\n\\nRemove that number from the array:\\n\\narr [1, 2], k = 0.\\n\\nAgain:\\n\\n0: 1 + {2}\\n1: 2 + {1}\\n\\nHere 0/1 = 0, and 0%1 = 0.\\n\\nAdd the 0th index number to the string:\\n\\nString becomes \"341\".\\n\\nNow, we are left out only with one number, so you could simply add that number to the string, i.e., the final string is \"3412\"."
                    },
                    {
                        "username": "pcRipper",
                        "content": "why is it even hard?"
                    },
                    {
                        "username": "Diean233",
                        "content": "I guess it\\'s because LC groups it together with other permutation problems, like 46&47, and this problem seems to be more complicated. But they are not the same type of problems at all, thus this is not that hard if you can just treat it as a math problem. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I think that this problem is easier than ``46. Permutations`` but that problem could be solved using backtracking and didn\\'t require knowledge of factoradics.\\n\\nI actually used factoradics to solve problem 46 so generating a single permutation proved easier than generating all of them."
                    },
                    {
                        "username": "egretrteg",
                        "content": "string s=\"\";\\n        for(int i=1;i<=n;i++) s+=to_string(i);\\n        cout<<s<<endl;\\n        int cnt=1;\\n        while(k!=1)\\n        {\\n            next_permutation(s.begin(),s.end());\\n            //cout<<s<<endl;\\n            k--;\\n        }\\n        return s;"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This question is marked as Hard.\\nIs this make sence?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It IS hard if you are not familiar with factorials."
                    },
                    {
                        "username": "Vithesh",
                        "content": "this problem is more like a medium level one.\\nThey could have made it harder by adding  strict time complexity and space.\\nHowever i used O(n) space and O(k*nlogn) time."
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s just unfair. If you are not a pure genius mathematician you have no chance to solve it without TLE :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree. I have a pretty good background in math but I am no genius for sure, and I had no particular problem solving it\nThe only mathematical knowledge required is factorials which I'm sure you're familiar with (and they even give you a refresher in the problem statement), it's unfair to say you need to be mathematician to solve that"
                    }
                ]
            },
            {
                "id": 1850409,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for somebody wondering if this can be solved using trie, the answer is yes!"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "can Any one optimise this code ::..\\n`\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String numbers = \"123456789\";\\n        String st = numbers.substring(0, n);\\n        List<String> list = new ArrayList<>();\\n\\n        permutation(st, \"\", list);\\n\\n        if (k <= list.size()) return list.get(k - 1);\\n        else return \"\";\\n    }\\n   \\n   public static void permutation(String str, String afot, List<String> list) {\\n\\n        if (str.length() == 0) {\\n            list.add(afot);\\n\\n            return;\\n        }\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            char ch = str.charAt(i);\\n            String left = str.substring(0, i);\\n            String right = str.substring(i + 1);\\n            String req = left + right;\\n            permutation(req, afot + ch, list);\\n        }\\n\\n    }\\n   \\n} `"
                    },
                    {
                        "username": "aditya_dawar24",
                        "content": "i hope this helps :\\nstring x=\"\";\\n        \\n        for(int i=1;i<=n;i++){\\n            x+=\\'0\\'+i;\\n        }\\n\\n        vector<string>ans;\\n        \\n        do{\\n            ans.push_back(x);\\n        }while(next_permutation(x.begin(),x.end()));\\n    \\n        return ans[k-1];"
                    },
                    {
                        "username": "pravanshu1608",
                        "content": "Here is a possible explanation (if you still can\\'t follow it, refer to: (https://leetcode.com/problems/permutation-sequence/solutions/3853004/java-easy-to-understand-code/)\\n )\\n\\nHope this helps...\\n\\n\\narr = [1, 2, 3, 4], k = 17\\n\\nk = 17 - 1 = 16 (0-based indexing)\\n\\nHere, the number of elements is 4, so the possible permutations would be 4! = 24.\\n\\nWe can arrange the above in the following way:\\n\\n0: 1 + {2, 3, 4}\\n1: 2 + {1, 3, 4}\\n2: 3 + {1, 2, 4}\\n3: 4 + {1, 2, 3}\\n\\n0, 1, 2, 3 are index numbers.\\n\\n16/6 = 2 (this will let us know the index of the sequence, i.e., in which index the sequence would be)\\n\\n16%6 = 4 (this would give the next sequence to search for)\\n\\nWhy 6? Because in the above arrangement, we can see a number + a set of n numbers (in our case, it is 3) which is n!, i.e., 3!.\\n\\nNow we add the number of that particular index where our sequence could be found.\\n\\nWe can take an empty string and store the number so as to get our sequence.\\n\\nSo, the string is \"3\" (because 3 is the number present in that index).\\n\\nNow we remove that number and again follow the same pattern as above:\\n\\ni.e., our updated array would be [1, 2, 4], k = 4.\\n\\nAgain:\\n\\n0: 1 + {2, 4}\\n1: 2 + {1, 4}\\n2: 4 + {1, 2}\\n\\nHere 4/2 = 2, and 4%2 = 0.\\n\\nAdd the number of the 2nd index to our string, i.e., 4.\\n\\nString becomes \"34\".\\n\\nRemove that number from the array:\\n\\narr [1, 2], k = 0.\\n\\nAgain:\\n\\n0: 1 + {2}\\n1: 2 + {1}\\n\\nHere 0/1 = 0, and 0%1 = 0.\\n\\nAdd the 0th index number to the string:\\n\\nString becomes \"341\".\\n\\nNow, we are left out only with one number, so you could simply add that number to the string, i.e., the final string is \"3412\"."
                    },
                    {
                        "username": "pcRipper",
                        "content": "why is it even hard?"
                    },
                    {
                        "username": "Diean233",
                        "content": "I guess it\\'s because LC groups it together with other permutation problems, like 46&47, and this problem seems to be more complicated. But they are not the same type of problems at all, thus this is not that hard if you can just treat it as a math problem. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I think that this problem is easier than ``46. Permutations`` but that problem could be solved using backtracking and didn\\'t require knowledge of factoradics.\\n\\nI actually used factoradics to solve problem 46 so generating a single permutation proved easier than generating all of them."
                    },
                    {
                        "username": "egretrteg",
                        "content": "string s=\"\";\\n        for(int i=1;i<=n;i++) s+=to_string(i);\\n        cout<<s<<endl;\\n        int cnt=1;\\n        while(k!=1)\\n        {\\n            next_permutation(s.begin(),s.end());\\n            //cout<<s<<endl;\\n            k--;\\n        }\\n        return s;"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This question is marked as Hard.\\nIs this make sence?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It IS hard if you are not familiar with factorials."
                    },
                    {
                        "username": "Vithesh",
                        "content": "this problem is more like a medium level one.\\nThey could have made it harder by adding  strict time complexity and space.\\nHowever i used O(n) space and O(k*nlogn) time."
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s just unfair. If you are not a pure genius mathematician you have no chance to solve it without TLE :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree. I have a pretty good background in math but I am no genius for sure, and I had no particular problem solving it\nThe only mathematical knowledge required is factorials which I'm sure you're familiar with (and they even give you a refresher in the problem statement), it's unfair to say you need to be mathematician to solve that"
                    }
                ]
            },
            {
                "id": 1843550,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for somebody wondering if this can be solved using trie, the answer is yes!"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "can Any one optimise this code ::..\\n`\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String numbers = \"123456789\";\\n        String st = numbers.substring(0, n);\\n        List<String> list = new ArrayList<>();\\n\\n        permutation(st, \"\", list);\\n\\n        if (k <= list.size()) return list.get(k - 1);\\n        else return \"\";\\n    }\\n   \\n   public static void permutation(String str, String afot, List<String> list) {\\n\\n        if (str.length() == 0) {\\n            list.add(afot);\\n\\n            return;\\n        }\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            char ch = str.charAt(i);\\n            String left = str.substring(0, i);\\n            String right = str.substring(i + 1);\\n            String req = left + right;\\n            permutation(req, afot + ch, list);\\n        }\\n\\n    }\\n   \\n} `"
                    },
                    {
                        "username": "aditya_dawar24",
                        "content": "i hope this helps :\\nstring x=\"\";\\n        \\n        for(int i=1;i<=n;i++){\\n            x+=\\'0\\'+i;\\n        }\\n\\n        vector<string>ans;\\n        \\n        do{\\n            ans.push_back(x);\\n        }while(next_permutation(x.begin(),x.end()));\\n    \\n        return ans[k-1];"
                    },
                    {
                        "username": "pravanshu1608",
                        "content": "Here is a possible explanation (if you still can\\'t follow it, refer to: (https://leetcode.com/problems/permutation-sequence/solutions/3853004/java-easy-to-understand-code/)\\n )\\n\\nHope this helps...\\n\\n\\narr = [1, 2, 3, 4], k = 17\\n\\nk = 17 - 1 = 16 (0-based indexing)\\n\\nHere, the number of elements is 4, so the possible permutations would be 4! = 24.\\n\\nWe can arrange the above in the following way:\\n\\n0: 1 + {2, 3, 4}\\n1: 2 + {1, 3, 4}\\n2: 3 + {1, 2, 4}\\n3: 4 + {1, 2, 3}\\n\\n0, 1, 2, 3 are index numbers.\\n\\n16/6 = 2 (this will let us know the index of the sequence, i.e., in which index the sequence would be)\\n\\n16%6 = 4 (this would give the next sequence to search for)\\n\\nWhy 6? Because in the above arrangement, we can see a number + a set of n numbers (in our case, it is 3) which is n!, i.e., 3!.\\n\\nNow we add the number of that particular index where our sequence could be found.\\n\\nWe can take an empty string and store the number so as to get our sequence.\\n\\nSo, the string is \"3\" (because 3 is the number present in that index).\\n\\nNow we remove that number and again follow the same pattern as above:\\n\\ni.e., our updated array would be [1, 2, 4], k = 4.\\n\\nAgain:\\n\\n0: 1 + {2, 4}\\n1: 2 + {1, 4}\\n2: 4 + {1, 2}\\n\\nHere 4/2 = 2, and 4%2 = 0.\\n\\nAdd the number of the 2nd index to our string, i.e., 4.\\n\\nString becomes \"34\".\\n\\nRemove that number from the array:\\n\\narr [1, 2], k = 0.\\n\\nAgain:\\n\\n0: 1 + {2}\\n1: 2 + {1}\\n\\nHere 0/1 = 0, and 0%1 = 0.\\n\\nAdd the 0th index number to the string:\\n\\nString becomes \"341\".\\n\\nNow, we are left out only with one number, so you could simply add that number to the string, i.e., the final string is \"3412\"."
                    },
                    {
                        "username": "pcRipper",
                        "content": "why is it even hard?"
                    },
                    {
                        "username": "Diean233",
                        "content": "I guess it\\'s because LC groups it together with other permutation problems, like 46&47, and this problem seems to be more complicated. But they are not the same type of problems at all, thus this is not that hard if you can just treat it as a math problem. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I think that this problem is easier than ``46. Permutations`` but that problem could be solved using backtracking and didn\\'t require knowledge of factoradics.\\n\\nI actually used factoradics to solve problem 46 so generating a single permutation proved easier than generating all of them."
                    },
                    {
                        "username": "egretrteg",
                        "content": "string s=\"\";\\n        for(int i=1;i<=n;i++) s+=to_string(i);\\n        cout<<s<<endl;\\n        int cnt=1;\\n        while(k!=1)\\n        {\\n            next_permutation(s.begin(),s.end());\\n            //cout<<s<<endl;\\n            k--;\\n        }\\n        return s;"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This question is marked as Hard.\\nIs this make sence?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It IS hard if you are not familiar with factorials."
                    },
                    {
                        "username": "Vithesh",
                        "content": "this problem is more like a medium level one.\\nThey could have made it harder by adding  strict time complexity and space.\\nHowever i used O(n) space and O(k*nlogn) time."
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s just unfair. If you are not a pure genius mathematician you have no chance to solve it without TLE :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree. I have a pretty good background in math but I am no genius for sure, and I had no particular problem solving it\nThe only mathematical knowledge required is factorials which I'm sure you're familiar with (and they even give you a refresher in the problem statement), it's unfair to say you need to be mathematician to solve that"
                    }
                ]
            }
        ]
    }
]