[
    {
        "title": "Rotate List",
        "question_content": "Given the head of a linked&nbsp;list, rotate the list to the right by k places.\n&nbsp;\nExample 1:\n\nInput: head = [1,2,3,4,5], k = 2\nOutput: [4,5,1,2,3]\n\nExample 2:\n\nInput: head = [0,1,2], k = 4\nOutput: [2,0,1]\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the list is in the range [0, 500].\n\t-100 <= Node.val <= 100\n\t0 <= k <= 2 * 109",
        "solutions": [
            {
                "id": 22735,
                "title": "my-clean-c-code-quite-standard-find-tail-and-reconnect-the-list",
                "content": "There is no trick for this problem. Some people used slow/fast pointers to find the tail node but I don't see the benefit (in the sense that it doesn't reduce the pointer move op) to do so. So I just used one loop to find the length first.\\n\\n    class Solution {\\n    public:\\n        ListNode* rotateRight(ListNode* head, int k) {\\n            if(!head) return head;\\n            \\n            int len=1; // number of nodes\\n            ListNode *newH, *tail;\\n            newH=tail=head;\\n            \\n            while(tail->next)  // get the number of nodes in the list\\n            {\\n                tail = tail->next;\\n                len++;\\n            }\\n            tail->next = head; // circle the link\\n\\n            if(k %= len) \\n            {\\n                for(auto i=0; i<len-k; i++) tail = tail->next; // the tail node is the (len-k)-th node (1st node is head)\\n            }\\n            newH = tail->next; \\n            tail->next = NULL;\\n            return newH;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* rotateRight(ListNode* head, int k) {\\n            if(!head) return head;\\n            \\n            int len=1; // number of nodes\\n            ListNode *newH, *tail;\\n            newH=tail=head;\\n            \\n            while(tail->next)  // get the number of nodes in the list\\n            {\\n                tail = tail->next;\\n                len++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 348197,
                "title": "96-faster-simple-python-solution-with-explanation",
                "content": "Please upvote if you liked the solution \\n\\n\\n```\\n\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        \\n        if not head:\\n            return None\\n        \\n        lastElement = head\\n        length = 1\\n        # get the length of the list and the last node in the list\\n        while ( lastElement.next ):\\n            lastElement = lastElement.next\\n            length += 1\\n\\n        # If k is equal to the length of the list then k == 0\\n        # ElIf k is greater than the length of the list then k = k % length\\n        k = k % length\\n            \\n        # Set the last node to point to head node\\n        # The list is now a circular linked list with last node pointing to first node\\n        lastElement.next = head\\n        \\n        # Traverse the list to get to the node just before the ( length - k )th node.\\n        # Example: In 1->2->3->4->5, and k = 2\\n        #          we need to get to the Node(3)\\n        tempNode = head\\n        for _ in range( length - k - 1 ):\\n            tempNode = tempNode.next\\n        \\n        # Get the next node from the tempNode and then set the tempNode.next as None\\n        # Example: In 1->2->3->4->5, and k = 2\\n        #          tempNode = Node(3)\\n        #          answer = Node(3).next => Node(4)\\n        #          Node(3).next = None ( cut the linked list from here )\\n        answer = tempNode.next\\n        tempNode.next = None\\n        \\n        return answer\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        \\n        if not head:\\n            return None\\n        \\n        lastElement = head\\n        length = 1\\n        # get the length of the list and the last node in the list\\n        while ( lastElement.next ):\\n            lastElement = lastElement.next\\n            length += 1\\n\\n        # If k is equal to the length of the list then k == 0\\n        # ElIf k is greater than the length of the list then k = k % length\\n        k = k % length\\n            \\n        # Set the last node to point to head node\\n        # The list is now a circular linked list with last node pointing to first node\\n        lastElement.next = head\\n        \\n        # Traverse the list to get to the node just before the ( length - k )th node.\\n        # Example: In 1->2->3->4->5, and k = 2\\n        #          we need to get to the Node(3)\\n        tempNode = head\\n        for _ in range( length - k - 1 ):\\n            tempNode = tempNode.next\\n        \\n        # Get the next node from the tempNode and then set the tempNode.next as None\\n        # Example: In 1->2->3->4->5, and k = 2\\n        #          tempNode = Node(3)\\n        #          answer = Node(3).next => Node(4)\\n        #          Node(3).next = None ( cut the linked list from here )\\n        answer = tempNode.next\\n        tempNode.next = None\\n        \\n        return answer\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22715,
                "title": "share-my-java-solution-with-explanation",
                "content": "Since n may be  a large number compared to the length of list. So we need to know the length of linked list.After that, move the list after the (l-n%l )th node to the front to finish the rotation.\\n\\nEx: {1,2,3} k=2 Move the list after the 1st node to the front\\n\\n\\nEx: {1,2,3} k=5, In this case Move the list after (3-5%3=1)st node to the front.\\n\\nSo  the code has three parts. \\n\\n1) Get the length\\n\\n2) Move to the (l-n%l)th node\\n\\n3)Do the rotation\\n\\n\\n\\n    public ListNode rotateRight(ListNode head, int n) {\\n        if (head==null||head.next==null) return head;\\n        ListNode dummy=new ListNode(0);\\n        dummy.next=head;\\n        ListNode fast=dummy,slow=dummy;\\n\\n        int i;\\n        for (i=0;fast.next!=null;i++)//Get the total length \\n        \\tfast=fast.next;\\n        \\n        for (int j=i-n%i;j>0;j--) //Get the i-n%i th node\\n        \\tslow=slow.next;\\n        \\n        fast.next=dummy.next; //Do the rotation\\n        dummy.next=slow.next;\\n        slow.next=null;\\n        \\n        return dummy.next;\\n    }",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "Since n may be  a large number compared to the length of list. So we need to know the length of linked list.After that, move the list after the (l-n%l )th node to the front to finish the rotation.\\n\\nEx: {1,2,3} k=2 Move the list after the 1st node to the front\\n\\n\\nEx: {1,2,3} k=5, In this case Move the list after (3-5%3=1)st node to the front.\\n\\nSo  the code has three parts. \\n\\n1) Get the length\\n\\n2) Move to the (l-n%l)th node\\n\\n3)Do the rotation\\n\\n\\n\\n    public ListNode rotateRight(ListNode head, int n) {\\n        if (head==null||head.next==null) return head;\\n        ListNode dummy=new ListNode(0);\\n        dummy.next=head;\\n        ListNode fast=dummy,slow=dummy;\\n\\n        int i;\\n        for (i=0;fast.next!=null;i++)//Get the total length \\n        \\tfast=fast.next;\\n        \\n        for (int j=i-n%i;j>0;j--) //Get the i-n%i th node\\n        \\tslow=slow.next;\\n        \\n        fast.next=dummy.next; //Do the rotation\\n        dummy.next=slow.next;\\n        slow.next=null;\\n        \\n        return dummy.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 22827,
                "title": "java-clean-solution-only-one-pointer-used",
                "content": "I first used a ListNode p, and point it to the head, then move it to the end of the list, and at the same time get the length of the list.  Then `p.next = head;` gives me a circle.   At this time, by moving `p` for `len-k` times, it will be pointing to the node before the break point.  Then all we need to do is record the next node as head, and break the circle with `p.next = null.`  \\n\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head == null || k == 0) {\\n            return head;\\n        }\\n        ListNode p = head;\\n        int len = 1;\\n        while(p.next != null) {\\n            p = p.next;\\n            len++;\\n        }\\n        p.next = head;\\n        k %= len;\\n        for(int i = 0; i < len - k; i++) {\\n            p = p.next;\\n        }\\n        head = p.next;\\n        p.next = null;\\n        return head;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "I first used a ListNode p, and point it to the head, then move it to the end of the list, and at the same time get the length of the list.  Then `p.next = head;` gives me a circle.   At this time, by moving `p` for `len-k` times, it will be pointing to the node before the break point.  Then all we need to do is record the next node as head, and break the circle with `p.next = null.`  \\n\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head == null || k == 0) {\\n            return head;\\n        }\\n        ListNode p = head;\\n        int len = 1;\\n        while(p.next != null) {\\n            p = p.next;\\n            len++;\\n        }\\n        p.next = head;\\n        k %= len;\\n        for(int i = 0; i < len - k; i++) {\\n            p = p.next;\\n        }\\n        head = p.next;\\n        p.next = null;\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 22726,
                "title": "anyone-solve-the-problem-without-counting-the-length-of-list",
                "content": "My solution has O(n) time complexity and O(1) memory.\\nThe basic idea is to connect the list into a circle. First, count the length of list while going through the list to find the end of it. Connect the tail to head. The problem asked to rotate k nodes, however, now the tail is at the end of the list and its difficult to move backward, so move *(k - len)* nodes along the list instead. *\"k = k % len\"* saves the unnecessary moves because rotate a list with length = *len* by *len* times doesn't change the list at all.\\n\\n    ListNode *rotateRight(ListNode *head, int k) {\\n            if (head == NULL || head->next == NULL || k == 0) return head;\\n            int len = 1;\\n            ListNode *tail = head;\\n\\n            /* find the end of list */\\n            while (tail->next != NULL) {\\n                tail = tail->next;\\n                len++;\\n            }\\n\\n            /* form a circle */\\n            tail->next = head;\\n            k = k % len;\\n            for (int i = 0; i < len - k; i++) {\\n                tail = tail->next;\\n            }\\n            head = tail->next;\\n            tail->next = NULL;\\n            return head;\\n        }",
                "solutionTags": [],
                "code": "My solution has O(n) time complexity and O(1) memory.\\nThe basic idea is to connect the list into a circle. First, count the length of list while going through the list to find the end of it. Connect the tail to head. The problem asked to rotate k nodes, however, now the tail is at the end of the list and its difficult to move backward, so move *(k - len)* nodes along the list instead. *\"k = k % len\"* saves the unnecessary moves because rotate a list with length = *len* by *len* times doesn't change the list at all.\\n\\n    ListNode *rotateRight(ListNode *head, int k) {\\n            if (head == NULL || head->next == NULL || k == 0) return head;\\n            int len = 1;\\n            ListNode *tail = head;\\n\\n            /* find the end of list */\\n            while (tail->next != NULL) {\\n                tail = tail->next;\\n                len++;\\n            }\\n\\n            /* form a circle */\\n            tail->next = head;\\n            k = k % len;\\n            for (int i = 0; i < len - k; i++) {\\n                tail = tail->next;\\n            }\\n            head = tail->next;\\n            tail->next = NULL;\\n            return head;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 22751,
                "title": "clean-java-solution-with-brief-explanation",
                "content": "The basic idea is to link the tail of the list with the head, make it a cycle. Then count to the rotate point and cut it.\\n\\n    if (head == null)\\n\\t\\t\\treturn head;\\n\\t\\t\\n\\t\\tListNode copyHead = head;\\n\\t\\t\\n\\t\\tint len = 1;\\n\\t\\twhile (copyHead.next != null) {\\n\\t\\t\\tcopyHead = copyHead.next;\\n\\t\\t\\tlen++;\\n\\t\\t}\\n\\t\\t\\n\\t\\tcopyHead.next = head;\\n\\t\\t\\n\\t\\tfor (int i = len - k % len; i > 1; i--)\\n\\t\\t\\thead = head.next;\\n\\n\\t\\tcopyHead = head.next;\\n\\t\\thead.next = null;\\n\\n\\t\\treturn copyHead;\\n\\t}",
                "solutionTags": [],
                "code": "The basic idea is to link the tail of the list with the head, make it a cycle. Then count to the rotate point and cut it.\\n\\n    if (head == null)\\n\\t\\t\\treturn head;\\n\\t\\t\\n\\t\\tListNode copyHead = head;\\n\\t\\t\\n\\t\\tint len = 1;\\n\\t\\twhile (copyHead.next != null) {\\n\\t\\t\\tcopyHead = copyHead.next;\\n\\t\\t\\tlen++;\\n\\t\\t}\\n\\t\\t\\n\\t\\tcopyHead.next = head;\\n\\t\\t\\n\\t\\tfor (int i = len - k % len; i > 1; i--)\\n\\t\\t\\thead = head.next;\\n\\n\\t\\tcopyHead = head.next;\\n\\t\\thead.next = null;\\n\\n\\t\\treturn copyHead;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 883252,
                "title": "python-o-n-solution-explained",
                "content": "What we need to do in this problem is to find `k`-th element from the end, cut list in two parts and put second part after the first one. Let us do in it several steps:\\n\\n1. Find `n`, length of our list, just traverse it until we reached end.\\n2. If `k % n == 0`, we do not need to rotate list, so return it as it is.\\n3. Find element where we need to cut our list: it has number `n - k%n`, but we need to cut previous connection, so we stop one element earlier.\\n4. Finally, put new head as `middle.next`, make connection between head and tail of original ist and remove connection between `middle` and its next, return new head.\\n\\n**Complexity** is `O(n)` for time: we traverse our list twice at most; space complexity is `O(1)`, we did not use any additional space.\\n\\n```\\nclass Solution:\\n    def rotateRight(self, head, k):\\n        if not head or not head.next: return head\\n        \\n        last, n = head, 1\\n        while last.next:\\n            last = last.next\\n            n += 1\\n            \\n        if k % n == 0: return head\\n        \\n        middle = head\\n        for i in range(n - k%n-1):\\n            middle = middle.next\\n            \\n        new_head = middle.next\\n        last.next = head\\n        middle.next = None\\n        return new_head\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rotateRight(self, head, k):\\n        if not head or not head.next: return head\\n        \\n        last, n = head, 1\\n        while last.next:\\n            last = last.next\\n            n += 1\\n            \\n        if k % n == 0: return head\\n        \\n        middle = head\\n        for i in range(n - k%n-1):\\n            middle = middle.next\\n            \\n        new_head = middle.next\\n        last.next = head\\n        middle.next = None\\n        return new_head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1838907,
                "title": "python-visual-easy-to-understand-o-n-time-o-1-space",
                "content": "\\uD83D\\uDD3A**Please UPVOTE: Can we hit 20?**  \\uD83D\\uDD3A\\n\\n**Approach**\\nHere we modify the linked list in place by visiting the last node and then moving a certain number of nodes to find the new head of the linked list. The example below shows a visual of the algorithm working on the given example [1,2,3,4,5] k=2.\\n\\n![image](https://assets.leetcode.com/users/images/ea4cb812-2bf2-4246-955d-71521ebd787d_1646980729.443265.png)\\n\\n\\n\\n**Code**\\nSee the code below related to the visual above.\\n\\n<iframe src=\"https://leetcode.com/playground/WwHR5WaM/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>\\n\\n\\t\\nHope you enjoyed! Please leave a comment if anything is missed. Thanks!\\n\\uD83D\\uDD3A**Please UPVOTE: Can we hit 20?**  \\uD83D\\uDD3A",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "\\uD83D\\uDD3A**Please UPVOTE: Can we hit 20?**  \\uD83D\\uDD3A\\n\\n**Approach**\\nHere we modify the linked list in place by visiting the last node and then moving a certain number of nodes to find the new head of the linked list. The example below shows a visual of the algorithm working on the given example [1,2,3,4,5] k=2.\\n\\n![image](https://assets.leetcode.com/users/images/ea4cb812-2bf2-4246-955d-71521ebd787d_1646980729.443265.png)\\n\\n\\n\\n**Code**\\nSee the code below related to the visual above.\\n\\n<iframe src=\"https://leetcode.com/playground/WwHR5WaM/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>\\n\\n\\t\\nHope you enjoyed! Please leave a comment if anything is missed. Thanks!\\n\\uD83D\\uDD3A**Please UPVOTE: Can we hit 20?**  \\uD83D\\uDD3A",
                "codeTag": "Unknown"
            },
            {
                "id": 883486,
                "title": "simple-clean-c-code-with-comments",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if (head == nullptr || head->next == nullptr) {\\n            return head;\\n        }\\n        auto iter = head;\\n        auto len = 1;\\n        while (iter->next != nullptr) {\\n            iter = iter->next; ++len;\\n        }\\n        // close the list (create a ring)\\n        iter->next = head;\\n        iter = head;\\n        // find one element before the new head\\n        for (int i = 0; i < len - (k % len) - 1; ++i) {\\n            iter = iter->next;\\n        }\\n        head = iter->next;\\n        // open the list (break the ring)\\n        iter->next = nullptr;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if (head == nullptr || head->next == nullptr) {\\n            return head;\\n        }\\n        auto iter = head;\\n        auto len = 1;\\n        while (iter->next != nullptr) {\\n            iter = iter->next; ++len;\\n        }\\n        // close the list (create a ring)\\n        iter->next = head;\\n        iter = head;\\n        // find one element before the new head\\n        for (int i = 0; i < len - (k % len) - 1; ++i) {\\n            iter = iter->next;\\n        }\\n        head = iter->next;\\n        // open the list (break the ring)\\n        iter->next = nullptr;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22842,
                "title": "97-63-python-solution",
                "content": "    class Solution(object):\\n    def rotateRight(self, head, k):\\n        \"\"\"\\n        :type head: ListNode\\n        :type k: int\\n        :rtype: ListNode\\n        \"\"\"\\n        if not head:\\n            return None\\n        \\n        if head.next == None:\\n            return head\\n            \\n        pointer = head\\n        length = 1\\n        \\n        while pointer.next:\\n            pointer = pointer.next\\n            length += 1\\n        \\n        rotateTimes = k%length\\n        \\n        if k == 0 or rotateTimes == 0:\\n            return head\\n        \\n        fastPointer = head\\n        slowPointer = head\\n        \\n        for a in range (rotateTimes):\\n            fastPointer = fastPointer.next\\n        \\n        \\n        while fastPointer.next:\\n            slowPointer = slowPointer.next\\n            fastPointer = fastPointer.next\\n        \\n        temp = slowPointer.next\\n        \\n        slowPointer.next = None\\n        fastPointer.next = head\\n        head = temp\\n        \\n        return head",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n    def rotateRight(self, head, k):\\n        \"\"\"\\n        :type head: ListNode\\n        :type k: int\\n        :rtype: ListNode\\n        \"\"\"\\n        if not head:\\n            return None\\n        \\n        if head.next == None:\\n            return head\\n            \\n        pointer = head\\n        length = 1\\n        \\n        while pointer.next:\\n            pointer = pointer.next\\n            length += 1\\n        \\n        rotateTimes = k%length\\n        \\n        if k == 0 or rotateTimes == 0:\\n            return head\\n        \\n        fastPointer = head\\n        slowPointer = head\\n        \\n        for a in range (rotateTimes):\\n            fastPointer = fastPointer.next\\n        \\n        \\n        while fastPointer.next:\\n            slowPointer = slowPointer.next\\n            fastPointer = fastPointer.next\\n        \\n        temp = slowPointer.next\\n        \\n        slowPointer.next = None\\n        fastPointer.next = head\\n        head = temp\\n        \\n        return head",
                "codeTag": "Java"
            },
            {
                "id": 923222,
                "title": "java-0ms-faster-than-100-submissions-with-explanation",
                "content": "We can optimize the solution by finding (n-k)th element which is going to be the starting element. First we find the length of the list as n and make the list as a circular linked list. So to perform rotation on linked list, we first find (n-k-1)th element whose next element would be (n-k). Now set (n-k) as result(or head) and (n-k-1)\\'s next as null to break the loop of circular linked list. \\n![image](https://assets.leetcode.com/users/images/74e6013e-d76a-45df-beed-9168dfa854b8_1604495855.260614.png)\\n\\n\\n\\n\\n```\\npublic ListNode rotateRight(ListNode head, int k) {\\n        ListNode dummy = head;\\n        //for empty or list with 1 node return them as such         \\n        if(head == null || head.next == null)\\n            return head;\\n\\t\\t//length starts from 1 to include last element\\n        int n = 1;\\n\\t\\t//goes until last element\\n        while(dummy.next!=null){\\n            dummy = dummy.next;\\n            n++;\\n        }\\n        //Set the last node to head to form circular linked list\\n        dummy.next = head;\\n        dummy = head;\\n        // Rotating n*a times would just give the same linked list so remove them\\n        k = k%n;\\n        //  Since we rotate right we have to find the (n-k)th element which is the head      \\n        for(int i = 0;i<n-k-1;i++){\\n            dummy = dummy.next;\\n        }\\n        //Break the cycle by keeping head as (n-k) and setting (n-k-1)th element as tail\\n        head = dummy.next;\\n        dummy.next = null;\\n        return head;\\n    }\\n```\\n**P.S. Do upvote if you like this solution.**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic ListNode rotateRight(ListNode head, int k) {\\n        ListNode dummy = head;\\n        //for empty or list with 1 node return them as such         \\n        if(head == null || head.next == null)\\n            return head;\\n\\t\\t//length starts from 1 to include last element\\n        int n = 1;\\n\\t\\t//goes until last element\\n        while(dummy.next!=null){\\n            dummy = dummy.next;\\n            n++;\\n        }\\n        //Set the last node to head to form circular linked list\\n        dummy.next = head;\\n        dummy = head;\\n        // Rotating n*a times would just give the same linked list so remove them\\n        k = k%n;\\n        //  Since we rotate right we have to find the (n-k)th element which is the head      \\n        for(int i = 0;i<n-k-1;i++){\\n            dummy = dummy.next;\\n        }\\n        //Break the cycle by keeping head as (n-k) and setting (n-k-1)th element as tail\\n        head = dummy.next;\\n        dummy.next = null;\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 22908,
                "title": "c-simple-algorithm-with-explanation",
                "content": " 1. Enumerate through the list to find the last node, count the size along the way.\\n 2. Make a loop, by connection last to first\\n 3. Get modulo of |k/size| - avoiding extra rotation\\n 4. Enumerate again *size-k* nodes\\n 5. Break the loop and return new head\\n\\ncode:\\n\\n     ListNode *rotateRight(ListNode *head, int k) \\n         {\\n            if(head == NULL || head->next == NULL||k==0) return head;\\n            \\n            ListNode* node = head;\\n            int size =1;\\n            \\n            while(node->next != NULL)\\n            {\\n                size++;\\n                node = node->next;\\n            }\\n            \\n            //loop the list\\n            node->next=head;\\n            \\n            //handle the case of k>size\\n            k = k%size;\\n            \\n            //find the node to break the loop at\\n            while(--size >= k)\\n            {\\n                node=node->next;\\n            }\\n            \\n            ListNode* first = node->next;\\n            node->next=NULL;\\n            \\n            return first;\\n        }",
                "solutionTags": [
                    "C++"
                ],
                "code": " 1. Enumerate through the list to find the last node, count the size along the way.\\n 2. Make a loop, by connection last to first\\n 3. Get modulo of |k/size| - avoiding extra rotation\\n 4. Enumerate again *size-k* nodes\\n 5. Break the loop and return new head\\n\\ncode:\\n\\n     ListNode *rotateRight(ListNode *head, int k) \\n         {\\n            if(head == NULL || head->next == NULL||k==0) return head;\\n            \\n            ListNode* node = head;\\n            int size =1;\\n            \\n            while(node->next != NULL)\\n            {\\n                size++;\\n                node = node->next;\\n            }\\n            \\n            //loop the list\\n            node->next=head;\\n            \\n            //handle the case of k>size\\n            k = k%size;\\n            \\n            //find the node to break the loop at\\n            while(--size >= k)\\n            {\\n                node=node->next;\\n            }\\n            \\n            ListNode* first = node->next;\\n            node->next=NULL;\\n            \\n            return first;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1838152,
                "title": "python3-rotate-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nFirst of all, we notice that `k` can be greater than the length of the list. In this case, rotations will be repeated. To avoid useless operations, we convert `k` as follows: `k = k % length` (if `k` is equal to the length, the k becomes 0 so we don\\'t need to rotate anything). Thus, we need to know the length of the list and also the last element to attach it to the head.  After we figure out the true `k`, we can find the node where we have to cut the list.\\n\\nTime: **O(n)** - traversing\\nSpace: **O(1)**\\n\\nRuntime: 38 ms, faster than **86.22%** of Python3 online submissions for Rotate List.\\nMemory Usage: 13.9 MB, less than **88.66%** of Python3 online submissions for Rotate List.\\n\\n```\\nclass Solution:\\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        if not head: return head\\n        \\n        zero = ListNode(next=head) # dummy node\\n        \\n        count, tail = 0, zero\\n        while tail.next:\\n            count, tail = count + 1, tail.next\\n            \\n        k = k % count\\n        if not k: return head\\n\\n        newTail = zero\\n        for _ in range(0, count - k):\\n            newTail = newTail.next\\n\\n        zero.next, tail.next, newTail.next = newTail.next, head, None\\n            \\n        return zero.next\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        if not head: return head\\n        \\n        zero = ListNode(next=head) # dummy node\\n        \\n        count, tail = 0, zero\\n        while tail.next:\\n            count, tail = count + 1, tail.next\\n            \\n        k = k % count\\n        if not k: return head\\n\\n        newTail = zero\\n        for _ in range(0, count - k):\\n            newTail = newTail.next\\n\\n        zero.next, tail.next, newTail.next = newTail.next, head, None\\n            \\n        return zero.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1838161,
                "title": "algo-explained-easy-js-97-fast-commented",
                "content": "```\\n/* \\nAlgorithm Explanation: (Image attached in comments)\\n1.  We count the total number of nodes in the list using count variable,\\n2.  Now the total rotations we have to do can be restricted to k= k % count.\\n3.  Now we move a pointer from head equal to k positions. This is necessary \\nfor the next interesting logic\\n4. Now since our ptr is k steps ahead then it will tell us the kth position from end\\ni.e we iterate until ptr.next !==null and we move our prev pointer. Once ptr.next===null\\ni.e ptr reaches the last node, out prev pointer will be exactly at the kth position from end\\nHere kth position from end is nothing but the number of k rotations\\n5. Now simply break the list after prev node. Last node i.e ptr will now point to head\\ni.e ptr.next=head, next node of prev becomes our new head and finally prev becomes our \\nlast node so prev.next=null\\n*/\\n![image](https://assets.leetcode.com/users/images/9971b712-d655-4a65-8820-5672c17d878c_1646963771.4553995.png)\\n\\nvar rotateRight = function (head, k) {\\n\\tif (!head) return head;\\n\\tlet count = 0,\\n\\t\\tptr = head;\\n\\n\\t//Step 1 of the algo, count list nodes\\n\\twhile (ptr) {\\n\\t\\tcount++;\\n\\t\\tptr = ptr.next;\\n\\t}\\n\\n\\t//Ste 2: Number of rotations are now restricted within limit\\n\\tk = k % count;\\n\\tlet prev = head;\\n\\tptr = head;\\n\\n\\t//Step 3: Moving one pointer k positions ahead\\n\\twhile (k--) {\\n\\t\\tptr = ptr.next;\\n\\t}\\n\\n\\t//Step 4: The actual magic, explained above\\n\\twhile (ptr.next) {\\n\\t\\tprev = prev.next;\\n\\t\\tptr = ptr.next;\\n\\t}\\n\\n\\t//Step 5: Simply modifying the head and last node\\n\\tptr.next = head;\\n\\thead = prev.next;\\n\\tprev.next = null;\\n\\treturn head;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/* \\nAlgorithm Explanation: (Image attached in comments)\\n1.  We count the total number of nodes in the list using count variable,\\n2.  Now the total rotations we have to do can be restricted to k= k % count.\\n3.  Now we move a pointer from head equal to k positions. This is necessary \\nfor the next interesting logic\\n4. Now since our ptr is k steps ahead then it will tell us the kth position from end\\ni.e we iterate until ptr.next !==null and we move our prev pointer. Once ptr.next===null\\ni.e ptr reaches the last node, out prev pointer will be exactly at the kth position from end\\nHere kth position from end is nothing but the number of k rotations\\n5. Now simply break the list after prev node. Last node i.e ptr will now point to head\\ni.e ptr.next=head, next node of prev becomes our new head and finally prev becomes our \\nlast node so prev.next=null\\n*/\\n![image](https://assets.leetcode.com/users/images/9971b712-d655-4a65-8820-5672c17d878c_1646963771.4553995.png)\\n\\nvar rotateRight = function (head, k) {\\n\\tif (!head) return head;\\n\\tlet count = 0,\\n\\t\\tptr = head;\\n\\n\\t//Step 1 of the algo, count list nodes\\n\\twhile (ptr) {\\n\\t\\tcount++;\\n\\t\\tptr = ptr.next;\\n\\t}\\n\\n\\t//Ste 2: Number of rotations are now restricted within limit\\n\\tk = k % count;\\n\\tlet prev = head;\\n\\tptr = head;\\n\\n\\t//Step 3: Moving one pointer k positions ahead\\n\\twhile (k--) {\\n\\t\\tptr = ptr.next;\\n\\t}\\n\\n\\t//Step 4: The actual magic, explained above\\n\\twhile (ptr.next) {\\n\\t\\tprev = prev.next;\\n\\t\\tptr = ptr.next;\\n\\t}\\n\\n\\t//Step 5: Simply modifying the head and last node\\n\\tptr.next = head;\\n\\thead = prev.next;\\n\\tprev.next = null;\\n\\treturn head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1838092,
                "title": "c-easy-to-understand-simple-short-explained",
                "content": "**61. Rotate List**\\n**KNOCKCAT**\\n\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Linked list problem with Initution.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\\n``` ```\\n[LeetCode](https://github.com/knockcat/Leetcode)         **LINK TO LEETCODE REPOSITORY**\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n``` ```\\n**EXPLANATION**\\n* To **rotate a linked list by k**, we can **first make the linked list circular**.\\n* And, **then moving k-1 steps forward from head node**, **making (k-1)th node\\u2019s next to null and make kth node as head.**\\n* Firstly **checking if list is empty** , we will **return NULL**.\\n* Second, **if list contain only node** than rotation doesn\\'t have any effect , **return head**.\\n* **Counting Number of Nodes.**\\n* Now c**onsider an eg.** Our List is \\n* **1 -> 3 -> 5 -> 5-> 8**\\n* so the **count of nodes is 5**; & **value of k given is 7**\\n* this means we have to **rotate list by 7 places**.\\n* so the list will become,\\n\\t*  8->1->3->->5->5, at **1st iteration**,\\n\\t*  **5->8->1->3->5**, at **2nd iteration**,\\n\\t*  5->5->8->1->3, at **3rd iteration**,\\n\\t*  3->5->5->8->1, at **4th iteration**,\\n\\t*  1->3->5->5->8, at **5th iteration**,\\n\\t*  8->1->3->5->5, at **6th iteration**,\\n\\t*  **5->8->1->3->5**, at **7th iteration**.\\n*  Therefore our list afte **7 rotaion is  5->8->1->3->5**.\\n*  Now  see at **7th and 2nd iteration the list is same**, so why we **need to rotate list** **when the outcome is same.**\\n*  Therefore we are taking **mod of count with k  as k = k % cnt.** this will give us the **valid minimum rotation we have to perform**.\\n* Now we will t**raverse list k times.**\\n* we will **first make list circular** and then **move the list 1 by 1 and last we will add NULL.**\\n* This process we will **repeat k times** as we have to **rotate by k places**.\\n* At last, **return head.**\\n``` ```\\n\\n**CODE WITH EXPLANATION**\\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n       \\n        ListNode *temp = head, *ptr = head;\\n        \\n\\t\\t// if  list is empty return NULL\\n        if(head == NULL)\\n            return NULL;\\n\\t\\t\\t\\n        // if  list contain 1 node return NULL\\n        if(head -> next == NULL)\\n            return head;\\n        \\n        int cnt = 1;\\n        \\n\\t\\t// counting nodes in list\\n        while(temp->next != NULL)\\n        {\\n            temp = temp -> next;\\n            cnt++;\\n        }\\n\\t\\t\\n\\t\\t// mod of k with cnt to find the minimum no of rotations.\\n        k = k % cnt;\\n        \\n        while(k--)\\n        {\\n            while(temp->next != NULL)\\n                temp = temp -> next;\\n        \\n            temp -> next = head;           //making it a circular linked list\\n\\t\\t\\t\\n\\t\\t\\t// making last node the new head\\n            head = temp;\\n            ptr = temp;\\n\\t\\t\\t\\n\\t\\t\\t// moving list values one by one\\n            while(temp -> next != head)\\n            {\\n                temp = temp -> next;\\n            }\\n            \\n\\t\\t\\t// adding NULL at end of list\\n            temp -> next = NULL;\\n\\t\\t\\t\\n            temp = ptr;\\n            \\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Linked list problem with Initution.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\n``` ```\n``` ```\n``` ```\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n       \\n        ListNode *temp = head, *ptr = head;\\n        \\n\\t\\t// if  list is empty return NULL\\n        if(head == NULL)\\n            return NULL;\\n\\t\\t\\t\\n        // if  list contain 1 node return NULL\\n        if(head -> next == NULL)\\n            return head;\\n        \\n        int cnt = 1;\\n        \\n\\t\\t// counting nodes in list\\n        while(temp->next != NULL)\\n        {\\n            temp = temp -> next;\\n            cnt++;\\n        }\\n\\t\\t\\n\\t\\t// mod of k with cnt to find the minimum no of rotations.\\n        k = k % cnt;\\n        \\n        while(k--)\\n        {\\n            while(temp->next != NULL)\\n                temp = temp -> next;\\n        \\n            temp -> next = head;           //making it a circular linked list\\n\\t\\t\\t\\n\\t\\t\\t// making last node the new head\\n            head = temp;\\n            ptr = temp;\\n\\t\\t\\t\\n\\t\\t\\t// moving list values one by one\\n            while(temp -> next != head)\\n            {\\n                temp = temp -> next;\\n            }\\n            \\n\\t\\t\\t// adding NULL at end of list\\n            temp -> next = NULL;\\n\\t\\t\\t\\n            temp = ptr;\\n            \\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066492,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n       if(!head)\\n           return NULL;\\n        int n = 1;\\n        ListNode* tail = head;\\n        while(tail->next){\\n            n++;\\n            tail = tail->next;\\n        }\\n        tail->next = head;\\n        int sz = n - k % n;\\n        for(int i = 0; i < sz; i++){\\n            tail = tail->next;\\n        }  \\n        head = tail->next;\\n        tail->next = NULL;\\n        return head;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n       if(!head)\\n           return NULL;\\n        int n = 1;\\n        ListNode* tail = head;\\n        while(tail->next){\\n            n++;\\n            tail = tail->next;\\n        }\\n        tail->next = head;\\n        int sz = n - k % n;\\n        for(int i = 0; i < sz; i++){\\n            tail = tail->next;\\n        }  \\n        head = tail->next;\\n        tail->next = NULL;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22839,
                "title": "clean-python-code",
                "content": "    class Solution(object):\\n        def rotateRight(self, head, k):\\n            n, pre, current = 0, None, head\\n            while current:\\n                pre, current = current, current.next\\n                n += 1\\n    \\n            if not n or not k % n:\\n                return head\\n    \\n            tail = head\\n            for _ in xrange(n - k % n - 1):\\n                tail = tail.next\\n    \\n            next, tail.next, pre.next = tail.next, None, head\\n            return next",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def rotateRight(self, head, k):\\n            n, pre, current = 0, None, head\\n            while current:\\n                pre, current = current, current.next\\n                n += 1\\n    \\n            if not n or not k % n:\\n                return head\\n    \\n            tail = head\\n            for _ in xrange(n - k % n - 1):\\n                tail = tail.next\\n    \\n            next, tail.next, pre.next = tail.next, None, head\\n            return next",
                "codeTag": "Java"
            },
            {
                "id": 22905,
                "title": "my-short-java-solution-with-comments",
                "content": "\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null||head.next==null||k==0) return head;\\n        \\n        //make it a cricle, break from k postion far from the head\\n        ListNode index=head; int len=1;// int len to record the length of list\\n        while(index.next!=null)\\n        {index=index.next; len++;}\\n        index.next=head;\\n        \\n        for(int i=0;i<len-k%len;i++)\\n        {\\n           index=index.next;\\n        }\\n        ListNode result=index.next;\\n        index.next=null;\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null||head.next==null||k==0) return head;\\n        \\n        //make it a cricle, break from k postion far from the head\\n        ListNode index=head; int len=1;// int len to record the length of list\\n        while(index.next!=null)\\n        {index=index.next; len++;}\\n        index.next=head;\\n        \\n        for(int i=0;i<len-k%len;i++)\\n        {\\n           index=index.next;\\n        }\\n        ListNode result=index.next;\\n        index.next=null;\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 883117,
                "title": "java-solution-with-diagrammatic-explanation-0-ms",
                "content": "**EXPLANATION**\\n\\nLet\\'s take the following list as an example:\\n\\n**Node 1** -> **Node 2** -> **Node 3** -> **Node 4** -> **Node 5**\\nwith **K = 3**\\n\\nMake the list circular first and calculate the length of the actual linear list:\\n\\n**Node 1** -> **Node 2** -> **Node 3** -> **Node 4** -> **Node 5** -> **Node 1**\\n\\n**Length = 5**\\n\\nNow, our result after **K = 3** rotations should look like this:\\n\\n**Node 3** -> **Node 4** -> **Node 5** -> **Node 1** -> **Node 2**\\n\\nThat is, we need to break the link between **Node 2** and **Node 3**, in the circular linked list, which is at position **length - K** *(5 - 3 = 2)* from the start (**head**) of the list.\\n\\nSo start traversing until **cut = length - K** from the start.  After the traversal ends, make **Node 3** the head of the linked list and make the **next** node of **curr** (here **Node 2**) equal to **null**.\\n\\n**Note: *K can be greater than the length of the list so use the modulo (%) operation before starting the rotation.***\\n\\n***Edge Cases:  (Length of list is 0 or 1) and (K is 0 or a multiple of the length of the list)**.  In either case, return **head***.\\n\\n*------Please **upvote** if you liked the solution.  Please put your doubts/queries in the comments section below.  I will try my best to answer them.------*\\n\\n```\\nclass Solution {\\n    public ListNode rotateRight (ListNode head, int k) {\\n        if (head == null)\\n            return head;\\n        ListNode curr = head;\\n        int length = 0;\\n        while (curr.next != null) {\\n            length++;\\n            curr = curr.next;\\n        }\\n        length++;\\n        if (length == 1)\\n            return head;\\n        k %= length;\\n        if (k == 0)\\n            return head;\\n        curr.next = head;\\n        curr = head;\\n        int cut = length - k;\\n        while (--cut > 0)\\n            curr = curr.next;\\n        head = curr.next;\\n        curr.next = null;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode rotateRight (ListNode head, int k) {\\n        if (head == null)\\n            return head;\\n        ListNode curr = head;\\n        int length = 0;\\n        while (curr.next != null) {\\n            length++;\\n            curr = curr.next;\\n        }\\n        length++;\\n        if (length == 1)\\n            return head;\\n        k %= length;\\n        if (k == 0)\\n            return head;\\n        curr.next = head;\\n        curr = head;\\n        int cut = length - k;\\n        while (--cut > 0)\\n            curr = curr.next;\\n        head = curr.next;\\n        curr.next = null;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839864,
                "title": "java-thought-process-explained-from-brute-force-to-optimized",
                "content": "**Brute Force Method**\\n1. Firstly, Let\\'s think about the brute force approach. \\n2. By taking a look on the problem, we can say that if simply rotate the array to right by 1 element and do this k times , then we will get the answer.  Time Complexity -> O(n * k)\\n3. Now, lets look at constraints, \\n\\t* \\tThe number of nodes in the list is in the range [0, 500].\\n\\t* \\t-100 <= Node.val <= 100\\n\\t* \\t0 <= k <= 2 * 10^9\\n4. So, if we go by the brute force method, it will take 500 * 10^9 operations in the worst case, which will not be accepted and will give TLE error. We can optimize it.\\n\\n```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if( head == null || k==0) return head;  // if list is empty or if we don\\'t have to rotate the list, return it\\n        while(k-- > 0){  // repeating k times\\n            ListNode x = head;\\n            int preValue = x.val;\\n            x = x.next; // starting from 2nd node\\n            while( x != null ){\\n                // swapping x.val with preValue\\n                int temp = x.val;  \\n                x.val = preValue;\\n                preValue = temp;\\n\\t\\t\\t\\t// iterating to next node\\n                x= x.next;\\n            }\\n            head.val = preValue; //updating 1st node value to last\\n        }\\n        return head;\\n    }\\n}\\n```\\n**Optimized Brute Force**\\n5. Update k to k % n ( i.e k modulus n)\\n* \\twhy k%n? Because if k > n, let\\'s say,  n = 5 and k = 8 , so, we have to rotate list of 5 elements 8 times, if we break down 8 , 8 = 5 + 3 .\\n* If we rotate a list of 5 elements by 5 times, the result will be same, So, if instead of rotating that 8 times we rotate it 3 times, we still get the correct answer. \\n* So, now it will take 500 * 500 operations only which is 2.5 * 10^5 operations which is still large but can be accepted.\\n\\n```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        ListNode x = head; // creating copy of head in x to iterate the list while keeping the head unchanged\\n        if( x == null || k==0) return head; // if list is empty or if we don\\'t have to rotate the list, return it\\n        int n = 1;  // counting no. of nodes in the list \\n        while( x.next != null){\\n            x = x.next;\\n            n++;\\n        }\\n        k = k% n; // updating k acc. to point 5\\n        while(k-- > 0){\\n            ListNode y = head;\\n            int preValue = y.val;\\n\\n            y = y.next; // starting from 2nd node\\n            while( y != null ){\\n                // swapping x.val with preValue\\n                int temp = y.val;  \\n                y.val = preValue;\\n                preValue = temp;\\n\\n                y= y.next;\\n            }\\n            head.val = preValue; //updating 1st node value to last\\n        }\\n        return head;\\n    }\\n}\\n```\\n\\n**A new Better Approach**\\n6. Now what we can do is that instead of changing the values, we change the structure of the List by changing the head pointer.\\n* which means that if instead of pointing to head, we point to the (n-k)th node , because after rotating it will become the first element. \\n* why (n-k)th and not kth ? because we are rotating to right, so, its kth element from last node, which is (n-k)th . If we want to rotate to left then it will be kth. E\\n* Suppose our list is like this :-   1 -> 2 -> 3 -> 4 -> 5 -> null\\n* and we need  4 -> 5-> 1 -> 2 -> 3-> null \\n* We can also see that 5 is pointing to null which is breaking the list, so we point 5 to 1 and point 3 to null, and we will return a new head pointer which is pointing to 4.\\n* So, we will get out ans with Time Complexity O(n)\\n\\n```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        ListNode x = head; // creating copy of head in x to iterate the list while keeping the head unchanged\\n        if( x == null || k==0) return head; // if list is empty or if we don\\'t have to rotate the list, return it\\n        int n = 1;  // counting no. of nodes in the list \\n        while( x.next != null){\\n            x = x.next;\\n            n++;\\n        }\\n        int i = 1;\\n        k = k%n;  // updaing k acc. to point 5\\n        if(k==0 || n==1) return head; // list will not change in this case, so just return it\\n        ListNode y = head;\\n        while( i < n-k ){\\n            y = y.next;\\n            i++;\\n        }\\n        ListNode newHead = y.next; // Creating a new head point which points to (n-k)th node\\n        y.next = null;   // pointing the (n- k-1)th node to null\\n        x.next = head; // pointing the last pointer to first node.\\n        \\n        return newHead;\\n    }\\n}\\n```\\n\\nP.S : This is the first time I am trying to post a solution with a through explanation, so please comment if you liked it, if it helped you or to give your valuable feedback and suggestions.",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if( head == null || k==0) return head;  // if list is empty or if we don\\'t have to rotate the list, return it\\n        while(k-- > 0){  // repeating k times\\n            ListNode x = head;\\n            int preValue = x.val;\\n            x = x.next; // starting from 2nd node\\n            while( x != null ){\\n                // swapping x.val with preValue\\n                int temp = x.val;  \\n                x.val = preValue;\\n                preValue = temp;\\n\\t\\t\\t\\t// iterating to next node\\n                x= x.next;\\n            }\\n            head.val = preValue; //updating 1st node value to last\\n        }\\n        return head;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        ListNode x = head; // creating copy of head in x to iterate the list while keeping the head unchanged\\n        if( x == null || k==0) return head; // if list is empty or if we don\\'t have to rotate the list, return it\\n        int n = 1;  // counting no. of nodes in the list \\n        while( x.next != null){\\n            x = x.next;\\n            n++;\\n        }\\n        k = k% n; // updating k acc. to point 5\\n        while(k-- > 0){\\n            ListNode y = head;\\n            int preValue = y.val;\\n\\n            y = y.next; // starting from 2nd node\\n            while( y != null ){\\n                // swapping x.val with preValue\\n                int temp = y.val;  \\n                y.val = preValue;\\n                preValue = temp;\\n\\n                y= y.next;\\n            }\\n            head.val = preValue; //updating 1st node value to last\\n        }\\n        return head;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        ListNode x = head; // creating copy of head in x to iterate the list while keeping the head unchanged\\n        if( x == null || k==0) return head; // if list is empty or if we don\\'t have to rotate the list, return it\\n        int n = 1;  // counting no. of nodes in the list \\n        while( x.next != null){\\n            x = x.next;\\n            n++;\\n        }\\n        int i = 1;\\n        k = k%n;  // updaing k acc. to point 5\\n        if(k==0 || n==1) return head; // list will not change in this case, so just return it\\n        ListNode y = head;\\n        while( i < n-k ){\\n            y = y.next;\\n            i++;\\n        }\\n        ListNode newHead = y.next; // Creating a new head point which points to (n-k)th node\\n        y.next = null;   // pointing the (n- k-1)th node to null\\n        x.next = head; // pointing the last pointer to first node.\\n        \\n        return newHead;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828170,
                "title": "java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are given a linked list, we are required to rotate the linked list right by k places.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly, we calculated the length of the linked list and after reaching the last node of the linked list we pointed its next to head making it a circular linked list. And then we forwarded temp k places ahead and set the head value to temp.next and then set temp.next to null. Thus, rotating the linked list to the right by k places.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || head.next==null || k==0) return head;\\n\\n        ListNode temp = head;\\n        int count = 1;\\n        while(temp.next!=null){\\n            count++;\\n            temp = temp.next;\\n        }\\n        temp.next = head;\\n        k = k % count;\\n        k = count - k;\\n        while(k!=0){\\n            temp = temp.next;\\n            k--;\\n        }\\n        head = temp.next;\\n        temp.next = null;\\n\\n        return head;\\n    }\\n}\\n```\\n![oie_CksRiTNvbciG.jpg](https://assets.leetcode.com/users/images/3a11a14a-a573-47b3-82a6-3e37ee8d32c7_1690539034.4558487.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || head.next==null || k==0) return head;\\n\\n        ListNode temp = head;\\n        int count = 1;\\n        while(temp.next!=null){\\n            count++;\\n            temp = temp.next;\\n        }\\n        temp.next = head;\\n        k = k % count;\\n        k = count - k;\\n        while(k!=0){\\n            temp = temp.next;\\n            k--;\\n        }\\n        head = temp.next;\\n        temp.next = null;\\n\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490137,
                "title": "very-easy-explantation-c-with-comments-for-better-understanding",
                "content": "class Solution {\\npublic:\\n\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        ListNode* temp = head;\\n        if(head== NULL || k == 0)\\n            return head;\\n        int n = 0;\\n        while(temp->next != NULL){\\n            temp = temp->next;\\n            n++;\\n        }\\n        temp->next = head;\\n        k = k%(n+1);  \\n        \\n        // ye isleye kia manlo linked list ka size ha 3 or app chle ho 4 bar rotate krne to vo to hum jante hi ha ji 4 bar rotate kro ya 1 bar kro agar size 3 ha to bat to same h islye koi faida nhi h 4 bar krne ka islye y line use krre h \\n        \\n        int x = n-k;\\n        \\n            // ye isleye kai h kyuki apko jump kitni bar krna h vo to pta chle app kis element ke bad sare elements ko hata ke agge lgare ho vo ye btaega ji \\n        \\n       \\n        temp = head;\\n        while(x){\\n            temp = temp->next;\\n            x--;\\n        }\\n        ListNode* head1 = temp->next ; \\n        \\n        //NULL krne se phe uske next ko store kralo kyuki abb vhi hoga apka head agar sidha apne temp ke next ko null krdia to jo value head honi chaiye vo lost oh jaegi \\n        \\n        \\n        temp->next = NULL;\\n            return head1;\\n        \\n            \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        ListNode* temp = head;\\n        if(head== NULL || k == 0)\\n            return head;\\n        int n = 0;\\n        while(temp->next != NULL){\\n            temp = temp->next;\\n            n++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1838877,
                "title": "javascript-easy-to-understand-2-solutions-detailed-explanation",
                "content": "## Core strategy\\n\\nFor this problem, in short words, we need to move the last `k` nodes to the start of the linked list. So, what we need to do is:\\n1. find the node of current tail\\n1. find the node before `k` nodes as the new tail\\n1. link the current tail to the original head\\n1. link the new tail to `null`\\n\\nBut there\\'s something else we need to take care:\\n- we don\\'t know the length of the linked list\\n- the linked list could be empty\\n- the `k` could be bigger than the length\\n- the `k` could be 0 or the multiple of the length\\n\\nSo, for step 1, we could traverse the linked list to find the current tail. And during this, we could get the length of the linked list.\\nFor step 2, we could calculate the index of that node by length and `k`, so what we need to do is traverse again.\\nFor step 3 and 4, we just need to change the value of `next` pointer.\\n\\n## With extra space\\n\\nIf we could use extra space, we may just put each node of linked list into an array. And with the length and `k`, we could easily calculate the index and get what we want. Just take care of some corner cases.\\n\\nHere\\'s a sample code from me:\\n\\n```js\\nconst rotateRight = (head, k) => {\\n  if (!head || !head.next || !k) return head;\\n  const list = [];\\n  let len = 0;\\n  // put linked list into array\\n  for (let cur = head; cur; cur = cur.next) {\\n    list[len++] = cur;\\n  }\\n  // calculate the break position\\n  const newHead = len - (k % len);\\n  if (newHead === len) return head;\\n  // change pointer\\n  list[len - 1].next = head;\\n  list[newHead - 1].next = null;\\n  return list[newHead];\\n};\\n```\\n\\n## Without extra space\\n\\nIf you don\\'t want to use extra space, then we need to traverse again to get the new tail node.\\n\\nHere\\'s a sample code from me:\\n\\n```js\\nconst rotateRight = (head, k) => {\\n  if (!head || !head.next || !k) return head;\\n  let newTail = head;\\n  let tail = head;\\n  let len = 1;\\n  // get current tail node and length of linked list\\n  while (tail.next) {\\n    tail = tail.next;\\n    ++len;\\n  }\\n  // link current tail to head\\n  tail.next = head;\\n  // get the new tail node\\n  for (let i = 1; i < len - (k % len); ++i) {\\n    newTail = newTail.next;\\n  }\\n  const ret = newTail.next;\\n  // change it into the real tail\\n  newTail.next = null;\\n  return ret;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst rotateRight = (head, k) => {\\n  if (!head || !head.next || !k) return head;\\n  const list = [];\\n  let len = 0;\\n  // put linked list into array\\n  for (let cur = head; cur; cur = cur.next) {\\n    list[len++] = cur;\\n  }\\n  // calculate the break position\\n  const newHead = len - (k % len);\\n  if (newHead === len) return head;\\n  // change pointer\\n  list[len - 1].next = head;\\n  list[newHead - 1].next = null;\\n  return list[newHead];\\n};\\n```\n```js\\nconst rotateRight = (head, k) => {\\n  if (!head || !head.next || !k) return head;\\n  let newTail = head;\\n  let tail = head;\\n  let len = 1;\\n  // get current tail node and length of linked list\\n  while (tail.next) {\\n    tail = tail.next;\\n    ++len;\\n  }\\n  // link current tail to head\\n  tail.next = head;\\n  // get the new tail node\\n  for (let i = 1; i < len - (k % len); ++i) {\\n    newTail = newTail.next;\\n  }\\n  const ret = newTail.next;\\n  // change it into the real tail\\n  newTail.next = null;\\n  return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 199470,
                "title": "javascript-easy-way",
                "content": "```javascript\\nvar rotateRight = function(head, k) {\\n  let tail = head;\\n  if (head === null) return head;\\n  let len = 1;\\n  while (tail.next) {\\n    tail = tail.next;\\n    len++;\\n  }\\n  tail.next = head;\\n  let count = len - (k % len);\\n  while (count > 0) {\\n    head = head.next;\\n    tail = tail.next;\\n    count--;\\n  }\\n  tail.next = null;\\n  return head;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar rotateRight = function(head, k) {\\n  let tail = head;\\n  if (head === null) return head;\\n  let len = 1;\\n  while (tail.next) {\\n    tail = tail.next;\\n    len++;\\n  }\\n  tail.next = head;\\n  let count = len - (k % len);\\n  while (count > 0) {\\n    head = head.next;\\n    tail = tail.next;\\n    count--;\\n  }\\n  tail.next = null;\\n  return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3172692,
                "title": "85-67-acceptable-beginner-level-js-solution-explained-with-proper-intuition-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n1. The solution uses **two pointers** to find the tail of the linked list and then creates a loop to make the rotation more efficient.\\n\\n2. After finding the new head, it breaks the loop and returns the new head.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe below code implements a solution to rotate a linked list to the right by a specified number of steps (k).\\n\\nHere\\'s how the below code works :-\\n\\n1. The code first checks if the linked list is empty or has only one node, in which case it returns the head of the list as the result.\\n\\n2. Then, it finds the tail node of the linked list and the length of the linked list.\\n\\n3.  The tail node is found by iterating through the linked list and updating the tail variable until there is no next node.\\n\\n4. Next, the code calculates the number of steps to rotate the linked list to the right. This is done by subtracting k modulo the length of the linked list from the length of the linked list.\\n\\n5. Then, the code creates a circular linked list by connecting the tail node to the head node.\\n\\n6. Finally, the code breaks the circular linked list back into a linear linked list by setting the next node of the tail node to null and returning the head node of the rotated linked list.\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n1. Here n is the number of nodes in the linked list. \\n\\n2. This is because the code iterates through the linked list to find the tail and the length of the linked list, and then iterates through the linked list again to find the new head.\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n1. Because it only uses a few pointers to keep track of the head, tail, and length of the linked list, and it doesn\\'t use any additional data structures. \\n\\n2. The solution only uses a constant amount of extra memory regardless of the size of the linked list.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} k\\n * @return {ListNode}\\n */\\n\\n\\nvar rotateRight = function(head, k) {\\n\\n    if (!head || !head.next) return head;\\n    \\n    let tail = head;\\n\\n    let length = 1;\\n    \\n    while (tail.next) {\\n\\n        tail = tail.next;\\n\\n        length++;\\n\\n    }\\n\\n    tail.next = head;\\n\\n    k = length - k % length;\\n\\n    for (let i = 0; i < k; i++) {\\n\\n    tail = tail.next;\\n\\n    head = tail.next;\\n    \\n    }\\n    \\n    tail.next = null;\\n    \\n    return head;\\n\\n};\\n\\n```\\n\\n![cat img for upvote on LC.jpeg](https://assets.leetcode.com/users/images/9e228812-daf6-4f4f-bbe8-4e4cd8039cf2_1676133046.0874872.jpeg)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} k\\n * @return {ListNode}\\n */\\n\\n\\nvar rotateRight = function(head, k) {\\n\\n    if (!head || !head.next) return head;\\n    \\n    let tail = head;\\n\\n    let length = 1;\\n    \\n    while (tail.next) {\\n\\n        tail = tail.next;\\n\\n        length++;\\n\\n    }\\n\\n    tail.next = head;\\n\\n    k = length - k % length;\\n\\n    for (let i = 0; i < k; i++) {\\n\\n    tail = tail.next;\\n\\n    head = tail.next;\\n    \\n    }\\n    \\n    tail.next = null;\\n    \\n    return head;\\n\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1912571,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n\\n    func rotateRight(_ head: ListNode?, _ k: Int) -> ListNode? {\\n        guard head?.next != nil else { return head }\\n\\n        var curr = head\\n        var len = 1\\n\\n        while curr?.next != nil {\\n            curr = curr?.next\\n            len += 1\\n        }\\n        curr?.next = head\\n\\n        for _ in 0..<(len - k % len) { curr = curr?.next }\\n\\n        var newHead = curr?.next\\n        curr?.next = nil\\n\\n        return newHead\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n\\n    func rotateRight(_ head: ListNode?, _ k: Int) -> ListNode? {\\n        guard head?.next != nil else { return head }\\n\\n        var curr = head\\n        var len = 1\\n\\n        while curr?.next != nil {\\n            curr = curr?.next\\n            len += 1\\n        }\\n        curr?.next = head\\n\\n        for _ in 0..<(len - k % len) { curr = curr?.next }\\n\\n        var newHead = curr?.next\\n        curr?.next = nil\\n\\n        return newHead\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1838477,
                "title": "c-java-easy-to-understand-iterative-simple-explanation",
                "content": "**61. Rotate List**\\n\\n##### **APPROACH -**\\n* **Take last k nodes from the end and put them at the front**\\n\\n*First calculate the length of the linked list\\nUpdate **k = k % len** for optimization\\nCreate `slow` and `fast` pointers\\nIterate to make **fast point to the last node**  and **slow to (k+1)th node from end**\\nForm the required new pointer links*\\n</br>\\n\\n##### **COMPLEXITY -**\\n* **Time Complexity : O(N)**, where N = number of nodes in the list\\n* **Space Complexity : O(1)**\\n</br>\\n\\n##### **CODE -**\\n\\n**C++**\\n```\\nclass Solution {\\n    inline int getLength(ListNode* head) {\\n        int len = 0;\\n        while(head) {\\n            len++;\\n            head = head->next;\\n        }\\n        return len;\\n    }\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head)   return head;\\n        \\n        // calculate length and update k\\n        int len = getLength(head);\\n        k = k % len;\\n        \\n        // get the required nodes\\n        ListNode *fast = head, *slow = head;\\n        while(k--)\\n            fast = fast->next;\\n        while(fast->next) {\\n            slow = slow->next;\\n            fast = fast->next;\\n        }\\n        \\n        // form the new links\\n        fast->next = head;\\n        head = slow->next;\\n        slow->next = NULL;\\n        \\n        return head;\\n    }\\n};\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    private int getLength(ListNode head) {\\n        int len = 0;\\n        while(head != null) {\\n            len++;\\n            head = head.next;\\n        }\\n        return len;\\n    }\\n    \\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head == null)   return head;\\n        \\n        // calculate length and update k\\n        int len = getLength(head);\\n        k = k % len;\\n        \\n        // get the required nodes\\n        ListNode fast = head, slow = head;\\n        while(k != 0) {\\n            fast = fast.next;\\n            k--;\\n        }\\n        while(fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        \\n        // form the new links\\n        fast.next = head;\\n        head = slow.next;\\n        slow.next = null;\\n        \\n        return head;\\n    }\\n}\\n```\\n\\n**If you found this helpful, please Upvote \\u2B06\\uFE0F**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    inline int getLength(ListNode* head) {\\n        int len = 0;\\n        while(head) {\\n            len++;\\n            head = head->next;\\n        }\\n        return len;\\n    }\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head)   return head;\\n        \\n        // calculate length and update k\\n        int len = getLength(head);\\n        k = k % len;\\n        \\n        // get the required nodes\\n        ListNode *fast = head, *slow = head;\\n        while(k--)\\n            fast = fast->next;\\n        while(fast->next) {\\n            slow = slow->next;\\n            fast = fast->next;\\n        }\\n        \\n        // form the new links\\n        fast->next = head;\\n        head = slow->next;\\n        slow->next = NULL;\\n        \\n        return head;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    private int getLength(ListNode head) {\\n        int len = 0;\\n        while(head != null) {\\n            len++;\\n            head = head.next;\\n        }\\n        return len;\\n    }\\n    \\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head == null)   return head;\\n        \\n        // calculate length and update k\\n        int len = getLength(head);\\n        k = k % len;\\n        \\n        // get the required nodes\\n        ListNode fast = head, slow = head;\\n        while(k != 0) {\\n            fast = fast.next;\\n            k--;\\n        }\\n        while(fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        \\n        // form the new links\\n        fast.next = head;\\n        head = slow.next;\\n        slow.next = null;\\n        \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630272,
                "title": "c-2-approaches",
                "content": "**Method-1 : (Effecient Approach 7ms)**\\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if (head == NULL || head->next == NULL || k == 0) return head;\\n        int len = 1;\\n        ListNode *tail = head;\\n        while (tail->next != NULL)\\n            tail = tail->next, len++;\\n\\n        /* form a circle */\\n        tail->next = head;\\n        k = k % len;\\n        for (int i = 0; i < len - k; i++)\\n            tail = tail->next;\\n            \\n        head = tail->next;\\n        tail->next = NULL;\\n        return head;\\n    }\\n};\\n```\\n**Time-Complexity : 0(n)\\nSpace-Complexity : 0(1)**\\n\\n**Method -2: (Using Vector 4ms)**\\n```\\nclass Solution {\\npublic:\\n    \\n    void reverse(vector<int>& nums, int left, int right){\\n        while(left < right){\\n            int temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left++;\\n            right--;\\n        }\\n    }\\n    \\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head || !head->next || k <= 0)  return head;\\n        \\n        vector<int> nums;\\n        ListNode* temp = head;\\n        while(temp != NULL){\\n            nums.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n        \\n        k = k % nums.size();\\n        reverse(nums, 0, nums.size()-1);\\n        reverse(nums, 0, k-1);\\n        reverse(nums, k, nums.size()-1);\\n        \\n        temp = head;\\n        int i = 0;\\n        while(temp != NULL){\\n            temp->val = nums[i++];\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```\\nTime-Complexity : 0(n)\\nSpace-Complexity : 0(n)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if (head == NULL || head->next == NULL || k == 0) return head;\\n        int len = 1;\\n        ListNode *tail = head;\\n        while (tail->next != NULL)\\n            tail = tail->next, len++;\\n\\n        /* form a circle */\\n        tail->next = head;\\n        k = k % len;\\n        for (int i = 0; i < len - k; i++)\\n            tail = tail->next;\\n            \\n        head = tail->next;\\n        tail->next = NULL;\\n        return head;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    void reverse(vector<int>& nums, int left, int right){\\n        while(left < right){\\n            int temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left++;\\n            right--;\\n        }\\n    }\\n    \\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head || !head->next || k <= 0)  return head;\\n        \\n        vector<int> nums;\\n        ListNode* temp = head;\\n        while(temp != NULL){\\n            nums.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n        \\n        k = k % nums.size();\\n        reverse(nums, 0, nums.size()-1);\\n        reverse(nums, 0, k-1);\\n        reverse(nums, k, nums.size()-1);\\n        \\n        temp = head;\\n        int i = 0;\\n        while(temp != NULL){\\n            temp->val = nums[i++];\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186709,
                "title": "short-python-solution-99-7",
                "content": "```\nclass Solution:\n    def rotateRight(self, head, k):\n        if not head:\n            return None\n        p=q=head\n        l=1\n        while p.next:\n            p=p.next\n            l+=1\n        p.next=head\n        k%=l\n        for _ in range(l-k-1):\n            q=q.next\n        ans=q.next\n        q.next=None\n        return ans\t\t\n",
                "solutionTags": [],
                "code": "class Solution:\n    def rotateRight(self, head, k):\n        p=q=head\n        l=1\n            p=p.next\n            l+=1\n        p.next=head\n        k%=l\n        for _ in range(l-k-1):\n            q=q.next\n        ans=q.next\n        q.next=None",
                "codeTag": "Java"
            },
            {
                "id": 1838527,
                "title": "java-c-best-diagramatic-explanation",
                "content": "```\\nThis ques is all about converting a single linkedlist into a circular linkedlist after rotating the nodes k times.\\nLets first understand about the k .\\n```\\nLet assume the length of the linked list given is L.\\nso,there can be 2 possible cases;\\n1-**When k < L**\\nEx: {1,2,3} k=2 Move the list after the 1st node to the front\\n\\n2-**When k > L**\\nEx: {1,2,3} k=5, In this case Move the list after 1 st node to the front.\\n\\nSo, to calculate after rotation of nodes which node to be use as the head of the node we can use the formula\\n***[ L-k%L ]*** which is valid for both the upr cases .\\n\\nNow we came to a conclusion that this conde consist of 3 major parts:\\n* Converting singly Linkedlist to a circular:-\\n         which means last nodes points toward the head of the link list\\n* Calculating the length of the Linnkedlist :-\\n         we can use a pointer `curr` in a while loop in which we will forward the curr pointer till it reaches the end of              the list and every time it moves forward we store it in a `count` variable which give us the length\\n* Calculating  `k=Count -(k %Count)` \\n* Rotate the nodes;\\n\\n```\\nLet\\'s understand it visually :-\\n```\\n\\n![image](https://assets.leetcode.com/users/images/7b371609-3a96-4f58-b17d-b7495bb75ca8_1646973846.1428955.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/0044ac8a-f761-45c7-a971-6dedd4c1110c_1646974034.2282662.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/91b1f303-4668-4c32-949b-3066d3b276c0_1646974086.2907307.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/fac99020-40bf-4d3a-9cdb-da5fcca55da0_1646974132.3556378.jpeg)\\n\\n***SO , LETS CODE IT ***\\n\\n***JAVA***\\n\\n```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        // Base Condition OR edge case\\n        if(head == null || head.next == null || k == 0) return head;\\n        \\n        ListNode curr = head; // pointer current\\n        int count = 1; // here count is length\\n        while(curr.next != null){ // reach end of list, and have the count\\n            count++;\\n            curr = curr.next;\\n        }\\n        curr.next = head; // connect last node to head node to make it circular\\n        k = count - (k % count); // get the length\\n        while(k--> 0) curr = curr.next; // now move pointer, to the kth node\\n        head = curr.next; // make the head \\n        curr.next = null; // and point that curr to null\\n        \\n        return head;\\n    }\\n}\\n```\\n\\n***C++***\\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head == NULL || head->next == NULL || k == 0) return head;\\n        \\n        ListNode *curr = head;\\n        int count = 1;\\n        while(curr->next != NULL){\\n            count++;\\n            curr = curr->next;\\n        }\\n        curr->next = head;\\n        k = count - (k % count);\\n        while(k--> 0) curr = curr->next;\\n        head = curr->next;\\n        curr->next = NULL;\\n        \\n        return head;\\n    }\\n};\\n```\\n<hr>\\n<hr>\\n\\nANALYSIS\\n* **Time Complexity :-** O( N - ( N % K )) = O(N)\\n\\n\\n* **Space Complexity :-** O(1)\\n\\n\\n<hr>\\n<hr>\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nThis ques is all about converting a single linkedlist into a circular linkedlist after rotating the nodes k times.\\nLets first understand about the k .\\n```\n```\\nLet\\'s understand it visually :-\\n```\n```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        // Base Condition OR edge case\\n        if(head == null || head.next == null || k == 0) return head;\\n        \\n        ListNode curr = head; // pointer current\\n        int count = 1; // here count is length\\n        while(curr.next != null){ // reach end of list, and have the count\\n            count++;\\n            curr = curr.next;\\n        }\\n        curr.next = head; // connect last node to head node to make it circular\\n        k = count - (k % count); // get the length\\n        while(k--> 0) curr = curr.next; // now move pointer, to the kth node\\n        head = curr.next; // make the head \\n        curr.next = null; // and point that curr to null\\n        \\n        return head;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head == NULL || head->next == NULL || k == 0) return head;\\n        \\n        ListNode *curr = head;\\n        int count = 1;\\n        while(curr->next != NULL){\\n            count++;\\n            curr = curr->next;\\n        }\\n        curr->next = head;\\n        k = count - (k % count);\\n        while(k--> 0) curr = curr->next;\\n        head = curr->next;\\n        curr->next = NULL;\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 883159,
                "title": "rotate-list-java-c-o-n",
                "content": "\\nTime: O(N) \\nSpace O(1)\\n\\nIf you like it, please upvote it. Thanks.\\n\\nJava\\n```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        // handle special case length is 0 or 1\\n        if (head == null || head.next == null) return head;\\n\\n        // calculate list length\\n\\t\\t// we also need to find the tail node and point it to head at the end\\n        int length = 1;\\n        ListNode tail = head;\\n        while (tail.next != null)\\n        {\\n            tail = tail.next;\\n            length ++;\\n        }\\n        \\n        //calcualte k so rotate at most length-1 steps\\n        k = k % length;\\n        if (k == 0) return head;\\n        \\n\\t\\t//split the list to two lists.\\n        ListNode newHead = head;\\n        ListNode newTail = head;; \\n        while (length > k)\\n        {\\n            newTail = newHead;\\n            newHead = newHead.next;\\n            length --;\\n        }\\n        newTail.next = null;\\n        tail.next = head;\\n        return newHead;\\n    }\\n}\\n```\\n\\nC++\\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        // handle special case length is 0 or 1\\n        if (head == nullptr || head->next == nullptr) return head;\\n\\n        // calculate list length\\n\\t\\t// we also need to find the tail node and point it to head at the end\\n        int length = 1;\\n        ListNode* tail = head;\\n        while (tail->next != nullptr)\\n        {\\n            tail = tail->next;\\n            length ++;\\n        }\\n        \\n        //calcualte k so rotate at most length-1 steps\\n        k = k % length;\\n        if (k == 0) return head;\\n        \\n\\t\\t//split the list to two lists.\\n        ListNode* newHead = head;\\n        ListNode* newTail = head;; \\n        while (length > k)\\n        {\\n            newTail = newHead;\\n            newHead = newHead->next;\\n            length --;\\n        }\\n        newTail->next = nullptr;\\n        tail->next = head;\\n        return newHead;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        // handle special case length is 0 or 1\\n        if (head == null || head.next == null) return head;\\n\\n        // calculate list length\\n\\t\\t// we also need to find the tail node and point it to head at the end\\n        int length = 1;\\n        ListNode tail = head;\\n        while (tail.next != null)\\n        {\\n            tail = tail.next;\\n            length ++;\\n        }\\n        \\n        //calcualte k so rotate at most length-1 steps\\n        k = k % length;\\n        if (k == 0) return head;\\n        \\n\\t\\t//split the list to two lists.\\n        ListNode newHead = head;\\n        ListNode newTail = head;; \\n        while (length > k)\\n        {\\n            newTail = newHead;\\n            newHead = newHead.next;\\n            length --;\\n        }\\n        newTail.next = null;\\n        tail.next = head;\\n        return newHead;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        // handle special case length is 0 or 1\\n        if (head == nullptr || head->next == nullptr) return head;\\n\\n        // calculate list length\\n\\t\\t// we also need to find the tail node and point it to head at the end\\n        int length = 1;\\n        ListNode* tail = head;\\n        while (tail->next != nullptr)\\n        {\\n            tail = tail->next;\\n            length ++;\\n        }\\n        \\n        //calcualte k so rotate at most length-1 steps\\n        k = k % length;\\n        if (k == 0) return head;\\n        \\n\\t\\t//split the list to two lists.\\n        ListNode* newHead = head;\\n        ListNode* newTail = head;; \\n        while (length > k)\\n        {\\n            newTail = newHead;\\n            newHead = newHead->next;\\n            length --;\\n        }\\n        newTail->next = nullptr;\\n        tail->next = head;\\n        return newHead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1838171,
                "title": "c-iterative-2-approaches",
                "content": "**Approach - 1 Basic**\\n```\\n1.Make a for loop , Each time go to the last second node and make last node as head\\n\\nhow to do -->\\n1. Calculate the length of linked list\\n2. take the mod of k with length as k is very large and if k > n its same as list rotating k/n + k%n\\n times which is same as k%n times\\n```\\n**TC - O(n^2)** -- as we can rotate the whole linked list this is worst\\n**CODE**\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        // if head is null or head next is null \\n        if(head == NULL || head->next == NULL){\\n            return head;\\n        }\\n        \\n        // calculating length and taking mod of k with n\\n        ListNode * temp = head;\\n        int length =0;\\n        while(temp!= NULL){\\n            temp = temp->next;\\n            length++;\\n        }\\n        if ( k%length == 0){\\n            return head;\\n        }\\n        int n ;\\n        n = k%length;\\n        \\n        \\n        // each time loop goes to last second element and attached it to head\\n        for(int i = 1 ; i <= n ; i++ ){\\n            temp = head;\\n            while(temp->next->next!=NULL){\\n                temp = temp->next;\\n            }\\n            temp->next->next = head;\\n            head = temp->next;\\n            temp->next = NULL;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```\\n\\n**Approach 2**\\n```\\n1. Take a temp pointer taking it to node which is (length - k)th node\\n2. Point the end of linked list to head and next of temp as NULL\\n```\\n\\n**Example**\\n```\\nk = 2\\nMake another pointer  p\\ntake temp to length - k\\n1-->2-->3-->4-->5\\nt,p\\n1-->2-->3-->4-->5\\n   t,p\\n1-->2-->3-->4-->5\\n       t,p\\n1-->2-->3-->4-->5\\n         t  p\\n1-->2-->3-->4-->5\\n        t       p\\n\\t\\t\\n\\t\\t\\n4-->5-->1--->2--->3\\n\\n```\\n\\n**TC - O(n)**\\n\\n**CODE**\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        // if head is null or head next is null \\n        if(head == NULL || head->next == NULL){\\n            return head;\\n        }\\n        \\n        // calculating length and taking mod of k with n\\n        ListNode * temp = head;\\n        int length =0;\\n        while(temp!= NULL){\\n            temp = temp->next;\\n            length++;\\n        }\\n        if ( k%length == 0){\\n            return head;\\n        }\\n        int n ;\\n        n = k%length;\\n        \\n        \\n        \\n        ListNode* temp1 = head;\\n        ListNode * temp2 = head;\\n        \\n        \\n        \\n        for(int i = 1 ; i < (length-n) ; i++){\\n            temp1 = temp1->next;\\n            temp2 = temp2->next;\\n        }\\n        while(temp1->next != NULL){\\n            temp1 = temp1->next;\\n            \\n        }\\n        temp1->next = head;\\n        head = temp2->next;\\n        temp2->next = NULL;\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\n1.Make a for loop , Each time go to the last second node and make last node as head\\n\\nhow to do -->\\n1. Calculate the length of linked list\\n2. take the mod of k with length as k is very large and if k > n its same as list rotating k/n + k%n\\n times which is same as k%n times\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        // if head is null or head next is null \\n        if(head == NULL || head->next == NULL){\\n            return head;\\n        }\\n        \\n        // calculating length and taking mod of k with n\\n        ListNode * temp = head;\\n        int length =0;\\n        while(temp!= NULL){\\n            temp = temp->next;\\n            length++;\\n        }\\n        if ( k%length == 0){\\n            return head;\\n        }\\n        int n ;\\n        n = k%length;\\n        \\n        \\n        // each time loop goes to last second element and attached it to head\\n        for(int i = 1 ; i <= n ; i++ ){\\n            temp = head;\\n            while(temp->next->next!=NULL){\\n                temp = temp->next;\\n            }\\n            temp->next->next = head;\\n            head = temp->next;\\n            temp->next = NULL;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```\n```\\n1. Take a temp pointer taking it to node which is (length - k)th node\\n2. Point the end of linked list to head and next of temp as NULL\\n```\n```\\nk = 2\\nMake another pointer  p\\ntake temp to length - k\\n1-->2-->3-->4-->5\\nt,p\\n1-->2-->3-->4-->5\\n   t,p\\n1-->2-->3-->4-->5\\n       t,p\\n1-->2-->3-->4-->5\\n         t  p\\n1-->2-->3-->4-->5\\n        t       p\\n\\t\\t\\n\\t\\t\\n4-->5-->1--->2--->3\\n\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        // if head is null or head next is null \\n        if(head == NULL || head->next == NULL){\\n            return head;\\n        }\\n        \\n        // calculating length and taking mod of k with n\\n        ListNode * temp = head;\\n        int length =0;\\n        while(temp!= NULL){\\n            temp = temp->next;\\n            length++;\\n        }\\n        if ( k%length == 0){\\n            return head;\\n        }\\n        int n ;\\n        n = k%length;\\n        \\n        \\n        \\n        ListNode* temp1 = head;\\n        ListNode * temp2 = head;\\n        \\n        \\n        \\n        for(int i = 1 ; i < (length-n) ; i++){\\n            temp1 = temp1->next;\\n            temp2 = temp2->next;\\n        }\\n        while(temp1->next != NULL){\\n            temp1 = temp1->next;\\n            \\n        }\\n        temp1->next = head;\\n        head = temp2->next;\\n        temp2->next = NULL;\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592889,
                "title": "0-ms-easy-to-undertsand-breaking-and-re-connecting-the-list",
                "content": "```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head == null || head.next == null)\\n            return head;\\n        ListNode count = head; // counting the list size\\n        int size = 0;\\n        while(count!=null){\\n            size++;\\n            count = count.next;\\n        }\\n        k=k%size;  // adjusting number of rotations\\n        if(k == 0)\\n            return head;\\n        ListNode x = head; // setting the pointer to the position of breaking the list\\n        int a=0;\\n        while(x != null){\\n            a++;\\n            if(a == (size-k)){\\n                break;\\n            }\\n            x=x.next;\\n        }\\n        ListNode newList = new ListNode(-1); // New listnode to point the head of the answer list\\n        newList.next = x.next;                //\\n        ListNode newx = x.next;              //\\n        x.next = null;                      //\\n        while(newx.next != null){          //\\n            newx=newx.next;               //\\n        }                                //\\n        newx.next = head;               //  setting up the new list\\n        return newList.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head == null || head.next == null)\\n            return head;\\n        ListNode count = head; // counting the list size\\n        int size = 0;\\n        while(count!=null){\\n            size++;\\n            count = count.next;\\n        }\\n        k=k%size;  // adjusting number of rotations\\n        if(k == 0)\\n            return head;\\n        ListNode x = head; // setting the pointer to the position of breaking the list\\n        int a=0;\\n        while(x != null){\\n            a++;\\n            if(a == (size-k)){\\n                break;\\n            }\\n            x=x.next;\\n        }\\n        ListNode newList = new ListNode(-1); // New listnode to point the head of the answer list\\n        newList.next = x.next;                //\\n        ListNode newx = x.next;              //\\n        x.next = null;                      //\\n        while(newx.next != null){          //\\n            newx=newx.next;               //\\n        }                                //\\n        newx.next = head;               //  setting up the new list\\n        return newList.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22909,
                "title": "4ms-c-solution",
                "content": "    struct ListNode *rotateRight(struct ListNode *head, int k) {\\n        if (!head || k == 0) return head;\\n    \\n    \\tstruct ListNode* lastNode = head;\\n    \\tint n = 1;\\n    \\twhile (lastNode->next)\\n    \\t{\\n    \\t\\tlastNode = lastNode->next;\\n    \\t\\tn++;\\n    \\t}\\n    \\n    \\tk = k%n;\\t\\t\\n    \\tif (k == 0) return head;\\n    \\tk = n - k;\\n    \\n    \\tlastNode->next = head;\\n    \\tstruct ListNode *newHead = head;\\n    \\n    \\tfor (int i = 0; i < k - 1; i++)\\n    \\t\\tnewHead = newHead->next;\\n    \\t\\t\\n    \\thead = newHead->next;\\n    \\tnewHead->next = NULL;\\n    \\treturn head;\\n    }",
                "solutionTags": [],
                "code": "    struct ListNode *rotateRight(struct ListNode *head, int k) {\\n        if (!head || k == 0) return head;\\n    \\n    \\tstruct ListNode* lastNode = head;\\n    \\tint n = 1;\\n    \\twhile (lastNode->next)\\n    \\t{\\n    \\t\\tlastNode = lastNode->next;\\n    \\t\\tn++;\\n    \\t}\\n    \\n    \\tk = k%n;\\t\\t\\n    \\tif (k == 0) return head;\\n    \\tk = n - k;\\n    \\n    \\tlastNode->next = head;\\n    \\tstruct ListNode *newHead = head;\\n    \\n    \\tfor (int i = 0; i < k - 1; i++)\\n    \\t\\tnewHead = newHead->next;\\n    \\t\\t\\n    \\thead = newHead->next;\\n    \\tnewHead->next = NULL;\\n    \\treturn head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3772637,
                "title": "easy-java-solution-beats-100-clean-code-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        \\n        if(head == null) {\\n            return head;\\n        }\\n\\n        int length = 1;\\n        ListNode tail = head;\\n\\n        while(tail.next != null) {\\n            tail = tail.next;\\n            length++;\\n        }\\n\\n        int rotations = k % length;\\n        int newLastIndex = length - rotations;\\n\\n        if(rotations == 0) {\\n            return head;\\n        }\\n\\n        ListNode newLastNode = head;\\n        \\n        while(newLastIndex > 1) {\\n            newLastNode = newLastNode.next;\\n            newLastIndex--;\\n        }\\n\\n        ListNode newHead = newLastNode.next;\\n        newLastNode.next = null;\\n        tail.next = head;\\n        head = newHead;\\n\\n        return head;\\n    }\\n}\\n```\\n\\n![cat.jpeg](https://assets.leetcode.com/users/images/947f4334-522b-4a30-a0cc-389cc044ab13_1689496489.2165964.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        \\n        if(head == null) {\\n            return head;\\n        }\\n\\n        int length = 1;\\n        ListNode tail = head;\\n\\n        while(tail.next != null) {\\n            tail = tail.next;\\n            length++;\\n        }\\n\\n        int rotations = k % length;\\n        int newLastIndex = length - rotations;\\n\\n        if(rotations == 0) {\\n            return head;\\n        }\\n\\n        ListNode newLastNode = head;\\n        \\n        while(newLastIndex > 1) {\\n            newLastNode = newLastNode.next;\\n            newLastIndex--;\\n        }\\n\\n        ListNode newHead = newLastNode.next;\\n        newLastNode.next = null;\\n        tail.next = head;\\n        head = newHead;\\n\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430870,
                "title": "easy-cpp-step-wise-explanation",
                "content": "# Description\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to rotate the linked list k time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nCheck if the linked list is empty or has only one node. If true, return the linked list as it is.\\n\\nCount the total number of nodes in the linked list using a while loop.\\n\\nIf the given value of k is greater than the total number of nodes, find the remainder of k divided by the total number of nodes.\\n\\nIf the remainder is 0, it means that there is no need to rotate the linked list as the new linked list would be the same as the original linked list. Return the original linked list.\\n\\nIf the remainder is not 0, set k to the remainder value.\\nCalculate the index of the node up to which the linked list has to be rotated, using the formula cnt - k where cnt is the total number of nodes in the linked list.\\n\\nTraverse the linked list till the node at the calculated index.\\nStore the next node of the node at the calculated index in a temporary variable and set the next of this node to NULL.\\n\\nTraverse the temporary node till the last node of the linked list.\\nSet the next of the last node of the linked list to the original head of the linked list.\\n\\nReturn the temporary node, which is the new head of the rotated linked list.\\n\\nThe overall logic of the code is to rotate the linked list to the right by k nodes.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n        int cnt = 1;\\n        ListNode* temp = head;\\n        while(temp->next!=NULL)\\n        {\\n            temp=temp->next;\\n            cnt++;\\n        }\\n        \\n          k=k%cnt;\\n          if(k==0) return head;\\n\\n        temp->next = head;\\n        \\n        int res = cnt - k;\\n        temp = head;\\n        int i=1;\\n        while(i<res)\\n        {\\n            temp=temp->next;\\n            i++;\\n        }\\n        ListNode* prev = temp->next;\\n        temp->next = NULL;\\n        return prev;\\n    }\\n};\\n```\\n![PLEASE UPVOTE.jpg](https://assets.leetcode.com/users/images/9edd6e7c-23ce-4cf2-9d7c-c2e9475d16e1_1681820118.7475502.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n        int cnt = 1;\\n        ListNode* temp = head;\\n        while(temp->next!=NULL)\\n        {\\n            temp=temp->next;\\n            cnt++;\\n        }\\n        \\n          k=k%cnt;\\n          if(k==0) return head;\\n\\n        temp->next = head;\\n        \\n        int res = cnt - k;\\n        temp = head;\\n        int i=1;\\n        while(i<res)\\n        {\\n            temp=temp->next;\\n            i++;\\n        }\\n        ListNode* prev = temp->next;\\n        temp->next = NULL;\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793419,
                "title": "c-o-n-t-c-and-o-1-s-c",
                "content": "```\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        int c=0;\\n        ListNode *A=head;\\n        if(A==NULL || A->next==NULL || k==0) return A;\\n        while(A)\\n        {\\n            c++;\\n            A=A->next;\\n        }\\n        k=k%c;\\n        if(k==0)return head;\\n        k=c-k;\\n        int n=0;\\n        A=head;\\n        ListNode * x,*y,*prv=NULL;\\n        cout<<k<<endl;\\n        while(A)\\n        {\\n            n++;\\n            if(n==k)\\n            {\\n                y=A;\\n                x=A->next;\\n            }\\n            prv=A;\\n            A=A->next;\\n        }\\n        y->next=NULL;\\n        prv->next=head;\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        int c=0;\\n        ListNode *A=head;\\n        if(A==NULL || A->next==NULL || k==0) return A;\\n        while(A)\\n        {\\n            c++;\\n            A=A->next;\\n        }\\n        k=k%c;\\n        if(k==0)return head;\\n        k=c-k;\\n        int n=0;\\n        A=head;\\n        ListNode * x,*y,*prv=NULL;\\n        cout<<k<<endl;\\n        while(A)\\n        {\\n            n++;\\n            if(n==k)\\n            {\\n                y=A;\\n                x=A->next;\\n            }\\n            prv=A;\\n            A=A->next;\\n        }\\n        y->next=NULL;\\n        prv->next=head;\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1259556,
                "title": "javascript-time-o-n-space-o-1",
                "content": "```\\nvar rotateRight = function(head, k){\\n    //find the length\\n    let length = 1 \\n    let pt = head\\n    while(pt && pt.next){\\n          length++\\n          pt = pt.next \\n          }\\n    \\n    //we\\'re using modulo for the edge case of if the length is smaller than k\\n    k = k % length \\n    \\n    //edge case -> if k is 0, we don\\'t need a rotation\\n    if(k === 0){\\n        return head \\n    } \\n    \\n    //find the new tail\\n    let newTail = head\\n    let spaces = length - k \\n    while(spaces > 1){\\n        spaces--\\n        newTail = newTail.next  \\n          }\\n    \\n    //save the new head and reset appropriately \\n    let newHead = newTail.next \\n    newTail.next = null\\n    pt.next = head\\n    return newHead  \\n}\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rotateRight = function(head, k){\\n    //find the length\\n    let length = 1 \\n    let pt = head\\n    while(pt && pt.next){\\n          length++\\n          pt = pt.next \\n          }\\n    \\n    //we\\'re using modulo for the edge case of if the length is smaller than k\\n    k = k % length \\n    \\n    //edge case -> if k is 0, we don\\'t need a rotation\\n    if(k === 0){\\n        return head \\n    } \\n    \\n    //find the new tail\\n    let newTail = head\\n    let spaces = length - k \\n    while(spaces > 1){\\n        spaces--\\n        newTail = newTail.next  \\n          }\\n    \\n    //save the new head and reset appropriately \\n    let newHead = newTail.next \\n    newTail.next = null\\n    pt.next = head\\n    return newHead  \\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 888503,
                "title": "pyhton-easy-to-understand-i-promise-o-n-time-complexity",
                "content": "```\\nclass Solution(object):\\n    def rotateRight(self, head, k):\\n        \"\"\"\\n        :type head: ListNode\\n        :type k: int\\n        :rtype: ListNode\\n        \"\"\"\\n        #if no head, return head\\n        \\n        if not head:\\n            return head\\n        \\n        #make the tail point to the last node while calculating the length of LL\\n        #calculate relative position of k as 0 < k < infinity\\n        #if k is found to have value 0, then return the head as is\\n        \\n        length = 1\\n        tail = head\\n        \\n        while tail.next:\\n            tail = tail.next\\n            length += 1\\n        \\n        k %= length\\n        \\n        if k == 0:\\n            return head\\n        \\n        #new head will always start from length - k\\n        #attach tail->next to head and find new head now relative to tail position \\n        \\n        steps_to_new_head = length - k\\n        tail.next = head\\n        \\n        while steps_to_new_head > 0:\\n            tail = tail.next\\n            steps_to_new_head -= 1\\n        \\n        #make new_head point to tail.next\\n        #and point tail->next to NULL\\n        \\n        new_head = tail.next\\n        tail.next = None\\n        \\n        return new_head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def rotateRight(self, head, k):\\n        \"\"\"\\n        :type head: ListNode\\n        :type k: int\\n        :rtype: ListNode\\n        \"\"\"\\n        #if no head, return head\\n        \\n        if not head:\\n            return head\\n        \\n        #make the tail point to the last node while calculating the length of LL\\n        #calculate relative position of k as 0 < k < infinity\\n        #if k is found to have value 0, then return the head as is\\n        \\n        length = 1\\n        tail = head\\n        \\n        while tail.next:\\n            tail = tail.next\\n            length += 1\\n        \\n        k %= length\\n        \\n        if k == 0:\\n            return head\\n        \\n        #new head will always start from length - k\\n        #attach tail->next to head and find new head now relative to tail position \\n        \\n        steps_to_new_head = length - k\\n        tail.next = head\\n        \\n        while steps_to_new_head > 0:\\n            tail = tail.next\\n            steps_to_new_head -= 1\\n        \\n        #make new_head point to tail.next\\n        #and point tail->next to NULL\\n        \\n        new_head = tail.next\\n        tail.next = None\\n        \\n        return new_head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 883826,
                "title": "c-straightforward-algorithm-with-brief-explanation-create-the-circle-then-break-it",
                "content": "**Brief Explanation**\\n* *Return if list is empty or singleton or if k is 0.*\\n* Compute the size of the list.\\n* Link the last node of the list with head. (*A circular list is created*)\\n* If k is greater than size of the list, take modulus. `k = k % size`\\n* Find the position (**p<sub>i</sub>**) from where to break the circle. `size - k % size`\\n* Mark next element (**p<sub>i+1</sub>**) the new head.\\n* Break the circle!\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if (!head || !head->next || !k) return head;\\n        \\n        auto temp = head;\\n        \\n        // Compute the size of the linked list.\\n        int size = 1;\\n        while (temp->next) {\\n            temp = temp->next;\\n            ++size;\\n        }\\n        \\n        // Circular linked list is created.\\n        temp->next = head;\\n        \\n        // If k is greater than size of the linked list then take modulus.\\n        k %= size;\\n        \\n        // Find the last node in the list after k rotations.\\n        while(--size >= k) {\\n            temp = temp->next;\\n        }\\n        \\n        // Make the next of last the new head.\\n        head = temp->next;\\n        \\n        // Break the circle.\\n        temp->next = nullptr;\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if (!head || !head->next || !k) return head;\\n        \\n        auto temp = head;\\n        \\n        // Compute the size of the linked list.\\n        int size = 1;\\n        while (temp->next) {\\n            temp = temp->next;\\n            ++size;\\n        }\\n        \\n        // Circular linked list is created.\\n        temp->next = head;\\n        \\n        // If k is greater than size of the linked list then take modulus.\\n        k %= size;\\n        \\n        // Find the last node in the list after k rotations.\\n        while(--size >= k) {\\n            temp = temp->next;\\n        }\\n        \\n        // Make the next of last the new head.\\n        head = temp->next;\\n        \\n        // Break the circle.\\n        temp->next = nullptr;\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22834,
                "title": "sharing-my-8ms-c-solution",
                "content": "    /**\\n     * 1) connect the head with the tail, and form a closed circle\\n     * 2) rotate (n-k%n) times\\n     * 3) find the new head and tail, break them apart, and return the new head\\n     */\\n     \\n    class Solution{\\n    public:\\n        ListNode* rotateRight(ListNode* head, int k) {\\n            if(head==NULL || head->next==NULL)\\n                return head;\\n                \\n            ListNode* last;\\n            int n = 1;\\n            ListNode* p = head;\\n            while(p->next)\\n            {\\n                n++;\\n                p=p->next;\\n            }\\n            p->next = head;\\n            last = p;\\n            k = k%n;\\n            k = n-k;\\n            ListNode* current = head;\\n            for(int i=0; i<k; i++)\\n            {\\n                last = current;\\n                current = current->next;\\n            }\\n            \\n            last->next = NULL;\\n            return current;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution{\\n    public:\\n        ListNode* rotateRight(ListNode* head, int k) {\\n            if(head==NULL || head->next==NULL)\\n                return head;\\n                \\n            ListNode* last;\\n            int n = 1;\\n            ListNode* p = head;\\n            while(p->next)\\n            {\\n                n++;\\n                p=p->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1838659,
                "title": "rotate-list-very-simple-and-easy-solution-c",
                "content": "****EAsy to understand solution with comments for understanding the Logic ***\\n\\n   ****PLEASE UP VOTE IF YOU THINK IT HELPS YOU !!!\\n\\n\\n```\\nListNode* rotateRight(ListNode* head, int k) {\\n        \\n        ListNode *ptr=head;\\n    // if ther is no node than just return 0\\n            if(head==NULL)\\n                return NULL;\\n        // if ther is only one node than return head;\\n           if(head->next==NULL|| k==0 )\\n                return head;\\n         ListNode *temp=head->next;\\n        // l is actually a counter for counting no. of nodes l=2 since the pointer to the linked list is placed and 2nd position  \\n            int l=2;\\n            while(temp->next!=NULL)\\n            {\\n                l++;\\n                temp=temp->next;\\n                ptr=ptr->next;\\n            }\\n        k=k%l;\\n        // if no. of nodes is equal to no. of rotation or no. of node is a multiple of no. rotation than just return head\\n        if(l==k || k==0)\\n            return head;\\n        temp->next=head;\\n        head=temp;\\n        k=k%l;\\n        \\n        int j=1;\\n        // just for no. of rotation\\n        while(j!=k)\\n        {\\n        while(ptr->next->next!=head )\\n        {\\n           ptr=ptr->next; \\n        }\\n            head=ptr->next;\\n            j++;\\n        }\\n        ptr->next=NULL;\\n        return head;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nListNode* rotateRight(ListNode* head, int k) {\\n        \\n        ListNode *ptr=head;\\n    // if ther is no node than just return 0\\n            if(head==NULL)\\n                return NULL;\\n        // if ther is only one node than return head;\\n           if(head->next==NULL|| k==0 )\\n                return head;\\n         ListNode *temp=head->next;\\n        // l is actually a counter for counting no. of nodes l=2 since the pointer to the linked list is placed and 2nd position  \\n            int l=2;\\n            while(temp->next!=NULL)\\n            {\\n                l++;\\n                temp=temp->next;\\n                ptr=ptr->next;\\n            }\\n        k=k%l;\\n        // if no. of nodes is equal to no. of rotation or no. of node is a multiple of no. rotation than just return head\\n        if(l==k || k==0)\\n            return head;\\n        temp->next=head;\\n        head=temp;\\n        k=k%l;\\n        \\n        int j=1;\\n        // just for no. of rotation\\n        while(j!=k)\\n        {\\n        while(ptr->next->next!=head )\\n        {\\n           ptr=ptr->next; \\n        }\\n            head=ptr->next;\\n            j++;\\n        }\\n        ptr->next=NULL;\\n        return head;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730890,
                "title": "beats-99-59-less-code-and-easy-to-understand-solutions-without-and-with-extra-space",
                "content": "![image](https://assets.leetcode.com/users/images/f7ace022-a799-4545-97d4-f78d9a4ee790_1643529593.6388466.png)\\n\\n\\n# First solution T O(N) and M O(1)\\nclass Solution:\\n    \\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        \\n        if not head:\\n            return None\\n        \\n        n, tail = 1, head\\n\\n        while tail.next:\\n            tail = tail.next\\n            n += 1\\n            \\n        k = k % n\\n        \\n        # k is equal or bigger than return head\\n        if k == 0:\\n            return head\\n        \\n        \\n        cur = head\\n        for i in range(n - k - 1):\\n            cur = cur.next\\n        \\n        # New head is now pivot next\\n        newHead = cur.next\\n        # piviot next after assigning new head is null\\n        cur.next = None\\n        # tail which is pointing last node is now connected to head \\n        tail.next = head\\n        # newhead is piviot point\\n        return newHead\\n        \\n# Second solution with T O(N) and M O(N)\\n\\nclass Solution:\\n\\n    def rotateRight(self, head, k):\\n\\n        if not head:\\n            return None\\n        \\n        arr = []\\n        \\n        while head:\\n            arr.append(head.val)\\n            head = head.next\\n\\n        k = k % len(arr)\\n        \\n        l, r = 0, len(arr) - 1\\n        while l < r:\\n            arr[l], arr[r] = arr[r], arr[l]\\n            l, r = l + 1, r - 1\\n            \\n        l, r = 0, k - 1\\n        while l < r:\\n            arr[l], arr[r] = arr[r], arr[l]\\n            l, r = l + 1, r - 1\\n\\n        l, r = k, len(arr) - 1\\n        while l < r:\\n            arr[l], arr[r] = arr[r], arr[l]\\n            l, r = l + 1, r - 1\\n\\n        dummy = ListNode(0)\\n        tmp = dummy\\n        \\n        for i in arr:\\n            tmp.next = ListNode(i)\\n            tmp = tmp.next\\n            \\n        return dummy.next\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Linked List"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/f7ace022-a799-4545-97d4-f78d9a4ee790_1643529593.6388466.png)\\n\\n\\n# First solution T O(N) and M O(1)\\nclass Solution:\\n    \\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        \\n        if not head:\\n            return None\\n        \\n        n, tail = 1, head\\n\\n        while tail.next:\\n            tail = tail.next\\n            n += 1\\n            \\n        k = k % n\\n        \\n        # k is equal or bigger than return head\\n        if k == 0:\\n            return head\\n        \\n        \\n        cur = head\\n        for i in range(n - k - 1):\\n            cur = cur.next\\n        \\n        # New head is now pivot next\\n        newHead = cur.next\\n        # piviot next after assigning new head is null\\n        cur.next = None\\n        # tail which is pointing last node is now connected to head \\n        tail.next = head\\n        # newhead is piviot point\\n        return newHead\\n        \\n# Second solution with T O(N) and M O(N)\\n\\nclass Solution:\\n\\n    def rotateRight(self, head, k):\\n\\n        if not head:\\n            return None\\n        \\n        arr = []\\n        \\n        while head:\\n            arr.append(head.val)\\n            head = head.next\\n\\n        k = k % len(arr)\\n        \\n        l, r = 0, len(arr) - 1\\n        while l < r:\\n            arr[l], arr[r] = arr[r], arr[l]\\n            l, r = l + 1, r - 1\\n            \\n        l, r = 0, k - 1\\n        while l < r:\\n            arr[l], arr[r] = arr[r], arr[l]\\n            l, r = l + 1, r - 1\\n\\n        l, r = k, len(arr) - 1\\n        while l < r:\\n            arr[l], arr[r] = arr[r], arr[l]\\n            l, r = l + 1, r - 1\\n\\n        dummy = ListNode(0)\\n        tmp = dummy\\n        \\n        for i in arr:\\n            tmp.next = ListNode(i)\\n            tmp = tmp.next\\n            \\n        return dummy.next\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1723555,
                "title": "easy-c-code-100-faster",
                "content": "```\\nListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next==NULL || k==0){\\n            return head;\\n        }\\n        ListNode *cur=head;\\n        int len=1;\\n        while(cur->next!=NULL){\\n            cur=cur->next;\\n            len++;\\n        }\\n        cur->next=head;\\n        k=k%len;\\n        k=len-k; \\n        \\n        while(k--){\\n            cur=cur->next;\\n        }\\n        head=cur->next;\\n        cur->next=NULL;\\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next==NULL || k==0){\\n            return head;\\n        }\\n        ListNode *cur=head;\\n        int len=1;\\n        while(cur->next!=NULL){\\n            cur=cur->next;\\n            len++;\\n        }\\n        cur->next=head;\\n        k=k%len;\\n        k=len-k; \\n        \\n        while(k--){\\n            cur=cur->next;\\n        }\\n        head=cur->next;\\n        cur->next=NULL;\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 22756,
                "title": "golang-concise-solution-using-two-pointers",
                "content": "To simplify, let's assume `k` is less than a number of ListNode first.  \\nThen we need to do is let a fast pointer move to the `k` th node first, then set a slow pointer to the head and move both slow and fast pointers until the fast pointer reach to the end.\\n\\nAs a result, we can get the situation like below:\\n```\\n+---+    +---+    +---+    +---+    +---+    +---+\\n|   +--->+   +--->+   +--->+   +--->+   +--->+   |\\n+---+    +---+    +---+    +---+    +---+    +---+\\n                   slow                       fast\\n```\\nfast is on the last node and slow is `k` th point before the fast one. So we can arrange the node like so that:\\n1. a new head is positioned at the next node of slow.\\n2. `slow.Next` should `nil`, means an end.\\n3. `fast.Next` should an original head.\\n\\nSo...remaining tricky part is when `k` is more than a length of the list. To handle this, I calculate the remaining rotation number and call another `rotateRight`.\\n\\n```\\nfunc rotateRight(head *ListNode, k int) *ListNode {\\n\\tif k == 0 || head == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\tslow, fast := head, head\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tif fast.Next == nil {\\n\\t\\t\\treturn rotateRight(head, k%(i+1))\\n\\t\\t}\\n\\t\\tfast = fast.Next\\n\\t}\\n\\n\\tfor fast.Next != nil {\\n\\t\\tslow, fast = slow.Next, fast.Next\\n\\t}\\n\\tnewHead := slow.Next\\n\\tslow.Next, fast.Next = nil, head\\n\\treturn newHead\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n+---+    +---+    +---+    +---+    +---+    +---+\\n|   +--->+   +--->+   +--->+   +--->+   +--->+   |\\n+---+    +---+    +---+    +---+    +---+    +---+\\n                   slow                       fast\\n```\n```\\nfunc rotateRight(head *ListNode, k int) *ListNode {\\n\\tif k == 0 || head == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\tslow, fast := head, head\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tif fast.Next == nil {\\n\\t\\t\\treturn rotateRight(head, k%(i+1))\\n\\t\\t}\\n\\t\\tfast = fast.Next\\n\\t}\\n\\n\\tfor fast.Next != nil {\\n\\t\\tslow, fast = slow.Next, fast.Next\\n\\t}\\n\\tnewHead := slow.Next\\n\\tslow.Next, fast.Next = nil, head\\n\\treturn newHead\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3782214,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe code starts with a helper function GetLength which recursively calculates the length of the linked list. It traverses the list until it reaches the end (NULL) and returns the count of nodes encountered.\\n\\nThe rotateRight function takes the head of the linked list and the rotation value k as input. It performs the following steps:\\n\\nCheck for base cases:\\n\\nIf the head is NULL or k is 0, return the head as no rotation is needed.\\nIf the length of the list is 1, return the head as there\\'s only one node and no rotation can be performed.\\nCalculate the length of the list by calling the GetLength helper function.\\n\\nAdjust k to be within the range of the list length by taking the modulus (k % length).\\n\\nPerform the rotation k % length times:\\n\\nStart a loop from 0 to k % length - 1.\\nInitialize a pointer p to the head of the list.\\nTraverse the list until p reaches the second-to-last node (p->next->next == NULL).\\nCreate a new node a using dynamic memory allocation (malloc) and assign the value of the last node (p->next->val) to it.\\nSet the next pointer of a to the current head of the list (a->next = head).\\nUpdate the head to be the new node a (head = a).\\nSet the next pointer of the second-to-last node (p->next) to NULL to disconnect the last node from the list.\\nReturn the new head of the rotated list.\\n\\nThe time complexity of the code is O(n), where n is the length of the linked list. This is because we traverse the list twice: once to calculate the length and again to perform the rotation. The space complexity is O(1) as we are using a constant amount of additional space for the pointers and variables.\\n\\n\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n int GetLength(struct ListNode* head)\\n{\\n\\tif (head == NULL)\\n\\t\\treturn 0;\\n\\n\\treturn 1 + GetLength(head->next);\\n}\\nstruct ListNode* rotateRight(struct ListNode* head, int k){\\n        if (head == NULL || k == 0)\\n\\t\\treturn head;\\n    int length = GetLength(head);\\n\\n\\tif (length == 1)\\n\\t\\treturn head;\\n    for(int i=0;i<k%length;i++)\\n    {\\n        struct ListNode *p=head;\\n        while(p->next->next!=NULL)\\n        {\\n            p=p->next;\\n        }\\n        struct ListNode *a=(struct ListNode *)malloc(sizeof(struct ListNode));\\n        a->val=p->next->val;\\n        a->next=head;\\n        head=a;\\n        p->next=NULL;\\n    }\\n    return head;\\n\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n int GetLength(struct ListNode* head)\\n{\\n\\tif (head == NULL)\\n\\t\\treturn 0;\\n\\n\\treturn 1 + GetLength(head->next);\\n}\\nstruct ListNode* rotateRight(struct ListNode* head, int k){\\n        if (head == NULL || k == 0)\\n\\t\\treturn head;\\n    int length = GetLength(head);\\n\\n\\tif (length == 1)\\n\\t\\treturn head;\\n    for(int i=0;i<k%length;i++)\\n    {\\n        struct ListNode *p=head;\\n        while(p->next->next!=NULL)\\n        {\\n            p=p->next;\\n        }\\n        struct ListNode *a=(struct ListNode *)malloc(sizeof(struct ListNode));\\n        a->val=p->next->val;\\n        a->next=head;\\n        head=a;\\n        p->next=NULL;\\n    }\\n    return head;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3579199,
                "title": "best-o-n-solution",
                "content": "# Approach\\nOptimal Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if (head == NULL || head->next == NULL) {\\n            return head;\\n        }\\n        ListNode* dummy = head;\\n        int len = 1;\\n        while (dummy->next != NULL) {\\n            len++;\\n            dummy = dummy->next;\\n        }\\n        dummy->next = head;\\n        k = k % len;\\n        int end = len - k;\\n        dummy = head;\\n        while (end > 1) {\\n            end--;\\n            dummy = dummy->next;\\n        }\\n        head = dummy->next;\\n        dummy->next = NULL;\\n\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if (head == NULL || head->next == NULL) {\\n            return head;\\n        }\\n        ListNode* dummy = head;\\n        int len = 1;\\n        while (dummy->next != NULL) {\\n            len++;\\n            dummy = dummy->next;\\n        }\\n        dummy->next = head;\\n        k = k % len;\\n        int end = len - k;\\n        dummy = head;\\n        while (end > 1) {\\n            end--;\\n            dummy = dummy->next;\\n        }\\n        head = dummy->next;\\n        dummy->next = NULL;\\n\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446807,
                "title": "0ms-100-faster-solution-in-java-using-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n\\n        ListNode temp = new ListNode();\\n        temp = head;\\n        if(head==null || head.next==null || k==0) return head;\\n        int count = 1;\\n        while(temp.next!=null){\\n            temp = temp.next;\\n            count++;\\n        }\\n\\n        temp.next = head;\\n        k = k%count;\\n        k = count-k;\\n\\n        while(k-->0){\\n            temp = temp.next;\\n        }\\n        head = temp.next;\\n        temp.next = null;\\n        return head;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n\\n        ListNode temp = new ListNode();\\n        temp = head;\\n        if(head==null || head.next==null || k==0) return head;\\n        int count = 1;\\n        while(temp.next!=null){\\n            temp = temp.next;\\n            count++;\\n        }\\n\\n        temp.next = head;\\n        k = k%count;\\n        k = count-k;\\n\\n        while(k-->0){\\n            temp = temp.next;\\n        }\\n        head = temp.next;\\n        temp.next = null;\\n        return head;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1838726,
                "title": "simple-solution-easy-to-understand",
                "content": "\\n\\n     if(head == NULL || head->next == NULL)\\n        return head;\\n    else{\\n        struct ListNode *prev = NULL;\\n        struct ListNode *temp = NULL;\\n        temp = head;\\n        int c = 0;\\n        while(temp != NULL){\\n            c++;\\n            temp = temp->next;\\n        }\\n        k %= c;\\n    temp = head;\\n    while(k-- > 0){\\n        while(temp->next != NULL){\\n            prev = temp;\\n            temp = temp->next;\\n        }\\n        temp->next = head;\\n        prev->next = NULL;\\n        head = temp;\\n        temp = head;\\n    }\\n    return head;",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Linked List"
                ],
                "code": "\\n\\n     if(head == NULL || head->next == NULL)\\n        return head;\\n    else{\\n        struct ListNode *prev = NULL;\\n        struct ListNode *temp = NULL;\\n        temp = head;\\n        int c = 0;\\n        while(temp != NULL){\\n            c++;\\n            temp = temp->next;\\n        }\\n        k %= c;\\n    temp = head;\\n    while(k-- > 0){\\n        while(temp->next != NULL){\\n            prev = temp;\\n            temp = temp->next;\\n        }\\n        temp->next = head;\\n        prev->next = NULL;\\n        head = temp;\\n        temp = head;\\n    }\\n    return head;",
                "codeTag": "Unknown"
            },
            {
                "id": 1699839,
                "title": "c-optimized-fast-and-easy-to-understand-code-for-rotating-the-list",
                "content": "**Here\\'s the well commented code for rotating the linked list**\\n\\n```\\nListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL||head->next==NULL||k==0)                   //return head for empty list or list with single node\\n            return head;\\n        int count=1;                                             //initialize counter to find length of list with 1\\n        ListNode*cur=head;\\n        while(cur->next!=NULL){                                  //traverse till the last node of the list\\n            count++;\\n            cur=cur->next;\\n        }\\n        cur->next=head;                                          //link the last node with the first node making it a circular list\\n\\t\\t/*\\n\\t\\tNow, note the fact that after rotating the list in a multiple of its on length, it with result in\\n\\t\\tthe original list itself. So, we can do modulo arithmatic on k and reduce the number of k\\n\\t\\tto k modulus length\\n\\t\\t*/\\n        k=k%count;\\n        k=count-k;                                              //finding the position of the last node of the resulting list\\n        while(k--){                                             //traversing circular list k number of times\\n            cur=cur->next;\\n        }\\n\\t\\t//pointing new head and changing it back to linear list\\n        head=cur->next;\\n        cur->next=NULL;\\n        return head;\\n}",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "**Here\\'s the well commented code for rotating the linked list**\\n\\n```\\nListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL||head->next==NULL||k==0)                   //return head for empty list or list with single node\\n            return head;\\n        int count=1;                                             //initialize counter to find length of list with 1\\n        ListNode*cur=head;\\n        while(cur->next!=NULL){                                  //traverse till the last node of the list\\n            count++;\\n            cur=cur->next;\\n        }\\n        cur->next=head;                                          //link the last node with the first node making it a circular list\\n\\t\\t/*\\n\\t\\tNow, note the fact that after rotating the list in a multiple of its on length, it with result in\\n\\t\\tthe original list itself. So, we can do modulo arithmatic on k and reduce the number of k\\n\\t\\tto k modulus length\\n\\t\\t*/\\n        k=k%count;\\n        k=count-k;                                              //finding the position of the last node of the resulting list\\n        while(k--){                                             //traversing circular list k number of times\\n            cur=cur->next;\\n        }\\n\\t\\t//pointing new head and changing it back to linear list\\n        head=cur->next;\\n        cur->next=NULL;\\n        return head;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1684600,
                "title": "c-soln-using-vector",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int key) {\\n        if(!head || !head->next)return head;\\n        ListNode* temp = head;\\n        vector<int> order;\\n        while(temp!=NULL)order.push_back(temp->val),temp = temp->next;\\n        temp = head;\\n        int index = 0;\\n          key = key % order.size();\\n        if(key < 0)\\n         key = key + order.size();\\n   \\n   reverse(order.begin(),order.begin() + order.size() - key);\\n   reverse(order.begin() ,order.end());\\n   reverse(order.begin(),order.begin() + key);\\n        while(temp!=NULL)temp->val = order[index++],temp=temp->next;\\n        return head;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int key) {\\n        if(!head || !head->next)return head;\\n        ListNode* temp = head;\\n        vector<int> order;\\n        while(temp!=NULL)order.push_back(temp->val),temp = temp->next;\\n        temp = head;\\n        int index = 0;\\n          key = key % order.size();\\n        if(key < 0)\\n         key = key + order.size();\\n   \\n   reverse(order.begin(),order.begin() + order.size() - key);\\n   reverse(order.begin() ,order.end());\\n   reverse(order.begin(),order.begin() + key);\\n        while(temp!=NULL)temp->val = order[index++],temp=temp->next;\\n        return head;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1664174,
                "title": "my-clean-c-code-with-explanation",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head){\\n            return head;\\n        }\\n        int size = 1;\\n        //size started with one because we need to stop at temp not at temp->next\\n        ListNode* temp = head;\\n        while(temp->next){\\n            temp = temp->next;\\n            size++;\\n        }\\n        // making the list circular \\n        temp->next = head ;\\n        //making k less than the size of linked list\\n        k = k%size;\\n        // checking how many elements should be sent forward \\n        k = size-k;\\n        // running the while loop till k =0\\n         while(k--){\\n            temp = temp->next;\\n        }\\n        head = temp->next;\\n        temp->next = NULL;\\n        return head;\\n    }\\n        \\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head){\\n            return head;\\n        }\\n        int size = 1;\\n        //size started with one because we need to stop at temp not at temp->next\\n        ListNode* temp = head;\\n        while(temp->next){\\n            temp = temp->next;\\n            size++;\\n        }\\n        // making the list circular \\n        temp->next = head ;\\n        //making k less than the size of linked list\\n        k = k%size;\\n        // checking how many elements should be sent forward \\n        k = size-k;\\n        // running the while loop till k =0\\n         while(k--){\\n            temp = temp->next;\\n        }\\n        head = temp->next;\\n        temp->next = NULL;\\n        return head;\\n    }\\n        \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581632,
                "title": "c-beats-100-with-explaination",
                "content": "**Approach : We first find out the length of our linked list, here we can see that if our \"k\" value is lesser than the size of our linked list, let`s say our linked list is : 1->2->3->4->5 and \"k\" value is 2 then we append last 2 nodes at the beginning. So, our resultant linked list will become 4->5->1->2->3. In other case if our \"k\" value is greater than the length of our linked list then we only consider the (k % length) nodes from right because all the other (length=k) times rotations will simply return our original linked list. if we take our list as 1->2 and k = 3. Then after k = 1 rotations our linked list will become 2->1 and on further k=2 rotations our linked list will become 1->2(original list). Thus we will only rotate for length%k times from right. Here length =2 and k= 3, So , k % length = 1, there fore our final list will become 2->1.**\\n```\\nclass Solution {\\npublic:\\n    //Function to calculate the length of our linked list\\n    int length(ListNode *head){\\n        if(head==nullptr){\\n            return 0;\\n        }\\n        int count =1;\\n        while(head->next!=nullptr){\\n            head = head->next;\\n           count++;\\n        }\\n        return count;\\n    }\\n    ListNode* rotateRight(ListNode* head, int k) {\\n       int len = length(head);\\n       ListNode* Newhead;\\n        if(head==nullptr || len==1){\\n            return head;\\n        }\\n        k = k % len;\\n        if(k==len || k==0){\\n            return head;\\n        }\\n            int n = len-k-1;\\n            ListNode* temp = head;\\n            while(temp->next!=nullptr){\\n                temp = temp->next;\\n            }\\n            ListNode* temp1 = head;\\n            for(int i=1;i<=n;i++){\\n                temp1 = temp1->next;\\n            }\\n        Newhead = temp1->next;\\n        temp1->next = nullptr;\\n            temp->next = head;\\n         return Newhead;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    //Function to calculate the length of our linked list\\n    int length(ListNode *head){\\n        if(head==nullptr){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1319291,
                "title": "clean-and-easy-java-solution",
                "content": "class Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        \\n        if(head == null || head.next == null || k == 0) return head;\\n        \\n        ListNode curr = head;\\n        int length = 1;\\n        \\n\\t\\t// calculate the length of the LinkedList//\\n        while(curr.next != null) {\\n            curr = curr.next;\\n            length++;\\n        }\\n        \\n        curr.next = head;\\n\\t\\t// if the value of k is greater than length , we dont have to calculate that many times because if k = 5 we will end up having the same LinkedList// \\n\\t\\t//So to avoid that just modulo k with length//\\n\\t\\tk = k % length;\\n        k = length - k;\\n        while(k-->0) {\\n            curr = curr.next;\\n        }\\n\\t\\t// head->4->5 //\\n        head = curr.next;\\n\\t\\t// 1->2->3-> null //\\n        curr.next = null;\\n        \\n\\t\\t// head->4->5->1->2->3->null //\\n        return head;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        \\n        if(head == null || head.next == null || k == 0) return head;\\n        \\n        ListNode curr = head;\\n        int length = 1;\\n        \\n\\t\\t// calculate the length of the LinkedList//\\n        while(curr.next != null) {\\n            curr = curr.next;\\n            length++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4060553,
                "title": "beginner-explanation-with-diagram",
                "content": "# Intuition\\n\\n![first.jpg](https://assets.leetcode.com/users/images/db16bc4e-a758-4fdc-ad89-6643f88850b2_1695049094.776298.jpeg)\\n\\n![second.jpg](https://assets.leetcode.com/users/images/8367aa8f-e20d-4dc0-8580-e211079a0981_1695049132.0701945.jpeg)\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || head.next ==null || k==0 ) return head;\\n\\n        ListNode curr = head;\\n\\n        // step 1  -  calculate the  size of linked list\\n        int size = 1;\\n        while(curr.next!=null){\\n            size++;\\n            curr=curr.next;\\n        }\\n\\n        // step 2  -  pointer curr to head of LL\\n        \\n        curr.next = head;\\n\\n        k = k % size;\\n        k = size - k;\\n\\n        // step 3  -  move curr til k > 0 and make head to curr.next and curr.next = null;\\n\\n        while(k>0){\\n            curr=curr.next;\\n            k--;\\n        }\\n        \\n        // step - 4 \\n\\n        head=curr.next;\\n        curr.next = null;\\n\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || head.next ==null || k==0 ) return head;\\n\\n        ListNode curr = head;\\n\\n        // step 1  -  calculate the  size of linked list\\n        int size = 1;\\n        while(curr.next!=null){\\n            size++;\\n            curr=curr.next;\\n        }\\n\\n        // step 2  -  pointer curr to head of LL\\n        \\n        curr.next = head;\\n\\n        k = k % size;\\n        k = size - k;\\n\\n        // step 3  -  move curr til k > 0 and make head to curr.next and curr.next = null;\\n\\n        while(k>0){\\n            curr=curr.next;\\n            k--;\\n        }\\n        \\n        // step - 4 \\n\\n        head=curr.next;\\n        curr.next = null;\\n\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943977,
                "title": "easy-c-solution-beats-100-users-0ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head || !head->next||k==0)\\n        {\\n            return head;\\n        }\\n        ListNode* temp=head;\\n        int len=1;\\n        while(temp->next)\\n        {\\n            len++;\\n            temp=temp->next;\\n        }\\n        temp->next=head;\\n        k=k%len;\\n        k=len-k;\\n        while(k>0)\\n        {\\n            temp=temp->next;\\n            k--;\\n        }\\n        head=temp->next;\\n        temp->next=NULL;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head || !head->next||k==0)\\n        {\\n            return head;\\n        }\\n        ListNode* temp=head;\\n        int len=1;\\n        while(temp->next)\\n        {\\n            len++;\\n            temp=temp->next;\\n        }\\n        temp->next=head;\\n        k=k%len;\\n        k=len-k;\\n        while(k>0)\\n        {\\n            temp=temp->next;\\n            k--;\\n        }\\n        head=temp->next;\\n        temp->next=NULL;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800460,
                "title": "clean-c-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        // edge cases\\n        if (!head || !head->next || !k) {\\n            return head;\\n        }\\n        // dummy curr\\n        ListNode* curr = head;\\n        // finding length\\n        int len = 1;\\n        while(curr->next) {\\n            curr = curr->next;\\n            ++len;\\n        }\\n        curr->next = head;\\n        // we will traverse from start instead so take len - k instead\\n        k = k % len;\\n        k = len - k;\\n        // lets start traversing\\n        while(k--) {\\n            curr = curr->next;\\n        }\\n        head = curr->next;\\n        curr->next = NULL;\\n\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        // edge cases\\n        if (!head || !head->next || !k) {\\n            return head;\\n        }\\n        // dummy curr\\n        ListNode* curr = head;\\n        // finding length\\n        int len = 1;\\n        while(curr->next) {\\n            curr = curr->next;\\n            ++len;\\n        }\\n        curr->next = head;\\n        // we will traverse from start instead so take len - k instead\\n        k = k % len;\\n        k = len - k;\\n        // lets start traversing\\n        while(k--) {\\n            curr = curr->next;\\n        }\\n        head = curr->next;\\n        curr->next = NULL;\\n\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262985,
                "title": "java-0ms-100-faster-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n\\n        if(head==null || head.next==null ||k==0) return head;\\n        \\n        ListNode cur=head;\\n        int len=1;\\n        while(cur.next!=null){\\n            len++;\\n            cur=cur.next;\\n        }\\n\\n        cur.next=head;\\n        k=k%len;\\n        k=len-k;\\n        while(k!=0){\\n            cur=cur.next;\\n            k--;\\n        } \\n\\n        head=cur.next;\\n        cur.next=null;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n\\n        if(head==null || head.next==null ||k==0) return head;\\n        \\n        ListNode cur=head;\\n        int len=1;\\n        while(cur.next!=null){\\n            len++;\\n            cur=cur.next;\\n        }\\n\\n        cur.next=head;\\n        k=k%len;\\n        k=len-k;\\n        while(k!=0){\\n            cur=cur.next;\\n            k--;\\n        } \\n\\n        head=cur.next;\\n        cur.next=null;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207879,
                "title": "java-0ms-100-simple-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        ListNode tem1 = head;\\n        int count = 0;\\n        while(tem1 != null)\\n        {\\n            count++;\\n            tem1 = tem1.next;\\n        }\\n        if(k==0 || head==null)\\n        return head;\\n        k = k % count;\\n        int m = count - k;\\n        int m1 = m;\\n        ListNode tem2 = head;\\n        ListNode tem3 = new ListNode(-1);\\n        ListNode ans = tem3;\\n        ListNode first = new ListNode(-1);\\n        ListNode fir = first;\\n        while(m-- > 0)\\n        {\\n            first.next = new ListNode(tem2.val);\\n            tem2 = tem2.next;\\n            first = first.next;\\n        }\\n        while(tem2 != null)\\n        {\\n            tem3.next = tem2;\\n            tem2 = tem2.next;\\n            tem3 = tem3.next;\\n        }\\n        ListNode tem4 = head;\\n        tem3.next = fir.next;\\n        return ans.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        ListNode tem1 = head;\\n        int count = 0;\\n        while(tem1 != null)\\n        {\\n            count++;\\n            tem1 = tem1.next;\\n        }\\n        if(k==0 || head==null)\\n        return head;\\n        k = k % count;\\n        int m = count - k;\\n        int m1 = m;\\n        ListNode tem2 = head;\\n        ListNode tem3 = new ListNode(-1);\\n        ListNode ans = tem3;\\n        ListNode first = new ListNode(-1);\\n        ListNode fir = first;\\n        while(m-- > 0)\\n        {\\n            first.next = new ListNode(tem2.val);\\n            tem2 = tem2.next;\\n            first = first.next;\\n        }\\n        while(tem2 != null)\\n        {\\n            tem3.next = tem2;\\n            tem2 = tem2.next;\\n            tem3 = tem3.next;\\n        }\\n        ListNode tem4 = head;\\n        tem3.next = fir.next;\\n        return ans.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3138302,
                "title": "clean-optimized-java-sol-0ms-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N) + O(N-(k%N)) --> O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        \\n      if(head==null || head.next==null || k==0)  return head;\\n\\n      ListNode curr = head;  int len=1;\\n      while(curr.next!=null){\\n          len++;  curr = curr.next;     //counting the length of list.\\n      }\\n      curr.next = head;                 // joining last node to first making it a circular list.\\n      k = len-(k%len);                  // doing K%len as any rotation in multiple of len will give same list.Ex- k=12 and len is 5 then we need\\n                                        // to rotate 2 times.  len-(k%len) is to go till node from start to node where we have to break list.\\n                                      \\n      while(k>0){\\n          curr = curr.next;\\n          k--;\\n      }\\n      head = curr.next;                  // making new head which will be the node after the breaking point;\\n      curr.next = null;                  // now curr is the last node with its next value as null.\\n      return head;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        \\n      if(head==null || head.next==null || k==0)  return head;\\n\\n      ListNode curr = head;  int len=1;\\n      while(curr.next!=null){\\n          len++;  curr = curr.next;     //counting the length of list.\\n      }\\n      curr.next = head;                 // joining last node to first making it a circular list.\\n      k = len-(k%len);                  // doing K%len as any rotation in multiple of len will give same list.Ex- k=12 and len is 5 then we need\\n                                        // to rotate 2 times.  len-(k%len) is to go till node from start to node where we have to break list.\\n                                      \\n      while(k>0){\\n          curr = curr.next;\\n          k--;\\n      }\\n      head = curr.next;                  // making new head which will be the node after the breaking point;\\n      curr.next = null;                  // now curr is the last node with its next value as null.\\n      return head;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060311,
                "title": "c-92-faster-easy-approach-o-n-o-1",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head || !head -> next || k == 0)\\n            return head;\\n        int size = 1;\\n        ListNode* tail = head;\\n        while(tail->next){\\n            tail = tail -> next;\\n            size++;\\n        }\\n\\n        int rotate = k%size;\\n        if(rotate == 0)\\n            return head;\\n            \\n        tail -> next = head;\\n        rotate = size - rotate - 1;\\n        ListNode* temp = head;\\n\\n        while(rotate--){\\n            temp = temp -> next;\\n        }\\n        ListNode* forward = temp->next;\\n        temp -> next = NULL;\\n\\n        return forward;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head || !head -> next || k == 0)\\n            return head;\\n        int size = 1;\\n        ListNode* tail = head;\\n        while(tail->next){\\n            tail = tail -> next;\\n            size++;\\n        }\\n\\n        int rotate = k%size;\\n        if(rotate == 0)\\n            return head;\\n            \\n        tail -> next = head;\\n        rotate = size - rotate - 1;\\n        ListNode* temp = head;\\n\\n        while(rotate--){\\n            temp = temp -> next;\\n        }\\n        ListNode* forward = temp->next;\\n        temp -> next = NULL;\\n\\n        return forward;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2890931,
                "title": "o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n       if(!head)return head;\\n       ListNode*ptr=head;\\n        int n=1;\\n        while(ptr->next){\\n            ptr=ptr->next;\\n            n++;\\n         }\\n        k=k%n;\\n        if( k==0 || n==1)return head;\\n        int s=n-k;//where the list is cut it out\\n        ListNode*ptr1=NULL;\\n        ListNode*ptr2=head;\\n        while(s--){\\n            ptr1=ptr2;\\n            ptr2=ptr2->next;\\n        }\\n        ptr->next=head;\\n        ptr1->next=NULL;\\n      return ptr2;\\n    }    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n       if(!head)return head;\\n       ListNode*ptr=head;\\n        int n=1;\\n        while(ptr->next){\\n            ptr=ptr->next;\\n            n++;\\n         }\\n        k=k%n;\\n        if( k==0 || n==1)return head;\\n        int s=n-k;//where the list is cut it out\\n        ListNode*ptr1=NULL;\\n        ListNode*ptr2=head;\\n        while(s--){\\n            ptr1=ptr2;\\n            ptr2=ptr2->next;\\n        }\\n        ptr->next=head;\\n        ptr1->next=NULL;\\n      return ptr2;\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673151,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) \\n    {\\n        if(!head || !head->next ||k==0)\\n        {\\n            return head;\\n        }\\n        ListNode *curr=head;\\n        int count=1;\\n        while(curr->next && ++count)\\n        {\\n            curr=curr->next;\\n        }\\n        curr->next=head;\\n        k=k%count;\\n        k=count-k;\\n        while(k--)\\n        {\\n            curr=curr->next;\\n        }\\n        head=curr->next;\\n        curr->next=NULL;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) \\n    {\\n        if(!head || !head->next ||k==0)\\n        {\\n            return head;\\n        }\\n        ListNode *curr=head;\\n        int count=1;\\n        while(curr->next && ++count)\\n        {\\n            curr=curr->next;\\n        }\\n        curr->next=head;\\n        k=k%count;\\n        k=count-k;\\n        while(k--)\\n        {\\n            curr=curr->next;\\n        }\\n        head=curr->next;\\n        curr->next=NULL;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2565572,
                "title": "java-o-n-complexity-o-1-space",
                "content": "```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        \\n        if(head == null)\\n            return head;\\n        \\n        int len= findLength(head);\\n        k = k % len ;\\n        \\n        if( k ==0 )\\n            return head;\\n        \\n        ListNode temp = head;\\n        \\n        for(int i=1; i<len-k; i++){\\n            temp = temp.next;\\n        }\\n        \\n        ListNode store = temp.next;\\n        temp.next = null;\\n        \\n        temp =  store;\\n        \\n        while(temp.next != null){\\n            temp = temp.next;\\n        }\\n        \\n        temp.next = head;\\n       return store;\\n    }\\n    \\n    int findLength(ListNode head){\\n        int len = 0;\\n        \\n        while(head!= null ){\\n            len ++;\\n            head = head.next;\\n        }\\n        \\n        return len;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        \\n        if(head == null)\\n            return head;\\n        \\n        int len= findLength(head);\\n        k = k % len ;\\n        \\n        if( k ==0 )\\n            return head;\\n        \\n        ListNode temp = head;\\n        \\n        for(int i=1; i<len-k; i++){\\n            temp = temp.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2378138,
                "title": "easy-c-bring-the-tail-ahead-clean-fast-and-efficient-code-o-n-tc-o-1-sc",
                "content": "The idea is to reach the **\\'starting point of tail\\'** and point it to the **head** of the linked list. During this process, we also need to store the node \\'just before tail\\' and point it to **\\'null\\'**. That\\'s all. \\nFeel free to ask me anything in the comments below.\\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) { \\n\\t    // base cases\\n        if (!head)                             \\n            return head;\\n        else if (!head -> next)\\n            return head;\\n\\t\\t\\t\\n\\t\\t// counting the nodes in linked list\\n        int count = 0;                 \\n        ListNode *temp = head;\\n        while (temp){\\n            temp = temp -> next;\\n            count++;\\n        }\\n\\t\\t\\n\\t\\t// some more base cases\\n        if (k >= count)         // if you need to rotate the list more times than number of number of nodes present\\n            k %= count;        // then reduce the k to an equivalent number less than count (the remainder)\\n        if (k == 0)\\n            return head;\\n\\t\\t\\t\\n        ListNode * previous = nullptr, *current = head;    \\n\\t\\t// reaching the  starting point of tail\\n        for (int i = 0; current != nullptr && i < count-k; i++){       \\n            previous = current;\\n            current = current -> next;\\n        }\\n\\t\\t\\n        ListNode *lastNodeOfSecondPart = current;\\n\\t\\t// connecting the end to the start\\n        for (int i = 0; lastNodeOfSecondPart != nullptr &&  i < k-1; i++)\\n            lastNodeOfSecondPart = lastNodeOfSecondPart -> next;\\n        lastNodeOfSecondPart -> next = head;\\n\\t\\t\\n\\t\\t// point node just before tail to null\\n        previous -> next = nullptr;\\n\\t\\t\\n\\t\\t// return the current node\\n        return current;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) { \\n\\t    // base cases\\n        if (!head)                             \\n            return head;\\n        else if (!head -> next)\\n            return head;\\n\\t\\t\\t\\n\\t\\t// counting the nodes in linked list\\n        int count = 0;                 \\n        ListNode *temp = head;\\n        while (temp){\\n            temp = temp -> next;\\n            count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2118203,
                "title": "c-easy-soln-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next==NULL ||k==0) return head;\\n        \\n        ListNode* cur = head;\\n        int len =1;\\n        while(cur->next){\\n            len++;\\n            cur=cur->next;\\n        }\\n        cur->next=head;\\n        k=k%len;\\n        k = len-k;\\n        while(k--)\\n            cur=cur->next;\\n        \\n        head=cur->next;\\n        cur->next=NULL;\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next==NULL ||k==0) return head;\\n        \\n        ListNode* cur = head;\\n        int len =1;\\n        while(cur->next){\\n            len++;\\n            cur=cur->next;\\n        }\\n        cur->next=head;\\n        k=k%len;\\n        k = len-k;\\n        while(k--)\\n            cur=cur->next;\\n        \\n        head=cur->next;\\n        cur->next=NULL;\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868989,
                "title": "java-c-o-n-simple-to-understand-with-diagrammatic-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/bc6fee45-30b8-4e82-8455-5e1d7b48d782_1647833259.269898.png)\\n![image](https://assets.leetcode.com/users/images/4dac0e08-6ed7-4d4c-9384-663577277c6c_1647833836.224485.jpeg)\\n\\n\\nclass Solution {\\n  \\n    \\n    public ListNode rotateRight(ListNode head, int k) {\\n        \\n        \\n        if(head == null){\\n            return head;\\n        }\\n        \\n        //First total length of linked list is calculated\\n        int size = 0;\\n    \\n        ListNode curr = head;\\n        \\n        while(curr!=null){\\n            size++;\\n            curr = curr.next;\\n            \\n        }\\n        \\n        \\n        if(size == 1 || k==0 || k%size == 0){\\n            return head;\\n        }\\n        \\n        curr = head;\\n        ListNode temp1 =  curr;\\n        \\n        //This will handle the case if k>size\\n        int n = k%size;\\n        \\n        //Traversing till the kth value \\n        int i = 0;\\n        while(i<size-n-1){\\n            \\n            curr = curr.next;\\n            i++;\\n        }\\n        \\n        //temp2 will store the last element till k where we have to break the linked list ;\\n         ListNode temp2 = curr;\\n        \\n        \\n        //Creating a dummy node that will store the part whuch is to be rotated\\n        ListNode dummy = new ListNode(-1);\\n        ListNode temp  = dummy;//to store the initial position of dummy node;\\n        \\n        //traversing till the last element and attaching with dummy\\n        while(curr.next!=null){\\n            dummy.next = curr.next;\\n            dummy = curr.next;\\n            curr = curr.next;\\n        }\\n        \\n        //joining the last element with the first element\\n        curr.next = temp1;\\n        \\n        //breaking at the kth position;\\n        temp2.next = null;\\n        \\n        return temp.next;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "class Solution {\\n  \\n    \\n    public ListNode rotateRight(ListNode head, int k) {\\n        \\n        \\n        if(head == null){\\n            return head;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1839874,
                "title": "python-t-o-n-s-o-1-simple-comments",
                "content": "```\\n\\'\\'\\'\\n1. Approach is to link last node with first node\\n2. Then disconnect at a point size of the list - k\\n\\nExample : 1->2->3-4>5  , k = 2\\n\\n step 1 ,  1->2->3->4->5\\n           ^___________|\\n\\nlink the last index with first\\n\\n\\nstep 2,    1->2->3  x 4->5\\n           ^_____________|\\n\\ncut the link at size-k th index \\n\\'\\'\\'\\n\\n\\nclass Solution:\\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        if not head or not k:\\n            return head\\n        # capture the length of the list\\n        copy = head\\n        size = 1\\n        while copy.next:\\n            size+=1\\n            copy = copy.next\\n        # sometimes k > size, in such case perform modulo to reduce the value\\n        k = k%size if k>=size else k\\n        # k = 0 means performing rotation will bring same arrangement, hence return head\\n        if k==0:\\n            return head\\n        else:\\n            copy.next = head\\n        \\n        # move to a point where we need to cut the link\\n        ctr = 1\\n        while ctr<size-k:\\n            head = head.next\\n            ctr+=1\\n        # store the value to return and remove the link\\n        temp = head.next\\n        head.next = None\\n        return temp\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n\\'\\'\\'\\n1. Approach is to link last node with first node\\n2. Then disconnect at a point size of the list - k\\n\\nExample : 1->2->3-4>5  , k = 2\\n\\n step 1 ,  1->2->3->4->5\\n           ^___________|\\n\\nlink the last index with first\\n\\n\\nstep 2,    1->2->3  x 4->5\\n           ^_____________|\\n\\ncut the link at size-k th index \\n\\'\\'\\'\\n\\n\\nclass Solution:\\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        if not head or not k:\\n            return head\\n        # capture the length of the list\\n        copy = head\\n        size = 1\\n        while copy.next:\\n            size+=1\\n            copy = copy.next\\n        # sometimes k > size, in such case perform modulo to reduce the value\\n        k = k%size if k>=size else k\\n        # k = 0 means performing rotation will bring same arrangement, hence return head\\n        if k==0:\\n            return head\\n        else:\\n            copy.next = head\\n        \\n        # move to a point where we need to cut the link\\n        ctr = 1\\n        while ctr<size-k:\\n            head = head.next\\n            ctr+=1\\n        # store the value to return and remove the link\\n        temp = head.next\\n        head.next = None\\n        return temp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839705,
                "title": "java-100",
                "content": "\\tclass Solution {\\n\\t\\tpublic ListNode rotateRight(ListNode head, int k) {\\n\\t\\t\\tif(head==null) return null;\\n\\t\\t\\tint l=0;ListNode h=head;\\n\\t\\t\\tListNode last=null;\\n\\t\\t\\twhile(h!=null){\\n\\t\\t\\t\\tlast=h;\\n\\t\\t\\t\\th=h.next;l++;\\n\\t\\t\\t}\\n\\t\\t\\tk=k%l;\\n\\t\\t\\tk=l-k;\\n\\t\\t\\th=head;\\n\\t\\t\\twhile(k-->1){\\n\\t\\t\\t\\th=h.next;\\n\\t\\t\\t}\\n\\t\\t\\tlast.next=head;\\n\\t\\t\\thead=h.next;\\n\\t\\t\\th.next=null;\\n\\t\\t\\treturn head;\\n\\n\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic ListNode rotateRight(ListNode head, int k) {\\n\\t\\t\\tif(head==null) return null;\\n\\t\\t\\tint l=0;ListNode h=head;\\n\\t\\t\\tListNode last=null;\\n\\t\\t\\twhile(h!=null){\\n\\t\\t\\t\\tlast=h;\\n\\t\\t\\t\\th=h.next;l++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1839646,
                "title": "very-easy-solution-with-hand-written-steps",
                "content": "\\n![image](https://assets.leetcode.com/users/images/0b7c5a19-711d-4919-af67-8ec13a74acd0_1647002665.5356383.jpeg)\\n![image](https://assets.leetcode.com/users/images/c968364a-521f-463f-af31-2ff047ada9e5_1647002691.5484843.jpeg)\\n\\n\\n```\\n\\nclass Solution {\\n    public int getLength(ListNode head){\\n        int len=0;\\n        while(head!=null){\\n            len++;\\n            head=head.next;\\n        }\\n          \\n        \\n        return len;\\n    }\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null)return null;\\n        int len=getLength(head);\\n        k=k%len;\\n        ListNode fast=head,slow=head;\\n        while(k!=0){\\n           fast=fast.next;\\n            k--;\\n        }\\n            \\n        \\n        while(fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next;\\n        }\\n        fast.next=head;\\n        head=slow.next;\\n        slow.next=null;\\n        \\n        return head;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public int getLength(ListNode head){\\n        int len=0;\\n        while(head!=null){\\n            len++;\\n            head=head.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1838559,
                "title": "c-easy-to-understand-with-image-and-proper-explanation",
                "content": "# Daily Challenge:-11/03/2022.\\n**Approach:**-Apply Following steps:\\n-->Count the number of Nodes in Link-List.\\n-->Find the end of Link-List and name it as tail.\\n-->Update K by k= k%Node_count.\\n-->If updated k is 0 then return same Link-List.\\n\\n**Otherwise :-**\\n-->Break the Link List from (k)th node from end.\\n-->Attach the next of the tail to head of Link-List.\\n-->Make that k th node from end as new head of Link-Lis\\n-->return that head.\\n\\n***Understand the Concept From Image:-***\\n![image](https://assets.leetcode.com/users/images/a9cc929a-ef56-45a5-a559-10c5137a9900_1646975087.9075916.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL||head->next==NULL) //If this simply return head.\\n            return head;\\n        \\n        int Node_count=0; //Keep Node Count.\\n        ListNode* curr=head; \\n        ListNode* tail=NULL; //Keep the record of end of given Link-List.\\n        ListNode* new_head; //Keep the record of new head.\\n        while(curr!=NULL)\\n        {\\n            Node_count++;\\n            tail=curr; //Keep the record of tail.\\n            curr=curr->next;\\n        }\\n        \\n        if(k%Node_count==0) //If this means no rotation is necessary.\\n            return head;\\n        \\n        k=k%Node_count; // Actual rotation require. -->Updated k.\\n        int count=0; // it will keep the record of  kth node from end.\\n        curr=head; //For calculation.\\n        while(true)\\n        {\\n          count++; //Increment the count.\\n            if(count==Node_count-k) //If we find k th node from end (cuur->next is our kth node from end ,means curr is one node before it.)\\n            {\\n                new_head=curr->next; //Update our new head, with kth node from end.\\n                curr->next=NULL; //MAke the curr-Next null.\\n                tail->next=head; //Attach head to next of tail.\\n                head=new_head; //Update the head with new head.\\n                break; //Break the Loop\\n            }\\n            curr=curr->next; //Jump to next node\\n        }\\n        \\n        return head; //Return the Updated head.\\n    }\\n};\\n```\\nIf you find it helpful . Please Upvote .",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL||head->next==NULL) //If this simply return head.\\n            return head;\\n        \\n        int Node_count=0; //Keep Node Count.\\n        ListNode* curr=head; \\n        ListNode* tail=NULL; //Keep the record of end of given Link-List.\\n        ListNode* new_head; //Keep the record of new head.\\n        while(curr!=NULL)\\n        {\\n            Node_count++;\\n            tail=curr; //Keep the record of tail.\\n            curr=curr->next;\\n        }\\n        \\n        if(k%Node_count==0) //If this means no rotation is necessary.\\n            return head;\\n        \\n        k=k%Node_count; // Actual rotation require. -->Updated k.\\n        int count=0; // it will keep the record of  kth node from end.\\n        curr=head; //For calculation.\\n        while(true)\\n        {\\n          count++; //Increment the count.\\n            if(count==Node_count-k) //If we find k th node from end (cuur->next is our kth node from end ,means curr is one node before it.)\\n            {\\n                new_head=curr->next; //Update our new head, with kth node from end.\\n                curr->next=NULL; //MAke the curr-Next null.\\n                tail->next=head; //Attach head to next of tail.\\n                head=new_head; //Update the head with new head.\\n                break; //Break the Loop\\n            }\\n            curr=curr->next; //Jump to next node\\n        }\\n        \\n        return head; //Return the Updated head.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1838466,
                "title": "c-3-approaches-full-explanation-o-n-simple",
                "content": "```\\n//We can use array to rotate the linked list.\\n//Time complexity: O(N)\\n//Space complexity: O(N)\\n\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL){\\n            return 0;\\n        }\\n        vector<int> nums;\\n        ListNode* node=head;\\n        while(node){\\n            nums.push_back(node->val);\\n            node=node->next;\\n        }\\n        k=k%nums.size();\\n        reverse(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.begin()+k);\\n        reverse(nums.begin()+k,nums.end());\\n        node=head;\\n        int i=0;\\n        while(node){\\n            node->val=nums[i++];\\n            node=node->next;\\n        }\\n        return head;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/66fec479-dac2-4495-8d05-7ca2b5327046_1646972684.798328.jpeg)\\n\\n```\\n//Another approach is to \\n//1. Reverse the full list\\n//2. reverse first k size list\\n//3. reverse remaning list i:e (n-k)\\n//You will get the result\\n//Time complexity: O(N)\\n//Space complexity: O(1)\\n\\nclass Solution {\\npublic:\\n    //Reverse a linked list\\n    ListNode* reverseList(ListNode* root) {\\n        ListNode* prev = NULL;\\n        ListNode* curr = root;\\n        while (curr != NULL) {\\n            ListNode* nextTemp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = nextTemp;\\n        }\\n        return prev;\\n    }\\n    \\n    ListNode* rotateRight(ListNode* head, int k) {\\n        //If the node is NULL\\n        if(head==NULL)\\n            return 0;\\n        \\n        //Calculate the length of linked list\\n        \\n        ListNode* newhead = head;\\n        int length=0;\\n        while(newhead!=NULL){\\n            length++;\\n            newhead=newhead->next;\\n        }\\n        \\n        \\n        k = k%length;\\n        if(k==0)\\n            return head;\\n        \\n        //Reverse list\\n        head=reverseList(head);\\n        \\n        //Find the kth node \\n        ListNode* kthnode=head;\\n        while(k>1 && kthnode){\\n            kthnode=kthnode->next;\\n            k--;\\n        }\\n\\n        if(kthnode==NULL || kthnode->next==NULL)\\n            return head;\\n        \\n        //Reverse second list\\n        ListNode* secondhalf=reverseList(kthnode->next);\\n        kthnode->next=NULL;\\n        \\n        //Reverse first list\\n        ListNode* firsthalfend=reverseList(head);\\n        ListNode* result=firsthalfend;\\n        \\n        //Link firlt list to second list\\n        while(firsthalfend && firsthalfend->next){\\n            firsthalfend=firsthalfend->next;\\n        }\\n        firsthalfend->next=secondhalf;\\n        \\n        return result;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/5d8db2bc-2985-4351-9e87-7dd7336d07b0_1646972712.8995314.jpeg)\\n\\n```\\n//Another approach is to make list cyclic\\n//Time complexity: O(N)\\n//Space complexity: O(1)\\n\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL or head->next==NULL){\\n            return head;\\n        }\\n        int length = 0;\\n        ListNode* newhead = head;\\n        while(newhead!=NULL){\\n            length++;\\n            if(newhead->next==NULL){\\n                newhead->next=head;\\n                break;\\n            }\\n            newhead=newhead->next;\\n        }\\n        k = length - k%length;\\n        for(int i=0;i<k;i++){\\n            newhead=newhead->next;\\n        }\\n        head=newhead->next;\\n        newhead->next=NULL;\\n        return head;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/17287e7c-db7e-4dfc-861f-92b396321022_1646972720.9260263.jpeg)\\n\\n**Please upvote if you like the solution**\\n\\nCheck my git hub repo: [Link](https://t.co/fWekOVcKHC)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//We can use array to rotate the linked list.\\n//Time complexity: O(N)\\n//Space complexity: O(N)\\n\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL){\\n            return 0;\\n        }\\n        vector<int> nums;\\n        ListNode* node=head;\\n        while(node){\\n            nums.push_back(node->val);\\n            node=node->next;\\n        }\\n        k=k%nums.size();\\n        reverse(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.begin()+k);\\n        reverse(nums.begin()+k,nums.end());\\n        node=head;\\n        int i=0;\\n        while(node){\\n            node->val=nums[i++];\\n            node=node->next;\\n        }\\n        return head;\\n    }\\n};\\n```\n```\\n//Another approach is to \\n//1. Reverse the full list\\n//2. reverse first k size list\\n//3. reverse remaning list i:e (n-k)\\n//You will get the result\\n//Time complexity: O(N)\\n//Space complexity: O(1)\\n\\nclass Solution {\\npublic:\\n    //Reverse a linked list\\n    ListNode* reverseList(ListNode* root) {\\n        ListNode* prev = NULL;\\n        ListNode* curr = root;\\n        while (curr != NULL) {\\n            ListNode* nextTemp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = nextTemp;\\n        }\\n        return prev;\\n    }\\n    \\n    ListNode* rotateRight(ListNode* head, int k) {\\n        //If the node is NULL\\n        if(head==NULL)\\n            return 0;\\n        \\n        //Calculate the length of linked list\\n        \\n        ListNode* newhead = head;\\n        int length=0;\\n        while(newhead!=NULL){\\n            length++;\\n            newhead=newhead->next;\\n        }\\n        \\n        \\n        k = k%length;\\n        if(k==0)\\n            return head;\\n        \\n        //Reverse list\\n        head=reverseList(head);\\n        \\n        //Find the kth node \\n        ListNode* kthnode=head;\\n        while(k>1 && kthnode){\\n            kthnode=kthnode->next;\\n            k--;\\n        }\\n\\n        if(kthnode==NULL || kthnode->next==NULL)\\n            return head;\\n        \\n        //Reverse second list\\n        ListNode* secondhalf=reverseList(kthnode->next);\\n        kthnode->next=NULL;\\n        \\n        //Reverse first list\\n        ListNode* firsthalfend=reverseList(head);\\n        ListNode* result=firsthalfend;\\n        \\n        //Link firlt list to second list\\n        while(firsthalfend && firsthalfend->next){\\n            firsthalfend=firsthalfend->next;\\n        }\\n        firsthalfend->next=secondhalf;\\n        \\n        return result;\\n    }\\n};\\n```\n```\\n//Another approach is to make list cyclic\\n//Time complexity: O(N)\\n//Space complexity: O(1)\\n\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL or head->next==NULL){\\n            return head;\\n        }\\n        int length = 0;\\n        ListNode* newhead = head;\\n        while(newhead!=NULL){\\n            length++;\\n            if(newhead->next==NULL){\\n                newhead->next=head;\\n                break;\\n            }\\n            newhead=newhead->next;\\n        }\\n        k = length - k%length;\\n        for(int i=0;i<k;i++){\\n            newhead=newhead->next;\\n        }\\n        head=newhead->next;\\n        newhead->next=NULL;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1838446,
                "title": "easy-cycle-link-list-approach-o-n-solution",
                "content": "\\n     if(head==NULL || head->next==NULL || k==0){\\n           return head;\\n       }\\n        int n=1; \\n        ListNode*temp=head->next;\\n        ListNode* he=head;\\n        ListNode* curr=head;\\n        while(curr->next!=NULL){\\n            n++;\\n            curr=curr->next;\\n        }\\n        curr->next=head;\\n        k=k%n;\\n        k=n-k-1;\\n        while(k!=0){\\n            he=he->next;\\n            temp=temp->next;\\n            k--;\\n        }\\n        he->next=NULL;\\n        \\n       \\n        return temp;\\n",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "\\n     if(head==NULL || head->next==NULL || k==0){\\n           return head;\\n       }\\n        int n=1; \\n        ListNode*temp=head->next;\\n        ListNode* he=head;\\n        ListNode* curr=head;\\n        while(curr->next!=NULL){\\n            n++;\\n            curr=curr->next;\\n        }\\n        curr->next=head;\\n        k=k%n;\\n        k=n-k-1;\\n        while(k!=0){\\n            he=he->next;\\n            temp=temp->next;\\n            k--;\\n        }\\n        he->next=NULL;\\n        \\n       \\n        return temp;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1431369,
                "title": "c-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        \\n        if (!head || !head->next) \\n            return head;\\n       \\n        ListNode* p = head;\\n        ListNode* res;\\n        int l = 1;\\n        \\n        while(p->next != NULL) {\\n            l++; \\n            p = p->next; \\n        }\\n        \\n        k = k%l;\\n        int x = l-k;\\n        \\n        p->next = head;\\n        \\n        while(x--)\\n            p = p->next;\\n        \\n        res = p->next;\\n        p->next = NULL;\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        \\n        if (!head || !head->next) \\n            return head;\\n       \\n        ListNode* p = head;\\n        ListNode* res;\\n        int l = 1;\\n        \\n        while(p->next != NULL) {\\n            l++; \\n            p = p->next; \\n        }\\n        \\n        k = k%l;\\n        int x = l-k;\\n        \\n        p->next = head;\\n        \\n        while(x--)\\n            p = p->next;\\n        \\n        res = p->next;\\n        p->next = NULL;\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391679,
                "title": "95-time-o-n-space-o-1",
                "content": "***Do upvote if you like the solution to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n\\n**Explanation :-**\\n1. Count the total number of nodes present in the original list.\\n2. Traverse (count - k) times and maintain a prev pointer which will keep track of the previous node.\\n3. After traversing , we will reach at the position from where we need to rotate the list.\\n4. Store reference of that node using curr pointer.\\n5. Now, traverse till end of the list and the last node will point to the start of the original list or the head of the list. \\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head == NULL || head -> next == NULL)\\n        {\\n            return head;\\n        }\\n        ListNode* temp = head;\\n        ListNode* prev;\\n        int i = 0 , count = 0;\\n        while(temp != NULL) // Count total nodes\\n        {\\n            temp = temp -> next;\\n            count++;\\n        }\\n        temp = head;\\n        k = k % count;\\n        while(temp != NULL && i < count - k) // Reach at the node from where we want to rotate\\n        {\\n            i++;\\n            prev = temp;\\n            temp = temp -> next;\\n        }\\n        if(temp == NULL)\\n        {\\n            return head;\\n        }\\n        ListNode* curr = temp; // curr wil hold the start of the list\\n        prev -> next = NULL; // Previous node of temp i.e. prev will point to NULL\\n        while(temp -> next != NULL)\\n        {\\n            temp = temp -> next;\\n        }\\n        temp -> next = head; // Last node will point to start to the original list\\n       return curr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head == NULL || head -> next == NULL)\\n        {\\n            return head;\\n        }\\n        ListNode* temp = head;\\n        ListNode* prev;\\n        int i = 0 , count = 0;\\n        while(temp != NULL) // Count total nodes\\n        {\\n            temp = temp -> next;\\n            count++;\\n        }\\n        temp = head;\\n        k = k % count;\\n        while(temp != NULL && i < count - k) // Reach at the node from where we want to rotate\\n        {\\n            i++;\\n            prev = temp;\\n            temp = temp -> next;\\n        }\\n        if(temp == NULL)\\n        {\\n            return head;\\n        }\\n        ListNode* curr = temp; // curr wil hold the start of the list\\n        prev -> next = NULL; // Previous node of temp i.e. prev will point to NULL\\n        while(temp -> next != NULL)\\n        {\\n            temp = temp -> next;\\n        }\\n        temp -> next = head; // Last node will point to start to the original list\\n       return curr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337678,
                "title": "java-solution-100-o-n",
                "content": "```\\n public ListNode rotateRight(ListNode head, int k) {\\n        if(head == null || head.next==null || k==0) return head;\\n        int len =0;\\n        \\n        ListNode node = head;\\n        while(node!=null){\\n            node = node.next;\\n            len++;\\n        }\\n        \\n        k = k%len;\\n        \\n        if(k==0){\\n            return head;\\n        }\\n        node = head;\\n        for(int i=1;i<len-k;i++){\\n            node = node.next;\\n        }\\n        \\n        ListNode temp =node.next;\\n        node.next = null;\\n        node = temp;\\n        \\n        while(temp.next!=null){\\n            temp = temp.next;\\n        }\\n        \\n        temp.next =head;\\n        return node;\\n        \\n        \\n    }\\n```\\n\\nTime complexity: O(N)\\nSpace Complexity: O(1)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public ListNode rotateRight(ListNode head, int k) {\\n        if(head == null || head.next==null || k==0) return head;\\n        int len =0;\\n        \\n        ListNode node = head;\\n        while(node!=null){\\n            node = node.next;\\n            len++;\\n        }\\n        \\n        k = k%len;\\n        \\n        if(k==0){\\n            return head;\\n        }\\n        node = head;\\n        for(int i=1;i<len-k;i++){\\n            node = node.next;\\n        }\\n        \\n        ListNode temp =node.next;\\n        node.next = null;\\n        node = temp;\\n        \\n        while(temp.next!=null){\\n            temp = temp.next;\\n        }\\n        \\n        temp.next =head;\\n        return node;\\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1164698,
                "title": "python3-simple-solution-using-circular-linked-list-with-figure-explanation",
                "content": "**Idea**\\nAssuming the length of linked list is `size`, rotate the list to the right by `k` places\\n- After `size` times rotation, the list is same as the original list\\n\\t- Therefore, we just need to perform `k = k % size` rotations\\n- Rotation of list to the right by `k` places is equivalent to \\n\\t1. Connect the tail and head of the list to create a circular list\\n\\t2. Split list after the (`size-k`)-th node\\n\\n**Implementation**\\n```python\\nclass Solution:\\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        # If list is empty or contains only one element,\\n        # no need to rotate\\n        if not head or not head.next:\\n            return head\\n        \\n        # Iterate to the list tail and get list size\\n        cur = head\\n        size = 1\\n        while cur.next:\\n            size += 1\\n            cur = cur.next \\n            \\n        # Compute the actual number that need to be rotated\\n        k %= size\\n        # If k = n * size, then no need to rotate\\n        if k == 0:\\n            return head\\n        \\n        # Connect tail and head to create a circular list\\n        cur.next = head \\n        \\n        # Iterate to the node which should be the new tail after rotation,\\n        # and split the list \\n        cur = head\\n        for _ in range(size - k - 1):\\n            cur = cur.next\\n        new_head = cur.next\\n        cur.next = None\\n        \\n        return new_head\\n```\\n\\n**Visualization**\\n`k = 2`\\n![image](https://assets.leetcode.com/users/images/7afc23b3-6827-4e82-bdc5-15df448b8ae4_1618738444.142348.png)\\n\\n**Complexity**\\n- Time: O(n)\\n- Space: O(1)\\n\\n\\n\\nIf you think this is helpful, please give it a vote.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        # If list is empty or contains only one element,\\n        # no need to rotate\\n        if not head or not head.next:\\n            return head\\n        \\n        # Iterate to the list tail and get list size\\n        cur = head\\n        size = 1\\n        while cur.next:\\n            size += 1\\n            cur = cur.next \\n            \\n        # Compute the actual number that need to be rotated\\n        k %= size\\n        # If k = n * size, then no need to rotate\\n        if k == 0:\\n            return head\\n        \\n        # Connect tail and head to create a circular list\\n        cur.next = head \\n        \\n        # Iterate to the node which should be the new tail after rotation,\\n        # and split the list \\n        cur = head\\n        for _ in range(size - k - 1):\\n            cur = cur.next\\n        new_head = cur.next\\n        cur.next = None\\n        \\n        return new_head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 884232,
                "title": "python-tricky-but-neat-solution-with-explanation",
                "content": "The little trick here is to put the `tail` back to `head` so that the list becomes a circle. \\nThen we just need to find the cut point and change the circle back to normal list, which is the final result.\\n\\nFor example: given list `[1, 2, 3, 4, 5]` and `k=2`, \\n- put list tail back to head, we get an unlimited list `[..., 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ...]` and origin list length = 5.\\n- find correct cut point, 5 - 2 = 3, thus we cut at the third place,  `[..., 1, 2, 3, |4, 5, 1, 2, 3,| 4, 5, ...]`. The circle list becomes back to normal list: `[4, 5, 1, 2, 3]`.\\n\\n```\\nclass Solution:\\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        \\n        if not head:\\n            return \\n        \\n        runner = head\\n        length = 1\\n        while runner.next:\\n            runner = runner.next\\n            length += 1\\n\\t\\t# KEY: put the tail back to head so that the list becomes a circle.\\n        runner.next = head\\n        \\n        for i in range(length - k % length - 1):\\n            head = head.next\\n\\t\\t\\t\\n        # Cut the circle list at `head`.\\n        ans, head.next = head.next, None\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        \\n        if not head:\\n            return \\n        \\n        runner = head\\n        length = 1\\n        while runner.next:\\n            runner = runner.next\\n            length += 1\\n\\t\\t# KEY: put the tail back to head so that the list becomes a circle.\\n        runner.next = head\\n        \\n        for i in range(length - k % length - 1):\\n            head = head.next\\n\\t\\t\\t\\n        # Cut the circle list at `head`.\\n        ans, head.next = head.next, None\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 883266,
                "title": "c-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if (!head)\\n            return NULL;\\n        \\n        ListNode *cur = head;\\n        int len = 1;        \\n        \\n        while (cur->next) \\n            len++,\\n            cur = cur->next;\\n        \\n        cur->next = head;\\n        \\n        k = k % len;\\n        int m = len - k - 1;\\n        \\n        while (m--)\\n            head = head->next;\\n        \\n        auto newHead = head->next;\\n        head->next = NULL;\\n        \\n        return newHead;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if (!head)\\n            return NULL;\\n        \\n        ListNode *cur = head;\\n        int len = 1;        \\n        \\n        while (cur->next) \\n            len++,\\n            cur = cur->next;\\n        \\n        cur->next = head;\\n        \\n        k = k % len;\\n        int m = len - k - 1;\\n        \\n        while (m--)\\n            head = head->next;\\n        \\n        auto newHead = head->next;\\n        head->next = NULL;\\n        \\n        return newHead;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 883100,
                "title": "java-2-easy-solution-with-and-w-o-counting-length",
                "content": "**#if helpful please do Upvote#**\\n\\n**Solution 1:  With Counting length**\\nTime Complexity : O(n)\\nSpace Complexity : O(1)\\n**0ms faster than 100%**\\n```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null) return head;\\n        int len=1;\\n        ListNode tail=head;\\n\\t\\t//calculate length\\n        while(tail.next!=null){\\n            tail=tail.next;\\n            len++;\\n        }\\n        tail.next=head; //loop back to root\\n        k%=len; //avoid unnecessary moves\\n        for(int i=0;i<len-k;i++){\\n            tail=tail.next;\\n        }\\n        ListNode NewHead=tail.next; //calculate new Head\\n        tail.next=null;\\n        return NewHead;\\n        \\n    }\\n}\\n```\\n\\n**Solution 2 : Without counting the length**\\n**But this is slow :-(**\\n```\\npublic ListNode rotateRight(ListNode head, int n) {\\n    if (head == null || head.next == null || n == 0) {\\n         return head;\\n    }\\n    ListNode fast = head;\\n    ListNode slow = head;\\n    ListNode newHead;\\n    for (int i = 0; i < n; i++) {\\n        if (fast.next == null) {\\n            fast = head;\\n        } else {\\n            fast = fast.next;\\n        }\\n    }\\n    while (fast.next != null) {\\n        fast = fast.next;\\n        slow = slow.next;\\n    }\\n    fast.next = head;\\n    newHead = slow.next;\\n    slow.next = null;\\n    return newHead;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null) return head;\\n        int len=1;\\n        ListNode tail=head;\\n\\t\\t//calculate length\\n        while(tail.next!=null){\\n            tail=tail.next;\\n            len++;\\n        }\\n        tail.next=head; //loop back to root\\n        k%=len; //avoid unnecessary moves\\n        for(int i=0;i<len-k;i++){\\n            tail=tail.next;\\n        }\\n        ListNode NewHead=tail.next; //calculate new Head\\n        tail.next=null;\\n        return NewHead;\\n        \\n    }\\n}\\n```\n```\\npublic ListNode rotateRight(ListNode head, int n) {\\n    if (head == null || head.next == null || n == 0) {\\n         return head;\\n    }\\n    ListNode fast = head;\\n    ListNode slow = head;\\n    ListNode newHead;\\n    for (int i = 0; i < n; i++) {\\n        if (fast.next == null) {\\n            fast = head;\\n        } else {\\n            fast = fast.next;\\n        }\\n    }\\n    while (fast.next != null) {\\n        fast = fast.next;\\n        slow = slow.next;\\n    }\\n    fast.next = head;\\n    newHead = slow.next;\\n    slow.next = null;\\n    return newHead;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 802313,
                "title": "c-super-simple-solution-with-explanations-4ms-faster-than-97",
                "content": "**Like it? please upvote...**\\n```\\nint get_len(ListNode* head){\\n        int res=0;\\n        while(head!=NULL)\\n        {\\n            res++;\\n            head = head->next;\\n        }\\n        return res;\\n    }\\n    \\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if ((!head) || (!head->next) || (k==0)) return head;\\n        ListNode* ptr = head;\\n        int len = get_len(ptr);\\n        k = k%len;\\n        if (k==0) // no need to rotate\\n            return head;\\n        ptr = head;\\n        for (int i=0; i<len-k-1; i++) // go to node which will be the head\\n            ptr = ptr->next;\\n        \\n        ListNode* new_tail = ptr; // we split the list\\n        ListNode* new_head = ptr->next;\\n        ptr = ptr->next;\\n        new_tail->next = NULL;\\n        \\n        while (ptr->next!=NULL) // connect second part to first part\\n            ptr = ptr->next;\\n        ptr->next = head;\\n        return new_head;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint get_len(ListNode* head){\\n        int res=0;\\n        while(head!=NULL)\\n        {\\n            res++;\\n            head = head->next;\\n        }\\n        return res;\\n    }\\n    \\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if ((!head) || (!head->next) || (k==0)) return head;\\n        ListNode* ptr = head;\\n        int len = get_len(ptr);\\n        k = k%len;\\n        if (k==0) // no need to rotate\\n            return head;\\n        ptr = head;\\n        for (int i=0; i<len-k-1; i++) // go to node which will be the head\\n            ptr = ptr->next;\\n        \\n        ListNode* new_tail = ptr; // we split the list\\n        ListNode* new_head = ptr->next;\\n        ptr = ptr->next;\\n        new_tail->next = NULL;\\n        \\n        while (ptr->next!=NULL) // connect second part to first part\\n            ptr = ptr->next;\\n        ptr->next = head;\\n        return new_head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 796748,
                "title": "c-faster-than-97-73-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {   \\n        if (head == NULL) // If the list is empty\\n            return head;\\n        \\n        ListNode *itr = head, *fwd, *new_head;\\n        int len = 0, kFront, ctr=0;\\n        while (itr != NULL) { // To get the length of the list\\n            itr = itr->next;\\n            len++;\\n        }\\n        \\n        k = k%len; // To avoid unnecessary rotations\\n        \\n        if (k == 0) // If no rotation is needed\\n            return head;\\n        \\n        kFront = len - (k+1);\\n        itr = head;\\n        while (ctr < kFront) { // Iterate to element before the K th rotation \\n            itr = itr->next;\\n            ctr++;\\n        }\\n        \\n        new_head = itr->next; \\n        itr->next = NULL; // Setting the next of node before k th rotation to NULL\\n        fwd = new_head;\\n        \\n        while (fwd->next) {\\n            fwd = fwd->next;\\n        }\\n        fwd->next = head;\\n        \\n        return new_head;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {   \\n        if (head == NULL) // If the list is empty\\n            return head;\\n        \\n        ListNode *itr = head, *fwd, *new_head;\\n        int len = 0, kFront, ctr=0;\\n        while (itr != NULL) { // To get the length of the list\\n            itr = itr->next;\\n            len++;\\n        }\\n        \\n        k = k%len; // To avoid unnecessary rotations\\n        \\n        if (k == 0) // If no rotation is needed\\n            return head;\\n        \\n        kFront = len - (k+1);\\n        itr = head;\\n        while (ctr < kFront) { // Iterate to element before the K th rotation \\n            itr = itr->next;\\n            ctr++;\\n        }\\n        \\n        new_head = itr->next; \\n        itr->next = NULL; // Setting the next of node before k th rotation to NULL\\n        fwd = new_head;\\n        \\n        while (fwd->next) {\\n            fwd = fwd->next;\\n        }\\n        fwd->next = head;\\n        \\n        return new_head;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 738991,
                "title": "java-a-clear-solution-only-with-tail-node",
                "content": "```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if (head == null) return null;\\n        int len = 1;\\n        ListNode tail = head;\\n        while (tail.next != null) {\\n            tail = tail.next;\\n            len = len + 1;\\n        }\\n        tail.next = head;\\n\\t\\t// find the pre node of Kth from end\\n        for (int i = len - k%len; i > 0; --i) {\\n            tail = tail.next;\\n        }\\n        ListNode res = tail.next;\\n        tail.next = null;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if (head == null) return null;\\n        int len = 1;\\n        ListNode tail = head;\\n        while (tail.next != null) {\\n            tail = tail.next;\\n            len = len + 1;\\n        }\\n        tail.next = head;\\n\\t\\t// find the pre node of Kth from end\\n        for (int i = len - k%len; i > 0; --i) {\\n            tail = tail.next;\\n        }\\n        ListNode res = tail.next;\\n        tail.next = null;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 330828,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head == null) return null;\\n        \\n        int len = 1;\\n        ListNode fast = head, slow = head;\\n        while(fast.next != null){\\n            len++;\\n            fast = fast.next;\\n        }\\n        \\n        for(int i = 1; i < len - k % len; i++)\\n            slow = slow.next;\\n        \\n        fast.next = head;\\n        head = slow.next;\\n        slow.next = null;\\n        \\n        return head;\\n    }\\n}\\n```\\n\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Rotate List.\\nMemory Usage: 39.2 MB, less than 39.66% of Java online submissions for Rotate List.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head == null) return null;\\n        \\n        int len = 1;\\n        ListNode fast = head, slow = head;\\n        while(fast.next != null){\\n            len++;\\n            fast = fast.next;\\n        }\\n        \\n        for(int i = 1; i < len - k % len; i++)\\n            slow = slow.next;\\n        \\n        fast.next = head;\\n        head = slow.next;\\n        slow.next = null;\\n        \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 330439,
                "title": "js-solution-beat-97-20-super-easy-understand",
                "content": "```\\nvar rotateRight = function(head, k) {\\n    if(!head || !head.next) return head\\n    dummy = head;\\n    depth = 0;\\n    while(dummy){\\n        depth += 1\\n        dummy = dummy.next\\n    }\\n    k = k%depth\\n    while(k > 0){\\n        node = head;\\n        while(node.next.next !== null){\\n            node = node.next\\n        }\\n        temp = node.next;\\n        node.next = null;\\n        temp.next = head;\\n        head = temp;\\n        k -= 1\\n    }\\n    return head\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rotateRight = function(head, k) {\\n    if(!head || !head.next) return head\\n    dummy = head;\\n    depth = 0;\\n    while(dummy){\\n        depth += 1\\n        dummy = dummy.next\\n    }\\n    k = k%depth\\n    while(k > 0){\\n        node = head;\\n        while(node.next.next !== null){\\n            node = node.next\\n        }\\n        temp = node.next;\\n        node.next = null;\\n        temp.next = head;\\n        head = temp;\\n        k -= 1\\n    }\\n    return head\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 246743,
                "title": "c-6-lines-head-and-tail",
                "content": "Intuition: right shift is tricky, but left shift follows the list direction. So, let\\'s rotate list ```len - k``` times left instead.\\n\\n- Count nodes (len) until we reach the tail.\\n- Connect head to tail (the list is short-circuited now).\\n- Then, move head and tail ```len - k``` times.\\n> Tip: use ```k % len``` to optimize for large ```k```.\\n- Finally, break the list at tail and return head.\\n```\\nListNode* rotateRight(ListNode* head, int k, int len = 1) {\\n  for (auto tail = head; tail != nullptr; tail = tail->next, ++len)\\n    if (tail->next == nullptr) {\\n      tail->next = head;\\n      for (k = len - k % len; k > 0; --k) head = head->next, tail = tail->next;\\n      tail->next = nullptr;\\n    }\\n  return head;\\n}\\n```",
                "solutionTags": [],
                "code": "```len - k```\n```len - k```\n```k % len```\n```k```\n```\\nListNode* rotateRight(ListNode* head, int k, int len = 1) {\\n  for (auto tail = head; tail != nullptr; tail = tail->next, ++len)\\n    if (tail->next == nullptr) {\\n      tail->next = head;\\n      for (k = len - k % len; k > 0; --k) head = head->next, tail = tail->next;\\n      tail->next = nullptr;\\n    }\\n  return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 181728,
                "title": "c-8ms",
                "content": "1.\\u8BB0\\u4F4Fhead\\u7684\\u4F4D\\u7F6E\\uFF0C\\u7136\\u540E\\u5C06\\u5355\\u5411\\u94FE\\u8868\\u641E\\u6210\\u73AF\\uFF0C\\u90A3\\u4E48\\u53EA\\u8981\\u5C06head\\u7684\\u4F4D\\u7F6E\\u5411\\u53F3\\u79FB\\u52A8(n-k%n)\\u4E2A\\u4F4D\\u7F6E\\uFF0C\\u7136\\u540E\\u518D\\u5C06\\u73AF\\u89E3\\u5F00\\u6210\\u5355\\u5411\\u94FE\\u8868\\uFF0C\\u6700\\u540E\\u8FD4\\u56DE\\u3002\\n\\n```\\nclass Solution {\\npublic:\\nListNode* rotateRight(ListNode* head, int k) {\\n\\tif(!head) return NULL;\\n\\tint n=1;\\n\\tListNode* cur = head;\\n\\tListNode* res = head;\\n\\twhile(cur->next){\\n\\t\\tn++;\\n\\t\\tcur = cur->next;\\n\\t}\\n\\tcur->next = head; //\\u641E\\u6210\\u5FAA\\u73AF\\n\\tk=k%n;\\n\\twhile((n-k) > 0){\\n\\t\\tk++;\\n\\t\\tres = res->next;\\n\\t}\\n\\tcur = res;\\n\\twhile(cur->next != res){\\n\\t\\tcur = cur->next;\\n\\t}\\n\\tcur->next = NULL;\\n\\n\\t\\t\\treturn res;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nListNode* rotateRight(ListNode* head, int k) {\\n\\tif(!head) return NULL;\\n\\tint n=1;\\n\\tListNode* cur = head;\\n\\tListNode* res = head;\\n\\twhile(cur->next){\\n\\t\\tn++;\\n\\t\\tcur = cur->next;\\n\\t}\\n\\tcur->next = head; //\\u641E\\u6210\\u5FAA\\u73AF\\n\\tk=k%n;\\n\\twhile((n-k) > 0){\\n\\t\\tk++;\\n\\t\\tres = res->next;\\n\\t}\\n\\tcur = res;\\n\\twhile(cur->next != res){\\n\\t\\tcur = cur->next;\\n\\t}\\n\\tcur->next = NULL;\\n\\n\\t\\t\\treturn res;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22729,
                "title": "clean-c-9ms-step-by-step-solution",
                "content": "**Solution 1.**\\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head || !head->next) return head;\\n\\n        int len = 0;\\n        ListNode* p = head;\\n        while(p) p = p->next, len++;\\n        k = k % len;\\n        if(k == 0) return head;\\n        \\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(k > 0) fast = fast->next, k--;\\n        while(fast->next) fast = fast->next, slow = slow->next;\\n        \\n        ListNode* res = slow->next;\\n        \\n        slow->next = NULL;\\n        fast->next = head;\\n        \\n        return res;\\n    }\\n};\\n```\\n***\\n**Solution 2.**\\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head || !k) return head;\\n        ListNode* tail(head), *cur(head), *res;\\n        \\n        int len = 1;\\n        while(tail->next) tail = tail->next, len++;\\n        \\n        k = k % len;\\n        if(!k) return head;\\n        k = len - k;\\n        \\n        while(--k) cur = cur->next;\\n        \\n        res = cur->next;\\n        cur->next = NULL;\\n        tail->next = head;\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head || !head->next) return head;\\n\\n        int len = 0;\\n        ListNode* p = head;\\n        while(p) p = p->next, len++;\\n        k = k % len;\\n        if(k == 0) return head;\\n        \\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(k > 0) fast = fast->next, k--;\\n        while(fast->next) fast = fast->next, slow = slow->next;\\n        \\n        ListNode* res = slow->next;\\n        \\n        slow->next = NULL;\\n        fast->next = head;\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head || !k) return head;\\n        ListNode* tail(head), *cur(head), *res;\\n        \\n        int len = 1;\\n        while(tail->next) tail = tail->next, len++;\\n        \\n        k = k % len;\\n        if(!k) return head;\\n        k = len - k;\\n        \\n        while(--k) cur = cur->next;\\n        \\n        res = cur->next;\\n        cur->next = NULL;\\n        tail->next = head;\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22813,
                "title": "clear-python-solution",
                "content": "    class Solution(object):\\n        def rotateRight(self, head, k):\\n            \"\"\"\\n            :type head: ListNode\\n            :type k: int\\n            :rtype: ListNode\\n            \"\"\"\\n            if head is None:\\n                return head\\n            l, p = 1, head\\n            while p.next:\\n                p = p.next\\n                l += 1\\n            k = k % l\\n            if k == 0:\\n                return head\\n            \\n            q, n = head, l - k - 1\\n            while n:\\n                q = q.next\\n                n -= 1\\n            \\n            p.next = head\\n            head = q.next\\n            q.next = None\\n            return head",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def rotateRight(self, head, k):\\n            \"\"\"\\n            :type head: ListNode\\n            :type k: int\\n            :rtype: ListNode\\n            \"\"\"\\n            if head is None:\\n                return head\\n            l, p = 1, head\\n            while p.next:\\n                p = p.next\\n                l += 1\\n            k = k % l\\n            if k == 0:\\n                return head\\n            \\n            q, n = head, l - k - 1\\n            while n:\\n                q = q.next\\n                n -= 1\\n            \\n            p.next = head\\n            head = q.next\\n            q.next = None\\n            return head",
                "codeTag": "Java"
            },
            {
                "id": 22816,
                "title": "a-golang-solution",
                "content": "    func rotateRight(head *ListNode, k int) *ListNode {\\n        if head == nil {\\n    \\t\\treturn head\\n    \\t}\\n    \\n    \\tvar count int\\n    \\tm := make(map[int]*ListNode)\\n    \\n    \\tfor head != nil {\\n    \\t\\tm[count] = head\\n    \\t\\tcount++\\n    \\t\\thead = head.Next\\n    \\t}\\n    \\n    \\tk = k % count\\n    \\tif k == 0 {\\n    \\t    return m[0]\\n    \\t}\\n    \\n    \\tm[count - 1].Next = m[0]\\n    \\tm[count - k - 1].Next = nil\\n    \\treturn m[count - k]\\n    }",
                "solutionTags": [
                    "Go"
                ],
                "code": "    func rotateRight(head *ListNode, k int) *ListNode {\\n        if head == nil {\\n    \\t\\treturn head\\n    \\t}\\n    \\n    \\tvar count int\\n    \\tm := make(map[int]*ListNode)\\n    \\n    \\tfor head != nil {\\n    \\t\\tm[count] = head\\n    \\t\\tcount++\\n    \\t\\thead = head.Next\\n    \\t}\\n    \\n    \\tk = k % count\\n    \\tif k == 0 {\\n    \\t    return m[0]\\n    \\t}\\n    \\n    \\tm[count - 1].Next = m[0]\\n    \\tm[count - k - 1].Next = nil\\n    \\treturn m[count - k]\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3913844,
                "title": "beats-100-striver-s-approach-explained-clean-code",
                "content": "# Approach\\n![image.png](https://assets.leetcode.com/users/images/2045c536-b1e2-403e-a7e7-3aff7c040ba4_1692104707.3630223.png)\\n\\nMain idea is to convert Singly Linked List into a Circular Linked List. \\nFor that, we traverse till `curr -> next != NULL` which is the last node, and then point it to the head : `curr -> next = head`\\n\\nThen instead of rotating the list k times, we would rotate it 0 times if k = 5 for length = 5, rotate it once it k = 6 such that, twice if k = 7 and so on. So we count total rotations to be made as `k = k % length`\\n\\nThe pointer currently points to the tail of the SLL which is now connected to the head. We now move it to `k = length - k`\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head == NULL || k == 0 || head->next == NULL)    return head;\\n\\n        ListNode* curr = head;\\n        int length = 1;\\n\\n        while(curr->next != NULL) {\\n            curr = curr->next;\\n            length++;\\n        }\\n\\n        curr->next = head;\\n        k = k % length;\\n        k = length - k;\\n        while(k--)  curr = curr->next;\\n\\n        head = curr->next;\\n        curr->next = NULL;\\n\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head == NULL || k == 0 || head->next == NULL)    return head;\\n\\n        ListNode* curr = head;\\n        int length = 1;\\n\\n        while(curr->next != NULL) {\\n            curr = curr->next;\\n            length++;\\n        }\\n\\n        curr->next = head;\\n        k = k % length;\\n        k = length - k;\\n        while(k--)  curr = curr->next;\\n\\n        head = curr->next;\\n        curr->next = NULL;\\n\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860256,
                "title": "best-and-easiest-2-c-solutions-simple-two-pointer-approach-beats-100",
                "content": "\\n\\n# Complexity\\n### - Time complexity: O(N)\\n\\n### - Space complexity: O(1)\\n# Code\\n```\\n// Approach 1 - Two pointer\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head == NULL || head->next == NULL)\\n            return head;\\n            \\n        ListNode *p1 = head, *p2 = head, *prev1 = head, *prev2 = head;\\n        int len = 0;\\n        while(p1 != NULL){\\n            len++;\\n            p1 = p1->next;\\n        }\\n        k = k % len;\\n        if(k==0)    return head;\\n        p1 = head;\\n\\n        while(k-- && p1!= NULL){\\n            p1 = p1->next;\\n        }\\n\\n        while(p1 != NULL){\\n            prev1 = p1;\\n            prev2 = p2;\\n\\n            p1 = p1->next;\\n            p2 = p2->next;\\n        }\\n\\n        prev1->next = head;\\n        prev2->next = NULL;\\n        return p2;\\n    }\\n};\\n\\n// Approach 2 = Reverse the list\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode* head){\\n        ListNode *curr = head, *prev = NULL, *forward = NULL;\\n        while(curr != NULL){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n        }\\n        return prev;\\n    }\\n\\n    int getLength(ListNode *head){\\n        int len = 0;\\n        while(head != NULL){\\n            head= head->next;\\n            len++;\\n        }\\n        return len;\\n    }\\n\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head == NULL || head->next == NULL)\\n            return head;\\n\\n        int len = getLength(head);\\n        k = k%len;\\n        if(k==0)\\n            return head;\\n        \\n        ListNode *newHead = reverse(head);\\n        ListNode *p1 = newHead, *p2 = newHead, *prev1 = newHead;\\n        \\n        while(k--){\\n            prev1 = p1;\\n            p1 = p1->next;\\n        }\\n        prev1->next = NULL;\\n        ListNode *finalHead = reverse(p2);\\n        ListNode *joinHead = reverse(p1);\\n\\n        p1 = finalHead;\\n        while(p1->next != NULL)\\n            p1 = p1->next;\\n\\n        p1->next = joinHead;\\n        return finalHead;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n// Approach 1 - Two pointer\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head == NULL || head->next == NULL)\\n            return head;\\n            \\n        ListNode *p1 = head, *p2 = head, *prev1 = head, *prev2 = head;\\n        int len = 0;\\n        while(p1 != NULL){\\n            len++;\\n            p1 = p1->next;\\n        }\\n        k = k % len;\\n        if(k==0)    return head;\\n        p1 = head;\\n\\n        while(k-- && p1!= NULL){\\n            p1 = p1->next;\\n        }\\n\\n        while(p1 != NULL){\\n            prev1 = p1;\\n            prev2 = p2;\\n\\n            p1 = p1->next;\\n            p2 = p2->next;\\n        }\\n\\n        prev1->next = head;\\n        prev2->next = NULL;\\n        return p2;\\n    }\\n};\\n\\n// Approach 2 = Reverse the list\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode* head){\\n        ListNode *curr = head, *prev = NULL, *forward = NULL;\\n        while(curr != NULL){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n        }\\n        return prev;\\n    }\\n\\n    int getLength(ListNode *head){\\n        int len = 0;\\n        while(head != NULL){\\n            head= head->next;\\n            len++;\\n        }\\n        return len;\\n    }\\n\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head == NULL || head->next == NULL)\\n            return head;\\n\\n        int len = getLength(head);\\n        k = k%len;\\n        if(k==0)\\n            return head;\\n        \\n        ListNode *newHead = reverse(head);\\n        ListNode *p1 = newHead, *p2 = newHead, *prev1 = newHead;\\n        \\n        while(k--){\\n            prev1 = p1;\\n            p1 = p1->next;\\n        }\\n        prev1->next = NULL;\\n        ListNode *finalHead = reverse(p2);\\n        ListNode *joinHead = reverse(p1);\\n\\n        p1 = finalHead;\\n        while(p1->next != NULL)\\n            p1 = p1->next;\\n\\n        p1->next = joinHead;\\n        return finalHead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788502,
                "title": "easy-java-sol-circular-linked-list-concept-0ms-beats-100",
                "content": "\\n\\n# Approach\\nThe approach is making the list into circular list and then traversing the list till len-k-1 and then initialising its next to null.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nIF YOU LIKE THE SOLUTION, PLEASE UPVOTE.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n         if (head == null) {\\n            return head;\\n        }\\n        int len = 1;\\n        ListNode curr = head;\\n        while (curr.next != null) {\\n            curr = curr.next;\\n            len++;\\n        }\\n        k = k % len;\\n        if (k == 0) {\\n            return head;\\n        }\\n        curr.next = head;\\n        ListNode newHead = head;\\n        for (int i = 0; i < len - k - 1; i++) {\\n            newHead = newHead.next;\\n        }\\n        ListNode temp = newHead.next;\\n        newHead.next = null;\\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n         if (head == null) {\\n            return head;\\n        }\\n        int len = 1;\\n        ListNode curr = head;\\n        while (curr.next != null) {\\n            curr = curr.next;\\n            len++;\\n        }\\n        k = k % len;\\n        if (k == 0) {\\n            return head;\\n        }\\n        curr.next = head;\\n        ListNode newHead = head;\\n        for (int i = 0; i < len - k - 1; i++) {\\n            newHead = newHead.next;\\n        }\\n        ListNode temp = newHead.next;\\n        newHead.next = null;\\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747143,
                "title": "simple-java-solution-0ms-100-beats",
                "content": "# Approach\\n-Count the no of nodes in the list.\\n-divide them into two lists where second list contains k elements.\\n-if k > no of nodes make k as k % (no of nodes).\\n-add second list\\'s end to first list\\'s head and return second list head. \\n# Complexity\\n- Time complexity:\\n    O(N),N=no of nodes.\\n\\n- Space complexity:\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || head.next==null || k==0)\\n        return head;\\n        ListNode prev,temp;\\n        int x=0,y=0;\\n        prev=temp=head;\\n        while(temp!=null)\\n        {\\n            x++;\\n            temp=temp.next;\\n        }\\n        if(k>=x)\\n        k=k%x;\\n        if(k==0)\\n        return head;\\n        temp=head;\\n        while(y<x-k)\\n        {\\n            prev=temp;\\n            temp=temp.next;\\n            y++;\\n        }\\n        while(temp!=null)\\n        {\\n            if(temp.next==null)\\n            {\\n                temp.next=head;\\n                break;\\n            }\\n            temp=temp.next;\\n        }\\n        head=prev.next;\\n        prev.next=null;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || head.next==null || k==0)\\n        return head;\\n        ListNode prev,temp;\\n        int x=0,y=0;\\n        prev=temp=head;\\n        while(temp!=null)\\n        {\\n            x++;\\n            temp=temp.next;\\n        }\\n        if(k>=x)\\n        k=k%x;\\n        if(k==0)\\n        return head;\\n        temp=head;\\n        while(y<x-k)\\n        {\\n            prev=temp;\\n            temp=temp.next;\\n            y++;\\n        }\\n        while(temp!=null)\\n        {\\n            if(temp.next==null)\\n            {\\n                temp.next=head;\\n                break;\\n            }\\n            temp=temp.next;\\n        }\\n        head=prev.next;\\n        prev.next=null;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739814,
                "title": "easy-to-understand-97-beats-c",
                "content": "\\n\\n# Approach\\n1. Create a function to get length pf LL.\\n2. Create a function for single rotation.\\n3. Simply make the value of k smaller : to avoide repeated effect of rotation (k=k%n).\\n4. Now find the NewLast node and NewHead node and perform opreation acc to the question.\\n5. return newhead\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //find lenght of linked list \\n    int length(ListNode* head){\\n        int len =0;\\n        while(head){\\n            head=head->next;\\n            len++;\\n        }\\n        return len;\\n    }\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head == NULL) return NULL;\\n        int len = length(head);\\n        int actualk = k%len;\\n        if(actualk == 0) return head;\\n\\n        int pos = len-actualk-1;\\n\\n        ListNode* newlast=head;\\n        ListNode* newhead=nullptr;\\n\\n        //finding new LastNode \\n        for(int i=0;i<pos;i++){\\n            newlast=newlast->next;\\n        }\\n        newhead = newlast->next; // new head mil gya \\n        newlast->next = NULL;  // new last ko NULL kr de\\n        //find linkes list last node and connect it with first node \\n        \\n        ListNode* it = newhead;\\n        while(it->next != NULL){\\n            it=it->next;\\n        }\\n        it->next=head;\\n        return newhead;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //find lenght of linked list \\n    int length(ListNode* head){\\n        int len =0;\\n        while(head){\\n            head=head->next;\\n            len++;\\n        }\\n        return len;\\n    }\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head == NULL) return NULL;\\n        int len = length(head);\\n        int actualk = k%len;\\n        if(actualk == 0) return head;\\n\\n        int pos = len-actualk-1;\\n\\n        ListNode* newlast=head;\\n        ListNode* newhead=nullptr;\\n\\n        //finding new LastNode \\n        for(int i=0;i<pos;i++){\\n            newlast=newlast->next;\\n        }\\n        newhead = newlast->next; // new head mil gya \\n        newlast->next = NULL;  // new last ko NULL kr de\\n        //find linkes list last node and connect it with first node \\n        \\n        ListNode* it = newhead;\\n        while(it->next != NULL){\\n            it=it->next;\\n        }\\n        it->next=head;\\n        return newhead;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682484,
                "title": "using-queue-and-single-pass-no-need-to-count-first-beats-98-6-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing queue with maximum length of k to store items which should move to the begining of the list\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n![Screenshot 2023-06-25 at 3.37.08 PM.png](https://assets.leetcode.com/users/images/a9521192-2c95-4016-b891-a1b0d2cf73f5_1687732658.799979.png)\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode RotateRight(ListNode head, int k) {\\n        var queue = new Queue<ListNode>();\\n        if(k == 0) return head;\\n        var first = head;\\n        while(head != null)\\n        {\\n            if(head.next == null && queue.Count == k){\\n                head.next = first;\\n                queue.Dequeue().next = null;\\n                first = queue.Count > 0 ? queue.Peek() : head;\\n                break;\\n            }\\n            if(queue.Count == k) queue.Dequeue(); // We do n\\'t need to keep more than k items in the queue\\n            queue.Enqueue(head);\\n            if(head.next == null && queue.Count != k){\\n                k = k % queue.Count;// To avoid repeating if k is greater than items in the list\\n                if(k == 0) break;\\n                queue.Clear();\\n            } \\n            head=head.next ?? first;\\n        }\\n        return first;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode RotateRight(ListNode head, int k) {\\n        var queue = new Queue<ListNode>();\\n        if(k == 0) return head;\\n        var first = head;\\n        while(head != null)\\n        {\\n            if(head.next == null && queue.Count == k){\\n                head.next = first;\\n                queue.Dequeue().next = null;\\n                first = queue.Count > 0 ? queue.Peek() : head;\\n                break;\\n            }\\n            if(queue.Count == k) queue.Dequeue(); // We do n\\'t need to keep more than k items in the queue\\n            queue.Enqueue(head);\\n            if(head.next == null && queue.Count != k){\\n                k = k % queue.Count;// To avoid repeating if k is greater than items in the list\\n                if(k == 0) break;\\n                queue.Clear();\\n            } \\n            head=head.next ?? first;\\n        }\\n        return first;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651799,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head == null){\\n            return null;\\n        }\\n        int n =0;\\n        ListNode l = head;\\n        while(l!=null){\\n            l = l.next;\\n            n++;\\n        }\\n        k = k%n;\\n        for(int i=0 ; i<k ; i++){\\n            ListNode dum = head;\\n            ListNode prev=null;\\n            while(dum.next!=null){\\n                prev = dum;\\n                dum = dum.next;\\n            }\\n            if(prev!=null){\\n                prev.next = null;\\n                dum.next = head;\\n                head = dum;\\n\\n            }\\n        }\\n        return head;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head == null){\\n            return null;\\n        }\\n        int n =0;\\n        ListNode l = head;\\n        while(l!=null){\\n            l = l.next;\\n            n++;\\n        }\\n        k = k%n;\\n        for(int i=0 ; i<k ; i++){\\n            ListNode dum = head;\\n            ListNode prev=null;\\n            while(dum.next!=null){\\n                prev = dum;\\n                dum = dum.next;\\n            }\\n            if(prev!=null){\\n                prev.next = null;\\n                dum.next = head;\\n                head = dum;\\n\\n            }\\n        }\\n        return head;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583834,
                "title": "o-n-time-very-easy-c-11-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        //Boundary Case\\n        if(!head||!head->next||k==0){return head;}\\n        ListNode* cur=head;\\n        int len=1;\\n        //Iterating to last node\\n        while(cur->next && ++len){cur=cur->next;}\\n        //Creating a circular link list\\n        cur->next=head;\\n        k=k%len;\\n        k=len-k;\\n        //Iterating to rotated list \\n        while(k--){cur=cur->next;}\\n        //Cutting circular link list and adding headl\\n        head=cur->next;\\n        cur->next=NULL;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        //Boundary Case\\n        if(!head||!head->next||k==0){return head;}\\n        ListNode* cur=head;\\n        int len=1;\\n        //Iterating to last node\\n        while(cur->next && ++len){cur=cur->next;}\\n        //Creating a circular link list\\n        cur->next=head;\\n        k=k%len;\\n        k=len-k;\\n        //Iterating to rotated list \\n        while(k--){cur=cur->next;}\\n        //Cutting circular link list and adding headl\\n        head=cur->next;\\n        cur->next=NULL;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541946,
                "title": "61-rotate-list",
                "content": "class Solution {\\nprivate:\\n    void insertAthead(ListNode* & head,int val)\\n        \\n    {\\n        ListNode* newhead=new ListNode(val);\\n            if(head==NULL)\\n            {\\n             head=newhead;   \\n            }\\n        else\\n        {\\n            newhead->next=head;\\n            head=newhead;\\n        }\\n        \\n    }\\n    int lastval(ListNode* & head)\\n    {\\n        ListNode* curr=head;\\n        while(curr->next->next!=NULL)\\n        {\\n            curr=curr->next;\\n        }\\n        int v=curr->next->val;\\n        curr->next=NULL;\\n            return v;\\n    }\\n    \\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        int len=0;\\n            ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            len++;\\n            curr=curr->next;\\n        }\\n        k=k%len;\\n        for(int i=0;i<k;i++)\\n        {\\n            int val=lastval(head);\\n            insertAthead(head,val);\\n        }\\n        return head;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\nprivate:\\n    void insertAthead(ListNode* & head,int val)\\n        \\n    {\\n        ListNode* newhead=new ListNode(val);\\n            if(head==NULL)\\n            {\\n             head=newhead;   \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3508848,
                "title": "beats-100-simple-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if( k == 0 || head ==null || head.next == null) return head;\\n\\n        int len=1;\\n        ListNode cur=head;\\n        //count and travel to the last node;\\n        while(cur.next != null){\\n            len++;\\n            cur=cur.next;\\n        }\\n        //when k=len we get the same linked list\\n        k = len - (k%len);\\n        //make a loop by attaching last to first\\n        cur.next = head;\\n\\n        while(k > 0){\\n            cur=cur.next;\\n            k--;\\n        } \\n        //get the head and break the link\\n        head = cur.next;\\n        cur.next = null;\\n\\n        return head;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if( k == 0 || head ==null || head.next == null) return head;\\n\\n        int len=1;\\n        ListNode cur=head;\\n        //count and travel to the last node;\\n        while(cur.next != null){\\n            len++;\\n            cur=cur.next;\\n        }\\n        //when k=len we get the same linked list\\n        k = len - (k%len);\\n        //make a loop by attaching last to first\\n        cur.next = head;\\n\\n        while(k > 0){\\n            cur=cur.next;\\n            k--;\\n        } \\n        //get the head and break the link\\n        head = cur.next;\\n        cur.next = null;\\n\\n        return head;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316060,
                "title": "c-code-simple-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL) return head;\\n        \\n        ListNode* temp1=head;\\n        int size=1;\\n        while(temp1->next){\\n           temp1=temp1->next; \\n            size++;\\n        } \\n        temp1->next=head;\\n        \\n        k=k%size;\\n        int val=size-k-1;\\n        ListNode* temp2=head, *temp3=head;\\n        while(val--)\\n        {\\n            temp2=temp2->next;\\n        } \\n        temp3=temp2->next;\\n        temp2->next=NULL;\\n        \\n        return temp3;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL) return head;\\n        \\n        ListNode* temp1=head;\\n        int size=1;\\n        while(temp1->next){\\n           temp1=temp1->next; \\n            size++;\\n        } \\n        temp1->next=head;\\n        \\n        k=k%size;\\n        int val=size-k-1;\\n        ListNode* temp2=head, *temp3=head;\\n        while(val--)\\n        {\\n            temp2=temp2->next;\\n        } \\n        temp3=temp2->next;\\n        temp2->next=NULL;\\n        \\n        return temp3;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307764,
                "title": "rotate-linked-list-by-k-position-easy-java-solution-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nlet\\'s use two pointer as start and end. From start to end will be the rotating part that will come first.\\n    so, end will be the last element and find start with the help of\\n```\\n        int i = 0;\\n        k %= count;\\n        while(i < count - k - 1){\\n            i++;\\n            start = start.next;\\n        }\\n```\\nnow we just need to point end node to original first ```end.next = head;```\\nNow make a new head in start pointer and start.next will be null.\\n\\nAs a first example start is 3 and end is 5.\\nso after start 3 will point to null.\\nand ```newHead = start.next``` will point to 4.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        ListNode start = head, end = head, curr = head;\\n        int count = 0;\\n        if(head == null || head.next == null)\\n            return head;\\n        while(curr != null){\\n            curr = curr.next;\\n            count++;\\n        }\\n        while(end.next != null){\\n            end = end.next;\\n        }\\n        end.next = head; //ending point\\n        int i = 0;\\n        k %= count;\\n        while(i < count - k - 1){\\n            i++;\\n            start = start.next;\\n        }\\n        ListNode newhead = start.next;\\n        start.next = null;\\n        return newhead;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n        int i = 0;\\n        k %= count;\\n        while(i < count - k - 1){\\n            i++;\\n            start = start.next;\\n        }\\n```\n```end.next = head;```\n```newHead = start.next```\n```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        ListNode start = head, end = head, curr = head;\\n        int count = 0;\\n        if(head == null || head.next == null)\\n            return head;\\n        while(curr != null){\\n            curr = curr.next;\\n            count++;\\n        }\\n        while(end.next != null){\\n            end = end.next;\\n        }\\n        end.next = head; //ending point\\n        int i = 0;\\n        k %= count;\\n        while(i < count - k - 1){\\n            i++;\\n            start = start.next;\\n        }\\n        ListNode newhead = start.next;\\n        start.next = null;\\n        return newhead;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285408,
                "title": "c-solution-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this problem , we have find the last node of the linked list and always try to rotate it with joining lastnode to head and previous of last to NULL; \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe function first checks if the input linked list is empty or if k is zero. If either of these conditions is true, the function returns the input list as it is.\\n\\nThe function then computes the length of the linked list by traversing it using a temporary pointer temp that starts from the head of the list. The length c of the list is incremented for each node encountered.\\n\\nThe function then computes the actual number of positions z by which the list should be rotated. This is done by taking the remainder of k divided by c. This ensures that if k is greater than c, the function rotates the list by only the necessary amount.\\n\\nThe function then enters a loop that rotates the list by z positions. In each iteration, the function traverses the list using a pointer curr that starts from the head of the list and stops at the second-last node. This is because we need to change the next pointer of the second-last node to point to NULL in order to make it the last node of the rotated list. The function then saves the next pointer of the second-last node in a temporary pointer next, sets the next pointer of the second-last node to NULL, and sets the next pointer of next to point to the original head of the list. Finally, the function updates the head of the list to point to next.\\n\\nThe loop runs z times, so the final result is a rotated list.\\n\\nThe function returns a pointer to the new head of the rotated list.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(k*n)  \\nwhere \\nk= no of rotations. k is always k <= n.\\nn= length of linked list;\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1);\\nwe are not using extra space;\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n     if(!head || k==0)\\n     {\\n         return head;\\n     }\\n       int c=0;\\n       ListNode* temp=head;\\n       while(temp)\\n       {\\n           c++;\\n           temp=temp->next;\\n       }\\n\\n       int z=k%c;\\n    //    cout<<c<<\" \"<<z<<\"\\\\n\";\\n    //   cout<<temp->val<<\"\\\\n\";\\n       while(z--)\\n       {\\n           ListNode* curr=head;\\n           while(curr->next->next)\\n           {\\n               \\n               curr=curr->next;\\n           }\\n            ListNode* next=curr->next;\\n           curr->next=next->next;\\n           next->next=head;\\n           head=next;\\n\\n       }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n     if(!head || k==0)\\n     {\\n         return head;\\n     }\\n       int c=0;\\n       ListNode* temp=head;\\n       while(temp)\\n       {\\n           c++;\\n           temp=temp->next;\\n       }\\n\\n       int z=k%c;\\n    //    cout<<c<<\" \"<<z<<\"\\\\n\";\\n    //   cout<<temp->val<<\"\\\\n\";\\n       while(z--)\\n       {\\n           ListNode* curr=head;\\n           while(curr->next->next)\\n           {\\n               \\n               curr=curr->next;\\n           }\\n            ListNode* next=curr->next;\\n           curr->next=next->next;\\n           next->next=head;\\n           head=next;\\n\\n       }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3228968,
                "title": "easy-to-understand-c-solution",
                "content": "# Code\\n```\\npublic class Solution \\n{\\n    public ListNode RotateRight(ListNode head, int k)\\n    {\\n        if (head == null)\\n        {\\n            return null;\\n        }\\n        \\n        var length = 1;\\n        var tail = head;\\n    \\n        while (tail.next != null)\\n        {\\n            length++;\\n            tail = tail.next;\\n        }\\n\\n        tail.next = head;\\n        \\n        k = length - k % length;\\n\\n        for (var i = 0; i < k; i++)\\n        {\\n            head = head.next;\\n            tail = tail.next;\\n        }\\n\\n        tail.next = null;\\n\\n        return head;\\n    }\\n}\\n```\\n\\n![pleaseupvote.jpg](https://assets.leetcode.com/users/images/67e97d5d-9eeb-4160-a966-5534f748b3f5_1677333688.581251.jpeg)\\n",
                "solutionTags": [
                    "C#",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public ListNode RotateRight(ListNode head, int k)\\n    {\\n        if (head == null)\\n        {\\n            return null;\\n        }\\n        \\n        var length = 1;\\n        var tail = head;\\n    \\n        while (tail.next != null)\\n        {\\n            length++;\\n            tail = tail.next;\\n        }\\n\\n        tail.next = head;\\n        \\n        k = length - k % length;\\n\\n        for (var i = 0; i < k; i++)\\n        {\\n            head = head.next;\\n            tail = tail.next;\\n        }\\n\\n        tail.next = null;\\n\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211274,
                "title": "java-easy-0ms-beats-100-simple",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if (k==0 || head==null) return head;\\n        int count = 1;\\n        ListNode temp = head;\\n        while (temp.next!=null) {\\n            count++;\\n            temp = temp.next;\\n        }\\n        if (k>count) k = k%count;\\n        if (k==count) return head;\\n        k = count-k-1;\\n        temp.next = head;\\n        temp = head;\\n        while (k>0) {\\n            k--;\\n            temp = temp.next;\\n        }\\n        head = temp.next;\\n        temp.next = null;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if (k==0 || head==null) return head;\\n        int count = 1;\\n        ListNode temp = head;\\n        while (temp.next!=null) {\\n            count++;\\n            temp = temp.next;\\n        }\\n        if (k>count) k = k%count;\\n        if (k==count) return head;\\n        k = count-k-1;\\n        temp.next = head;\\n        temp = head;\\n        while (k>0) {\\n            k--;\\n            temp = temp.next;\\n        }\\n        head = temp.next;\\n        temp.next = null;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3199897,
                "title": "0ms-java-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || head.next==null ||k==0){\\n            return head;\\n        }\\n        //count the length\\n        ListNode cur=head;\\n        int len=1;\\n        while(cur.next!=null){\\n            len++;\\n            cur=cur.next;\\n        }\\n        //go till that node\\n        cur.next=head;\\n        k=k%len;\\n        k=len-k;\\n        while(k-- >0){\\n            cur=cur.next;\\n        }\\n        //make the node head and break connection\\n        head=cur.next;\\n        cur.next=null;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || head.next==null ||k==0){\\n            return head;\\n        }\\n        //count the length\\n        ListNode cur=head;\\n        int len=1;\\n        while(cur.next!=null){\\n            len++;\\n            cur=cur.next;\\n        }\\n        //go till that node\\n        cur.next=head;\\n        k=k%len;\\n        k=len-k;\\n        while(k-- >0){\\n            cur=cur.next;\\n        }\\n        //make the node head and break connection\\n        head=cur.next;\\n        cur.next=null;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182224,
                "title": "100-faster-c",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int len(ListNode* p){\\n        int x = 0;\\n        while(p){\\n            x++;\\n            p = p->next;\\n        }\\n        return x;\\n    }\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL||head->next==NULL)return head;\\n        int l = len(head);\\n        k = k%l;\\n        if(k==0)return head;\\n        k = l-k;\\n        ListNode* p = head;\\n        while(--k){\\n            p = p->next;\\n        }\\n        ListNode* q = p->next;\\n        p->next = NULL;\\n        ListNode* ans = q;\\n        while(q->next != NULL){\\n            q = q->next;\\n        }\\n        q->next = head;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int len(ListNode* p){\\n        int x = 0;\\n        while(p){\\n            x++;\\n            p = p->next;\\n        }\\n        return x;\\n    }\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL||head->next==NULL)return head;\\n        int l = len(head);\\n        k = k%l;\\n        if(k==0)return head;\\n        k = l-k;\\n        ListNode* p = head;\\n        while(--k){\\n            p = p->next;\\n        }\\n        ListNode* q = p->next;\\n        p->next = NULL;\\n        ListNode* ans = q;\\n        while(q->next != NULL){\\n            q = q->next;\\n        }\\n        q->next = head;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3127739,
                "title": "c-o-n-solution-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis code is a solution in C++ to the problem of rotating a linked list to the right by a certain number of places. The solution uses a private helper function \"getLength\" to get the length of the linked list. Then, in the public function \"rotateRight\", it calculates the new head of the rotated linked list, by traversing the original list until reaching a node \"k\" places from the end, where \"k\" is the number of places to rotate. The node \"k\" places from the end becomes the new head, and the original head is appended to the end of the new list.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code implements a solution to the problem of rotating a linked list to the right by a certain number of places. The linked list is represented by a chain of nodes, each node having a value and a pointer to the next node. The code uses a singly linked list representation, meaning that each node only points to the next node in the list, and not to the previous node.\\n\\nThe solution consists of two functions:\\n\\n1) getLength: This is a private helper function that calculates the length of the linked list. It does this by iterating through the linked list, starting from the head, and counting the number of nodes until it reaches the end of the list (when the current node\\'s next pointer is NULL).\\n\\n2) rotateRight: This is the public function that implements the rotation of the linked list. It takes as inputs the head of the linked list (head) and the number of places to rotate (k).\\n\\nHere are the steps that the code follows in the rotateRight function:\\n\\n1) Check if the linked list is empty or has only one node. If either of these conditions is true, then there is no need to rotate the list, so the function returns the head of the list.\\n\\n2) Calculate the length of the linked list by calling the getLength helper function.\\n\\n3) While k is greater than the length of the list, reduce k by the length of the list. This is to ensure that we only rotate the list by a number of places that is less than or equal to its length.\\n\\n4) Check if k is equal to the length of the list or 0. If either of these conditions is true, then there is no need to rotate the list, so the function returns the head of the list.\\n\\n5) Create a temporary pointer temp that starts at the head of the list.\\n\\n6) Traverse the list until temp points to the node k places from the end of the list. To do this, we iterate temp k times, starting from 1, and incrementing by 1 each time.\\n\\n7) The node temp points to is now the end of the original list, and the node after it is the new head of the rotated list. So we set ansHead to the node after temp and set temp->next to NULL to separate the two parts of the list.\\n\\n8) Create a new pointer forward that starts at the new head of the rotated list (ansHead).\\n\\n9) Traverse the new list until forward points to the last node. To do this, we iterate forward until its next pointer is NULL.\\n\\n10) Finally, set the next pointer of the last node of the new list to the original head of the list, so that the original head is appended to the end of the new list.\\n\\n11) Return the new head of the rotated list (ansHead).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe algorithm\\'s time complexity is O(n), where n is the length of the linked list, since we need to traverse the list once to calculate its length and once to perform the rotation.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this code is O(1), since it uses a constant amount of additional memory regardless of the size of the input linked list. The code only uses a few pointers (head, temp, ansHead, and forward) to traverse and manipulate the linked list, and the memory usage of these pointers is constant. The helper function getLength also uses a constant amount of memory. Hence, the overall space complexity of the code is O(1).\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    int getLength(ListNode* head){\\n        int counter = 0;\\n        while(head!=NULL){\\n            counter++;\\n            head=head->next;\\n        }\\n        return counter;\\n    }\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        ios_base::sync_with_stdio(false);\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        int len = getLength(head);\\n        while(k>len){\\n            k-=len;\\n        }\\n        if(k==len || k==0){\\n            return head;\\n        }\\n        ListNode* temp = head;\\n        k=len-k;\\n        int cnt = 1;\\n        while(cnt<k){\\n            temp=temp->next;\\n            cnt++;\\n        }\\n        ListNode* ansHead = temp->next;\\n        temp->next=NULL;\\n        ListNode* forward = ansHead;\\n        while(forward->next!=NULL){\\n            forward=forward->next;\\n        }\\n        forward->next=head;\\n        return ansHead;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    int getLength(ListNode* head){\\n        int counter = 0;\\n        while(head!=NULL){\\n            counter++;\\n            head=head->next;\\n        }\\n        return counter;\\n    }\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        ios_base::sync_with_stdio(false);\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        int len = getLength(head);\\n        while(k>len){\\n            k-=len;\\n        }\\n        if(k==len || k==0){\\n            return head;\\n        }\\n        ListNode* temp = head;\\n        k=len-k;\\n        int cnt = 1;\\n        while(cnt<k){\\n            temp=temp->next;\\n            cnt++;\\n        }\\n        ListNode* ansHead = temp->next;\\n        temp->next=NULL;\\n        ListNode* forward = ansHead;\\n        while(forward->next!=NULL){\\n            forward=forward->next;\\n        }\\n        forward->next=head;\\n        return ansHead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2888598,
                "title": "java-brute-force-optimal-clean-and-simple",
                "content": "# **Please Upvote** :D\\n##### 1. Brute force approach:\\n![image.png](https://assets.leetcode.com/users/images/7cddfd0b-ecdd-49bf-a69e-f0d3be8165a7_1670446044.8196685.png)\\n\\n```java []\\n\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if (head == null || head.next == null) return head;\\n\\n        ListNode curr = head;\\n        int size = 0;\\n\\n        while (curr != null) {\\n            size++;\\n            curr = curr.next;\\n        }\\n\\n        k %= size;\\n        int count = 0;\\n\\n        while (count++ != k) {\\n            curr = head;\\n            while (curr.next.next != null) {\\n                curr = curr.next;\\n            }\\n\\n            ListNode end = curr.next;\\n            curr.next = null;\\n            end.next = head;\\n            head = end;\\n        }\\n\\n        return head;\\n    }\\n}\\n\\n// TC: O(n) + O(n ^ 2) => O(n ^ 2)\\n\\n// In case our k is greater than n,\\n// we mod k by n to make it less than n,\\n// so at max k can be n - 1\\n// So O(k * n) => O((n-1) * n) => O(n ^ 2)\\n// If we don\\'t do it, we will get a TLE\\n\\n// SC: O(1)\\n```\\n\\n##### 2. Optimal approach:\\n![image.png](https://assets.leetcode.com/users/images/dc81f6a7-0b37-4a25-9d34-c5ea496d0b22_1670445816.6215196.png)\\n\\n``` java []\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if (head == null || head.next == null || k == 0) return head;\\n\\n        ListNode curr = head;\\n        int size = 1;\\n\\n        while (curr.next != null) {\\n            size++;\\n            curr = curr.next;\\n        }\\n\\n        curr.next = head;\\n        k %= size;\\n        k = size - k;\\n        // or k = size - (k % size);\\n\\n        while (k-- > 0) {\\n            curr = curr.next;\\n        }\\n\\n        head = curr.next;\\n        curr.next = null;\\n\\n        return head;\\n    }\\n}\\n\\n// TC: O(n) + O(n - k%n) => O(n)\\n// SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```java []\\n\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if (head == null || head.next == null) return head;\\n\\n        ListNode curr = head;\\n        int size = 0;\\n\\n        while (curr != null) {\\n            size++;\\n            curr = curr.next;\\n        }\\n\\n        k %= size;\\n        int count = 0;\\n\\n        while (count++ != k) {\\n            curr = head;\\n            while (curr.next.next != null) {\\n                curr = curr.next;\\n            }\\n\\n            ListNode end = curr.next;\\n            curr.next = null;\\n            end.next = head;\\n            head = end;\\n        }\\n\\n        return head;\\n    }\\n}\\n\\n// TC: O(n) + O(n ^ 2) => O(n ^ 2)\\n\\n// In case our k is greater than n,\\n// we mod k by n to make it less than n,\\n// so at max k can be n - 1\\n// So O(k * n) => O((n-1) * n) => O(n ^ 2)\\n// If we don\\'t do it, we will get a TLE\\n\\n// SC: O(1)\\n```\n``` java []\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if (head == null || head.next == null || k == 0) return head;\\n\\n        ListNode curr = head;\\n        int size = 1;\\n\\n        while (curr.next != null) {\\n            size++;\\n            curr = curr.next;\\n        }\\n\\n        curr.next = head;\\n        k %= size;\\n        k = size - k;\\n        // or k = size - (k % size);\\n\\n        while (k-- > 0) {\\n            curr = curr.next;\\n        }\\n\\n        head = curr.next;\\n        curr.next = null;\\n\\n        return head;\\n    }\\n}\\n\\n// TC: O(n) + O(n - k%n) => O(n)\\n// SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777504,
                "title": "easiest-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if (head ==NULL)return NULL;\\n        vector<int> nums;\\n        ListNode* p = head;\\n        while(p){\\n            nums.push_back(p->val);\\n            p = p->next;\\n        }\\n        k = k%nums.size();\\n        reverse(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.begin()+k);\\n        reverse(nums.begin()+k, nums.end());\\n        ListNode* a = new ListNode(nums[0]);\\n        ListNode* b = a;\\n        for(int i =1; i<nums.size(); i++){\\n            b->next = new ListNode(nums[i]);\\n            b = b->next;\\n        }\\n        return a;\\n        \\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if (head ==NULL)return NULL;\\n        vector<int> nums;\\n        ListNode* p = head;\\n        while(p){\\n            nums.push_back(p->val);\\n            p = p->next;\\n        }\\n        k = k%nums.size();\\n        reverse(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.begin()+k);\\n        reverse(nums.begin()+k, nums.end());\\n        ListNode* a = new ListNode(nums[0]);\\n        ListNode* b = a;\\n        for(int i =1; i<nums.size(); i++){\\n            b->next = new ListNode(nums[i]);\\n            b = b->next;\\n        }\\n        return a;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681554,
                "title": "java-easy-explained",
                "content": "```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n\\t// If no rotation is required\\n     if (k<=0 || head==null|| head.next==null){\\n            return head;\\n        }\\n\\n        int length=1;\\n        ListNode last=head;\\n\\t\\t\\n\\t\\t// For reaching to last Node and getting lenght\\n        while (last.next!=null){\\n            last=last.next;\\n            length++;\\n        }\\n\\t\\t// Now point last node to current head\\n        last.next=head;\\n\\t\\t// if k<6\\n        int roatations=k%length;\\n\\t\\t// no of skip need to made get desired new last node \\n        int skip=length-roatations;\\n        ListNode newLast=head;\\n\\t\\t\\n\\t\\t// Traversing till new last\\n        for (int i = 0; i < skip-1; i++) {\\n            newLast=newLast.next;\\n        }\\n\\t\\t// Now Pointing , new Last to new head;\\n        head=newLast.next;\\n\\t\\t// At last put new last point to null\\n        newLast.next=null;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n\\t// If no rotation is required\\n     if (k<=0 || head==null|| head.next==null){\\n            return head;\\n        }\\n\\n        int length=1;\\n        ListNode last=head;\\n\\t\\t\\n\\t\\t// For reaching to last Node and getting lenght\\n        while (last.next!=null){\\n            last=last.next;\\n            length++;\\n        }\\n\\t\\t// Now point last node to current head\\n        last.next=head;\\n\\t\\t// if k<6\\n        int roatations=k%length;\\n\\t\\t// no of skip need to made get desired new last node \\n        int skip=length-roatations;\\n        ListNode newLast=head;\\n\\t\\t\\n\\t\\t// Traversing till new last\\n        for (int i = 0; i < skip-1; i++) {\\n            newLast=newLast.next;\\n        }\\n\\t\\t// Now Pointing , new Last to new head;\\n        head=newLast.next;\\n\\t\\t// At last put new last point to null\\n        newLast.next=null;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266975,
                "title": "rotate-list",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        ListNode* temp = head;\\n        ListNode* curr = head;\\n        \\n        if(!head or !head->next)\\n            return head;\\n        int len = 1;\\n        while(temp->next){\\n            temp = temp -> next;\\n            len++;\\n        }\\n        // mod of k with cnt to find the minimum no of rotations.\\n        k = k % len;\\n        while(k--){\\n            temp = head;\\n            curr = head;\\n            while(curr -> next){\\n                temp = curr;\\n                curr = curr->next;\\n            }\\n            temp->next = NULL;\\n            curr->next = head;\\n            head = curr;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        ListNode* temp = head;\\n        ListNode* curr = head;\\n        \\n        if(!head or !head->next)\\n            return head;\\n        int len = 1;\\n        while(temp->next){\\n            temp = temp -> next;\\n            len++;\\n        }\\n        // mod of k with cnt to find the minimum no of rotations.\\n        k = k % len;\\n        while(k--){\\n            temp = head;\\n            curr = head;\\n            while(curr -> next){\\n                temp = curr;\\n                curr = curr->next;\\n            }\\n            temp->next = NULL;\\n            curr->next = head;\\n            head = curr;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235034,
                "title": "c-easy-explanation-with-pen-paper-optimal-approach",
                "content": "![image](https://assets.leetcode.com/users/images/8ed378f1-5f24-458c-a49f-0c5da71021a6_1656911105.8269634.jpeg)\\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        // Edge cases\\n        if(!head || !head->next || k==0)return head;\\n        \\n        //compute length of the list \\n        ListNode *cur=head;\\n        int length=1;\\n        while(cur->next)\\n        {\\n            cur=cur->next;\\n            ++length;\\n        }  // after this loop cur will be on last node\\n        \\n        // join last node with first Node\\n        cur->next=head;\\n        if(k>=length)    \\n         k=k%length;\\n        \\n        // main logic start from here\\n        k=length-k;      // k=(length-k)th node\\n        while(k--)     //go upto (length-k)th node \\n        {\\n            cur=cur->next;   \\n        }\\n        \\n        head=cur->next; // make head to point on  (length-k)th->next  node\\n        cur->next=NULL; // and then make  (length-k)th node null\\n        \\n        return head;\\n    }\\n};\\n//======================\\uD83D\\uDC4D\\uD83E\\uDD17Do upvote if you got the logic =========================\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        // Edge cases\\n        if(!head || !head->next || k==0)return head;\\n        \\n        //compute length of the list \\n        ListNode *cur=head;\\n        int length=1;\\n        while(cur->next)\\n        {\\n            cur=cur->next;\\n            ++length;\\n        }  // after this loop cur will be on last node\\n        \\n        // join last node with first Node\\n        cur->next=head;\\n        if(k>=length)    \\n         k=k%length;\\n        \\n        // main logic start from here\\n        k=length-k;      // k=(length-k)th node\\n        while(k--)     //go upto (length-k)th node \\n        {\\n            cur=cur->next;   \\n        }\\n        \\n        head=cur->next; // make head to point on  (length-k)th->next  node\\n        cur->next=NULL; // and then make  (length-k)th node null\\n        \\n        return head;\\n    }\\n};\\n//======================\\uD83D\\uDC4D\\uD83E\\uDD17Do upvote if you got the logic =========================\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2124136,
                "title": "simple-js-solution-w-comments-iterative",
                "content": "```\\n/**\\n * *Time: O(N)\\n * *Space: O(1)\\n */\\n// Runtime: 84 ms, faster than 66.96% of JavaScript online submissions for Rotate List.\\n// Memory Usage: 44.8 MB, less than 6.85% of JavaScript online submissions for Rotate List.\\nconst rotateRight = (head, k) => {\\n\\tif (!head) return null;\\n\\n\\tlet tail = head;\\n\\tlet len = 1; // 1-index based\\n\\n\\t// get tail node and length of LL\\n\\twhile (tail.next) {\\n\\t\\ttail = tail.next;\\n\\t\\tlen++;\\n\\t}\\n\\n\\ttail.next = head; // create cycle: connect to head\\n\\tlen = len - (k % len);\\n\\n\\t// if len === k: rotates to original LL\\n\\tif (len === 0) return head;\\n\\n\\t// find point of reverse\\n\\twhile (len--) {\\n\\t\\ttail = tail.next;\\n\\t}\\n\\n\\thead = tail.next; // set as new head\\n\\ttail.next = null; // server connection\\n\\n\\treturn head;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * *Time: O(N)\\n * *Space: O(1)\\n */\\n// Runtime: 84 ms, faster than 66.96% of JavaScript online submissions for Rotate List.\\n// Memory Usage: 44.8 MB, less than 6.85% of JavaScript online submissions for Rotate List.\\nconst rotateRight = (head, k) => {\\n\\tif (!head) return null;\\n\\n\\tlet tail = head;\\n\\tlet len = 1; // 1-index based\\n\\n\\t// get tail node and length of LL\\n\\twhile (tail.next) {\\n\\t\\ttail = tail.next;\\n\\t\\tlen++;\\n\\t}\\n\\n\\ttail.next = head; // create cycle: connect to head\\n\\tlen = len - (k % len);\\n\\n\\t// if len === k: rotates to original LL\\n\\tif (len === 0) return head;\\n\\n\\t// find point of reverse\\n\\twhile (len--) {\\n\\t\\ttail = tail.next;\\n\\t}\\n\\n\\thead = tail.next; // set as new head\\n\\ttail.next = null; // server connection\\n\\n\\treturn head;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2093972,
                "title": "easy-c-solution-with-o-1-space-complexity-and-o-n-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n\\t\\n\\t\\t// if linked list is NULL or k is 0 than return head\\n        if(k == 0 or head == NULL) return head;\\n\\t\\t\\n\\t\\t// first find the size of the linked list, and point tail at the end of the linked list\\n        int size = 0;\\n        ListNode* tail = new ListNode(0, head);\\n        while(tail->next)\\n        {\\n            tail = tail->next;\\n            size++;\\n        }\\n\\t\\t\\n\\t\\t// now if the value of k is greater than size than update it, as after this we need not to rotate list more than size time\\n        k %= size;\\n\\t\\t\\n\\t\\t// if k is zero than return head as we need not to rotate the list\\n        if(k == 0) return head;\\n\\t\\t\\n\\t\\t// now we need to rotate the linked list so we point our linked list tail to head\\n        tail -> next = head;\\n\\t\\t\\n\\t\\t// subtract k from the size to find the rotation point from the start and make it head and its tail equal to NULL\\n        k = size - k;\\n        ListNode* temp = new ListNode(0, head);\\n        while(k--)\\n        {\\n            temp = temp->next;\\n        }\\n        head = temp->next;\\n        temp->next = NULL;\\n\\t\\t\\n\\t\\t// return the new head\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n\\t\\n\\t\\t// if linked list is NULL or k is 0 than return head\\n        if(k == 0 or head == NULL) return head;\\n\\t\\t\\n\\t\\t// first find the size of the linked list, and point tail at the end of the linked list\\n        int size = 0;\\n        ListNode* tail = new ListNode(0, head);\\n        while(tail->next)\\n        {\\n            tail = tail->next;\\n            size++;\\n        }\\n\\t\\t\\n\\t\\t// now if the value of k is greater than size than update it, as after this we need not to rotate list more than size time\\n        k %= size;\\n\\t\\t\\n\\t\\t// if k is zero than return head as we need not to rotate the list\\n        if(k == 0) return head;\\n\\t\\t\\n\\t\\t// now we need to rotate the linked list so we point our linked list tail to head\\n        tail -> next = head;\\n\\t\\t\\n\\t\\t// subtract k from the size to find the rotation point from the start and make it head and its tail equal to NULL\\n        k = size - k;\\n        ListNode* temp = new ListNode(0, head);\\n        while(k--)\\n        {\\n            temp = temp->next;\\n        }\\n        head = temp->next;\\n        temp->next = NULL;\\n\\t\\t\\n\\t\\t// return the new head\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083741,
                "title": "explained-using-images-c-solution-well-explained-readable-code",
                "content": "![image](https://assets.leetcode.com/users/images/aa09ab34-01a7-4428-a8d8-7d1b38e4816e_1653753173.8543854.jpeg)\\n![image](https://assets.leetcode.com/users/images/dec10784-08c0-4062-9289-516db336490b_1653753188.5238533.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    int lengthofll(ListNode*head){                     // FUNCTION FOR FINDING NUMBER OF NODES\\n        int cnt=0;\\n        while(head){\\n            cnt++;\\n            head = head->next;\\n        }\\n        return cnt;\\n    }\\n    \\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head || !head->next || k==0) return head; // STEP 1  BASE CASE   \\n        int n = lengthofll(head);                     // STEP 2  FINDING NO OF NODES\\n        if(n==k || k%n==0) return head;               // STEP 3  AGAIN CHECKING REFER IMAGES FOR WHY\\n        int k1;                                      //  STEP 4  SIMPLIFYING K  \\n        if(k>n){\\n            k1 = k%n;\\n        }\\n        else if(k < n){\\n            k1 = k;\\n        }\\n        ListNode*curr_head,*last;\\n        ListNode*curr = head;\\n        int cnt = 0;\\n        for(int i=1;i<n;i++){                       // STEP 5 FINAL ROTATION\\n            if(i==n-k1){\\n                last = curr;\\n            }\\n            curr = curr->next;\\n        }\\n        curr->next = head;\\n        curr_head = last->next;\\n        last->next = nullptr;\\n        return curr_head;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthofll(ListNode*head){                     // FUNCTION FOR FINDING NUMBER OF NODES\\n        int cnt=0;\\n        while(head){\\n            cnt++;\\n            head = head->next;\\n        }\\n        return cnt;\\n    }\\n    \\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head || !head->next || k==0) return head; // STEP 1  BASE CASE   \\n        int n = lengthofll(head);                     // STEP 2  FINDING NO OF NODES\\n        if(n==k || k%n==0) return head;               // STEP 3  AGAIN CHECKING REFER IMAGES FOR WHY\\n        int k1;                                      //  STEP 4  SIMPLIFYING K  \\n        if(k>n){\\n            k1 = k%n;\\n        }\\n        else if(k < n){\\n            k1 = k;\\n        }\\n        ListNode*curr_head,*last;\\n        ListNode*curr = head;\\n        int cnt = 0;\\n        for(int i=1;i<n;i++){                       // STEP 5 FINAL ROTATION\\n            if(i==n-k1){\\n                last = curr;\\n            }\\n            curr = curr->next;\\n        }\\n        curr->next = head;\\n        curr_head = last->next;\\n        last->next = nullptr;\\n        return curr_head;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1869972,
                "title": "c-easiest-solution",
                "content": "This approach is applicable to a lot of scenarios where rotation is needed. Let me know if you need help or unsure about my approach, I will gladly help you!!! Please give me an upvote as your token of appreciation if you find this helpful XD.\\n\\n```\\nListNode* rotateRight(ListNode* head, int k) {\\n        if (!head)\\n            return head;\\n        \\n        ListNode* current = head;\\n        ListNode* ans = new ListNode;\\n        ListNode* currAns = ans;\\n        \\n        std::vector<int> temp;\\n        \\n        while (current)\\n        {\\n            temp.push_back(current->val);\\n            current = current->next;\\n        }\\n        \\n        std::rotate(temp.begin(), temp.end() - (k > temp.size() ? k % temp.size() : k), temp.end());\\n        \\n        for(int i = 0; i < temp.size(); ++i)\\n        {\\n            currAns->next = new ListNode(temp[i]);\\n            currAns = currAns->next;\\n        }\\n        \\n        return ans->next;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nListNode* rotateRight(ListNode* head, int k) {\\n        if (!head)\\n            return head;\\n        \\n        ListNode* current = head;\\n        ListNode* ans = new ListNode;\\n        ListNode* currAns = ans;\\n        \\n        std::vector<int> temp;\\n        \\n        while (current)\\n        {\\n            temp.push_back(current->val);\\n            current = current->next;\\n        }\\n        \\n        std::rotate(temp.begin(), temp.end() - (k > temp.size() ? k % temp.size() : k), temp.end());\\n        \\n        for(int i = 0; i < temp.size(); ++i)\\n        {\\n            currAns->next = new ListNode(temp[i]);\\n            currAns = currAns->next;\\n        }\\n        \\n        return ans->next;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1839920,
                "title": "c-efficient-tc-o-n-sc-o-1-easy-short-clean-solution-with-exp",
                "content": "#### if you find its Helpful, please UPVOTE :)\\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head || !head->next || k==0) return head;//edge case\\n        int len=1;\\n        ListNode* curr=head;\\n        while(curr->next){//counting length of ll\\n            len++;\\n            curr=curr->next;\\n        }\\n        curr->next=head;//connecting the last node to the head(makingcircular linked list) \\n        k=k%len;//\\n        k=len-k;\\n        while(k--)curr=curr->next;//travers to the (len-k) th node\\n        head=curr->next;//move the head to the new head\\n        curr->next=NULL;//break the list \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head || !head->next || k==0) return head;//edge case\\n        int len=1;\\n        ListNode* curr=head;\\n        while(curr->next){//counting length of ll\\n            len++;\\n            curr=curr->next;\\n        }\\n        curr->next=head;//connecting the last node to the head(makingcircular linked list) \\n        k=k%len;//\\n        k=len-k;\\n        while(k--)curr=curr->next;//travers to the (len-k) th node\\n        head=curr->next;//move the head to the new head\\n        curr->next=NULL;//break the list \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839100,
                "title": "go-0ms-solution",
                "content": "**Runtime:** 0 ms, faster than **100.00%** of Go online submissions for Rotate List.\\n**Memory Usage:** 2.6 MB, less than **30.22%** of Go online submissions for Rotate List.\\n\\n```go\\nfunc rotateRight( head *ListNode, k int ) *ListNode {\\n\\n    if k == 0 || head == nil{\\n        return head\\n    }\\n    var dummy  = &ListNode{Next: head}\\n    count, tail, sp := 0, head, head\\n    \\n    for tail.Next != nil {\\n        count++\\n        tail = tail.Next\\n    }\\n    count++\\n    j := k%count\\n    for i:=1; i < count-j;i++{\\n        sp = sp.Next\\n    }\\n    \\n    tail.Next = head\\n    dummy.Next = sp.Next\\n    sp.Next = nil\\n    \\n    return dummy.Next\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc rotateRight( head *ListNode, k int ) *ListNode {\\n\\n    if k == 0 || head == nil{\\n        return head\\n    }\\n    var dummy  = &ListNode{Next: head}\\n    count, tail, sp := 0, head, head\\n    \\n    for tail.Next != nil {\\n        count++\\n        tail = tail.Next\\n    }\\n    count++\\n    j := k%count\\n    for i:=1; i < count-j;i++{\\n        sp = sp.Next\\n    }\\n    \\n    tail.Next = head\\n    dummy.Next = sp.Next\\n    sp.Next = nil\\n    \\n    return dummy.Next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1838844,
                "title": "python-go-c-rotate-solution-and-explanation",
                "content": "**\\uD83D\\uDC46Please UPVOTE it if you find my soulutions are useful \\uD83D\\uDC46 Feel free to ask any question**\\n# [Python/GO/C++] \\uD83C\\uDF1F Rotate Solution and Explanation \\uD83D\\uDC95\\n## 1\\uFE0F\\u20E3 Main Idea:\\nBy example```[1,2,3,4,5], k = 2``` The answer will be move length = 2 tail to head ```[4,5,  1,2,3]```.\\nSince it\\'s a linked-list, we can only traverse whole linked-list from head to tail. So we have to find the length before **k length tail** first.\\nBut in example 2 ```head = [0,1,2], k = 4``` We can k mod 3 = 1, to calculate new k value. And move 2 to be new head ```[2,0,1]```\\n\\n**Algo**\\n1. Calculate **length** of linked-list, and make it **circular** (We will break circular at final step)\\n2. Make k %= length, and calculate **lengthPrev** to be length before k element => lengthPrev = length - k - 1 (1 will be initial length when we start from head)\\n3. Traverse linked-list from head, once curr in the lengthPrev node, we know it\\'s new tail of result\\n\\tnewHead = curr.next, and make curr.next = None\\n4. return newHead\\n## Complexity Analysis\\n* Time: O(N): Let N be the length of linked list\\n* Space: O(1)\\n\\n## Code\\n\\n**Python**\\n```python\\n# O(N) | O(1)\\nclass Solution:\\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n        length = 1\\n        curr = head\\n        # Calculate length of linked-list\\n        while curr.next is not None:\\n            length += 1\\n            curr = curr.next\\n        curr.next = head\\n        \\n        # Calculate length before k element\\n        k %= length\\n        lengthPrev = length - k - 1\\n        curr = head\\n        # Move curr to new tail\\n        for _ in range(lengthPrev):\\n            curr = curr.next\\n        # New head would be tail.next\\n        res = curr.next\\n        # Make tali point to None\\n        curr.next = None\\n        \\n        return res\\n```\\n**Go**\\n```go\\nfunc rotateRight(head *ListNode, k int) *ListNode {\\n    if head == nil || head.Next == nil{\\n        return head\\n    }\\n    \\n    length := 1\\n    curr := head\\n    // Calculate length of linked-list and make it circular\\n    for curr.Next != nil{\\n        length += 1\\n        curr = curr.Next\\n    }\\n    curr.Next = head\\n    // Calculate length before k element\\n    k %= length\\n    lengthPrev := length - k - 1\\n    curr = head\\n    // Move curr to new tail\\n    for i := 0; i < lengthPrev; i++{\\n        curr = curr.Next\\n    }\\n    // New head would be tail.next\\n    res := curr.Next\\n    // Make tali point to None\\n    curr.Next = nil\\n    \\n    return res\\n}\\n```\\n**C++**\\n```C++\\n// O(N) | O(1)\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if (!head || !head->next) return head;\\n        int length = 1;\\n        ListNode* curr = head;\\n        while (curr->next){\\n            length++;\\n            curr = curr->next;\\n        }\\n        curr->next = head;\\n        \\n        k %= length;\\n        int lengthPrev = length - k - 1;\\n        curr = head;\\n        for (int i = 0; i < lengthPrev; i++){\\n            curr = curr->next;\\n        }\\n        ListNode* res = curr->next;\\n        curr->next = nullptr;\\n        return res;\\n    }\\n};\\n```\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)",
                "solutionTags": [
                    "Python",
                    "C",
                    "Go"
                ],
                "code": "```[1,2,3,4,5], k = 2```\n```[4,5,  1,2,3]```\n```head = [0,1,2], k = 4```\n```[2,0,1]```\n```python\\n# O(N) | O(1)\\nclass Solution:\\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n        length = 1\\n        curr = head\\n        # Calculate length of linked-list\\n        while curr.next is not None:\\n            length += 1\\n            curr = curr.next\\n        curr.next = head\\n        \\n        # Calculate length before k element\\n        k %= length\\n        lengthPrev = length - k - 1\\n        curr = head\\n        # Move curr to new tail\\n        for _ in range(lengthPrev):\\n            curr = curr.next\\n        # New head would be tail.next\\n        res = curr.next\\n        # Make tali point to None\\n        curr.next = None\\n        \\n        return res\\n```\n```go\\nfunc rotateRight(head *ListNode, k int) *ListNode {\\n    if head == nil || head.Next == nil{\\n        return head\\n    }\\n    \\n    length := 1\\n    curr := head\\n    // Calculate length of linked-list and make it circular\\n    for curr.Next != nil{\\n        length += 1\\n        curr = curr.Next\\n    }\\n    curr.Next = head\\n    // Calculate length before k element\\n    k %= length\\n    lengthPrev := length - k - 1\\n    curr = head\\n    // Move curr to new tail\\n    for i := 0; i < lengthPrev; i++{\\n        curr = curr.Next\\n    }\\n    // New head would be tail.next\\n    res := curr.Next\\n    // Make tali point to None\\n    curr.Next = nil\\n    \\n    return res\\n}\\n```\n```C++\\n// O(N) | O(1)\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if (!head || !head->next) return head;\\n        int length = 1;\\n        ListNode* curr = head;\\n        while (curr->next){\\n            length++;\\n            curr = curr->next;\\n        }\\n        curr->next = head;\\n        \\n        k %= length;\\n        int lengthPrev = length - k - 1;\\n        curr = head;\\n        for (int i = 0; i < lengthPrev; i++){\\n            curr = curr->next;\\n        }\\n        ListNode* res = curr->next;\\n        curr->next = nullptr;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1838430,
                "title": "converting-into-circular-list-then-rotating-by-k",
                "content": "Converted the list into circular list then traversed find the (size-k)th node and delink it i.e, make it point to NULL, but before doing this store next node in ans variable and return it.\\n```\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head || !head->next){\\n            return head;\\n        }\\n        \\n        int len=0,last=0;\\n        ListNode *temp=head,*ans=head,*t1=head;\\n        while(temp->next){\\n            len++;\\n            temp=temp->next;\\n        }\\n        \\n        len++;\\n        k=k%len; \\n        if(k==0){               //no rotation\\n            return head;\\n        }\\n        \\n        //converting list into circular list\\n        temp->next=head;\\n        \\n        //rotate list by delinking (len-k)th node and setting it to null\\n        k=(len-k);\\n        k--;\\n        while(k>0){\\n            k--;\\n            t1=t1->next;\\n        }\\n        ans=t1->next;\\n        t1->next=NULL;\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head || !head->next){\\n            return head;\\n        }\\n        \\n        int len=0,last=0;\\n        ListNode *temp=head,*ans=head,*t1=head;\\n        while(temp->next){\\n            len++;\\n            temp=temp->next;\\n        }\\n        \\n        len++;\\n        k=k%len; \\n        if(k==0){               //no rotation\\n            return head;\\n        }\\n        \\n        //converting list into circular list\\n        temp->next=head;\\n        \\n        //rotate list by delinking (len-k)th node and setting it to null\\n        k=(len-k);\\n        k--;\\n        while(k>0){\\n            k--;\\n            t1=t1->next;\\n        }\\n        ans=t1->next;\\n        t1->next=NULL;\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1790963,
                "title": "solution-swift-rotate-list",
                "content": "```swift\\nclass Solution {\\n    func rotateRight(_ head: ListNode?, _ k: Int) -> ListNode? {\\n        if head == nil { return nil }\\n        \\n        var prev = head, post = head\\n        \\n        var len: Int {\\n            get {\\n                var value = 0\\n                var dummy = head\\n                while let node = dummy {\\n                    dummy = node.next\\n                    value += 1\\n                }\\n                return value\\n            }\\n        }\\n        \\n        var places = (k % len)\\n        \\n        while places > 0 {\\n            post = post?.next\\n            places -= 1\\n        }\\n        \\n        while let postnext = post?.next {\\n            post = postnext\\n            prev = prev?.next\\n        }\\n        \\n        post?.next = head\\n        post = prev?.next\\n        prev?.next = nil\\n        \\n        return post\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><b>ListNode</b></summary>\\n\\n```swift\\npublic class ListNode {\\n    public var val: Int\\n    public var next: ListNode?\\n    public init() { self.val = 0; self.next = nil; }\\n    public init(_ val: Int) { self.val = val; self.next = nil; }\\n    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n}\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func rotateRight(_ head: ListNode?, _ k: Int) -> ListNode? {\\n        if head == nil { return nil }\\n        \\n        var prev = head, post = head\\n        \\n        var len: Int {\\n            get {\\n                var value = 0\\n                var dummy = head\\n                while let node = dummy {\\n                    dummy = node.next\\n                    value += 1\\n                }\\n                return value\\n            }\\n        }\\n        \\n        var places = (k % len)\\n        \\n        while places > 0 {\\n            post = post?.next\\n            places -= 1\\n        }\\n        \\n        while let postnext = post?.next {\\n            post = postnext\\n            prev = prev?.next\\n        }\\n        \\n        post?.next = head\\n        post = prev?.next\\n        prev?.next = nil\\n        \\n        return post\\n    }\\n}\\n```\n```swift\\npublic class ListNode {\\n    public var val: Int\\n    public var next: ListNode?\\n    public init() { self.val = 0; self.next = nil; }\\n    public init(_ val: Int) { self.val = val; self.next = nil; }\\n    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1727748,
                "title": "68-ms-faster-than-99-52-of-javascript-code",
                "content": "```\\nvar rotateRight = function(head, k) {\\n     \\n    if(!head || !head.next)return head;\\n    let pointer=head;\\n    let prevNode=null;\\n    let count=1;\\n    while(pointer.next){\\n        prevNode=pointer;\\n        pointer=pointer.next;\\n        count++;\\n    }\\n    k=k%count;\\n    if(k===0){\\n        return head;\\n    }\\n    prevNode.next=null;\\n    pointer.next=head;\\n    head=pointer;\\n    return rotateRight(head,k-1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar rotateRight = function(head, k) {\\n     \\n    if(!head || !head.next)return head;\\n    let pointer=head;\\n    let prevNode=null;\\n    let count=1;\\n    while(pointer.next){\\n        prevNode=pointer;\\n        pointer=pointer.next;\\n        count++;\\n    }\\n    k=k%count;\\n    if(k===0){\\n        return head;\\n    }\\n    prevNode.next=null;\\n    pointer.next=head;\\n    head=pointer;\\n    return rotateRight(head,k-1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1422635,
                "title": "0ms-100-c-solution-with-clear-explanation",
                "content": "```\\nstruct ListNode* rotateRight(struct ListNode* head, int k){\\n     if (!head || !head->next || !k ) return head;\\n \\n    // find the tail, compute the len to find k.\\n    // since were not iterate the whole list to NULL\\n    // len starts from 1.\\n    int len = 1;\\n    struct ListNode *curr = head;\\n    while (curr->next != NULL) {\\n        len++;\\n        curr = curr->next;\\n    }\\n    // Now curr points to last node, circle the list.\\n    curr->next = head;\\n    // Find the rotate position.\\n    int position = len - k % len;\\n    for (int i = 0; i < position; i++) {\\n        // Since list is circled, move the curr to position.\\n        curr = curr->next;\\n    } \\n    // Since the list is circled, change head to (position+1)th node.\\n    head = curr->next;\\n    // Change the next of curr node to NULL to uncircle the list.\\n    curr->next = NULL;\\n    return head;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstruct ListNode* rotateRight(struct ListNode* head, int k){\\n     if (!head || !head->next || !k ) return head;\\n \\n    // find the tail, compute the len to find k.\\n    // since were not iterate the whole list to NULL\\n    // len starts from 1.\\n    int len = 1;\\n    struct ListNode *curr = head;\\n    while (curr->next != NULL) {\\n        len++;\\n        curr = curr->next;\\n    }\\n    // Now curr points to last node, circle the list.\\n    curr->next = head;\\n    // Find the rotate position.\\n    int position = len - k % len;\\n    for (int i = 0; i < position; i++) {\\n        // Since list is circled, move the curr to position.\\n        curr = curr->next;\\n    } \\n    // Since the list is circled, change head to (position+1)th node.\\n    head = curr->next;\\n    // Change the next of curr node to NULL to uncircle the list.\\n    curr->next = NULL;\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1383821,
                "title": "java-solution-beats-100-in-time-and-93-in-memory",
                "content": "Java Solution \\nBeats 100% in time and 93% in memory.\\n\\n\\n```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        // handle the edge cases\\n        if (head == null) return null;\\n        //iterating pointer\\n        ListNode itr = head;\\n        //length of list\\n        int len = 1;\\n        //get the length of the list and set last nodes pointer to head.\\n        while(itr.next != null){\\n            len++;\\n            itr = itr.next;\\n        }\\n        //set the pointer to head\\n        itr.next = head;\\n        //reset pointer\\n        itr = head;\\n        //mathematical formula to determine where the head should be pointing\\n        int headpointer = len + 1 - (k%len);\\n        //travel to the node previous to headpointer\\n        for(int i = 1; i < headpointer -1; i++){\\n            itr = itr.next;\\n        }\\n        //set the curr node as head node and prev nodes next pointer to null to break the cycle.\\n        head = itr.next;\\n        itr.next = null;\\n        return head;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        // handle the edge cases\\n        if (head == null) return null;\\n        //iterating pointer\\n        ListNode itr = head;\\n        //length of list\\n        int len = 1;\\n        //get the length of the list and set last nodes pointer to head.\\n        while(itr.next != null){\\n            len++;\\n            itr = itr.next;\\n        }\\n        //set the pointer to head\\n        itr.next = head;\\n        //reset pointer\\n        itr = head;\\n        //mathematical formula to determine where the head should be pointing\\n        int headpointer = len + 1 - (k%len);\\n        //travel to the node previous to headpointer\\n        for(int i = 1; i < headpointer -1; i++){\\n            itr = itr.next;\\n        }\\n        //set the curr node as head node and prev nodes next pointer to null to break the cycle.\\n        head = itr.next;\\n        itr.next = null;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354375,
                "title": "c-easy-solution-optimal",
                "content": "```\\nListNode* rotateRight(ListNode* head, int k) {\\n        \\n        if( head == NULL || head->next == NULL ) return head;\\n        \\n        \\n        ListNode *temp = head;\\n        int len = 1;\\n        while( temp->next && ++len ){\\n            temp = temp->next;\\n         }\\n        \\n        \\n        //point last node to first node \\n        temp->next = head;\\n        int actual_rotation = k%len;\\n        actual_rotation = len - actual_rotation;\\n        \\n        while( actual_rotation-- ){\\n            temp = temp->next;\\n        }\\n        \\n        head = temp->next;\\n        temp->next = NULL;\\n        return head;\\n    }\\n```\\n\\nIdea is to make circular linked list and then singly linked list. If you got any query feel free to ask query.And if you like my solution please upvote.",
                "solutionTags": [],
                "code": "```\\nListNode* rotateRight(ListNode* head, int k) {\\n        \\n        if( head == NULL || head->next == NULL ) return head;\\n        \\n        \\n        ListNode *temp = head;\\n        int len = 1;\\n        while( temp->next && ++len ){\\n            temp = temp->next;\\n         }\\n        \\n        \\n        //point last node to first node \\n        temp->next = head;\\n        int actual_rotation = k%len;\\n        actual_rotation = len - actual_rotation;\\n        \\n        while( actual_rotation-- ){\\n            temp = temp->next;\\n        }\\n        \\n        head = temp->next;\\n        temp->next = NULL;\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1337323,
                "title": "0-ms-c-100-simple-and-intuitive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head == NULL or head->next == NULL){\\n            return head;\\n        }\\n        \\n        int len = 0, rotation = 0;\\n        ListNode* temp = head;\\n        while(temp != NULL){\\n            len++;\\n            temp = temp->next;\\n        }\\n        \\n        k = k % len;\\n        \\n        ListNode *preTail = head, *tail = head;\\n        for(int i = 0; i < k; i++){\\n            while(tail->next != NULL){\\n                preTail = tail;\\n                tail = tail->next;\\n            }\\n            preTail->next = NULL;\\n            tail->next = head;\\n            head = tail;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head == NULL or head->next == NULL){\\n            return head;\\n        }\\n        \\n        int len = 0, rotation = 0;\\n        ListNode* temp = head;\\n        while(temp != NULL){\\n            len++;\\n            temp = temp->next;\\n        }\\n        \\n        k = k % len;\\n        \\n        ListNode *preTail = head, *tail = head;\\n        for(int i = 0; i < k; i++){\\n            while(tail->next != NULL){\\n                preTail = tail;\\n                tail = tail->next;\\n            }\\n            preTail->next = NULL;\\n            tail->next = head;\\n            head = tail;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1184214,
                "title": "python-3-simple-2-pointers-approach-w-comments",
                "content": "**IDEA**\\nIdea here is to first compute the length of list and maintain 2 pointers -  one at (length-k) node and other at tail node. Now,\\n1. Attach the tail node to head node.\\n2. Make the next node to (length-k)th node as the new head node.\\n3. Make the next of (length-k)th node None.\\n\\n**CAUTION**\\n**Avoid rotating each and every node k number of times in a loop. This wil cause TLE.**\\n\\n```\\nclass Solution:\\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        # Base case\\n\\t\\tif head is None or head.next is None:\\n            return head\\n        \\n\\t\\t# Compute the length of list and maintain a pointer for the tail of list.\\n        curr = head\\n        length = 0\\n        while curr.next is not None:\\n            length += 1\\n            curr = curr.next\\n        length += 1\\n        \\n\\t\\t# No. of rotations cannot be greater than the length of list. Hence, the modulo operation.\\n        k = k%length\\n        \\n\\t\\t# Return head if k is equal to 0 or the length of list i.e. no rotation case.\\n        if k == length or k == 0:\\n            return head\\n           \\n\\t\\t# Maintain a pointer for the (length-k)th node.\\n        prev = head\\n        for i in range(1, length-k):\\n            prev = prev.next\\n\\t\\t\\t\\n\\t\\t# Perform the 3 step operation given in the Idea section.\\n        curr.next = head\\n        head = prev.next\\n        prev.next = None\\n\\t\\t\\n        return head\\n            \\n```\\n\\nFeel free to comment down your answers or post your query, doubt or question :)",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        # Base case\\n\\t\\tif head is None or head.next is None:\\n            return head\\n        \\n\\t\\t# Compute the length of list and maintain a pointer for the tail of list.\\n        curr = head\\n        length = 0\\n        while curr.next is not None:\\n            length += 1\\n            curr = curr.next\\n        length += 1\\n        \\n\\t\\t# No. of rotations cannot be greater than the length of list. Hence, the modulo operation.\\n        k = k%length\\n        \\n\\t\\t# Return head if k is equal to 0 or the length of list i.e. no rotation case.\\n        if k == length or k == 0:\\n            return head\\n           \\n\\t\\t# Maintain a pointer for the (length-k)th node.\\n        prev = head\\n        for i in range(1, length-k):\\n            prev = prev.next\\n\\t\\t\\t\\n\\t\\t# Perform the 3 step operation given in the Idea section.\\n        curr.next = head\\n        head = prev.next\\n        prev.next = None\\n\\t\\t\\n        return head\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1180024,
                "title": "python-simplest-solution-100-faster",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        \\n        if head is None or head.next is None:\\n            return head\\n        \\n        length=0\\n        start=head\\n        prev=None\\n        \\n        while start :\\n            \\n            length+=1\\n            prev=start\\n            start=start.next\\n        \\n        k=k%length\\n        \\n        if k==length or k==0:\\n            return head \\n        \\n        \\n        prev.next=head\\n        prev=None\\n        \\n      \\n        \\n        for i in range(length-k):\\n            prev=head\\n            head=head.next\\n        \\n        prev.next=None\\n        \\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        \\n        if head is None or head.next is None:\\n            return head\\n        \\n        length=0\\n        start=head\\n        prev=None\\n        \\n        while start :\\n            \\n            length+=1\\n            prev=start\\n            start=start.next\\n        \\n        k=k%length\\n        \\n        if k==length or k==0:\\n            return head \\n        \\n        \\n        prev.next=head\\n        prev=None\\n        \\n      \\n        \\n        for i in range(length-k):\\n            prev=head\\n            head=head.next\\n        \\n        prev.next=None\\n        \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156321,
                "title": "c-solution-with-explanation",
                "content": "\\n To rotate element right by k places we first attach head to last node of head.\\n then we will make the head as node at n-k+1 position and assign null to the node at n-k position.\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n       //If head is null return empty.\\n        if(!head) return NULL;\\n        \\n        ListNode* temp = head,*ans = head;\\n        //Find the size, here we do size is 1 as we will go from first node to second last node. The loop will not run for last node\\n        int size=1;\\n        while(head->next){ \\n            head=head->next;\\n            size++;\\n        }\\n        \\n        // Now we assign first element to the last node\\n        head->next=temp;\\n        //We use this since if k is greater than size rotation will be same as remainder of k%size\\n        k=k%size;\\n        //We do size-k-1 since we need to stop at a mode earlier to node at position n-k+1. Since we have to make it null.\\n        k=size-k-1;\\n        while(k>0){\\n            ans=ans->next;\\n            k--;\\n        }\\n        //\\n        temp = ans;\\n        ans=ans->next;\\n        temp->next=NULL;\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n       //If head is null return empty.\\n        if(!head) return NULL;\\n        \\n        ListNode* temp = head,*ans = head;\\n        //Find the size, here we do size is 1 as we will go from first node to second last node. The loop will not run for last node\\n        int size=1;\\n        while(head->next){ \\n            head=head->next;\\n            size++;\\n        }\\n        \\n        // Now we assign first element to the last node\\n        head->next=temp;\\n        //We use this since if k is greater than size rotation will be same as remainder of k%size\\n        k=k%size;\\n        //We do size-k-1 since we need to stop at a mode earlier to node at position n-k+1. Since we have to make it null.\\n        k=size-k-1;\\n        while(k>0){\\n            ans=ans->next;\\n            k--;\\n        }\\n        //\\n        temp = ans;\\n        ans=ans->next;\\n        temp->next=NULL;\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1100806,
                "title": "c-easy-solution-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head) return NULL;\\n        ListNode* ans = head;\\n        int size=1;\\n        while(head->next){ \\n            head=head->next;\\n            size++;\\n        }\\n        head->next=ans;\\n        k=k%size;\\n        k=size-k;\\n        while(--k>0){\\n            ans=ans->next;\\n        }\\n        head = ans;\\n        ans=ans->next;\\n        head->next=NULL;\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head) return NULL;\\n        ListNode* ans = head;\\n        int size=1;\\n        while(head->next){ \\n            head=head->next;\\n            size++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 919353,
                "title": "faster-than-99-56-of-python3-memory-usage-less-than-100-00-of-python3",
                "content": "The thing you should notice here is to rotate a list k time, you only need to cut the last (k % list_length) element of that list and bring it to the front.\\nBellow is the solution by using two pointer approach.\\n\\n```\\nclass Solution:\\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        c, h = 0, head\\n        while h is not None:\\n            c += 1\\n            h = h.next\\n        if c == 0 or k % c == 0:\\n            return head\\n        k = k % c\\n        s, f = head, head\\n        for _ in range(k):\\n            f = f.next\\n        while f.next is not None:\\n            f = f.next\\n            s = s.next\\n        nh = s.next\\n        s.next = None\\n        f.next = head\\n        return nh\\n\\t\\t\\n",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "The thing you should notice here is to rotate a list k time, you only need to cut the last (k % list_length) element of that list and bring it to the front.\\nBellow is the solution by using two pointer approach.\\n\\n```\\nclass Solution:\\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        c, h = 0, head\\n        while h is not None:\\n            c += 1\\n            h = h.next\\n        if c == 0 or k % c == 0:\\n            return head\\n        k = k % c\\n        s, f = head, head\\n        for _ in range(k):\\n            f = f.next\\n        while f.next is not None:\\n            f = f.next\\n            s = s.next\\n        nh = s.next\\n        s.next = None\\n        f.next = head\\n        return nh\\n\\t\\t\\n",
                "codeTag": "Java"
            },
            {
                "id": 885653,
                "title": "modular-rust-solution-60-lines-of-code",
                "content": "Since the linked list is built with `Box<T>` instead of `Rc<RefCell<T>>`, the compiler will not allow an ownership cycle. So we have to break the list in two before adding the extra link. We transfer ownership between temporary variables with `take()` (`Option<T>::take(&mut self) -> Option<T>`).\\n\\n```\\n/*\\n// Definition for singly-linked list.\\n#[derive(PartialEq, Eq, Clone, Debug)]\\npub struct ListNode {\\n    pub val: i32,\\n    pub next: Option<Box<ListNode>>,\\n}\\n\\nimpl ListNode {\\n    #[inline]\\n    pub fn new(val: i32) -> Self {\\n        ListNode { next: None, val }\\n    }\\n}\\n\\npub struct Solution;\\n*/\\n\\ntype Node = ListNode;\\n\\ntype Link = Option<Box<Node>>;\\n\\nimpl Solution {\\n    pub fn rotate_right(head: Link, k: i32) -> Link {\\n        let mut list = List { head };\\n        list.rotate(k as isize);\\n        list.head\\n    }\\n}\\n\\nstruct List {\\n    head: Link,\\n}\\n\\nimpl List {\\n    fn rotate(&mut self, k: isize) {\\n        let n = self.len();\\n        if n == 0 {\\n            return;\\n        }\\n        let k = k.rem_euclid(n as isize) as usize;\\n        if k == 0 {\\n            return;\\n        }\\n\\n        debug_assert!(0 < k && k < n);\\n\\n        let mut old_head = self.head.take().unwrap();\\n\\n        let new_tail = old_head.get_node(n - k - 1).unwrap();\\n        let mut new_head = new_tail.next.take().unwrap();\\n        let tail = new_head.get_node(k - 1).unwrap();\\n        tail.next = Some(old_head);\\n\\n        self.head = Some(new_head);\\n    }\\n\\n    fn len(&self) -> usize {\\n        let mut count = 0;\\n        let mut link = &self.head;\\n        while let Some(node) = link {\\n            count += 1;\\n            link = &node.next;\\n        }\\n        count\\n    }\\n}\\n\\nimpl Node {\\n    /// Walk `i` steps forward in the linked list.\\n    fn get_node(&mut self, i: usize) -> Option<&mut Node> {\\n        let mut node = self;\\n        for _ in 0..i {\\n            node = node.next.as_mut()?;\\n        }\\n        Some(node)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Linked List"
                ],
                "code": "```\\n/*\\n// Definition for singly-linked list.\\n#[derive(PartialEq, Eq, Clone, Debug)]\\npub struct ListNode {\\n    pub val: i32,\\n    pub next: Option<Box<ListNode>>,\\n}\\n\\nimpl ListNode {\\n    #[inline]\\n    pub fn new(val: i32) -> Self {\\n        ListNode { next: None, val }\\n    }\\n}\\n\\npub struct Solution;\\n*/\\n\\ntype Node = ListNode;\\n\\ntype Link = Option<Box<Node>>;\\n\\nimpl Solution {\\n    pub fn rotate_right(head: Link, k: i32) -> Link {\\n        let mut list = List { head };\\n        list.rotate(k as isize);\\n        list.head\\n    }\\n}\\n\\nstruct List {\\n    head: Link,\\n}\\n\\nimpl List {\\n    fn rotate(&mut self, k: isize) {\\n        let n = self.len();\\n        if n == 0 {\\n            return;\\n        }\\n        let k = k.rem_euclid(n as isize) as usize;\\n        if k == 0 {\\n            return;\\n        }\\n\\n        debug_assert!(0 < k && k < n);\\n\\n        let mut old_head = self.head.take().unwrap();\\n\\n        let new_tail = old_head.get_node(n - k - 1).unwrap();\\n        let mut new_head = new_tail.next.take().unwrap();\\n        let tail = new_head.get_node(k - 1).unwrap();\\n        tail.next = Some(old_head);\\n\\n        self.head = Some(new_head);\\n    }\\n\\n    fn len(&self) -> usize {\\n        let mut count = 0;\\n        let mut link = &self.head;\\n        while let Some(node) = link {\\n            count += 1;\\n            link = &node.next;\\n        }\\n        count\\n    }\\n}\\n\\nimpl Node {\\n    /// Walk `i` steps forward in the linked list.\\n    fn get_node(&mut self, i: usize) -> Option<&mut Node> {\\n        let mut node = self;\\n        for _ in 0..i {\\n            node = node.next.as_mut()?;\\n        }\\n        Some(node)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 883145,
                "title": "rotate-list-python-99-6",
                "content": "```\\nclass Solution:\\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        if not head:\\n            return head\\n        dic={1:head}\\n        length=1\\n        node=head\\n        while node.next:\\n            length+=1\\n            node=node.next\\n            dic[length]=node\\n\\n        rotate=k%length\\n        if not rotate:\\n            return head\\n        dic[length-rotate].next=None\\n        dic[length].next=head\\n        return dic[length-rotate+1]\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        if not head:\\n            return head\\n        dic={1:head}\\n        length=1\\n        node=head\\n        while node.next:\\n            length+=1\\n            node=node.next\\n            dic[length]=node\\n\\n        rotate=k%length\\n        if not rotate:\\n            return head\\n        dic[length-rotate].next=None\\n        dic[length].next=head\\n        return dic[length-rotate+1]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 883079,
                "title": "c-o-n-solution-with-explanations",
                "content": "**The main idea is to iterate the list till we get to the node that will be the head after rotating, and to then take that part from new head till tail and reconnect it to previous head**\\n\\nif helpful please upvote\\n```\\n\\nstruct ListNode* rotateRight(struct ListNode* head, int k)\\n{\\n        struct ListNode* iter = head, *prev, *iter2;\\n    \\n        // if list needs no rotation or head is null (checking these conditions makes the solution more efficient)\\n        if (k == 0 || !head)\\n\\t\\t\\treturn head;\\n    \\n        // counting number of nodes in list\\n        size_t num_nodes = 0;\\n        while (iter)\\n        {\\n            iter = iter->next;\\n            num_nodes++;\\n        }\\n    \\n        // if there is one node in list or after rotation the list will be same as given list then there is no need to rotate list \\n\\t    // (checking these conditions makes the solution more efficient)\\n        if (num_nodes == 1 || k % num_nodes == 0)\\n\\t\\t\\treturn head;\\n    \\n        // rotating:\\n\\t\\t\\n        iter = head;\\n        k %= num_nodes;\\n\\t\\t// find node that will be head\\n        while (num_nodes - k)\\n        {\\n            prev = iter;\\n            iter = iter->next;\\n            num_nodes--;\\n        }\\n        prev->next = NULL;\\n\\t\\t// attach the previous tail to the previous head\\n        iter2 = iter;\\n\\t\\t\\n        while (iter2->next)\\n\\t\\t\\titer2 = iter2->next;\\n\\t\\t\\n        iter2->next = head;\\n        head = iter;\\n    \\n        return head;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nstruct ListNode* rotateRight(struct ListNode* head, int k)\\n{\\n        struct ListNode* iter = head, *prev, *iter2;\\n    \\n        // if list needs no rotation or head is null (checking these conditions makes the solution more efficient)\\n        if (k == 0 || !head)\\n\\t\\t\\treturn head;\\n    \\n        // counting number of nodes in list\\n        size_t num_nodes = 0;\\n        while (iter)\\n        {\\n            iter = iter->next;\\n            num_nodes++;\\n        }\\n    \\n        // if there is one node in list or after rotation the list will be same as given list then there is no need to rotate list \\n\\t    // (checking these conditions makes the solution more efficient)\\n        if (num_nodes == 1 || k % num_nodes == 0)\\n\\t\\t\\treturn head;\\n    \\n        // rotating:\\n\\t\\t\\n        iter = head;\\n        k %= num_nodes;\\n\\t\\t// find node that will be head\\n        while (num_nodes - k)\\n        {\\n            prev = iter;\\n            iter = iter->next;\\n            num_nodes--;\\n        }\\n        prev->next = NULL;\\n\\t\\t// attach the previous tail to the previous head\\n        iter2 = iter;\\n\\t\\t\\n        while (iter2->next)\\n\\t\\t\\titer2 = iter2->next;\\n\\t\\t\\n        iter2->next = head;\\n        head = iter;\\n    \\n        return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 829575,
                "title": "python-o-n",
                "content": "O(kn) if we do it naively, rotating the list k times. We notice that the list rotation is modular in fashion. That is, given the length of the list n, there can be at most k % n rotations. As a result, we can reduce the problem down to O((k % n)n). k %n is some constant << k, so the solution is O(n).\\n\\n```\\ndef rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        prev = None\\n        cur = head\\n        \\n        if not head or not head.next:\\n            return head\\n        \\n        # first get length of list\\n        length = 0\\n        while cur:\\n            length += 1\\n            cur = cur.next\\n        cur = head\\n        \\n        for i in range(k % length):\\n            while cur.next:\\n                prev = cur\\n                cur = cur.next\\n            cur.next = head\\n            head = cur\\n            prev.next = None\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\ndef rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        prev = None\\n        cur = head\\n        \\n        if not head or not head.next:\\n            return head\\n        \\n        # first get length of list\\n        length = 0\\n        while cur:\\n            length += 1\\n            cur = cur.next\\n        cur = head\\n        \\n        for i in range(k % length):\\n            while cur.next:\\n                prev = cur\\n                cur = cur.next\\n            cur.next = head\\n            head = cur\\n            prev.next = None\\n        return head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 721448,
                "title": "python-fast-solution",
                "content": "Python fast solution\\n```\\n    length = 1\\n    node = head\\n    while node.next:\\n        node = node.next\\n        length += 1\\n    tail = node\\n\\n    offset = abs(k) % length\\n\\tif offset == 0:\\n        return head\\n\\n    new_tail_position = length - offset if k > 0 else offset\\n\\t\\t\\n    counter = 1\\n    node = head\\n    while node.next:\\n        if counter ==new_tail_position:\\n            final_tail = node\\n            break\\n        node = node.next\\n        counter += 1\\n\\n    tail.next = head\\n    head = final_tail.next\\n    final_tail.next = None\\n\\n    return head\\n```",
                "solutionTags": [],
                "code": "```\\n    length = 1\\n    node = head\\n    while node.next:\\n        node = node.next\\n        length += 1\\n    tail = node\\n\\n    offset = abs(k) % length\\n\\tif offset == 0:\\n        return head\\n\\n    new_tail_position = length - offset if k > 0 else offset\\n\\t\\t\\n    counter = 1\\n    node = head\\n    while node.next:\\n        if counter ==new_tail_position:\\n            final_tail = node\\n            break\\n        node = node.next\\n        counter += 1\\n\\n    tail.next = head\\n    head = final_tail.next\\n    final_tail.next = None\\n\\n    return head\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 687535,
                "title": "swift-rotate-list-with-comments",
                "content": "```\\nclass Solution {\\n    func rotateRight(_ head: ListNode?, _ k: Int) -> ListNode? {\\n        if head == nil {\\n            return head\\n        }\\n        // To get length of list\\n        var length = 1\\n        // To find tail of list\\n        var tail : ListNode? = head \\n        \\n        while tail?.next !=  nil {\\n            length += 1\\n            tail = tail?.next\\n        }\\n        // if K == length in that case we have to rotate entire list to return same original list\\n        var k =  k % length\\n        if k == 0 {\\n            return head\\n        }\\n        \\n        // Steps to find new head will be length - k \\n        var stepsToNewHead = length - k\\n        \\n        // Connet Tail to head to form cycle list\\n        tail?.next = head\\n        \\n        // Find New tail after rotating stepsToNewHead th time\\n        var newTail = tail\\n        \\n        while stepsToNewHead > 0 {\\n            stepsToNewHead -= 1\\n            newTail = newTail?.next\\n        }\\n        // New head\\n        let newHead = newTail?.next\\n        // Break cycle\\n        newTail?.next = nil\\n        \\n        return newHead\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func rotateRight(_ head: ListNode?, _ k: Int) -> ListNode? {\\n        if head == nil {\\n            return head\\n        }\\n        // To get length of list\\n        var length = 1\\n        // To find tail of list\\n        var tail : ListNode? = head \\n        \\n        while tail?.next !=  nil {\\n            length += 1\\n            tail = tail?.next\\n        }\\n        // if K == length in that case we have to rotate entire list to return same original list\\n        var k =  k % length\\n        if k == 0 {\\n            return head\\n        }\\n        \\n        // Steps to find new head will be length - k \\n        var stepsToNewHead = length - k\\n        \\n        // Connet Tail to head to form cycle list\\n        tail?.next = head\\n        \\n        // Find New tail after rotating stepsToNewHead th time\\n        var newTail = tail\\n        \\n        while stepsToNewHead > 0 {\\n            stepsToNewHead -= 1\\n            newTail = newTail?.next\\n        }\\n        // New head\\n        let newHead = newTail?.next\\n        // Break cycle\\n        newTail?.next = nil\\n        \\n        return newHead\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685024,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def rotateRight(self, head: \\'ListNode\\', k: \\'int\\') -> \\'ListNode\\':\\n        \\n        ## RC ##\\n        ## APPROACH  : LINKED LIST ##\\n        ## 1. Find first length of the linkedlist.\\n        ## 2. when you found that next node is null while doing 1, make it a circular linked list, connecting it to head\\n        ## 3. Now move n - k positions forward and break the circle.\\n        ## 4. step 3 can be reduced to (n-k) % (n - 1)\\n        \\n        if not head or not head.next:\\n            return head\\n        \\n        old_tail = head\\n        n = 1\\n        while old_tail.next:\\n            old_tail = old_tail.next\\n            n += 1\\n        old_tail.next = head\\n        \\n        new_tail = head\\n        for i in range(n - k % n - 1):\\n            new_tail = new_tail.next\\n        new_head = new_tail.next\\n        \\n        new_tail.next = None\\n        return new_head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotateRight(self, head: \\'ListNode\\', k: \\'int\\') -> \\'ListNode\\':\\n        \\n        ## RC ##\\n        ## APPROACH  : LINKED LIST ##\\n        ## 1. Find first length of the linkedlist.\\n        ## 2. when you found that next node is null while doing 1, make it a circular linked list, connecting it to head\\n        ## 3. Now move n - k positions forward and break the circle.\\n        ## 4. step 3 can be reduced to (n-k) % (n - 1)\\n        \\n        if not head or not head.next:\\n            return head\\n        \\n        old_tail = head\\n        n = 1\\n        while old_tail.next:\\n            old_tail = old_tail.next\\n            n += 1\\n        old_tail.next = head\\n        \\n        new_tail = head\\n        for i in range(n - k % n - 1):\\n            new_tail = new_tail.next\\n        new_head = new_tail.next\\n        \\n        new_tail.next = None\\n        return new_head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 509348,
                "title": "python3-o-n-time",
                "content": "```\\nclass Solution:\\n    \\n    def get_length(self,head):\\n        count = 0\\n        while head:\\n            count+=1\\n            head = head.next\\n        return count\\n    \\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        length = self.get_length(head)\\n        if length==0:\\n            return head\\n        k = k%length\\n        if k==0:\\n            return head\\n        temp = head\\n        i = 0\\n        while i<length-k-1:\\n            temp = temp.next\\n            i+=1\\n        next = temp.next\\n        temp.next = None\\n        temp = next\\n        while temp.next:\\n            temp = temp.next\\n        temp.next = head\\n        return next\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def get_length(self,head):\\n        count = 0\\n        while head:\\n            count+=1\\n            head = head.next\\n        return count\\n    \\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        length = self.get_length(head)\\n        if length==0:\\n            return head\\n        k = k%length\\n        if k==0:\\n            return head\\n        temp = head\\n        i = 0\\n        while i<length-k-1:\\n            temp = temp.next\\n            i+=1\\n        next = temp.next\\n        temp.next = None\\n        temp = next\\n        while temp.next:\\n            temp = temp.next\\n        temp.next = head\\n        return next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 330145,
                "title": "easy-and-clean-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL) return head;\\n        \\n        //first,calculate the length of list        \\n        int len = 1;\\n        ListNode *p = head;\\n        while(p->next!=NULL)\\n        {\\n            len++;\\n            p = p->next;\\n        }\\n        \\n        //second,connect tail to head\\n        p->next = head;\\n        \\n        int forward_step = len - k%len;\\n        \\n        //third,forward in the circle. backward k step is equal to forward len-k step.And we can only forward.\\n        for(int i=0; i<forward_step;i++)\\n            p = p->next;  //finally, p is the pointer pointing to hte previous node of the head we want\\n        \\n        head = p->next;\\n        p->next = NULL;\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL) return head;\\n        \\n        //first,calculate the length of list        \\n        int len = 1;\\n        ListNode *p = head;\\n        while(p->next!=NULL)\\n        {\\n            len++;\\n            p = p->next;\\n        }\\n        \\n        //second,connect tail to head\\n        p->next = head;\\n        \\n        int forward_step = len - k%len;\\n        \\n        //third,forward in the circle. backward k step is equal to forward len-k step.And we can only forward.\\n        for(int i=0; i<forward_step;i++)\\n            p = p->next;  //finally, p is the pointer pointing to hte previous node of the head we want\\n        \\n        head = p->next;\\n        p->next = NULL;\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312039,
                "title": "swift-99-beat-o-n-linear-speed-must-traverse-whole-list",
                "content": "```\\nclass Solution {\\n    func rotateRight(_ head: ListNode?, _ k: Int) -> ListNode? {\\n        \\n        if head == nil { return nil }\\n        \\n        var tail: ListNode?\\n        var node = head\\n        var count = 0\\n        while node != nil {\\n            tail = node\\n            node = node!.next\\n            count += 1\\n        }\\n        \\n        var k = k % count\\n        if k == 0 { return head }\\n        \\n        var slice = count - k\\n        \\n        var prev: ListNode?\\n        node = head\\n        while slice > 0 {\\n            prev = node\\n            node = node!.next\\n            slice -= 1\\n        }\\n        \\n        prev!.next = nil\\n        tail!.next = head \\n        return node\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func rotateRight(_ head: ListNode?, _ k: Int) -> ListNode? {\\n        \\n        if head == nil { return nil }\\n        \\n        var tail: ListNode?\\n        var node = head\\n        var count = 0\\n        while node != nil {\\n            tail = node\\n            node = node!.next\\n            count += 1\\n        }\\n        \\n        var k = k % count\\n        if k == 0 { return head }\\n        \\n        var slice = count - k\\n        \\n        var prev: ListNode?\\n        node = head\\n        while slice > 0 {\\n            prev = node\\n            node = node!.next\\n            slice -= 1\\n        }\\n        \\n        prev!.next = nil\\n        tail!.next = head \\n        return node\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309400,
                "title": "easiest-java-beats-100",
                "content": "```java\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head == null || head.next == null) return head;\\n        int count = 1;\\n        ListNode runner = head;\\n        for(; runner.next != null; runner = runner.next, count++);\\n        runner.next = head;\\n        k = count - (k % count);\\n        for(int i=1; i<=k; i++, runner = runner.next);\\n        head = runner.next;\\n        runner.next = null;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head == null || head.next == null) return head;\\n        int count = 1;\\n        ListNode runner = head;\\n        for(; runner.next != null; runner = runner.next, count++);\\n        runner.next = head;\\n        k = count - (k % count);\\n        for(int i=1; i<=k; i++, runner = runner.next);\\n        head = runner.next;\\n        runner.next = null;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22714,
                "title": "rotate-list-solution-in-c-in-o-n-linear-time-and-o-1-constant-space-complexity",
                "content": "'''\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        \\n        if (!head || !head->next || k == 0)\\n            return head;\\n        ListNode* temp = head;\\n        ListNode* curr = head;\\n        ListNode* headN = head;\\n        int n = 0;\\n        \\n        while (temp) {\\n            temp = temp->next;\\n            n++;\\n        }\\n        \\n        int shift = (n - k % n) - 1;\\n        \\n        while (shift) {\\n            curr = curr->next;\\n            shift--;\\n        }\\n        \\n        ListNode* KthNode = curr;\\n\\n        while (curr->next)\\n            curr = curr->next;\\n        \\n        curr->next = head;\\n        headN = KthNode->next;\\n        KthNode->next = NULL;\\n        \\n        return headN;\\n    }\\n};\\n'''",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        \\n        if (!head || !head->next || k == 0)\\n            return head;\\n        ListNode* temp = head;\\n        ListNode* curr = head;\\n        ListNode* headN = head;\\n        int n = 0;\\n        \\n        while (temp) {\\n            temp = temp->next;\\n            n++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 22796,
                "title": "python-solution-only-go-through-ll-once",
                "content": "This one requires extra memory space to store refs to all nodes, but no need to iterate through it again.\\n\\n\\n```\\nclass Solution(object):\\n    def rotateRight(self, head, k):\\n        \"\"\"\\n        :type head: ListNode\\n        :type k: int\\n        :rtype: ListNode\\n        \"\"\"\\n        if head is None:\\n            return None\\n        if head.next is None:\\n            return head\\n        nodes = []\\n        p = ListNode(None)\\n        p.next = head\\n        q = p\\n        while q.next is not None:\\n            q = q.next\\n            nodes.append(q)\\n        k %= len(nodes)\\n        if k == 0:\\n            return head\\n        newHead = nodes[-k]\\n        nodes[-k - 1].next = None\\n        nodes[-1].next = head\\n        return newHead\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def rotateRight(self, head, k):\\n        \"\"\"\\n        :type head: ListNode\\n        :type k: int\\n        :rtype: ListNode\\n        \"\"\"\\n        if head is None:\\n            return None\\n        if head.next is None:\\n            return head\\n        nodes = []\\n        p = ListNode(None)\\n        p.next = head\\n        q = p\\n        while q.next is not None:\\n            q = q.next\\n            nodes.append(q)\\n        k %= len(nodes)\\n        if k == 0:\\n            return head\\n        newHead = nodes[-k]\\n        nodes[-k - 1].next = None\\n        nodes[-1].next = head\\n        return newHead\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22818,
                "title": "c-12-ms-solution",
                "content": "    class Solution {\\n    public:\\n        ListNode* rotateRight(ListNode* head, int k) {\\n            if(head == NULL || head->next == NULL) return head;\\n            ListNode *tail;\\n            int n=1,j;\\n            for(tail = head;tail->next!=NULL;tail=tail->next) n++;\\n            j = (n-k%n)%n;\\n            tail->next = head;\\n            for(int i=0;i<j;i++){\\n                head = head->next;\\n                tail = tail->next;\\n            }\\n            tail->next = NULL;\\n            return head;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* rotateRight(ListNode* head, int k) {\\n            if(head == NULL || head->next == NULL) return head;\\n            ListNode *tail;\\n            int n=1,j;\\n            for(tail = head;tail->next!=NULL;tail=tail->next) n++;\\n            j = (n-k%n)%n;\\n            tail->next = head;\\n            for(int i=0;i<j;i++){\\n                head = head->next;\\n                tail = tail->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 22885,
                "title": "simple-java-solution",
                "content": "\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if (head == null) return head;\\n        k = k % getLen(head);\\n        ListNode p1 = new ListNode(0);\\n        ListNode p2 = new ListNode(0);\\n        p1.next = head;\\n        p2.next = head;\\n        for (int i = 0; i < k; i++) {\\n            p2 = p2.next;\\n        }\\n        while (p2.next != null) {\\n            p1 = p1.next;\\n            p2 = p2.next;\\n        }\\n        p2.next = head;\\n        ListNode res = p1.next;\\n        p1.next = null;\\n        return res;\\n    }\\n    \\n    private int getLen(ListNode node) {\\n        int count = 0;\\n        while (node != null) {\\n            count++;\\n            node = node.next;\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if (head == null) return head;\\n        k = k % getLen(head);\\n        ListNode p1 = new ListNode(0);\\n        ListNode p2 = new ListNode(0);\\n        p1.next = head;\\n        p2.next = head;\\n        for (int i = 0; i < k; i++) {\\n            p2 = p2.next;\\n        }\\n        while (p2.next != null) {\\n            p1 = p1.next;\\n            p2 = p2.next;\\n        }\\n        p2.next = head;\\n        ListNode res = p1.next;\\n        p1.next = null;\\n        return res;\\n    }\\n    \\n    private int getLen(ListNode node) {\\n        int count = 0;\\n        while (node != null) {\\n            count++;\\n            node = node.next;\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 22910,
                "title": "simple-java-solution-with-explanation",
                "content": " My idea is, first concat the tail to the head, building a cycle, then decide where to break the cycle to get the resulting list. The advantage of the method is, you dont need to worry about n being larger than the length of the list.\\n\\n       public ListNode rotateRight(ListNode head, int n) {\\n            if (head == null) return null;\\n            ListNode tail = head;                       //first, build a cycle\\n            while (tail.next != null){\\n                tail = tail.next;\\n            }\\n            tail.next = head;                          //cycle built.\\n            ListNode fast = head, slow = head;         //now find where to break the cycle\\n            while (n-->0){\\n                fast = fast.next;                      //move the fast runner first\\n            }\\n            while (fast!=tail){\\n                fast = fast.next;                      //then move the fast and the slow runners together\\n                slow = slow.next;\\n            }\\n            head = slow.next;                          //break the cycle at after the slow runner\\n            slow.next = null;\\n            return head;                              // return the new head\\n        }",
                "solutionTags": [],
                "code": " My idea is, first concat the tail to the head, building a cycle, then decide where to break the cycle to get the resulting list. The advantage of the method is, you dont need to worry about n being larger than the length of the list.\\n\\n       public ListNode rotateRight(ListNode head, int n) {\\n            if (head == null) return null;\\n            ListNode tail = head;                       //first, build a cycle\\n            while (tail.next != null){\\n                tail = tail.next;\\n            }\\n            tail.next = head;                          //cycle built.\\n            ListNode fast = head, slow = head;         //now find where to break the cycle\\n            while (n-->0){\\n                fast = fast.next;                      //move the fast runner first\\n            }\\n            while (fast!=tail){\\n                fast = fast.next;                      //then move the fast and the slow runners together\\n                slow = slow.next;\\n            }\\n            head = slow.next;                          //break the cycle at after the slow runner\\n            slow.next = null;\\n            return head;                              // return the new head\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 4050522,
                "title": "rotate-list-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getlength(ListNode* head1)\\n    {\\n        int count=1;\\n        while(head1->next!=NULL)\\n        {\\n            count++;\\n            head1=head1->next;\\n        }\\n        return count;\\n    }\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next==NULL)return head;\\n        int l=getlength(head);\\n        k=k%l;\\n    for(int i=1;i<=k;i++)\\n    { \\n        ListNode* tail=head;\\n        ListNode* tailprev=NULL;\\n        while(tail->next!=NULL)\\n        {\\n            tailprev=tail;\\n            tail=tail->next;\\n\\n        }\\n        tail->next=head;\\n        tailprev->next=NULL;\\n        head=tail;\\n    }\\n    return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getlength(ListNode* head1)\\n    {\\n        int count=1;\\n        while(head1->next!=NULL)\\n        {\\n            count++;\\n            head1=head1->next;\\n        }\\n        return count;\\n    }\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next==NULL)return head;\\n        int l=getlength(head);\\n        k=k%l;\\n    for(int i=1;i<=k;i++)\\n    { \\n        ListNode* tail=head;\\n        ListNode* tailprev=NULL;\\n        while(tail->next!=NULL)\\n        {\\n            tailprev=tail;\\n            tail=tail->next;\\n\\n        }\\n        tail->next=head;\\n        tailprev->next=NULL;\\n        head=tail;\\n    }\\n    return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041577,
                "title": "best-python-solution-o-n-time-beats-90-two-pointers",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe create two pointers f and s initially we send f to k moves forward. If k exceeds the length of list then we take k % length to get the exact number of moves f should move. And finally we start moving both s and f until f reaches the end then just cut the list from s to f and attach it in the front :) \\n\\nComment down for more clarification and please Upvote if like the solution\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        if not head or not head.next or k==0:\\n            return head\\n        f = s = head\\n        count  = 0\\n        for i in range(k):\\n            count +=1\\n            if not f.next:\\n                f = s\\n                break\\n            f = f.next \\n        for i in range(k%count):\\n            f = f.next\\n        if f == s:\\n            return f\\n        while f.next:\\n            f = f.next\\n            s = s.next\\n        temp = s.next\\n        s.next = None\\n        f.next = head\\n        return temp\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        if not head or not head.next or k==0:\\n            return head\\n        f = s = head\\n        count  = 0\\n        for i in range(k):\\n            count +=1\\n            if not f.next:\\n                f = s\\n                break\\n            f = f.next \\n        for i in range(k%count):\\n            f = f.next\\n        if f == s:\\n            return f\\n        while f.next:\\n            f = f.next\\n            s = s.next\\n        temp = s.next\\n        s.next = None\\n        f.next = head\\n        return temp\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565004,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1582109,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1565003,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1940800,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1966760,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1565927,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1573278,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1572794,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1567829,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1568880,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1565004,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1582109,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1565003,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1940800,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1966760,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1565927,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1573278,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1572794,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1567829,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1568880,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1989135,
                "content": [
                    {
                        "username": "Akash_Verma2000",
                        "content": "FOLLOW THESE STEPS TO SOLVE THIS PROBLEM\\n //connect the tail to the head\\n        //figure out the optimum value of k BY K=K%length of list\\n        //pointer=length-k\\n        //travel till pointer\\n        //secure the ListNode at the next of the pointer in another ListNode \\n        //point the same to null"
                    },
                    {
                        "username": "Yashdahiya295",
                        "content": "OPTIMAL SOLUTION :C++\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next == NULL ||k==0)\\n     {\\n          return head ;\\n     }\\n\\n     //Compute the length of the linked list \\n     ListNode* cur = head ;\\n     int len = 1;\\n     while(cur->next!=NULL)\\n     {\\n          ++len ;\\n          cur = cur->next ;\\n     }\\n\\n     //Pointing the last node to the head;\\n     cur->next = head ;\\n     k = k % len ;//Like if we have 12 rotation and k = 5 then till 10 rotation its same as the original linked list , so we do this .\\n     k = len - k ; // So that we can able to know how much we have to traverse from the head .\\n     while(k--)\\n     {\\n          cur = cur->next ;\\n     }\\n\\n     //Make the node to the head and break the connection\\n     head = cur->next ;\\n     cur->next = NULL ;\\n\\n\\n     return head;\\n\\n    }\\n}; \\nTC : O(N). , SC: O(1).   "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Optimal rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jyotiraditya",
                        "content": "Hint : Take an example of rotating a cirucular linked list. "
                    },
                    {
                        "username": "nafSadh",
                        "content": "In most (if not all) questions, OJ defined struct/class use NULL instead of nullptr. Why is that?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "Probably author preference, but I would guess some authors use nullptr instead of NULL because nullptr was inroduced in C++ to remove the ambiguity of the C NULL which is 0."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach for Beginners:-)**\\n- Calculate the length of the linked list while keeping track of the tail node.\\n- Adjust k by taking its modulo with the list length to find the effective rotation amount.\\n- If k becomes zero, return the original head; no rotation is needed.\\n- Find the new head and new tail nodes after rotation:\\n  - The new tail is k nodes from the end of the list.\\n  - The new head is the node after the new tail.\\n- Break the list at the new tail and reconnect it to the original head, completing the rotation.\\n- Return the new head as the result of the rotation."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/rotate-list/solutions/4087567/easiest-solution-beginner-friendly-straight-forward/?envType=study-plan-v2&envId=top-interview-150"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Rotating Linked List is very similar to rotating array. I am sure that you might be worked on sorted rotated array while learning on Binary search. The approach will same. let\\'s code it.\\n# Approach\\n1 : Find Last node and connect with head.\\n2 : How many times need to skip or rotate, skip = length - k.\\n3 : Find the rotation that how many times it rotated (k). mean skip = length - rotation.\\n4 : Once you found the last node connect with head and put null in last node.\\n5 : return head."
                    },
                    {
                        "username": "user8272RT",
                        "content": "I struggled to write clean code for this problem. Need more practice! "
                    },
                    {
                        "username": "SiddhantP",
                        "content": "If Anyone is struggling,\\n\\n1. Get the List Length, and Do k % length to find out how much rotation is needed.\\n2. Traverse using 2 Pointers (Difference between them == k % length).\\n3. When fast pointer hits null, Just Append anything after slow pointer before head. (This part is bit tricky, take care that you don\\'t accidently create Infinite Linked list).\\n\\nHope this helps...\\n\\nRef : [My Submission - O(n)](https://leetcode.com/problems/rotate-list/solutions/3778788/c-2-pointers-faster-than-90-of-the-submissions/)"
                    },
                    {
                        "username": "Abhaydeep_Sharma",
                        "content": "Can any body tell whats wrong in this code\\n\\n ListNode* rotateRight(ListNode* head, int k) \\n    {\\n        if(k==0|| head == NULL|| head->next==NULL)return head;\\n\\n         ListNode*end = head;\\n        ListNode* temp;\\n        int len =0;\\n\\n        while(end->next)\\n        {\\n             end = end->next;\\n             len++;\\n        }\\n        len++;\\n\\n        cout<<len<<endl;\\n        \\n        k = k%len;\\n        \\n        int cnt=0;\\n        \\n        while(--k)\\n        {\\n            temp = head->next;\\n            end->next = head;\\n            \\n            head->next=NULL;\\n            \\n            end = head;\\n            head = temp;\\n        }\\n        \\n        return head;\\n    }"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "What the fuck is wrong with test case 12??? k=2000000000??? WTF!!! Seriously LeetCode"
                    },
                    {
                        "username": "anshul_0077",
                        "content": "bro u dont have to run loop k times . k rotations and k%size rotation will give the same link list\\n"
                    }
                ]
            },
            {
                "id": 1918540,
                "content": [
                    {
                        "username": "Akash_Verma2000",
                        "content": "FOLLOW THESE STEPS TO SOLVE THIS PROBLEM\\n //connect the tail to the head\\n        //figure out the optimum value of k BY K=K%length of list\\n        //pointer=length-k\\n        //travel till pointer\\n        //secure the ListNode at the next of the pointer in another ListNode \\n        //point the same to null"
                    },
                    {
                        "username": "Yashdahiya295",
                        "content": "OPTIMAL SOLUTION :C++\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next == NULL ||k==0)\\n     {\\n          return head ;\\n     }\\n\\n     //Compute the length of the linked list \\n     ListNode* cur = head ;\\n     int len = 1;\\n     while(cur->next!=NULL)\\n     {\\n          ++len ;\\n          cur = cur->next ;\\n     }\\n\\n     //Pointing the last node to the head;\\n     cur->next = head ;\\n     k = k % len ;//Like if we have 12 rotation and k = 5 then till 10 rotation its same as the original linked list , so we do this .\\n     k = len - k ; // So that we can able to know how much we have to traverse from the head .\\n     while(k--)\\n     {\\n          cur = cur->next ;\\n     }\\n\\n     //Make the node to the head and break the connection\\n     head = cur->next ;\\n     cur->next = NULL ;\\n\\n\\n     return head;\\n\\n    }\\n}; \\nTC : O(N). , SC: O(1).   "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Optimal rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jyotiraditya",
                        "content": "Hint : Take an example of rotating a cirucular linked list. "
                    },
                    {
                        "username": "nafSadh",
                        "content": "In most (if not all) questions, OJ defined struct/class use NULL instead of nullptr. Why is that?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "Probably author preference, but I would guess some authors use nullptr instead of NULL because nullptr was inroduced in C++ to remove the ambiguity of the C NULL which is 0."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach for Beginners:-)**\\n- Calculate the length of the linked list while keeping track of the tail node.\\n- Adjust k by taking its modulo with the list length to find the effective rotation amount.\\n- If k becomes zero, return the original head; no rotation is needed.\\n- Find the new head and new tail nodes after rotation:\\n  - The new tail is k nodes from the end of the list.\\n  - The new head is the node after the new tail.\\n- Break the list at the new tail and reconnect it to the original head, completing the rotation.\\n- Return the new head as the result of the rotation."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/rotate-list/solutions/4087567/easiest-solution-beginner-friendly-straight-forward/?envType=study-plan-v2&envId=top-interview-150"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Rotating Linked List is very similar to rotating array. I am sure that you might be worked on sorted rotated array while learning on Binary search. The approach will same. let\\'s code it.\\n# Approach\\n1 : Find Last node and connect with head.\\n2 : How many times need to skip or rotate, skip = length - k.\\n3 : Find the rotation that how many times it rotated (k). mean skip = length - rotation.\\n4 : Once you found the last node connect with head and put null in last node.\\n5 : return head."
                    },
                    {
                        "username": "user8272RT",
                        "content": "I struggled to write clean code for this problem. Need more practice! "
                    },
                    {
                        "username": "SiddhantP",
                        "content": "If Anyone is struggling,\\n\\n1. Get the List Length, and Do k % length to find out how much rotation is needed.\\n2. Traverse using 2 Pointers (Difference between them == k % length).\\n3. When fast pointer hits null, Just Append anything after slow pointer before head. (This part is bit tricky, take care that you don\\'t accidently create Infinite Linked list).\\n\\nHope this helps...\\n\\nRef : [My Submission - O(n)](https://leetcode.com/problems/rotate-list/solutions/3778788/c-2-pointers-faster-than-90-of-the-submissions/)"
                    },
                    {
                        "username": "Abhaydeep_Sharma",
                        "content": "Can any body tell whats wrong in this code\\n\\n ListNode* rotateRight(ListNode* head, int k) \\n    {\\n        if(k==0|| head == NULL|| head->next==NULL)return head;\\n\\n         ListNode*end = head;\\n        ListNode* temp;\\n        int len =0;\\n\\n        while(end->next)\\n        {\\n             end = end->next;\\n             len++;\\n        }\\n        len++;\\n\\n        cout<<len<<endl;\\n        \\n        k = k%len;\\n        \\n        int cnt=0;\\n        \\n        while(--k)\\n        {\\n            temp = head->next;\\n            end->next = head;\\n            \\n            head->next=NULL;\\n            \\n            end = head;\\n            head = temp;\\n        }\\n        \\n        return head;\\n    }"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "What the fuck is wrong with test case 12??? k=2000000000??? WTF!!! Seriously LeetCode"
                    },
                    {
                        "username": "anshul_0077",
                        "content": "bro u dont have to run loop k times . k rotations and k%size rotation will give the same link list\\n"
                    }
                ]
            },
            {
                "id": 1677536,
                "content": [
                    {
                        "username": "Akash_Verma2000",
                        "content": "FOLLOW THESE STEPS TO SOLVE THIS PROBLEM\\n //connect the tail to the head\\n        //figure out the optimum value of k BY K=K%length of list\\n        //pointer=length-k\\n        //travel till pointer\\n        //secure the ListNode at the next of the pointer in another ListNode \\n        //point the same to null"
                    },
                    {
                        "username": "Yashdahiya295",
                        "content": "OPTIMAL SOLUTION :C++\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next == NULL ||k==0)\\n     {\\n          return head ;\\n     }\\n\\n     //Compute the length of the linked list \\n     ListNode* cur = head ;\\n     int len = 1;\\n     while(cur->next!=NULL)\\n     {\\n          ++len ;\\n          cur = cur->next ;\\n     }\\n\\n     //Pointing the last node to the head;\\n     cur->next = head ;\\n     k = k % len ;//Like if we have 12 rotation and k = 5 then till 10 rotation its same as the original linked list , so we do this .\\n     k = len - k ; // So that we can able to know how much we have to traverse from the head .\\n     while(k--)\\n     {\\n          cur = cur->next ;\\n     }\\n\\n     //Make the node to the head and break the connection\\n     head = cur->next ;\\n     cur->next = NULL ;\\n\\n\\n     return head;\\n\\n    }\\n}; \\nTC : O(N). , SC: O(1).   "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Optimal rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jyotiraditya",
                        "content": "Hint : Take an example of rotating a cirucular linked list. "
                    },
                    {
                        "username": "nafSadh",
                        "content": "In most (if not all) questions, OJ defined struct/class use NULL instead of nullptr. Why is that?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "Probably author preference, but I would guess some authors use nullptr instead of NULL because nullptr was inroduced in C++ to remove the ambiguity of the C NULL which is 0."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach for Beginners:-)**\\n- Calculate the length of the linked list while keeping track of the tail node.\\n- Adjust k by taking its modulo with the list length to find the effective rotation amount.\\n- If k becomes zero, return the original head; no rotation is needed.\\n- Find the new head and new tail nodes after rotation:\\n  - The new tail is k nodes from the end of the list.\\n  - The new head is the node after the new tail.\\n- Break the list at the new tail and reconnect it to the original head, completing the rotation.\\n- Return the new head as the result of the rotation."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/rotate-list/solutions/4087567/easiest-solution-beginner-friendly-straight-forward/?envType=study-plan-v2&envId=top-interview-150"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Rotating Linked List is very similar to rotating array. I am sure that you might be worked on sorted rotated array while learning on Binary search. The approach will same. let\\'s code it.\\n# Approach\\n1 : Find Last node and connect with head.\\n2 : How many times need to skip or rotate, skip = length - k.\\n3 : Find the rotation that how many times it rotated (k). mean skip = length - rotation.\\n4 : Once you found the last node connect with head and put null in last node.\\n5 : return head."
                    },
                    {
                        "username": "user8272RT",
                        "content": "I struggled to write clean code for this problem. Need more practice! "
                    },
                    {
                        "username": "SiddhantP",
                        "content": "If Anyone is struggling,\\n\\n1. Get the List Length, and Do k % length to find out how much rotation is needed.\\n2. Traverse using 2 Pointers (Difference between them == k % length).\\n3. When fast pointer hits null, Just Append anything after slow pointer before head. (This part is bit tricky, take care that you don\\'t accidently create Infinite Linked list).\\n\\nHope this helps...\\n\\nRef : [My Submission - O(n)](https://leetcode.com/problems/rotate-list/solutions/3778788/c-2-pointers-faster-than-90-of-the-submissions/)"
                    },
                    {
                        "username": "Abhaydeep_Sharma",
                        "content": "Can any body tell whats wrong in this code\\n\\n ListNode* rotateRight(ListNode* head, int k) \\n    {\\n        if(k==0|| head == NULL|| head->next==NULL)return head;\\n\\n         ListNode*end = head;\\n        ListNode* temp;\\n        int len =0;\\n\\n        while(end->next)\\n        {\\n             end = end->next;\\n             len++;\\n        }\\n        len++;\\n\\n        cout<<len<<endl;\\n        \\n        k = k%len;\\n        \\n        int cnt=0;\\n        \\n        while(--k)\\n        {\\n            temp = head->next;\\n            end->next = head;\\n            \\n            head->next=NULL;\\n            \\n            end = head;\\n            head = temp;\\n        }\\n        \\n        return head;\\n    }"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "What the fuck is wrong with test case 12??? k=2000000000??? WTF!!! Seriously LeetCode"
                    },
                    {
                        "username": "anshul_0077",
                        "content": "bro u dont have to run loop k times . k rotations and k%size rotation will give the same link list\\n"
                    }
                ]
            },
            {
                "id": 1571145,
                "content": [
                    {
                        "username": "Akash_Verma2000",
                        "content": "FOLLOW THESE STEPS TO SOLVE THIS PROBLEM\\n //connect the tail to the head\\n        //figure out the optimum value of k BY K=K%length of list\\n        //pointer=length-k\\n        //travel till pointer\\n        //secure the ListNode at the next of the pointer in another ListNode \\n        //point the same to null"
                    },
                    {
                        "username": "Yashdahiya295",
                        "content": "OPTIMAL SOLUTION :C++\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next == NULL ||k==0)\\n     {\\n          return head ;\\n     }\\n\\n     //Compute the length of the linked list \\n     ListNode* cur = head ;\\n     int len = 1;\\n     while(cur->next!=NULL)\\n     {\\n          ++len ;\\n          cur = cur->next ;\\n     }\\n\\n     //Pointing the last node to the head;\\n     cur->next = head ;\\n     k = k % len ;//Like if we have 12 rotation and k = 5 then till 10 rotation its same as the original linked list , so we do this .\\n     k = len - k ; // So that we can able to know how much we have to traverse from the head .\\n     while(k--)\\n     {\\n          cur = cur->next ;\\n     }\\n\\n     //Make the node to the head and break the connection\\n     head = cur->next ;\\n     cur->next = NULL ;\\n\\n\\n     return head;\\n\\n    }\\n}; \\nTC : O(N). , SC: O(1).   "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Optimal rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jyotiraditya",
                        "content": "Hint : Take an example of rotating a cirucular linked list. "
                    },
                    {
                        "username": "nafSadh",
                        "content": "In most (if not all) questions, OJ defined struct/class use NULL instead of nullptr. Why is that?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "Probably author preference, but I would guess some authors use nullptr instead of NULL because nullptr was inroduced in C++ to remove the ambiguity of the C NULL which is 0."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach for Beginners:-)**\\n- Calculate the length of the linked list while keeping track of the tail node.\\n- Adjust k by taking its modulo with the list length to find the effective rotation amount.\\n- If k becomes zero, return the original head; no rotation is needed.\\n- Find the new head and new tail nodes after rotation:\\n  - The new tail is k nodes from the end of the list.\\n  - The new head is the node after the new tail.\\n- Break the list at the new tail and reconnect it to the original head, completing the rotation.\\n- Return the new head as the result of the rotation."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/rotate-list/solutions/4087567/easiest-solution-beginner-friendly-straight-forward/?envType=study-plan-v2&envId=top-interview-150"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Rotating Linked List is very similar to rotating array. I am sure that you might be worked on sorted rotated array while learning on Binary search. The approach will same. let\\'s code it.\\n# Approach\\n1 : Find Last node and connect with head.\\n2 : How many times need to skip or rotate, skip = length - k.\\n3 : Find the rotation that how many times it rotated (k). mean skip = length - rotation.\\n4 : Once you found the last node connect with head and put null in last node.\\n5 : return head."
                    },
                    {
                        "username": "user8272RT",
                        "content": "I struggled to write clean code for this problem. Need more practice! "
                    },
                    {
                        "username": "SiddhantP",
                        "content": "If Anyone is struggling,\\n\\n1. Get the List Length, and Do k % length to find out how much rotation is needed.\\n2. Traverse using 2 Pointers (Difference between them == k % length).\\n3. When fast pointer hits null, Just Append anything after slow pointer before head. (This part is bit tricky, take care that you don\\'t accidently create Infinite Linked list).\\n\\nHope this helps...\\n\\nRef : [My Submission - O(n)](https://leetcode.com/problems/rotate-list/solutions/3778788/c-2-pointers-faster-than-90-of-the-submissions/)"
                    },
                    {
                        "username": "Abhaydeep_Sharma",
                        "content": "Can any body tell whats wrong in this code\\n\\n ListNode* rotateRight(ListNode* head, int k) \\n    {\\n        if(k==0|| head == NULL|| head->next==NULL)return head;\\n\\n         ListNode*end = head;\\n        ListNode* temp;\\n        int len =0;\\n\\n        while(end->next)\\n        {\\n             end = end->next;\\n             len++;\\n        }\\n        len++;\\n\\n        cout<<len<<endl;\\n        \\n        k = k%len;\\n        \\n        int cnt=0;\\n        \\n        while(--k)\\n        {\\n            temp = head->next;\\n            end->next = head;\\n            \\n            head->next=NULL;\\n            \\n            end = head;\\n            head = temp;\\n        }\\n        \\n        return head;\\n    }"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "What the fuck is wrong with test case 12??? k=2000000000??? WTF!!! Seriously LeetCode"
                    },
                    {
                        "username": "anshul_0077",
                        "content": "bro u dont have to run loop k times . k rotations and k%size rotation will give the same link list\\n"
                    }
                ]
            },
            {
                "id": 2071608,
                "content": [
                    {
                        "username": "Akash_Verma2000",
                        "content": "FOLLOW THESE STEPS TO SOLVE THIS PROBLEM\\n //connect the tail to the head\\n        //figure out the optimum value of k BY K=K%length of list\\n        //pointer=length-k\\n        //travel till pointer\\n        //secure the ListNode at the next of the pointer in another ListNode \\n        //point the same to null"
                    },
                    {
                        "username": "Yashdahiya295",
                        "content": "OPTIMAL SOLUTION :C++\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next == NULL ||k==0)\\n     {\\n          return head ;\\n     }\\n\\n     //Compute the length of the linked list \\n     ListNode* cur = head ;\\n     int len = 1;\\n     while(cur->next!=NULL)\\n     {\\n          ++len ;\\n          cur = cur->next ;\\n     }\\n\\n     //Pointing the last node to the head;\\n     cur->next = head ;\\n     k = k % len ;//Like if we have 12 rotation and k = 5 then till 10 rotation its same as the original linked list , so we do this .\\n     k = len - k ; // So that we can able to know how much we have to traverse from the head .\\n     while(k--)\\n     {\\n          cur = cur->next ;\\n     }\\n\\n     //Make the node to the head and break the connection\\n     head = cur->next ;\\n     cur->next = NULL ;\\n\\n\\n     return head;\\n\\n    }\\n}; \\nTC : O(N). , SC: O(1).   "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Optimal rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jyotiraditya",
                        "content": "Hint : Take an example of rotating a cirucular linked list. "
                    },
                    {
                        "username": "nafSadh",
                        "content": "In most (if not all) questions, OJ defined struct/class use NULL instead of nullptr. Why is that?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "Probably author preference, but I would guess some authors use nullptr instead of NULL because nullptr was inroduced in C++ to remove the ambiguity of the C NULL which is 0."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach for Beginners:-)**\\n- Calculate the length of the linked list while keeping track of the tail node.\\n- Adjust k by taking its modulo with the list length to find the effective rotation amount.\\n- If k becomes zero, return the original head; no rotation is needed.\\n- Find the new head and new tail nodes after rotation:\\n  - The new tail is k nodes from the end of the list.\\n  - The new head is the node after the new tail.\\n- Break the list at the new tail and reconnect it to the original head, completing the rotation.\\n- Return the new head as the result of the rotation."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/rotate-list/solutions/4087567/easiest-solution-beginner-friendly-straight-forward/?envType=study-plan-v2&envId=top-interview-150"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Rotating Linked List is very similar to rotating array. I am sure that you might be worked on sorted rotated array while learning on Binary search. The approach will same. let\\'s code it.\\n# Approach\\n1 : Find Last node and connect with head.\\n2 : How many times need to skip or rotate, skip = length - k.\\n3 : Find the rotation that how many times it rotated (k). mean skip = length - rotation.\\n4 : Once you found the last node connect with head and put null in last node.\\n5 : return head."
                    },
                    {
                        "username": "user8272RT",
                        "content": "I struggled to write clean code for this problem. Need more practice! "
                    },
                    {
                        "username": "SiddhantP",
                        "content": "If Anyone is struggling,\\n\\n1. Get the List Length, and Do k % length to find out how much rotation is needed.\\n2. Traverse using 2 Pointers (Difference between them == k % length).\\n3. When fast pointer hits null, Just Append anything after slow pointer before head. (This part is bit tricky, take care that you don\\'t accidently create Infinite Linked list).\\n\\nHope this helps...\\n\\nRef : [My Submission - O(n)](https://leetcode.com/problems/rotate-list/solutions/3778788/c-2-pointers-faster-than-90-of-the-submissions/)"
                    },
                    {
                        "username": "Abhaydeep_Sharma",
                        "content": "Can any body tell whats wrong in this code\\n\\n ListNode* rotateRight(ListNode* head, int k) \\n    {\\n        if(k==0|| head == NULL|| head->next==NULL)return head;\\n\\n         ListNode*end = head;\\n        ListNode* temp;\\n        int len =0;\\n\\n        while(end->next)\\n        {\\n             end = end->next;\\n             len++;\\n        }\\n        len++;\\n\\n        cout<<len<<endl;\\n        \\n        k = k%len;\\n        \\n        int cnt=0;\\n        \\n        while(--k)\\n        {\\n            temp = head->next;\\n            end->next = head;\\n            \\n            head->next=NULL;\\n            \\n            end = head;\\n            head = temp;\\n        }\\n        \\n        return head;\\n    }"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "What the fuck is wrong with test case 12??? k=2000000000??? WTF!!! Seriously LeetCode"
                    },
                    {
                        "username": "anshul_0077",
                        "content": "bro u dont have to run loop k times . k rotations and k%size rotation will give the same link list\\n"
                    }
                ]
            },
            {
                "id": 2045061,
                "content": [
                    {
                        "username": "Akash_Verma2000",
                        "content": "FOLLOW THESE STEPS TO SOLVE THIS PROBLEM\\n //connect the tail to the head\\n        //figure out the optimum value of k BY K=K%length of list\\n        //pointer=length-k\\n        //travel till pointer\\n        //secure the ListNode at the next of the pointer in another ListNode \\n        //point the same to null"
                    },
                    {
                        "username": "Yashdahiya295",
                        "content": "OPTIMAL SOLUTION :C++\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next == NULL ||k==0)\\n     {\\n          return head ;\\n     }\\n\\n     //Compute the length of the linked list \\n     ListNode* cur = head ;\\n     int len = 1;\\n     while(cur->next!=NULL)\\n     {\\n          ++len ;\\n          cur = cur->next ;\\n     }\\n\\n     //Pointing the last node to the head;\\n     cur->next = head ;\\n     k = k % len ;//Like if we have 12 rotation and k = 5 then till 10 rotation its same as the original linked list , so we do this .\\n     k = len - k ; // So that we can able to know how much we have to traverse from the head .\\n     while(k--)\\n     {\\n          cur = cur->next ;\\n     }\\n\\n     //Make the node to the head and break the connection\\n     head = cur->next ;\\n     cur->next = NULL ;\\n\\n\\n     return head;\\n\\n    }\\n}; \\nTC : O(N). , SC: O(1).   "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Optimal rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jyotiraditya",
                        "content": "Hint : Take an example of rotating a cirucular linked list. "
                    },
                    {
                        "username": "nafSadh",
                        "content": "In most (if not all) questions, OJ defined struct/class use NULL instead of nullptr. Why is that?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "Probably author preference, but I would guess some authors use nullptr instead of NULL because nullptr was inroduced in C++ to remove the ambiguity of the C NULL which is 0."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach for Beginners:-)**\\n- Calculate the length of the linked list while keeping track of the tail node.\\n- Adjust k by taking its modulo with the list length to find the effective rotation amount.\\n- If k becomes zero, return the original head; no rotation is needed.\\n- Find the new head and new tail nodes after rotation:\\n  - The new tail is k nodes from the end of the list.\\n  - The new head is the node after the new tail.\\n- Break the list at the new tail and reconnect it to the original head, completing the rotation.\\n- Return the new head as the result of the rotation."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/rotate-list/solutions/4087567/easiest-solution-beginner-friendly-straight-forward/?envType=study-plan-v2&envId=top-interview-150"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Rotating Linked List is very similar to rotating array. I am sure that you might be worked on sorted rotated array while learning on Binary search. The approach will same. let\\'s code it.\\n# Approach\\n1 : Find Last node and connect with head.\\n2 : How many times need to skip or rotate, skip = length - k.\\n3 : Find the rotation that how many times it rotated (k). mean skip = length - rotation.\\n4 : Once you found the last node connect with head and put null in last node.\\n5 : return head."
                    },
                    {
                        "username": "user8272RT",
                        "content": "I struggled to write clean code for this problem. Need more practice! "
                    },
                    {
                        "username": "SiddhantP",
                        "content": "If Anyone is struggling,\\n\\n1. Get the List Length, and Do k % length to find out how much rotation is needed.\\n2. Traverse using 2 Pointers (Difference between them == k % length).\\n3. When fast pointer hits null, Just Append anything after slow pointer before head. (This part is bit tricky, take care that you don\\'t accidently create Infinite Linked list).\\n\\nHope this helps...\\n\\nRef : [My Submission - O(n)](https://leetcode.com/problems/rotate-list/solutions/3778788/c-2-pointers-faster-than-90-of-the-submissions/)"
                    },
                    {
                        "username": "Abhaydeep_Sharma",
                        "content": "Can any body tell whats wrong in this code\\n\\n ListNode* rotateRight(ListNode* head, int k) \\n    {\\n        if(k==0|| head == NULL|| head->next==NULL)return head;\\n\\n         ListNode*end = head;\\n        ListNode* temp;\\n        int len =0;\\n\\n        while(end->next)\\n        {\\n             end = end->next;\\n             len++;\\n        }\\n        len++;\\n\\n        cout<<len<<endl;\\n        \\n        k = k%len;\\n        \\n        int cnt=0;\\n        \\n        while(--k)\\n        {\\n            temp = head->next;\\n            end->next = head;\\n            \\n            head->next=NULL;\\n            \\n            end = head;\\n            head = temp;\\n        }\\n        \\n        return head;\\n    }"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "What the fuck is wrong with test case 12??? k=2000000000??? WTF!!! Seriously LeetCode"
                    },
                    {
                        "username": "anshul_0077",
                        "content": "bro u dont have to run loop k times . k rotations and k%size rotation will give the same link list\\n"
                    }
                ]
            },
            {
                "id": 2015354,
                "content": [
                    {
                        "username": "Akash_Verma2000",
                        "content": "FOLLOW THESE STEPS TO SOLVE THIS PROBLEM\\n //connect the tail to the head\\n        //figure out the optimum value of k BY K=K%length of list\\n        //pointer=length-k\\n        //travel till pointer\\n        //secure the ListNode at the next of the pointer in another ListNode \\n        //point the same to null"
                    },
                    {
                        "username": "Yashdahiya295",
                        "content": "OPTIMAL SOLUTION :C++\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next == NULL ||k==0)\\n     {\\n          return head ;\\n     }\\n\\n     //Compute the length of the linked list \\n     ListNode* cur = head ;\\n     int len = 1;\\n     while(cur->next!=NULL)\\n     {\\n          ++len ;\\n          cur = cur->next ;\\n     }\\n\\n     //Pointing the last node to the head;\\n     cur->next = head ;\\n     k = k % len ;//Like if we have 12 rotation and k = 5 then till 10 rotation its same as the original linked list , so we do this .\\n     k = len - k ; // So that we can able to know how much we have to traverse from the head .\\n     while(k--)\\n     {\\n          cur = cur->next ;\\n     }\\n\\n     //Make the node to the head and break the connection\\n     head = cur->next ;\\n     cur->next = NULL ;\\n\\n\\n     return head;\\n\\n    }\\n}; \\nTC : O(N). , SC: O(1).   "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Optimal rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jyotiraditya",
                        "content": "Hint : Take an example of rotating a cirucular linked list. "
                    },
                    {
                        "username": "nafSadh",
                        "content": "In most (if not all) questions, OJ defined struct/class use NULL instead of nullptr. Why is that?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "Probably author preference, but I would guess some authors use nullptr instead of NULL because nullptr was inroduced in C++ to remove the ambiguity of the C NULL which is 0."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach for Beginners:-)**\\n- Calculate the length of the linked list while keeping track of the tail node.\\n- Adjust k by taking its modulo with the list length to find the effective rotation amount.\\n- If k becomes zero, return the original head; no rotation is needed.\\n- Find the new head and new tail nodes after rotation:\\n  - The new tail is k nodes from the end of the list.\\n  - The new head is the node after the new tail.\\n- Break the list at the new tail and reconnect it to the original head, completing the rotation.\\n- Return the new head as the result of the rotation."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/rotate-list/solutions/4087567/easiest-solution-beginner-friendly-straight-forward/?envType=study-plan-v2&envId=top-interview-150"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Rotating Linked List is very similar to rotating array. I am sure that you might be worked on sorted rotated array while learning on Binary search. The approach will same. let\\'s code it.\\n# Approach\\n1 : Find Last node and connect with head.\\n2 : How many times need to skip or rotate, skip = length - k.\\n3 : Find the rotation that how many times it rotated (k). mean skip = length - rotation.\\n4 : Once you found the last node connect with head and put null in last node.\\n5 : return head."
                    },
                    {
                        "username": "user8272RT",
                        "content": "I struggled to write clean code for this problem. Need more practice! "
                    },
                    {
                        "username": "SiddhantP",
                        "content": "If Anyone is struggling,\\n\\n1. Get the List Length, and Do k % length to find out how much rotation is needed.\\n2. Traverse using 2 Pointers (Difference between them == k % length).\\n3. When fast pointer hits null, Just Append anything after slow pointer before head. (This part is bit tricky, take care that you don\\'t accidently create Infinite Linked list).\\n\\nHope this helps...\\n\\nRef : [My Submission - O(n)](https://leetcode.com/problems/rotate-list/solutions/3778788/c-2-pointers-faster-than-90-of-the-submissions/)"
                    },
                    {
                        "username": "Abhaydeep_Sharma",
                        "content": "Can any body tell whats wrong in this code\\n\\n ListNode* rotateRight(ListNode* head, int k) \\n    {\\n        if(k==0|| head == NULL|| head->next==NULL)return head;\\n\\n         ListNode*end = head;\\n        ListNode* temp;\\n        int len =0;\\n\\n        while(end->next)\\n        {\\n             end = end->next;\\n             len++;\\n        }\\n        len++;\\n\\n        cout<<len<<endl;\\n        \\n        k = k%len;\\n        \\n        int cnt=0;\\n        \\n        while(--k)\\n        {\\n            temp = head->next;\\n            end->next = head;\\n            \\n            head->next=NULL;\\n            \\n            end = head;\\n            head = temp;\\n        }\\n        \\n        return head;\\n    }"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "What the fuck is wrong with test case 12??? k=2000000000??? WTF!!! Seriously LeetCode"
                    },
                    {
                        "username": "anshul_0077",
                        "content": "bro u dont have to run loop k times . k rotations and k%size rotation will give the same link list\\n"
                    }
                ]
            },
            {
                "id": 1974403,
                "content": [
                    {
                        "username": "Akash_Verma2000",
                        "content": "FOLLOW THESE STEPS TO SOLVE THIS PROBLEM\\n //connect the tail to the head\\n        //figure out the optimum value of k BY K=K%length of list\\n        //pointer=length-k\\n        //travel till pointer\\n        //secure the ListNode at the next of the pointer in another ListNode \\n        //point the same to null"
                    },
                    {
                        "username": "Yashdahiya295",
                        "content": "OPTIMAL SOLUTION :C++\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next == NULL ||k==0)\\n     {\\n          return head ;\\n     }\\n\\n     //Compute the length of the linked list \\n     ListNode* cur = head ;\\n     int len = 1;\\n     while(cur->next!=NULL)\\n     {\\n          ++len ;\\n          cur = cur->next ;\\n     }\\n\\n     //Pointing the last node to the head;\\n     cur->next = head ;\\n     k = k % len ;//Like if we have 12 rotation and k = 5 then till 10 rotation its same as the original linked list , so we do this .\\n     k = len - k ; // So that we can able to know how much we have to traverse from the head .\\n     while(k--)\\n     {\\n          cur = cur->next ;\\n     }\\n\\n     //Make the node to the head and break the connection\\n     head = cur->next ;\\n     cur->next = NULL ;\\n\\n\\n     return head;\\n\\n    }\\n}; \\nTC : O(N). , SC: O(1).   "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Optimal rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jyotiraditya",
                        "content": "Hint : Take an example of rotating a cirucular linked list. "
                    },
                    {
                        "username": "nafSadh",
                        "content": "In most (if not all) questions, OJ defined struct/class use NULL instead of nullptr. Why is that?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "Probably author preference, but I would guess some authors use nullptr instead of NULL because nullptr was inroduced in C++ to remove the ambiguity of the C NULL which is 0."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach for Beginners:-)**\\n- Calculate the length of the linked list while keeping track of the tail node.\\n- Adjust k by taking its modulo with the list length to find the effective rotation amount.\\n- If k becomes zero, return the original head; no rotation is needed.\\n- Find the new head and new tail nodes after rotation:\\n  - The new tail is k nodes from the end of the list.\\n  - The new head is the node after the new tail.\\n- Break the list at the new tail and reconnect it to the original head, completing the rotation.\\n- Return the new head as the result of the rotation."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/rotate-list/solutions/4087567/easiest-solution-beginner-friendly-straight-forward/?envType=study-plan-v2&envId=top-interview-150"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Rotating Linked List is very similar to rotating array. I am sure that you might be worked on sorted rotated array while learning on Binary search. The approach will same. let\\'s code it.\\n# Approach\\n1 : Find Last node and connect with head.\\n2 : How many times need to skip or rotate, skip = length - k.\\n3 : Find the rotation that how many times it rotated (k). mean skip = length - rotation.\\n4 : Once you found the last node connect with head and put null in last node.\\n5 : return head."
                    },
                    {
                        "username": "user8272RT",
                        "content": "I struggled to write clean code for this problem. Need more practice! "
                    },
                    {
                        "username": "SiddhantP",
                        "content": "If Anyone is struggling,\\n\\n1. Get the List Length, and Do k % length to find out how much rotation is needed.\\n2. Traverse using 2 Pointers (Difference between them == k % length).\\n3. When fast pointer hits null, Just Append anything after slow pointer before head. (This part is bit tricky, take care that you don\\'t accidently create Infinite Linked list).\\n\\nHope this helps...\\n\\nRef : [My Submission - O(n)](https://leetcode.com/problems/rotate-list/solutions/3778788/c-2-pointers-faster-than-90-of-the-submissions/)"
                    },
                    {
                        "username": "Abhaydeep_Sharma",
                        "content": "Can any body tell whats wrong in this code\\n\\n ListNode* rotateRight(ListNode* head, int k) \\n    {\\n        if(k==0|| head == NULL|| head->next==NULL)return head;\\n\\n         ListNode*end = head;\\n        ListNode* temp;\\n        int len =0;\\n\\n        while(end->next)\\n        {\\n             end = end->next;\\n             len++;\\n        }\\n        len++;\\n\\n        cout<<len<<endl;\\n        \\n        k = k%len;\\n        \\n        int cnt=0;\\n        \\n        while(--k)\\n        {\\n            temp = head->next;\\n            end->next = head;\\n            \\n            head->next=NULL;\\n            \\n            end = head;\\n            head = temp;\\n        }\\n        \\n        return head;\\n    }"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "What the fuck is wrong with test case 12??? k=2000000000??? WTF!!! Seriously LeetCode"
                    },
                    {
                        "username": "anshul_0077",
                        "content": "bro u dont have to run loop k times . k rotations and k%size rotation will give the same link list\\n"
                    }
                ]
            },
            {
                "id": 1933543,
                "content": [
                    {
                        "username": "Akash_Verma2000",
                        "content": "FOLLOW THESE STEPS TO SOLVE THIS PROBLEM\\n //connect the tail to the head\\n        //figure out the optimum value of k BY K=K%length of list\\n        //pointer=length-k\\n        //travel till pointer\\n        //secure the ListNode at the next of the pointer in another ListNode \\n        //point the same to null"
                    },
                    {
                        "username": "Yashdahiya295",
                        "content": "OPTIMAL SOLUTION :C++\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next == NULL ||k==0)\\n     {\\n          return head ;\\n     }\\n\\n     //Compute the length of the linked list \\n     ListNode* cur = head ;\\n     int len = 1;\\n     while(cur->next!=NULL)\\n     {\\n          ++len ;\\n          cur = cur->next ;\\n     }\\n\\n     //Pointing the last node to the head;\\n     cur->next = head ;\\n     k = k % len ;//Like if we have 12 rotation and k = 5 then till 10 rotation its same as the original linked list , so we do this .\\n     k = len - k ; // So that we can able to know how much we have to traverse from the head .\\n     while(k--)\\n     {\\n          cur = cur->next ;\\n     }\\n\\n     //Make the node to the head and break the connection\\n     head = cur->next ;\\n     cur->next = NULL ;\\n\\n\\n     return head;\\n\\n    }\\n}; \\nTC : O(N). , SC: O(1).   "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Optimal rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jyotiraditya",
                        "content": "Hint : Take an example of rotating a cirucular linked list. "
                    },
                    {
                        "username": "nafSadh",
                        "content": "In most (if not all) questions, OJ defined struct/class use NULL instead of nullptr. Why is that?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "Probably author preference, but I would guess some authors use nullptr instead of NULL because nullptr was inroduced in C++ to remove the ambiguity of the C NULL which is 0."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach for Beginners:-)**\\n- Calculate the length of the linked list while keeping track of the tail node.\\n- Adjust k by taking its modulo with the list length to find the effective rotation amount.\\n- If k becomes zero, return the original head; no rotation is needed.\\n- Find the new head and new tail nodes after rotation:\\n  - The new tail is k nodes from the end of the list.\\n  - The new head is the node after the new tail.\\n- Break the list at the new tail and reconnect it to the original head, completing the rotation.\\n- Return the new head as the result of the rotation."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/rotate-list/solutions/4087567/easiest-solution-beginner-friendly-straight-forward/?envType=study-plan-v2&envId=top-interview-150"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Rotating Linked List is very similar to rotating array. I am sure that you might be worked on sorted rotated array while learning on Binary search. The approach will same. let\\'s code it.\\n# Approach\\n1 : Find Last node and connect with head.\\n2 : How many times need to skip or rotate, skip = length - k.\\n3 : Find the rotation that how many times it rotated (k). mean skip = length - rotation.\\n4 : Once you found the last node connect with head and put null in last node.\\n5 : return head."
                    },
                    {
                        "username": "user8272RT",
                        "content": "I struggled to write clean code for this problem. Need more practice! "
                    },
                    {
                        "username": "SiddhantP",
                        "content": "If Anyone is struggling,\\n\\n1. Get the List Length, and Do k % length to find out how much rotation is needed.\\n2. Traverse using 2 Pointers (Difference between them == k % length).\\n3. When fast pointer hits null, Just Append anything after slow pointer before head. (This part is bit tricky, take care that you don\\'t accidently create Infinite Linked list).\\n\\nHope this helps...\\n\\nRef : [My Submission - O(n)](https://leetcode.com/problems/rotate-list/solutions/3778788/c-2-pointers-faster-than-90-of-the-submissions/)"
                    },
                    {
                        "username": "Abhaydeep_Sharma",
                        "content": "Can any body tell whats wrong in this code\\n\\n ListNode* rotateRight(ListNode* head, int k) \\n    {\\n        if(k==0|| head == NULL|| head->next==NULL)return head;\\n\\n         ListNode*end = head;\\n        ListNode* temp;\\n        int len =0;\\n\\n        while(end->next)\\n        {\\n             end = end->next;\\n             len++;\\n        }\\n        len++;\\n\\n        cout<<len<<endl;\\n        \\n        k = k%len;\\n        \\n        int cnt=0;\\n        \\n        while(--k)\\n        {\\n            temp = head->next;\\n            end->next = head;\\n            \\n            head->next=NULL;\\n            \\n            end = head;\\n            head = temp;\\n        }\\n        \\n        return head;\\n    }"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "What the fuck is wrong with test case 12??? k=2000000000??? WTF!!! Seriously LeetCode"
                    },
                    {
                        "username": "anshul_0077",
                        "content": "bro u dont have to run loop k times . k rotations and k%size rotation will give the same link list\\n"
                    }
                ]
            },
            {
                "id": 1925587,
                "content": [
                    {
                        "username": "Akash_Verma2000",
                        "content": "FOLLOW THESE STEPS TO SOLVE THIS PROBLEM\\n //connect the tail to the head\\n        //figure out the optimum value of k BY K=K%length of list\\n        //pointer=length-k\\n        //travel till pointer\\n        //secure the ListNode at the next of the pointer in another ListNode \\n        //point the same to null"
                    },
                    {
                        "username": "Yashdahiya295",
                        "content": "OPTIMAL SOLUTION :C++\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next == NULL ||k==0)\\n     {\\n          return head ;\\n     }\\n\\n     //Compute the length of the linked list \\n     ListNode* cur = head ;\\n     int len = 1;\\n     while(cur->next!=NULL)\\n     {\\n          ++len ;\\n          cur = cur->next ;\\n     }\\n\\n     //Pointing the last node to the head;\\n     cur->next = head ;\\n     k = k % len ;//Like if we have 12 rotation and k = 5 then till 10 rotation its same as the original linked list , so we do this .\\n     k = len - k ; // So that we can able to know how much we have to traverse from the head .\\n     while(k--)\\n     {\\n          cur = cur->next ;\\n     }\\n\\n     //Make the node to the head and break the connection\\n     head = cur->next ;\\n     cur->next = NULL ;\\n\\n\\n     return head;\\n\\n    }\\n}; \\nTC : O(N). , SC: O(1).   "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Optimal rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jyotiraditya",
                        "content": "Hint : Take an example of rotating a cirucular linked list. "
                    },
                    {
                        "username": "nafSadh",
                        "content": "In most (if not all) questions, OJ defined struct/class use NULL instead of nullptr. Why is that?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "Probably author preference, but I would guess some authors use nullptr instead of NULL because nullptr was inroduced in C++ to remove the ambiguity of the C NULL which is 0."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach for Beginners:-)**\\n- Calculate the length of the linked list while keeping track of the tail node.\\n- Adjust k by taking its modulo with the list length to find the effective rotation amount.\\n- If k becomes zero, return the original head; no rotation is needed.\\n- Find the new head and new tail nodes after rotation:\\n  - The new tail is k nodes from the end of the list.\\n  - The new head is the node after the new tail.\\n- Break the list at the new tail and reconnect it to the original head, completing the rotation.\\n- Return the new head as the result of the rotation."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/rotate-list/solutions/4087567/easiest-solution-beginner-friendly-straight-forward/?envType=study-plan-v2&envId=top-interview-150"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Rotating Linked List is very similar to rotating array. I am sure that you might be worked on sorted rotated array while learning on Binary search. The approach will same. let\\'s code it.\\n# Approach\\n1 : Find Last node and connect with head.\\n2 : How many times need to skip or rotate, skip = length - k.\\n3 : Find the rotation that how many times it rotated (k). mean skip = length - rotation.\\n4 : Once you found the last node connect with head and put null in last node.\\n5 : return head."
                    },
                    {
                        "username": "user8272RT",
                        "content": "I struggled to write clean code for this problem. Need more practice! "
                    },
                    {
                        "username": "SiddhantP",
                        "content": "If Anyone is struggling,\\n\\n1. Get the List Length, and Do k % length to find out how much rotation is needed.\\n2. Traverse using 2 Pointers (Difference between them == k % length).\\n3. When fast pointer hits null, Just Append anything after slow pointer before head. (This part is bit tricky, take care that you don\\'t accidently create Infinite Linked list).\\n\\nHope this helps...\\n\\nRef : [My Submission - O(n)](https://leetcode.com/problems/rotate-list/solutions/3778788/c-2-pointers-faster-than-90-of-the-submissions/)"
                    },
                    {
                        "username": "Abhaydeep_Sharma",
                        "content": "Can any body tell whats wrong in this code\\n\\n ListNode* rotateRight(ListNode* head, int k) \\n    {\\n        if(k==0|| head == NULL|| head->next==NULL)return head;\\n\\n         ListNode*end = head;\\n        ListNode* temp;\\n        int len =0;\\n\\n        while(end->next)\\n        {\\n             end = end->next;\\n             len++;\\n        }\\n        len++;\\n\\n        cout<<len<<endl;\\n        \\n        k = k%len;\\n        \\n        int cnt=0;\\n        \\n        while(--k)\\n        {\\n            temp = head->next;\\n            end->next = head;\\n            \\n            head->next=NULL;\\n            \\n            end = head;\\n            head = temp;\\n        }\\n        \\n        return head;\\n    }"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "What the fuck is wrong with test case 12??? k=2000000000??? WTF!!! Seriously LeetCode"
                    },
                    {
                        "username": "anshul_0077",
                        "content": "bro u dont have to run loop k times . k rotations and k%size rotation will give the same link list\\n"
                    }
                ]
            },
            {
                "id": 1922249,
                "content": [
                    {
                        "username": "anshul_0077",
                        "content": "I DONT KNOW WHY ITS THROWING RUNTIME ERROR SOMEONE PLS HELP :(\\n\\n      class Solution {\\n     public:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n         \\n           if(head==NULL) return NULL;\\n          if(head->next==NULL) return head;\\n        vector<ListNode*> v;\\n        ListNode* temp=head;\\n\\n        while(temp){\\n            v.push_back(temp);\\n            temp=temp->next;\\n        }\\n        int n=v.size()-1;\\n        int indx=abs(n-k)+1;\\n        \\n        if(indx==0) return head;\\n        else{\\n            v[indx-1]->next=NULL;\\n            v[n]->next=head;\\n            head=v[indx];\\n            return head;\\n        }\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n\\n        if(head==null || head.next==null){\\n            return head;\\n        }\\n        while(k!=0){\\n            ListNode current = head;\\n            ListNode previous = null;\\n\\n            while (current.next != null) {\\n            previous = current;\\n            current = current.next;\\n        }\\n\\n            previous.next = null;\\n            current.next = head;\\n            head = current;\\n            k--;\\n        }\\n        return head;\\n    }\\n}\\nTry this one..."
                    },
                    {
                        "username": "utkarshcs",
                        "content": "Very Easy Solution In JAVA\n\nclass Solution {\n    public ListNode rr(ListNode head, int k){\n        if(k==0){\n            return head;\n        }\n        ListNode prev = null;\n        ListNode current = head;\n        while(current.next!=null){\n            prev = current;\n            current = current.next;\n        }\n\n\n        prev.next = null;\n        current.next = head;\n        head = current;\n        ListNode aa = rr(head,--k);\n\n        return aa;\n\n    }\n\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head==null || head.next==null || k==0){\n            return head;\n        }\n        int a=0;\n        ListNode temp = head;\n        while(temp!=null){\n            a++;\n            temp = temp.next;\n        }\n        k = k%a;\n        ListNode ans = rr(head,k);\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case no 12 ,k\\'s value is 200000000 \\n"
                    },
                    {
                        "username": "kingofjong",
                        "content": "In PHP I get the error Uncaught Error: Attempt to assign property \"next\" on null in solution.php. I am not trying to assign a null to value. I am assigning a variable which was set to null to another value. I assign variable to null and then reassign them bunch times in PHP at my job. Why is the error showing up?"
                    },
                    {
                        "username": "kamrantaslimdos",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n     if(head == null || head.next == null) return head;\\n\\n     ListNode pre = null,cur = head;\\n     int size = 0;\\n\\n     while(cur != null){\\n         pre = cur;\\n         cur = cur.next; \\n         size++;\\n\\n     }   \\n     cur = head;\\n     pre.next = cur;\\n     \\n     int rotate = k % size;\\n\\n     int location = size - rotate;\\n\\n     for(int i=0; i< location; i++){\\n         pre = cur;\\n         cur = cur.next;\\n     } \\n     pre.next = null;\\n     return cur;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "my code is say time limit  exceeded what should i do"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/rotate-list/solutions/3125965/js-linear-time-linear-space-doubly-linked-list/\\n\\nLinear time and space"
                    },
                    {
                        "username": "thisisankit_27",
                        "content": "Can the Approach we used in Reverse Array be used in Array List?\\n\\nreverse (nums.begin() , nums.end());\\nreverse (nums.begin() , nums.begin() + k);\\nreverse (nums.begin() + k , nums.end());"
                    },
                    {
                        "username": "apurvakhatri2011",
                        "content": "Why is my head not changing? At the end it returns the old head.\\n\\nclass Solution {\\npublic:\\n    \\n    ListNode* findLengthAndTail(ListNode* head, int* ptr){\\n        ListNode* tail;\\n        ListNode* curr = head;\\n        while(curr!=NULL){\\n            *ptr+=1;\\n            if(curr->next == NULL) tail = curr;\\n            curr = curr->next;\\n        }\\n        return tail;\\n    }\\n\\n    void rotate(ListNode* head, ListNode* tail, int* pos){\\n        cout<<\"Inside head address is: \"<<head<<endl;\\n        int k = 1;\\n        ListNode* curr = head;\\n        while(k!=*pos){\\n            curr = curr->next;\\n            k+=1;\\n        }\\n        //cout<<\"Curr is at: \"<<curr->val<<endl;\\n        tail->next = head;\\n        //cout<<\"Tail and its next are: \"<<tail->val<<\" \"<<tail->next->val<<endl;\\n        head = curr->next;\\n        //cout<<\"New head is: \"<<head->val<<endl;\\n        curr->next = NULL;\\n        //cout<<\"Curr is: \"<<curr->val<<endl;\\n    }\\n\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL) return head;\\n        \\n        int length = 0;\\n        int* ptr = &length;\\n        ListNode* tail = findLengthAndTail(head, ptr);\\n        //cout<<\"Length and tail are: \"<<length<<\" \"<<tail->val<<endl;\\n        if(k%length==0) return head;\\n        int pos = (length - k%length);\\n        cout<<\"Head address is: \"<<head<<endl;\\n        rotate(head, tail, &pos);\\n        //cout<<\"Head here is: \"<<head->val<<endl;\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1900433,
                "content": [
                    {
                        "username": "anshul_0077",
                        "content": "I DONT KNOW WHY ITS THROWING RUNTIME ERROR SOMEONE PLS HELP :(\\n\\n      class Solution {\\n     public:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n         \\n           if(head==NULL) return NULL;\\n          if(head->next==NULL) return head;\\n        vector<ListNode*> v;\\n        ListNode* temp=head;\\n\\n        while(temp){\\n            v.push_back(temp);\\n            temp=temp->next;\\n        }\\n        int n=v.size()-1;\\n        int indx=abs(n-k)+1;\\n        \\n        if(indx==0) return head;\\n        else{\\n            v[indx-1]->next=NULL;\\n            v[n]->next=head;\\n            head=v[indx];\\n            return head;\\n        }\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n\\n        if(head==null || head.next==null){\\n            return head;\\n        }\\n        while(k!=0){\\n            ListNode current = head;\\n            ListNode previous = null;\\n\\n            while (current.next != null) {\\n            previous = current;\\n            current = current.next;\\n        }\\n\\n            previous.next = null;\\n            current.next = head;\\n            head = current;\\n            k--;\\n        }\\n        return head;\\n    }\\n}\\nTry this one..."
                    },
                    {
                        "username": "utkarshcs",
                        "content": "Very Easy Solution In JAVA\n\nclass Solution {\n    public ListNode rr(ListNode head, int k){\n        if(k==0){\n            return head;\n        }\n        ListNode prev = null;\n        ListNode current = head;\n        while(current.next!=null){\n            prev = current;\n            current = current.next;\n        }\n\n\n        prev.next = null;\n        current.next = head;\n        head = current;\n        ListNode aa = rr(head,--k);\n\n        return aa;\n\n    }\n\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head==null || head.next==null || k==0){\n            return head;\n        }\n        int a=0;\n        ListNode temp = head;\n        while(temp!=null){\n            a++;\n            temp = temp.next;\n        }\n        k = k%a;\n        ListNode ans = rr(head,k);\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case no 12 ,k\\'s value is 200000000 \\n"
                    },
                    {
                        "username": "kingofjong",
                        "content": "In PHP I get the error Uncaught Error: Attempt to assign property \"next\" on null in solution.php. I am not trying to assign a null to value. I am assigning a variable which was set to null to another value. I assign variable to null and then reassign them bunch times in PHP at my job. Why is the error showing up?"
                    },
                    {
                        "username": "kamrantaslimdos",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n     if(head == null || head.next == null) return head;\\n\\n     ListNode pre = null,cur = head;\\n     int size = 0;\\n\\n     while(cur != null){\\n         pre = cur;\\n         cur = cur.next; \\n         size++;\\n\\n     }   \\n     cur = head;\\n     pre.next = cur;\\n     \\n     int rotate = k % size;\\n\\n     int location = size - rotate;\\n\\n     for(int i=0; i< location; i++){\\n         pre = cur;\\n         cur = cur.next;\\n     } \\n     pre.next = null;\\n     return cur;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "my code is say time limit  exceeded what should i do"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/rotate-list/solutions/3125965/js-linear-time-linear-space-doubly-linked-list/\\n\\nLinear time and space"
                    },
                    {
                        "username": "thisisankit_27",
                        "content": "Can the Approach we used in Reverse Array be used in Array List?\\n\\nreverse (nums.begin() , nums.end());\\nreverse (nums.begin() , nums.begin() + k);\\nreverse (nums.begin() + k , nums.end());"
                    },
                    {
                        "username": "apurvakhatri2011",
                        "content": "Why is my head not changing? At the end it returns the old head.\\n\\nclass Solution {\\npublic:\\n    \\n    ListNode* findLengthAndTail(ListNode* head, int* ptr){\\n        ListNode* tail;\\n        ListNode* curr = head;\\n        while(curr!=NULL){\\n            *ptr+=1;\\n            if(curr->next == NULL) tail = curr;\\n            curr = curr->next;\\n        }\\n        return tail;\\n    }\\n\\n    void rotate(ListNode* head, ListNode* tail, int* pos){\\n        cout<<\"Inside head address is: \"<<head<<endl;\\n        int k = 1;\\n        ListNode* curr = head;\\n        while(k!=*pos){\\n            curr = curr->next;\\n            k+=1;\\n        }\\n        //cout<<\"Curr is at: \"<<curr->val<<endl;\\n        tail->next = head;\\n        //cout<<\"Tail and its next are: \"<<tail->val<<\" \"<<tail->next->val<<endl;\\n        head = curr->next;\\n        //cout<<\"New head is: \"<<head->val<<endl;\\n        curr->next = NULL;\\n        //cout<<\"Curr is: \"<<curr->val<<endl;\\n    }\\n\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL) return head;\\n        \\n        int length = 0;\\n        int* ptr = &length;\\n        ListNode* tail = findLengthAndTail(head, ptr);\\n        //cout<<\"Length and tail are: \"<<length<<\" \"<<tail->val<<endl;\\n        if(k%length==0) return head;\\n        int pos = (length - k%length);\\n        cout<<\"Head address is: \"<<head<<endl;\\n        rotate(head, tail, &pos);\\n        //cout<<\"Head here is: \"<<head->val<<endl;\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1898535,
                "content": [
                    {
                        "username": "anshul_0077",
                        "content": "I DONT KNOW WHY ITS THROWING RUNTIME ERROR SOMEONE PLS HELP :(\\n\\n      class Solution {\\n     public:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n         \\n           if(head==NULL) return NULL;\\n          if(head->next==NULL) return head;\\n        vector<ListNode*> v;\\n        ListNode* temp=head;\\n\\n        while(temp){\\n            v.push_back(temp);\\n            temp=temp->next;\\n        }\\n        int n=v.size()-1;\\n        int indx=abs(n-k)+1;\\n        \\n        if(indx==0) return head;\\n        else{\\n            v[indx-1]->next=NULL;\\n            v[n]->next=head;\\n            head=v[indx];\\n            return head;\\n        }\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n\\n        if(head==null || head.next==null){\\n            return head;\\n        }\\n        while(k!=0){\\n            ListNode current = head;\\n            ListNode previous = null;\\n\\n            while (current.next != null) {\\n            previous = current;\\n            current = current.next;\\n        }\\n\\n            previous.next = null;\\n            current.next = head;\\n            head = current;\\n            k--;\\n        }\\n        return head;\\n    }\\n}\\nTry this one..."
                    },
                    {
                        "username": "utkarshcs",
                        "content": "Very Easy Solution In JAVA\n\nclass Solution {\n    public ListNode rr(ListNode head, int k){\n        if(k==0){\n            return head;\n        }\n        ListNode prev = null;\n        ListNode current = head;\n        while(current.next!=null){\n            prev = current;\n            current = current.next;\n        }\n\n\n        prev.next = null;\n        current.next = head;\n        head = current;\n        ListNode aa = rr(head,--k);\n\n        return aa;\n\n    }\n\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head==null || head.next==null || k==0){\n            return head;\n        }\n        int a=0;\n        ListNode temp = head;\n        while(temp!=null){\n            a++;\n            temp = temp.next;\n        }\n        k = k%a;\n        ListNode ans = rr(head,k);\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case no 12 ,k\\'s value is 200000000 \\n"
                    },
                    {
                        "username": "kingofjong",
                        "content": "In PHP I get the error Uncaught Error: Attempt to assign property \"next\" on null in solution.php. I am not trying to assign a null to value. I am assigning a variable which was set to null to another value. I assign variable to null and then reassign them bunch times in PHP at my job. Why is the error showing up?"
                    },
                    {
                        "username": "kamrantaslimdos",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n     if(head == null || head.next == null) return head;\\n\\n     ListNode pre = null,cur = head;\\n     int size = 0;\\n\\n     while(cur != null){\\n         pre = cur;\\n         cur = cur.next; \\n         size++;\\n\\n     }   \\n     cur = head;\\n     pre.next = cur;\\n     \\n     int rotate = k % size;\\n\\n     int location = size - rotate;\\n\\n     for(int i=0; i< location; i++){\\n         pre = cur;\\n         cur = cur.next;\\n     } \\n     pre.next = null;\\n     return cur;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "my code is say time limit  exceeded what should i do"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/rotate-list/solutions/3125965/js-linear-time-linear-space-doubly-linked-list/\\n\\nLinear time and space"
                    },
                    {
                        "username": "thisisankit_27",
                        "content": "Can the Approach we used in Reverse Array be used in Array List?\\n\\nreverse (nums.begin() , nums.end());\\nreverse (nums.begin() , nums.begin() + k);\\nreverse (nums.begin() + k , nums.end());"
                    },
                    {
                        "username": "apurvakhatri2011",
                        "content": "Why is my head not changing? At the end it returns the old head.\\n\\nclass Solution {\\npublic:\\n    \\n    ListNode* findLengthAndTail(ListNode* head, int* ptr){\\n        ListNode* tail;\\n        ListNode* curr = head;\\n        while(curr!=NULL){\\n            *ptr+=1;\\n            if(curr->next == NULL) tail = curr;\\n            curr = curr->next;\\n        }\\n        return tail;\\n    }\\n\\n    void rotate(ListNode* head, ListNode* tail, int* pos){\\n        cout<<\"Inside head address is: \"<<head<<endl;\\n        int k = 1;\\n        ListNode* curr = head;\\n        while(k!=*pos){\\n            curr = curr->next;\\n            k+=1;\\n        }\\n        //cout<<\"Curr is at: \"<<curr->val<<endl;\\n        tail->next = head;\\n        //cout<<\"Tail and its next are: \"<<tail->val<<\" \"<<tail->next->val<<endl;\\n        head = curr->next;\\n        //cout<<\"New head is: \"<<head->val<<endl;\\n        curr->next = NULL;\\n        //cout<<\"Curr is: \"<<curr->val<<endl;\\n    }\\n\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL) return head;\\n        \\n        int length = 0;\\n        int* ptr = &length;\\n        ListNode* tail = findLengthAndTail(head, ptr);\\n        //cout<<\"Length and tail are: \"<<length<<\" \"<<tail->val<<endl;\\n        if(k%length==0) return head;\\n        int pos = (length - k%length);\\n        cout<<\"Head address is: \"<<head<<endl;\\n        rotate(head, tail, &pos);\\n        //cout<<\"Head here is: \"<<head->val<<endl;\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1893809,
                "content": [
                    {
                        "username": "anshul_0077",
                        "content": "I DONT KNOW WHY ITS THROWING RUNTIME ERROR SOMEONE PLS HELP :(\\n\\n      class Solution {\\n     public:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n         \\n           if(head==NULL) return NULL;\\n          if(head->next==NULL) return head;\\n        vector<ListNode*> v;\\n        ListNode* temp=head;\\n\\n        while(temp){\\n            v.push_back(temp);\\n            temp=temp->next;\\n        }\\n        int n=v.size()-1;\\n        int indx=abs(n-k)+1;\\n        \\n        if(indx==0) return head;\\n        else{\\n            v[indx-1]->next=NULL;\\n            v[n]->next=head;\\n            head=v[indx];\\n            return head;\\n        }\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n\\n        if(head==null || head.next==null){\\n            return head;\\n        }\\n        while(k!=0){\\n            ListNode current = head;\\n            ListNode previous = null;\\n\\n            while (current.next != null) {\\n            previous = current;\\n            current = current.next;\\n        }\\n\\n            previous.next = null;\\n            current.next = head;\\n            head = current;\\n            k--;\\n        }\\n        return head;\\n    }\\n}\\nTry this one..."
                    },
                    {
                        "username": "utkarshcs",
                        "content": "Very Easy Solution In JAVA\n\nclass Solution {\n    public ListNode rr(ListNode head, int k){\n        if(k==0){\n            return head;\n        }\n        ListNode prev = null;\n        ListNode current = head;\n        while(current.next!=null){\n            prev = current;\n            current = current.next;\n        }\n\n\n        prev.next = null;\n        current.next = head;\n        head = current;\n        ListNode aa = rr(head,--k);\n\n        return aa;\n\n    }\n\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head==null || head.next==null || k==0){\n            return head;\n        }\n        int a=0;\n        ListNode temp = head;\n        while(temp!=null){\n            a++;\n            temp = temp.next;\n        }\n        k = k%a;\n        ListNode ans = rr(head,k);\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case no 12 ,k\\'s value is 200000000 \\n"
                    },
                    {
                        "username": "kingofjong",
                        "content": "In PHP I get the error Uncaught Error: Attempt to assign property \"next\" on null in solution.php. I am not trying to assign a null to value. I am assigning a variable which was set to null to another value. I assign variable to null and then reassign them bunch times in PHP at my job. Why is the error showing up?"
                    },
                    {
                        "username": "kamrantaslimdos",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n     if(head == null || head.next == null) return head;\\n\\n     ListNode pre = null,cur = head;\\n     int size = 0;\\n\\n     while(cur != null){\\n         pre = cur;\\n         cur = cur.next; \\n         size++;\\n\\n     }   \\n     cur = head;\\n     pre.next = cur;\\n     \\n     int rotate = k % size;\\n\\n     int location = size - rotate;\\n\\n     for(int i=0; i< location; i++){\\n         pre = cur;\\n         cur = cur.next;\\n     } \\n     pre.next = null;\\n     return cur;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "my code is say time limit  exceeded what should i do"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/rotate-list/solutions/3125965/js-linear-time-linear-space-doubly-linked-list/\\n\\nLinear time and space"
                    },
                    {
                        "username": "thisisankit_27",
                        "content": "Can the Approach we used in Reverse Array be used in Array List?\\n\\nreverse (nums.begin() , nums.end());\\nreverse (nums.begin() , nums.begin() + k);\\nreverse (nums.begin() + k , nums.end());"
                    },
                    {
                        "username": "apurvakhatri2011",
                        "content": "Why is my head not changing? At the end it returns the old head.\\n\\nclass Solution {\\npublic:\\n    \\n    ListNode* findLengthAndTail(ListNode* head, int* ptr){\\n        ListNode* tail;\\n        ListNode* curr = head;\\n        while(curr!=NULL){\\n            *ptr+=1;\\n            if(curr->next == NULL) tail = curr;\\n            curr = curr->next;\\n        }\\n        return tail;\\n    }\\n\\n    void rotate(ListNode* head, ListNode* tail, int* pos){\\n        cout<<\"Inside head address is: \"<<head<<endl;\\n        int k = 1;\\n        ListNode* curr = head;\\n        while(k!=*pos){\\n            curr = curr->next;\\n            k+=1;\\n        }\\n        //cout<<\"Curr is at: \"<<curr->val<<endl;\\n        tail->next = head;\\n        //cout<<\"Tail and its next are: \"<<tail->val<<\" \"<<tail->next->val<<endl;\\n        head = curr->next;\\n        //cout<<\"New head is: \"<<head->val<<endl;\\n        curr->next = NULL;\\n        //cout<<\"Curr is: \"<<curr->val<<endl;\\n    }\\n\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL) return head;\\n        \\n        int length = 0;\\n        int* ptr = &length;\\n        ListNode* tail = findLengthAndTail(head, ptr);\\n        //cout<<\"Length and tail are: \"<<length<<\" \"<<tail->val<<endl;\\n        if(k%length==0) return head;\\n        int pos = (length - k%length);\\n        cout<<\"Head address is: \"<<head<<endl;\\n        rotate(head, tail, &pos);\\n        //cout<<\"Head here is: \"<<head->val<<endl;\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1820728,
                "content": [
                    {
                        "username": "anshul_0077",
                        "content": "I DONT KNOW WHY ITS THROWING RUNTIME ERROR SOMEONE PLS HELP :(\\n\\n      class Solution {\\n     public:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n         \\n           if(head==NULL) return NULL;\\n          if(head->next==NULL) return head;\\n        vector<ListNode*> v;\\n        ListNode* temp=head;\\n\\n        while(temp){\\n            v.push_back(temp);\\n            temp=temp->next;\\n        }\\n        int n=v.size()-1;\\n        int indx=abs(n-k)+1;\\n        \\n        if(indx==0) return head;\\n        else{\\n            v[indx-1]->next=NULL;\\n            v[n]->next=head;\\n            head=v[indx];\\n            return head;\\n        }\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n\\n        if(head==null || head.next==null){\\n            return head;\\n        }\\n        while(k!=0){\\n            ListNode current = head;\\n            ListNode previous = null;\\n\\n            while (current.next != null) {\\n            previous = current;\\n            current = current.next;\\n        }\\n\\n            previous.next = null;\\n            current.next = head;\\n            head = current;\\n            k--;\\n        }\\n        return head;\\n    }\\n}\\nTry this one..."
                    },
                    {
                        "username": "utkarshcs",
                        "content": "Very Easy Solution In JAVA\n\nclass Solution {\n    public ListNode rr(ListNode head, int k){\n        if(k==0){\n            return head;\n        }\n        ListNode prev = null;\n        ListNode current = head;\n        while(current.next!=null){\n            prev = current;\n            current = current.next;\n        }\n\n\n        prev.next = null;\n        current.next = head;\n        head = current;\n        ListNode aa = rr(head,--k);\n\n        return aa;\n\n    }\n\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head==null || head.next==null || k==0){\n            return head;\n        }\n        int a=0;\n        ListNode temp = head;\n        while(temp!=null){\n            a++;\n            temp = temp.next;\n        }\n        k = k%a;\n        ListNode ans = rr(head,k);\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case no 12 ,k\\'s value is 200000000 \\n"
                    },
                    {
                        "username": "kingofjong",
                        "content": "In PHP I get the error Uncaught Error: Attempt to assign property \"next\" on null in solution.php. I am not trying to assign a null to value. I am assigning a variable which was set to null to another value. I assign variable to null and then reassign them bunch times in PHP at my job. Why is the error showing up?"
                    },
                    {
                        "username": "kamrantaslimdos",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n     if(head == null || head.next == null) return head;\\n\\n     ListNode pre = null,cur = head;\\n     int size = 0;\\n\\n     while(cur != null){\\n         pre = cur;\\n         cur = cur.next; \\n         size++;\\n\\n     }   \\n     cur = head;\\n     pre.next = cur;\\n     \\n     int rotate = k % size;\\n\\n     int location = size - rotate;\\n\\n     for(int i=0; i< location; i++){\\n         pre = cur;\\n         cur = cur.next;\\n     } \\n     pre.next = null;\\n     return cur;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "my code is say time limit  exceeded what should i do"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/rotate-list/solutions/3125965/js-linear-time-linear-space-doubly-linked-list/\\n\\nLinear time and space"
                    },
                    {
                        "username": "thisisankit_27",
                        "content": "Can the Approach we used in Reverse Array be used in Array List?\\n\\nreverse (nums.begin() , nums.end());\\nreverse (nums.begin() , nums.begin() + k);\\nreverse (nums.begin() + k , nums.end());"
                    },
                    {
                        "username": "apurvakhatri2011",
                        "content": "Why is my head not changing? At the end it returns the old head.\\n\\nclass Solution {\\npublic:\\n    \\n    ListNode* findLengthAndTail(ListNode* head, int* ptr){\\n        ListNode* tail;\\n        ListNode* curr = head;\\n        while(curr!=NULL){\\n            *ptr+=1;\\n            if(curr->next == NULL) tail = curr;\\n            curr = curr->next;\\n        }\\n        return tail;\\n    }\\n\\n    void rotate(ListNode* head, ListNode* tail, int* pos){\\n        cout<<\"Inside head address is: \"<<head<<endl;\\n        int k = 1;\\n        ListNode* curr = head;\\n        while(k!=*pos){\\n            curr = curr->next;\\n            k+=1;\\n        }\\n        //cout<<\"Curr is at: \"<<curr->val<<endl;\\n        tail->next = head;\\n        //cout<<\"Tail and its next are: \"<<tail->val<<\" \"<<tail->next->val<<endl;\\n        head = curr->next;\\n        //cout<<\"New head is: \"<<head->val<<endl;\\n        curr->next = NULL;\\n        //cout<<\"Curr is: \"<<curr->val<<endl;\\n    }\\n\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL) return head;\\n        \\n        int length = 0;\\n        int* ptr = &length;\\n        ListNode* tail = findLengthAndTail(head, ptr);\\n        //cout<<\"Length and tail are: \"<<length<<\" \"<<tail->val<<endl;\\n        if(k%length==0) return head;\\n        int pos = (length - k%length);\\n        cout<<\"Head address is: \"<<head<<endl;\\n        rotate(head, tail, &pos);\\n        //cout<<\"Head here is: \"<<head->val<<endl;\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1803655,
                "content": [
                    {
                        "username": "anshul_0077",
                        "content": "I DONT KNOW WHY ITS THROWING RUNTIME ERROR SOMEONE PLS HELP :(\\n\\n      class Solution {\\n     public:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n         \\n           if(head==NULL) return NULL;\\n          if(head->next==NULL) return head;\\n        vector<ListNode*> v;\\n        ListNode* temp=head;\\n\\n        while(temp){\\n            v.push_back(temp);\\n            temp=temp->next;\\n        }\\n        int n=v.size()-1;\\n        int indx=abs(n-k)+1;\\n        \\n        if(indx==0) return head;\\n        else{\\n            v[indx-1]->next=NULL;\\n            v[n]->next=head;\\n            head=v[indx];\\n            return head;\\n        }\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n\\n        if(head==null || head.next==null){\\n            return head;\\n        }\\n        while(k!=0){\\n            ListNode current = head;\\n            ListNode previous = null;\\n\\n            while (current.next != null) {\\n            previous = current;\\n            current = current.next;\\n        }\\n\\n            previous.next = null;\\n            current.next = head;\\n            head = current;\\n            k--;\\n        }\\n        return head;\\n    }\\n}\\nTry this one..."
                    },
                    {
                        "username": "utkarshcs",
                        "content": "Very Easy Solution In JAVA\n\nclass Solution {\n    public ListNode rr(ListNode head, int k){\n        if(k==0){\n            return head;\n        }\n        ListNode prev = null;\n        ListNode current = head;\n        while(current.next!=null){\n            prev = current;\n            current = current.next;\n        }\n\n\n        prev.next = null;\n        current.next = head;\n        head = current;\n        ListNode aa = rr(head,--k);\n\n        return aa;\n\n    }\n\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head==null || head.next==null || k==0){\n            return head;\n        }\n        int a=0;\n        ListNode temp = head;\n        while(temp!=null){\n            a++;\n            temp = temp.next;\n        }\n        k = k%a;\n        ListNode ans = rr(head,k);\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case no 12 ,k\\'s value is 200000000 \\n"
                    },
                    {
                        "username": "kingofjong",
                        "content": "In PHP I get the error Uncaught Error: Attempt to assign property \"next\" on null in solution.php. I am not trying to assign a null to value. I am assigning a variable which was set to null to another value. I assign variable to null and then reassign them bunch times in PHP at my job. Why is the error showing up?"
                    },
                    {
                        "username": "kamrantaslimdos",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n     if(head == null || head.next == null) return head;\\n\\n     ListNode pre = null,cur = head;\\n     int size = 0;\\n\\n     while(cur != null){\\n         pre = cur;\\n         cur = cur.next; \\n         size++;\\n\\n     }   \\n     cur = head;\\n     pre.next = cur;\\n     \\n     int rotate = k % size;\\n\\n     int location = size - rotate;\\n\\n     for(int i=0; i< location; i++){\\n         pre = cur;\\n         cur = cur.next;\\n     } \\n     pre.next = null;\\n     return cur;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "my code is say time limit  exceeded what should i do"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/rotate-list/solutions/3125965/js-linear-time-linear-space-doubly-linked-list/\\n\\nLinear time and space"
                    },
                    {
                        "username": "thisisankit_27",
                        "content": "Can the Approach we used in Reverse Array be used in Array List?\\n\\nreverse (nums.begin() , nums.end());\\nreverse (nums.begin() , nums.begin() + k);\\nreverse (nums.begin() + k , nums.end());"
                    },
                    {
                        "username": "apurvakhatri2011",
                        "content": "Why is my head not changing? At the end it returns the old head.\\n\\nclass Solution {\\npublic:\\n    \\n    ListNode* findLengthAndTail(ListNode* head, int* ptr){\\n        ListNode* tail;\\n        ListNode* curr = head;\\n        while(curr!=NULL){\\n            *ptr+=1;\\n            if(curr->next == NULL) tail = curr;\\n            curr = curr->next;\\n        }\\n        return tail;\\n    }\\n\\n    void rotate(ListNode* head, ListNode* tail, int* pos){\\n        cout<<\"Inside head address is: \"<<head<<endl;\\n        int k = 1;\\n        ListNode* curr = head;\\n        while(k!=*pos){\\n            curr = curr->next;\\n            k+=1;\\n        }\\n        //cout<<\"Curr is at: \"<<curr->val<<endl;\\n        tail->next = head;\\n        //cout<<\"Tail and its next are: \"<<tail->val<<\" \"<<tail->next->val<<endl;\\n        head = curr->next;\\n        //cout<<\"New head is: \"<<head->val<<endl;\\n        curr->next = NULL;\\n        //cout<<\"Curr is: \"<<curr->val<<endl;\\n    }\\n\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL) return head;\\n        \\n        int length = 0;\\n        int* ptr = &length;\\n        ListNode* tail = findLengthAndTail(head, ptr);\\n        //cout<<\"Length and tail are: \"<<length<<\" \"<<tail->val<<endl;\\n        if(k%length==0) return head;\\n        int pos = (length - k%length);\\n        cout<<\"Head address is: \"<<head<<endl;\\n        rotate(head, tail, &pos);\\n        //cout<<\"Head here is: \"<<head->val<<endl;\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1783054,
                "content": [
                    {
                        "username": "anshul_0077",
                        "content": "I DONT KNOW WHY ITS THROWING RUNTIME ERROR SOMEONE PLS HELP :(\\n\\n      class Solution {\\n     public:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n         \\n           if(head==NULL) return NULL;\\n          if(head->next==NULL) return head;\\n        vector<ListNode*> v;\\n        ListNode* temp=head;\\n\\n        while(temp){\\n            v.push_back(temp);\\n            temp=temp->next;\\n        }\\n        int n=v.size()-1;\\n        int indx=abs(n-k)+1;\\n        \\n        if(indx==0) return head;\\n        else{\\n            v[indx-1]->next=NULL;\\n            v[n]->next=head;\\n            head=v[indx];\\n            return head;\\n        }\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n\\n        if(head==null || head.next==null){\\n            return head;\\n        }\\n        while(k!=0){\\n            ListNode current = head;\\n            ListNode previous = null;\\n\\n            while (current.next != null) {\\n            previous = current;\\n            current = current.next;\\n        }\\n\\n            previous.next = null;\\n            current.next = head;\\n            head = current;\\n            k--;\\n        }\\n        return head;\\n    }\\n}\\nTry this one..."
                    },
                    {
                        "username": "utkarshcs",
                        "content": "Very Easy Solution In JAVA\n\nclass Solution {\n    public ListNode rr(ListNode head, int k){\n        if(k==0){\n            return head;\n        }\n        ListNode prev = null;\n        ListNode current = head;\n        while(current.next!=null){\n            prev = current;\n            current = current.next;\n        }\n\n\n        prev.next = null;\n        current.next = head;\n        head = current;\n        ListNode aa = rr(head,--k);\n\n        return aa;\n\n    }\n\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head==null || head.next==null || k==0){\n            return head;\n        }\n        int a=0;\n        ListNode temp = head;\n        while(temp!=null){\n            a++;\n            temp = temp.next;\n        }\n        k = k%a;\n        ListNode ans = rr(head,k);\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case no 12 ,k\\'s value is 200000000 \\n"
                    },
                    {
                        "username": "kingofjong",
                        "content": "In PHP I get the error Uncaught Error: Attempt to assign property \"next\" on null in solution.php. I am not trying to assign a null to value. I am assigning a variable which was set to null to another value. I assign variable to null and then reassign them bunch times in PHP at my job. Why is the error showing up?"
                    },
                    {
                        "username": "kamrantaslimdos",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n     if(head == null || head.next == null) return head;\\n\\n     ListNode pre = null,cur = head;\\n     int size = 0;\\n\\n     while(cur != null){\\n         pre = cur;\\n         cur = cur.next; \\n         size++;\\n\\n     }   \\n     cur = head;\\n     pre.next = cur;\\n     \\n     int rotate = k % size;\\n\\n     int location = size - rotate;\\n\\n     for(int i=0; i< location; i++){\\n         pre = cur;\\n         cur = cur.next;\\n     } \\n     pre.next = null;\\n     return cur;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "my code is say time limit  exceeded what should i do"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/rotate-list/solutions/3125965/js-linear-time-linear-space-doubly-linked-list/\\n\\nLinear time and space"
                    },
                    {
                        "username": "thisisankit_27",
                        "content": "Can the Approach we used in Reverse Array be used in Array List?\\n\\nreverse (nums.begin() , nums.end());\\nreverse (nums.begin() , nums.begin() + k);\\nreverse (nums.begin() + k , nums.end());"
                    },
                    {
                        "username": "apurvakhatri2011",
                        "content": "Why is my head not changing? At the end it returns the old head.\\n\\nclass Solution {\\npublic:\\n    \\n    ListNode* findLengthAndTail(ListNode* head, int* ptr){\\n        ListNode* tail;\\n        ListNode* curr = head;\\n        while(curr!=NULL){\\n            *ptr+=1;\\n            if(curr->next == NULL) tail = curr;\\n            curr = curr->next;\\n        }\\n        return tail;\\n    }\\n\\n    void rotate(ListNode* head, ListNode* tail, int* pos){\\n        cout<<\"Inside head address is: \"<<head<<endl;\\n        int k = 1;\\n        ListNode* curr = head;\\n        while(k!=*pos){\\n            curr = curr->next;\\n            k+=1;\\n        }\\n        //cout<<\"Curr is at: \"<<curr->val<<endl;\\n        tail->next = head;\\n        //cout<<\"Tail and its next are: \"<<tail->val<<\" \"<<tail->next->val<<endl;\\n        head = curr->next;\\n        //cout<<\"New head is: \"<<head->val<<endl;\\n        curr->next = NULL;\\n        //cout<<\"Curr is: \"<<curr->val<<endl;\\n    }\\n\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL) return head;\\n        \\n        int length = 0;\\n        int* ptr = &length;\\n        ListNode* tail = findLengthAndTail(head, ptr);\\n        //cout<<\"Length and tail are: \"<<length<<\" \"<<tail->val<<endl;\\n        if(k%length==0) return head;\\n        int pos = (length - k%length);\\n        cout<<\"Head address is: \"<<head<<endl;\\n        rotate(head, tail, &pos);\\n        //cout<<\"Head here is: \"<<head->val<<endl;\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1776911,
                "content": [
                    {
                        "username": "anshul_0077",
                        "content": "I DONT KNOW WHY ITS THROWING RUNTIME ERROR SOMEONE PLS HELP :(\\n\\n      class Solution {\\n     public:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n         \\n           if(head==NULL) return NULL;\\n          if(head->next==NULL) return head;\\n        vector<ListNode*> v;\\n        ListNode* temp=head;\\n\\n        while(temp){\\n            v.push_back(temp);\\n            temp=temp->next;\\n        }\\n        int n=v.size()-1;\\n        int indx=abs(n-k)+1;\\n        \\n        if(indx==0) return head;\\n        else{\\n            v[indx-1]->next=NULL;\\n            v[n]->next=head;\\n            head=v[indx];\\n            return head;\\n        }\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n\\n        if(head==null || head.next==null){\\n            return head;\\n        }\\n        while(k!=0){\\n            ListNode current = head;\\n            ListNode previous = null;\\n\\n            while (current.next != null) {\\n            previous = current;\\n            current = current.next;\\n        }\\n\\n            previous.next = null;\\n            current.next = head;\\n            head = current;\\n            k--;\\n        }\\n        return head;\\n    }\\n}\\nTry this one..."
                    },
                    {
                        "username": "utkarshcs",
                        "content": "Very Easy Solution In JAVA\n\nclass Solution {\n    public ListNode rr(ListNode head, int k){\n        if(k==0){\n            return head;\n        }\n        ListNode prev = null;\n        ListNode current = head;\n        while(current.next!=null){\n            prev = current;\n            current = current.next;\n        }\n\n\n        prev.next = null;\n        current.next = head;\n        head = current;\n        ListNode aa = rr(head,--k);\n\n        return aa;\n\n    }\n\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head==null || head.next==null || k==0){\n            return head;\n        }\n        int a=0;\n        ListNode temp = head;\n        while(temp!=null){\n            a++;\n            temp = temp.next;\n        }\n        k = k%a;\n        ListNode ans = rr(head,k);\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case no 12 ,k\\'s value is 200000000 \\n"
                    },
                    {
                        "username": "kingofjong",
                        "content": "In PHP I get the error Uncaught Error: Attempt to assign property \"next\" on null in solution.php. I am not trying to assign a null to value. I am assigning a variable which was set to null to another value. I assign variable to null and then reassign them bunch times in PHP at my job. Why is the error showing up?"
                    },
                    {
                        "username": "kamrantaslimdos",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n     if(head == null || head.next == null) return head;\\n\\n     ListNode pre = null,cur = head;\\n     int size = 0;\\n\\n     while(cur != null){\\n         pre = cur;\\n         cur = cur.next; \\n         size++;\\n\\n     }   \\n     cur = head;\\n     pre.next = cur;\\n     \\n     int rotate = k % size;\\n\\n     int location = size - rotate;\\n\\n     for(int i=0; i< location; i++){\\n         pre = cur;\\n         cur = cur.next;\\n     } \\n     pre.next = null;\\n     return cur;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "my code is say time limit  exceeded what should i do"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/rotate-list/solutions/3125965/js-linear-time-linear-space-doubly-linked-list/\\n\\nLinear time and space"
                    },
                    {
                        "username": "thisisankit_27",
                        "content": "Can the Approach we used in Reverse Array be used in Array List?\\n\\nreverse (nums.begin() , nums.end());\\nreverse (nums.begin() , nums.begin() + k);\\nreverse (nums.begin() + k , nums.end());"
                    },
                    {
                        "username": "apurvakhatri2011",
                        "content": "Why is my head not changing? At the end it returns the old head.\\n\\nclass Solution {\\npublic:\\n    \\n    ListNode* findLengthAndTail(ListNode* head, int* ptr){\\n        ListNode* tail;\\n        ListNode* curr = head;\\n        while(curr!=NULL){\\n            *ptr+=1;\\n            if(curr->next == NULL) tail = curr;\\n            curr = curr->next;\\n        }\\n        return tail;\\n    }\\n\\n    void rotate(ListNode* head, ListNode* tail, int* pos){\\n        cout<<\"Inside head address is: \"<<head<<endl;\\n        int k = 1;\\n        ListNode* curr = head;\\n        while(k!=*pos){\\n            curr = curr->next;\\n            k+=1;\\n        }\\n        //cout<<\"Curr is at: \"<<curr->val<<endl;\\n        tail->next = head;\\n        //cout<<\"Tail and its next are: \"<<tail->val<<\" \"<<tail->next->val<<endl;\\n        head = curr->next;\\n        //cout<<\"New head is: \"<<head->val<<endl;\\n        curr->next = NULL;\\n        //cout<<\"Curr is: \"<<curr->val<<endl;\\n    }\\n\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL) return head;\\n        \\n        int length = 0;\\n        int* ptr = &length;\\n        ListNode* tail = findLengthAndTail(head, ptr);\\n        //cout<<\"Length and tail are: \"<<length<<\" \"<<tail->val<<endl;\\n        if(k%length==0) return head;\\n        int pos = (length - k%length);\\n        cout<<\"Head address is: \"<<head<<endl;\\n        rotate(head, tail, &pos);\\n        //cout<<\"Head here is: \"<<head->val<<endl;\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1761133,
                "content": [
                    {
                        "username": "anshul_0077",
                        "content": "I DONT KNOW WHY ITS THROWING RUNTIME ERROR SOMEONE PLS HELP :(\\n\\n      class Solution {\\n     public:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n         \\n           if(head==NULL) return NULL;\\n          if(head->next==NULL) return head;\\n        vector<ListNode*> v;\\n        ListNode* temp=head;\\n\\n        while(temp){\\n            v.push_back(temp);\\n            temp=temp->next;\\n        }\\n        int n=v.size()-1;\\n        int indx=abs(n-k)+1;\\n        \\n        if(indx==0) return head;\\n        else{\\n            v[indx-1]->next=NULL;\\n            v[n]->next=head;\\n            head=v[indx];\\n            return head;\\n        }\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n\\n        if(head==null || head.next==null){\\n            return head;\\n        }\\n        while(k!=0){\\n            ListNode current = head;\\n            ListNode previous = null;\\n\\n            while (current.next != null) {\\n            previous = current;\\n            current = current.next;\\n        }\\n\\n            previous.next = null;\\n            current.next = head;\\n            head = current;\\n            k--;\\n        }\\n        return head;\\n    }\\n}\\nTry this one..."
                    },
                    {
                        "username": "utkarshcs",
                        "content": "Very Easy Solution In JAVA\n\nclass Solution {\n    public ListNode rr(ListNode head, int k){\n        if(k==0){\n            return head;\n        }\n        ListNode prev = null;\n        ListNode current = head;\n        while(current.next!=null){\n            prev = current;\n            current = current.next;\n        }\n\n\n        prev.next = null;\n        current.next = head;\n        head = current;\n        ListNode aa = rr(head,--k);\n\n        return aa;\n\n    }\n\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head==null || head.next==null || k==0){\n            return head;\n        }\n        int a=0;\n        ListNode temp = head;\n        while(temp!=null){\n            a++;\n            temp = temp.next;\n        }\n        k = k%a;\n        ListNode ans = rr(head,k);\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case no 12 ,k\\'s value is 200000000 \\n"
                    },
                    {
                        "username": "kingofjong",
                        "content": "In PHP I get the error Uncaught Error: Attempt to assign property \"next\" on null in solution.php. I am not trying to assign a null to value. I am assigning a variable which was set to null to another value. I assign variable to null and then reassign them bunch times in PHP at my job. Why is the error showing up?"
                    },
                    {
                        "username": "kamrantaslimdos",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n     if(head == null || head.next == null) return head;\\n\\n     ListNode pre = null,cur = head;\\n     int size = 0;\\n\\n     while(cur != null){\\n         pre = cur;\\n         cur = cur.next; \\n         size++;\\n\\n     }   \\n     cur = head;\\n     pre.next = cur;\\n     \\n     int rotate = k % size;\\n\\n     int location = size - rotate;\\n\\n     for(int i=0; i< location; i++){\\n         pre = cur;\\n         cur = cur.next;\\n     } \\n     pre.next = null;\\n     return cur;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "my code is say time limit  exceeded what should i do"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/rotate-list/solutions/3125965/js-linear-time-linear-space-doubly-linked-list/\\n\\nLinear time and space"
                    },
                    {
                        "username": "thisisankit_27",
                        "content": "Can the Approach we used in Reverse Array be used in Array List?\\n\\nreverse (nums.begin() , nums.end());\\nreverse (nums.begin() , nums.begin() + k);\\nreverse (nums.begin() + k , nums.end());"
                    },
                    {
                        "username": "apurvakhatri2011",
                        "content": "Why is my head not changing? At the end it returns the old head.\\n\\nclass Solution {\\npublic:\\n    \\n    ListNode* findLengthAndTail(ListNode* head, int* ptr){\\n        ListNode* tail;\\n        ListNode* curr = head;\\n        while(curr!=NULL){\\n            *ptr+=1;\\n            if(curr->next == NULL) tail = curr;\\n            curr = curr->next;\\n        }\\n        return tail;\\n    }\\n\\n    void rotate(ListNode* head, ListNode* tail, int* pos){\\n        cout<<\"Inside head address is: \"<<head<<endl;\\n        int k = 1;\\n        ListNode* curr = head;\\n        while(k!=*pos){\\n            curr = curr->next;\\n            k+=1;\\n        }\\n        //cout<<\"Curr is at: \"<<curr->val<<endl;\\n        tail->next = head;\\n        //cout<<\"Tail and its next are: \"<<tail->val<<\" \"<<tail->next->val<<endl;\\n        head = curr->next;\\n        //cout<<\"New head is: \"<<head->val<<endl;\\n        curr->next = NULL;\\n        //cout<<\"Curr is: \"<<curr->val<<endl;\\n    }\\n\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL) return head;\\n        \\n        int length = 0;\\n        int* ptr = &length;\\n        ListNode* tail = findLengthAndTail(head, ptr);\\n        //cout<<\"Length and tail are: \"<<length<<\" \"<<tail->val<<endl;\\n        if(k%length==0) return head;\\n        int pos = (length - k%length);\\n        cout<<\"Head address is: \"<<head<<endl;\\n        rotate(head, tail, &pos);\\n        //cout<<\"Head here is: \"<<head->val<<endl;\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1760988,
                "content": [
                    {
                        "username": "anshul_0077",
                        "content": "I DONT KNOW WHY ITS THROWING RUNTIME ERROR SOMEONE PLS HELP :(\\n\\n      class Solution {\\n     public:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n         \\n           if(head==NULL) return NULL;\\n          if(head->next==NULL) return head;\\n        vector<ListNode*> v;\\n        ListNode* temp=head;\\n\\n        while(temp){\\n            v.push_back(temp);\\n            temp=temp->next;\\n        }\\n        int n=v.size()-1;\\n        int indx=abs(n-k)+1;\\n        \\n        if(indx==0) return head;\\n        else{\\n            v[indx-1]->next=NULL;\\n            v[n]->next=head;\\n            head=v[indx];\\n            return head;\\n        }\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n\\n        if(head==null || head.next==null){\\n            return head;\\n        }\\n        while(k!=0){\\n            ListNode current = head;\\n            ListNode previous = null;\\n\\n            while (current.next != null) {\\n            previous = current;\\n            current = current.next;\\n        }\\n\\n            previous.next = null;\\n            current.next = head;\\n            head = current;\\n            k--;\\n        }\\n        return head;\\n    }\\n}\\nTry this one..."
                    },
                    {
                        "username": "utkarshcs",
                        "content": "Very Easy Solution In JAVA\n\nclass Solution {\n    public ListNode rr(ListNode head, int k){\n        if(k==0){\n            return head;\n        }\n        ListNode prev = null;\n        ListNode current = head;\n        while(current.next!=null){\n            prev = current;\n            current = current.next;\n        }\n\n\n        prev.next = null;\n        current.next = head;\n        head = current;\n        ListNode aa = rr(head,--k);\n\n        return aa;\n\n    }\n\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head==null || head.next==null || k==0){\n            return head;\n        }\n        int a=0;\n        ListNode temp = head;\n        while(temp!=null){\n            a++;\n            temp = temp.next;\n        }\n        k = k%a;\n        ListNode ans = rr(head,k);\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case no 12 ,k\\'s value is 200000000 \\n"
                    },
                    {
                        "username": "kingofjong",
                        "content": "In PHP I get the error Uncaught Error: Attempt to assign property \"next\" on null in solution.php. I am not trying to assign a null to value. I am assigning a variable which was set to null to another value. I assign variable to null and then reassign them bunch times in PHP at my job. Why is the error showing up?"
                    },
                    {
                        "username": "kamrantaslimdos",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n     if(head == null || head.next == null) return head;\\n\\n     ListNode pre = null,cur = head;\\n     int size = 0;\\n\\n     while(cur != null){\\n         pre = cur;\\n         cur = cur.next; \\n         size++;\\n\\n     }   \\n     cur = head;\\n     pre.next = cur;\\n     \\n     int rotate = k % size;\\n\\n     int location = size - rotate;\\n\\n     for(int i=0; i< location; i++){\\n         pre = cur;\\n         cur = cur.next;\\n     } \\n     pre.next = null;\\n     return cur;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "my code is say time limit  exceeded what should i do"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/rotate-list/solutions/3125965/js-linear-time-linear-space-doubly-linked-list/\\n\\nLinear time and space"
                    },
                    {
                        "username": "thisisankit_27",
                        "content": "Can the Approach we used in Reverse Array be used in Array List?\\n\\nreverse (nums.begin() , nums.end());\\nreverse (nums.begin() , nums.begin() + k);\\nreverse (nums.begin() + k , nums.end());"
                    },
                    {
                        "username": "apurvakhatri2011",
                        "content": "Why is my head not changing? At the end it returns the old head.\\n\\nclass Solution {\\npublic:\\n    \\n    ListNode* findLengthAndTail(ListNode* head, int* ptr){\\n        ListNode* tail;\\n        ListNode* curr = head;\\n        while(curr!=NULL){\\n            *ptr+=1;\\n            if(curr->next == NULL) tail = curr;\\n            curr = curr->next;\\n        }\\n        return tail;\\n    }\\n\\n    void rotate(ListNode* head, ListNode* tail, int* pos){\\n        cout<<\"Inside head address is: \"<<head<<endl;\\n        int k = 1;\\n        ListNode* curr = head;\\n        while(k!=*pos){\\n            curr = curr->next;\\n            k+=1;\\n        }\\n        //cout<<\"Curr is at: \"<<curr->val<<endl;\\n        tail->next = head;\\n        //cout<<\"Tail and its next are: \"<<tail->val<<\" \"<<tail->next->val<<endl;\\n        head = curr->next;\\n        //cout<<\"New head is: \"<<head->val<<endl;\\n        curr->next = NULL;\\n        //cout<<\"Curr is: \"<<curr->val<<endl;\\n    }\\n\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL) return head;\\n        \\n        int length = 0;\\n        int* ptr = &length;\\n        ListNode* tail = findLengthAndTail(head, ptr);\\n        //cout<<\"Length and tail are: \"<<length<<\" \"<<tail->val<<endl;\\n        if(k%length==0) return head;\\n        int pos = (length - k%length);\\n        cout<<\"Head address is: \"<<head<<endl;\\n        rotate(head, tail, &pos);\\n        //cout<<\"Head here is: \"<<head->val<<endl;\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1759017,
                "content": [
                    {
                        "username": "ashu_2206",
                        "content": "class Solution { public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null)\\n      return head;\\n      ListNode tail=head;\\n      ListNode newHead=head;\\n      \\n           int len=1;\\n             while(tail.next!=null)\\n             {\\n                 len++;\\n                 tail=tail.next;\\n\\n             }\\n        tail.next=head;\\n        k=k%len;\\n        for(int i=0;i<len-k;i++)   tail=tail.next;\\n        newHead=tail.next;\\n        tail.next=null;\\n        return newHead;\\n        \\n         \\n         \\n\\n        \\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "why take length 1\\n"
                    },
                    {
                        "username": "ryabkin",
                        "content": "k is up to 10^9 - nice joke =)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "  ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL||k==0){\\n            return head;\\n        }\\n        ListNode*temp=head;\\n        int n=0;\\n        while(temp->next!=NULL){\\n            temp=temp->next;\\n            n++;\\n        }\\n        temp->next=head;\\n        k=k%(n+1);\\n        int jump=n-k;\\n        temp=head;\\n        while(jump){\\n            temp=temp->next;\\n            jump--;\\n        }\\n        ListNode*returnHead=temp->next;\\n        temp->next=NULL;\\n        return returnHead;\\n\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "edupuganti_tarun_venkata_sai",
                        "content": "class Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        int len=1;\\n        ListNode iter=head;\\n        ListNode iter1=head;\\n        if(head==null){\\n            return head;\\n        }\\n        while(iter.next!=null){\\n          len++;\\n          iter=iter.next;\\n        }\\n        k=k%len;\\n        if(k==0){\\n           return head;\\n        }\\n        \\n        int skip=len-k-1;\\n        \\n        \\n        while(skip-- >0){\\n            iter1=iter1.next;\\n        }\\n\\n        iter.next=head;\\n        head=iter1.next;\\n        iter1.next=null;\\n        \\n        \\n        return head;\\n    }   \\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "In my opinion, linked lists such as this problem have always been very annoying problems to deal with. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Learning to program in LISP has increased my skills with linked lists to the nth degree."
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || k==0 || head.next==null)\\n           return head;\\n        ListNode currentNode=head;\\n        int n=1;\\n        while(currentNode.next!=null){\\n            n++;\\n            currentNode=currentNode.next;\\n        }\\n      \\n        k=k%n;\\n        if(k==0)\\n          return head; \\n        ListNode secondNode=head;\\n        ListNode newnode=secondNode.next;\\n        int i=1;\\n        int j=n-k;\\n        while(i<j){\\n            secondNode=secondNode.next;\\n            newnode=secondNode.next;\\n            i++;\\n        }\\n        currentNode.next=head;\\n        secondNode.next=null;\\n        head=newnode;\\n        return head;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Well this took me far more attempts than it should have..."
                    },
                    {
                        "username": "deleted_user",
                        "content": "C++ solution[leetcode](https://leetcode.com)https://github.com/lets-do-code/rotate-list-leetcode-solution"
                    },
                    {
                        "username": "om_prakash9-",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(k==0){\\n            return head;\\n        }\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        else if(head->next==NULL){\\n            return head;\\n        }\\n        int n=0;\\n        ListNode*iter=head;\\n        while(iter!=NULL){\\n            n++;\\n            iter=iter->next;\\n        }\\n        int rotate=0;\\n        if(k<n){\\n            rotate=k;\\n        }\\n        else{\\n            rotate=k%n;\\n        }\\n        int target=n-rotate;\\n        if(k%n==0){\\n            return head;\\n        }\\n        cout<<\"target\"<<target<<endl;\\n        int flag=1;\\n        ListNode *temp=head,*nh,*null;\\n        while(temp!=NULL){\\n            if(flag==target){\\n                nh=temp->next;\\n                null=temp;\\n                break;\\n            }\\n            flag++;\\n            temp=temp->next;\\n        }\\n        ListNode* op=nh;\\n        null->next=NULL;\\n        while(op!=NULL){\\n            if(op->next==NULL){\\n                op->next=head;\\n                break;\\n            }\\n            op=op->next;\\n        }\\n        return nh;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ablinux",
                        "content": "100% fast 0ms run time..\\n\\n `struct ListNode* rotateRight(struct ListNode* head, int k){\\n    /* here we need 3 pointer 1, head, tail and prv pointer */\\n    struct ListNode *newHead,*prvNode,*endNode,*temp = NULL;\\n    \\n    if(!head) return NULL;\\n    if(head->next == NULL) return head;\\n    /* 1st approch */\\n\\n    /* let travel the list and find th last element */\\n    temp = head;\\n    int nodeCount = 0;\\n    while(temp)\\n    {\\n        nodeCount ++; /* stored count */\\n        temp = temp->next;\\n        if(temp)\\n            endNode = temp; /* stored end node */\\n    }\\n\\n    /* lets find out the number of rotation needed */\\n    if(k%nodeCount)\\n    {\\n        k = k%nodeCount;\\n        k = nodeCount - k ; /* here the actual number from where we can split the list and joint with head\\n        which in sense looks like a rotation of list */\\n        k = nodeCount - k;\\n    }\\n    else\\n    {\\n        k = 0;\\n    }\\n    printf(\"k = %d  nodeCount = %d\",k,nodeCount);\\n    temp = head;\\n    while(temp)\\n    {\\n        prvNode = temp;\\n        if(k == nodeCount-1)\\n        {\\n            endNode->next = head;\\n            head = prvNode->next;\\n            prvNode->next = NULL;\\n            return head;\\n        }\\n        nodeCount --;\\n        temp = temp->next;\\n    }\\n\\n\\n    return head;\\n\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% fast rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1750297,
                "content": [
                    {
                        "username": "ashu_2206",
                        "content": "class Solution { public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null)\\n      return head;\\n      ListNode tail=head;\\n      ListNode newHead=head;\\n      \\n           int len=1;\\n             while(tail.next!=null)\\n             {\\n                 len++;\\n                 tail=tail.next;\\n\\n             }\\n        tail.next=head;\\n        k=k%len;\\n        for(int i=0;i<len-k;i++)   tail=tail.next;\\n        newHead=tail.next;\\n        tail.next=null;\\n        return newHead;\\n        \\n         \\n         \\n\\n        \\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "why take length 1\\n"
                    },
                    {
                        "username": "ryabkin",
                        "content": "k is up to 10^9 - nice joke =)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "  ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL||k==0){\\n            return head;\\n        }\\n        ListNode*temp=head;\\n        int n=0;\\n        while(temp->next!=NULL){\\n            temp=temp->next;\\n            n++;\\n        }\\n        temp->next=head;\\n        k=k%(n+1);\\n        int jump=n-k;\\n        temp=head;\\n        while(jump){\\n            temp=temp->next;\\n            jump--;\\n        }\\n        ListNode*returnHead=temp->next;\\n        temp->next=NULL;\\n        return returnHead;\\n\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "edupuganti_tarun_venkata_sai",
                        "content": "class Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        int len=1;\\n        ListNode iter=head;\\n        ListNode iter1=head;\\n        if(head==null){\\n            return head;\\n        }\\n        while(iter.next!=null){\\n          len++;\\n          iter=iter.next;\\n        }\\n        k=k%len;\\n        if(k==0){\\n           return head;\\n        }\\n        \\n        int skip=len-k-1;\\n        \\n        \\n        while(skip-- >0){\\n            iter1=iter1.next;\\n        }\\n\\n        iter.next=head;\\n        head=iter1.next;\\n        iter1.next=null;\\n        \\n        \\n        return head;\\n    }   \\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "In my opinion, linked lists such as this problem have always been very annoying problems to deal with. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Learning to program in LISP has increased my skills with linked lists to the nth degree."
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || k==0 || head.next==null)\\n           return head;\\n        ListNode currentNode=head;\\n        int n=1;\\n        while(currentNode.next!=null){\\n            n++;\\n            currentNode=currentNode.next;\\n        }\\n      \\n        k=k%n;\\n        if(k==0)\\n          return head; \\n        ListNode secondNode=head;\\n        ListNode newnode=secondNode.next;\\n        int i=1;\\n        int j=n-k;\\n        while(i<j){\\n            secondNode=secondNode.next;\\n            newnode=secondNode.next;\\n            i++;\\n        }\\n        currentNode.next=head;\\n        secondNode.next=null;\\n        head=newnode;\\n        return head;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Well this took me far more attempts than it should have..."
                    },
                    {
                        "username": "deleted_user",
                        "content": "C++ solution[leetcode](https://leetcode.com)https://github.com/lets-do-code/rotate-list-leetcode-solution"
                    },
                    {
                        "username": "om_prakash9-",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(k==0){\\n            return head;\\n        }\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        else if(head->next==NULL){\\n            return head;\\n        }\\n        int n=0;\\n        ListNode*iter=head;\\n        while(iter!=NULL){\\n            n++;\\n            iter=iter->next;\\n        }\\n        int rotate=0;\\n        if(k<n){\\n            rotate=k;\\n        }\\n        else{\\n            rotate=k%n;\\n        }\\n        int target=n-rotate;\\n        if(k%n==0){\\n            return head;\\n        }\\n        cout<<\"target\"<<target<<endl;\\n        int flag=1;\\n        ListNode *temp=head,*nh,*null;\\n        while(temp!=NULL){\\n            if(flag==target){\\n                nh=temp->next;\\n                null=temp;\\n                break;\\n            }\\n            flag++;\\n            temp=temp->next;\\n        }\\n        ListNode* op=nh;\\n        null->next=NULL;\\n        while(op!=NULL){\\n            if(op->next==NULL){\\n                op->next=head;\\n                break;\\n            }\\n            op=op->next;\\n        }\\n        return nh;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ablinux",
                        "content": "100% fast 0ms run time..\\n\\n `struct ListNode* rotateRight(struct ListNode* head, int k){\\n    /* here we need 3 pointer 1, head, tail and prv pointer */\\n    struct ListNode *newHead,*prvNode,*endNode,*temp = NULL;\\n    \\n    if(!head) return NULL;\\n    if(head->next == NULL) return head;\\n    /* 1st approch */\\n\\n    /* let travel the list and find th last element */\\n    temp = head;\\n    int nodeCount = 0;\\n    while(temp)\\n    {\\n        nodeCount ++; /* stored count */\\n        temp = temp->next;\\n        if(temp)\\n            endNode = temp; /* stored end node */\\n    }\\n\\n    /* lets find out the number of rotation needed */\\n    if(k%nodeCount)\\n    {\\n        k = k%nodeCount;\\n        k = nodeCount - k ; /* here the actual number from where we can split the list and joint with head\\n        which in sense looks like a rotation of list */\\n        k = nodeCount - k;\\n    }\\n    else\\n    {\\n        k = 0;\\n    }\\n    printf(\"k = %d  nodeCount = %d\",k,nodeCount);\\n    temp = head;\\n    while(temp)\\n    {\\n        prvNode = temp;\\n        if(k == nodeCount-1)\\n        {\\n            endNode->next = head;\\n            head = prvNode->next;\\n            prvNode->next = NULL;\\n            return head;\\n        }\\n        nodeCount --;\\n        temp = temp->next;\\n    }\\n\\n\\n    return head;\\n\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% fast rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1749436,
                "content": [
                    {
                        "username": "ashu_2206",
                        "content": "class Solution { public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null)\\n      return head;\\n      ListNode tail=head;\\n      ListNode newHead=head;\\n      \\n           int len=1;\\n             while(tail.next!=null)\\n             {\\n                 len++;\\n                 tail=tail.next;\\n\\n             }\\n        tail.next=head;\\n        k=k%len;\\n        for(int i=0;i<len-k;i++)   tail=tail.next;\\n        newHead=tail.next;\\n        tail.next=null;\\n        return newHead;\\n        \\n         \\n         \\n\\n        \\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "why take length 1\\n"
                    },
                    {
                        "username": "ryabkin",
                        "content": "k is up to 10^9 - nice joke =)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "  ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL||k==0){\\n            return head;\\n        }\\n        ListNode*temp=head;\\n        int n=0;\\n        while(temp->next!=NULL){\\n            temp=temp->next;\\n            n++;\\n        }\\n        temp->next=head;\\n        k=k%(n+1);\\n        int jump=n-k;\\n        temp=head;\\n        while(jump){\\n            temp=temp->next;\\n            jump--;\\n        }\\n        ListNode*returnHead=temp->next;\\n        temp->next=NULL;\\n        return returnHead;\\n\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "edupuganti_tarun_venkata_sai",
                        "content": "class Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        int len=1;\\n        ListNode iter=head;\\n        ListNode iter1=head;\\n        if(head==null){\\n            return head;\\n        }\\n        while(iter.next!=null){\\n          len++;\\n          iter=iter.next;\\n        }\\n        k=k%len;\\n        if(k==0){\\n           return head;\\n        }\\n        \\n        int skip=len-k-1;\\n        \\n        \\n        while(skip-- >0){\\n            iter1=iter1.next;\\n        }\\n\\n        iter.next=head;\\n        head=iter1.next;\\n        iter1.next=null;\\n        \\n        \\n        return head;\\n    }   \\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "In my opinion, linked lists such as this problem have always been very annoying problems to deal with. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Learning to program in LISP has increased my skills with linked lists to the nth degree."
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || k==0 || head.next==null)\\n           return head;\\n        ListNode currentNode=head;\\n        int n=1;\\n        while(currentNode.next!=null){\\n            n++;\\n            currentNode=currentNode.next;\\n        }\\n      \\n        k=k%n;\\n        if(k==0)\\n          return head; \\n        ListNode secondNode=head;\\n        ListNode newnode=secondNode.next;\\n        int i=1;\\n        int j=n-k;\\n        while(i<j){\\n            secondNode=secondNode.next;\\n            newnode=secondNode.next;\\n            i++;\\n        }\\n        currentNode.next=head;\\n        secondNode.next=null;\\n        head=newnode;\\n        return head;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Well this took me far more attempts than it should have..."
                    },
                    {
                        "username": "deleted_user",
                        "content": "C++ solution[leetcode](https://leetcode.com)https://github.com/lets-do-code/rotate-list-leetcode-solution"
                    },
                    {
                        "username": "om_prakash9-",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(k==0){\\n            return head;\\n        }\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        else if(head->next==NULL){\\n            return head;\\n        }\\n        int n=0;\\n        ListNode*iter=head;\\n        while(iter!=NULL){\\n            n++;\\n            iter=iter->next;\\n        }\\n        int rotate=0;\\n        if(k<n){\\n            rotate=k;\\n        }\\n        else{\\n            rotate=k%n;\\n        }\\n        int target=n-rotate;\\n        if(k%n==0){\\n            return head;\\n        }\\n        cout<<\"target\"<<target<<endl;\\n        int flag=1;\\n        ListNode *temp=head,*nh,*null;\\n        while(temp!=NULL){\\n            if(flag==target){\\n                nh=temp->next;\\n                null=temp;\\n                break;\\n            }\\n            flag++;\\n            temp=temp->next;\\n        }\\n        ListNode* op=nh;\\n        null->next=NULL;\\n        while(op!=NULL){\\n            if(op->next==NULL){\\n                op->next=head;\\n                break;\\n            }\\n            op=op->next;\\n        }\\n        return nh;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ablinux",
                        "content": "100% fast 0ms run time..\\n\\n `struct ListNode* rotateRight(struct ListNode* head, int k){\\n    /* here we need 3 pointer 1, head, tail and prv pointer */\\n    struct ListNode *newHead,*prvNode,*endNode,*temp = NULL;\\n    \\n    if(!head) return NULL;\\n    if(head->next == NULL) return head;\\n    /* 1st approch */\\n\\n    /* let travel the list and find th last element */\\n    temp = head;\\n    int nodeCount = 0;\\n    while(temp)\\n    {\\n        nodeCount ++; /* stored count */\\n        temp = temp->next;\\n        if(temp)\\n            endNode = temp; /* stored end node */\\n    }\\n\\n    /* lets find out the number of rotation needed */\\n    if(k%nodeCount)\\n    {\\n        k = k%nodeCount;\\n        k = nodeCount - k ; /* here the actual number from where we can split the list and joint with head\\n        which in sense looks like a rotation of list */\\n        k = nodeCount - k;\\n    }\\n    else\\n    {\\n        k = 0;\\n    }\\n    printf(\"k = %d  nodeCount = %d\",k,nodeCount);\\n    temp = head;\\n    while(temp)\\n    {\\n        prvNode = temp;\\n        if(k == nodeCount-1)\\n        {\\n            endNode->next = head;\\n            head = prvNode->next;\\n            prvNode->next = NULL;\\n            return head;\\n        }\\n        nodeCount --;\\n        temp = temp->next;\\n    }\\n\\n\\n    return head;\\n\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% fast rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1745710,
                "content": [
                    {
                        "username": "ashu_2206",
                        "content": "class Solution { public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null)\\n      return head;\\n      ListNode tail=head;\\n      ListNode newHead=head;\\n      \\n           int len=1;\\n             while(tail.next!=null)\\n             {\\n                 len++;\\n                 tail=tail.next;\\n\\n             }\\n        tail.next=head;\\n        k=k%len;\\n        for(int i=0;i<len-k;i++)   tail=tail.next;\\n        newHead=tail.next;\\n        tail.next=null;\\n        return newHead;\\n        \\n         \\n         \\n\\n        \\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "why take length 1\\n"
                    },
                    {
                        "username": "ryabkin",
                        "content": "k is up to 10^9 - nice joke =)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "  ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL||k==0){\\n            return head;\\n        }\\n        ListNode*temp=head;\\n        int n=0;\\n        while(temp->next!=NULL){\\n            temp=temp->next;\\n            n++;\\n        }\\n        temp->next=head;\\n        k=k%(n+1);\\n        int jump=n-k;\\n        temp=head;\\n        while(jump){\\n            temp=temp->next;\\n            jump--;\\n        }\\n        ListNode*returnHead=temp->next;\\n        temp->next=NULL;\\n        return returnHead;\\n\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "edupuganti_tarun_venkata_sai",
                        "content": "class Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        int len=1;\\n        ListNode iter=head;\\n        ListNode iter1=head;\\n        if(head==null){\\n            return head;\\n        }\\n        while(iter.next!=null){\\n          len++;\\n          iter=iter.next;\\n        }\\n        k=k%len;\\n        if(k==0){\\n           return head;\\n        }\\n        \\n        int skip=len-k-1;\\n        \\n        \\n        while(skip-- >0){\\n            iter1=iter1.next;\\n        }\\n\\n        iter.next=head;\\n        head=iter1.next;\\n        iter1.next=null;\\n        \\n        \\n        return head;\\n    }   \\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "In my opinion, linked lists such as this problem have always been very annoying problems to deal with. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Learning to program in LISP has increased my skills with linked lists to the nth degree."
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || k==0 || head.next==null)\\n           return head;\\n        ListNode currentNode=head;\\n        int n=1;\\n        while(currentNode.next!=null){\\n            n++;\\n            currentNode=currentNode.next;\\n        }\\n      \\n        k=k%n;\\n        if(k==0)\\n          return head; \\n        ListNode secondNode=head;\\n        ListNode newnode=secondNode.next;\\n        int i=1;\\n        int j=n-k;\\n        while(i<j){\\n            secondNode=secondNode.next;\\n            newnode=secondNode.next;\\n            i++;\\n        }\\n        currentNode.next=head;\\n        secondNode.next=null;\\n        head=newnode;\\n        return head;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Well this took me far more attempts than it should have..."
                    },
                    {
                        "username": "deleted_user",
                        "content": "C++ solution[leetcode](https://leetcode.com)https://github.com/lets-do-code/rotate-list-leetcode-solution"
                    },
                    {
                        "username": "om_prakash9-",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(k==0){\\n            return head;\\n        }\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        else if(head->next==NULL){\\n            return head;\\n        }\\n        int n=0;\\n        ListNode*iter=head;\\n        while(iter!=NULL){\\n            n++;\\n            iter=iter->next;\\n        }\\n        int rotate=0;\\n        if(k<n){\\n            rotate=k;\\n        }\\n        else{\\n            rotate=k%n;\\n        }\\n        int target=n-rotate;\\n        if(k%n==0){\\n            return head;\\n        }\\n        cout<<\"target\"<<target<<endl;\\n        int flag=1;\\n        ListNode *temp=head,*nh,*null;\\n        while(temp!=NULL){\\n            if(flag==target){\\n                nh=temp->next;\\n                null=temp;\\n                break;\\n            }\\n            flag++;\\n            temp=temp->next;\\n        }\\n        ListNode* op=nh;\\n        null->next=NULL;\\n        while(op!=NULL){\\n            if(op->next==NULL){\\n                op->next=head;\\n                break;\\n            }\\n            op=op->next;\\n        }\\n        return nh;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ablinux",
                        "content": "100% fast 0ms run time..\\n\\n `struct ListNode* rotateRight(struct ListNode* head, int k){\\n    /* here we need 3 pointer 1, head, tail and prv pointer */\\n    struct ListNode *newHead,*prvNode,*endNode,*temp = NULL;\\n    \\n    if(!head) return NULL;\\n    if(head->next == NULL) return head;\\n    /* 1st approch */\\n\\n    /* let travel the list and find th last element */\\n    temp = head;\\n    int nodeCount = 0;\\n    while(temp)\\n    {\\n        nodeCount ++; /* stored count */\\n        temp = temp->next;\\n        if(temp)\\n            endNode = temp; /* stored end node */\\n    }\\n\\n    /* lets find out the number of rotation needed */\\n    if(k%nodeCount)\\n    {\\n        k = k%nodeCount;\\n        k = nodeCount - k ; /* here the actual number from where we can split the list and joint with head\\n        which in sense looks like a rotation of list */\\n        k = nodeCount - k;\\n    }\\n    else\\n    {\\n        k = 0;\\n    }\\n    printf(\"k = %d  nodeCount = %d\",k,nodeCount);\\n    temp = head;\\n    while(temp)\\n    {\\n        prvNode = temp;\\n        if(k == nodeCount-1)\\n        {\\n            endNode->next = head;\\n            head = prvNode->next;\\n            prvNode->next = NULL;\\n            return head;\\n        }\\n        nodeCount --;\\n        temp = temp->next;\\n    }\\n\\n\\n    return head;\\n\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% fast rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1733208,
                "content": [
                    {
                        "username": "ashu_2206",
                        "content": "class Solution { public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null)\\n      return head;\\n      ListNode tail=head;\\n      ListNode newHead=head;\\n      \\n           int len=1;\\n             while(tail.next!=null)\\n             {\\n                 len++;\\n                 tail=tail.next;\\n\\n             }\\n        tail.next=head;\\n        k=k%len;\\n        for(int i=0;i<len-k;i++)   tail=tail.next;\\n        newHead=tail.next;\\n        tail.next=null;\\n        return newHead;\\n        \\n         \\n         \\n\\n        \\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "why take length 1\\n"
                    },
                    {
                        "username": "ryabkin",
                        "content": "k is up to 10^9 - nice joke =)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "  ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL||k==0){\\n            return head;\\n        }\\n        ListNode*temp=head;\\n        int n=0;\\n        while(temp->next!=NULL){\\n            temp=temp->next;\\n            n++;\\n        }\\n        temp->next=head;\\n        k=k%(n+1);\\n        int jump=n-k;\\n        temp=head;\\n        while(jump){\\n            temp=temp->next;\\n            jump--;\\n        }\\n        ListNode*returnHead=temp->next;\\n        temp->next=NULL;\\n        return returnHead;\\n\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "edupuganti_tarun_venkata_sai",
                        "content": "class Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        int len=1;\\n        ListNode iter=head;\\n        ListNode iter1=head;\\n        if(head==null){\\n            return head;\\n        }\\n        while(iter.next!=null){\\n          len++;\\n          iter=iter.next;\\n        }\\n        k=k%len;\\n        if(k==0){\\n           return head;\\n        }\\n        \\n        int skip=len-k-1;\\n        \\n        \\n        while(skip-- >0){\\n            iter1=iter1.next;\\n        }\\n\\n        iter.next=head;\\n        head=iter1.next;\\n        iter1.next=null;\\n        \\n        \\n        return head;\\n    }   \\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "In my opinion, linked lists such as this problem have always been very annoying problems to deal with. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Learning to program in LISP has increased my skills with linked lists to the nth degree."
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || k==0 || head.next==null)\\n           return head;\\n        ListNode currentNode=head;\\n        int n=1;\\n        while(currentNode.next!=null){\\n            n++;\\n            currentNode=currentNode.next;\\n        }\\n      \\n        k=k%n;\\n        if(k==0)\\n          return head; \\n        ListNode secondNode=head;\\n        ListNode newnode=secondNode.next;\\n        int i=1;\\n        int j=n-k;\\n        while(i<j){\\n            secondNode=secondNode.next;\\n            newnode=secondNode.next;\\n            i++;\\n        }\\n        currentNode.next=head;\\n        secondNode.next=null;\\n        head=newnode;\\n        return head;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Well this took me far more attempts than it should have..."
                    },
                    {
                        "username": "deleted_user",
                        "content": "C++ solution[leetcode](https://leetcode.com)https://github.com/lets-do-code/rotate-list-leetcode-solution"
                    },
                    {
                        "username": "om_prakash9-",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(k==0){\\n            return head;\\n        }\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        else if(head->next==NULL){\\n            return head;\\n        }\\n        int n=0;\\n        ListNode*iter=head;\\n        while(iter!=NULL){\\n            n++;\\n            iter=iter->next;\\n        }\\n        int rotate=0;\\n        if(k<n){\\n            rotate=k;\\n        }\\n        else{\\n            rotate=k%n;\\n        }\\n        int target=n-rotate;\\n        if(k%n==0){\\n            return head;\\n        }\\n        cout<<\"target\"<<target<<endl;\\n        int flag=1;\\n        ListNode *temp=head,*nh,*null;\\n        while(temp!=NULL){\\n            if(flag==target){\\n                nh=temp->next;\\n                null=temp;\\n                break;\\n            }\\n            flag++;\\n            temp=temp->next;\\n        }\\n        ListNode* op=nh;\\n        null->next=NULL;\\n        while(op!=NULL){\\n            if(op->next==NULL){\\n                op->next=head;\\n                break;\\n            }\\n            op=op->next;\\n        }\\n        return nh;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ablinux",
                        "content": "100% fast 0ms run time..\\n\\n `struct ListNode* rotateRight(struct ListNode* head, int k){\\n    /* here we need 3 pointer 1, head, tail and prv pointer */\\n    struct ListNode *newHead,*prvNode,*endNode,*temp = NULL;\\n    \\n    if(!head) return NULL;\\n    if(head->next == NULL) return head;\\n    /* 1st approch */\\n\\n    /* let travel the list and find th last element */\\n    temp = head;\\n    int nodeCount = 0;\\n    while(temp)\\n    {\\n        nodeCount ++; /* stored count */\\n        temp = temp->next;\\n        if(temp)\\n            endNode = temp; /* stored end node */\\n    }\\n\\n    /* lets find out the number of rotation needed */\\n    if(k%nodeCount)\\n    {\\n        k = k%nodeCount;\\n        k = nodeCount - k ; /* here the actual number from where we can split the list and joint with head\\n        which in sense looks like a rotation of list */\\n        k = nodeCount - k;\\n    }\\n    else\\n    {\\n        k = 0;\\n    }\\n    printf(\"k = %d  nodeCount = %d\",k,nodeCount);\\n    temp = head;\\n    while(temp)\\n    {\\n        prvNode = temp;\\n        if(k == nodeCount-1)\\n        {\\n            endNode->next = head;\\n            head = prvNode->next;\\n            prvNode->next = NULL;\\n            return head;\\n        }\\n        nodeCount --;\\n        temp = temp->next;\\n    }\\n\\n\\n    return head;\\n\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% fast rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1727187,
                "content": [
                    {
                        "username": "ashu_2206",
                        "content": "class Solution { public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null)\\n      return head;\\n      ListNode tail=head;\\n      ListNode newHead=head;\\n      \\n           int len=1;\\n             while(tail.next!=null)\\n             {\\n                 len++;\\n                 tail=tail.next;\\n\\n             }\\n        tail.next=head;\\n        k=k%len;\\n        for(int i=0;i<len-k;i++)   tail=tail.next;\\n        newHead=tail.next;\\n        tail.next=null;\\n        return newHead;\\n        \\n         \\n         \\n\\n        \\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "why take length 1\\n"
                    },
                    {
                        "username": "ryabkin",
                        "content": "k is up to 10^9 - nice joke =)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "  ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL||k==0){\\n            return head;\\n        }\\n        ListNode*temp=head;\\n        int n=0;\\n        while(temp->next!=NULL){\\n            temp=temp->next;\\n            n++;\\n        }\\n        temp->next=head;\\n        k=k%(n+1);\\n        int jump=n-k;\\n        temp=head;\\n        while(jump){\\n            temp=temp->next;\\n            jump--;\\n        }\\n        ListNode*returnHead=temp->next;\\n        temp->next=NULL;\\n        return returnHead;\\n\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "edupuganti_tarun_venkata_sai",
                        "content": "class Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        int len=1;\\n        ListNode iter=head;\\n        ListNode iter1=head;\\n        if(head==null){\\n            return head;\\n        }\\n        while(iter.next!=null){\\n          len++;\\n          iter=iter.next;\\n        }\\n        k=k%len;\\n        if(k==0){\\n           return head;\\n        }\\n        \\n        int skip=len-k-1;\\n        \\n        \\n        while(skip-- >0){\\n            iter1=iter1.next;\\n        }\\n\\n        iter.next=head;\\n        head=iter1.next;\\n        iter1.next=null;\\n        \\n        \\n        return head;\\n    }   \\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "In my opinion, linked lists such as this problem have always been very annoying problems to deal with. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Learning to program in LISP has increased my skills with linked lists to the nth degree."
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || k==0 || head.next==null)\\n           return head;\\n        ListNode currentNode=head;\\n        int n=1;\\n        while(currentNode.next!=null){\\n            n++;\\n            currentNode=currentNode.next;\\n        }\\n      \\n        k=k%n;\\n        if(k==0)\\n          return head; \\n        ListNode secondNode=head;\\n        ListNode newnode=secondNode.next;\\n        int i=1;\\n        int j=n-k;\\n        while(i<j){\\n            secondNode=secondNode.next;\\n            newnode=secondNode.next;\\n            i++;\\n        }\\n        currentNode.next=head;\\n        secondNode.next=null;\\n        head=newnode;\\n        return head;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Well this took me far more attempts than it should have..."
                    },
                    {
                        "username": "deleted_user",
                        "content": "C++ solution[leetcode](https://leetcode.com)https://github.com/lets-do-code/rotate-list-leetcode-solution"
                    },
                    {
                        "username": "om_prakash9-",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(k==0){\\n            return head;\\n        }\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        else if(head->next==NULL){\\n            return head;\\n        }\\n        int n=0;\\n        ListNode*iter=head;\\n        while(iter!=NULL){\\n            n++;\\n            iter=iter->next;\\n        }\\n        int rotate=0;\\n        if(k<n){\\n            rotate=k;\\n        }\\n        else{\\n            rotate=k%n;\\n        }\\n        int target=n-rotate;\\n        if(k%n==0){\\n            return head;\\n        }\\n        cout<<\"target\"<<target<<endl;\\n        int flag=1;\\n        ListNode *temp=head,*nh,*null;\\n        while(temp!=NULL){\\n            if(flag==target){\\n                nh=temp->next;\\n                null=temp;\\n                break;\\n            }\\n            flag++;\\n            temp=temp->next;\\n        }\\n        ListNode* op=nh;\\n        null->next=NULL;\\n        while(op!=NULL){\\n            if(op->next==NULL){\\n                op->next=head;\\n                break;\\n            }\\n            op=op->next;\\n        }\\n        return nh;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ablinux",
                        "content": "100% fast 0ms run time..\\n\\n `struct ListNode* rotateRight(struct ListNode* head, int k){\\n    /* here we need 3 pointer 1, head, tail and prv pointer */\\n    struct ListNode *newHead,*prvNode,*endNode,*temp = NULL;\\n    \\n    if(!head) return NULL;\\n    if(head->next == NULL) return head;\\n    /* 1st approch */\\n\\n    /* let travel the list and find th last element */\\n    temp = head;\\n    int nodeCount = 0;\\n    while(temp)\\n    {\\n        nodeCount ++; /* stored count */\\n        temp = temp->next;\\n        if(temp)\\n            endNode = temp; /* stored end node */\\n    }\\n\\n    /* lets find out the number of rotation needed */\\n    if(k%nodeCount)\\n    {\\n        k = k%nodeCount;\\n        k = nodeCount - k ; /* here the actual number from where we can split the list and joint with head\\n        which in sense looks like a rotation of list */\\n        k = nodeCount - k;\\n    }\\n    else\\n    {\\n        k = 0;\\n    }\\n    printf(\"k = %d  nodeCount = %d\",k,nodeCount);\\n    temp = head;\\n    while(temp)\\n    {\\n        prvNode = temp;\\n        if(k == nodeCount-1)\\n        {\\n            endNode->next = head;\\n            head = prvNode->next;\\n            prvNode->next = NULL;\\n            return head;\\n        }\\n        nodeCount --;\\n        temp = temp->next;\\n    }\\n\\n\\n    return head;\\n\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% fast rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1722427,
                "content": [
                    {
                        "username": "ashu_2206",
                        "content": "class Solution { public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null)\\n      return head;\\n      ListNode tail=head;\\n      ListNode newHead=head;\\n      \\n           int len=1;\\n             while(tail.next!=null)\\n             {\\n                 len++;\\n                 tail=tail.next;\\n\\n             }\\n        tail.next=head;\\n        k=k%len;\\n        for(int i=0;i<len-k;i++)   tail=tail.next;\\n        newHead=tail.next;\\n        tail.next=null;\\n        return newHead;\\n        \\n         \\n         \\n\\n        \\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "why take length 1\\n"
                    },
                    {
                        "username": "ryabkin",
                        "content": "k is up to 10^9 - nice joke =)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "  ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL||k==0){\\n            return head;\\n        }\\n        ListNode*temp=head;\\n        int n=0;\\n        while(temp->next!=NULL){\\n            temp=temp->next;\\n            n++;\\n        }\\n        temp->next=head;\\n        k=k%(n+1);\\n        int jump=n-k;\\n        temp=head;\\n        while(jump){\\n            temp=temp->next;\\n            jump--;\\n        }\\n        ListNode*returnHead=temp->next;\\n        temp->next=NULL;\\n        return returnHead;\\n\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "edupuganti_tarun_venkata_sai",
                        "content": "class Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        int len=1;\\n        ListNode iter=head;\\n        ListNode iter1=head;\\n        if(head==null){\\n            return head;\\n        }\\n        while(iter.next!=null){\\n          len++;\\n          iter=iter.next;\\n        }\\n        k=k%len;\\n        if(k==0){\\n           return head;\\n        }\\n        \\n        int skip=len-k-1;\\n        \\n        \\n        while(skip-- >0){\\n            iter1=iter1.next;\\n        }\\n\\n        iter.next=head;\\n        head=iter1.next;\\n        iter1.next=null;\\n        \\n        \\n        return head;\\n    }   \\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "In my opinion, linked lists such as this problem have always been very annoying problems to deal with. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Learning to program in LISP has increased my skills with linked lists to the nth degree."
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || k==0 || head.next==null)\\n           return head;\\n        ListNode currentNode=head;\\n        int n=1;\\n        while(currentNode.next!=null){\\n            n++;\\n            currentNode=currentNode.next;\\n        }\\n      \\n        k=k%n;\\n        if(k==0)\\n          return head; \\n        ListNode secondNode=head;\\n        ListNode newnode=secondNode.next;\\n        int i=1;\\n        int j=n-k;\\n        while(i<j){\\n            secondNode=secondNode.next;\\n            newnode=secondNode.next;\\n            i++;\\n        }\\n        currentNode.next=head;\\n        secondNode.next=null;\\n        head=newnode;\\n        return head;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Well this took me far more attempts than it should have..."
                    },
                    {
                        "username": "deleted_user",
                        "content": "C++ solution[leetcode](https://leetcode.com)https://github.com/lets-do-code/rotate-list-leetcode-solution"
                    },
                    {
                        "username": "om_prakash9-",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(k==0){\\n            return head;\\n        }\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        else if(head->next==NULL){\\n            return head;\\n        }\\n        int n=0;\\n        ListNode*iter=head;\\n        while(iter!=NULL){\\n            n++;\\n            iter=iter->next;\\n        }\\n        int rotate=0;\\n        if(k<n){\\n            rotate=k;\\n        }\\n        else{\\n            rotate=k%n;\\n        }\\n        int target=n-rotate;\\n        if(k%n==0){\\n            return head;\\n        }\\n        cout<<\"target\"<<target<<endl;\\n        int flag=1;\\n        ListNode *temp=head,*nh,*null;\\n        while(temp!=NULL){\\n            if(flag==target){\\n                nh=temp->next;\\n                null=temp;\\n                break;\\n            }\\n            flag++;\\n            temp=temp->next;\\n        }\\n        ListNode* op=nh;\\n        null->next=NULL;\\n        while(op!=NULL){\\n            if(op->next==NULL){\\n                op->next=head;\\n                break;\\n            }\\n            op=op->next;\\n        }\\n        return nh;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ablinux",
                        "content": "100% fast 0ms run time..\\n\\n `struct ListNode* rotateRight(struct ListNode* head, int k){\\n    /* here we need 3 pointer 1, head, tail and prv pointer */\\n    struct ListNode *newHead,*prvNode,*endNode,*temp = NULL;\\n    \\n    if(!head) return NULL;\\n    if(head->next == NULL) return head;\\n    /* 1st approch */\\n\\n    /* let travel the list and find th last element */\\n    temp = head;\\n    int nodeCount = 0;\\n    while(temp)\\n    {\\n        nodeCount ++; /* stored count */\\n        temp = temp->next;\\n        if(temp)\\n            endNode = temp; /* stored end node */\\n    }\\n\\n    /* lets find out the number of rotation needed */\\n    if(k%nodeCount)\\n    {\\n        k = k%nodeCount;\\n        k = nodeCount - k ; /* here the actual number from where we can split the list and joint with head\\n        which in sense looks like a rotation of list */\\n        k = nodeCount - k;\\n    }\\n    else\\n    {\\n        k = 0;\\n    }\\n    printf(\"k = %d  nodeCount = %d\",k,nodeCount);\\n    temp = head;\\n    while(temp)\\n    {\\n        prvNode = temp;\\n        if(k == nodeCount-1)\\n        {\\n            endNode->next = head;\\n            head = prvNode->next;\\n            prvNode->next = NULL;\\n            return head;\\n        }\\n        nodeCount --;\\n        temp = temp->next;\\n    }\\n\\n\\n    return head;\\n\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% fast rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1704362,
                "content": [
                    {
                        "username": "ashu_2206",
                        "content": "class Solution { public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null)\\n      return head;\\n      ListNode tail=head;\\n      ListNode newHead=head;\\n      \\n           int len=1;\\n             while(tail.next!=null)\\n             {\\n                 len++;\\n                 tail=tail.next;\\n\\n             }\\n        tail.next=head;\\n        k=k%len;\\n        for(int i=0;i<len-k;i++)   tail=tail.next;\\n        newHead=tail.next;\\n        tail.next=null;\\n        return newHead;\\n        \\n         \\n         \\n\\n        \\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "why take length 1\\n"
                    },
                    {
                        "username": "ryabkin",
                        "content": "k is up to 10^9 - nice joke =)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "  ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL||k==0){\\n            return head;\\n        }\\n        ListNode*temp=head;\\n        int n=0;\\n        while(temp->next!=NULL){\\n            temp=temp->next;\\n            n++;\\n        }\\n        temp->next=head;\\n        k=k%(n+1);\\n        int jump=n-k;\\n        temp=head;\\n        while(jump){\\n            temp=temp->next;\\n            jump--;\\n        }\\n        ListNode*returnHead=temp->next;\\n        temp->next=NULL;\\n        return returnHead;\\n\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "edupuganti_tarun_venkata_sai",
                        "content": "class Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        int len=1;\\n        ListNode iter=head;\\n        ListNode iter1=head;\\n        if(head==null){\\n            return head;\\n        }\\n        while(iter.next!=null){\\n          len++;\\n          iter=iter.next;\\n        }\\n        k=k%len;\\n        if(k==0){\\n           return head;\\n        }\\n        \\n        int skip=len-k-1;\\n        \\n        \\n        while(skip-- >0){\\n            iter1=iter1.next;\\n        }\\n\\n        iter.next=head;\\n        head=iter1.next;\\n        iter1.next=null;\\n        \\n        \\n        return head;\\n    }   \\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "In my opinion, linked lists such as this problem have always been very annoying problems to deal with. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Learning to program in LISP has increased my skills with linked lists to the nth degree."
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || k==0 || head.next==null)\\n           return head;\\n        ListNode currentNode=head;\\n        int n=1;\\n        while(currentNode.next!=null){\\n            n++;\\n            currentNode=currentNode.next;\\n        }\\n      \\n        k=k%n;\\n        if(k==0)\\n          return head; \\n        ListNode secondNode=head;\\n        ListNode newnode=secondNode.next;\\n        int i=1;\\n        int j=n-k;\\n        while(i<j){\\n            secondNode=secondNode.next;\\n            newnode=secondNode.next;\\n            i++;\\n        }\\n        currentNode.next=head;\\n        secondNode.next=null;\\n        head=newnode;\\n        return head;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Well this took me far more attempts than it should have..."
                    },
                    {
                        "username": "deleted_user",
                        "content": "C++ solution[leetcode](https://leetcode.com)https://github.com/lets-do-code/rotate-list-leetcode-solution"
                    },
                    {
                        "username": "om_prakash9-",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(k==0){\\n            return head;\\n        }\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        else if(head->next==NULL){\\n            return head;\\n        }\\n        int n=0;\\n        ListNode*iter=head;\\n        while(iter!=NULL){\\n            n++;\\n            iter=iter->next;\\n        }\\n        int rotate=0;\\n        if(k<n){\\n            rotate=k;\\n        }\\n        else{\\n            rotate=k%n;\\n        }\\n        int target=n-rotate;\\n        if(k%n==0){\\n            return head;\\n        }\\n        cout<<\"target\"<<target<<endl;\\n        int flag=1;\\n        ListNode *temp=head,*nh,*null;\\n        while(temp!=NULL){\\n            if(flag==target){\\n                nh=temp->next;\\n                null=temp;\\n                break;\\n            }\\n            flag++;\\n            temp=temp->next;\\n        }\\n        ListNode* op=nh;\\n        null->next=NULL;\\n        while(op!=NULL){\\n            if(op->next==NULL){\\n                op->next=head;\\n                break;\\n            }\\n            op=op->next;\\n        }\\n        return nh;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ablinux",
                        "content": "100% fast 0ms run time..\\n\\n `struct ListNode* rotateRight(struct ListNode* head, int k){\\n    /* here we need 3 pointer 1, head, tail and prv pointer */\\n    struct ListNode *newHead,*prvNode,*endNode,*temp = NULL;\\n    \\n    if(!head) return NULL;\\n    if(head->next == NULL) return head;\\n    /* 1st approch */\\n\\n    /* let travel the list and find th last element */\\n    temp = head;\\n    int nodeCount = 0;\\n    while(temp)\\n    {\\n        nodeCount ++; /* stored count */\\n        temp = temp->next;\\n        if(temp)\\n            endNode = temp; /* stored end node */\\n    }\\n\\n    /* lets find out the number of rotation needed */\\n    if(k%nodeCount)\\n    {\\n        k = k%nodeCount;\\n        k = nodeCount - k ; /* here the actual number from where we can split the list and joint with head\\n        which in sense looks like a rotation of list */\\n        k = nodeCount - k;\\n    }\\n    else\\n    {\\n        k = 0;\\n    }\\n    printf(\"k = %d  nodeCount = %d\",k,nodeCount);\\n    temp = head;\\n    while(temp)\\n    {\\n        prvNode = temp;\\n        if(k == nodeCount-1)\\n        {\\n            endNode->next = head;\\n            head = prvNode->next;\\n            prvNode->next = NULL;\\n            return head;\\n        }\\n        nodeCount --;\\n        temp = temp->next;\\n    }\\n\\n\\n    return head;\\n\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% fast rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1703078,
                "content": [
                    {
                        "username": "ashu_2206",
                        "content": "class Solution { public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null)\\n      return head;\\n      ListNode tail=head;\\n      ListNode newHead=head;\\n      \\n           int len=1;\\n             while(tail.next!=null)\\n             {\\n                 len++;\\n                 tail=tail.next;\\n\\n             }\\n        tail.next=head;\\n        k=k%len;\\n        for(int i=0;i<len-k;i++)   tail=tail.next;\\n        newHead=tail.next;\\n        tail.next=null;\\n        return newHead;\\n        \\n         \\n         \\n\\n        \\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "why take length 1\\n"
                    },
                    {
                        "username": "ryabkin",
                        "content": "k is up to 10^9 - nice joke =)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "  ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL||k==0){\\n            return head;\\n        }\\n        ListNode*temp=head;\\n        int n=0;\\n        while(temp->next!=NULL){\\n            temp=temp->next;\\n            n++;\\n        }\\n        temp->next=head;\\n        k=k%(n+1);\\n        int jump=n-k;\\n        temp=head;\\n        while(jump){\\n            temp=temp->next;\\n            jump--;\\n        }\\n        ListNode*returnHead=temp->next;\\n        temp->next=NULL;\\n        return returnHead;\\n\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "edupuganti_tarun_venkata_sai",
                        "content": "class Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        int len=1;\\n        ListNode iter=head;\\n        ListNode iter1=head;\\n        if(head==null){\\n            return head;\\n        }\\n        while(iter.next!=null){\\n          len++;\\n          iter=iter.next;\\n        }\\n        k=k%len;\\n        if(k==0){\\n           return head;\\n        }\\n        \\n        int skip=len-k-1;\\n        \\n        \\n        while(skip-- >0){\\n            iter1=iter1.next;\\n        }\\n\\n        iter.next=head;\\n        head=iter1.next;\\n        iter1.next=null;\\n        \\n        \\n        return head;\\n    }   \\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "In my opinion, linked lists such as this problem have always been very annoying problems to deal with. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Learning to program in LISP has increased my skills with linked lists to the nth degree."
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || k==0 || head.next==null)\\n           return head;\\n        ListNode currentNode=head;\\n        int n=1;\\n        while(currentNode.next!=null){\\n            n++;\\n            currentNode=currentNode.next;\\n        }\\n      \\n        k=k%n;\\n        if(k==0)\\n          return head; \\n        ListNode secondNode=head;\\n        ListNode newnode=secondNode.next;\\n        int i=1;\\n        int j=n-k;\\n        while(i<j){\\n            secondNode=secondNode.next;\\n            newnode=secondNode.next;\\n            i++;\\n        }\\n        currentNode.next=head;\\n        secondNode.next=null;\\n        head=newnode;\\n        return head;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Well this took me far more attempts than it should have..."
                    },
                    {
                        "username": "deleted_user",
                        "content": "C++ solution[leetcode](https://leetcode.com)https://github.com/lets-do-code/rotate-list-leetcode-solution"
                    },
                    {
                        "username": "om_prakash9-",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(k==0){\\n            return head;\\n        }\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        else if(head->next==NULL){\\n            return head;\\n        }\\n        int n=0;\\n        ListNode*iter=head;\\n        while(iter!=NULL){\\n            n++;\\n            iter=iter->next;\\n        }\\n        int rotate=0;\\n        if(k<n){\\n            rotate=k;\\n        }\\n        else{\\n            rotate=k%n;\\n        }\\n        int target=n-rotate;\\n        if(k%n==0){\\n            return head;\\n        }\\n        cout<<\"target\"<<target<<endl;\\n        int flag=1;\\n        ListNode *temp=head,*nh,*null;\\n        while(temp!=NULL){\\n            if(flag==target){\\n                nh=temp->next;\\n                null=temp;\\n                break;\\n            }\\n            flag++;\\n            temp=temp->next;\\n        }\\n        ListNode* op=nh;\\n        null->next=NULL;\\n        while(op!=NULL){\\n            if(op->next==NULL){\\n                op->next=head;\\n                break;\\n            }\\n            op=op->next;\\n        }\\n        return nh;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ablinux",
                        "content": "100% fast 0ms run time..\\n\\n `struct ListNode* rotateRight(struct ListNode* head, int k){\\n    /* here we need 3 pointer 1, head, tail and prv pointer */\\n    struct ListNode *newHead,*prvNode,*endNode,*temp = NULL;\\n    \\n    if(!head) return NULL;\\n    if(head->next == NULL) return head;\\n    /* 1st approch */\\n\\n    /* let travel the list and find th last element */\\n    temp = head;\\n    int nodeCount = 0;\\n    while(temp)\\n    {\\n        nodeCount ++; /* stored count */\\n        temp = temp->next;\\n        if(temp)\\n            endNode = temp; /* stored end node */\\n    }\\n\\n    /* lets find out the number of rotation needed */\\n    if(k%nodeCount)\\n    {\\n        k = k%nodeCount;\\n        k = nodeCount - k ; /* here the actual number from where we can split the list and joint with head\\n        which in sense looks like a rotation of list */\\n        k = nodeCount - k;\\n    }\\n    else\\n    {\\n        k = 0;\\n    }\\n    printf(\"k = %d  nodeCount = %d\",k,nodeCount);\\n    temp = head;\\n    while(temp)\\n    {\\n        prvNode = temp;\\n        if(k == nodeCount-1)\\n        {\\n            endNode->next = head;\\n            head = prvNode->next;\\n            prvNode->next = NULL;\\n            return head;\\n        }\\n        nodeCount --;\\n        temp = temp->next;\\n    }\\n\\n\\n    return head;\\n\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% fast rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1628069,
                "content": [
                    {
                        "username": "ashu_2206",
                        "content": "class Solution { public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null)\\n      return head;\\n      ListNode tail=head;\\n      ListNode newHead=head;\\n      \\n           int len=1;\\n             while(tail.next!=null)\\n             {\\n                 len++;\\n                 tail=tail.next;\\n\\n             }\\n        tail.next=head;\\n        k=k%len;\\n        for(int i=0;i<len-k;i++)   tail=tail.next;\\n        newHead=tail.next;\\n        tail.next=null;\\n        return newHead;\\n        \\n         \\n         \\n\\n        \\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "why take length 1\\n"
                    },
                    {
                        "username": "ryabkin",
                        "content": "k is up to 10^9 - nice joke =)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "  ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL||k==0){\\n            return head;\\n        }\\n        ListNode*temp=head;\\n        int n=0;\\n        while(temp->next!=NULL){\\n            temp=temp->next;\\n            n++;\\n        }\\n        temp->next=head;\\n        k=k%(n+1);\\n        int jump=n-k;\\n        temp=head;\\n        while(jump){\\n            temp=temp->next;\\n            jump--;\\n        }\\n        ListNode*returnHead=temp->next;\\n        temp->next=NULL;\\n        return returnHead;\\n\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "edupuganti_tarun_venkata_sai",
                        "content": "class Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        int len=1;\\n        ListNode iter=head;\\n        ListNode iter1=head;\\n        if(head==null){\\n            return head;\\n        }\\n        while(iter.next!=null){\\n          len++;\\n          iter=iter.next;\\n        }\\n        k=k%len;\\n        if(k==0){\\n           return head;\\n        }\\n        \\n        int skip=len-k-1;\\n        \\n        \\n        while(skip-- >0){\\n            iter1=iter1.next;\\n        }\\n\\n        iter.next=head;\\n        head=iter1.next;\\n        iter1.next=null;\\n        \\n        \\n        return head;\\n    }   \\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "In my opinion, linked lists such as this problem have always been very annoying problems to deal with. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Learning to program in LISP has increased my skills with linked lists to the nth degree."
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || k==0 || head.next==null)\\n           return head;\\n        ListNode currentNode=head;\\n        int n=1;\\n        while(currentNode.next!=null){\\n            n++;\\n            currentNode=currentNode.next;\\n        }\\n      \\n        k=k%n;\\n        if(k==0)\\n          return head; \\n        ListNode secondNode=head;\\n        ListNode newnode=secondNode.next;\\n        int i=1;\\n        int j=n-k;\\n        while(i<j){\\n            secondNode=secondNode.next;\\n            newnode=secondNode.next;\\n            i++;\\n        }\\n        currentNode.next=head;\\n        secondNode.next=null;\\n        head=newnode;\\n        return head;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Well this took me far more attempts than it should have..."
                    },
                    {
                        "username": "deleted_user",
                        "content": "C++ solution[leetcode](https://leetcode.com)https://github.com/lets-do-code/rotate-list-leetcode-solution"
                    },
                    {
                        "username": "om_prakash9-",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(k==0){\\n            return head;\\n        }\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        else if(head->next==NULL){\\n            return head;\\n        }\\n        int n=0;\\n        ListNode*iter=head;\\n        while(iter!=NULL){\\n            n++;\\n            iter=iter->next;\\n        }\\n        int rotate=0;\\n        if(k<n){\\n            rotate=k;\\n        }\\n        else{\\n            rotate=k%n;\\n        }\\n        int target=n-rotate;\\n        if(k%n==0){\\n            return head;\\n        }\\n        cout<<\"target\"<<target<<endl;\\n        int flag=1;\\n        ListNode *temp=head,*nh,*null;\\n        while(temp!=NULL){\\n            if(flag==target){\\n                nh=temp->next;\\n                null=temp;\\n                break;\\n            }\\n            flag++;\\n            temp=temp->next;\\n        }\\n        ListNode* op=nh;\\n        null->next=NULL;\\n        while(op!=NULL){\\n            if(op->next==NULL){\\n                op->next=head;\\n                break;\\n            }\\n            op=op->next;\\n        }\\n        return nh;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ablinux",
                        "content": "100% fast 0ms run time..\\n\\n `struct ListNode* rotateRight(struct ListNode* head, int k){\\n    /* here we need 3 pointer 1, head, tail and prv pointer */\\n    struct ListNode *newHead,*prvNode,*endNode,*temp = NULL;\\n    \\n    if(!head) return NULL;\\n    if(head->next == NULL) return head;\\n    /* 1st approch */\\n\\n    /* let travel the list and find th last element */\\n    temp = head;\\n    int nodeCount = 0;\\n    while(temp)\\n    {\\n        nodeCount ++; /* stored count */\\n        temp = temp->next;\\n        if(temp)\\n            endNode = temp; /* stored end node */\\n    }\\n\\n    /* lets find out the number of rotation needed */\\n    if(k%nodeCount)\\n    {\\n        k = k%nodeCount;\\n        k = nodeCount - k ; /* here the actual number from where we can split the list and joint with head\\n        which in sense looks like a rotation of list */\\n        k = nodeCount - k;\\n    }\\n    else\\n    {\\n        k = 0;\\n    }\\n    printf(\"k = %d  nodeCount = %d\",k,nodeCount);\\n    temp = head;\\n    while(temp)\\n    {\\n        prvNode = temp;\\n        if(k == nodeCount-1)\\n        {\\n            endNode->next = head;\\n            head = prvNode->next;\\n            prvNode->next = NULL;\\n            return head;\\n        }\\n        nodeCount --;\\n        temp = temp->next;\\n    }\\n\\n\\n    return head;\\n\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% fast rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            }
        ]
    }
]