[
    {
        "title": "Count the Digits That Divide a Number",
        "question_content": "Given an integer num, return the number of digits in num that divide num.\nAn integer val divides nums if nums % val == 0.\n&nbsp;\nExample 1:\n\nInput: num = 7\nOutput: 1\nExplanation: 7 divides itself, hence the answer is 1.\n\nExample 2:\n\nInput: num = 121\nOutput: 2\nExplanation: 121 is divisible by 1, but not 2. Since 1 occurs twice as a digit, we return 2.\n\nExample 3:\n\nInput: num = 1248\nOutput: 4\nExplanation: 1248 is divisible by all of its digits, hence the answer is 4.\n\n&nbsp;\nConstraints:\n\n\t1 <= num <= 109\n\tnum does not contain 0 as one of its digits.",
        "solutions": [
            {
                "id": 2984535,
                "title": "simple-and-concise-100-fast",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int answer = 0;\\n        int n = num;\\n        while(n>0){\\n            if(num % (n%10) == 0) answer++;\\n            n/=10;\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int answer = 0;\\n        int n = num;\\n        while(n>0){\\n            if(num % (n%10) == 0) answer++;\\n            n/=10;\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977336,
                "title": "two-approaches",
                "content": "We can extract each digit using the modulo/division technique, or just convert `num` to a string.\\n\\n## Modulo\\n**C++**\\n```cpp\\nint countDigits(int num) {\\n    int res = 0;\\n    for (int n = num; n > 0; n /= 10)\\n        res += num % (n % 10) == 0;\\n    return res;\\n}\\n```\\n## Convert to String\\n**Python 3**\\n```python\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        return sum(1 if num % int(d) == 0 else 0 for d in str(num))\\n```\\n**C++**\\n```cpp\\nint countDigits(int num) {\\n    auto s = to_string(num);\\n    return accumulate(begin(s), end(s), 0, [&](int res, char ch){ \\n        return res + (num % (ch - \\'0\\') == 0);\\n    });\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```cpp\\nint countDigits(int num) {\\n    int res = 0;\\n    for (int n = num; n > 0; n /= 10)\\n        res += num % (n % 10) == 0;\\n    return res;\\n}\\n```\n```python\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        return sum(1 if num % int(d) == 0 else 0 for d in str(num))\\n```\n```cpp\\nint countDigits(int num) {\\n    auto s = to_string(num);\\n    return accumulate(begin(s), end(s), 0, [&](int res, char ch){ \\n        return res + (num % (ch - \\'0\\') == 0);\\n    });\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977409,
                "title": "java-c-python-fully-explained",
                "content": "```\\n# Intituition\\n```\\nThe solution iterates through the digits of the integer, and checks if each digit divides the original integer. If a digit divides the integer, the count is incremented. At the end, the final count is returned, which is the number of digits in the integer that divide the integer.\\n\\nFor example, if the input integer is **121**, the digits are **1** and **2**. The digit **1** divides **121**, so the count is incremented to **1**. The digit **2** does not divide **121**, so the count is not incremented. The final count is **1**, which is the number of digits in **121** that divide **121**.\\n\\n```\\n# Approach\\n```\\n\\n* **Initialize a count to 0** to keep track of the number of digits that **divide the integer**.\\n\\n* Iterate through the digits in the integer. For each digit:\\n\\n* * **Check if** the digit divides the integer.\\n* * **If it does**, increment the count.\\n* **Return** the count.\\n\\n**Diagram Representation**\\n\\n```\\n                              +---------------+\\n                              |   num = 121   |\\n                              +-------+-------+\\n                                      |\\n                                      v\\n    +------------------------------------+\\n    | count = 0                         |\\n    +------------------------------------+\\n    |                                    |\\n    | for digit in digits(num):          |\\n    |   if num % digit == 0:            |\\n    |     count += 1                     |\\n    |                                    |\\n    +------------------------------------+\\n                                      |\\n                                      v\\n                              +-------+-------+\\n                              |   count = 1   |\\n                              +---------------+\\n\\n```\\n\\n**Java**\\n\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        String str = Integer.toString(num);\\n\\n    // Initialize a count to keep track of the number of digits that divide num\\n    int count = 0;\\n\\n    // Iterate through the digits in the string\\n    for (int i = 0; i < str.length(); i++) {\\n      // Convert the current character to an integer\\n      int digit = Character.getNumericValue(str.charAt(i));\\n\\n      // Check if the digit divides num\\n      if (num % digit == 0) {\\n        // If it does, increment the count\\n        count++;\\n      }\\n    }\\n\\n    // Return the count\\n    return count;\\n    }\\n}\\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        // Convert the integer to a string\\n    string str = to_string(num);\\n\\n    // Initialize a count to keep track of the number of digits that divide num\\n    int count = 0;\\n\\n    // Iterate through the digits in the string\\n    for (char c : str) {\\n      // Convert the current character to an integer\\n      int digit = c - \\'0\\';\\n\\n      // Check if the digit divides num\\n      if (num % digit == 0) {\\n        // If it does, increment the count\\n        count++;\\n      }\\n    }\\n\\n    // Return the count\\n    return count;\\n    }\\n};\\n```\\n\\n**Python**\\n\\n```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        # Initialize a count to keep track of the number of digits that divide num\\n        count = 0\\n\\n        # Iterate through the digits in the integer\\n        for digit in str(num):\\n            # Check if the digit divides num\\n            if num % int(digit) == 0:\\n                # If it does, increment the count\\n                count += 1\\n\\n        # Return the count\\n        return count\\n```\\n\\n**ANALYSIS**\\n* **The time complexity :** of this solution is **`O(n)`**, where n is the number of digits in the integer. This is because the solution iterates through all the digits in the integer and performs a constant number of operations on each digit.\\n\\n* **The space complexity :** of this solution is **`O(n)`**, where n is the number of digits in the integer. This is because the solution stores the digits in the integer as a string, which takes up O(n) space.",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\n# Intituition\\n```\n```\\n# Approach\\n```\n```\\n                              +---------------+\\n                              |   num = 121   |\\n                              +-------+-------+\\n                                      |\\n                                      v\\n    +------------------------------------+\\n    | count = 0                         |\\n    +------------------------------------+\\n    |                                    |\\n    | for digit in digits(num):          |\\n    |   if num % digit == 0:            |\\n    |     count += 1                     |\\n    |                                    |\\n    +------------------------------------+\\n                                      |\\n                                      v\\n                              +-------+-------+\\n                              |   count = 1   |\\n                              +---------------+\\n\\n```\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        String str = Integer.toString(num);\\n\\n    // Initialize a count to keep track of the number of digits that divide num\\n    int count = 0;\\n\\n    // Iterate through the digits in the string\\n    for (int i = 0; i < str.length(); i++) {\\n      // Convert the current character to an integer\\n      int digit = Character.getNumericValue(str.charAt(i));\\n\\n      // Check if the digit divides num\\n      if (num % digit == 0) {\\n        // If it does, increment the count\\n        count++;\\n      }\\n    }\\n\\n    // Return the count\\n    return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        // Convert the integer to a string\\n    string str = to_string(num);\\n\\n    // Initialize a count to keep track of the number of digits that divide num\\n    int count = 0;\\n\\n    // Iterate through the digits in the string\\n    for (char c : str) {\\n      // Convert the current character to an integer\\n      int digit = c - \\'0\\';\\n\\n      // Check if the digit divides num\\n      if (num % digit == 0) {\\n        // If it does, increment the count\\n        count++;\\n      }\\n    }\\n\\n    // Return the count\\n    return count;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        # Initialize a count to keep track of the number of digits that divide num\\n        count = 0\\n\\n        # Iterate through the digits in the integer\\n        for digit in str(num):\\n            # Check if the digit divides num\\n            if num % int(digit) == 0:\\n                # If it does, increment the count\\n                count += 1\\n\\n        # Return the count\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977375,
                "title": "c-very-simple-and-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int ans = 0;;\\n        int n = num;\\n        while(n > 0){\\n            int r = n%10;\\n            if(num % r == 0) ans++;\\n            n = n/10;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int ans = 0;;\\n        int n = num;\\n        while(n > 0){\\n            int r = n%10;\\n            if(num % r == 0) ans++;\\n            n = n/10;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977312,
                "title": "simple-python-solution",
                "content": "- *Time Complexity:* **O(N)**\\n- *Space Complexity:* **O(1)**\\n```\\nclass Solution(object):\\n    def countDigits(self, num):\\n        str_num, count = str(num), 0\\n        for digit in str_num:\\n            if num % int(digit) == 0:\\n                count += 1\\n        return count\\n```\\n**UpVote**, if you like it **:)**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def countDigits(self, num):\\n        str_num, count = str(num), 0\\n        for digit in str_num:\\n            if num % int(digit) == 0:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977349,
                "title": "java-c-python-easy-and-concise",
                "content": "# **Explanation**\\nIterative `num` digit by digit.\\nWe can do this by transforming the integer `num` to string,\\nor divide `num` by 10 repeatly.\\n<br>\\n\\n# **Complexity**\\nTime `O(log(num))`\\nSpace `O(log(num))`\\n<br>\\n\\n**Java**\\n```java\\n    public int countDigits(int num) {\\n        int res = 0;\\n        for (int x = num; x > 0; x /= 10)\\n            if (num % (x % 10) == 0)\\n                res++;\\n        return res;\\n    }\\n\\n    public int countDigits(int num) {\\n        int res = 0;\\n        for (Character c : Integer.toString(num).toCharArray())\\n            if (num % (c - \\'0\\') == 0)\\n                res++;\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int countDigits(int x) {\\n        int res = 0;\\n        for (auto& c: to_string(x))\\n            if (x % (c - \\'0\\') == 0)\\n                res++;\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def countDigits(self, x: int) -> int:\\n        return sum(x % int(y) == 0 for y in str(x))\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int countDigits(int num) {\\n        int res = 0;\\n        for (int x = num; x > 0; x /= 10)\\n            if (num % (x % 10) == 0)\\n                res++;\\n        return res;\\n    }\\n\\n    public int countDigits(int num) {\\n        int res = 0;\\n        for (Character c : Integer.toString(num).toCharArray())\\n            if (num % (c - \\'0\\') == 0)\\n                res++;\\n        return res;\\n    }\\n```\n```cpp\\n    int countDigits(int x) {\\n        int res = 0;\\n        for (auto& c: to_string(x))\\n            if (x % (c - \\'0\\') == 0)\\n                res++;\\n        return res;\\n    }\\n```\n```py\\n    def countDigits(self, x: int) -> int:\\n        return sum(x % int(y) == 0 for y in str(x))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2977297,
                "title": "c-java-python",
                "content": "**Brute Force**\\n**Check Divisibilty from each Digit of NUM**\\nTime Complexity -> O(log(num))\\nspace Complexity -> O(1)\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int n = num, ans = 0;\\n        while(num>0){\\n            ans += (n%(num%10)==0);\\n            num /= 10;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Python\\n```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        n, res = num, 0\\n        while n>0:\\n            if num%(n%10)==0:\\n                res += 1\\n            n //= 10\\n        return res\\n```\\n# JAVA\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int n = num, cnt = 0;\\n        while ( n > 0 ){\\n            int rem = n%10;\\n            n = n/10;\\n            if ( num % rem == 0 ) cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int n = num, ans = 0;\\n        while(num>0){\\n            ans += (n%(num%10)==0);\\n            num /= 10;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        n, res = num, 0\\n        while n>0:\\n            if num%(n%10)==0:\\n                res += 1\\n            n //= 10\\n        return res\\n```\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int n = num, cnt = 0;\\n        while ( n > 0 ){\\n            int rem = n%10;\\n            n = n/10;\\n            if ( num % rem == 0 ) cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979310,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\n---\\n\\n**Approach 1: Convert ot String**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int ans = 0;\\n        // convert num to string\\n        string s = to_string(num);\\n        // for each character\\n        for (auto c : s) {\\n            // convert it to number\\n            int d = c - \\'0\\';\\n            // check if it divisible\\n            ans += num % d == 0;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Approach 2: Check each digit**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int ans = 0, n = num;\\n        while (n > 0) {\\n            // check each digit\\n            ans += num % (n % 10) == 0;\\n            // move to the next digit\\n            n /= 10;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int ans = 0;\\n        // convert num to string\\n        string s = to_string(num);\\n        // for each character\\n        for (auto c : s) {\\n            // convert it to number\\n            int d = c - \\'0\\';\\n            // check if it divisible\\n            ans += num % d == 0;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int ans = 0, n = num;\\n        while (n > 0) {\\n            // check each digit\\n            ans += num % (n % 10) == 0;\\n            // move to the next digit\\n            n /= 10;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512255,
                "title": "my-countdigits",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} num\\n * @return {number}\\n */\\nvar countDigits = function (num) {\\n\\tlet tempNum = num;\\n\\tlet count = 0;\\n\\n\\twhile (tempNum !== 0) {\\n\\t\\tlet digit = tempNum % 10;\\n\\t\\tif (num % digit === 0) {\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\ttempNum = Math.floor(tempNum / 10);\\n\\t}\\n\\n\\treturn count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} num\\n * @return {number}\\n */\\nvar countDigits = function (num) {\\n\\tlet tempNum = num;\\n\\tlet count = 0;\\n\\n\\twhile (tempNum !== 0) {\\n\\t\\tlet digit = tempNum % 10;\\n\\t\\tif (num % digit === 0) {\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\ttempNum = Math.floor(tempNum / 10);\\n\\t}\\n\\n\\treturn count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2999122,
                "title": "python-simple-and-clear-solution",
                "content": "# Approach\\nGo through the digits in num and check for each one if num is divided.\\n\\n# Code\\n```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        res = 0\\n        \\n        for i in list(str(num)):\\n            if not num % int(i):\\n                res += 1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        res = 0\\n        \\n        for i in list(str(num)):\\n            if not num % int(i):\\n                res += 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129582,
                "title": "python-easy-solution",
                "content": "# Code\\u2705\\nSolution 1:\\n```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        count = [digit for digit in str(num) if num % int(digit) == 0]\\n        return len(count)\\n```\\nSolution 2:\\n```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        count = 0\\n        for digit in str(num):\\n            if num % int(digit) == 0:\\n                count +=1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        count = [digit for digit in str(num) if num % int(digit) == 0]\\n        return len(count)\\n```\n```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        count = 0\\n        for digit in str(num):\\n            if num % int(digit) == 0:\\n                count +=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054148,
                "title": "java-100-faster-shotest-code",
                "content": "![coutn digit.PNG](https://assets.leetcode.com/users/images/fdfb4209-f4eb-46b8-a8c1-eb8012f9d314_1673778912.6200123.png)\\n\\n# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int count = 0;\\n        int storingNumber = num;\\n        while (num != 0) {\\n            int r = num % 10;\\n            if (r != 0 && storingNumber % r == 0) {\\n                count++;\\n            }\\n            num = num / 10;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int count = 0;\\n        int storingNumber = num;\\n        while (num != 0) {\\n            int r = num % 10;\\n            if (r != 0 && storingNumber % r == 0) {\\n                count++;\\n            }\\n            num = num / 10;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979994,
                "title": "one-line-swift-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    func countDigits(_ num: Int) -> Int {\\n        String(num).compactMap(\\\\.wholeNumberValue).filter{ num.isMultiple(of: $0) }.count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countDigits(_ num: Int) -> Int {\\n        String(num).compactMap(\\\\.wholeNumberValue).filter{ num.isMultiple(of: $0) }.count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977556,
                "title": "easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        vector<int> v;\\n        int j=1, res, sum=0, original = num;\\n        \\n        while(num!=0){\\n            int k = num % 10;\\n            if(original%k==0)\\n                sum++;\\n            num = num/10;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        vector<int> v;\\n        int j=1, res, sum=0, original = num;\\n        \\n        while(num!=0){\\n            int k = num % 10;\\n            if(original%k==0)\\n                sum++;\\n            num = num/10;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977294,
                "title": "short-clean-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int tmp = num, count = 0;\\n        while(tmp > 0){\\n            int val = tmp%10;\\n            if(val != 0 && num % val == 0)   count++;\\n            tmp /= 10;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int tmp = num, count = 0;\\n        while(tmp > 0){\\n            int val = tmp%10;\\n            if(val != 0 && num % val == 0)   count++;\\n            tmp /= 10;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467622,
                "title": "beats-100-very-simple-and-easy-solution-must-visit-for-new-beginners",
                "content": "# Intuition\\n![code.jpg](https://assets.leetcode.com/users/images/630c567e-02cf-4599-8487-eec99122726b_1682795106.9404132.jpeg)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Code\\n```\\nint countDigits(int num){\\n    int c=0;\\n    int digit=0;\\n    int x=num;\\n    while(num>0)\\n    {\\n        digit=num % 10;\\n        if(x % digit ==0)\\n        {\\n            c++;\\n        }\\n        num=num/10;\\n    }\\n    return c;\\n\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nint countDigits(int num){\\n    int c=0;\\n    int digit=0;\\n    int x=num;\\n    while(num>0)\\n    {\\n        digit=num % 10;\\n        if(x % digit ==0)\\n        {\\n            c++;\\n        }\\n        num=num/10;\\n    }\\n    return c;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3408350,
                "title": "c-simple-easy-to-understand",
                "content": "````\\n\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int ans = 0, n = num,k;\\n        while(n){\\n            k = n%10;//GET LAST DIGIT OF NUMBER\\n            n /= 10;//DIVIDE NUMBER BY 10\\n            if(num%k==0)ans++;//IF NUM DIVISIBLE BY DIGIT OF NUM INCREMENT ANS BY 1\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "````\\n\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int ans = 0, n = num,k;\\n        while(n){\\n            k = n%10;//GET LAST DIGIT OF NUMBER\\n            n /= 10;//DIVIDE NUMBER BY 10\\n            if(num%k==0)ans++;//IF NUM DIVISIBLE BY DIGIT OF NUM INCREMENT ANS BY 1\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078251,
                "title": "java-solution-for-beginners",
                "content": "Please Upvote if you like my solution!\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        String str = Integer.toString(num);\\n        int count = 0;\\n        for(int i = 0;i<str.length();i++){\\n            int a = str.charAt(i) - \\'0\\';\\n            if(num%a == 0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        String str = Integer.toString(num);\\n        int count = 0;\\n        for(int i = 0;i<str.length();i++){\\n            int a = str.charAt(i) - \\'0\\';\\n            if(num%a == 0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2983876,
                "title": "c-easy-solution-simple",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDeviding the number with each digit of the number.\\n\\n# Complexity\\n- Time complexity:O(1)\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int n=num;\\n        int cnt=0;\\n        while(n){\\n            int r=n%10;\\n            n=n/10;\\n            if(num%r==0)cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int n=num;\\n        int cnt=0;\\n        while(n){\\n            int r=n%10;\\n            n=n/10;\\n            if(num%r==0)cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978847,
                "title": "c-easy-to-understand-very-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int n=num;\\n        int cnt=0;\\n        while(n>0){\\n            int rem=n%10;\\n            if(num%rem==0){\\n                cnt++;\\n            }\\n            n/=10;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int n=num;\\n        int cnt=0;\\n        while(n>0){\\n            int rem=n%10;\\n            if(num%rem==0){\\n                cnt++;\\n            }\\n            n/=10;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977824,
                "title": "python3-simple-solution",
                "content": "Iterate over the **digits** of the original number and check the remainder when dividing:\\n```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        count = 0\\n        \\n        for digit in str(num):\\n            if num % int(digit) == 0:\\n                count += 1\\n                \\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        count = 0\\n        \\n        for digit in str(num):\\n            if num % int(digit) == 0:\\n                count += 1\\n                \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977701,
                "title": "beats-100-explanation-o-n-codedominar-solution",
                "content": "# Approach 1 \\n```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        # Initialize a count of divisor digits to 0\\n        cnt = 0\\n        # Store a copy of num in a temporary variable for processing\\n        tmp = num\\n        # Loop until tmp is 0\\n        while tmp:\\n            # If num is divisible by the last digit of tmp, increment the count\\n            if num % (tmp % 10) == 0:\\n                cnt += 1\\n            # Remove the last digit of tmp by integer division\\n            tmp //= 10\\n        # Return the final count\\n        return cnt\\n\\n        \\n```\\n\\n\\n---\\n\\n\\n\\n# Approach 2\\n```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        # Initialize a count of divisor digits to 0\\n        cnt = 0\\n        # Convert num to a string for processing\\n        num_str = str(num)\\n        # Iterate over the characters in the string representation of num\\n        for digit in num_str:\\n            # If num is divisible by the current digit, increment the count\\n            if num % int(digit) == 0:\\n                cnt += 1\\n        # Return the final count\\n        return cnt\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        # Initialize a count of divisor digits to 0\\n        cnt = 0\\n        # Store a copy of num in a temporary variable for processing\\n        tmp = num\\n        # Loop until tmp is 0\\n        while tmp:\\n            # If num is divisible by the last digit of tmp, increment the count\\n            if num % (tmp % 10) == 0:\\n                cnt += 1\\n            # Remove the last digit of tmp by integer division\\n            tmp //= 10\\n        # Return the final count\\n        return cnt\\n\\n        \\n```\n```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        # Initialize a count of divisor digits to 0\\n        cnt = 0\\n        # Convert num to a string for processing\\n        num_str = str(num)\\n        # Iterate over the characters in the string representation of num\\n        for digit in num_str:\\n            # If num is divisible by the current digit, increment the count\\n            if num % int(digit) == 0:\\n                cnt += 1\\n        # Return the final count\\n        return cnt\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977524,
                "title": "c-3-line-code-beginner-friendly-code",
                "content": "![image](https://assets.leetcode.com/users/images/77e19f79-00c4-45c3-84e8-ee44b3b733ad_1672546226.7368474.png)\\n\\n**n==number of digits of num\\nT->O(n) && S->O(1)**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint countDigits(int num) {\\n\\t\\t\\t\\tint val=num;\\n\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\twhile(num){\\n\\t\\t\\t\\t\\tif(val%(num%10)==0)count++;\\n\\t\\t\\t\\t\\tnum/=10;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn count;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint countDigits(int num) {\\n\\t\\t\\t\\tint val=num;\\n\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\twhile(num){\\n\\t\\t\\t\\t\\tif(val%(num%10)==0)count++;\\n\\t\\t\\t\\t\\tnum/=10;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2977276,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\nint countDigits(int n) {\\n    int m=n, ans=0;\\n    while(m>0){\\n        int x=m%10;\\n        m/=10;\\n        ans+=(n%x)==0;\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint countDigits(int n) {\\n    int m=n, ans=0;\\n    while(m>0){\\n        int x=m%10;\\n        m/=10;\\n        ans+=(n%x)==0;\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3560788,
                "title": "javascript-easy-oneliner",
                "content": "# Intuition\\nThe code implements a function called countDigits that takes a number num as input. The goal is to count the number of digits in num that evenly divide num.\\n# Approach\\n\\nThe approach used in the code is as follows:\\n\\n1. Convert the number num to a string using the toString() method.\\n2. Split the string into an array of individual characters representing the digits of the number using the split(\\'\\') method.\\n3. Apply the reduce() method on the array of digits to calculate the count of digits that evenly divide num.\\n4. In each iteration of reduce(), check if the current digit (cur) evenly divides num using the modulo operator (num % +cur === 0).\\n    * If the digit evenly divides num, increment the accumulator (acc) by 1.\\n    * If the digit does not evenly divide num, keep the accumulator unchanged.\\n5. Finally, the resulting count of digits that evenly divide num is returned.\\n# Complexity\\n- Time complexity:\\n O(n), where n is the number of digits in num.\\n- Space complexity:\\n O(n), as an array of digits is created.\\n# Code\\n```\\n/**\\n * @param {number} num\\n * @return {number}\\n */\\nvar countDigits = (num) =>\\n    num.toString().split(\\'\\').reduce((acc,curr)=> (num % +curr ===0 ? acc+1 : acc), 0)\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} num\\n * @return {number}\\n */\\nvar countDigits = (num) =>\\n    num.toString().split(\\'\\').reduce((acc,curr)=> (num % +curr ===0 ? acc+1 : acc), 0)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3306832,
                "title": "zero-ms-solution-naive-approach-simple-maths-if-any-doubt-i-will-try-to-resolve-it",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int temp = num;\\n        int count = 0;\\n        while(num != 0) {\\n            int div = num % 10;\\n            if (temp % div == 0) {\\n                count++;\\n            }\\n        num = num/10;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int temp = num;\\n        int count = 0;\\n        while(num != 0) {\\n            int div = num % 10;\\n            if (temp % div == 0) {\\n                count++;\\n            }\\n        num = num/10;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241157,
                "title": "crazy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        count=0\\n        n=str(num)\\n        for i in n:\\n            if num%int(i)==0:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        count=0\\n        n=str(num)\\n        for i in n:\\n            if num%int(i)==0:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240394,
                "title": "easiest-python-solution-you-ever-found",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        count=0\\n        x=str(num)\\n        for i in x:\\n            if num%int(i)==0:\\n                count+=1\\n            else:\\n                count+=0\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        count=0\\n        x=str(num)\\n        for i in x:\\n            if num%int(i)==0:\\n                count+=1\\n            else:\\n                count+=0\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076087,
                "title": "easy-solution",
                "content": "\\n# 1 line\\n```\\n/**\\n * @param {number} num\\n * @return {number}\\n */\\nvar countDigits = function(num) {\\n    return String(num).split(\\'\\').reduce((acc, val) => acc += num % +val === 0 ? 1 : 0 ,0)\\n};\\n```\\n# Easy to understand\\n```\\n/**\\n * @param {number} num\\n * @return {number}\\n */\\nvar countDigits = function(num) {\\n     let count = 0;\\n\\n     for (let i = 0; i < String(num).length; i++) {\\n        if (num % Number(String(num)[i]) === 0) count++\\n    }\\n\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} num\\n * @return {number}\\n */\\nvar countDigits = function(num) {\\n    return String(num).split(\\'\\').reduce((acc, val) => acc += num % +val === 0 ? 1 : 0 ,0)\\n};\\n```\n```\\n/**\\n * @param {number} num\\n * @return {number}\\n */\\nvar countDigits = function(num) {\\n     let count = 0;\\n\\n     for (let i = 0; i < String(num).length; i++) {\\n        if (num % Number(String(num)[i]) === 0) count++\\n    }\\n\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3016425,
                "title": "rust-simple-1-liner-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn count_digits(num: i32) -> i32 {\\n        num.to_string().bytes().filter(|x| num % (x - 48) as i32 == 0).count() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn count_digits(num: i32) -> i32 {\\n        num.to_string().bytes().filter(|x| num % (x - 48) as i32 == 0).count() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2985247,
                "title": "c-hashmap-easy-40-time-60-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n      unordered_map<int, int> um;\\n      int temp = num;\\n      while(temp){\\n        int ld = temp % 10;\\n        temp /= 10;\\n        um[ld]++;\\n      }\\n      int ans = 0;\\n      for(auto &[f, s]: um){\\n        if(num % f == 0) ans += s;\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n      unordered_map<int, int> um;\\n      int temp = num;\\n      while(temp){\\n        int ld = temp % 10;\\n        temp /= 10;\\n        um[ld]++;\\n      }\\n      int ans = 0;\\n      for(auto &[f, s]: um){\\n        if(num % f == 0) ans += s;\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981371,
                "title": "simple-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int k=num;\\n        int c=0;\\n        while(num!=0)\\n        {\\n            if(check(k,num%10))\\n            {\\n                c++;\\n            }\\n            num/=10;\\n        }\\n        return c;\\n    }\\n    public boolean check(int num, int div)\\n    {\\n        return num%div==0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int k=num;\\n        int c=0;\\n        while(num!=0)\\n        {\\n            if(check(k,num%10))\\n            {\\n                c++;\\n            }\\n            num/=10;\\n        }\\n        return c;\\n    }\\n    public boolean check(int num, int div)\\n    {\\n        return num%div==0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979208,
                "title": "c-simple-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int cnt=0;\\n        string str=to_string(num);\\n        for(auto i:str){\\n            int val= i-\\'0\\';\\n            if(num%val==0)\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int cnt=0;\\n        string str=to_string(num);\\n        for(auto i:str){\\n            int val= i-\\'0\\';\\n            if(num%val==0)\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978987,
                "title": "full-explanation-brute-force",
                "content": "# Intuition\\nBRUTE FORCE \\n\\n# Approach\\nTo solve this problem, you can first convert the integer to a string so that you can iterate through each digit of the number. Then, you can iterate through each digit of the number, convert it back to an integer, and check if it divides the original number. If it does, you can increment a count. At the end, return the count.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        \\n    string s = to_string(num);\\n    int count = 0;\\n\\n    for (int i=0;i<s.size();i++) {\\n      if (num % (s[i]-\\'0\\') == 0) {\\n        count++;\\n      }\\n    }\\n    return count;\\n    }\\n};\\n```\\n\\n\\n# Upvote if you like",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        \\n    string s = to_string(num);\\n    int count = 0;\\n\\n    for (int i=0;i<s.size();i++) {\\n      if (num % (s[i]-\\'0\\') == 0) {\\n        count++;\\n      }\\n    }\\n    return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978768,
                "title": "most-short-easiest-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n       int cnt = 0;\\n        for (auto ch : to_string(num))\\n            cnt += (num % (ch - \\'0\\') == 0);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n       int cnt = 0;\\n        for (auto ch : to_string(num))\\n            cnt += (num % (ch - \\'0\\') == 0);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978456,
                "title": "my-c-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n- Space complexity: o(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int n = num;\\n        int count = 0;\\n        while(num!=0)\\n        {\\n            if(n%(num%10) == 0)\\n            {\\n                count++;\\n            }\\n            \\n            num=num/10;\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n\\n# Please vote if you like my answer\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int n = num;\\n        int count = 0;\\n        while(num!=0)\\n        {\\n            if(n%(num%10) == 0)\\n            {\\n                count++;\\n            }\\n            \\n            num=num/10;\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n\\n# Please vote if you like my answer\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977514,
                "title": "java-solution-easy-and-concise-beats-100",
                "content": "```\\nclass Solution {\\n    public int countDigits(int n) {\\n        int a=n, c=0;\\n        while(n>0)\\n        {\\n            if(a%(n%10)==0)\\n                c++;\\n            n/=10;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int n) {\\n        int a=n, c=0;\\n        while(n>0)\\n        {\\n            if(a%(n%10)==0)\\n                c++;\\n            n/=10;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977248,
                "title": "short-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int a = num, ans = 0;\\n        while(a) {\\n            if(num % (a % 10) == 0) ans++;\\n            a /= 10;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int a = num, ans = 0;\\n        while(a) {\\n            if(num % (a % 10) == 0) ans++;\\n            a /= 10;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938258,
                "title": "simple-easy-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int n) {\\n       int cnt=0;\\n        int t=n;\\n        while(n>0){\\nint x=n%10;\\n            if(t%x==0) cnt++;\\n            n=n/10;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int n) {\\n       int cnt=0;\\n        int t=n;\\n        while(n>0){\\nint x=n%10;\\n            if(t%x==0) cnt++;\\n            n=n/10;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892253,
                "title": "intuitive-easy-and-concise-beats-100",
                "content": "# Intuition\\nThe problem asks us to count the digits within a given number that can divide the entire number evenly, without leaving any remainder. To achieve this, we need to identify each digit within the number and check whether it satisfies the divisibility condition.\\n\\n# Approach\\n1. We create a temporary variable to work with (temp).\\n1. We initialize a counter (count) to keep track of qualifying digits.\\n1. We iterate through each digit of the number using a loop, extracting digits from the least significant digit to the most significant digit.\\n1. For each digit, we check if it divides the original number evenly. If it does, we increment the counter.\\n1. After processing each digit, we move to the next digit by dividing the temp variable by 10.\\n1. Finally, we return the counter, which represents the count of digits that evenly divide the original number.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of your solution depends on the number of digits in the input number num. If the number has d digits, the time complexity is $$O(d)$$ because you iterate through each digit once.\\n\\n- Space complexity:\\nThe space complexity is $$O(1)$$ because you only use a constant amount of extra space for the temp variable, the count variable, and the loop variables.\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int countDigits(int num) {\\n        int temp = num;     // Create a temporary variable to store the original number\\n        int count = 0;      // Initialize a counter to keep track of qualifying digits\\n        \\n        // Iterate through each digit of the number\\n        while (temp > 0) {\\n            int digit = temp % 10;  // Get the last digit of the number\\n            \\n            // Check if the digit divides the original number evenly\\n            if (num % digit == 0) {\\n                count++;            // Increment the counter if the digit qualifies\\n            }\\n            \\n            temp = temp / 10;       // Move to the next digit by removing the last digit\\n        }\\n        \\n        return count;   // Return the final count of digits that divide the number evenly\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution:\\n    def countDigits(self, num):\\n        temp = num     # Create a temporary variable to store the original number\\n        count = 0      # Initialize a counter to keep track of qualifying digits\\n        \\n        # Iterate through each digit of the number\\n        while temp > 0:\\n            digit = temp % 10  # Get the last digit of the number\\n            \\n            # Check if the digit divides the original number evenly\\n            if num % digit == 0:\\n                count += 1       # Increment the counter if the digit qualifies\\n            \\n            temp = temp / 10    # Move to the next digit by removing the last digit\\n        \\n        return count  # Return the final count of digits that divide the number evenly\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int temp = num;  // Create a temporary variable to store the original number\\n        int count = 0;   // Initialize a counter to keep track of qualifying digits\\n        \\n        // Iterate through each digit of the number\\n        while (temp > 0) {\\n            int digit = temp % 10;  // Get the last digit of the number\\n            \\n            // Check if the digit divides the original number evenly\\n            if (num % digit == 0) {\\n                count++;  // Increment the counter if the digit qualifies\\n            }\\n            \\n            temp = temp / 10;  // Move to the next digit by removing the last digit\\n        }\\n        \\n        return count;  // Return the final count of digits that divide the number evenly\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Math"
                ],
                "code": "```java []\\nclass Solution {\\n    public int countDigits(int num) {\\n        int temp = num;     // Create a temporary variable to store the original number\\n        int count = 0;      // Initialize a counter to keep track of qualifying digits\\n        \\n        // Iterate through each digit of the number\\n        while (temp > 0) {\\n            int digit = temp % 10;  // Get the last digit of the number\\n            \\n            // Check if the digit divides the original number evenly\\n            if (num % digit == 0) {\\n                count++;            // Increment the counter if the digit qualifies\\n            }\\n            \\n            temp = temp / 10;       // Move to the next digit by removing the last digit\\n        }\\n        \\n        return count;   // Return the final count of digits that divide the number evenly\\n    }\\n}\\n\\n```\n```python []\\nclass Solution:\\n    def countDigits(self, num):\\n        temp = num     # Create a temporary variable to store the original number\\n        count = 0      # Initialize a counter to keep track of qualifying digits\\n        \\n        # Iterate through each digit of the number\\n        while temp > 0:\\n            digit = temp % 10  # Get the last digit of the number\\n            \\n            # Check if the digit divides the original number evenly\\n            if num % digit == 0:\\n                count += 1       # Increment the counter if the digit qualifies\\n            \\n            temp = temp / 10    # Move to the next digit by removing the last digit\\n        \\n        return count  # Return the final count of digits that divide the number evenly\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int temp = num;  // Create a temporary variable to store the original number\\n        int count = 0;   // Initialize a counter to keep track of qualifying digits\\n        \\n        // Iterate through each digit of the number\\n        while (temp > 0) {\\n            int digit = temp % 10;  // Get the last digit of the number\\n            \\n            // Check if the digit divides the original number evenly\\n            if (num % digit == 0) {\\n                count++;  // Increment the counter if the digit qualifies\\n            }\\n            \\n            temp = temp / 10;  // Move to the next digit by removing the last digit\\n        }\\n        \\n        return count;  // Return the final count of digits that divide the number evenly\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875385,
                "title": "python-easy-solution-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        res=0\\n        for i in str(num):\\n            if num%int(i)==0:\\n                res+=1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        res=0\\n        for i in str(num):\\n            if num%int(i)==0:\\n                res+=1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797597,
                "title": "fully-explained-c-100-beats-in-time-complexity",
                "content": "# Intuition &  Approach\\n\\n1. ```int result = 0;```: A variable result is initialized to zero. This variable will keep track of the count of digits that divide ```num```.\\n\\n2. ```int tempNum = num;```: A temporary variable ```tempNum``` is initialized with the same value as ```num```. This is done to preserve the original value of ```num``` since it will be modified later in the code.\\n\\n3. ```while (num)```: This is a while loop that runs as long as ```num``` is non-zero. The purpose of this loop is to extract the individual digits of ```num``` and *check if they divide tempNum evenly*.\\n\\n4. ```if (tempNum % (num % 10) == 0)```: This line extracts the last digit of ```num``` (the least significant digit) by calculating ```num % 10```. Then, it checks whether the extracted digit divides tempNum evenly (i.e., with a remainder of zero). If it does, then:\\n\\n- ```result += 1;```: The result variable is incremented by 1, indicating that the current digit is a divisor of ```tempNum```.\\n\\n- ```num /= 10;```: This line removes the last digit of ```num``` by dividing it by 10. This operation effectively shifts the number one digit to the right (*removing the least significant digit*).\\n\\n5. After the above ```while``` loop, the function will have iterated through all the digits of the original ```num```, and the variable ```result``` will hold the count of digits that divide ```tempNum``` evenly.\\n\\n6. **Finally**, the function returns the value of ```result```, which represents the count of digits in the original num that divide ```num``` evenly.\\n\\n7. After the above while loop, the vector arr will contain the individual digits of ```num``` in reverse order.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        \\n        int result = 0;\\n        int tempNum = num;\\n\\n        while(num){\\n\\n            \\n            if(tempNum % (num % 10) == 0){\\n                result +=1;\\n            }\\n            num /= 10;\\n        }\\n       \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```int result = 0;```\n```num```\n```int tempNum = num;```\n```tempNum```\n```num```\n```num```\n```while (num)```\n```num```\n```num```\n```if (tempNum % (num % 10) == 0)```\n```num```\n```num % 10```\n```result += 1;```\n```tempNum```\n```num /= 10;```\n```num```\n```while```\n```num```\n```result```\n```tempNum```\n```result```\n```num```\n```num```\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        \\n        int result = 0;\\n        int tempNum = num;\\n\\n        while(num){\\n\\n            \\n            if(tempNum % (num % 10) == 0){\\n                result +=1;\\n            }\\n            num /= 10;\\n        }\\n       \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697417,
                "title": "easy-and-simple-solution-in-java-0ms-runtime",
                "content": "# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int count = 0;\\n        int n=num;\\n        while(num!=0)\\n        {\\n            int k=num%10;\\n            if(n%k==0)\\n            {\\n                count++;\\n            }\\n            num/=10;\\n        }\\n        return count; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int count = 0;\\n        int n=num;\\n        while(num!=0)\\n        {\\n            int k=num%10;\\n            if(n%k==0)\\n            {\\n                count++;\\n            }\\n            num/=10;\\n        }\\n        return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697416,
                "title": "0ms-solution-in-c-beats-94-memory",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int temp=num;\\n        int count=0;\\n        while (temp>0)\\n        {\\n            int dig=temp%10;\\n            if (num%dig==0) count++;\\n            temp/=10;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int temp=num;\\n        int count=0;\\n        while (temp>0)\\n        {\\n            int dig=temp%10;\\n            if (num%dig==0) count++;\\n            temp/=10;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668040,
                "title": "0-ms-c-solution",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int count=0;\\n        int copy=num;\\n        while(copy!=0)\\n        {\\n            int rem=copy%10;\\n            if(num%rem==0) count++;\\n            copy=copy/10;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int count=0;\\n        int copy=num;\\n        while(copy!=0)\\n        {\\n            int rem=copy%10;\\n            if(num%rem==0) count++;\\n            copy=copy/10;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662293,
                "title": "2520-count-the-digits-that-divide-a-number-100-easy-java-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int count = 0;\\n        int r = 0;\\n        int res = num;\\n        while(res>0){\\n            r = res%10;\\n            res = res/10;\\n            if(num% r == 0){\\n                count++;\\n            }\\n\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int count = 0;\\n        int r = 0;\\n        int res = num;\\n        while(res>0){\\n            r = res%10;\\n            res = res/10;\\n            if(num% r == 0){\\n                count++;\\n            }\\n\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593808,
                "title": "java-easy-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n<!-- Intuition is simple just simple access each digit and divide from the given number if the remainder is **Zero** then increase the count. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n      int b = num;\\n      int count = 0;\\n      while(num != 0){\\n        int rem = num % 10;\\n        num/=10;\\n        if(b % rem == 0){\\n          count++;\\n        }\\n\\n      }\\n      return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n      int b = num;\\n      int count = 0;\\n      while(num != 0){\\n        int rem = num % 10;\\n        num/=10;\\n        if(b % rem == 0){\\n          count++;\\n        }\\n\\n      }\\n      return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571466,
                "title": "beginners-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int count =0;\\n\\n        int x=num;\\n\\n        while(x!=0){\\n            int t= x%10;\\n            if(t!=0 && num%t==0) count++; \\n            x/=10;\\n        }\\n\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int count =0;\\n\\n        int x=num;\\n\\n        while(x!=0){\\n            int t= x%10;\\n            if(t!=0 && num%t==0) count++; \\n            x/=10;\\n        }\\n\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549805,
                "title": "easy-1-line-solution-python3",
                "content": "# Code\\n```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        return sum(1 for x in str(num) if num % int(x) == 0)\\n       \\n                \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        return sum(1 for x in str(num) if num % int(x) == 0)\\n       \\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508754,
                "title": "best-code-with-o-log-n-time-complexity",
                "content": "# Intuition\\nTo solve this problem, we need to count the number of digits in a given positive integer that divide the number itself without leaving a remainder. \\n\\n# Approach\\nWe can implement this algorithm using a simple while loop. First, initialize a counter variable to zero and store the input number in a separate variable. Then, while the input number is greater than zero, find the remainder of the number when it is divided by 10 to get the rightmost digit. Check if the stored input number is divisible by this digit without leaving a remainder. If it is, increment the counter variable. Divide the input number by 10 to remove the rightmost digit. Repeat these steps until the input number becomes zero. Return the counter variable, which represents the number of digits in the original number that divide the number without leaving a remainder.\\n\\n# Complexity\\n- Time complexity: The time complexity of this algorithm is O(log n) because we are dividing the number by 10 in each step until it becomes zero, which results in log base 10 of n steps.\\n- Space complexity: The space complexity of this algorithm is O(1) because we are only using a constant amount of memory to store the counter variable and temporary variables.\\n\\n# Code\\n```\\nint countDigits(int num){\\nint a,b=0,c=num;\\nwhile(num>0){\\n    a=num%10;\\n    if(c%a==0){\\n        b++;\\n    }\\n    num/=10;\\n}\\nreturn b;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint countDigits(int num){\\nint a,b=0,c=num;\\nwhile(num>0){\\n    a=num%10;\\n    if(c%a==0){\\n        b++;\\n    }\\n    num/=10;\\n}\\nreturn b;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3360482,
                "title": "c-easy-to-understand-0ms-beats-100-one-iteration",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nC++ | EASY TO UNDERSTAND | 0ms Beats 100% | ONE ITERATION\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    To begin, we create a new variable to store our initial number.\\n\\n    Next, we isolate the digit in the ones place of the number, and\\n    divide our initial number by this digit.\\n\\n    If the division is successful with no remainder, we increment \\n    our count and remove the digit in the ones place from our \\n    initial number.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    Runtime 0 ms,  Beats 100%\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    Memory 6 MB,  Beats:  10.29%\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int count,a,n = num;\\n        while(num>0)\\n        {\\n            a = num%10;\\n            if(n%a == 0)\\n            {\\n                count++;\\n            }\\n            num=num/10;\\n        }\\n    return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int count,a,n = num;\\n        while(num>0)\\n        {\\n            a = num%10;\\n            if(n%a == 0)\\n            {\\n                count++;\\n            }\\n            num=num/10;\\n        }\\n    return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358805,
                "title": "very-easy-beats-100-0ms-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int n = String.valueOf(num).length();\\n\\n        // int arr[]= new int[n];\\n        int a=0;\\n        int flag=0;\\n        int copy=num;\\n\\n        for(int i =0 ;i<n;i++){\\n            a=num%10;\\n            if(copy%a==0){\\n                flag++;\\n            }\\n            num/=10;\\n        }\\n\\n        return flag;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int n = String.valueOf(num).length();\\n\\n        // int arr[]= new int[n];\\n        int a=0;\\n        int flag=0;\\n        int copy=num;\\n\\n        for(int i =0 ;i<n;i++){\\n            a=num%10;\\n            if(copy%a==0){\\n                flag++;\\n            }\\n            num/=10;\\n        }\\n\\n        return flag;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354354,
                "title": "one-liner-solution-easy-undetstanding",
                "content": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        return (int)(Integer.toString(num)).chars()\\n                                           .map(Character::getNumericValue)\\n                                           .filter(digit -> digit != 0 && num % digit == 0)\\n                                           .count();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        return (int)(Integer.toString(num)).chars()\\n                                           .map(Character::getNumericValue)\\n                                           .filter(digit -> digit != 0 && num % digit == 0)\\n                                           .count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352530,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int ans=0;\\n        int temp=num;\\n        while(temp>0){\\n            if(num%(temp%10)==0)ans++;\\n            temp/=10;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int ans=0;\\n        int temp=num;\\n        while(temp>0){\\n            if(num%(temp%10)==0)ans++;\\n            temp/=10;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352528,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int ans=0;\\n        int temp=num;\\n        while(temp>0){\\n            if(num%(temp%10)==0)ans++;\\n            temp/=10;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int ans=0;\\n        int temp=num;\\n        while(temp>0){\\n            if(num%(temp%10)==0)ans++;\\n            temp/=10;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330091,
                "title": "easiest-java-solution-100-faster",
                "content": "# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int count = 0;\\n        int digit = 0;\\n        int temp = num;\\n        while (num != 0) {\\n            digit = num % 10;\\n            if (temp % digit == 0) {\\n                count++;\\n            }\\n            num = num / 10;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int count = 0;\\n        int digit = 0;\\n        int temp = num;\\n        while (num != 0) {\\n            digit = num % 10;\\n            if (temp % digit == 0) {\\n                count++;\\n            }\\n            num = num / 10;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327436,
                "title": "simple-java-solution-beats-100",
                "content": "# Code\\n```\\npublic int countDigits(int num) {\\n    int count = 0, temp = num;\\n    \\n    while (temp > 0) {\\n        count += num % (temp%10) == 0 ? 1 : 0; \\n        temp /= 10;\\n    }\\n    \\n    return count;\\n}\\n```\\n<br/>\\n<br/>\\n<br/>\\n\\nAuthor :- [*Abhinav Bhardwaj*](https://abhinavbhardwaj.in)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int countDigits(int num) {\\n    int count = 0, temp = num;\\n    \\n    while (temp > 0) {\\n        count += num % (temp%10) == 0 ? 1 : 0; \\n        temp /= 10;\\n    }\\n    \\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3324522,
                "title": "simplest-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        temp=0\\n        st=str(num)\\n        for i in st:\\n            if num%int(i)==0:\\n                temp+=1\\n        return temp\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        temp=0\\n        st=str(num)\\n        for i in st:\\n            if num%int(i)==0:\\n                temp+=1\\n        return temp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229029,
                "title": "java-100-beast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        String s = String.valueOf(num);\\n        int x = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(num % Integer.parseInt(s.substring(i,i+1)) == 0)\\n                x++;\\n        }\\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        String s = String.valueOf(num);\\n        int x = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(num % Integer.parseInt(s.substring(i,i+1)) == 0)\\n                x++;\\n        }\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228326,
                "title": "very-easy-java-solution-straightforward-approach",
                "content": "# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int cnt=0;\\n        int n = num;\\n        while(n>0){\\n            int rem = n%10;\\n            if(rem!=0 && num%rem==0){\\n                cnt++;\\n            }\\n            n=n/10;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int cnt=0;\\n        int n = num;\\n        while(n>0){\\n            int rem = n%10;\\n            if(rem!=0 && num%rem==0){\\n                cnt++;\\n            }\\n            n=n/10;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172578,
                "title": "count-the-digits-that-divide-a-number-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind all the digits of the number\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGet all the elements of the number using a while loop and store in an array. Then divide the number by the digits and if it\\'s fully divisible then increment count variable. Return count in the end.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int i, j, n, flag=0, count=0;\\n        vector<int> arr;\\n        n = num;\\n        while(num>0)\\n        {\\n            i = num%10;\\n            num = num/10;\\n            arr.push_back(i);\\n        }\\n\\n        for(i=0 ; i<arr.size() ; i++)\\n        {\\n            if(n%arr[i]==0)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int i, j, n, flag=0, count=0;\\n        vector<int> arr;\\n        n = num;\\n        while(num>0)\\n        {\\n            i = num%10;\\n            num = num/10;\\n            arr.push_back(i);\\n        }\\n\\n        for(i=0 ; i<arr.size() ; i++)\\n        {\\n            if(n%arr[i]==0)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169888,
                "title": "swift-fast-one-liner",
                "content": "**One-Liner, terse (accepted answer)**\\n```\\nclass Solution {\\n    func countDigits(_ num: Int) -> Int {\\n        \"\\\\(num)\".reduce(0){$0+(num%$1.wholeNumberValue!==0 ? 1:0)}\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countDigits(_ num: Int) -> Int {\\n        \"\\\\(num)\".reduce(0){$0+(num%$1.wholeNumberValue!==0 ? 1:0)}\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128558,
                "title": "beats-76-69-count-the-digits-that-divide-a-number",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        count=0\\n        temp=num\\n        while num>0:\\n            rem=num%10\\n            if temp%rem==0:\\n                count+=1\\n            num//=10\\n        return count\\n        \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        count=0\\n        temp=num\\n        while num>0:\\n            rem=num%10\\n            if temp%rem==0:\\n                count+=1\\n            num//=10\\n        return count\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3121094,
                "title": "c-tostring",
                "content": "# Code\\n```\\npublic class Solution \\n{\\n    public int CountDigits(int num) \\n    {\\n        var s = num.ToString();\\n        var res = 0;\\n\\n        for(var i = 0; i < s.Length; i++)\\n        {\\n            var cur = s[i] - \\'0\\';\\n            if(num % cur == 0)\\n            {\\n                res++;\\n            }\\n        }\\n        return res;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int CountDigits(int num) \\n    {\\n        var s = num.ToString();\\n        var res = 0;\\n\\n        for(var i = 0; i < s.Length; i++)\\n        {\\n            var cur = s[i] - \\'0\\';\\n            if(num % cur == 0)\\n            {\\n                res++;\\n            }\\n        }\\n        return res;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117326,
                "title": "c-beats-100",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int n) {\\n        if(n < 10) return 1;\\n        int x = n, count = 0;;\\n        while(x) {\\n            if(n % (x % 10) == 0) count++;\\n            x /= 10;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int n) {\\n        if(n < 10) return 1;\\n        int x = n, count = 0;;\\n        while(x) {\\n            if(n % (x % 10) == 0) count++;\\n            x /= 10;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104374,
                "title": "java-0ms-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int temp = num, count = 0;\\n        while (temp > 0) {\\n            if (num % (temp % 10) == 0) count++;\\n            temp /= 10;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int temp = num, count = 0;\\n        while (temp > 0) {\\n            if (num % (temp % 10) == 0) count++;\\n            temp /= 10;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102233,
                "title": "c-simplest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int temp=num,count=0;\\n        while(temp>0){\\n            int rem=temp%10;\\n            if(num%rem==0){\\n                count++;\\n            }\\n            temp=temp/10;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int temp=num,count=0;\\n        while(temp>0){\\n            int rem=temp%10;\\n            if(num%rem==0){\\n                count++;\\n            }\\n            temp=temp/10;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099010,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        c=0\\n        a=str(num)\\n        for i in range(len(a)):\\n            if(num%int(a[i])==0):\\n                c=c+1\\n        print(1%num)\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        c=0\\n        a=str(num)\\n        for i in range(len(a)):\\n            if(num%int(a[i])==0):\\n                c=c+1\\n        print(1%num)\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3077470,
                "title": "c-easy-understanding-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Iterate till the number is `greater than 0`\\n2. Find the `last digit` of the number \\n3. Check if it divides num\\n4. Increase `cnt` if it divides \\n5. Divide the number by 10.\\n6. Return the `cnt`\\n\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int temp = num ; \\n        int x ; \\n        int cnt = 0 ;\\n        while (num)\\n        {\\n            x = num % 10;\\n            if(temp % x == 0 )\\n            {\\n                cnt ++ ; \\n            }\\n            num = num /10;\\n        }\\n        return cnt ; \\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023 (1).png](https://assets.leetcode.com/users/images/f45fd0c7-6e49-4cbc-86b3-cf7eb834f5c0_1674226046.226242.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int temp = num ; \\n        int x ; \\n        int cnt = 0 ;\\n        while (num)\\n        {\\n            x = num % 10;\\n            if(temp % x == 0 )\\n            {\\n                cnt ++ ; \\n            }\\n            num = num /10;\\n        }\\n        return cnt ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067581,
                "title": "c-easy-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int count = 0;\\n        int n = num;\\n        while(n != 0){\\n            int r = n % 10;\\n            if(num % r == 0) count++;\\n            n /= 10;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int count = 0;\\n        int n = num;\\n        while(n != 0){\\n            int r = n % 10;\\n            if(num % r == 0) count++;\\n            n /= 10;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043401,
                "title": "easy-solution-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int count=0;\\n        String temp = Integer.toString(num);\\n        int[] numbers = new int[temp.length()];\\n        for (int i=0;i<temp.length();i++){\\n            numbers[i]=Character.getNumericValue(temp.charAt(i));\\n            if(num%numbers[i]==0){\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int count=0;\\n        String temp = Integer.toString(num);\\n        int[] numbers = new int[temp.length()];\\n        for (int i=0;i<temp.length();i++){\\n            numbers[i]=Character.getNumericValue(temp.charAt(i));\\n            if(num%numbers[i]==0){\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039034,
                "title": "easy-java-solution-with-0-ms-runtime-tc-o-n-beats-100",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int countDigits(int num) \\n    {\\n        int count = 0;\\n        for(int tempNum = num, currDiv; tempNum>0; tempNum/=10)\\n        {\\n            currDiv = tempNum%10;\\n            count += currDiv > 0 && num % currDiv == 0 ? 1 : 0;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int countDigits(int num) \\n    {\\n        int count = 0;\\n        for(int tempNum = num, currDiv; tempNum>0; tempNum/=10)\\n        {\\n            currDiv = tempNum%10;\\n            count += currDiv > 0 && num % currDiv == 0 ? 1 : 0;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036602,
                "title": "dart",
                "content": "# Code\\n```dart\\nclass Solution {\\n  int countDigits(int num) {\\n    var result = 0;\\n    for (var rest = num; rest > 0; rest ~/= 10) {\\n      final digit = rest % 10;\\n      if (num % digit == 0) {\\n        result++;\\n      }\\n    }\\n    return result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```dart\\nclass Solution {\\n  int countDigits(int num) {\\n    var result = 0;\\n    for (var rest = num; rest > 0; rest ~/= 10) {\\n      final digit = rest % 10;\\n      if (num % digit == 0) {\\n        result++;\\n      }\\n    }\\n    return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035969,
                "title": "simple-js-solution-with-1-line",
                "content": "# Code\\n```\\n/**\\n * @param {number} num\\n * @return {number}\\n */\\nconst countDigits = function (num) {\\n  return num.toString().split(\\'\\').filter(x => num % x == 0).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} num\\n * @return {number}\\n */\\nconst countDigits = function (num) {\\n  return num.toString().split(\\'\\').filter(x => num % x == 0).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3021880,
                "title": "c-solution-easy-basic-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        \\n    int count = 0;\\n    int n = num;\\n    while(n>0){\\n        if(num%(n%10) == 0)\\n            count++;\\n            n/=10;\\n    }\\n    return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        \\n    int count = 0;\\n    int n = num;\\n    while(n>0){\\n        if(num%(n%10) == 0)\\n            count++;\\n            n/=10;\\n    }\\n    return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016013,
                "title": "java-100-short-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst store input to another variable then check every digits if it\\'s divide the number.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int res = 0;\\n        int numCarry = num;\\n        while(numCarry>0){\\n            if(num % (numCarry%10) == 0) res++;\\n            numCarry/=10;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int res = 0;\\n        int numCarry = num;\\n        while(numCarry>0){\\n            if(num % (numCarry%10) == 0) res++;\\n            numCarry/=10;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014491,
                "title": "c-100-easy",
                "content": "\\n# Code\\n```\\n\\nstatic auto _ = []() {\\n  std::ios::sync_with_stdio(false);\\n  std::cin.tie(nullptr);\\n  return nullptr;\\n}();\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int tmp= num, count=0, digit;\\n\\n        while (tmp){\\n            digit = tmp%10;\\n            if (num % digit == 0) count++;\\n            tmp = tmp/10;\\n        }\\n\\n        return count;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nstatic auto _ = []() {\\n  std::ios::sync_with_stdio(false);\\n  std::cin.tie(nullptr);\\n  return nullptr;\\n}();\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int tmp= num, count=0, digit;\\n\\n        while (tmp){\\n            digit = tmp%10;\\n            if (num % digit == 0) count++;\\n            tmp = tmp/10;\\n        }\\n\\n        return count;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012030,
                "title": "q2520-accepted-c-100-fastest-sol-easiest-simple",
                "content": "CRUX\\n1) We need to find the each digits of the number is able to divide it\\'s parent without remainder.\\n2) Thus, We apply a very simple approach by going through individual digits.\\n3) While traversing we check whether the digits divides the number completely then we increment count.\\n4) Otherwise, we move forward.\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int t=num; // Making a copy\\n        int count=0;\\n        while(t>0){ \\n            int x=t%10; //Ex- 256 , We get 6 , Used to find the last digit\\n            if(num%x==0) // If the digit divides the number the we increment count  \\n                count++;\\n            t=t/10; // Ex- 256 , We get 25 , Divide by 10 to move forward with traversal \\n        }\\n        return count; //Returing the answer\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int t=num; // Making a copy\\n        int count=0;\\n        while(t>0){ \\n            int x=t%10; //Ex- 256 , We get 6 , Used to find the last digit\\n            if(num%x==0) // If the digit divides the number the we increment count  \\n                count++;\\n            t=t/10; // Ex- 256 , We get 25 , Divide by 10 to move forward with traversal \\n        }\\n        return count; //Returing the answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3004388,
                "title": "easyyyyy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nMD ARHAM KALAM ANSARI\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        unordered_set<int> s;\\n        unordered_map<int,int> m;\\n        int n=num;\\n        int k=num;\\n        while(num)\\n        {\\n            m[num%10]++;\\n            num=num/10;\\n        }\\n        int i;\\n        int c=0;\\n        while(n)\\n        {\\n            i=n%10;\\n            if(k%i==0 and s.find(i)==s.end())\\n            {\\n                c+=m[i];\\n                s.insert(i);\\n            }\\n            n=n/10;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        unordered_set<int> s;\\n        unordered_map<int,int> m;\\n        int n=num;\\n        int k=num;\\n        while(num)\\n        {\\n            m[num%10]++;\\n            num=num/10;\\n        }\\n        int i;\\n        int c=0;\\n        while(n)\\n        {\\n            i=n%10;\\n            if(k%i==0 and s.find(i)==s.end())\\n            {\\n                c+=m[i];\\n                s.insert(i);\\n            }\\n            n=n/10;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997880,
                "title": "c-most-easy-and-concise-solution",
                "content": "# Explanation\\nWe take `n` as a copy of `num` to split into digits.\\nWe start from the last digit - `n % 10` and check if it devides `num`.\\nThen we cut off the last digit and go on to the next one.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int res = 0, n = num;\\n        while (n) {\\n            res += num % (n % 10) ? 0 : 1;\\n            n /= 10;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int res = 0, n = num;\\n        while (n) {\\n            res += num % (n % 10) ? 0 : 1;\\n            n /= 10;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994726,
                "title": "rust-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn count_digits(num: i32) -> i32 {\\n        let mut ans = 0;\\n        let mut t = num;\\n        while t > 0\\n        {\\n            if num % (t%10) == 0\\n            {\\n                ans += 1;\\n            }\\n            t/= 10;\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_digits(num: i32) -> i32 {\\n        let mut ans = 0;\\n        let mut t = num;\\n        while t > 0\\n        {\\n            if num % (t%10) == 0\\n            {\\n                ans += 1;\\n            }\\n            t/= 10;\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2994233,
                "title": "python-90-35-faster-easy-solution",
                "content": "```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        t,c=num,0\\n        while t>0:\\n            s=t%10\\n            if num%s==0:\\n                c+=1\\n            t//=10\\n        return c\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        t,c=num,0\\n        while t>0:\\n            s=t%10\\n            if num%s==0:\\n                c+=1\\n            t//=10\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993675,
                "title": "easy-c-solution-just-read-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int c=0;\\n        int temp=num;\\n        while(temp)\\n        {\\n            int r=temp%10;\\n            if(num%r==0)\\n                c++;\\n            temp/=10;    \\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int c=0;\\n        int temp=num;\\n        while(temp)\\n        {\\n            int r=temp%10;\\n            if(num%r==0)\\n                c++;\\n            temp/=10;    \\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990902,
                "title": "simple-o-log-n-solution-c-clean-code",
                "content": "\\n# Complexity\\n- Time complexity:$$O(log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n\\tint countDigits(int num)\\n\\t{\\n\\t\\tint x = num;\\n\\t\\tint ans = 0;\\n\\t\\twhile (num > 0)\\n\\t\\t{\\n\\t\\t\\tint p = num % 10; // digit\\n\\t\\t\\tif (p) // p should not be equal to zero, divide by zero error\\n\\t\\t\\t{ \\n\\t\\t\\t\\tif (x % p == 0)\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t\\tnum /= 10;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\tint countDigits(int num)\\n\\t{\\n\\t\\tint x = num;\\n\\t\\tint ans = 0;\\n\\t\\twhile (num > 0)\\n\\t\\t{\\n\\t\\t\\tint p = num % 10; // digit\\n\\t\\t\\tif (p) // p should not be equal to zero, divide by zero error\\n\\t\\t\\t{ \\n\\t\\t\\t\\tif (x % p == 0)\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t\\tnum /= 10;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2988106,
                "title": "javascript-one-liner",
                "content": "\\n```\\nconst countDigits = (num) =>\\n    num\\n        .toString()\\n        .split(\\'\\')\\n        .reduce((acc, cur) => (num % +cur === 0 ? acc + 1 : acc), 0);\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst countDigits = (num) =>\\n    num\\n        .toString()\\n        .split(\\'\\')\\n        .reduce((acc, cur) => (num % +cur === 0 ? acc + 1 : acc), 0);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2987219,
                "title": "rust-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn count_digits(num: i32) -> i32 {\\n        let (mut n, mut res) = (num, 0);\\n        while n > 0 {\\n            res += (num % (n % 10) == 0) as i32;\\n            n /= 10;\\n        }\\n        res\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust",
                    "Math"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_digits(num: i32) -> i32 {\\n        let (mut n, mut res) = (num, 0);\\n        while n > 0 {\\n            res += (num % (n % 10) == 0) as i32;\\n            n /= 10;\\n        }\\n        res\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2986866,
                "title": "c-easy-solution-beats-100",
                "content": "# Intuition\\nnumber % 10 = last digit \\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int ans = 0;;\\n        int n = num;\\n        while(n > 0){\\n            int r = n%10;\\n            if(num % r == 0) ans++;\\n            n = n/10;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int ans = 0;;\\n        int n = num;\\n        while(n > 0){\\n            int r = n%10;\\n            if(num % r == 0) ans++;\\n            n = n/10;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2986589,
                "title": "c-easy-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int n = num,ele,cnt=0;\\n        while(n){\\n            ele = n%10;\\n            n/=10;\\n            if(ele!=0 && num%ele==0) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int n = num,ele,cnt=0;\\n        while(n){\\n            ele = n%10;\\n            n/=10;\\n            if(ele!=0 && num%ele==0) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2986178,
                "title": "c-solution-very-easy-approach-single-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n         int n=num;\\n         int count=0;\\n         while(num>0)\\n         {\\n             int rem=num%10;\\n             if(n%rem==0)\\n             {\\n                 count++;\\n             }\\n             num=num/10;\\n         }\\n\\n         return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n         int n=num;\\n         int count=0;\\n         while(num>0)\\n         {\\n             int rem=num%10;\\n             if(n%rem==0)\\n             {\\n                 count++;\\n             }\\n             num=num/10;\\n         }\\n\\n         return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979384,
                "title": "easy-problem-c-0ms-o-log-n",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int nums){\\n     int cnt=0,i,num=nums;\\n        while(nums>0){\\n         i=nums%10;\\n          //get the last element \\n         if(num%i==0){\\n             cnt++;\\n         }\\n            nums/=10;\\n        // reduce the number \\n     }   \\n      return cnt++;\\n   }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int nums){\\n     int cnt=0,i,num=nums;\\n        while(nums>0){\\n         i=nums%10;\\n          //get the last element \\n         if(num%i==0){\\n             cnt++;\\n         }\\n            nums/=10;\\n        // reduce the number \\n     }   \\n      return cnt++;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978842,
                "title": "very-easy-fast-solution-java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int out=0, d,t=num;\\n        \\n        while(num>0){\\n            d=num%10;\\n            num/=10;\\n            if(t%d==0)\\n                    out++;\\n        }\\n        return out;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int out=0, d,t=num;\\n        \\n        while(num>0){\\n            d=num%10;\\n            num/=10;\\n            if(t%d==0)\\n                    out++;\\n        }\\n        return out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978824,
                "title": "modulo-approach",
                "content": "\\n# Complexity\\n- Time complexity: N ( here N is the length of num)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) constant\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction countDigits(num: number): number {\\n    let count = 0 ;\\n    const n = num;\\n    \\n    while(num > 1){\\n        if(n % (num % 10) === 0) count++\\n        num = Math.floor(num / 10)\\n    }\\n    \\n    if(num === 1) count++\\n    \\n    return count\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "TypeScript",
                    "Math"
                ],
                "code": "```\\nfunction countDigits(num: number): number {\\n    let count = 0 ;\\n    const n = num;\\n    \\n    while(num > 1){\\n        if(n % (num % 10) === 0) count++\\n        num = Math.floor(num / 10)\\n    }\\n    \\n    if(num === 1) count++\\n    \\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2978575,
                "title": "java-easy-solution-100-faster",
                "content": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int count=0;\\n        int temp=num;\\n        while(temp!=0){\\n            int div=temp%10;\\n            if(num%div==0){\\n                count++;\\n            }\\n            temp/=10;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int count=0;\\n        int temp=num;\\n        while(temp!=0){\\n            int div=temp%10;\\n            if(num%div==0){\\n                count++;\\n            }\\n            temp/=10;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978418,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        String s = \"\"+num;\\n        int i=0, count = 0;\\n        while(i<s.length()){\\n            int n = Integer.parseInt(\"\"+s.charAt(i));\\n            i++;\\n            if(num%n==0)    count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        String s = \"\"+num;\\n        int i=0, count = 0;\\n        while(i<s.length()){\\n            int n = Integer.parseInt(\"\"+s.charAt(i));\\n            i++;\\n            if(num%n==0)    count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978176,
                "title": "c-simple-and-easy-to-understand-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int temp=num;\\n        int count=0;\\n        while(temp>0){\\n            int digit=temp%10;\\n            if(num%digit==0){\\n                count++;\\n            }\\n            temp=temp/10;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int temp=num;\\n        int count=0;\\n        while(temp>0){\\n            int digit=temp%10;\\n            if(num%digit==0){\\n                count++;\\n            }\\n            temp=temp/10;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977768,
                "title": "java-easy",
                "content": "---\\n# Please Upvote \\uD83D\\uDE07\\n---\\n``` \\nclass Solution {\\n    public int countDigits(int num) {\\n        int x = num;\\n        int count = 0;\\n        while (num != 0) {\\n            int rem = num % 10;\\n            if (x % rem == 0) {\\n                count++;\\n            }\\n            num /= 10;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\n---\\n##### Time Complexity: $$O(n)$$\\nwhere $$n$$ is the number of digits in `num`\\n",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "``` \\nclass Solution {\\n    public int countDigits(int num) {\\n        int x = num;\\n        int count = 0;\\n        while (num != 0) {\\n            int rem = num % 10;\\n            if (x % rem == 0) {\\n                count++;\\n            }\\n            num /= 10;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977759,
                "title": "ruby-1-liner",
                "content": "```ruby\\ndef count_digits(n) = n.digits.count { n % _1 == 0 }\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef count_digits(n) = n.digits.count { n % _1 == 0 }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2977475,
                "title": "simple-and-esay-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int x=num;\\n        int count=0;\\n        while(num!=0){\\n            int rem=num%10;\\n            num/=10;\\n            if(x%rem==0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int x=num;\\n        int count=0;\\n        while(num!=0){\\n            int rem=num%10;\\n            num/=10;\\n            if(x%rem==0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977473,
                "title": "c-6-lines-of-code-beats-100",
                "content": "***If you find this helpful, Please Upvote \\uD83D\\uDD3C\\nThank You !***\\n\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        \\n        int temp = num, cnt = 0, val;\\n        \\n        while(num) {\\n            val = num%10;\\n            \\n            if(temp % val == 0) cnt++;\\n            \\n            num = num/10;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        \\n        int temp = num, cnt = 0, val;\\n        \\n        while(num) {\\n            val = num%10;\\n            \\n            if(temp % val == 0) cnt++;\\n            \\n            num = num/10;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977471,
                "title": "simple-brute-force-approach-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        vector<int> arr;\\n        int temp = num;\\n        while(temp){\\n            arr.push_back(temp%10);\\n            temp/=10;\\n        };\\n        int res = 0;\\n        for(int i = 0;i<size(arr);i++){\\n            if(num%arr[i] == 0)++res;\\n        };\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        vector<int> arr;\\n        int temp = num;\\n        while(temp){\\n            arr.push_back(temp%10);\\n            temp/=10;\\n        };\\n        int res = 0;\\n        for(int i = 0;i<size(arr);i++){\\n            if(num%arr[i] == 0)++res;\\n        };\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977333,
                "title": "c-to-string-use",
                "content": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        string n = to_string(num);\\n        int ans=0;\\n        for(auto it : n){\\n            if(num%(it-\\'0\\')==0) ans += 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        string n = to_string(num);\\n        int ans=0;\\n        for(auto it : n){\\n            if(num%(it-\\'0\\')==0) ans += 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977322,
                "title": "easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n            int cnt=0;\\n            \\n        int value=num;\\n         while (value > 0) {\\n          \\n          if (num%(value%10) == 0) {\\n               cnt++;\\n           }\\n        value /= 10;\\n    }\\n\\n       return cnt; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n            int cnt=0;\\n            \\n        int value=num;\\n         while (value > 0) {\\n          \\n          if (num%(value%10) == 0) {\\n               cnt++;\\n           }\\n        value /= 10;\\n    }\\n\\n       return cnt; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977320,
                "title": "2520-count-the-digits-that-divide-a-number",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int d, c = 0;\\n        int m = num;\\n        while(m != 0)\\n        {\\n            d = m % 10;\\n            if(num % d == 0) c++;\\n            m = m/10;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int d, c = 0;\\n        int m = num;\\n        while(m != 0)\\n        {\\n            d = m % 10;\\n            if(num % d == 0) c++;\\n            m = m/10;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977299,
                "title": "very-simple-c-solution",
                "content": "```\\nint countDigits(int num) {\\n        int prevNum=num;\\n        int count=0;\\n        while(num)\\n        {\\n            int d=num%10;\\n            if(prevNum%d == 0)\\n                count++;\\n            num/=10;\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint countDigits(int num) {\\n        int prevNum=num;\\n        int count=0;\\n        while(num)\\n        {\\n            int d=num%10;\\n            if(prevNum%d == 0)\\n                count++;\\n            num/=10;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2977265,
                "title": "c-explanation-easy",
                "content": "\\n\\n**Happy New Year !!!**\\n\\n* **Approach** - \\n    1. Very simple, We need all digits so, we take it one digit and check num % digit == 0\\n* Time Complextiy - O(N)\\n* Spcace Complextiy - O(1)\\n\\n**REQUEST** :\\xA0If you found this post even remotely helpful, be kind enough to smash a upvote. I will be grateful.\\n\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int nn = num, ans = 0;\\n        while(nn) {\\n            int rem = nn % 10;\\n            if(num % rem == 0) ans++;\\n            nn /= 10;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int nn = num, ans = 0;\\n        while(nn) {\\n            int rem = nn % 10;\\n            if(num % rem == 0) ans++;\\n            nn /= 10;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977262,
                "title": "c-easy-and-simple-solution",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n# Complexity\\n- Time complexity:\\nO(N)<br>\\nN is the no of digit in Num .\\n\\n- Space complexity:\\n O(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        vector<int>digit;\\n        int temp=num;\\n        while(temp>0){\\n            digit.push_back(temp%10);\\n            temp=temp/10;\\n        }\\n        int count=0;\\n        for(int i=0;i<digit.size();i++){\\n            if(num%digit[i]==0) count++;\\n            \\n        }\\n        return count;\\n    }\\n};\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        vector<int>digit;\\n        int temp=num;\\n        while(temp>0){\\n            digit.push_back(temp%10);\\n            temp=temp/10;\\n        }\\n        int count=0;\\n        for(int i=0;i<digit.size();i++){\\n            if(num%digit[i]==0) count++;\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977242,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        string n = to_string(num);\\n        int count = 0;\\n        for(auto it: n) {\\n            int temp = it - \\'0\\';\\n            if(num % temp == 0) count += 1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        string n = to_string(num);\\n        int count = 0;\\n        for(auto it: n) {\\n            int temp = it - \\'0\\';\\n            if(num % temp == 0) count += 1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090179,
                "title": "100-faster-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int n=num;\\n        int c=0;\\n        while(num!=0){\\n            if(n%(num%10)==0)c++;\\n            num=num/10;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int n=num;\\n        int c=0;\\n        while(num!=0){\\n            if(n%(num%10)==0)c++;\\n            num=num/10;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089694,
                "title": "java-easy-solution-beats-100-with-time-and-99-89-with-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        String s= Integer.toString(num);\\n        char[] c=s.toCharArray();\\n        int x=0;\\n        for(int i=0;i<c.length;i++){\\n\\n            int a=c[i]-\\'0\\';\\n            if(num%a==0)\\n            x++;\\n        }\\n        return x;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        String s= Integer.toString(num);\\n        char[] c=s.toCharArray();\\n        int x=0;\\n        for(int i=0;i<c.length;i++){\\n\\n            int a=c[i]-\\'0\\';\\n            if(num%a==0)\\n            x++;\\n        }\\n        return x;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082983,
                "title": "python3-o-logn-tc",
                "content": "# Complexity\\n- Time complexity:\\nO(logn)\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        tmp = num\\n        c = 0\\n        while tmp > 0:\\n            d = tmp % 10\\n            tmp = tmp // 10\\n            if num % d == 0:\\n                c += 1\\n        return c\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        tmp = num\\n        c = 0\\n        while tmp > 0:\\n            d = tmp % 10\\n            tmp = tmp // 10\\n            if num % d == 0:\\n                c += 1\\n        return c\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081084,
                "title": "kotlin-1-line-solution-that-beats-90-113ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n fun countDigits(num: Int): Int = \"$num\".fold(0) { acc, it -> if ( num % (it - \\'0\\')  == 0) acc + 1 else acc }\\n\\n\\n}\\n\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n\\n fun countDigits(num: Int): Int = \"$num\".fold(0) { acc, it -> if ( num % (it - \\'0\\')  == 0) acc + 1 else acc }\\n\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074650,
                "title": "python-solution-for-count-the-digits-that-divide-a-number",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        divs = [int(i) for i in str(num)]\\n        cnt = 0\\n        for i in divs:\\n            if num % i == 0:\\n                cnt += 1\\n        return cnt\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        divs = [int(i) for i in str(num)]\\n        cnt = 0\\n        for i in divs:\\n            if num % i == 0:\\n                cnt += 1\\n        return cnt\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074525,
                "title": "python-solution-easy-to-understand-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        s=0\\n        for i in str(num):\\n            if num%int(i)==0:\\n                s+=1\\n        return s\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        s=0\\n        for i in str(num):\\n            if num%int(i)==0:\\n                s+=1\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073410,
                "title": "the-only-easy-way",
                "content": "# \\uD83D\\uDE09Don\\'t just watch & move away, also give an Upvote.\\uD83D\\uDE09\\n# Complexity\\n- Time complexity: $$O(n)$$, where `n` is the no. of digits in `num`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int cnt=0;\\n        int n = num;\\n        int divider = 0;\\n\\n        while(n != 0)\\n        {\\n            divider = n%10;\\n\\n            if(divider != 0 && num%divider == 0)\\n                cnt++;\\n            \\n            n = n/10;\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return cnt;\\n    }\\n};\\n```\\n![Leetcode Upvote.gif](https://assets.leetcode.com/users/images/0b05a106-2f1f-4678-8e4d-350bb25033b3_1695315972.6420393.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int cnt=0;\\n        int n = num;\\n        int divider = 0;\\n\\n        while(n != 0)\\n        {\\n            divider = n%10;\\n\\n            if(divider != 0 && num%divider == 0)\\n                cnt++;\\n            \\n            n = n/10;\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068858,
                "title": "easy-solution",
                "content": "int cnt=0;\\n        int n=num;\\n        while(n>0)\\n        {                                                      \\n            int rem=n%10;\\n            if(num%rem==0)\\n            {\\n                cnt++;\\n            }\\n            n=n/10;\\n        }\\n        return cnt;",
                "solutionTags": [
                    "C"
                ],
                "code": "int cnt=0;\\n        int n=num;\\n        while(n>0)\\n        {                                                      \\n            int rem=n%10;\\n            if(num%rem==0)\\n            {\\n                cnt++;\\n            }\\n            n=n/10;\\n        }\\n        return cnt;",
                "codeTag": "Unknown"
            },
            {
                "id": 4063432,
                "title": "c-solution-beats-100-0ms",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int digits[10] {0};\\n        int n = num, count = 0;\\n        while(n) {\\n            if(digits[n%10] == 1)\\n                count++;\\n            else if(digits[n%10] == 0) {\\n                if(num % (n%10) == 0) {\\n                    digits[n%10] = 1;\\n                    count++;\\n                }\\n                else\\n                    digits[n%10] = -1;\\n            }\\n            n /= 10;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int digits[10] {0};\\n        int n = num, count = 0;\\n        while(n) {\\n            if(digits[n%10] == 1)\\n                count++;\\n            else if(digits[n%10] == 0) {\\n                if(num % (n%10) == 0) {\\n                    digits[n%10] = 1;\\n                    count++;\\n                }\\n                else\\n                    digits[n%10] = -1;\\n            }\\n            n /= 10;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057708,
                "title": "python-o-log-n-time-o-1-space",
                "content": "- Time complexity: O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        n = num\\n\\n        count = 0\\n        while n:\\n            x = n % 10\\n            n = n // 10\\n            if num % x == 0:\\n                count += 1\\n        \\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        n = num\\n\\n        count = 0\\n        while n:\\n            x = n % 10\\n            n = n // 10\\n            if num % x == 0:\\n                count += 1\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055670,
                "title": "kotlin-easy-to-read-and-understand-using-string",
                "content": "# Approach\\nConvert num to String\\nCount modulo division for every char in string\\n\\ndigit.toString().toInt() is required because digit is a Char and converted to Int using ASCII table number\\n\\n# Code\\n```\\nclass Solution {\\n    fun countDigits(num: Int): Int {\\n        var count = 0\\n\\n        for (digit in num.toString()) {\\n            if (num % digit.toString().toInt() == 0) {\\n                count++\\n            }\\n        }\\n\\n        return count\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun countDigits(num: Int): Int {\\n        var count = 0\\n\\n        for (digit in num.toString()) {\\n            if (num % digit.toString().toInt() == 0) {\\n                count++\\n            }\\n        }\\n\\n        return count\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055606,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int n = num; \\n        int count =0; \\n        if(num<10) return 1;\\n        else{\\n            while(n!=0)\\n            {\\n                int rem = n%10;\\n                if(num%rem==0) count++;\\n                n /= 10;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int n = num; \\n        int count =0; \\n        if(num<10) return 1;\\n        else{\\n            while(n!=0)\\n            {\\n                int rem = n%10;\\n                if(num%rem==0) count++;\\n                n /= 10;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050679,
                "title": "c-python-brute-force-approach-too-easy-fully-explained",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere\\'s how the code works:\\n\\n1. It starts by creating a copy of the input integer `num` and stores it in a variable `n`. This is done to avoid modifying the original value of `num`.\\n\\n2. It initializes a variable `cnt` to zero. This variable will be used to count the digits of `num` that evenly divide `num`.\\n\\n3. It enters a `while` loop that continues as long as `n` is not equal to zero. This loop processes each digit of `num` one by one, starting from the rightmost digit.\\n\\n4. Inside the loop, it calculates the remainder of `n` divided by 10 (`n % 10`) to extract the last digit of `n` and stores it in the variable `rem`.\\n\\n5. It checks if `num` is evenly divisible by `rem` (i.e., `num % rem == 0`). If it is, it increments the `cnt` variable to count this digit.\\n\\n6. After processing the last digit, it moves to the next digit by dividing `n` by 10 (`n /= 10`). This effectively removes the last digit, and the loop continues with the next digit.\\n\\n7. Finally, after processing all digits of `num`, it returns the value of the `cnt` variable, which represents the count of digits that evenly divide `num`.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int n = num;\\n        int cnt = 0;\\n        while(n != 0){\\n            int rem = n % 10;\\n            if(num % rem == 0)\\n                cnt++;\\n            n /= 10;\\n        }\\n    return cnt;\\n    }\\n};\\n```\\n``` Python []\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        cnt = 0\\n        n = num\\n        while(n != 0):\\n            if num % (n % 10) == 0:\\n                cnt += 1\\n            n = n // 10\\n        return cnt\\n```",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int n = num;\\n        int cnt = 0;\\n        while(n != 0){\\n            int rem = n % 10;\\n            if(num % rem == 0)\\n                cnt++;\\n            n /= 10;\\n        }\\n    return cnt;\\n    }\\n};\\n```\n``` Python []\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        cnt = 0\\n        n = num\\n        while(n != 0):\\n            if num % (n % 10) == 0:\\n                cnt += 1\\n            n = n // 10\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042695,
                "title": "better-than-98-runtime-and-memory-very-efficient",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        ans = 0\\n        m = [int(x) for x in str(num)]\\n        for n in m:\\n            if num % n == 0:\\n                ans = ans + 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        ans = 0\\n        m = [int(x) for x in str(num)]\\n        for n in m:\\n            if num % n == 0:\\n                ans = ans + 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042229,
                "title": "easiest-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int n=num,count=0,i=0;\\n        while(n!=0){\\n            n=n/10;\\n            count++;\\n        }\\n        n=num;\\n        int d;\\n        int[] arr=new int[count];\\n        while(n!=0){\\n            d=n%10;\\n            arr[i++]=d;\\n            n=n/10;\\n            \\n        }\\n        count=0;\\n        for(i=0;i<arr.length;i++){\\n            if(num%arr[i]==0){\\n                count++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int n=num,count=0,i=0;\\n        while(n!=0){\\n            n=n/10;\\n            count++;\\n        }\\n        n=num;\\n        int d;\\n        int[] arr=new int[count];\\n        while(n!=0){\\n            d=n%10;\\n            arr[i++]=d;\\n            n=n/10;\\n            \\n        }\\n        count=0;\\n        for(i=0;i<arr.length;i++){\\n            if(num%arr[i]==0){\\n                count++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038957,
                "title": "easiest-fastest-java-solution",
                "content": "# Intuition\\nI will iterate number from once digit to last digit. If is dividing the number then I will just increase count by 1 \\n***Easy Peasy WooHoo***\\n\\n# Approach\\nSame as Intuition\\n\\n# Complexity\\n- Time complexity :- O(num of digits in number)\\n- Space complexity :- O(1)\\n\\n***Plz Upvote Less Gooo***\\n# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int count =0 ;\\n        int x = num;\\n        while(num>0){\\n            if(x%(num%10)==0){\\n                count++;\\n            }\\n            num/=10;\\n        }\\n        return count;\\n    }\\n}\\n```\\n![5zadts.jpg](https://assets.leetcode.com/users/images/f466ecb0-4893-48cb-bfe4-dc0dcd473c89_1694589294.6573546.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int count =0 ;\\n        int x = num;\\n        while(num>0){\\n            if(x%(num%10)==0){\\n                count++;\\n            }\\n            num/=10;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038860,
                "title": "easiest-fastest-java-solution",
                "content": "# Intuition\\nI will iterate number from once digit to last digit. If is dividing the number then I will just increase count by 1 \\n***Easy Peasy WooHoo***\\n\\n# Approach\\nSame as Intuition\\n\\n# Complexity\\n- Time complexity :- O(num of digits in number)\\n- Space complexity :- O(1)\\n\\n***Plz Upvote Less Gooo***\\n# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int count =0 ;\\n        int x = num;\\n        while(num>0){\\n            if(x%(num%10)==0){\\n                count++;\\n            }\\n            num/=10;\\n        }\\n        return count;\\n    }\\n}\\n```\\n![5zadts.jpg](https://assets.leetcode.com/users/images/f466ecb0-4893-48cb-bfe4-dc0dcd473c89_1694589294.6573546.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int count =0 ;\\n        int x = num;\\n        while(num>0){\\n            if(x%(num%10)==0){\\n                count++;\\n            }\\n            num/=10;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030955,
                "title": "swift-0ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func countDigits(_ num: Int) -> Int {\\n        \\n        String(num)\\n        .filter { n in\\n            num.isMultiple(of: Int(String(n))!)\\n        }\\n        .endIndex\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countDigits(_ num: Int) -> Int {\\n        \\n        String(num)\\n        .filter { n in\\n            num.isMultiple(of: Int(String(n))!)\\n        }\\n        .endIndex\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026850,
                "title": "simple-java-code-with-explanation",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) \\n    {\\n        int orgNumber = num;  // according to question we need to devide each digit by its original number we have given that is \"num\" if i find all the digit then using original value than the my original value is changed thats why i stored it into another variable\\uD83D\\uDE0A.\\n        int rem,count=0;\\n        while(num>0)  // for calculating each digit from the given value we have\\n        {\\n          rem = num % 10;\\n          if(orgNumber % rem == 0)  //cheking original value is divisible by each digit.\\n          {\\n              count++;   // if divisible then count = count + 1;\\n          }\\n          num/=10; \\n        }\\n\\n        return count; \\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) \\n    {\\n        int orgNumber = num;  // according to question we need to devide each digit by its original number we have given that is \"num\" if i find all the digit then using original value than the my original value is changed thats why i stored it into another variable\\uD83D\\uDE0A.\\n        int rem,count=0;\\n        while(num>0)  // for calculating each digit from the given value we have\\n        {\\n          rem = num % 10;\\n          if(orgNumber % rem == 0)  //cheking original value is divisible by each digit.\\n          {\\n              count++;   // if divisible then count = count + 1;\\n          }\\n          num/=10; \\n        }\\n\\n        return count; \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024901,
                "title": "typescript-javascript-simple-one-line-solution",
                "content": "# Code\\n```\\nfunction countDigits(num: number): number {\\n    return [...String(num)]\\n        .filter((n) => num % +n === 0)\\n        .length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array"
                ],
                "code": "```\\nfunction countDigits(num: number): number {\\n    return [...String(num)]\\n        .filter((n) => num % +n === 0)\\n        .length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4022065,
                "title": "easyyy-java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int x=num;\\n        int count=0;\\n        while(num>0){\\n            int a= num%10;\\n            if(x % a ==0){\\n                count++;\\n            }\\n            num=num/10;\\n        }\\n        return count;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int x=num;\\n        int count=0;\\n        while(num>0){\\n            int a= num%10;\\n            if(x % a ==0){\\n                count++;\\n            }\\n            num=num/10;\\n        }\\n        return count;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019077,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int temp = num;\\n        int count = 0;\\n        while(temp>0){\\n            int ld = temp%10;\\n            if(num%ld == 0){\\n                count += 1;\\n            }\\n            temp = temp/10;\\n        }\\n        return count;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int temp = num;\\n        int count = 0;\\n        while(temp>0){\\n            int ld = temp%10;\\n            if(num%ld == 0){\\n                count += 1;\\n            }\\n            temp = temp/10;\\n        }\\n        return count;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013536,
                "title": "python3-oneline",
                "content": "# Code\\n```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        return sum(num % int(n) == 0 for n in str(num))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        return sum(num % int(n) == 0 for n in str(num))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010275,
                "title": "beginner-s-approach-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int c = 0, copy = num;\\n        while(num>0){\\n            int rem = num%10;\\n            if(copy%rem == 0){\\n               c += 1;\\n            }\\n            num /= 10;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int c = 0, copy = num;\\n        while(num>0){\\n            int rem = num%10;\\n            if(copy%rem == 0){\\n               c += 1;\\n            }\\n            num /= 10;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010031,
                "title": "divide-with-digit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int count=0,temp=num;\\n        while(num!=0){\\n            int last=num%10;\\n            if(temp%last==0){\\n                count++;\\n            }\\n            num/=10;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int count=0,temp=num;\\n        while(num!=0){\\n            int last=num%10;\\n            if(temp%last==0){\\n                count++;\\n            }\\n            num/=10;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010006,
                "title": "java-solution-easy-beats-100",
                "content": "\\n\\n**Time Complexity O(N)**\\n\\n# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int count = 0;\\n        int temp = num;\\n        while(num !=0){\\n            int rem = num % 10;\\n            if(temp % rem ==0){\\n                count++;\\n            }\\n            num = num / 10;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int count = 0;\\n        int temp = num;\\n        while(num !=0){\\n            int rem = num % 10;\\n            if(temp % rem ==0){\\n                count++;\\n            }\\n            num = num / 10;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006453,
                "title": "very-easy-solution-with-0ms-runtime-explained-with-intuition-and-approach",
                "content": "# Intuition\\nThe intuition is very simple . We just need two math operators **/** and **%**\\n\\n# Approach\\neg: take a number ``` n = 1234 ```\\n-> if we do **n%10** we get **4** as output  \\n-> now if we divide it with 10 : **n/10** we get  **n= 123**\\n-> in this method we can simply get last digit of any number without converting it into a string or using some other painful methods . \\n\\n# Complexity\\n- Time complexity:\\n we need to consider n as the length of the number : for 1234 length is 4 \\nso time complexity is : **O(n)**\\n\\n- Space complexity:\\nwe are not using any extra space so : **O(1)**\\n\\n# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        \\n        int dividend = num;\\n        int count =0;\\n        while(dividend >0){\\n            int lastdigit = dividend%10;\\n            if(num%lastdigit==0)count++;\\n            dividend/=10;\\n        }\\n        return count;\\n\\n    }\\n}\\n```\\n# upvote if you found this helpful :)",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "``` n = 1234 ```\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        \\n        int dividend = num;\\n        int count =0;\\n        while(dividend >0){\\n            int lastdigit = dividend%10;\\n            if(num%lastdigit==0)count++;\\n            dividend/=10;\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005875,
                "title": "easy-to-understand-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        if len(str(num))==1:\\n            return 1\\n        else:\\n            temp=num\\n            c=0\\n            while(num>0):\\n                r=num%10\\n                if temp%r==0:\\n                    c+=1\\n                num//=10\\n            return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        if len(str(num))==1:\\n            return 1\\n        else:\\n            temp=num\\n            c=0\\n            while(num>0):\\n                r=num%10\\n                if temp%r==0:\\n                    c+=1\\n                num//=10\\n            return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005107,
                "title": "beats-86-17-of-users-with-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        digit_set = []\\n        original_num = num  # Store the original number for reference\\n        while num > 0:\\n            digit = num % 10\\n            if digit != 0 :\\n                digit_set.append(digit)\\n            num = num // 10\\n        \\n        count = 0\\n        for i in digit_set:\\n            if original_num % i == 0:\\n                count += 1\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        digit_set = []\\n        original_num = num  # Store the original number for reference\\n        while num > 0:\\n            digit = num % 10\\n            if digit != 0 :\\n                digit_set.append(digit)\\n            num = num // 10\\n        \\n        count = 0\\n        for i in digit_set:\\n            if original_num % i == 0:\\n                count += 1\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002597,
                "title": "very-basic-java-soln-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int c=num,ans=0;\\n        while(c!=0){\\n            if(num%(c%10)==0)\\n                ans++;\\n            c/=10;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int c=num,ans=0;\\n        while(c!=0){\\n            if(num%(c%10)==0)\\n                ans++;\\n            c/=10;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997645,
                "title": "my-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is easy one.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBasically we can copy the main number for checking then we can easily check the number;\\n# Complexity\\n- Time complexity: 0ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 39MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int count= 0;\\n        int temp = num;\\n        while(temp>0){\\n            int val= temp%10;\\n            if(num % val == 0){\\n                count++;\\n            }\\n            temp= temp/10;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int count= 0;\\n        int temp = num;\\n        while(temp>0){\\n            int val= temp%10;\\n            if(num % val == 0){\\n                count++;\\n            }\\n            temp= temp/10;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994677,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int temp = num;\\n        int ans = 0;\\n\\n        while(temp){\\n            int rem = temp%10;\\n\\n            if(num%rem == 0) ans++;\\n\\n            temp /= 10;\\n        }   \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int temp = num;\\n        int ans = 0;\\n\\n        while(temp){\\n            int rem = temp%10;\\n\\n            if(num%rem == 0) ans++;\\n\\n            temp /= 10;\\n        }   \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993323,
                "title": "simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        temp = num\\n        count = 0\\n        while temp>0:\\n            count+=1 if num%(temp%10)==0 else 0\\n            temp//=10\\n        return count\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        temp = num\\n        count = 0\\n        while temp>0:\\n            count+=1 if num%(temp%10)==0 else 0\\n            temp//=10\\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988899,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int c=0;\\n        String s=Integer.toString(num);\\n        for(int i=0;i<s.length();i++){\\n            int n=s.charAt(i)-\\'0\\';\\n            if(num%n==0){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int c=0;\\n        String s=Integer.toString(num);\\n        for(int i=0;i<s.length();i++){\\n            int n=s.charAt(i)-\\'0\\';\\n            if(num%n==0){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987116,
                "title": "easy-maths-solution-11ms-beats-98-99-c",
                "content": "# Intuition\\nPure mathematics approach\\n![CountDigits.PNG](https://assets.leetcode.com/users/images/1fae3147-8061-4a9f-8450-b2966483f201_1693549393.9053652.png)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CountDigits(int num) {\\n        int original = num;\\n        int length = num.ToString().Length;\\n        int counter = 0;\\n\\n        for(int i = 0; i< length; i++)\\n        {\\n            int remainder = num % 10;\\n\\n            if (original % remainder == 0) counter++;\\n\\n            num -= remainder;\\n            num /= 10;\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountDigits(int num) {\\n        int original = num;\\n        int length = num.ToString().Length;\\n        int counter = 0;\\n\\n        for(int i = 0; i< length; i++)\\n        {\\n            int remainder = num % 10;\\n\\n            if (original % remainder == 0) counter++;\\n\\n            num -= remainder;\\n            num /= 10;\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984865,
                "title": "python-solution-made-by-a-beginner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        D=0\\n        for i in list(str(num)):\\n            if num%int(i)==0:\\n                D += 1\\n        return D\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        D=0\\n        for i in list(str(num)):\\n            if num%int(i)==0:\\n                D += 1\\n        return D\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981426,
                "title": "simple-python3-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        s=str(num)\\n        count=0\\n        for i in s:\\n            if num%(int(i))==0:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDigits(self, num: int) -> int:\\n        s=str(num)\\n        count=0\\n        for i in s:\\n            if num%(int(i))==0:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979345,
                "title": "java-easy-100-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n    var temp = num;\\n    var ans = 0;\\n    while (temp>0){\\n      var currentD = temp%10;\\n      temp = temp/10;\\n      if(num % currentD ==0){\\n        ans++;\\n      }\\n    }\\n    return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n    var temp = num;\\n    var ans = 0;\\n    while (temp>0){\\n      var currentD = temp%10;\\n      temp = temp/10;\\n      if(num % currentD ==0){\\n        ans++;\\n      }\\n    }\\n    return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979043,
                "title": "beat-100-test-case-easy-sol-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int count =0;\\n        int t =num; \\n        while(num>0){\\n        int val = num%10;\\n         \\n        if(t%val==0)\\n            count++;\\n        num=num/10;\\n        \\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int count =0;\\n        int t =num; \\n        while(num>0){\\n        int val = num%10;\\n         \\n        if(t%val==0)\\n            count++;\\n        num=num/10;\\n        \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978323,
                "title": "simple-math-logic-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int answer = 0;\\n        int n = num;\\n        while(n>0){\\n            if(num % (n%10) == 0) answer++;\\n            n/=10;\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int answer = 0;\\n        int n = num;\\n        while(n>0){\\n            if(num % (n%10) == 0) answer++;\\n            n/=10;\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977480,
                "title": "runtime-beats-100-memory-beats-83-19",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countDigits(int n) {\\n        int cnt=0;\\n        int m=n;\\n        int a;\\n        while(n!=0){\\n              a=n%10;\\n            if(m%a==0  ){\\n                cnt++;\\n            }\\n            n/=10;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int n) {\\n        int cnt=0;\\n        int m=n;\\n        int a;\\n        while(n!=0){\\n              a=n%10;\\n            if(m%a==0  ){\\n                cnt++;\\n            }\\n            n/=10;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977372,
                "title": "c-very-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this solution is to iterate through the digits of the given number `num`, and for each digit, check if it divides the original number `num`. If it does, increment a count to keep track of how many digits of `num` are divisors.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach to solving this problem involves the following steps:\\n\\n1. Initialize `n` with the value of `num` to preserve the original number.\\n2. Initialize variables `digit`, which will store each digit of the number in each iteration, and `count` to keep track of the number of digits that are divisors of the original number.\\n3. Use a while loop to iterate through the digits of the number:\\n    - Extract the rightmost digit of `n` using `n % 10` and store it in the variable `digit`.\\n    - Check if the original number `num` is divisible by the extracted digit digit (i.e., `num % digit == 0`). If it is, increment the `count`.\\n    - Perform integer division to remove the rightmost digit from `n` (i.e., `n /= 10`).\\n4. After the loop completes, return the `count` as the result.\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int n = num, digit = 0, count = 0;\\n        while(n > 0) {\\n            digit = n % 10;\\n            if(num % digit == 0) {\\n                count++;\\n            }\\n            n /= 10;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int n = num, digit = 0, count = 0;\\n        while(n > 0) {\\n            digit = n % 10;\\n            if(num % digit == 0) {\\n                count++;\\n            }\\n            n /= 10;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976417,
                "title": "fastest-code-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int count=0,r=0;\\n        int res = num;\\n        while(res>0){\\n            r = res%10;\\n            res/=10;\\n            if(num%r == 0) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigits(int num) {\\n        int count=0,r=0;\\n        int res = num;\\n        while(res>0){\\n            r = res%10;\\n            res/=10;\\n            if(num%r == 0) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1818471,
                "content": [
                    {
                        "username": "akksh_18",
                        "content": "i have given correct conditions but my code gives wrong output for testcase 2\\n"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "Heyy, \\nWhen I divide the number by 10 before the condition my solution take 3ms, but when I updated my code a little bit and divide the number by 10 right after the mod ZERO condition. It takes 0ms.\\n\\nWhat is the reason behind this?"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "[@PixDay](/PixDay) Thanks, it goes from 3ms to 0ms without any change in the code."
                    },
                    {
                        "username": "PixDay",
                        "content": "Try to submit multiple time the exact same code and sometimes you have some small differences, I don\\'t know exactly what is this comming from but I guess it\\'s due to server requests and latencies"
                    },
                    {
                        "username": "kennyhml",
                        "content": "For anyone struggling to solve this without 'cheating' by turning the number into a string, I wrote down a pretty detailed explanation in my [solution](https://leetcode.com/problems/count-the-digits-that-divide-a-number/solutions/3702272/important-to-understand-no-string-solution/). \n\nEDIT: If you only want a hint, and not the full solution, just read up to the first two bullet points of the approach!"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int x=num,count=0;\\n        if(num<10) return 1;\\n        else{\\n            while(x!=0){\\n                int s=x%10;\\n                if(num%s==0) count++;\\n                x/=10;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2520.%20Count%20the%20Digits%20That%20Divide%20a%20Number.cpp\\n\\nThis repository contains all LEETCODE SOLUTIONS IN C++\\nIf you find it useful please LEAVE A STAR "
                    },
                    {
                        "username": "prashantsleet",
                        "content": "Why am I getting error while incrementing ans? It says signed interger overflow.\\n\\n**************************************************************\\nruntime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:17:20\\n**************************************************************\\n\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int ans = 0;\\n        int n = num;\\n        while(n > 0){\\n            if(num % (n%10) == 0) \\n                ans++;\\n            n/10;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ENViN",
                        "content": "The update statement should be n/=10 and not n/10. The latter is causing an infinite loop and fortunately you get integer overflow before TLE :)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    int countDigits(int num) {\\n        int count=0;\\n        int temp=num;\\n        while(num>0){\\n            int digit=num%10;\\n            if(temp%digit==0){\\n                count++;\\n            }\\n            num=num/10;\\n        }\\n        return count;\\n        \\n    }"
                    },
                    {
                        "username": "ashokimandi",
                        "content": "how to read input"
                    },
                    {
                        "username": "PixDay",
                        "content": "What do you mean by : \"read the input\" do you talk about the parameters of the function ?"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Guys, There is no point converting num to string here. We can directly count by storing num in temp variable and taking remainder of the temp and dividing it by 10 each time. Hope it helps. Happy coding."
                    },
                    {
                        "username": "STDeeznutz",
                        "content": "I have a testcase where num = 54. Number of digits is 2. 54/2 = 27 no remainder. But it expects 0? What\\'s going on and what\\'s the reason behind this?"
                    },
                    {
                        "username": "PixDay",
                        "content": "What is asked is not the numbers of digit in the given number but if a digit of the number can divide it  in your example you will have 54/4 and 54/5\\n"
                    }
                ]
            },
            {
                "id": 1736406,
                "content": [
                    {
                        "username": "akksh_18",
                        "content": "i have given correct conditions but my code gives wrong output for testcase 2\\n"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "Heyy, \\nWhen I divide the number by 10 before the condition my solution take 3ms, but when I updated my code a little bit and divide the number by 10 right after the mod ZERO condition. It takes 0ms.\\n\\nWhat is the reason behind this?"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "[@PixDay](/PixDay) Thanks, it goes from 3ms to 0ms without any change in the code."
                    },
                    {
                        "username": "PixDay",
                        "content": "Try to submit multiple time the exact same code and sometimes you have some small differences, I don\\'t know exactly what is this comming from but I guess it\\'s due to server requests and latencies"
                    },
                    {
                        "username": "kennyhml",
                        "content": "For anyone struggling to solve this without 'cheating' by turning the number into a string, I wrote down a pretty detailed explanation in my [solution](https://leetcode.com/problems/count-the-digits-that-divide-a-number/solutions/3702272/important-to-understand-no-string-solution/). \n\nEDIT: If you only want a hint, and not the full solution, just read up to the first two bullet points of the approach!"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int x=num,count=0;\\n        if(num<10) return 1;\\n        else{\\n            while(x!=0){\\n                int s=x%10;\\n                if(num%s==0) count++;\\n                x/=10;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2520.%20Count%20the%20Digits%20That%20Divide%20a%20Number.cpp\\n\\nThis repository contains all LEETCODE SOLUTIONS IN C++\\nIf you find it useful please LEAVE A STAR "
                    },
                    {
                        "username": "prashantsleet",
                        "content": "Why am I getting error while incrementing ans? It says signed interger overflow.\\n\\n**************************************************************\\nruntime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:17:20\\n**************************************************************\\n\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int ans = 0;\\n        int n = num;\\n        while(n > 0){\\n            if(num % (n%10) == 0) \\n                ans++;\\n            n/10;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ENViN",
                        "content": "The update statement should be n/=10 and not n/10. The latter is causing an infinite loop and fortunately you get integer overflow before TLE :)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    int countDigits(int num) {\\n        int count=0;\\n        int temp=num;\\n        while(num>0){\\n            int digit=num%10;\\n            if(temp%digit==0){\\n                count++;\\n            }\\n            num=num/10;\\n        }\\n        return count;\\n        \\n    }"
                    },
                    {
                        "username": "ashokimandi",
                        "content": "how to read input"
                    },
                    {
                        "username": "PixDay",
                        "content": "What do you mean by : \"read the input\" do you talk about the parameters of the function ?"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Guys, There is no point converting num to string here. We can directly count by storing num in temp variable and taking remainder of the temp and dividing it by 10 each time. Hope it helps. Happy coding."
                    },
                    {
                        "username": "STDeeznutz",
                        "content": "I have a testcase where num = 54. Number of digits is 2. 54/2 = 27 no remainder. But it expects 0? What\\'s going on and what\\'s the reason behind this?"
                    },
                    {
                        "username": "PixDay",
                        "content": "What is asked is not the numbers of digit in the given number but if a digit of the number can divide it  in your example you will have 54/4 and 54/5\\n"
                    }
                ]
            },
            {
                "id": 1951011,
                "content": [
                    {
                        "username": "akksh_18",
                        "content": "i have given correct conditions but my code gives wrong output for testcase 2\\n"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "Heyy, \\nWhen I divide the number by 10 before the condition my solution take 3ms, but when I updated my code a little bit and divide the number by 10 right after the mod ZERO condition. It takes 0ms.\\n\\nWhat is the reason behind this?"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "[@PixDay](/PixDay) Thanks, it goes from 3ms to 0ms without any change in the code."
                    },
                    {
                        "username": "PixDay",
                        "content": "Try to submit multiple time the exact same code and sometimes you have some small differences, I don\\'t know exactly what is this comming from but I guess it\\'s due to server requests and latencies"
                    },
                    {
                        "username": "kennyhml",
                        "content": "For anyone struggling to solve this without 'cheating' by turning the number into a string, I wrote down a pretty detailed explanation in my [solution](https://leetcode.com/problems/count-the-digits-that-divide-a-number/solutions/3702272/important-to-understand-no-string-solution/). \n\nEDIT: If you only want a hint, and not the full solution, just read up to the first two bullet points of the approach!"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int x=num,count=0;\\n        if(num<10) return 1;\\n        else{\\n            while(x!=0){\\n                int s=x%10;\\n                if(num%s==0) count++;\\n                x/=10;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2520.%20Count%20the%20Digits%20That%20Divide%20a%20Number.cpp\\n\\nThis repository contains all LEETCODE SOLUTIONS IN C++\\nIf you find it useful please LEAVE A STAR "
                    },
                    {
                        "username": "prashantsleet",
                        "content": "Why am I getting error while incrementing ans? It says signed interger overflow.\\n\\n**************************************************************\\nruntime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:17:20\\n**************************************************************\\n\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int ans = 0;\\n        int n = num;\\n        while(n > 0){\\n            if(num % (n%10) == 0) \\n                ans++;\\n            n/10;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ENViN",
                        "content": "The update statement should be n/=10 and not n/10. The latter is causing an infinite loop and fortunately you get integer overflow before TLE :)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    int countDigits(int num) {\\n        int count=0;\\n        int temp=num;\\n        while(num>0){\\n            int digit=num%10;\\n            if(temp%digit==0){\\n                count++;\\n            }\\n            num=num/10;\\n        }\\n        return count;\\n        \\n    }"
                    },
                    {
                        "username": "ashokimandi",
                        "content": "how to read input"
                    },
                    {
                        "username": "PixDay",
                        "content": "What do you mean by : \"read the input\" do you talk about the parameters of the function ?"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Guys, There is no point converting num to string here. We can directly count by storing num in temp variable and taking remainder of the temp and dividing it by 10 each time. Hope it helps. Happy coding."
                    },
                    {
                        "username": "STDeeznutz",
                        "content": "I have a testcase where num = 54. Number of digits is 2. 54/2 = 27 no remainder. But it expects 0? What\\'s going on and what\\'s the reason behind this?"
                    },
                    {
                        "username": "PixDay",
                        "content": "What is asked is not the numbers of digit in the given number but if a digit of the number can divide it  in your example you will have 54/4 and 54/5\\n"
                    }
                ]
            },
            {
                "id": 1831198,
                "content": [
                    {
                        "username": "akksh_18",
                        "content": "i have given correct conditions but my code gives wrong output for testcase 2\\n"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "Heyy, \\nWhen I divide the number by 10 before the condition my solution take 3ms, but when I updated my code a little bit and divide the number by 10 right after the mod ZERO condition. It takes 0ms.\\n\\nWhat is the reason behind this?"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "[@PixDay](/PixDay) Thanks, it goes from 3ms to 0ms without any change in the code."
                    },
                    {
                        "username": "PixDay",
                        "content": "Try to submit multiple time the exact same code and sometimes you have some small differences, I don\\'t know exactly what is this comming from but I guess it\\'s due to server requests and latencies"
                    },
                    {
                        "username": "kennyhml",
                        "content": "For anyone struggling to solve this without 'cheating' by turning the number into a string, I wrote down a pretty detailed explanation in my [solution](https://leetcode.com/problems/count-the-digits-that-divide-a-number/solutions/3702272/important-to-understand-no-string-solution/). \n\nEDIT: If you only want a hint, and not the full solution, just read up to the first two bullet points of the approach!"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int x=num,count=0;\\n        if(num<10) return 1;\\n        else{\\n            while(x!=0){\\n                int s=x%10;\\n                if(num%s==0) count++;\\n                x/=10;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2520.%20Count%20the%20Digits%20That%20Divide%20a%20Number.cpp\\n\\nThis repository contains all LEETCODE SOLUTIONS IN C++\\nIf you find it useful please LEAVE A STAR "
                    },
                    {
                        "username": "prashantsleet",
                        "content": "Why am I getting error while incrementing ans? It says signed interger overflow.\\n\\n**************************************************************\\nruntime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:17:20\\n**************************************************************\\n\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int ans = 0;\\n        int n = num;\\n        while(n > 0){\\n            if(num % (n%10) == 0) \\n                ans++;\\n            n/10;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ENViN",
                        "content": "The update statement should be n/=10 and not n/10. The latter is causing an infinite loop and fortunately you get integer overflow before TLE :)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    int countDigits(int num) {\\n        int count=0;\\n        int temp=num;\\n        while(num>0){\\n            int digit=num%10;\\n            if(temp%digit==0){\\n                count++;\\n            }\\n            num=num/10;\\n        }\\n        return count;\\n        \\n    }"
                    },
                    {
                        "username": "ashokimandi",
                        "content": "how to read input"
                    },
                    {
                        "username": "PixDay",
                        "content": "What do you mean by : \"read the input\" do you talk about the parameters of the function ?"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Guys, There is no point converting num to string here. We can directly count by storing num in temp variable and taking remainder of the temp and dividing it by 10 each time. Hope it helps. Happy coding."
                    },
                    {
                        "username": "STDeeznutz",
                        "content": "I have a testcase where num = 54. Number of digits is 2. 54/2 = 27 no remainder. But it expects 0? What\\'s going on and what\\'s the reason behind this?"
                    },
                    {
                        "username": "PixDay",
                        "content": "What is asked is not the numbers of digit in the given number but if a digit of the number can divide it  in your example you will have 54/4 and 54/5\\n"
                    }
                ]
            },
            {
                "id": 1795348,
                "content": [
                    {
                        "username": "akksh_18",
                        "content": "i have given correct conditions but my code gives wrong output for testcase 2\\n"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "Heyy, \\nWhen I divide the number by 10 before the condition my solution take 3ms, but when I updated my code a little bit and divide the number by 10 right after the mod ZERO condition. It takes 0ms.\\n\\nWhat is the reason behind this?"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "[@PixDay](/PixDay) Thanks, it goes from 3ms to 0ms without any change in the code."
                    },
                    {
                        "username": "PixDay",
                        "content": "Try to submit multiple time the exact same code and sometimes you have some small differences, I don\\'t know exactly what is this comming from but I guess it\\'s due to server requests and latencies"
                    },
                    {
                        "username": "kennyhml",
                        "content": "For anyone struggling to solve this without 'cheating' by turning the number into a string, I wrote down a pretty detailed explanation in my [solution](https://leetcode.com/problems/count-the-digits-that-divide-a-number/solutions/3702272/important-to-understand-no-string-solution/). \n\nEDIT: If you only want a hint, and not the full solution, just read up to the first two bullet points of the approach!"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int x=num,count=0;\\n        if(num<10) return 1;\\n        else{\\n            while(x!=0){\\n                int s=x%10;\\n                if(num%s==0) count++;\\n                x/=10;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2520.%20Count%20the%20Digits%20That%20Divide%20a%20Number.cpp\\n\\nThis repository contains all LEETCODE SOLUTIONS IN C++\\nIf you find it useful please LEAVE A STAR "
                    },
                    {
                        "username": "prashantsleet",
                        "content": "Why am I getting error while incrementing ans? It says signed interger overflow.\\n\\n**************************************************************\\nruntime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:17:20\\n**************************************************************\\n\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int ans = 0;\\n        int n = num;\\n        while(n > 0){\\n            if(num % (n%10) == 0) \\n                ans++;\\n            n/10;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ENViN",
                        "content": "The update statement should be n/=10 and not n/10. The latter is causing an infinite loop and fortunately you get integer overflow before TLE :)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    int countDigits(int num) {\\n        int count=0;\\n        int temp=num;\\n        while(num>0){\\n            int digit=num%10;\\n            if(temp%digit==0){\\n                count++;\\n            }\\n            num=num/10;\\n        }\\n        return count;\\n        \\n    }"
                    },
                    {
                        "username": "ashokimandi",
                        "content": "how to read input"
                    },
                    {
                        "username": "PixDay",
                        "content": "What do you mean by : \"read the input\" do you talk about the parameters of the function ?"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Guys, There is no point converting num to string here. We can directly count by storing num in temp variable and taking remainder of the temp and dividing it by 10 each time. Hope it helps. Happy coding."
                    },
                    {
                        "username": "STDeeznutz",
                        "content": "I have a testcase where num = 54. Number of digits is 2. 54/2 = 27 no remainder. But it expects 0? What\\'s going on and what\\'s the reason behind this?"
                    },
                    {
                        "username": "PixDay",
                        "content": "What is asked is not the numbers of digit in the given number but if a digit of the number can divide it  in your example you will have 54/4 and 54/5\\n"
                    }
                ]
            },
            {
                "id": 1761689,
                "content": [
                    {
                        "username": "akksh_18",
                        "content": "i have given correct conditions but my code gives wrong output for testcase 2\\n"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "Heyy, \\nWhen I divide the number by 10 before the condition my solution take 3ms, but when I updated my code a little bit and divide the number by 10 right after the mod ZERO condition. It takes 0ms.\\n\\nWhat is the reason behind this?"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "[@PixDay](/PixDay) Thanks, it goes from 3ms to 0ms without any change in the code."
                    },
                    {
                        "username": "PixDay",
                        "content": "Try to submit multiple time the exact same code and sometimes you have some small differences, I don\\'t know exactly what is this comming from but I guess it\\'s due to server requests and latencies"
                    },
                    {
                        "username": "kennyhml",
                        "content": "For anyone struggling to solve this without 'cheating' by turning the number into a string, I wrote down a pretty detailed explanation in my [solution](https://leetcode.com/problems/count-the-digits-that-divide-a-number/solutions/3702272/important-to-understand-no-string-solution/). \n\nEDIT: If you only want a hint, and not the full solution, just read up to the first two bullet points of the approach!"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int x=num,count=0;\\n        if(num<10) return 1;\\n        else{\\n            while(x!=0){\\n                int s=x%10;\\n                if(num%s==0) count++;\\n                x/=10;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2520.%20Count%20the%20Digits%20That%20Divide%20a%20Number.cpp\\n\\nThis repository contains all LEETCODE SOLUTIONS IN C++\\nIf you find it useful please LEAVE A STAR "
                    },
                    {
                        "username": "prashantsleet",
                        "content": "Why am I getting error while incrementing ans? It says signed interger overflow.\\n\\n**************************************************************\\nruntime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:17:20\\n**************************************************************\\n\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int ans = 0;\\n        int n = num;\\n        while(n > 0){\\n            if(num % (n%10) == 0) \\n                ans++;\\n            n/10;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ENViN",
                        "content": "The update statement should be n/=10 and not n/10. The latter is causing an infinite loop and fortunately you get integer overflow before TLE :)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    int countDigits(int num) {\\n        int count=0;\\n        int temp=num;\\n        while(num>0){\\n            int digit=num%10;\\n            if(temp%digit==0){\\n                count++;\\n            }\\n            num=num/10;\\n        }\\n        return count;\\n        \\n    }"
                    },
                    {
                        "username": "ashokimandi",
                        "content": "how to read input"
                    },
                    {
                        "username": "PixDay",
                        "content": "What do you mean by : \"read the input\" do you talk about the parameters of the function ?"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Guys, There is no point converting num to string here. We can directly count by storing num in temp variable and taking remainder of the temp and dividing it by 10 each time. Hope it helps. Happy coding."
                    },
                    {
                        "username": "STDeeznutz",
                        "content": "I have a testcase where num = 54. Number of digits is 2. 54/2 = 27 no remainder. But it expects 0? What\\'s going on and what\\'s the reason behind this?"
                    },
                    {
                        "username": "PixDay",
                        "content": "What is asked is not the numbers of digit in the given number but if a digit of the number can divide it  in your example you will have 54/4 and 54/5\\n"
                    }
                ]
            },
            {
                "id": 1757658,
                "content": [
                    {
                        "username": "akksh_18",
                        "content": "i have given correct conditions but my code gives wrong output for testcase 2\\n"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "Heyy, \\nWhen I divide the number by 10 before the condition my solution take 3ms, but when I updated my code a little bit and divide the number by 10 right after the mod ZERO condition. It takes 0ms.\\n\\nWhat is the reason behind this?"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "[@PixDay](/PixDay) Thanks, it goes from 3ms to 0ms without any change in the code."
                    },
                    {
                        "username": "PixDay",
                        "content": "Try to submit multiple time the exact same code and sometimes you have some small differences, I don\\'t know exactly what is this comming from but I guess it\\'s due to server requests and latencies"
                    },
                    {
                        "username": "kennyhml",
                        "content": "For anyone struggling to solve this without 'cheating' by turning the number into a string, I wrote down a pretty detailed explanation in my [solution](https://leetcode.com/problems/count-the-digits-that-divide-a-number/solutions/3702272/important-to-understand-no-string-solution/). \n\nEDIT: If you only want a hint, and not the full solution, just read up to the first two bullet points of the approach!"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int x=num,count=0;\\n        if(num<10) return 1;\\n        else{\\n            while(x!=0){\\n                int s=x%10;\\n                if(num%s==0) count++;\\n                x/=10;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2520.%20Count%20the%20Digits%20That%20Divide%20a%20Number.cpp\\n\\nThis repository contains all LEETCODE SOLUTIONS IN C++\\nIf you find it useful please LEAVE A STAR "
                    },
                    {
                        "username": "prashantsleet",
                        "content": "Why am I getting error while incrementing ans? It says signed interger overflow.\\n\\n**************************************************************\\nruntime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:17:20\\n**************************************************************\\n\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int ans = 0;\\n        int n = num;\\n        while(n > 0){\\n            if(num % (n%10) == 0) \\n                ans++;\\n            n/10;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ENViN",
                        "content": "The update statement should be n/=10 and not n/10. The latter is causing an infinite loop and fortunately you get integer overflow before TLE :)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    int countDigits(int num) {\\n        int count=0;\\n        int temp=num;\\n        while(num>0){\\n            int digit=num%10;\\n            if(temp%digit==0){\\n                count++;\\n            }\\n            num=num/10;\\n        }\\n        return count;\\n        \\n    }"
                    },
                    {
                        "username": "ashokimandi",
                        "content": "how to read input"
                    },
                    {
                        "username": "PixDay",
                        "content": "What do you mean by : \"read the input\" do you talk about the parameters of the function ?"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Guys, There is no point converting num to string here. We can directly count by storing num in temp variable and taking remainder of the temp and dividing it by 10 each time. Hope it helps. Happy coding."
                    },
                    {
                        "username": "STDeeznutz",
                        "content": "I have a testcase where num = 54. Number of digits is 2. 54/2 = 27 no remainder. But it expects 0? What\\'s going on and what\\'s the reason behind this?"
                    },
                    {
                        "username": "PixDay",
                        "content": "What is asked is not the numbers of digit in the given number but if a digit of the number can divide it  in your example you will have 54/4 and 54/5\\n"
                    }
                ]
            },
            {
                "id": 1744579,
                "content": [
                    {
                        "username": "akksh_18",
                        "content": "i have given correct conditions but my code gives wrong output for testcase 2\\n"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "Heyy, \\nWhen I divide the number by 10 before the condition my solution take 3ms, but when I updated my code a little bit and divide the number by 10 right after the mod ZERO condition. It takes 0ms.\\n\\nWhat is the reason behind this?"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "[@PixDay](/PixDay) Thanks, it goes from 3ms to 0ms without any change in the code."
                    },
                    {
                        "username": "PixDay",
                        "content": "Try to submit multiple time the exact same code and sometimes you have some small differences, I don\\'t know exactly what is this comming from but I guess it\\'s due to server requests and latencies"
                    },
                    {
                        "username": "kennyhml",
                        "content": "For anyone struggling to solve this without 'cheating' by turning the number into a string, I wrote down a pretty detailed explanation in my [solution](https://leetcode.com/problems/count-the-digits-that-divide-a-number/solutions/3702272/important-to-understand-no-string-solution/). \n\nEDIT: If you only want a hint, and not the full solution, just read up to the first two bullet points of the approach!"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int x=num,count=0;\\n        if(num<10) return 1;\\n        else{\\n            while(x!=0){\\n                int s=x%10;\\n                if(num%s==0) count++;\\n                x/=10;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2520.%20Count%20the%20Digits%20That%20Divide%20a%20Number.cpp\\n\\nThis repository contains all LEETCODE SOLUTIONS IN C++\\nIf you find it useful please LEAVE A STAR "
                    },
                    {
                        "username": "prashantsleet",
                        "content": "Why am I getting error while incrementing ans? It says signed interger overflow.\\n\\n**************************************************************\\nruntime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:17:20\\n**************************************************************\\n\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int ans = 0;\\n        int n = num;\\n        while(n > 0){\\n            if(num % (n%10) == 0) \\n                ans++;\\n            n/10;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ENViN",
                        "content": "The update statement should be n/=10 and not n/10. The latter is causing an infinite loop and fortunately you get integer overflow before TLE :)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    int countDigits(int num) {\\n        int count=0;\\n        int temp=num;\\n        while(num>0){\\n            int digit=num%10;\\n            if(temp%digit==0){\\n                count++;\\n            }\\n            num=num/10;\\n        }\\n        return count;\\n        \\n    }"
                    },
                    {
                        "username": "ashokimandi",
                        "content": "how to read input"
                    },
                    {
                        "username": "PixDay",
                        "content": "What do you mean by : \"read the input\" do you talk about the parameters of the function ?"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Guys, There is no point converting num to string here. We can directly count by storing num in temp variable and taking remainder of the temp and dividing it by 10 each time. Hope it helps. Happy coding."
                    },
                    {
                        "username": "STDeeznutz",
                        "content": "I have a testcase where num = 54. Number of digits is 2. 54/2 = 27 no remainder. But it expects 0? What\\'s going on and what\\'s the reason behind this?"
                    },
                    {
                        "username": "PixDay",
                        "content": "What is asked is not the numbers of digit in the given number but if a digit of the number can divide it  in your example you will have 54/4 and 54/5\\n"
                    }
                ]
            },
            {
                "id": 1742861,
                "content": [
                    {
                        "username": "akksh_18",
                        "content": "i have given correct conditions but my code gives wrong output for testcase 2\\n"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "Heyy, \\nWhen I divide the number by 10 before the condition my solution take 3ms, but when I updated my code a little bit and divide the number by 10 right after the mod ZERO condition. It takes 0ms.\\n\\nWhat is the reason behind this?"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "[@PixDay](/PixDay) Thanks, it goes from 3ms to 0ms without any change in the code."
                    },
                    {
                        "username": "PixDay",
                        "content": "Try to submit multiple time the exact same code and sometimes you have some small differences, I don\\'t know exactly what is this comming from but I guess it\\'s due to server requests and latencies"
                    },
                    {
                        "username": "kennyhml",
                        "content": "For anyone struggling to solve this without 'cheating' by turning the number into a string, I wrote down a pretty detailed explanation in my [solution](https://leetcode.com/problems/count-the-digits-that-divide-a-number/solutions/3702272/important-to-understand-no-string-solution/). \n\nEDIT: If you only want a hint, and not the full solution, just read up to the first two bullet points of the approach!"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int x=num,count=0;\\n        if(num<10) return 1;\\n        else{\\n            while(x!=0){\\n                int s=x%10;\\n                if(num%s==0) count++;\\n                x/=10;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2520.%20Count%20the%20Digits%20That%20Divide%20a%20Number.cpp\\n\\nThis repository contains all LEETCODE SOLUTIONS IN C++\\nIf you find it useful please LEAVE A STAR "
                    },
                    {
                        "username": "prashantsleet",
                        "content": "Why am I getting error while incrementing ans? It says signed interger overflow.\\n\\n**************************************************************\\nruntime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:17:20\\n**************************************************************\\n\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int ans = 0;\\n        int n = num;\\n        while(n > 0){\\n            if(num % (n%10) == 0) \\n                ans++;\\n            n/10;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ENViN",
                        "content": "The update statement should be n/=10 and not n/10. The latter is causing an infinite loop and fortunately you get integer overflow before TLE :)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    int countDigits(int num) {\\n        int count=0;\\n        int temp=num;\\n        while(num>0){\\n            int digit=num%10;\\n            if(temp%digit==0){\\n                count++;\\n            }\\n            num=num/10;\\n        }\\n        return count;\\n        \\n    }"
                    },
                    {
                        "username": "ashokimandi",
                        "content": "how to read input"
                    },
                    {
                        "username": "PixDay",
                        "content": "What do you mean by : \"read the input\" do you talk about the parameters of the function ?"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Guys, There is no point converting num to string here. We can directly count by storing num in temp variable and taking remainder of the temp and dividing it by 10 each time. Hope it helps. Happy coding."
                    },
                    {
                        "username": "STDeeznutz",
                        "content": "I have a testcase where num = 54. Number of digits is 2. 54/2 = 27 no remainder. But it expects 0? What\\'s going on and what\\'s the reason behind this?"
                    },
                    {
                        "username": "PixDay",
                        "content": "What is asked is not the numbers of digit in the given number but if a digit of the number can divide it  in your example you will have 54/4 and 54/5\\n"
                    }
                ]
            },
            {
                "id": 1742030,
                "content": [
                    {
                        "username": "akksh_18",
                        "content": "i have given correct conditions but my code gives wrong output for testcase 2\\n"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "Heyy, \\nWhen I divide the number by 10 before the condition my solution take 3ms, but when I updated my code a little bit and divide the number by 10 right after the mod ZERO condition. It takes 0ms.\\n\\nWhat is the reason behind this?"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "[@PixDay](/PixDay) Thanks, it goes from 3ms to 0ms without any change in the code."
                    },
                    {
                        "username": "PixDay",
                        "content": "Try to submit multiple time the exact same code and sometimes you have some small differences, I don\\'t know exactly what is this comming from but I guess it\\'s due to server requests and latencies"
                    },
                    {
                        "username": "kennyhml",
                        "content": "For anyone struggling to solve this without 'cheating' by turning the number into a string, I wrote down a pretty detailed explanation in my [solution](https://leetcode.com/problems/count-the-digits-that-divide-a-number/solutions/3702272/important-to-understand-no-string-solution/). \n\nEDIT: If you only want a hint, and not the full solution, just read up to the first two bullet points of the approach!"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int x=num,count=0;\\n        if(num<10) return 1;\\n        else{\\n            while(x!=0){\\n                int s=x%10;\\n                if(num%s==0) count++;\\n                x/=10;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2520.%20Count%20the%20Digits%20That%20Divide%20a%20Number.cpp\\n\\nThis repository contains all LEETCODE SOLUTIONS IN C++\\nIf you find it useful please LEAVE A STAR "
                    },
                    {
                        "username": "prashantsleet",
                        "content": "Why am I getting error while incrementing ans? It says signed interger overflow.\\n\\n**************************************************************\\nruntime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:17:20\\n**************************************************************\\n\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int ans = 0;\\n        int n = num;\\n        while(n > 0){\\n            if(num % (n%10) == 0) \\n                ans++;\\n            n/10;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ENViN",
                        "content": "The update statement should be n/=10 and not n/10. The latter is causing an infinite loop and fortunately you get integer overflow before TLE :)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    int countDigits(int num) {\\n        int count=0;\\n        int temp=num;\\n        while(num>0){\\n            int digit=num%10;\\n            if(temp%digit==0){\\n                count++;\\n            }\\n            num=num/10;\\n        }\\n        return count;\\n        \\n    }"
                    },
                    {
                        "username": "ashokimandi",
                        "content": "how to read input"
                    },
                    {
                        "username": "PixDay",
                        "content": "What do you mean by : \"read the input\" do you talk about the parameters of the function ?"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Guys, There is no point converting num to string here. We can directly count by storing num in temp variable and taking remainder of the temp and dividing it by 10 each time. Hope it helps. Happy coding."
                    },
                    {
                        "username": "STDeeznutz",
                        "content": "I have a testcase where num = 54. Number of digits is 2. 54/2 = 27 no remainder. But it expects 0? What\\'s going on and what\\'s the reason behind this?"
                    },
                    {
                        "username": "PixDay",
                        "content": "What is asked is not the numbers of digit in the given number but if a digit of the number can divide it  in your example you will have 54/4 and 54/5\\n"
                    }
                ]
            },
            {
                "id": 1818471,
                "content": [
                    {
                        "username": "akksh_18",
                        "content": "i have given correct conditions but my code gives wrong output for testcase 2\\n"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "Heyy, \\nWhen I divide the number by 10 before the condition my solution take 3ms, but when I updated my code a little bit and divide the number by 10 right after the mod ZERO condition. It takes 0ms.\\n\\nWhat is the reason behind this?"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "[@PixDay](/PixDay) Thanks, it goes from 3ms to 0ms without any change in the code."
                    },
                    {
                        "username": "PixDay",
                        "content": "Try to submit multiple time the exact same code and sometimes you have some small differences, I don\\'t know exactly what is this comming from but I guess it\\'s due to server requests and latencies"
                    },
                    {
                        "username": "kennyhml",
                        "content": "For anyone struggling to solve this without 'cheating' by turning the number into a string, I wrote down a pretty detailed explanation in my [solution](https://leetcode.com/problems/count-the-digits-that-divide-a-number/solutions/3702272/important-to-understand-no-string-solution/). \n\nEDIT: If you only want a hint, and not the full solution, just read up to the first two bullet points of the approach!"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int x=num,count=0;\\n        if(num<10) return 1;\\n        else{\\n            while(x!=0){\\n                int s=x%10;\\n                if(num%s==0) count++;\\n                x/=10;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2520.%20Count%20the%20Digits%20That%20Divide%20a%20Number.cpp\\n\\nThis repository contains all LEETCODE SOLUTIONS IN C++\\nIf you find it useful please LEAVE A STAR "
                    },
                    {
                        "username": "prashantsleet",
                        "content": "Why am I getting error while incrementing ans? It says signed interger overflow.\\n\\n**************************************************************\\nruntime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:17:20\\n**************************************************************\\n\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int ans = 0;\\n        int n = num;\\n        while(n > 0){\\n            if(num % (n%10) == 0) \\n                ans++;\\n            n/10;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ENViN",
                        "content": "The update statement should be n/=10 and not n/10. The latter is causing an infinite loop and fortunately you get integer overflow before TLE :)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    int countDigits(int num) {\\n        int count=0;\\n        int temp=num;\\n        while(num>0){\\n            int digit=num%10;\\n            if(temp%digit==0){\\n                count++;\\n            }\\n            num=num/10;\\n        }\\n        return count;\\n        \\n    }"
                    },
                    {
                        "username": "ashokimandi",
                        "content": "how to read input"
                    },
                    {
                        "username": "PixDay",
                        "content": "What do you mean by : \"read the input\" do you talk about the parameters of the function ?"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Guys, There is no point converting num to string here. We can directly count by storing num in temp variable and taking remainder of the temp and dividing it by 10 each time. Hope it helps. Happy coding."
                    },
                    {
                        "username": "STDeeznutz",
                        "content": "I have a testcase where num = 54. Number of digits is 2. 54/2 = 27 no remainder. But it expects 0? What\\'s going on and what\\'s the reason behind this?"
                    },
                    {
                        "username": "PixDay",
                        "content": "What is asked is not the numbers of digit in the given number but if a digit of the number can divide it  in your example you will have 54/4 and 54/5\\n"
                    }
                ]
            },
            {
                "id": 1736406,
                "content": [
                    {
                        "username": "akksh_18",
                        "content": "i have given correct conditions but my code gives wrong output for testcase 2\\n"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "Heyy, \\nWhen I divide the number by 10 before the condition my solution take 3ms, but when I updated my code a little bit and divide the number by 10 right after the mod ZERO condition. It takes 0ms.\\n\\nWhat is the reason behind this?"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "[@PixDay](/PixDay) Thanks, it goes from 3ms to 0ms without any change in the code."
                    },
                    {
                        "username": "PixDay",
                        "content": "Try to submit multiple time the exact same code and sometimes you have some small differences, I don\\'t know exactly what is this comming from but I guess it\\'s due to server requests and latencies"
                    },
                    {
                        "username": "kennyhml",
                        "content": "For anyone struggling to solve this without 'cheating' by turning the number into a string, I wrote down a pretty detailed explanation in my [solution](https://leetcode.com/problems/count-the-digits-that-divide-a-number/solutions/3702272/important-to-understand-no-string-solution/). \n\nEDIT: If you only want a hint, and not the full solution, just read up to the first two bullet points of the approach!"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int x=num,count=0;\\n        if(num<10) return 1;\\n        else{\\n            while(x!=0){\\n                int s=x%10;\\n                if(num%s==0) count++;\\n                x/=10;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2520.%20Count%20the%20Digits%20That%20Divide%20a%20Number.cpp\\n\\nThis repository contains all LEETCODE SOLUTIONS IN C++\\nIf you find it useful please LEAVE A STAR "
                    },
                    {
                        "username": "prashantsleet",
                        "content": "Why am I getting error while incrementing ans? It says signed interger overflow.\\n\\n**************************************************************\\nruntime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:17:20\\n**************************************************************\\n\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int ans = 0;\\n        int n = num;\\n        while(n > 0){\\n            if(num % (n%10) == 0) \\n                ans++;\\n            n/10;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ENViN",
                        "content": "The update statement should be n/=10 and not n/10. The latter is causing an infinite loop and fortunately you get integer overflow before TLE :)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    int countDigits(int num) {\\n        int count=0;\\n        int temp=num;\\n        while(num>0){\\n            int digit=num%10;\\n            if(temp%digit==0){\\n                count++;\\n            }\\n            num=num/10;\\n        }\\n        return count;\\n        \\n    }"
                    },
                    {
                        "username": "ashokimandi",
                        "content": "how to read input"
                    },
                    {
                        "username": "PixDay",
                        "content": "What do you mean by : \"read the input\" do you talk about the parameters of the function ?"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Guys, There is no point converting num to string here. We can directly count by storing num in temp variable and taking remainder of the temp and dividing it by 10 each time. Hope it helps. Happy coding."
                    },
                    {
                        "username": "STDeeznutz",
                        "content": "I have a testcase where num = 54. Number of digits is 2. 54/2 = 27 no remainder. But it expects 0? What\\'s going on and what\\'s the reason behind this?"
                    },
                    {
                        "username": "PixDay",
                        "content": "What is asked is not the numbers of digit in the given number but if a digit of the number can divide it  in your example you will have 54/4 and 54/5\\n"
                    }
                ]
            },
            {
                "id": 1951011,
                "content": [
                    {
                        "username": "akksh_18",
                        "content": "i have given correct conditions but my code gives wrong output for testcase 2\\n"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "Heyy, \\nWhen I divide the number by 10 before the condition my solution take 3ms, but when I updated my code a little bit and divide the number by 10 right after the mod ZERO condition. It takes 0ms.\\n\\nWhat is the reason behind this?"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "[@PixDay](/PixDay) Thanks, it goes from 3ms to 0ms without any change in the code."
                    },
                    {
                        "username": "PixDay",
                        "content": "Try to submit multiple time the exact same code and sometimes you have some small differences, I don\\'t know exactly what is this comming from but I guess it\\'s due to server requests and latencies"
                    },
                    {
                        "username": "kennyhml",
                        "content": "For anyone struggling to solve this without 'cheating' by turning the number into a string, I wrote down a pretty detailed explanation in my [solution](https://leetcode.com/problems/count-the-digits-that-divide-a-number/solutions/3702272/important-to-understand-no-string-solution/). \n\nEDIT: If you only want a hint, and not the full solution, just read up to the first two bullet points of the approach!"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int x=num,count=0;\\n        if(num<10) return 1;\\n        else{\\n            while(x!=0){\\n                int s=x%10;\\n                if(num%s==0) count++;\\n                x/=10;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2520.%20Count%20the%20Digits%20That%20Divide%20a%20Number.cpp\\n\\nThis repository contains all LEETCODE SOLUTIONS IN C++\\nIf you find it useful please LEAVE A STAR "
                    },
                    {
                        "username": "prashantsleet",
                        "content": "Why am I getting error while incrementing ans? It says signed interger overflow.\\n\\n**************************************************************\\nruntime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:17:20\\n**************************************************************\\n\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int ans = 0;\\n        int n = num;\\n        while(n > 0){\\n            if(num % (n%10) == 0) \\n                ans++;\\n            n/10;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ENViN",
                        "content": "The update statement should be n/=10 and not n/10. The latter is causing an infinite loop and fortunately you get integer overflow before TLE :)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    int countDigits(int num) {\\n        int count=0;\\n        int temp=num;\\n        while(num>0){\\n            int digit=num%10;\\n            if(temp%digit==0){\\n                count++;\\n            }\\n            num=num/10;\\n        }\\n        return count;\\n        \\n    }"
                    },
                    {
                        "username": "ashokimandi",
                        "content": "how to read input"
                    },
                    {
                        "username": "PixDay",
                        "content": "What do you mean by : \"read the input\" do you talk about the parameters of the function ?"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Guys, There is no point converting num to string here. We can directly count by storing num in temp variable and taking remainder of the temp and dividing it by 10 each time. Hope it helps. Happy coding."
                    },
                    {
                        "username": "STDeeznutz",
                        "content": "I have a testcase where num = 54. Number of digits is 2. 54/2 = 27 no remainder. But it expects 0? What\\'s going on and what\\'s the reason behind this?"
                    },
                    {
                        "username": "PixDay",
                        "content": "What is asked is not the numbers of digit in the given number but if a digit of the number can divide it  in your example you will have 54/4 and 54/5\\n"
                    }
                ]
            },
            {
                "id": 1831198,
                "content": [
                    {
                        "username": "akksh_18",
                        "content": "i have given correct conditions but my code gives wrong output for testcase 2\\n"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "Heyy, \\nWhen I divide the number by 10 before the condition my solution take 3ms, but when I updated my code a little bit and divide the number by 10 right after the mod ZERO condition. It takes 0ms.\\n\\nWhat is the reason behind this?"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "[@PixDay](/PixDay) Thanks, it goes from 3ms to 0ms without any change in the code."
                    },
                    {
                        "username": "PixDay",
                        "content": "Try to submit multiple time the exact same code and sometimes you have some small differences, I don\\'t know exactly what is this comming from but I guess it\\'s due to server requests and latencies"
                    },
                    {
                        "username": "kennyhml",
                        "content": "For anyone struggling to solve this without 'cheating' by turning the number into a string, I wrote down a pretty detailed explanation in my [solution](https://leetcode.com/problems/count-the-digits-that-divide-a-number/solutions/3702272/important-to-understand-no-string-solution/). \n\nEDIT: If you only want a hint, and not the full solution, just read up to the first two bullet points of the approach!"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int x=num,count=0;\\n        if(num<10) return 1;\\n        else{\\n            while(x!=0){\\n                int s=x%10;\\n                if(num%s==0) count++;\\n                x/=10;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2520.%20Count%20the%20Digits%20That%20Divide%20a%20Number.cpp\\n\\nThis repository contains all LEETCODE SOLUTIONS IN C++\\nIf you find it useful please LEAVE A STAR "
                    },
                    {
                        "username": "prashantsleet",
                        "content": "Why am I getting error while incrementing ans? It says signed interger overflow.\\n\\n**************************************************************\\nruntime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:17:20\\n**************************************************************\\n\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int ans = 0;\\n        int n = num;\\n        while(n > 0){\\n            if(num % (n%10) == 0) \\n                ans++;\\n            n/10;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ENViN",
                        "content": "The update statement should be n/=10 and not n/10. The latter is causing an infinite loop and fortunately you get integer overflow before TLE :)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    int countDigits(int num) {\\n        int count=0;\\n        int temp=num;\\n        while(num>0){\\n            int digit=num%10;\\n            if(temp%digit==0){\\n                count++;\\n            }\\n            num=num/10;\\n        }\\n        return count;\\n        \\n    }"
                    },
                    {
                        "username": "ashokimandi",
                        "content": "how to read input"
                    },
                    {
                        "username": "PixDay",
                        "content": "What do you mean by : \"read the input\" do you talk about the parameters of the function ?"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Guys, There is no point converting num to string here. We can directly count by storing num in temp variable and taking remainder of the temp and dividing it by 10 each time. Hope it helps. Happy coding."
                    },
                    {
                        "username": "STDeeznutz",
                        "content": "I have a testcase where num = 54. Number of digits is 2. 54/2 = 27 no remainder. But it expects 0? What\\'s going on and what\\'s the reason behind this?"
                    },
                    {
                        "username": "PixDay",
                        "content": "What is asked is not the numbers of digit in the given number but if a digit of the number can divide it  in your example you will have 54/4 and 54/5\\n"
                    }
                ]
            },
            {
                "id": 1795348,
                "content": [
                    {
                        "username": "akksh_18",
                        "content": "i have given correct conditions but my code gives wrong output for testcase 2\\n"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "Heyy, \\nWhen I divide the number by 10 before the condition my solution take 3ms, but when I updated my code a little bit and divide the number by 10 right after the mod ZERO condition. It takes 0ms.\\n\\nWhat is the reason behind this?"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "[@PixDay](/PixDay) Thanks, it goes from 3ms to 0ms without any change in the code."
                    },
                    {
                        "username": "PixDay",
                        "content": "Try to submit multiple time the exact same code and sometimes you have some small differences, I don\\'t know exactly what is this comming from but I guess it\\'s due to server requests and latencies"
                    },
                    {
                        "username": "kennyhml",
                        "content": "For anyone struggling to solve this without 'cheating' by turning the number into a string, I wrote down a pretty detailed explanation in my [solution](https://leetcode.com/problems/count-the-digits-that-divide-a-number/solutions/3702272/important-to-understand-no-string-solution/). \n\nEDIT: If you only want a hint, and not the full solution, just read up to the first two bullet points of the approach!"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int x=num,count=0;\\n        if(num<10) return 1;\\n        else{\\n            while(x!=0){\\n                int s=x%10;\\n                if(num%s==0) count++;\\n                x/=10;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2520.%20Count%20the%20Digits%20That%20Divide%20a%20Number.cpp\\n\\nThis repository contains all LEETCODE SOLUTIONS IN C++\\nIf you find it useful please LEAVE A STAR "
                    },
                    {
                        "username": "prashantsleet",
                        "content": "Why am I getting error while incrementing ans? It says signed interger overflow.\\n\\n**************************************************************\\nruntime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:17:20\\n**************************************************************\\n\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int ans = 0;\\n        int n = num;\\n        while(n > 0){\\n            if(num % (n%10) == 0) \\n                ans++;\\n            n/10;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ENViN",
                        "content": "The update statement should be n/=10 and not n/10. The latter is causing an infinite loop and fortunately you get integer overflow before TLE :)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    int countDigits(int num) {\\n        int count=0;\\n        int temp=num;\\n        while(num>0){\\n            int digit=num%10;\\n            if(temp%digit==0){\\n                count++;\\n            }\\n            num=num/10;\\n        }\\n        return count;\\n        \\n    }"
                    },
                    {
                        "username": "ashokimandi",
                        "content": "how to read input"
                    },
                    {
                        "username": "PixDay",
                        "content": "What do you mean by : \"read the input\" do you talk about the parameters of the function ?"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Guys, There is no point converting num to string here. We can directly count by storing num in temp variable and taking remainder of the temp and dividing it by 10 each time. Hope it helps. Happy coding."
                    },
                    {
                        "username": "STDeeznutz",
                        "content": "I have a testcase where num = 54. Number of digits is 2. 54/2 = 27 no remainder. But it expects 0? What\\'s going on and what\\'s the reason behind this?"
                    },
                    {
                        "username": "PixDay",
                        "content": "What is asked is not the numbers of digit in the given number but if a digit of the number can divide it  in your example you will have 54/4 and 54/5\\n"
                    }
                ]
            },
            {
                "id": 1761689,
                "content": [
                    {
                        "username": "akksh_18",
                        "content": "i have given correct conditions but my code gives wrong output for testcase 2\\n"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "Heyy, \\nWhen I divide the number by 10 before the condition my solution take 3ms, but when I updated my code a little bit and divide the number by 10 right after the mod ZERO condition. It takes 0ms.\\n\\nWhat is the reason behind this?"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "[@PixDay](/PixDay) Thanks, it goes from 3ms to 0ms without any change in the code."
                    },
                    {
                        "username": "PixDay",
                        "content": "Try to submit multiple time the exact same code and sometimes you have some small differences, I don\\'t know exactly what is this comming from but I guess it\\'s due to server requests and latencies"
                    },
                    {
                        "username": "kennyhml",
                        "content": "For anyone struggling to solve this without 'cheating' by turning the number into a string, I wrote down a pretty detailed explanation in my [solution](https://leetcode.com/problems/count-the-digits-that-divide-a-number/solutions/3702272/important-to-understand-no-string-solution/). \n\nEDIT: If you only want a hint, and not the full solution, just read up to the first two bullet points of the approach!"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int x=num,count=0;\\n        if(num<10) return 1;\\n        else{\\n            while(x!=0){\\n                int s=x%10;\\n                if(num%s==0) count++;\\n                x/=10;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2520.%20Count%20the%20Digits%20That%20Divide%20a%20Number.cpp\\n\\nThis repository contains all LEETCODE SOLUTIONS IN C++\\nIf you find it useful please LEAVE A STAR "
                    },
                    {
                        "username": "prashantsleet",
                        "content": "Why am I getting error while incrementing ans? It says signed interger overflow.\\n\\n**************************************************************\\nruntime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:17:20\\n**************************************************************\\n\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int ans = 0;\\n        int n = num;\\n        while(n > 0){\\n            if(num % (n%10) == 0) \\n                ans++;\\n            n/10;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ENViN",
                        "content": "The update statement should be n/=10 and not n/10. The latter is causing an infinite loop and fortunately you get integer overflow before TLE :)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    int countDigits(int num) {\\n        int count=0;\\n        int temp=num;\\n        while(num>0){\\n            int digit=num%10;\\n            if(temp%digit==0){\\n                count++;\\n            }\\n            num=num/10;\\n        }\\n        return count;\\n        \\n    }"
                    },
                    {
                        "username": "ashokimandi",
                        "content": "how to read input"
                    },
                    {
                        "username": "PixDay",
                        "content": "What do you mean by : \"read the input\" do you talk about the parameters of the function ?"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Guys, There is no point converting num to string here. We can directly count by storing num in temp variable and taking remainder of the temp and dividing it by 10 each time. Hope it helps. Happy coding."
                    },
                    {
                        "username": "STDeeznutz",
                        "content": "I have a testcase where num = 54. Number of digits is 2. 54/2 = 27 no remainder. But it expects 0? What\\'s going on and what\\'s the reason behind this?"
                    },
                    {
                        "username": "PixDay",
                        "content": "What is asked is not the numbers of digit in the given number but if a digit of the number can divide it  in your example you will have 54/4 and 54/5\\n"
                    }
                ]
            },
            {
                "id": 1757658,
                "content": [
                    {
                        "username": "akksh_18",
                        "content": "i have given correct conditions but my code gives wrong output for testcase 2\\n"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "Heyy, \\nWhen I divide the number by 10 before the condition my solution take 3ms, but when I updated my code a little bit and divide the number by 10 right after the mod ZERO condition. It takes 0ms.\\n\\nWhat is the reason behind this?"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "[@PixDay](/PixDay) Thanks, it goes from 3ms to 0ms without any change in the code."
                    },
                    {
                        "username": "PixDay",
                        "content": "Try to submit multiple time the exact same code and sometimes you have some small differences, I don\\'t know exactly what is this comming from but I guess it\\'s due to server requests and latencies"
                    },
                    {
                        "username": "kennyhml",
                        "content": "For anyone struggling to solve this without 'cheating' by turning the number into a string, I wrote down a pretty detailed explanation in my [solution](https://leetcode.com/problems/count-the-digits-that-divide-a-number/solutions/3702272/important-to-understand-no-string-solution/). \n\nEDIT: If you only want a hint, and not the full solution, just read up to the first two bullet points of the approach!"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int x=num,count=0;\\n        if(num<10) return 1;\\n        else{\\n            while(x!=0){\\n                int s=x%10;\\n                if(num%s==0) count++;\\n                x/=10;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2520.%20Count%20the%20Digits%20That%20Divide%20a%20Number.cpp\\n\\nThis repository contains all LEETCODE SOLUTIONS IN C++\\nIf you find it useful please LEAVE A STAR "
                    },
                    {
                        "username": "prashantsleet",
                        "content": "Why am I getting error while incrementing ans? It says signed interger overflow.\\n\\n**************************************************************\\nruntime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:17:20\\n**************************************************************\\n\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int ans = 0;\\n        int n = num;\\n        while(n > 0){\\n            if(num % (n%10) == 0) \\n                ans++;\\n            n/10;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ENViN",
                        "content": "The update statement should be n/=10 and not n/10. The latter is causing an infinite loop and fortunately you get integer overflow before TLE :)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    int countDigits(int num) {\\n        int count=0;\\n        int temp=num;\\n        while(num>0){\\n            int digit=num%10;\\n            if(temp%digit==0){\\n                count++;\\n            }\\n            num=num/10;\\n        }\\n        return count;\\n        \\n    }"
                    },
                    {
                        "username": "ashokimandi",
                        "content": "how to read input"
                    },
                    {
                        "username": "PixDay",
                        "content": "What do you mean by : \"read the input\" do you talk about the parameters of the function ?"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Guys, There is no point converting num to string here. We can directly count by storing num in temp variable and taking remainder of the temp and dividing it by 10 each time. Hope it helps. Happy coding."
                    },
                    {
                        "username": "STDeeznutz",
                        "content": "I have a testcase where num = 54. Number of digits is 2. 54/2 = 27 no remainder. But it expects 0? What\\'s going on and what\\'s the reason behind this?"
                    },
                    {
                        "username": "PixDay",
                        "content": "What is asked is not the numbers of digit in the given number but if a digit of the number can divide it  in your example you will have 54/4 and 54/5\\n"
                    }
                ]
            },
            {
                "id": 1744579,
                "content": [
                    {
                        "username": "akksh_18",
                        "content": "i have given correct conditions but my code gives wrong output for testcase 2\\n"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "Heyy, \\nWhen I divide the number by 10 before the condition my solution take 3ms, but when I updated my code a little bit and divide the number by 10 right after the mod ZERO condition. It takes 0ms.\\n\\nWhat is the reason behind this?"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "[@PixDay](/PixDay) Thanks, it goes from 3ms to 0ms without any change in the code."
                    },
                    {
                        "username": "PixDay",
                        "content": "Try to submit multiple time the exact same code and sometimes you have some small differences, I don\\'t know exactly what is this comming from but I guess it\\'s due to server requests and latencies"
                    },
                    {
                        "username": "kennyhml",
                        "content": "For anyone struggling to solve this without 'cheating' by turning the number into a string, I wrote down a pretty detailed explanation in my [solution](https://leetcode.com/problems/count-the-digits-that-divide-a-number/solutions/3702272/important-to-understand-no-string-solution/). \n\nEDIT: If you only want a hint, and not the full solution, just read up to the first two bullet points of the approach!"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int x=num,count=0;\\n        if(num<10) return 1;\\n        else{\\n            while(x!=0){\\n                int s=x%10;\\n                if(num%s==0) count++;\\n                x/=10;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2520.%20Count%20the%20Digits%20That%20Divide%20a%20Number.cpp\\n\\nThis repository contains all LEETCODE SOLUTIONS IN C++\\nIf you find it useful please LEAVE A STAR "
                    },
                    {
                        "username": "prashantsleet",
                        "content": "Why am I getting error while incrementing ans? It says signed interger overflow.\\n\\n**************************************************************\\nruntime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:17:20\\n**************************************************************\\n\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int ans = 0;\\n        int n = num;\\n        while(n > 0){\\n            if(num % (n%10) == 0) \\n                ans++;\\n            n/10;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ENViN",
                        "content": "The update statement should be n/=10 and not n/10. The latter is causing an infinite loop and fortunately you get integer overflow before TLE :)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    int countDigits(int num) {\\n        int count=0;\\n        int temp=num;\\n        while(num>0){\\n            int digit=num%10;\\n            if(temp%digit==0){\\n                count++;\\n            }\\n            num=num/10;\\n        }\\n        return count;\\n        \\n    }"
                    },
                    {
                        "username": "ashokimandi",
                        "content": "how to read input"
                    },
                    {
                        "username": "PixDay",
                        "content": "What do you mean by : \"read the input\" do you talk about the parameters of the function ?"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Guys, There is no point converting num to string here. We can directly count by storing num in temp variable and taking remainder of the temp and dividing it by 10 each time. Hope it helps. Happy coding."
                    },
                    {
                        "username": "STDeeznutz",
                        "content": "I have a testcase where num = 54. Number of digits is 2. 54/2 = 27 no remainder. But it expects 0? What\\'s going on and what\\'s the reason behind this?"
                    },
                    {
                        "username": "PixDay",
                        "content": "What is asked is not the numbers of digit in the given number but if a digit of the number can divide it  in your example you will have 54/4 and 54/5\\n"
                    }
                ]
            },
            {
                "id": 1742861,
                "content": [
                    {
                        "username": "akksh_18",
                        "content": "i have given correct conditions but my code gives wrong output for testcase 2\\n"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "Heyy, \\nWhen I divide the number by 10 before the condition my solution take 3ms, but when I updated my code a little bit and divide the number by 10 right after the mod ZERO condition. It takes 0ms.\\n\\nWhat is the reason behind this?"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "[@PixDay](/PixDay) Thanks, it goes from 3ms to 0ms without any change in the code."
                    },
                    {
                        "username": "PixDay",
                        "content": "Try to submit multiple time the exact same code and sometimes you have some small differences, I don\\'t know exactly what is this comming from but I guess it\\'s due to server requests and latencies"
                    },
                    {
                        "username": "kennyhml",
                        "content": "For anyone struggling to solve this without 'cheating' by turning the number into a string, I wrote down a pretty detailed explanation in my [solution](https://leetcode.com/problems/count-the-digits-that-divide-a-number/solutions/3702272/important-to-understand-no-string-solution/). \n\nEDIT: If you only want a hint, and not the full solution, just read up to the first two bullet points of the approach!"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int x=num,count=0;\\n        if(num<10) return 1;\\n        else{\\n            while(x!=0){\\n                int s=x%10;\\n                if(num%s==0) count++;\\n                x/=10;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2520.%20Count%20the%20Digits%20That%20Divide%20a%20Number.cpp\\n\\nThis repository contains all LEETCODE SOLUTIONS IN C++\\nIf you find it useful please LEAVE A STAR "
                    },
                    {
                        "username": "prashantsleet",
                        "content": "Why am I getting error while incrementing ans? It says signed interger overflow.\\n\\n**************************************************************\\nruntime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:17:20\\n**************************************************************\\n\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int ans = 0;\\n        int n = num;\\n        while(n > 0){\\n            if(num % (n%10) == 0) \\n                ans++;\\n            n/10;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ENViN",
                        "content": "The update statement should be n/=10 and not n/10. The latter is causing an infinite loop and fortunately you get integer overflow before TLE :)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    int countDigits(int num) {\\n        int count=0;\\n        int temp=num;\\n        while(num>0){\\n            int digit=num%10;\\n            if(temp%digit==0){\\n                count++;\\n            }\\n            num=num/10;\\n        }\\n        return count;\\n        \\n    }"
                    },
                    {
                        "username": "ashokimandi",
                        "content": "how to read input"
                    },
                    {
                        "username": "PixDay",
                        "content": "What do you mean by : \"read the input\" do you talk about the parameters of the function ?"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Guys, There is no point converting num to string here. We can directly count by storing num in temp variable and taking remainder of the temp and dividing it by 10 each time. Hope it helps. Happy coding."
                    },
                    {
                        "username": "STDeeznutz",
                        "content": "I have a testcase where num = 54. Number of digits is 2. 54/2 = 27 no remainder. But it expects 0? What\\'s going on and what\\'s the reason behind this?"
                    },
                    {
                        "username": "PixDay",
                        "content": "What is asked is not the numbers of digit in the given number but if a digit of the number can divide it  in your example you will have 54/4 and 54/5\\n"
                    }
                ]
            },
            {
                "id": 1742030,
                "content": [
                    {
                        "username": "akksh_18",
                        "content": "i have given correct conditions but my code gives wrong output for testcase 2\\n"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "Heyy, \\nWhen I divide the number by 10 before the condition my solution take 3ms, but when I updated my code a little bit and divide the number by 10 right after the mod ZERO condition. It takes 0ms.\\n\\nWhat is the reason behind this?"
                    },
                    {
                        "username": "HassanFCS",
                        "content": "[@PixDay](/PixDay) Thanks, it goes from 3ms to 0ms without any change in the code."
                    },
                    {
                        "username": "PixDay",
                        "content": "Try to submit multiple time the exact same code and sometimes you have some small differences, I don\\'t know exactly what is this comming from but I guess it\\'s due to server requests and latencies"
                    },
                    {
                        "username": "kennyhml",
                        "content": "For anyone struggling to solve this without 'cheating' by turning the number into a string, I wrote down a pretty detailed explanation in my [solution](https://leetcode.com/problems/count-the-digits-that-divide-a-number/solutions/3702272/important-to-understand-no-string-solution/). \n\nEDIT: If you only want a hint, and not the full solution, just read up to the first two bullet points of the approach!"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int x=num,count=0;\\n        if(num<10) return 1;\\n        else{\\n            while(x!=0){\\n                int s=x%10;\\n                if(num%s==0) count++;\\n                x/=10;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2520.%20Count%20the%20Digits%20That%20Divide%20a%20Number.cpp\\n\\nThis repository contains all LEETCODE SOLUTIONS IN C++\\nIf you find it useful please LEAVE A STAR "
                    },
                    {
                        "username": "prashantsleet",
                        "content": "Why am I getting error while incrementing ans? It says signed interger overflow.\\n\\n**************************************************************\\nruntime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:17:20\\n**************************************************************\\n\\nclass Solution {\\npublic:\\n    int countDigits(int num) {\\n        int ans = 0;\\n        int n = num;\\n        while(n > 0){\\n            if(num % (n%10) == 0) \\n                ans++;\\n            n/10;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ENViN",
                        "content": "The update statement should be n/=10 and not n/10. The latter is causing an infinite loop and fortunately you get integer overflow before TLE :)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    int countDigits(int num) {\\n        int count=0;\\n        int temp=num;\\n        while(num>0){\\n            int digit=num%10;\\n            if(temp%digit==0){\\n                count++;\\n            }\\n            num=num/10;\\n        }\\n        return count;\\n        \\n    }"
                    },
                    {
                        "username": "ashokimandi",
                        "content": "how to read input"
                    },
                    {
                        "username": "PixDay",
                        "content": "What do you mean by : \"read the input\" do you talk about the parameters of the function ?"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Guys, There is no point converting num to string here. We can directly count by storing num in temp variable and taking remainder of the temp and dividing it by 10 each time. Hope it helps. Happy coding."
                    },
                    {
                        "username": "STDeeznutz",
                        "content": "I have a testcase where num = 54. Number of digits is 2. 54/2 = 27 no remainder. But it expects 0? What\\'s going on and what\\'s the reason behind this?"
                    },
                    {
                        "username": "PixDay",
                        "content": "What is asked is not the numbers of digit in the given number but if a digit of the number can divide it  in your example you will have 54/4 and 54/5\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Distinct Prime Factors of Product of Array",
        "question_content": "<p>Given an array of positive integers <code>nums</code>, return <em>the number of <strong>distinct prime factors</strong> in the product of the elements of</em> <code>nums</code>.</p>\n\n<p><strong>Note</strong> that:</p>\n\n<ul>\n\t<li>A number greater than <code>1</code> is called <strong>prime</strong> if it is divisible by only <code>1</code> and itself.</li>\n\t<li>An integer <code>val1</code> is a factor of another integer <code>val2</code> if <code>val2 / val1</code> is an integer.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,4,3,7,10,6]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong>\nThe product of all the elements in nums is: 2 * 4 * 3 * 7 * 10 * 6 = 10080 = 2<sup>5</sup> * 3<sup>2</sup> * 5 * 7.\nThere are 4 distinct prime factors so we return 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,4,8,16]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong>\nThe product of all the elements in nums is: 2 * 4 * 8 * 16 = 1024 = 2<sup>10</sup>.\nThere is 1 distinct prime factor so we return 1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>2 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 2977286,
                "title": "large-prime-optimization",
                "content": "Multiplication won\\'t produce any new primes, so we can just check each number individually. \\n    \\nWe only need to know primes up to sqrt(1000).\\n    \\nIf, after dividing `n` by all these primes, `n` is still greater than 1, then what remains is a large prime.\\n\\n> This is because it is sufficient to try divisors up to sqrt(n) to check if a number is a prime.\\n\\nExample 1: `792` (`2 * 2 * 2 * 3 * 3 * 11`). Distinct primes are `2`, `3`, and `11`, and `n` is reduced to `1`.\\nExample 2: `723` (`3 * 241`). After checking primes `[2 ... 31]`, `n` is reduced to `241`, and therefore `241` is a large prime.\\n\\n**Complexity Analysis**\\n- Time: O(n \\u03C0(sqrt m)), where m is the largest value, and \\u03C0 is the \\u201Cprime counting function.\\u201D\\n- Memory: O(\\u03C0(m)). We store all primes less than m in a hashset.\\n\\n**C++**\\n```cpp\\nint ps[11] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31};\\nint distinctPrimeFactors(vector<int>& nums) {\\n    unordered_set<int> primes;\\n    for (int n : nums) {\\n        for (int p : ps)\\n            if (n % p == 0) {\\n                primes.insert(p);\\n                while (n % p == 0)\\n                    n /= p;\\n            }\\n        if (n != 1)\\n            primes.insert(n); // large prime.\\n    }\\n    return primes.size();\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint ps[11] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31};\\nint distinctPrimeFactors(vector<int>& nums) {\\n    unordered_set<int> primes;\\n    for (int n : nums) {\\n        for (int p : ps)\\n            if (n % p == 0) {\\n                primes.insert(p);\\n                while (n % p == 0)\\n                    n /= p;\\n            }\\n        if (n != 1)\\n            primes.insert(n); // large prime.\\n    }\\n    return primes.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2977549,
                "title": "c-easy-to-understand",
                "content": "This question is based on a question from previous contest. Both questions use the same approach\\nPrevious contest question => https://leetcode.com/problems/smallest-value-after-replacing-with-sum-of-prime-factors/\\nprevious contest solution => https://leetcode.com/problems/smallest-value-after-replacing-with-sum-of-prime-factors/discuss/2923624/c-simple-prime-factorization\\n\\n```\\nclass Solution {\\npublic:\\n    void addPrimeFactors(set<int>&st, int n)\\n    {\\n        int divisor = 2;\\n        long long ans = 0;\\n        while(n > 1)\\n        {\\n            if (n % divisor == 0) \\n            {\\n                st.insert(divisor);\\n                n = n / divisor;\\n            }\\n            else divisor++;\\n        }\\n    }\\n    int distinctPrimeFactors(vector<int>& nums) \\n    {\\n        set<int>st;\\n        for (int num : nums) addPrimeFactors(st, num);\\n        return st.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void addPrimeFactors(set<int>&st, int n)\\n    {\\n        int divisor = 2;\\n        long long ans = 0;\\n        while(n > 1)\\n        {\\n            if (n % divisor == 0) \\n            {\\n                st.insert(divisor);\\n                n = n / divisor;\\n            }\\n            else divisor++;\\n        }\\n    }\\n    int distinctPrimeFactors(vector<int>& nums) \\n    {\\n        set<int>st;\\n        for (int num : nums) addPrimeFactors(st, num);\\n        return st.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977676,
                "title": "sieve-of-eratosthenes-o-n-log-log-n-explained-intuition-with-clean-code-time-complexity",
                "content": "# Idea\\n- Looking at the contraints, which says the array nums can have value from 2 to 1000\\n- Its a clue to use Sieve of Erantoshenes\\n- Precompute for n=1000+1, to know primes in range 1 to 1000\\n- Then Iterate the primes and pick them if they divide any one of the numbers in the array of nums\\n- This is what the ques asks\\n- The ques says do prime factorization of prod of full array.\\n- But we can do prime fac of each and every num\\n- As at the end of the day we need how many unique primes are there\\n- Just have a counter to keep the distinct primes.\\n- BASICALLY \\n- EXAMPLE:\\n- The product of all the elements in nums is: 2 * 4 * 3 * 7 * 10 * 6 = 10080 = 2^5 * 3^2 * 5 * 7.\\n- Instead of all these calcs \\n- Go in reverse take primes from 2 to 1000\\n- Take all primes that divides any num in the Array.\\n- So why to take product and then prime factorize it back and get unique primes - **which is like touching the nose from round the head**.\\n\\n# Complexity\\n- Time complexity: O(N*Log(Log(N))) + O(1000 * N)\\n- O(N*Log(Log(N))) PRECALC (Sieve method of calculating primes)\\n- O(1000 * N) as at max 1000 primes we may have hypothetically.\\n- For every prime at max we iterate the full array.\\n- Still its less than 10^8 - So no TLE\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1001)\\n- The precalc is done for this much only.\\n- No matter whats the N = length of nums \\n- Only these many space we take\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<int> preCalc(int n){\\n        vector<int> prime(n+1, 0);\\n        int pr = 2;\\n        while(pr * pr<= n){\\n            if(prime[pr]== 0){\\n                for (int i=2*pr; i<n+1; i=i+pr)\\n                        prime[i]= 1;\\n            }\\n            pr++;\\n          }\\n\\n\\n        vector<int> ans;\\n        for (int i=2; i<n; i++) \\n            if (prime[i]==0) \\n                ans.push_back(i);\\n        \\n        return ans;\\n    }\\npublic:\\n    \\n    int helper(vector<int>&arr, vector<int>& Pans){\\n        int ctr = 0;\\n        for(int p : Pans){\\n            for(int val : arr){\\n                if(val%p == 0){\\n                    ctr++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ctr;\\n    }\\n    \\n    int distinctPrimeFactors(vector<int>& nums) {\\n        vector<int> Pans = preCalc(1001);\\n        return helper(nums, Pans);\\n \\n        \\n        \\n    }\\n};\\n```\\n# Kindly UPVOTE if u understood and liked the solution, so it helps others in getting the solution at top and myself too.\\n### Comment any doubts, if not put understood or us in comments if u got fully.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> preCalc(int n){\\n        vector<int> prime(n+1, 0);\\n        int pr = 2;\\n        while(pr * pr<= n){\\n            if(prime[pr]== 0){\\n                for (int i=2*pr; i<n+1; i=i+pr)\\n                        prime[i]= 1;\\n            }\\n            pr++;\\n          }\\n\\n\\n        vector<int> ans;\\n        for (int i=2; i<n; i++) \\n            if (prime[i]==0) \\n                ans.push_back(i);\\n        \\n        return ans;\\n    }\\npublic:\\n    \\n    int helper(vector<int>&arr, vector<int>& Pans){\\n        int ctr = 0;\\n        for(int p : Pans){\\n            for(int val : arr){\\n                if(val%p == 0){\\n                    ctr++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ctr;\\n    }\\n    \\n    int distinctPrimeFactors(vector<int>& nums) {\\n        vector<int> Pans = preCalc(1001);\\n        return helper(nums, Pans);\\n \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977534,
                "title": "python-simple-python-solution-using-set-100-faster",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 351 ms, faster than 100.00% of Python3 online submissions for Distinct Prime Factors of Product of Array.\\n# Memory Usage: 15.2 MB, less than 100.00% of Python3 online submissions for Distinct Prime Factors of Product of Array.\\n\\n![image](https://assets.leetcode.com/users/images/21d532fb-b66d-4c8d-93b4-a45d2aaa7172_1672546566.2624516.png)\\n\\n\\n\\tclass Solution:\\n\\t\\tdef distinctPrimeFactors(self, nums: List[int]) -> int:\\n\\n\\t\\t\\tresult = []\\n\\n\\t\\t\\tfor i in range (len(nums)) :\\n\\n\\t\\t\\t\\tsquare_root = int(math.sqrt(nums[i]))\\n\\n\\t\\t\\t\\tfor prime_num in range(2, square_root + 1) :\\n\\n\\t\\t\\t\\t\\tif (nums[i] % prime_num == 0) :\\n\\n\\t\\t\\t\\t\\t\\tresult.append(prime_num)\\n\\n\\t\\t\\t\\t\\t\\twhile (nums[i] % prime_num == 0) :\\n\\t\\t\\t\\t\\t\\t\\tnums[i] = nums[i] // prime_num\\n\\n\\t\\t\\t\\tif (nums[i] >= 2) :\\n\\t\\t\\t\\t\\tresult.append(nums[i])\\n\\n\\t\\t\\tresult = set(result)\\n\\t\\t\\treturn len(result)\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 351 ms, faster than 100.00% of Python3 online submissions for Distinct Prime Factors of Product of Array.\\n# Memory Usage: 15.2 MB, less than 100.00% of Python3 online submissions for Distinct Prime Factors of Product of Array.\\n\\n![image](https://assets.leetcode.com/users/images/21d532fb-b66d-4c8d-93b4-a45d2aaa7172_1672546566.2624516.png)\\n\\n\\n\\tclass Solution:\\n\\t\\tdef distinctPrimeFactors(self, nums: List[int]) -> int:\\n\\n\\t\\t\\tresult = []\\n\\n\\t\\t\\tfor i in range (len(nums)) :\\n\\n\\t\\t\\t\\tsquare_root = int(math.sqrt(nums[i]))\\n\\n\\t\\t\\t\\tfor prime_num in range(2, square_root + 1) :\\n\\n\\t\\t\\t\\t\\tif (nums[i] % prime_num == 0) :\\n\\n\\t\\t\\t\\t\\t\\tresult.append(prime_num)\\n\\n\\t\\t\\t\\t\\t\\twhile (nums[i] % prime_num == 0) :\\n\\t\\t\\t\\t\\t\\t\\tnums[i] = nums[i] // prime_num\\n\\n\\t\\t\\t\\tif (nums[i] >= 2) :\\n\\t\\t\\t\\t\\tresult.append(nums[i])\\n\\n\\t\\t\\tresult = set(result)\\n\\t\\t\\treturn len(result)\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n",
                "codeTag": "Java"
            },
            {
                "id": 2994472,
                "title": "java-8ms-optimized",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Find all primes within range (2 to max in array)\\n- to calculate product of all numbers will overflow, so we have to check all prime factors each number one by one\\n- Optimization, to get all prime factors for each number only once \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: (m+n)*sqrt(m)\\n    - get all primes: m*sqrt(m), where m is max of array (int this case, 1000)\\n    - Get all Prime Factors: n*sqrt(m), n is the length of array\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    public int distinctPrimeFactors(int[] a) {\\n        int max = 0;\\n        for (int x : a) if (x > max) max = x; // find max to get all primes for all values\\n\\n        // get all primes <= max\\n        List<Integer> primes = allPrimes(max);\\n\\n        boolean[] used = new boolean[max+1]; // mark Prime Factors used\\n        boolean[] visited = new boolean[max+1]; // do not calc same number in array twice\\n        for (int v : a)\\n            if (!visited[v]) {\\n                allPrimeFactors(v, primes, used); // check result for each of them\\n                visited[v] = true;\\n            }\\n\\n        int res = 0;\\n        for (int x = 2; x <= max; x++) if (used[x]) res++; // count all results\\n\\n        return res;\\n    }\\n\\n    private void allPrimeFactors(int v, List<Integer> primes, boolean[] used) {\\n        for (int p : primes) {\\n            if (p > v) break;\\n            if (v % p == 0) {\\n                used[p] = true;\\n                while (v % p == 0) v /= p;\\n            }\\n\\n        }\\n    }\\n\\n    public List<Integer> allPrimes(int n) {\\n        boolean[] notP = _allPrimes(n);\\n        List<Integer> res = new ArrayList<>();\\n        for (int x = 2; x <= n; x++) if (!notP[x]) res.add(x);\\n        return res;\\n    }\\n\\n    private boolean[] _allPrimes(int n) {\\n        boolean[] notP = new boolean[n+1];\\n        for (int x = 4; x <= n; x++) for (int y = 2; y*y <= x; y++)\\n            if (!notP[y] && x % y == 0) {\\n                notP[x] = true;\\n                break;\\n            }\\n\\n        return notP;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int distinctPrimeFactors(int[] a) {\\n        int max = 0;\\n        for (int x : a) if (x > max) max = x; // find max to get all primes for all values\\n\\n        // get all primes <= max\\n        List<Integer> primes = allPrimes(max);\\n\\n        boolean[] used = new boolean[max+1]; // mark Prime Factors used\\n        boolean[] visited = new boolean[max+1]; // do not calc same number in array twice\\n        for (int v : a)\\n            if (!visited[v]) {\\n                allPrimeFactors(v, primes, used); // check result for each of them\\n                visited[v] = true;\\n            }\\n\\n        int res = 0;\\n        for (int x = 2; x <= max; x++) if (used[x]) res++; // count all results\\n\\n        return res;\\n    }\\n\\n    private void allPrimeFactors(int v, List<Integer> primes, boolean[] used) {\\n        for (int p : primes) {\\n            if (p > v) break;\\n            if (v % p == 0) {\\n                used[p] = true;\\n                while (v % p == 0) v /= p;\\n            }\\n\\n        }\\n    }\\n\\n    public List<Integer> allPrimes(int n) {\\n        boolean[] notP = _allPrimes(n);\\n        List<Integer> res = new ArrayList<>();\\n        for (int x = 2; x <= n; x++) if (!notP[x]) res.add(x);\\n        return res;\\n    }\\n\\n    private boolean[] _allPrimes(int n) {\\n        boolean[] notP = new boolean[n+1];\\n        for (int x = 4; x <= n; x++) for (int y = 2; y*y <= x; y++)\\n            if (!notP[y] && x % y == 0) {\\n                notP[x] = true;\\n                break;\\n            }\\n\\n        return notP;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977354,
                "title": "java-optimized-solution",
                "content": "Time complexity: O(N)\\nSpace Complexity: O(ans)\\n```\\nclass Solution {\\n\\n    public int distinctPrimeFactors(int[] nums) {\\n        HashSet<Integer> primes = new HashSet<>();\\n        for (int i = 2; i <= 1000; i++) {\\n            if (isPrime(i)) {\\n                primes.add(i);\\n            }\\n        }\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        for (int i : nums) {\\n            for (int p : primes) {\\n                if (i % p == 0) {\\n                    set.add(p);\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n\\n    public boolean isPrime(int n) {\\n        if (n <= 1) {\\n            return false;\\n        }\\n        for (int i = 2; i <= Math.sqrt(n); i++) {\\n            if (n % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int distinctPrimeFactors(int[] nums) {\\n        HashSet<Integer> primes = new HashSet<>();\\n        for (int i = 2; i <= 1000; i++) {\\n            if (isPrime(i)) {\\n                primes.add(i);\\n            }\\n        }\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        for (int i : nums) {\\n            for (int p : primes) {\\n                if (i % p == 0) {\\n                    set.add(p);\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n\\n    public boolean isPrime(int n) {\\n        if (n <= 1) {\\n            return false;\\n        }\\n        for (int i = 2; i <= Math.sqrt(n); i++) {\\n            if (n % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978470,
                "title": "python-3-10-lines-sets-t-m-232ms-15-3-mb",
                "content": "\\n```\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n\\n        seen, primes = set(), {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31} \\n         \\n        for num in nums:\\n            for p in primes:\\n\\n                r = num%p\\n                if p not in seen and not r: seen.add(p)\\n\\n                while not r:\\n                    num//= p\\n                    r = num%p\\n\\n            if num > 1: seen.add(num) \\n\\n        return len(seen)\\n\\n```\\n[https://leetcode.com/problems/distinct-prime-factors-of-product-of-array/submissions/868932952/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is at worst *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n\\n        seen, primes = set(), {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31} \\n         \\n        for num in nums:\\n            for p in primes:\\n\\n                r = num%p\\n                if p not in seen and not r: seen.add(p)\\n\\n                while not r:\\n                    num//= p\\n                    r = num%p\\n\\n            if num > 1: seen.add(num) \\n\\n        return len(seen)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977245,
                "title": "c-easy-and-simple-solution",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n<!-- # Complexity -->\\n<!-- - Time complexity:\\nO(N)<br>\\nN is the no of digit in Num .\\n\\n- Space complexity:\\n O(N)\\n -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n\\nvoid primeFactors(long long int n,vector<int>&factor)\\n{\\n\\tint c=2;\\n\\twhile(n>1)\\n\\t{\\n\\t\\tif(n%c==0){\\n\\t\\tfactor.push_back(c);\\n\\t\\tn/=c;\\n\\t\\t}\\n\\t\\telse c++;\\n\\t}\\n}\\n    \\n    int distinctPrimeFactors(vector<int>& nums) {\\n        long long int res=1;\\n        int count=0;\\n        vector<int>factor;\\n        for(int i=0;i<nums.size();i++){\\n            primeFactors(nums[i],factor);\\n        }\\n        \\n        \\n        map<int,int>mapping;\\n        for(auto i : factor)\\n            mapping[i]++;\\n        return mapping.size();\\n        \\n    }\\n};\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n\\nvoid primeFactors(long long int n,vector<int>&factor)\\n{\\n\\tint c=2;\\n\\twhile(n>1)\\n\\t{\\n\\t\\tif(n%c==0){\\n\\t\\tfactor.push_back(c);\\n\\t\\tn/=c;\\n\\t\\t}\\n\\t\\telse c++;\\n\\t}\\n}\\n    \\n    int distinctPrimeFactors(vector<int>& nums) {\\n        long long int res=1;\\n        int count=0;\\n        vector<int>factor;\\n        for(int i=0;i<nums.size();i++){\\n            primeFactors(nums[i],factor);\\n        }\\n        \\n        \\n        map<int,int>mapping;\\n        for(auto i : factor)\\n            mapping[i]++;\\n        return mapping.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979365,
                "title": "c-simple-solution-using-sieve",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        long count=0;\\n\\n        vector<int> prime(1001,1);\\n        for(int i=2;i<=1000;i++){\\n           if(prime[i]==1)\\n           { for(int j=i*i;j<=1000;j+=i)\\n                prime[j]=0;\\n           }\\n    }\\n    \\n        vector<int> ans;\\n        for (int i=2; i<1001; i++) \\n            if (prime[i]==1) {\\n                ans.push_back(i);\\n            }\\n\\n        for(int i : ans){\\n            for(int j : nums){\\n                if(j%i == 0){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        long count=0;\\n\\n        vector<int> prime(1001,1);\\n        for(int i=2;i<=1000;i++){\\n           if(prime[i]==1)\\n           { for(int j=i*i;j<=1000;j+=i)\\n                prime[j]=0;\\n           }\\n    }\\n    \\n        vector<int> ans;\\n        for (int i=2; i<1001; i++) \\n            if (prime[i]==1) {\\n                ans.push_back(i);\\n            }\\n\\n        for(int i : ans){\\n            for(int j : nums){\\n                if(j%i == 0){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979277,
                "title": "leetcode-the-hard-way-prime-factorisation-set",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<pair<long long, int>> prime_factorize(long long n) {\\n        assert(n >= 1);\\n        vector<pair<long long, int>> result;\\n\\n        auto extract = [&](long long p) {\\n            if (n % p == 0) {\\n                result.emplace_back(p, 0);\\n\\n                do {\\n                    n /= p;\\n                    result.back().second++;\\n                } while (n % p == 0);\\n            }\\n        };\\n\\n        for (long long p = 2; p * p <= n; p += p % 2 + 1)\\n            extract(p);\\n\\n        if (n > 1)\\n            result.emplace_back(n, 1);\\n\\n        return result;\\n    }\\n\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        set<int> s;\\n        for (auto x : nums) {\\n            for (auto x : prime_factorize(x)) {\\n                s.insert(x.first);\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<pair<long long, int>> prime_factorize(long long n) {\\n        assert(n >= 1);\\n        vector<pair<long long, int>> result;\\n\\n        auto extract = [&](long long p) {\\n            if (n % p == 0) {\\n                result.emplace_back(p, 0);\\n\\n                do {\\n                    n /= p;\\n                    result.back().second++;\\n                } while (n % p == 0);\\n            }\\n        };\\n\\n        for (long long p = 2; p * p <= n; p += p % 2 + 1)\\n            extract(p);\\n\\n        if (n > 1)\\n            result.emplace_back(n, 1);\\n\\n        return result;\\n    }\\n\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        set<int> s;\\n        for (auto x : nums) {\\n            for (auto x : prime_factorize(x)) {\\n                s.insert(x.first);\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977664,
                "title": "c-explained-with-comments-clean-short-code",
                "content": "![image](https://assets.leetcode.com/users/images/de7cc524-3e12-468f-9dc7-5a055213ac90_1672546642.909689.png)\\n\\n**T->O(N Log(LogN) + N * 1e3) && S->O(1e3)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint distinctPrimeFactors(vector<int>& nums) {\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tset<int>s;\\n\\t\\t\\t\\n\\t\\t\\t//T->O(N log(log N))\\n\\t\\t\\t// sieve of eratosthenes (Algo to find prime numbers less than n, here n=1000)\\n\\t\\t\\tvector<bool> p(1001,true);\\n\\t\\t\\tp[0]=p[1]=false;\\n\\t\\t\\tfor(int i=2;i*i<1001;i++){\\n\\t\\t\\t\\tfor(int j=2;i*j<1001;j++) p[i*j]=false;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tT->O(N * 1000)\\n\\t\\t\\t// Finding number of primes\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tfor(int j=2;j<=1000;j++){\\n\\t\\t\\t\\t\\tif(p[j] && nums[i]%j==0) s.insert(j);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn s.size();\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint distinctPrimeFactors(vector<int>& nums) {\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tset<int>s;\\n\\t\\t\\t\\n\\t\\t\\t//T->O(N log(log N))\\n\\t\\t\\t// sieve of eratosthenes (Algo to find prime numbers less than n, here n=1000)\\n\\t\\t\\tvector<bool> p(1001,true);\\n\\t\\t\\tp[0]=p[1]=false;\\n\\t\\t\\tfor(int i=2;i*i<1001;i++){\\n\\t\\t\\t\\tfor(int j=2;i*j<1001;j++) p[i*j]=false;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2977310,
                "title": "c-mapping-prime-number-with-flag",
                "content": "```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        map<int,bool> mp;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=2;j<=nums[i];j++){\\n                while(nums[i]%j == 0){\\n                    mp[j] = 1;\\n                    nums[i] /= j;\\n                }\\n            }\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        map<int,bool> mp;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=2;j<=nums[i];j++){\\n                while(nums[i]%j == 0){\\n                    mp[j] = 1;\\n                    nums[i] /= j;\\n                }\\n            }\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3004548,
                "title": "east-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void addPrimeFactors(set<int>&s, int n){\\n        int divisor = 2;\\n        long long ans = 0;\\n        while(n > 1){\\n            if (n % divisor == 0){\\n                s.insert(divisor);\\n                n = n / divisor;\\n            }\\n            else\\n                divisor++;\\n        }\\n    }\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        set<int> s;\\n        for (int num : nums)\\n            addPrimeFactors(s, num);\\n        return s.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void addPrimeFactors(set<int>&s, int n){\\n        int divisor = 2;\\n        long long ans = 0;\\n        while(n > 1){\\n            if (n % divisor == 0){\\n                s.insert(divisor);\\n                n = n / divisor;\\n            }\\n            else\\n                divisor++;\\n        }\\n    }\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        set<int> s;\\n        for (int num : nums)\\n            addPrimeFactors(s, num);\\n        return s.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977490,
                "title": "100-faster-c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    void prime(int n, set<int> &st)\\n    {\\n        while (n%2 == 0) \\n        { \\n            st.insert(2);\\n            n = n/2; \\n        } \\n        for (int i = 3; i <= sqrt(n); i = i+2) \\n        { \\n            while (n%i == 0) \\n            { \\n                st.insert(i);\\n                n = n/i; \\n            } \\n        }\\n        if (n > 2)\\n            st.insert(n);\\n    }\\n    \\n    int distinctPrimeFactors(vector<int>& nums) \\n    {\\n        set<int> st;\\n        for (int i = 0; i < nums.size(); i++)\\n            prime(nums[i], st);\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void prime(int n, set<int> &st)\\n    {\\n        while (n%2 == 0) \\n        { \\n            st.insert(2);\\n            n = n/2; \\n        } \\n        for (int i = 3; i <= sqrt(n); i = i+2) \\n        { \\n            while (n%i == 0) \\n            { \\n                st.insert(i);\\n                n = n/i; \\n            } \\n        }\\n        if (n > 2)\\n            st.insert(n);\\n    }\\n    \\n    int distinctPrimeFactors(vector<int>& nums) \\n    {\\n        set<int> st;\\n        for (int i = 0; i < nums.size(); i++)\\n            prime(nums[i], st);\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654401,
                "title": "sieve-of-eratosthenes-c-hash-table-set",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        vector<bool> p(1001,true);\\n        int i = 2,j;\\n        for(i = 2; i <= 1000; i++){\\n            if(p[i]){\\n                for(j = i*i; j <= 1000; j+=i){\\n                    p[j] = false;\\n                }\\n            }\\n        }\\n        unordered_set<int> a,b;\\n        for(i  = 2; i < 1000; i++){\\n            if(p[i]){\\n                b.insert(i);\\n            }\\n        }\\n        for(auto &i: b){\\n            for(auto &j: nums){\\n                if(j%i==0){\\n                    a.insert(i);\\n                    break;\\n                }\\n            }\\n            \\n        }\\n        return a.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        vector<bool> p(1001,true);\\n        int i = 2,j;\\n        for(i = 2; i <= 1000; i++){\\n            if(p[i]){\\n                for(j = i*i; j <= 1000; j+=i){\\n                    p[j] = false;\\n                }\\n            }\\n        }\\n        unordered_set<int> a,b;\\n        for(i  = 2; i < 1000; i++){\\n            if(p[i]){\\n                b.insert(i);\\n            }\\n        }\\n        for(auto &i: b){\\n            for(auto &j: nums){\\n                if(j%i==0){\\n                    a.insert(i);\\n                    break;\\n                }\\n            }\\n            \\n        }\\n        return a.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3408376,
                "title": "c-easy-to-understand-simple-short-sweer-code",
                "content": "````\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        unordered_set<int> s;//store unique prime numbers\\n        int j,k;\\n        for(auto &i: nums){//find prime factors of each number\\n            k = i;\\n            for(j = 2; j <= sqrt(i); j++){\\n                if(k%j==0){\\n                    s.insert(j);//insert prime factore into ans set\\n                    while(k%j==0){\\n                        k /= j;\\n                    }\\n                }\\n            }\\n            if(k>1)s.insert(k);//if k itself a prime number\\n        }\\n        \\n        return s.size();//return no of prime numbers\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Ordered Set"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        unordered_set<int> s;//store unique prime numbers\\n        int j,k;\\n        for(auto &i: nums){//find prime factors of each number\\n            k = i;\\n            for(j = 2; j <= sqrt(i); j++){\\n                if(k%j==0){\\n                    s.insert(j);//insert prime factore into ans set\\n                    while(k%j==0){\\n                        k /= j;\\n                    }\\n                }\\n            }\\n            if(k>1)s.insert(k);//if k itself a prime number\\n        }\\n        \\n        return s.size();//return no of prime numbers\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2985368,
                "title": "c-inserting-prime-number-in-set",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint distinctPrimeFactors(vector<int>& nums) {\\n\\t\\t\\tset<int>s;\\n\\t\\t\\tfor(int i=0; i<nums.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint j=2;\\n\\t\\t\\t\\tint k;  \\n\\t\\t\\t\\tint m_num=nums[i];\\n\\t\\t\\t\\twhile(m_num>1){\\n\\t\\t\\t\\t\\tint b=m_num;\\n\\t\\t\\t\\t\\tif(m_num%j==0){\\n\\t\\t\\t\\t\\t\\ts.insert(j);\\n\\t\\t\\t\\t\\t\\tm_num/=j;\\n\\t\\t\\t\\t\\t\\tk=j;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tif(k==b)\\n\\t\\t\\t\\t\\t\\t  break;\\n\\t\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}        \\n\\t\\t\\treturn s.size();\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint distinctPrimeFactors(vector<int>& nums) {\\n\\t\\t\\tset<int>s;\\n\\t\\t\\tfor(int i=0; i<nums.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint j=2;\\n\\t\\t\\t\\tint k;  \\n\\t\\t\\t\\tint m_num=nums[i];\\n\\t\\t\\t\\twhile(m_num>1){\\n\\t\\t\\t\\t\\tint b=m_num;\\n\\t\\t\\t\\t\\tif(m_num%j==0){\\n\\t\\t\\t\\t\\t\\ts.insert(j);\\n\\t\\t\\t\\t\\t\\tm_num/=j;\\n\\t\\t\\t\\t\\t\\tk=j;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2983889,
                "title": "c-prime-factorisation-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        vector<int> prime;\\n        for(int i=2;i<=1000;i++){\\n            if(isprime(i)){\\n                prime.push_back(i);// storing all primes between 1-1000\\n            }\\n        }\\n        set<int> st;\\n        for(int n:nums){\\n            for(int p:prime){\\n                if(n%p==0){\\n                    st.insert(p);\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n    \\n    bool isprime(int n){\\n        int cnt=0;\\n        for(int i=2;i*i<=n;i++){\\n            if(n%i==0)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        vector<int> prime;\\n        for(int i=2;i<=1000;i++){\\n            if(isprime(i)){\\n                prime.push_back(i);// storing all primes between 1-1000\\n            }\\n        }\\n        set<int> st;\\n        for(int n:nums){\\n            for(int p:prime){\\n                if(n%p==0){\\n                    st.insert(p);\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n    \\n    bool isprime(int n){\\n        int cnt=0;\\n        for(int i=2;i*i<=n;i++){\\n            if(n%i==0)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978775,
                "title": "new-approach-100-efficient-and-unique-approach-only-counting",
                "content": "```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) \\n    {\\n     ArrayList<Integer> al=new ArrayList<>();\\n     int primes[]={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997};\\n        \\n        HashMap<Integer,Integer> count=new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=0;j<primes.length;j++)\\n            {\\n                if(nums[i]<primes[j])\\n                    break;\\n                if(nums[i]%primes[j]==0)\\n                {\\n                    count.put(primes[j],1);\\n                }\\n            }\\n        }\\n        \\n        \\n        return count.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) \\n    {\\n     ArrayList<Integer> al=new ArrayList<>();\\n     int primes[]={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997};\\n        \\n        HashMap<Integer,Integer> count=new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=0;j<primes.length;j++)\\n            {\\n                if(nums[i]<primes[j])\\n                    break;\\n                if(nums[i]%primes[j]==0)\\n                {\\n                    count.put(primes[j],1);\\n                }\\n            }\\n        }\\n        \\n        \\n        return count.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977829,
                "title": "java-brute-force-easy",
                "content": "# Please Upvote :D \\n``` java []\\nclass Solution {\\n    private Set<Integer> set = new HashSet<>();\\n    private void getPrimes(int num) {\\n        int n = num;\\n        for (int i = 2; i <= num; i++) {\\n            if (n % i == 0) {\\n                while (n % i == 0) {\\n                    n /= i;\\n                }\\n                set.add(i);\\n            }\\n            if (n == 1) {\\n                return;\\n            }\\n        }\\n    }\\n\\n    public int distinctPrimeFactors(int[] nums) {\\n        for (int n : nums) {\\n            getPrimes(n);\\n        }\\n\\n        return set.size();\\n    }\\n}\\n\\n// TC: O(n * k)\\n// n -> number of elements in nums\\n// k -> maximum element in nums\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java []\\nclass Solution {\\n    private Set<Integer> set = new HashSet<>();\\n    private void getPrimes(int num) {\\n        int n = num;\\n        for (int i = 2; i <= num; i++) {\\n            if (n % i == 0) {\\n                while (n % i == 0) {\\n                    n /= i;\\n                }\\n                set.add(i);\\n            }\\n            if (n == 1) {\\n                return;\\n            }\\n        }\\n    }\\n\\n    public int distinctPrimeFactors(int[] nums) {\\n        for (int n : nums) {\\n            getPrimes(n);\\n        }\\n\\n        return set.size();\\n    }\\n}\\n\\n// TC: O(n * k)\\n// n -> number of elements in nums\\n// k -> maximum element in nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977488,
                "title": "java-solution-with-comments-easy-beats-100-hashtable",
                "content": "```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        int count=0;\\n        int[] a = new int[1001];\\n        //mark prime factors of all elements of nums using hashtable(a)\\n        for(int x:nums){\\n            primeFactors(x,a);\\n        }\\n\\n        //counting all distinct prime factors\\n        for(int x:a){\\n            if(x==1)\\n                count++;\\n        }\\n        return count;\\n    }\\n    \\n    private void primeFactors(int x,int[] a)\\n    {\\n        int root = (int)Math.sqrt(x);\\n        for (int i=2; i<=root; i++) {\\n            while (x%i == 0) {\\n                x/=i;\\n                a[i]=1;\\n            }\\n        }\\n\\n        if(x>=2)\\n            a[x]=1;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        int count=0;\\n        int[] a = new int[1001];\\n        //mark prime factors of all elements of nums using hashtable(a)\\n        for(int x:nums){\\n            primeFactors(x,a);\\n        }\\n\\n        //counting all distinct prime factors\\n        for(int x:a){\\n            if(x==1)\\n                count++;\\n        }\\n        return count;\\n    }\\n    \\n    private void primeFactors(int x,int[] a)\\n    {\\n        int root = (int)Math.sqrt(x);\\n        for (int i=2; i<=root; i++) {\\n            while (x%i == 0) {\\n                x/=i;\\n                a[i]=1;\\n            }\\n        }\\n\\n        if(x>=2)\\n            a[x]=1;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977361,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\npublic:\\n    unordered_set<ll>pf, cache; // hash-set of all the prime factors of all the numbers\\n    void getPrimeFactors(ll n){\\n        ll m=n;\\n        if(n<2){\\n            return;\\n        }\\n        while (!(n&1)){\\n            pf.insert(2);\\n            n>>=1;\\n        }\\n        for (ll i = 3; i*i<=n; i+=2){\\n            while (n % i == 0){\\n                pf.insert(i);\\n                n/=i;\\n            }\\n        }\\n        if (n > 2){\\n            pf.insert(n);\\n        }\\n    }\\n    int distinctPrimeFactors(vector<int>&v) {\\n    ll ans=0;\\n    for(ll it:v){\\n        getPrimeFactors(it);\\n    }\\n    return pf.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\npublic:\\n    unordered_set<ll>pf, cache; // hash-set of all the prime factors of all the numbers\\n    void getPrimeFactors(ll n){\\n        ll m=n;\\n        if(n<2){\\n            return;\\n        }\\n        while (!(n&1)){\\n            pf.insert(2);\\n            n>>=1;\\n        }\\n        for (ll i = 3; i*i<=n; i+=2){\\n            while (n % i == 0){\\n                pf.insert(i);\\n                n/=i;\\n            }\\n        }\\n        if (n > 2){\\n            pf.insert(n);\\n        }\\n    }\\n    int distinctPrimeFactors(vector<int>&v) {\\n    ll ans=0;\\n    for(ll it:v){\\n        getPrimeFactors(it);\\n    }\\n    return pf.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977285,
                "title": "short-concise-c",
                "content": "```\\nclass Solution {\\n    void solve(int n, unordered_set<int> &s) {\\n        for(int i=2; i<=sqrt(n); i++) {\\n            while(n % i == 0) s.insert(i), n /= i;\\n        }\\n        if(n > 1) s.insert(n);\\n    }\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        unordered_set<int> s;\\n        for(int i : nums) solve(i, s);\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void solve(int n, unordered_set<int> &s) {\\n        for(int i=2; i<=sqrt(n); i++) {\\n            while(n % i == 0) s.insert(i), n /= i;\\n        }\\n        if(n > 1) s.insert(n);\\n    }\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        unordered_set<int> s;\\n        for(int i : nums) solve(i, s);\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888581,
                "title": "beats-90-using-sieve",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        vector<bool> primes(1001,true);\\n        int i = 2;\\n        int j;\\n        for(i=2;i<=1000;i++)\\n        {\\n            if(primes[i]==true)\\n            {\\n                for(j = i*i;j<=1000;j+=i)\\n                {\\n                    primes[j] = false;\\n                }\\n            }\\n        }\\n\\n\\n        unordered_set<int> p;\\n        for(int i=2;i<primes.size();i++)\\n        {\\n            if(primes[i])\\n            p.insert(i);\\n        }\\n        unordered_set<int> ans;\\n        for(auto it:p)\\n        {\\n            for(auto itj:nums)\\n            {\\n                if(itj%it==0)\\n                {\\n                    ans.insert(it);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        vector<bool> primes(1001,true);\\n        int i = 2;\\n        int j;\\n        for(i=2;i<=1000;i++)\\n        {\\n            if(primes[i]==true)\\n            {\\n                for(j = i*i;j<=1000;j+=i)\\n                {\\n                    primes[j] = false;\\n                }\\n            }\\n        }\\n\\n\\n        unordered_set<int> p;\\n        for(int i=2;i<primes.size();i++)\\n        {\\n            if(primes[i])\\n            p.insert(i);\\n        }\\n        unordered_set<int> ans;\\n        for(auto it:p)\\n        {\\n            for(auto itj:nums)\\n            {\\n                if(itj%it==0)\\n                {\\n                    ans.insert(it);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2985260,
                "title": "c-set-prime-factorization-easy-36-time-9-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> helper(int n){\\n      int c = 2;\\n      vector<int> res;\\n      while(n > 1){\\n        if(n % c == 0){\\n          res.emplace_back(c);\\n          n /= c;\\n        } else c++;\\n      }\\n      return res;\\n    }\\n    \\n    int distinctPrimeFactors(vector<int>& v) {\\n      unordered_set<int> s;\\n      for(auto &i: v){\\n        auto temp = helper(i);\\n        for(auto &e: temp) s.insert(e);\\n      }\\n      return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> helper(int n){\\n      int c = 2;\\n      vector<int> res;\\n      while(n > 1){\\n        if(n % c == 0){\\n          res.emplace_back(c);\\n          n /= c;\\n        } else c++;\\n      }\\n      return res;\\n    }\\n    \\n    int distinctPrimeFactors(vector<int>& v) {\\n      unordered_set<int> s;\\n      for(auto &i: v){\\n        auto temp = helper(i);\\n        for(auto &e: temp) s.insert(e);\\n      }\\n      return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2980025,
                "title": "python3-solution-100-faster-solution",
                "content": "\\n```\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n        s=set()\\n        for x in nums:\\n            t=2\\n            while t*t<=x:\\n                while x%t==0:\\n                    x//=t\\n                    s.add(t)\\n\\n                t+=1\\n\\n            if x>1:\\n                s.add(x)\\n\\n        return len(s)                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n        s=set()\\n        for x in nums:\\n            t=2\\n            while t*t<=x:\\n                while x%t==0:\\n                    x//=t\\n                    s.add(t)\\n\\n                t+=1\\n\\n            if x>1:\\n                s.add(x)\\n\\n        return len(s)                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2980010,
                "title": "javascript-neat",
                "content": "```js\\nconst primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]\\nconst distinctPrimeFactors = (nums) => {\\n    const primeFactors = new Set()\\n    for (let x of nums) {\\n        for (const p of primes)\\n            if (x % p === 0) {\\n                primeFactors.add(p)\\n                while (x % p === 0)\\n                    x /= p\\n                if (x === 1)\\n                    break\\n            }\\n        if (x !== 1)\\n            primeFactors.add(x)\\n    }\\n    return primeFactors.size\\n}\\n```\\nRuntime 81 ms, Beats 100%\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]\\nconst distinctPrimeFactors = (nums) => {\\n    const primeFactors = new Set()\\n    for (let x of nums) {\\n        for (const p of primes)\\n            if (x % p === 0) {\\n                primeFactors.add(p)\\n                while (x % p === 0)\\n                    x /= p\\n                if (x === 1)\\n                    break\\n            }\\n        if (x !== 1)\\n            primeFactors.add(x)\\n    }\\n    return primeFactors.size\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2978855,
                "title": "easiest-and-clean-code-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    void addPrimeFactors(set<int>&st, int num)\\n    {\\n        int divisor = 2;\\n        while(num > 1)\\n        {\\n            if (num % divisor == 0) \\n            {\\n                st.insert(divisor);\\n                num /= divisor;\\n            }\\n            else divisor++;\\n        }\\n    }\\n    int distinctPrimeFactors(vector<int>& nums) \\n    {\\n        set<int>st;\\n        for (auto it : nums) addPrimeFactors(st, it);\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void addPrimeFactors(set<int>&st, int num)\\n    {\\n        int divisor = 2;\\n        while(num > 1)\\n        {\\n            if (num % divisor == 0) \\n            {\\n                st.insert(divisor);\\n                num /= divisor;\\n            }\\n            else divisor++;\\n        }\\n    }\\n    int distinctPrimeFactors(vector<int>& nums) \\n    {\\n        set<int>st;\\n        for (auto it : nums) addPrimeFactors(st, it);\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978501,
                "title": "c-solution-easy-solution-with-explained-approach",
                "content": "# Approach\\nWe will directly do the prime factors of the elements of array as the product of array will not come in range of int or long long. After that we will start he process of  findingprime factors of each nums[i] and store them in set.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n- Space complexity: o(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        unordered_set<int> s;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int n = nums[i];\\n            int c=2;\\n            while(n>1)\\n            {\\n                if(n%c==0){\\n                s.insert(c);\\n                n/=c;\\n                }\\n                else c++;\\n            }\\n        }\\n\\n        return s.size();\\n    }\\n};\\n```\\n#### Please upvote if you liked my solution.\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        unordered_set<int> s;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int n = nums[i];\\n            int c=2;\\n            while(n>1)\\n            {\\n                if(n%c==0){\\n                s.insert(c);\\n                n/=c;\\n                }\\n                else c++;\\n            }\\n        }\\n\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977519,
                "title": "easy-python-solution-with-proper-comments",
                "content": "# Intuition\\nThe approch is to calculate all prime factors of every number of nums and the adding the factors to a set for getting unique prime factors.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n        O(n*k)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n        O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n        def factors(nums): #function to calculate prime factors\\n            z = 2\\n            s=[]   # list to store prime factors\\n            while(nums>1) :\\n                if(nums%z==0):\\n                    nums//=z\\n                    s.append(z)\\n                else:\\n                    z+=1\\n            return s\\n\\n        s=set()  #creating set to store the unique factors\\n        for k in nums:\\n            z = factors(k)  # calculating current kth numbers factors \\n            for j in z:\\n                s.add(j)  #adding factors to the set\\n                \\n\\n        return len(s)  #returning the length of set as ans.\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n        def factors(nums): #function to calculate prime factors\\n            z = 2\\n            s=[]   # list to store prime factors\\n            while(nums>1) :\\n                if(nums%z==0):\\n                    nums//=z\\n                    s.append(z)\\n                else:\\n                    z+=1\\n            return s\\n\\n        s=set()  #creating set to store the unique factors\\n        for k in nums:\\n            z = factors(k)  # calculating current kth numbers factors \\n            for j in z:\\n                s.add(j)  #adding factors to the set\\n                \\n\\n        return len(s)  #returning the length of set as ans.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977405,
                "title": "simple-brute-force",
                "content": "Simple Brute force\\n# Code\\n```\\nclass Solution(object):\\n    def distinctPrimeFactors(self, nums):\\n        def get_distinct(n):\\n            c = 2\\n            ans = []\\n            while(n > 1):\\n\\n                if(n % c == 0):\\n                    ans.append(c)\\n                    n = n / c\\n                else:\\n                    c = c + 1\\n            return ans\\n        \\n        p = []\\n        for i in nums:\\n            t = get_distinct(i)\\n            l = [p.append(j) for j in t]\\n        return len(set(p))\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def distinctPrimeFactors(self, nums):\\n        def get_distinct(n):\\n            c = 2\\n            ans = []\\n            while(n > 1):\\n\\n                if(n % c == 0):\\n                    ans.append(c)\\n                    n = n / c\\n                else:\\n                    c = c + 1\\n            return ans\\n        \\n        p = []\\n        for i in nums:\\n            t = get_distinct(i)\\n            l = [p.append(j) for j in t]\\n        return len(set(p))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808215,
                "title": "simple-o-168-n-solution-solution-very-fast-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\n    public static int p[];\\n    Solution(){ \\n        if(p==null){\\n            p=new int[1001]; // Seive\\'s Algorithm for generating Prime Numbers\\n            for(int i=2;i<1001;i++)\\n                for(int j=i*i; j<1001 && p[i]==0; p[j]=-1, j+=i);\\n        }\\n    }\\n    \\n    public int distinctPrimeFactors(int[] nums) {\\n        int res=0;\\n        for(int i=2;i<1001;i++){\\n            if(p[i]!=0) continue;\\n            for(int n:nums)\\n                if(n%i==0){\\n                    res++;\\n                    break;\\n                }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nThe time complexity is O(168*N), is because there are only 168 primes under 1000.\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int p[];\\n    Solution(){ \\n        if(p==null){\\n            p=new int[1001]; // Seive\\'s Algorithm for generating Prime Numbers\\n            for(int i=2;i<1001;i++)\\n                for(int j=i*i; j<1001 && p[i]==0; p[j]=-1, j+=i);\\n        }\\n    }\\n    \\n    public int distinctPrimeFactors(int[] nums) {\\n        int res=0;\\n        for(int i=2;i<1001;i++){\\n            if(p[i]!=0) continue;\\n            for(int n:nums)\\n                if(n%i==0){\\n                    res++;\\n                    break;\\n                }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432538,
                "title": "very-eazy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_set<int>st;\\n    int distinctPrimeFactors(vector<int>& nums) \\n    {\\n         for(int i=0;i<nums.size();i++)\\n         {\\n              fun(nums[i]);\\n         }    \\n        \\n         return st.size();\\n    }\\n    void fun(long long int product)\\n    {\\n        for(int i=2;i<=product;i++)\\n        {\\n            while((product % i) == 0)\\n            {\\n                st.insert(i);\\n                product = product / i;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<int>st;\\n    int distinctPrimeFactors(vector<int>& nums) \\n    {\\n         for(int i=0;i<nums.size();i++)\\n         {\\n              fun(nums[i]);\\n         }    \\n        \\n         return st.size();\\n    }\\n    void fun(long long int product)\\n    {\\n        for(int i=2;i<=product;i++)\\n        {\\n            while((product % i) == 0)\\n            {\\n                st.insert(i);\\n                product = product / i;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358868,
                "title": "sieve-python",
                "content": "# Intuition and Approach\\n* use sieve to find the prime numbers between 1 to 1000.\\n* then return the no. of prime no. among them which can perfeclty divide any no. of the given list\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:o(1)\\n\\n# Code\\n```\\nclass Solution:\\n    p=[]\\n    def __init__(self):\\n        if(len(self.p)!=0):return\\n        self.s=[1 for i in range(1001)]\\n        for i in range(2,1001):\\n            if(not self.s[i]):continue\\n            self.p.append(i)\\n            for j in range(i*i,1001,i):\\n                self.s[j]=0\\n        \\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n        # print(self.p)\\n        ans=0\\n        for i in range(len(self.p)):\\n            for j in range(len(nums)):\\n                if(nums[j]%self.p[i]==0):\\n                    # print(i,j,nums[j],self.p[i])\\n                    ans+=1\\n                    break\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution:\\n    p=[]\\n    def __init__(self):\\n        if(len(self.p)!=0):return\\n        self.s=[1 for i in range(1001)]\\n        for i in range(2,1001):\\n            if(not self.s[i]):continue\\n            self.p.append(i)\\n            for j in range(i*i,1001,i):\\n                self.s[j]=0\\n        \\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n        # print(self.p)\\n        ans=0\\n        for i in range(len(self.p)):\\n            for j in range(len(nums)):\\n                if(nums[j]%self.p[i]==0):\\n                    # print(i,j,nums[j],self.p[i])\\n                    ans+=1\\n                    break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250138,
                "title": "coolest-solution-using-set-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n $$O(n2)$$ \\n\\n- Space complexity:\\n$$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  set<int>st;\\n  void primeFact(int n){\\n            while (n%2 == 0){\\n      st.insert(2);\\n      n = n/2;\\n   }\\n   for (int i = 3; i <= n; i = i+2){\\n      while (n%i == 0){\\n          st.insert(i);\\n       \\n         n = n/i;\\n      }\\n}\\n  }\\n  int distinctPrimeFactors(vector<int>& nums) {\\n        int cnt=0;\\n      for(int i=0;i<nums.size();i++){\\n          primeFact(nums[i]);\\n      }\\n         int k=st.size();\\n       return k;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  set<int>st;\\n  void primeFact(int n){\\n            while (n%2 == 0){\\n      st.insert(2);\\n      n = n/2;\\n   }\\n   for (int i = 3; i <= n; i = i+2){\\n      while (n%i == 0){\\n          st.insert(i);\\n       \\n         n = n/i;\\n      }\\n}\\n  }\\n  int distinctPrimeFactors(vector<int>& nums) {\\n        int cnt=0;\\n      for(int i=0;i<nums.size();i++){\\n          primeFact(nums[i]);\\n      }\\n         int k=st.size();\\n       return k;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3245965,
                "title": "java-beats-100-o-n-time-sol",
                "content": "# Intuition\\nThe max value of nums[i]=1000 so the first thought should be using sieve algo.\\n\\n# Approach\\n\\nAlgo:\\n\\nStep-1)\\nwe create an integer array isComp of size 1001 which can basically have 4 values:\\n0-> a prime number.\\n1-> a composite number.\\n2-> a composite number present in nums.\\n3-> a prime number present in nums.\\n\\nStep-2)\\nApply the normal sieve algo and fill the isComp array with 0s and 1s.\\n\\nStep-3)\\nItterate through the nums array and replace 0s and 1s with 2s and 3s wherever nescessary.\\n\\nstep-4)\\nNow go through each and every prime number marked in isComp array to:\\na) if the prime number is present in nums then do count++.\\nb) if it is a prime number that is not present in nums then loop till you find a multiple of it that is composite and present in nums.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n  a) Time for step 2-> O(mloglogm) where m is 1000.\\n  b) Time for step 3-> O(n) where n is length of given array\\n  c) Time for step 4-> O(mloglogm) where m is 1000.\\n\\n  Explanation for c :\\n   * for i=2 the inner loop runs for m/2 times in worst case\\n   * simillary for i=3 the inner loop runs for m/3 times\\n   * For i=m :\\n     time complexity = m/2+ m/3 +m/5 + ..m/m\\n                     = m(1/2 + 1/3 +1/5 +...+1/m)\\n                     = m(loglogm)\\n      \\n   From a , b and c we can say the complexity is approximately O(n).\\n\\n\\n\\n- Space complexity:\\n  a) a space of O(m) where m is 1000.\\n\\n# Code\\n```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        int isComp []=new int[1001]; // step 1\\n        isComp[0]=1;\\n        isComp[1]=1;\\n\\n        for(int i=2;i*i<=1000;i++){  // step 2\\n            if(isComp[i]==0){\\n                for(int j=i*i;j<=1000;j+=i){\\n                    isComp[j]=1;\\n                }\\n            }\\n        }\\n      \\n        for(int i=0;i<nums.length;i++){ //step 3\\n            int cur=nums[i];\\n            if(isComp[cur]==1){\\n                isComp[cur]=2;\\n            }\\n            else if(isComp[cur]==0){\\n              isComp[cur]=3;\\n            }\\n        }\\n  \\n        int count=0;\\n\\n        for(int i=2;i<=1000;i++){  // step 4\\n            if(isComp[i]==0){\\n                for(int j=i*2;j<=1000;j+=i){\\n                    if(isComp[j]==2){\\n                        count++;\\n                        break;\\n                    }\\n                }\\n            }\\n            else if(isComp[i]==3){\\n                 count++;\\n            }\\n        }\\n\\n        return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        int isComp []=new int[1001]; // step 1\\n        isComp[0]=1;\\n        isComp[1]=1;\\n\\n        for(int i=2;i*i<=1000;i++){  // step 2\\n            if(isComp[i]==0){\\n                for(int j=i*i;j<=1000;j+=i){\\n                    isComp[j]=1;\\n                }\\n            }\\n        }\\n      \\n        for(int i=0;i<nums.length;i++){ //step 3\\n            int cur=nums[i];\\n            if(isComp[cur]==1){\\n                isComp[cur]=2;\\n            }\\n            else if(isComp[cur]==0){\\n              isComp[cur]=3;\\n            }\\n        }\\n  \\n        int count=0;\\n\\n        for(int i=2;i<=1000;i++){  // step 4\\n            if(isComp[i]==0){\\n                for(int j=i*2;j<=1000;j+=i){\\n                    if(isComp[j]==2){\\n                        count++;\\n                        break;\\n                    }\\n                }\\n            }\\n            else if(isComp[i]==3){\\n                 count++;\\n            }\\n        }\\n\\n        return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100055,
                "title": "beginner-friendly-easy-solution-please-upvote-if-you-like-the-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isprime(int n){\\n        for(int i=2;i<n;i++){\\n            if(n%i==0) return false;\\n        }return true;\\n    }\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        set<int> s;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=2;j<=nums[i];j++)\\n                if(nums[i]%j==0&&isprime(j))\\n                    s.insert(j);\\n        }return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isprime(int n){\\n        for(int i=2;i<n;i++){\\n            if(n%i==0) return false;\\n        }return true;\\n    }\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        set<int> s;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=2;j<=nums[i];j++)\\n                if(nums[i]%j==0&&isprime(j))\\n                    s.insert(j);\\n        }return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042525,
                "title": "video-sieve-of-eratosthenes-or-set-method",
                "content": "# Approach\\n\\nI was looking to simplify the code for readability, but the edit page for posts can be very laggy recently for me- I\\'m not sure what\\'s going on. Also Javascript comments look pretty wonky compared to Python (in the updated UI).\\n\\nBasically, the simple idea is that we want to get the product of the array and check it against all the prime numbers. For each prime number that our product is fully divisible by, we can increment a count. I use a helper method using The Sieve of Eratosthenes to get an array of all primes and just set that as a global variable. \\n\\nThe idea of Sieve of Eratosthenes is super simple! Here is an awesome 5 minute video that explains it:\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/V08g_lkKj6Q\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\nSorry - I would like to edit further, but this lag is making it very hard. Will check back later. \\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\n\\n/* helper to create an array of\\n * primes to keep as a global \\n * array \\n */\\nfunction sieveOfEratosthenes() {\\n    const array = Array(1000 + 1).fill(true)\\n    for (let x = 2; x < Math.floor(Math.sqrt(1000) + 1); x++) {\\n        if (!array[x]) continue\\n        let y = x + x\\n        while (y <= 1000) {\\n            array[y] = false\\n            y += x\\n        }\\n    }\\n    const map = []\\n    for (let i = 0; i < array.length; i++) {\\n        if (array[i]) map.push(i)\\n    }\\n\\n    console.log(map)\\n    return map\\n}\\n\\n// removed zero and one manually\\nconst sieveArr = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]\\n\\n// Using Sieve (remove Sieve from function name to run)\\n\\n/** \\n *  Multiplies all numbers and casts the variable into a big int.\\n *  Then iterates through all prime numbers and checks if the big\\n *  int modulo the prime is 0.\\n */\\nvar distinctPrimeFactorsSieve = function(nums, p = nums.reduce((a, b) => a * BigInt(b), 1n), c = 0) {\\n    for (let prime of sieveArr) if (p % BigInt(prime) == 0) c++\\n    return c\\n};\\n\\n/** set method -\\n *  instead of multiplying all of the nums and checking\\n *  if the large number modulo a prime is 0, we break \\n *  down each number from 2 (smallest prime) in nums \\n *  and add it to a set as we are guaranteed to see duplicates\\n */\\nvar distinctPrimeFactors = function(nums, set = new Set()) {\\n    for (let x of nums) {\\n        let y = 2\\n        while (y * y <= x) {\\n            if (x % y == 0) { // less strict equals -> faster runtime?\\n                set.add(y), x /= y, y = 2\\n                continue\\n            }\\n            y++\\n        }\\n        if (x > 1) set.add(x)\\n    }\\n    return set.size\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\n\\n/* helper to create an array of\\n * primes to keep as a global \\n * array \\n */\\nfunction sieveOfEratosthenes() {\\n    const array = Array(1000 + 1).fill(true)\\n    for (let x = 2; x < Math.floor(Math.sqrt(1000) + 1); x++) {\\n        if (!array[x]) continue\\n        let y = x + x\\n        while (y <= 1000) {\\n            array[y] = false\\n            y += x\\n        }\\n    }\\n    const map = []\\n    for (let i = 0; i < array.length; i++) {\\n        if (array[i]) map.push(i)\\n    }\\n\\n    console.log(map)\\n    return map\\n}\\n\\n// removed zero and one manually\\nconst sieveArr = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]\\n\\n// Using Sieve (remove Sieve from function name to run)\\n\\n/** \\n *  Multiplies all numbers and casts the variable into a big int.\\n *  Then iterates through all prime numbers and checks if the big\\n *  int modulo the prime is 0.\\n */\\nvar distinctPrimeFactorsSieve = function(nums, p = nums.reduce((a, b) => a * BigInt(b), 1n), c = 0) {\\n    for (let prime of sieveArr) if (p % BigInt(prime) == 0) c++\\n    return c\\n};\\n\\n/** set method -\\n *  instead of multiplying all of the nums and checking\\n *  if the large number modulo a prime is 0, we break \\n *  down each number from 2 (smallest prime) in nums \\n *  and add it to a set as we are guaranteed to see duplicates\\n */\\nvar distinctPrimeFactors = function(nums, set = new Set()) {\\n    for (let x of nums) {\\n        let y = 2\\n        while (y * y <= x) {\\n            if (x % y == 0) { // less strict equals -> faster runtime?\\n                set.add(y), x /= y, y = 2\\n                continue\\n            }\\n            y++\\n        }\\n        if (x > 1) set.add(x)\\n    }\\n    return set.size\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3035682,
                "title": "easiest-sieve-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isprime(int num){\\n        bool flag=true;\\n        for(int i=2;i<num;i++){\\n            if(num%i==0)\\n                flag=false;\\n        }\\n        return flag;\\n    }\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        vector<int> prime;\\n        for(int i=2;i<=1000;i++){\\n            if(isprime(i)){\\n                prime.push_back(i);\\n            }\\n        }\\n        set<int> st;\\n        for(int n:nums){\\n            for(int p:prime){\\n                if(n%p==0){\\n                    st.insert(p);\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isprime(int num){\\n        bool flag=true;\\n        for(int i=2;i<num;i++){\\n            if(num%i==0)\\n                flag=false;\\n        }\\n        return flag;\\n    }\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        vector<int> prime;\\n        for(int i=2;i<=1000;i++){\\n            if(isprime(i)){\\n                prime.push_back(i);\\n            }\\n        }\\n        set<int> st;\\n        for(int n:nums){\\n            for(int p:prime){\\n                if(n%p==0){\\n                    st.insert(p);\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021888,
                "title": "c-solution-easy-set-stl-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        unordered_set<int> s;\\n        for(int n:nums){\\n            for(int j = 2; j <= sqrt(n); j++) \\n            while(n % j == 0){\\n                s.insert(j);    \\n                n/=j;\\n            }  \\n            if(n>1)\\n                s.insert(n);                   \\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        unordered_set<int> s;\\n        for(int n:nums){\\n            for(int j = 2; j <= sqrt(n); j++) \\n            while(n % j == 0){\\n                s.insert(j);    \\n                n/=j;\\n            }  \\n            if(n>1)\\n                s.insert(n);                   \\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006913,
                "title": "prime-number-sieve-algorithm-2-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSieve algorithm, prime numbers\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*sqrt(maxno)*log(maxno))$$ , n = nums.size(), maxno = max num in nums\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(no of prime factors)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        int n = nums.size();\\n        set<int> st;\\n    for(int i=0;i<n;i++){\\n        int num = nums[i];\\n        for(int i=2;i*i<=num;i++){\\n            while(num%i==0){\\n                st.insert(i);\\n                num = num/i;\\n            }\\n        }\\n        if(num>1)st.insert(num);\\n    }\\n    return st.size();\\n    }\\n};\\n```\\n\\n//Runtime Error -> 64/87 (memory exceeds when nums is so large)\\n\\n```\\nclass Solution {\\nprivate:\\nconst int N = (int) 1e6+5;\\nvector<int> sieve(int n){\\n    vector<int> prime(N,1);\\n    for(int i=2;i*i<=N;i++){\\n        if(prime[i]){\\n            for(int j=i*i;j<N;j+=i){\\n                prime[j] = 0;\\n            }\\n        }\\n    }\\n    vector<int> v;\\n    for(int i=2;i<N;i++)if(prime[i])v.push_back(i);\\n    return v;\\n}\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        int n = nums.size();\\n        long long pro = 1;\\n        for(int i=0;i<n;i++)pro*= nums[i];\\n        vector<int> prime = sieve(pro);\\n        set<int> st;\\n        for(int i=0;i<prime.size();i++){\\n            while(pro%prime[i]==0){\\n                st.insert(prime[i]);\\n                pro = pro/prime[i];\\n                if(pro==1)break;\\n            }\\n            if(pro==1)break;\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        int n = nums.size();\\n        set<int> st;\\n    for(int i=0;i<n;i++){\\n        int num = nums[i];\\n        for(int i=2;i*i<=num;i++){\\n            while(num%i==0){\\n                st.insert(i);\\n                num = num/i;\\n            }\\n        }\\n        if(num>1)st.insert(num);\\n    }\\n    return st.size();\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\nconst int N = (int) 1e6+5;\\nvector<int> sieve(int n){\\n    vector<int> prime(N,1);\\n    for(int i=2;i*i<=N;i++){\\n        if(prime[i]){\\n            for(int j=i*i;j<N;j+=i){\\n                prime[j] = 0;\\n            }\\n        }\\n    }\\n    vector<int> v;\\n    for(int i=2;i<N;i++)if(prime[i])v.push_back(i);\\n    return v;\\n}\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        int n = nums.size();\\n        long long pro = 1;\\n        for(int i=0;i<n;i++)pro*= nums[i];\\n        vector<int> prime = sieve(pro);\\n        set<int> st;\\n        for(int i=0;i<prime.size();i++){\\n            while(pro%prime[i]==0){\\n                st.insert(prime[i]);\\n                pro = pro/prime[i];\\n                if(pro==1)break;\\n            }\\n            if(pro==1)break;\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3004489,
                "title": "prime-factors",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\neasy Maths use prime factors formula\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst take each element prime factors and store in list then put all elements in set to remove duplicates return set size\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n*sqrt(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\nMD ARHAM KALAM ANSARI\\n```\\nclass Solution {\\npublic:\\n    void sol(int p,vector<int> &v)\\n    {\\n        while(p%2==0)\\n        {\\n            v.push_back(2);\\n            p=p/2;\\n        }\\n        for(int i=3;i<=sqrt(p);i=i+2)\\n        {\\n            while(p%i==0)\\n            {\\n                v.push_back(i);\\n                p=p/i;\\n            }\\n        }\\n        if(p>2)\\n        {\\n            v.push_back(p);\\n        }\\n        \\n    }\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        unordered_set<int> st;\\n        vector<int> v;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sol(nums[i],v);\\n        }\\n        for(int i:v) st.insert(i);\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sol(int p,vector<int> &v)\\n    {\\n        while(p%2==0)\\n        {\\n            v.push_back(2);\\n            p=p/2;\\n        }\\n        for(int i=3;i<=sqrt(p);i=i+2)\\n        {\\n            while(p%i==0)\\n            {\\n                v.push_back(i);\\n                p=p/i;\\n            }\\n        }\\n        if(p>2)\\n        {\\n            v.push_back(p);\\n        }\\n        \\n    }\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        unordered_set<int> st;\\n        vector<int> v;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sol(nums[i],v);\\n        }\\n        for(int i:v) st.insert(i);\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992724,
                "title": "c-sieve",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        set<int>st;\\n        vector<int>primes,v;\\n        vector<bool>mark(1001, 1);\\n        for(int i = 2; i <= 1000; i++){\\n            if(mark[i]){\\n                v.push_back(i);\\n                for(int k = i * i; k <= 1000; k+= i) mark[k] = 0;\\n            }\\n        }\\n        for(auto it: nums){\\n            for(int i = 0; i < v.size(); ++i){\\n                if(it % v[i] == 0) st.insert(v[i]);\\n            }\\n        }\\n    \\n        return (int)st.size();\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        set<int>st;\\n        vector<int>primes,v;\\n        vector<bool>mark(1001, 1);\\n        for(int i = 2; i <= 1000; i++){\\n            if(mark[i]){\\n                v.push_back(i);\\n                for(int k = i * i; k <= 1000; k+= i) mark[k] = 0;\\n            }\\n        }\\n        for(auto it: nums){\\n            for(int i = 0; i < v.size(); ++i){\\n                if(it % v[i] == 0) st.insert(v[i]);\\n            }\\n        }\\n    \\n        return (int)st.size();\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992551,
                "title": "c-easy-solution-using-set",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    set<int>s;\\n    void solve(int &num){\\n        \\n        int n = num;\\n        \\n        for(int i=2;i<=num;i++){\\n            if(n%i==0){\\n                while(n%i==0)\\n                {\\n                    n = n/i;\\n                }\\n                 s.insert(i);\\n            }\\n           if(n==1){\\n               return;\\n           }\\n        }\\n        \\n    }\\n    int distinctPrimeFactors(vector<int>& nums) {\\n       \\n       for(auto x:nums){\\n           solve(x);\\n       }\\n       return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<int>s;\\n    void solve(int &num){\\n        \\n        int n = num;\\n        \\n        for(int i=2;i<=num;i++){\\n            if(n%i==0){\\n                while(n%i==0)\\n                {\\n                    n = n/i;\\n                }\\n                 s.insert(i);\\n            }\\n           if(n==1){\\n               return;\\n           }\\n        }\\n        \\n    }\\n    int distinctPrimeFactors(vector<int>& nums) {\\n       \\n       for(auto x:nums){\\n           solve(x);\\n       }\\n       return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990952,
                "title": "simple-o-n-time-and-o-1-space-solution-in-c-using-sieve-of-eratosthenes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince the product of the elements will be a very large number (1000^(10^4)), it can\\'t be calculated and checked whether divisible by any prime number. So we have to check for each prime number, by checking with each element of array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPrime numbers between 1 to 1000 was calculated using sieve and then for each prime number, it was checked whether it is a factor of that element.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n\\tint distinctPrimeFactors(vector<int> &nums)\\n\\t{\\n\\t\\tvector<bool> isPrime(1001, 1); // Sieve of Eratosthenes\\n\\t\\tisPrime[0] = isPrime[1] = 0;\\n\\t\\tfor (int i = 2; i * i <= 1000; i++)\\n\\t\\t{\\n\\t\\t\\tfor (int j = i * i; j <= 1000; j += i)\\n\\t\\t\\t\\tisPrime[j] = 0;\\n\\t\\t}\\n\\t\\tint ans = 0;\\n\\t\\tfor (int i = 2; i <= 1000; i++)\\n\\t\\t{\\n\\t\\t\\tif (!isPrime[i])\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tfor (auto &x : nums)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (x % i == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\tint distinctPrimeFactors(vector<int> &nums)\\n\\t{\\n\\t\\tvector<bool> isPrime(1001, 1); // Sieve of Eratosthenes\\n\\t\\tisPrime[0] = isPrime[1] = 0;\\n\\t\\tfor (int i = 2; i * i <= 1000; i++)\\n\\t\\t{\\n\\t\\t\\tfor (int j = i * i; j <= 1000; j += i)\\n\\t\\t\\t\\tisPrime[j] = 0;\\n\\t\\t}\\n\\t\\tint ans = 0;\\n\\t\\tfor (int i = 2; i <= 1000; i++)\\n\\t\\t{\\n\\t\\t\\tif (!isPrime[i])\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tfor (auto &x : nums)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (x % i == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2987402,
                "title": "c-easy-approach-sieve-of-eratosthenes",
                "content": "v -> boolean vector that mark prime numbers as 1 and non prime numbers as 0\\nprime -> keep track of all prime numbers that multiply that numbers.\\n\\n# Code\\n```\\nvector<bool>v(10002,1);\\nvector<vector<int>>prime(10002);\\nclass Solution {\\n    void seive(){\\n        v[1]=false;\\n        for(int i=2;i<=(10001/2);i++){\\n            if(v[i]){\\n                for(int j=i*2;j<=10001;j+=i){\\n                    v[j] = false;\\n                    prime[j].push_back(i);\\n                }\\n            }\\n        }\\n    }\\n\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        static int i=0;\\n        if(i==0){\\n            seive();\\n            i++;\\n        }\\n        set<int> st;\\n        for(int i=0;i<nums.size();i++){\\n            if(v[nums[i]]) st.insert(nums[i]);\\n            else {\\n                for(auto val:prime[nums[i]]){\\n                    st.insert(val);\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nvector<bool>v(10002,1);\\nvector<vector<int>>prime(10002);\\nclass Solution {\\n    void seive(){\\n        v[1]=false;\\n        for(int i=2;i<=(10001/2);i++){\\n            if(v[i]){\\n                for(int j=i*2;j<=10001;j+=i){\\n                    v[j] = false;\\n                    prime[j].push_back(i);\\n                }\\n            }\\n        }\\n    }\\n\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        static int i=0;\\n        if(i==0){\\n            seive();\\n            i++;\\n        }\\n        set<int> st;\\n        for(int i=0;i<nums.size();i++){\\n            if(v[nums[i]]) st.insert(nums[i]);\\n            else {\\n                for(auto val:prime[nums[i]]){\\n                    st.insert(val);\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2984706,
                "title": "optimized-version-with-precomputation-o-n-168",
                "content": "We will precompute every prime number till 1000 and for every prime number we will see if it divides atleast 1 element in nums. Since, there are 168 prime numbers from 1 to 1000. It\\'s time complexity will be O(n*168 + constant time for precomputation) \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        int n=1e3;\\n        vector<bool> is_prime(n+1, true);\\n        vector<int> primes;\\n        is_prime[0] = is_prime[1] = false;\\n        for (int i = 2; i <= n; i++) {\\n            if (is_prime[i] && (long long)i * i <= n) {\\n                for (int j = i * i; j <= n; j += i)\\n                    is_prime[j] = false;\\n            }\\n        }\\n\\n        for(int i=2; i<n;i++){\\n            if(is_prime[i]) primes.push_back(i);\\n        }\\n\\n        int cnt = 0;\\n        for(auto i:primes){\\n            for(auto j:nums){\\n                if(j%i==0){\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        int n=1e3;\\n        vector<bool> is_prime(n+1, true);\\n        vector<int> primes;\\n        is_prime[0] = is_prime[1] = false;\\n        for (int i = 2; i <= n; i++) {\\n            if (is_prime[i] && (long long)i * i <= n) {\\n                for (int j = i * i; j <= n; j += i)\\n                    is_prime[j] = false;\\n            }\\n        }\\n\\n        for(int i=2; i<n;i++){\\n            if(is_prime[i]) primes.push_back(i);\\n        }\\n\\n        int cnt = 0;\\n        for(auto i:primes){\\n            for(auto j:nums){\\n                if(j%i==0){\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981566,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n        lis=[]\\n        for n in nums:\\n            for i in range(2,int(sqrt(n))+1):\\n                while(n%i==0):\\n                    n=n/i\\n                    lis.append(i)\\n            if(n!=1):\\n                lis.append(n)\\n\\n        return len(set(lis))\\n                                    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n        lis=[]\\n        for n in nums:\\n            for i in range(2,int(sqrt(n))+1):\\n                while(n%i==0):\\n                    n=n/i\\n                    lis.append(i)\\n            if(n!=1):\\n                lis.append(n)\\n\\n        return len(set(lis))\\n                                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981250,
                "title": "c-easy-to-understand-prime-factor",
                "content": "# upvote\\n\\nclass Solution {\\npublic:\\n    \\n    void primeFactors(long long int n,vector<int>&factor){\\n        int c=2;\\n        \\n        while(n>1){\\n            \\n            if(n%c==0){\\n            factor.push_back(c);\\n            n/=c;\\n            }\\n            \\n            else c++;\\n        }\\n    }\\n\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        \\n        long long int res=1;\\n        int count=0;\\n        \\n        vector<int>factor\\n            ;\\n        for(int i=0;i<nums.size();i++){\\n            primeFactors(nums[i],factor);\\n        }\\n        \\n        \\n        map<int,int>mapping;\\n        \\n        for(auto i : factor)\\n            mapping[i]++;\\n        \\n        return mapping.size();\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    void primeFactors(long long int n,vector<int>&factor){\\n        int c=2;\\n        \\n        while(n>1){\\n            \\n            if(n%c==0){\\n            factor.push_back(c);\\n            n/=c;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2980014,
                "title": "c-easy-beginer-friendly-easy-fast-solution-beginer",
                "content": "# Intuition\\nprine factor of the product would be equal to the individual prime factors of every number in the vector there for we count the number of disctinct prime factore of all the elements of the vector.\\n\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        map<int,int> m;\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            for(int j=2;j*j<=nums[i];++j)\\n            {\\n                int f=0;\\n                while(nums[i]%j==0)\\n                {\\n                    f=1;\\n                    nums[i]=nums[i]/j;\\n                }\\n                if(f==1)\\n                m[j]++;\\n            }\\n            if(nums[i]>1)\\n            m[nums[i]]++;\\n        }\\n        int ans =m.size();\\n        for(auto it:m)\\n        cout<<it.first;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        map<int,int> m;\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            for(int j=2;j*j<=nums[i];++j)\\n            {\\n                int f=0;\\n                while(nums[i]%j==0)\\n                {\\n                    f=1;\\n                    nums[i]=nums[i]/j;\\n                }\\n                if(f==1)\\n                m[j]++;\\n            }\\n            if(nums[i]>1)\\n            m[nums[i]]++;\\n        }\\n        int ans =m.size();\\n        for(auto it:m)\\n        cout<<it.first;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2979681,
                "title": "distinct-prime-factors-of-product-of-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first thing I saw was the constraits which was 10^4, So I knew I can easily use O(N^2) solution.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Collected all the primes in range of [1, 1000]. \\n2. while that number is divisible by same prime number, divide the number by prime number and store the prime number in the set. \\n3. If it is not divisible move to the next prime number. \\n4. return the size of the set which store the unique prime numbers.\\n# Complexity\\n- **Time complexity**: \\nT.C is O(N*\\u221AM *168) where N is the input array size and M is the number. \\n\\n- **Space complexity**: \\n- space required to store prime number between 1 to 1000 which is O(168) ~ to O(1).\\n- The max size the set can have is O(168) ~ O(1). This is O(1) as it doesn\\'t depends on the input size.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        HashSet<Integer> ans = new HashSet<>();\\n        int[] primes = new int[] {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199,211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293,307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397,401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499,503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599,\\t601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997};\\n        for(int num: nums){\\n            int index =0;\\n            while(num>1){\\n                if(num% primes[index]==0){\\n                   ans.add(primes[index]); \\n                    num/= primes[index];\\n                } else {\\n                    index++;\\n                }\\n            }\\n        }\\n        return ans.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        HashSet<Integer> ans = new HashSet<>();\\n        int[] primes = new int[] {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199,211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293,307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397,401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499,503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599,\\t601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997};\\n        for(int num: nums){\\n            int index =0;\\n            while(num>1){\\n                if(num% primes[index]==0){\\n                   ans.add(primes[index]); \\n                    num/= primes[index];\\n                } else {\\n                    index++;\\n                }\\n            }\\n        }\\n        return ans.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979507,
                "title": "c-using-set-and-prime-no-s-pre-computation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n*(number of primes))\\n\\n- Space complexity:\\nO(number of primes)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) \\n    {\\n        int i,j,maxno=nums[0],ans=0;\\n        for(i=1;i<nums.size();i++)\\n        {\\n            maxno=max(maxno,nums[i]);\\n        }\\n        vector<int>isprime(maxno+1,1);\\n        vector<int>primenos;\\n        for(i=2;i<isprime.size();i++)\\n        {\\n            if(isprime[i]==0)\\n            {\\n                continue;\\n            }\\n            primenos.push_back(i);\\n            j=2*i;           \\n            while(j<=isprime.size()-1)\\n            {\\n                isprime[j]=0;\\n                j+=i;\\n            }\\n        }\\n        unordered_set<int>uniqueprimenos;\\n        for(i=0;i<nums.size();i++)\\n        {\\n            for(j=0;j<primenos.size();j++)\\n            {\\n                if(primenos[j]>nums[i])\\n                {\\n                    break;\\n                }\\n                if(nums[i]%primenos[j]==0)\\n                {\\n                    uniqueprimenos.insert(primenos[j]);\\n                }\\n            }\\n        }\\n        return uniqueprimenos.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) \\n    {\\n        int i,j,maxno=nums[0],ans=0;\\n        for(i=1;i<nums.size();i++)\\n        {\\n            maxno=max(maxno,nums[i]);\\n        }\\n        vector<int>isprime(maxno+1,1);\\n        vector<int>primenos;\\n        for(i=2;i<isprime.size();i++)\\n        {\\n            if(isprime[i]==0)\\n            {\\n                continue;\\n            }\\n            primenos.push_back(i);\\n            j=2*i;           \\n            while(j<=isprime.size()-1)\\n            {\\n                isprime[j]=0;\\n                j+=i;\\n            }\\n        }\\n        unordered_set<int>uniqueprimenos;\\n        for(i=0;i<nums.size();i++)\\n        {\\n            for(j=0;j<primenos.size();j++)\\n            {\\n                if(primenos[j]>nums[i])\\n                {\\n                    break;\\n                }\\n                if(nums[i]%primenos[j]==0)\\n                {\\n                    uniqueprimenos.insert(primenos[j]);\\n                }\\n            }\\n        }\\n        return uniqueprimenos.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979331,
                "title": "golang-using-hashmap",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc distinctPrimeFactors(nums []int) int {\\n    hashmap := make(map[int]int)\\n\\tfor _, n := range nums {\\n\\t\\tfor i := 2; n > 1; i++ {\\n\\t\\t\\tfor n%i == 0 {\\n\\t\\t\\t\\thashmap[i]++\\n\\t\\t\\t\\tn = n / i\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn len(hashmap)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Hash Table"
                ],
                "code": "```\\nfunc distinctPrimeFactors(nums []int) int {\\n    hashmap := make(map[int]int)\\n\\tfor _, n := range nums {\\n\\t\\tfor i := 2; n > 1; i++ {\\n\\t\\t\\tfor n%i == 0 {\\n\\t\\t\\t\\thashmap[i]++\\n\\t\\t\\t\\tn = n / i\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn len(hashmap)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2978993,
                "title": "detailed-explanation-along-with-java-code",
                "content": "**Hi** , \\nIf we look at contraints we can easily figure this out that if we multiply all the numbers in array then \\n**10^3 + 10^3 + .... + 10^3 upto 10^4 \\nwhich is *10^(3X10^4)* , This number can\\'t fit in any primitive data type.**\\n\\nSo we have to think different approach . look at arrays then we can also find our ans if we go to every individual element of array and then find if number is divisible by any prime factor \\n\\nif number is divisible by any prime then modulo(%) must be equal to 0\\n\\nHow can we figure out that this is gonna be work , again look at contraints and define our approach\\'s constraints \\nso , if we go to every number of array\\'s element , we have to check whether this is multiple of any prime or not \\n\\n**so for this we can find out all possible prime factors upto 1000 . \\nwhy 1000?** \\n\\nbecause number can\\'t go beyond 1000 as contraint defined in this scope. \\nnow we can use **seive of eratosthenes** . This algo will take nlog(log(n)) time complexity.\\n\\nso we now have 168 prime numbers upto 1000 using seive method . we can store these 168 prime numbers in ArrayList<> or in vector<> . \\n\\nwe would check for every individual element of array if element is divisible by any prime number if yes , then we can increase our count variable and break the loop because we want to check for distinct prime , alright \\n\\n**So now what would be our constraints for this approach?**\\n168Xlength of array => 168X10^4  => 1.68 X 10^6 \\nThis solution is acceptable why?\\nbecause 10^4 in this constraints O(n^2) is acceptable but our approach\\'s constraints is quite low (better) than O(n^2) which is 10^4X2 => 10^8\\n\\nour approach is approximately 100 times faster than expected solution . \\n\\nIf we talk about space complexity : we are using arr[i]<=1000 boolean space , to check all primes upto 1000; \\nand we are also using 168 space in arraylist.\\nTC -> number of primes upto arr[i] * O(n);\\nSC -> O(n)\\n\\nbelow I\\'ve written code for the same approach , we discussed above.\\n\\nAny suggestion ? write in comments \\nThank you \\n\\n```\\n public int distinctPrimeFactors(int[] nums) {\\n       \\n        boolean[] isPrime = new boolean[1001];\\n        Arrays.fill(isPrime,true);\\n        int max = 0 ; \\n        for(int k : nums) max = Math.max(max,k);\\n        for(int i = 2 ; i*i <= max ; i++){\\n            for(int j = i*i ; j<=max ; j+=i){\\n                isPrime[j] = false ; \\n            }\\n        }\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i = 2 ; i <= max ; i++){\\n            if(isPrime[i]) al.add(i);\\n        }\\n        \\n        int count = 0 ; \\n        for(int k : al){\\n            for(int i = 0 ; i < nums.length ; i++){\\n                if(nums[i]%k==0) {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count ; \\n       }\\n```",
                "solutionTags": [],
                "code": "```\\n public int distinctPrimeFactors(int[] nums) {\\n       \\n        boolean[] isPrime = new boolean[1001];\\n        Arrays.fill(isPrime,true);\\n        int max = 0 ; \\n        for(int k : nums) max = Math.max(max,k);\\n        for(int i = 2 ; i*i <= max ; i++){\\n            for(int j = i*i ; j<=max ; j+=i){\\n                isPrime[j] = false ; \\n            }\\n        }\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i = 2 ; i <= max ; i++){\\n            if(isPrime[i]) al.add(i);\\n        }\\n        \\n        int count = 0 ; \\n        for(int k : al){\\n            for(int i = 0 ; i < nums.length ; i++){\\n                if(nums[i]%k==0) {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count ; \\n       }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2978885,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void printPrimeFactors(int n,unordered_set<int> &st) {\\n   while (n%2 == 0){\\n      //cout<<\"2\\\\t\";\\n       st.insert(2);\\n      n = n/2;\\n   }\\n   for (int i = 3; i <= sqrt(n); i = i+2){\\n      while (n%i == 0){\\n         //out<<i<<\"\\\\t\";\\n         n = n/i;\\n          st.insert(i);\\n      }\\n   }\\n   if (n > 2)\\n       st.insert(n);\\n  //cout<<n<<\"\\\\t\";\\n}\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        unordered_set<int> st;\\n        for( int i = 0 ; i <nums.size() ; ++i )\\n        {\\n            printPrimeFactors(nums[i],st);\\n           // cout<<endl;\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void printPrimeFactors(int n,unordered_set<int> &st) {\\n   while (n%2 == 0){\\n      //cout<<\"2\\\\t\";\\n       st.insert(2);\\n      n = n/2;\\n   }\\n   for (int i = 3; i <= sqrt(n); i = i+2){\\n      while (n%i == 0){\\n         //out<<i<<\"\\\\t\";\\n         n = n/i;\\n          st.insert(i);\\n      }\\n   }\\n   if (n > 2)\\n       st.insert(n);\\n  //cout<<n<<\"\\\\t\";\\n}\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        unordered_set<int> st;\\n        for( int i = 0 ; i <nums.size() ; ++i )\\n        {\\n            printPrimeFactors(nums[i],st);\\n           // cout<<endl;\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2978304,
                "title": "c-sieve-of-eratosthenes",
                "content": "**Approach**: In sieve of eratosthenes algo, store the latest prime factor of `i` in `Prime[i]` instead of bool value.\\n```\\nclass Solution {\\npublic:\\n    vector<int> prime;\\n    void find(){\\n        for(int i = 1; i<=1000;++i) prime[i] = i;\\n        for(int i = 2;i*i<=1000;++i){\\n            if(prime[i]!=i) continue;\\n            for(int j = i*i; j<=1000;j+=i) prime[j] = i; // store latest prime factor\\n        }\\n    }\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        prime = vector<int>(1001); find();\\n        unordered_set<int> st;\\n        for(int i = 0; i<nums.size();++i){\\n            int k = nums[i];\\n            while(k!=1){\\n                st.insert(prime[k]); k = k/prime[k];  //store all factors in a set\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> prime;\\n    void find(){\\n        for(int i = 1; i<=1000;++i) prime[i] = i;\\n        for(int i = 2;i*i<=1000;++i){\\n            if(prime[i]!=i) continue;\\n            for(int j = i*i; j<=1000;j+=i) prime[j] = i; // store latest prime factor\\n        }\\n    }\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        prime = vector<int>(1001); find();\\n        unordered_set<int> st;\\n        for(int i = 0; i<nums.size();++i){\\n            int k = nums[i];\\n            while(k!=1){\\n                st.insert(prime[k]); k = k/prime[k];  //store all factors in a set\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978294,
                "title": "easy-and-simple-c-solution",
                "content": "```\\nclass Solution {\\n    #define ll long long\\n    unordered_set<int> factors;\\n    void prime_factors(ll n) {\\n        ll N = sqrt(n);\\n        for (ll i = 2; i <= N; ++i) {\\n            while (n % i == 0) {\\n                factors.insert(i);\\n                n /= i;\\n            }\\n        }\\n        if (n > 1) factors.insert(n);\\n        \\n    }\\npublic:\\n    ll distinctPrimeFactors(vector<int>& nums) {\\n        ll num = 1;\\n        int n = nums.size();\\n        for (int i = 0; i < n; ++i) {\\n            prime_factors(nums[i]);\\n        }\\n        return factors.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long\\n    unordered_set<int> factors;\\n    void prime_factors(ll n) {\\n        ll N = sqrt(n);\\n        for (ll i = 2; i <= N; ++i) {\\n            while (n % i == 0) {\\n                factors.insert(i);\\n                n /= i;\\n            }\\n        }\\n        if (n > 1) factors.insert(n);\\n        \\n    }\\npublic:\\n    ll distinctPrimeFactors(vector<int>& nums) {\\n        ll num = 1;\\n        int n = nums.size();\\n        for (int i = 0; i < n; ++i) {\\n            prime_factors(nums[i]);\\n        }\\n        return factors.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977767,
                "title": "beats-100-explanation-codedominar-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n\\n        def is_prime(num):\\n            if num < 2:\\n                return False\\n            for i in range(2, int(sqrt(num))+1):\\n                if num % i == 0:\\n                    return False\\n            return True\\n\\n\\n        # Create a Counter to store the prime factors of each number\\n        prime_factors = Counter()\\n        \\n        # Find the prime factorization of each number\\n        for num in nums:\\n            # If the number is prime, add it to the Counter as a prime factor\\n            if is_prime(num):\\n                prime_factors[num] += 1\\n                continue\\n                \\n            # Otherwise, find the prime factors of the number\\n            for i in range(2, int(sqrt(num))+1):\\n                while num % i == 0:\\n                    prime_factors[i] += 1\\n                    num = num // i\\n                    \\n            # If there are any remaining prime factors, add them to the Counter\\n            if num > 1:\\n                prime_factors[num] += 1\\n                \\n        # Count the number of distinct prime factors\\n        return len(prime_factors)\\n\\n        \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n\\n        def is_prime(num):\\n            if num < 2:\\n                return False\\n            for i in range(2, int(sqrt(num))+1):\\n                if num % i == 0:\\n                    return False\\n            return True\\n\\n\\n        # Create a Counter to store the prime factors of each number\\n        prime_factors = Counter()\\n        \\n        # Find the prime factorization of each number\\n        for num in nums:\\n            # If the number is prime, add it to the Counter as a prime factor\\n            if is_prime(num):\\n                prime_factors[num] += 1\\n                continue\\n                \\n            # Otherwise, find the prime factors of the number\\n            for i in range(2, int(sqrt(num))+1):\\n                while num % i == 0:\\n                    prime_factors[i] += 1\\n                    num = num // i\\n                    \\n            # If there are any remaining prime factors, add them to the Counter\\n            if num > 1:\\n                prime_factors[num] += 1\\n                \\n        # Count the number of distinct prime factors\\n        return len(prime_factors)\\n\\n        \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977624,
                "title": "simple-java-code-run-time-15-ms-beats-100-of-the-solutions",
                "content": "# Code\\n```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) \\n    {\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        for(int i:nums)\\n        {\\n            if(i%2==0)\\n            {\\n                set.add(2);\\n                /* Until we get odd number the loop divides with prime number 2*/\\n                while(i%2==0)\\n                {\\n                    i=i/2;\\n                }\\n            }\\n            /* Now we have only have odd numbers upon above loop execution and now we divide with odd prime numbers*/\\n            for(int j=3;j<=Math.sqrt(i);j+=2) // j = j + 2 makes sure only odd numbers since initial value j = 3 is odd\\n            {\\n                while(i%j==0)\\n                {\\n                        set.add(j);           \\n                        i/=j;\\n                }\\n            }\\n            if(i>2) /* Now if we have the prime number greater than 2 then it is added to the set */\\n                set.add(i);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) \\n    {\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        for(int i:nums)\\n        {\\n            if(i%2==0)\\n            {\\n                set.add(2);\\n                /* Until we get odd number the loop divides with prime number 2*/\\n                while(i%2==0)\\n                {\\n                    i=i/2;\\n                }\\n            }\\n            /* Now we have only have odd numbers upon above loop execution and now we divide with odd prime numbers*/\\n            for(int j=3;j<=Math.sqrt(i);j+=2) // j = j + 2 makes sure only odd numbers since initial value j = 3 is odd\\n            {\\n                while(i%j==0)\\n                {\\n                        set.add(j);           \\n                        i/=j;\\n                }\\n            }\\n            if(i>2) /* Now if we have the prime number greater than 2 then it is added to the set */\\n                set.add(i);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977506,
                "title": "unordered-set",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n\\tunordered_set<int> m;\\n\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\tint sq = sqrt(nums[i]);\\n\\t\\tfor (int j = 2; j <= sq; j++) {\\n\\t\\t\\tif (nums[i] % j == 0) {\\n\\t\\t\\t\\tm.insert(j);\\n\\t\\t\\t\\twhile (nums[i] % j == 0) {\\n\\t\\t\\t\\t\\tnums[i] /= j;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (nums[i] > 1) {\\n\\t\\t\\tm.insert(nums[i]);\\n\\t\\t}\\n\\t}\\n\\treturn m.size();    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n\\tunordered_set<int> m;\\n\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\tint sq = sqrt(nums[i]);\\n\\t\\tfor (int j = 2; j <= sq; j++) {\\n\\t\\t\\tif (nums[i] % j == 0) {\\n\\t\\t\\t\\tm.insert(j);\\n\\t\\t\\t\\twhile (nums[i] % j == 0) {\\n\\t\\t\\t\\t\\tnums[i] /= j;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (nums[i] > 1) {\\n\\t\\t\\tm.insert(nums[i]);\\n\\t\\t}\\n\\t}\\n\\treturn m.size();    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977483,
                "title": "easy-to-understand-beats-90",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- first insert all the numbers in set(s) and initialize a global set(ss).\\n- find the prime factor of every element in set(s) and insert in ss.\\n\\n\\n- we are using set(s) so that we don\\'t find prime factors of same number again and again\\n- we are using set(ss) so that we don\\'t insert the prime factors again.\\n \\n# Code\\n```\\nclass Solution {\\npublic:\\n    set<int> ss;\\n    void Prime(int n){\\n        int c = 2;\\n        while(n > 1){\\n            while(n%c==0){\\n                n /= c;\\n                ss.insert(c);\\n            }\\n            c++;\\n        }\\n    }\\n    \\n    int distinctPrimeFactors(vector<int>& nums) {\\n        set<int> s;\\n        for(int i : nums) s.insert(i);\\n        \\n       for(int i : s){\\n            Prime(i);\\n        }    \\n    \\n        return ss.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<int> ss;\\n    void Prime(int n){\\n        int c = 2;\\n        while(n > 1){\\n            while(n%c==0){\\n                n /= c;\\n                ss.insert(c);\\n            }\\n            c++;\\n        }\\n    }\\n    \\n    int distinctPrimeFactors(vector<int>& nums) {\\n        set<int> s;\\n        for(int i : nums) s.insert(i);\\n        \\n       for(int i : s){\\n            Prime(i);\\n        }    \\n    \\n        return ss.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977451,
                "title": "c-easy-to-understand-beats-100",
                "content": "***If you find this helpful, Please Upvote \\uD83D\\uDD3C\\nThank You !***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // sending set by address\\n    void solve(int product, vector<int> &v, unordered_set<int> &s) {\\n        \\n        // always check from 1st prime number in vector \\'v\\'\\n        // that\\'s why \\'i\\' is initialized by \\'0\\'\\n        int i = 0;\\n        \\n        while(product) {\\n            \\n            // if divisible\\n            if(product % v[i] == 0) {\\n                \\n                s.insert(v[i]);\\n                \\n                while(product % v[i] == 0) {\\n                    product /= v[i];\\n                }\\n            }\\n            else { // else check for next prime number in vector \\'v\\'\\n                i++; // so increase \\'i\\' pointer\\n            }\\n            \\n            //product cant reach to \\'0\\'\\n            // so to come out of this \\'while\\' loop:\\n            if(product == 1) break; \\n        }   \\n    }\\n    \\n    int distinctPrimeFactors(vector<int>& nums) {\\n        \\n        // All prime numbers from 1 to 1000 are stored in vector \\'v\\'\\n        // prime numbers upto 1000 because in \\'Constraints\\' upper bound is 1000 (2 <= nums[i] <= 1000)\\n        vector<int> v = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 791, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997};\\n        \\n        unordered_set<int> s;\\n        \\n        for(int j=0; j<nums.size(); j++) {\\n            solve(nums[j], v, s);\\n        }\\n        \\n        return s.size();\\n    } \\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // sending set by address\\n    void solve(int product, vector<int> &v, unordered_set<int> &s) {\\n        \\n        // always check from 1st prime number in vector \\'v\\'\\n        // that\\'s why \\'i\\' is initialized by \\'0\\'\\n        int i = 0;\\n        \\n        while(product) {\\n            \\n            // if divisible\\n            if(product % v[i] == 0) {\\n                \\n                s.insert(v[i]);\\n                \\n                while(product % v[i] == 0) {\\n                    product /= v[i];\\n                }\\n            }\\n            else { // else check for next prime number in vector \\'v\\'\\n                i++; // so increase \\'i\\' pointer\\n            }\\n            \\n            //product cant reach to \\'0\\'\\n            // so to come out of this \\'while\\' loop:\\n            if(product == 1) break; \\n        }   \\n    }\\n    \\n    int distinctPrimeFactors(vector<int>& nums) {\\n        \\n        // All prime numbers from 1 to 1000 are stored in vector \\'v\\'\\n        // prime numbers upto 1000 because in \\'Constraints\\' upper bound is 1000 (2 <= nums[i] <= 1000)\\n        vector<int> v = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 791, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997};\\n        \\n        unordered_set<int> s;\\n        \\n        for(int j=0; j<nums.size(); j++) {\\n            solve(nums[j], v, s);\\n        }\\n        \\n        return s.size();\\n    } \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977446,
                "title": "python-o-nsqrt-n",
                "content": "# Complexity\\n- Time complexity: O(n*sqrt(n))\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int: \\n        def prime(a):\\n            ans = set()            \\n            for i in range (len(a)) :\\n                if a[i] == 2:\\n                    ans.add(2)\\n                    continue\\n                sqr = int(math.sqrt(a[i]))\\n                for j in range(2, sqr+1) :\\n                    if (a[i] % j == 0) :\\n                        ans.add(j)\\n                        while (a[i] % j == 0) :\\n                            a[i] //= j\\n                if (a[i] > 2) :\\n                    ans.add(a[i])\\n            return len(ans)\\n\\n        return prime(nums)\\n```\\n---------------\\n**Upvote the post if you find it helpful.\\nHappy coding.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int: \\n        def prime(a):\\n            ans = set()            \\n            for i in range (len(a)) :\\n                if a[i] == 2:\\n                    ans.add(2)\\n                    continue\\n                sqr = int(math.sqrt(a[i]))\\n                for j in range(2, sqr+1) :\\n                    if (a[i] % j == 0) :\\n                        ans.add(j)\\n                        while (a[i] % j == 0) :\\n                            a[i] //= j\\n                if (a[i] > 2) :\\n                    ans.add(a[i])\\n            return len(ans)\\n\\n        return prime(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977437,
                "title": "break-all-numbers",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   set<int> st;\\n   void primeFactors(int n){  \\n        while (n%2 == 0)st.insert(2),n = n/2;  \\n        for (int i = 3; i <= sqrt(n); i = i+2)\\n            while (n%i == 0)st.insert(i),n= n/i;  \\n        if (n > 2) st.insert(n); \\n    }  \\n    int distinctPrimeFactors(vector<int>& nums) {\\n        for(auto ele:nums)primeFactors(ele);\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   set<int> st;\\n   void primeFactors(int n){  \\n        while (n%2 == 0)st.insert(2),n = n/2;  \\n        for (int i = 3; i <= sqrt(n); i = i+2)\\n            while (n%i == 0)st.insert(i),n= n/i;  \\n        if (n > 2) st.insert(n); \\n    }  \\n    int distinctPrimeFactors(vector<int>& nums) {\\n        for(auto ele:nums)primeFactors(ele);\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977394,
                "title": "c-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n     // use set to store distinct factors\\n    unordered_set<int> mp;\\n \\n    // iterate over every element of array\\n    for (int i = 0; i < nums.size(); i++) {\\n        int sq = sqrt(nums[i]);\\n \\n        \\n        for (int j = 2; j <= sq; j++) {\\n            if (nums[i] % j == 0) {\\n \\n               \\n                mp.insert(j);\\n \\n              \\n                while (nums[i] % j == 0) {\\n                    nums[i] /= j;\\n                }\\n            }\\n        }\\n \\n        \\n        if (nums[i] > 1) {\\n            mp.insert(nums[i]);\\n        }\\n    }\\n \\n   \\n    return mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n     // use set to store distinct factors\\n    unordered_set<int> mp;\\n \\n    // iterate over every element of array\\n    for (int i = 0; i < nums.size(); i++) {\\n        int sq = sqrt(nums[i]);\\n \\n        \\n        for (int j = 2; j <= sq; j++) {\\n            if (nums[i] % j == 0) {\\n \\n               \\n                mp.insert(j);\\n \\n              \\n                while (nums[i] % j == 0) {\\n                    nums[i] /= j;\\n                }\\n            }\\n        }\\n \\n        \\n        if (nums[i] > 1) {\\n            mp.insert(nums[i]);\\n        }\\n    }\\n \\n   \\n    return mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977340,
                "title": "2521-distinct-prime-factors-of-product-of-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        Set<Integer> primeFactors = new HashSet<>();\\n        for (int num : nums) {\\n            // Factorize num into its prime factors\\n            int i = 2;\\n            while (num > 1) {\\n                if (num % i == 0) {\\n                    primeFactors.add(i);\\n                    num /= i;\\n                } else {\\n                    i++;\\n                }\\n            }\\n        }\\n        return primeFactors.size();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        Set<Integer> primeFactors = new HashSet<>();\\n        for (int num : nums) {\\n            // Factorize num into its prime factors\\n            int i = 2;\\n            while (num > 1) {\\n                if (num % i == 0) {\\n                    primeFactors.add(i);\\n                    num /= i;\\n                } else {\\n                    i++;\\n                }\\n            }\\n        }\\n        return primeFactors.size();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977327,
                "title": "c-easy-to-understand-simple-brute-force",
                "content": "**Just follow the 4 condition than u will be able to solve the question**\\n1. Create a unordered set  as it will store only unique value ;\\n2.  Iterate the given vector . If it is already prime just store into the set ;\\n3.  Other wise iterate the  number and check for all the Prime Numbers ;\\n4.   Just return the set size as answer. (*Create a isprime function seperately for conveinence*)\\n```\\nclass Solution\\n{\\npublic:\\n  int distinctPrimeFactors(vector<int> &nums)\\n  {\\n    unordered_set<long long> ans;\\n    for (auto &it : nums)\\n    {\\n      if (isp(it))\\n      {\\n        ans.insert(it);\\n      }\\n      else\\n      {\\n        for (int i = 2; i < it; i++)\\n        {\\n          if (it % i == 0 && isp(i) && it != i)\\n            ans.insert(i);\\n        }\\n      }\\n    }\\n    return ans.size();\\n  }\\n\\nprivate:\\n  bool isp(int num)\\n  {\\n    bool isPrime = true;\\n    for (int i = 2; i <= num / 2; i++)\\n    {\\n      if (num % i == 0)\\n      {\\n        isPrime = false;\\n        break;\\n      }\\n    }\\n    if (isPrime)\\n      return true;\\n    else\\n      return false;\\n  }\\n};\\n```\\n**Upvote if you find it Useful !**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n  int distinctPrimeFactors(vector<int> &nums)\\n  {\\n    unordered_set<long long> ans;\\n    for (auto &it : nums)\\n    {\\n      if (isp(it))\\n      {\\n        ans.insert(it);\\n      }\\n      else\\n      {\\n        for (int i = 2; i < it; i++)\\n        {\\n          if (it % i == 0 && isp(i) && it != i)\\n            ans.insert(i);\\n        }\\n      }\\n    }\\n    return ans.size();\\n  }\\n\\nprivate:\\n  bool isp(int num)\\n  {\\n    bool isPrime = true;\\n    for (int i = 2; i <= num / 2; i++)\\n    {\\n      if (num % i == 0)\\n      {\\n        isPrime = false;\\n        break;\\n      }\\n    }\\n    if (isPrime)\\n      return true;\\n    else\\n      return false;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977301,
                "title": "java-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse HashSet to find all distinct prime numbers\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind all the prime factors of the elements in array nums\\n\\n# Complexity\\n- Time complexity: O(N * Prime Factors of each num)\\n\\n- Space complexity: O(Distict Prime Factors of each num)\\n\\n# Code\\n```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        Set<Integer> set = new HashSet();\\n        //Find all the prime factors of the elements in array nums\\n        for (int num : nums) {\\n            for (int i = 2; i <= num; i++) {\\n                while (num % i == 0) {\\n                    set.add(i);\\n                    num = num / i;\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        Set<Integer> set = new HashSet();\\n        //Find all the prime factors of the elements in array nums\\n        for (int num : nums) {\\n            for (int i = 2; i <= num; i++) {\\n                while (num % i == 0) {\\n                    set.add(i);\\n                    num = num / i;\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977258,
                "title": "c-simple-solution",
                "content": "```\\nint distinctPrimeFactors(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        int count=0;\\n        for(int n : nums)\\n        {\\n            int i=2;\\n            while(n>1)\\n            {\\n                if(n%i==0){\\n                    mp[i]++;\\n                    n/=i;\\n                }\\n                else i++;\\n            }\\n        }\\n        return mp.size();\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint distinctPrimeFactors(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        int count=0;\\n        for(int n : nums)\\n        {\\n            int i=2;\\n            while(n>1)\\n            {\\n                if(n%i==0){\\n                    mp[i]++;\\n                    n/=i;\\n                }\\n                else i++;\\n            }\\n        }\\n        return mp.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2977251,
                "title": "c-explanation-clean",
                "content": "\\n**Happy New Year !!!**\\n\\n* **Approach** -\\n    1. Find out prime factors of each number and count unique prime factors that\\'s it!\\n* Time Complexity - `O(N* LOG(N))`\\n* Space Complextiy - `O(N)`\\n\\n**REQUEST** :\\xA0If you found this post even remotely helpful, be kind enough to smash a upvote. I will be grateful.\\n    \\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> factors; // store prime factors \\n    void primeFactors(int n) { \\n        while (n % 2 == 0) { \\n            factors[2]++; \\n            n = n/2; \\n        } \\n        for (int i = 3; i <= sqrt(n); i = i + 2) { \\n            while (n % i == 0) { \\n                factors[i]++;\\n                n = n/i; \\n            } \\n        } \\n        if (n > 2) factors[n]++;  // last prime factor greater than 2\\n    } \\n\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        for(int i = 0; i < nums.size(); i++)  primeFactors(nums[i]); // find out all prime factors of each number \\n        return (int)factors.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> factors; // store prime factors \\n    void primeFactors(int n) { \\n        while (n % 2 == 0) { \\n            factors[2]++; \\n            n = n/2; \\n        } \\n        for (int i = 3; i <= sqrt(n); i = i + 2) { \\n            while (n % i == 0) { \\n                factors[i]++;\\n                n = n/i; \\n            } \\n        } \\n        if (n > 2) factors[n]++;  // last prime factor greater than 2\\n    } \\n\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        for(int i = 0; i < nums.size(); i++)  primeFactors(nums[i]); // find out all prime factors of each number \\n        return (int)factors.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078236,
                "title": "prime-factorization-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\n\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n       const int N=1007;\\nint prime[N]={0};\\n\\n    for(int i=2;i<=1003;i++){\\n        prime[i]=i;\\n    }\\n for(int i=2;i<=1003;i++){\\n    if(prime[i]==i){\\n        for(int j=i*i;j<=1003;j+=i){\\n           if(prime[j]==j){\\n             prime[j]=i;\\n           }\\n        }\\n    }\\n   }\\n\\n        map<int,int>mp;\\n    for(int i=0;i<nums.size();i++){\\n       \\n        while(nums[i]!=1){\\n                mp[prime[nums[i]]]++;\\n        nums[i]/=prime[nums[i]];\\n\\n        }\\n    }\\n  return mp.size();\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n       const int N=1007;\\nint prime[N]={0};\\n\\n    for(int i=2;i<=1003;i++){\\n        prime[i]=i;\\n    }\\n for(int i=2;i<=1003;i++){\\n    if(prime[i]==i){\\n        for(int j=i*i;j<=1003;j+=i){\\n           if(prime[j]==j){\\n             prime[j]=i;\\n           }\\n        }\\n    }\\n   }\\n\\n        map<int,int>mp;\\n    for(int i=0;i<nums.size();i++){\\n       \\n        while(nums[i]!=1){\\n                mp[prime[nums[i]]]++;\\n        nums[i]/=prime[nums[i]];\\n\\n        }\\n    }\\n  return mp.size();\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036524,
                "title": "distinct-prime-factors-of-product-of-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        long pro =1;\\n        HashSet<Integer> hs = new HashSet<Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            pro=nums[i];\\n            while (pro % 2 == 0) {\\n            hs.add(2);\\n            pro /= 2;\\n        }\\n        for (int j = 3; j <= Math.sqrt(pro); j += 2) {\\n            while (pro % j == 0) {\\n                hs.add(j);\\n                pro /= j;\\n            }\\n        }\\n        if (pro > 2)\\n            hs.add((int)pro);\\n        }\\n        return hs.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        long pro =1;\\n        HashSet<Integer> hs = new HashSet<Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            pro=nums[i];\\n            while (pro % 2 == 0) {\\n            hs.add(2);\\n            pro /= 2;\\n        }\\n        for (int j = 3; j <= Math.sqrt(pro); j += 2) {\\n            while (pro % j == 0) {\\n                hs.add(j);\\n                pro /= j;\\n            }\\n        }\\n        if (pro > 2)\\n            hs.add((int)pro);\\n        }\\n        return hs.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031152,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code first finds all the prime numbers up to 1000. Then, for each number in the input array, it repeatedly divides the number by its prime factors and adds the prime factors to a set. The number of distinct prime factors is then returned.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a set to store the distinct prime factors.\\n2. Create an array of prime numbers up to 1000.\\n3. Initialize all the elements of the array to -1.\\n4. Find all prime numbers up to 1000.\\n    - For each number, if its prime factor is not yet found, mark it as a prime number and add it to the array.\\n5. For each number in the input array:\\n    - While the number is greater than 1:\\n        - Add the prime factor of the number to the set.\\n        - Divide the number by its prime factor.\\n6. Return the size of the set.\\n\\n# Complexity\\n- Time complexity: O(n + n * log n) = O(n * log n).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        // Create a set to store the distinct prime factors.\\n        HashSet<Integer> set = new HashSet<>();\\n\\n        // Create an array of prime numbers up to 1000.\\n        int[] prime = new int[1001];\\n        Arrays.fill(prime, -1);\\n\\n        // Find all prime numbers up to 1000.\\n        for(int i = 2; i < 1001; i++){\\n            if(prime[i] == -1){\\n                for(int j = i; j < 1001; j+=i){\\n                    if(prime[j] == -1){\\n                        prime[j] = i;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // For each number in the input array, add its prime factors to the set.\\n        for(int num: nums){\\n            while(num > 1){\\n                set.add(prime[num]);\\n                num /= prime[num];\\n            }\\n        }\\n\\n        // Return the size of the set.\\n        return set.size();\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        // Create a set to store the distinct prime factors.\\n        HashSet<Integer> set = new HashSet<>();\\n\\n        // Create an array of prime numbers up to 1000.\\n        int[] prime = new int[1001];\\n        Arrays.fill(prime, -1);\\n\\n        // Find all prime numbers up to 1000.\\n        for(int i = 2; i < 1001; i++){\\n            if(prime[i] == -1){\\n                for(int j = i; j < 1001; j+=i){\\n                    if(prime[j] == -1){\\n                        prime[j] = i;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // For each number in the input array, add its prime factors to the set.\\n        for(int num: nums){\\n            while(num > 1){\\n                set.add(prime[num]);\\n                num /= prime[num];\\n            }\\n        }\\n\\n        // Return the size of the set.\\n        return set.size();\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003984,
                "title": "brute-force-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The isPrime function checks if a given number n is prime by counting the number of divisors it has. If it has exactly one divisor (1), it is considered prime, and the function returns true.\\n\\n2. The distinctPrimeFactors function takes a vector of integers nums as input and aims to find the count of distinct prime factors across all elements in the vector.\\n\\n3. It initializes an empty set s to store the distinct prime factors.\\n\\n4. It then iterates through each element in the nums vector and calculates its distinct prime factors. For each element temp, it iterates from 1 to temp, checking if each number is a factor and whether it is a prime number using the isPrime function. If it is a prime factor, it adds it to the set s.\\n\\n5. Finally, it returns the size of the set s, which represents the count of distinct prime factors in all the elements of the input vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrime(int n) {\\n        int count = 0;\\n        for(int i=1;i<=n/2;i++) {\\n            if(n%i == 0)\\n                count++;\\n        }\\n\\n        return count == 1;\\n    }\\n\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        int n = nums.size();\\n        set<int> s;\\n\\n        for(int i=0;i<n;i++) {\\n            int temp = nums[i];\\n            int count = 0;\\n\\n            for(int j=1;j<=temp;j++) {\\n                if(temp%j == 0) {\\n                    if(isPrime(j)) {\\n                        s.insert(j);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int n) {\\n        int count = 0;\\n        for(int i=1;i<=n/2;i++) {\\n            if(n%i == 0)\\n                count++;\\n        }\\n\\n        return count == 1;\\n    }\\n\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        int n = nums.size();\\n        set<int> s;\\n\\n        for(int i=0;i<n;i++) {\\n            int temp = nums[i];\\n            int count = 0;\\n\\n            for(int j=1;j<=temp;j++) {\\n                if(temp%j == 0) {\\n                    if(isPrime(j)) {\\n                        s.insert(j);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984366,
                "title": "java-simple-approach-using-prime-factorization",
                "content": "\\n\\n# Approach\\nHere in this problem I am finding the prime factors for each element in given array and append them into Hashset \\n\\n# Complexity\\n- Time complexity:\\napproximately equal to  O(n * sqrt(n) * log(n))\\n\\n- Space complexity:\\nequal to the number of distinct primes in the product of numbers from given array   \\n\\n# Code\\n```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        # Inorder to avoid repetation of primes we use Hashset\\n        Set<Integer> set = new HashSet<>();\\n\\n        #for each element in given array find the primeFactors and add them into Hashset\\n        for (int num : nums) {\\n           addPrimes(num,set);\\n        }\\n        return set.size();\\n    }\\n\\n    #addPrimes is the function which is used  to find all the primes of a given no and append them into Hashset\\n   #The Time complexity of addPrimes is:(sqrt(n) * log(n)) \\n\\n    public void addPrimes(int n,Set<Integer> s){\\n        for(int div=2;div*div<=n;div++){\\n              while(n%div==0) {\\n                  n = n / div;\\n                  s.add(div);\\n              }\\n          }\\n          if(n!=1){\\n              s.add(n);\\n          }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        # Inorder to avoid repetation of primes we use Hashset\\n        Set<Integer> set = new HashSet<>();\\n\\n        #for each element in given array find the primeFactors and add them into Hashset\\n        for (int num : nums) {\\n           addPrimes(num,set);\\n        }\\n        return set.size();\\n    }\\n\\n    #addPrimes is the function which is used  to find all the primes of a given no and append them into Hashset\\n   #The Time complexity of addPrimes is:(sqrt(n) * log(n)) \\n\\n    public void addPrimes(int n,Set<Integer> s){\\n        for(int div=2;div*div<=n;div++){\\n              while(n%div==0) {\\n                  n = n / div;\\n                  s.add(div);\\n              }\\n          }\\n          if(n!=1){\\n              s.add(n);\\n          }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971677,
                "title": "golang-solution",
                "content": "# Code\\n```go\\nfunc distinctPrimeFactors(nums []int) int {\\n\\tprimes := make([]int, 0, 50)\\n\\tfor i := 2; i <= 1000; i++ {\\n\\t\\tif isPrime(i) {\\n\\t\\t\\tprimes = append(primes, i)\\n\\t\\t}\\n\\t}\\n\\tprimeFactor := make(map[int]struct{}, 16)\\n\\tfor _, v := range nums {\\n\\t\\tfor v != 1 {\\n\\t\\t\\tfor p := 0; p < len(primes); p++ {\\n\\t\\t\\t\\tif v % primes[p] == 0 {\\n\\t\\t\\t\\t\\tprimeFactor[primes[p]] = struct{}{}\\n\\t\\t\\t\\t\\tv /= primes[p]\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn len(primeFactor)\\n}\\n\\nfunc isPrime(v int) bool {\\n\\tswitch {\\n\\tcase v == 1:\\n\\t\\treturn false\\n\\tcase v <= 3:\\n\\t\\treturn true\\n\\tcase v%2 == 0:\\n\\t\\treturn false\\n\\tdefault:\\n\\t}\\n\\tfor i := 3; i*i <= v; i += 2 {\\n\\t\\tif v%i == 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc distinctPrimeFactors(nums []int) int {\\n\\tprimes := make([]int, 0, 50)\\n\\tfor i := 2; i <= 1000; i++ {\\n\\t\\tif isPrime(i) {\\n\\t\\t\\tprimes = append(primes, i)\\n\\t\\t}\\n\\t}\\n\\tprimeFactor := make(map[int]struct{}, 16)\\n\\tfor _, v := range nums {\\n\\t\\tfor v != 1 {\\n\\t\\t\\tfor p := 0; p < len(primes); p++ {\\n\\t\\t\\t\\tif v % primes[p] == 0 {\\n\\t\\t\\t\\t\\tprimeFactor[primes[p]] = struct{}{}\\n\\t\\t\\t\\t\\tv /= primes[p]\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn len(primeFactor)\\n}\\n\\nfunc isPrime(v int) bool {\\n\\tswitch {\\n\\tcase v == 1:\\n\\t\\treturn false\\n\\tcase v <= 3:\\n\\t\\treturn true\\n\\tcase v%2 == 0:\\n\\t\\treturn false\\n\\tdefault:\\n\\t}\\n\\tfor i := 3; i*i <= v; i += 2 {\\n\\t\\tif v%i == 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3943085,
                "title": "most-understandable-code-in-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        int n=1001;\\n        vector<int>prime(n+1,0);\\n        //sieve of eratosthenes\\n        for(int i=2;i<=n;i++){\\n            if(prime[i]==0){\\n                for(int j=i*i;j<=n;j+=i){\\n                     prime[j]=1;\\n                }\\n            }\\n        }\\n        vector<int>p;\\n        //// storing prime number in a vector\\n        for(int i=2;i<n;i++){\\n            if(prime[i]==0){\\n                p.push_back(i);\\n            }\\n        }\\n        int count=0;\\n        set<int>s;\\n        int j=0;\\n // checking individual prime factors of a particular element and push into set for avoid duplication\\n        for(int i=0;i<nums.size();i++){\\n            int org=nums[i];\\n            while(org!=1){\\n                if(org%p[j]==0){\\n                    org/=p[j];\\n                    s.insert(p[j]);\\n                }\\n                else{\\n                    j++;\\n                    \\n                }\\n            }\\n            j=0;\\n        }\\n    return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        int n=1001;\\n        vector<int>prime(n+1,0);\\n        //sieve of eratosthenes\\n        for(int i=2;i<=n;i++){\\n            if(prime[i]==0){\\n                for(int j=i*i;j<=n;j+=i){\\n                     prime[j]=1;\\n                }\\n            }\\n        }\\n        vector<int>p;\\n        //// storing prime number in a vector\\n        for(int i=2;i<n;i++){\\n            if(prime[i]==0){\\n                p.push_back(i);\\n            }\\n        }\\n        int count=0;\\n        set<int>s;\\n        int j=0;\\n // checking individual prime factors of a particular element and push into set for avoid duplication\\n        for(int i=0;i<nums.size();i++){\\n            int org=nums[i];\\n            while(org!=1){\\n                if(org%p[j]==0){\\n                    org/=p[j];\\n                    s.insert(p[j]);\\n                }\\n                else{\\n                    j++;\\n                    \\n                }\\n            }\\n            j=0;\\n        }\\n    return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941120,
                "title": "sieve-using-spf-array",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> spf;\\n    \\n    void sieve()\\n    {\\n        spf[1]=1;\\n        \\n        for(int i=2;i<=1000;i++)\\n            spf[i]=i;\\n        \\n        for(int i=4;i<=1000;i+=2)\\n            spf[i]=2;\\n        \\n        for(int i=3;i<=sqrt(1000);i++)\\n        {\\n            if(spf[i]==i)\\n            {\\n                for(int j=i*i;j<=1000;j+=i)\\n                {\\n                    if(spf[j]==j)\\n                        spf[j]=i;\\n                }\\n            }\\n        }\\n    }\\n    \\n    unordered_set<int> s;\\n    \\n    int distinctPrimeFactors(vector<int>& nums) {\\n        int n= nums.size();\\n        \\n        spf.resize(1001,0);\\n        sieve();\\n        \\n        for(auto num: nums)\\n        {\\n            while(num!=1)\\n            {\\n                s.insert(spf[num]);\\n                num/= spf[num];\\n            }\\n        }\\n        return s.size();\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> spf;\\n    \\n    void sieve()\\n    {\\n        spf[1]=1;\\n        \\n        for(int i=2;i<=1000;i++)\\n            spf[i]=i;\\n        \\n        for(int i=4;i<=1000;i+=2)\\n            spf[i]=2;\\n        \\n        for(int i=3;i<=sqrt(1000);i++)\\n        {\\n            if(spf[i]==i)\\n            {\\n                for(int j=i*i;j<=1000;j+=i)\\n                {\\n                    if(spf[j]==j)\\n                        spf[j]=i;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3922630,
                "title": "c-javascript-easy-solution",
                "content": "# Approach\\nJust count how many different prime numbers can evenly divide the elements in a list of numbers. It does this by finding the prime factors of each number and keeping track of the unique ones in a set.\\n\\n# Complexity\\n- Time complexity: O(n * sqrt(max(nums)))\\n\\n- Space complexity: Depends on the number of distinct prime factors in the input.\\n\\n# Code\\n# C++\\n```\\nclass Solution {\\npublic:\\n    set<int>st;\\n    void primeFact(int n){\\n        while(n%2==0){\\n            st.insert(2);\\n            n/=2;\\n        }\\n        int ans=sqrt(n);\\n        for(int i=3;i<=ans;i+=2){\\n            while(n%i==0){\\n                st.insert(i);\\n                n/=i;\\n            }\\n        }\\n        if(n>2) st.insert(n);\\n    }\\n    int distinctPrimeFactors(vector<int>& nums) {\\n       for(int i=0;i<nums.size();i++){\\n           primeFact(nums[i]);\\n       }\\n       return st.size();\\n    }\\n};\\n\\n```\\n\\n---\\n\\n\\n# JavaScript\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar distinctPrimeFactors = function(nums) {\\n    st = new Set();\\n    const primeFact=(n)=>{\\n        while(n%2==0){\\n            st.add(2);\\n            n/=2;\\n        }\\n        let ans=Math.sqrt(n);\\n        for(let i=3;i<=ans;i+=2){\\n            while(n%i==0){\\n                st.add(i);\\n                n/=i;\\n            }\\n        }\\n        if(n>2) st.add(n);\\n    }\\n\\n    for(let i=0;i<nums.length;i++){\\n        primeFact(nums[i]);\\n    }\\n    return st.size;\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "JavaScript",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<int>st;\\n    void primeFact(int n){\\n        while(n%2==0){\\n            st.insert(2);\\n            n/=2;\\n        }\\n        int ans=sqrt(n);\\n        for(int i=3;i<=ans;i+=2){\\n            while(n%i==0){\\n                st.insert(i);\\n                n/=i;\\n            }\\n        }\\n        if(n>2) st.insert(n);\\n    }\\n    int distinctPrimeFactors(vector<int>& nums) {\\n       for(int i=0;i<nums.size();i++){\\n           primeFact(nums[i]);\\n       }\\n       return st.size();\\n    }\\n};\\n\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar distinctPrimeFactors = function(nums) {\\n    st = new Set();\\n    const primeFact=(n)=>{\\n        while(n%2==0){\\n            st.add(2);\\n            n/=2;\\n        }\\n        let ans=Math.sqrt(n);\\n        for(let i=3;i<=ans;i+=2){\\n            while(n%i==0){\\n                st.add(i);\\n                n/=i;\\n            }\\n        }\\n        if(n>2) st.add(n);\\n    }\\n\\n    for(let i=0;i<nums.length;i++){\\n        primeFact(nums[i]);\\n    }\\n    return st.size;\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922625,
                "title": "i-am-share-my-seive-based-solution",
                "content": "# Intuition\\n\\nFigure out all the prime numbers using a seive and then for each number,\\ncheck if it is divisible by some elements in the seive.\\n\\n\\n# Complexity\\n- Time complexity: O(n) for seive and O(log n) for the solution\\n\\n- Space complexity: O(n) or actually O(sqrt n)\\n\\n# Code\\n```\\nimport java.util.HashSet;\\nimport java.util.Set;\\n\\nclass Solution {\\n    int[] seive = new int[10000];\\n    Set<Integer> set = new HashSet<>();\\n\\n    public int distinctPrimeFactors(int[] nums) {\\n        createSeive();\\n\\n        for (int num : nums) {\\n            addFactors(num);\\n        }\\n\\n        return set.size();\\n    }\\n\\n    void createSeive() {\\n        int[] temp = new int[10000];\\n        temp[2] = 1;\\n        temp[3] = 1;\\n        Arrays.fill(temp, 1);\\n        int i = 2;\\n        while (i < 10000) {\\n            if (temp[i] == 1) {\\n                for (int j = i + i; j < 10000; j = j + i) {\\n                    temp[j] = 0;\\n                }\\n            }\\n            i++;\\n        }\\n\\n        int index = 0;\\n        for (i = 2; i < temp.length; i++) {\\n            if (temp[i] == 1) {\\n                seive[index++] = i;\\n            }\\n        }\\n\\n    }\\n\\n    void addFactors(int num) {\\n        for (int i = 0; i < seive.length; i++) {\\n            if (seive[i] > num || seive[i] == 0) {\\n                break;\\n            }\\n            if (num % seive[i] == 0)\\n                set.add(seive[i]);\\n        }\\n\\n    }\\n\\n    public static void main(String[] args) {\\n        Solution solution = new Solution();\\n        solution.distinctPrimeFactors(new int[]{2, 4, 3, 7, 10, 6});\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.HashSet;\\nimport java.util.Set;\\n\\nclass Solution {\\n    int[] seive = new int[10000];\\n    Set<Integer> set = new HashSet<>();\\n\\n    public int distinctPrimeFactors(int[] nums) {\\n        createSeive();\\n\\n        for (int num : nums) {\\n            addFactors(num);\\n        }\\n\\n        return set.size();\\n    }\\n\\n    void createSeive() {\\n        int[] temp = new int[10000];\\n        temp[2] = 1;\\n        temp[3] = 1;\\n        Arrays.fill(temp, 1);\\n        int i = 2;\\n        while (i < 10000) {\\n            if (temp[i] == 1) {\\n                for (int j = i + i; j < 10000; j = j + i) {\\n                    temp[j] = 0;\\n                }\\n            }\\n            i++;\\n        }\\n\\n        int index = 0;\\n        for (i = 2; i < temp.length; i++) {\\n            if (temp[i] == 1) {\\n                seive[index++] = i;\\n            }\\n        }\\n\\n    }\\n\\n    void addFactors(int num) {\\n        for (int i = 0; i < seive.length; i++) {\\n            if (seive[i] > num || seive[i] == 0) {\\n                break;\\n            }\\n            if (num % seive[i] == 0)\\n                set.add(seive[i]);\\n        }\\n\\n    }\\n\\n    public static void main(String[] args) {\\n        Solution solution = new Solution();\\n        solution.distinctPrimeFactors(new int[]{2, 4, 3, 7, 10, 6});\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911454,
                "title": "sieve-of-erasthosenes",
                "content": "Precalculate the prime factors for all the numebrs using a big array of size 10002 and then get th prime factors easily. \\n\\nTime - O(N*Log(N))\\nSpace - O( 10002 ) \\n# Code\\n```\\nclass Solution {\\n    int[] arr ; \\n    boolean done = false ; \\n    public int distinctPrimeFactors(int[] nums) {\\n        if( done == false ){\\n            int limit = 10002 ; \\n            arr = new int[limit ] ; \\n            boolean temp[] = new boolean[limit]  ; \\n            for(  int i = 2 ; i <  limit ; i++){\\n                if( temp[i] ) continue  ; \\n                int j = i ;\\n                int p = j ;  \\n                while( j < limit ){\\n                    arr[j]= i ; \\n                    temp[j] = true ; \\n                    j  += p ; \\n                }\\n            }\\n            done = true ; \\n        }\\n        HashSet<Integer> set = new HashSet<>() ; \\n        for( int k : nums ){\\n            int ele = k ; \\n            while( ele > 1 )\\n             {\\n                 set.add( arr[ele]) ; \\n                 ele = ele / arr[ele] ; \\n\\n             }\\n        }\\n        return set.size() ; \\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] arr ; \\n    boolean done = false ; \\n    public int distinctPrimeFactors(int[] nums) {\\n        if( done == false ){\\n            int limit = 10002 ; \\n            arr = new int[limit ] ; \\n            boolean temp[] = new boolean[limit]  ; \\n            for(  int i = 2 ; i <  limit ; i++){\\n                if( temp[i] ) continue  ; \\n                int j = i ;\\n                int p = j ;  \\n                while( j < limit ){\\n                    arr[j]= i ; \\n                    temp[j] = true ; \\n                    j  += p ; \\n                }\\n            }\\n            done = true ; \\n        }\\n        HashSet<Integer> set = new HashSet<>() ; \\n        for( int k : nums ){\\n            int ele = k ; \\n            while( ele > 1 )\\n             {\\n                 set.add( arr[ele]) ; \\n                 ele = ele / arr[ele] ; \\n\\n             }\\n        }\\n        return set.size() ; \\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895306,
                "title": "c-brute-force-unordered-set",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n  \\nbool isPrime(int n)\\n{\\n    if (n <= 1)return false;\\n    for (int i = 2; i <= n / 2; i++){\\n        if (n % i == 0)return false;\\n    }\\n    return true;\\n}\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        int counti=0;\\n        unordered_set<int>us;\\n        for(int i=0;i<nums.size();i++){\\n            if(us.find(nums[i])==us.end()){\\n                for(int j=1;j<=nums[i];j++){\\n                    if(nums[i]%j==0&&isPrime(j)&&us.find(j)==us.end()){\\n                        counti++;\\n                        us.insert(j);\\n                    }\\n                }\\n            }\\n        }\\n        return counti;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\nbool isPrime(int n)\\n{\\n    if (n <= 1)return false;\\n    for (int i = 2; i <= n / 2; i++){\\n        if (n % i == 0)return false;\\n    }\\n    return true;\\n}\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        int counti=0;\\n        unordered_set<int>us;\\n        for(int i=0;i<nums.size();i++){\\n            if(us.find(nums[i])==us.end()){\\n                for(int j=1;j<=nums[i];j++){\\n                    if(nums[i]%j==0&&isPrime(j)&&us.find(j)==us.end()){\\n                        counti++;\\n                        us.insert(j);\\n                    }\\n                }\\n            }\\n        }\\n        return counti;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885367,
                "title": "sieve-of-eratosthenes",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        vector<int> v,prime(1001,1);\\n        for(int i=2; i<=1000; i++){\\n            if(prime[i]){\\n                v.push_back(i);\\n                for(int j=i*i; j<=1000; j+=i){\\n                    prime[j]=0;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(auto x: v){\\n            for(auto y: nums){\\n                if(y%x==0){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        vector<int> v,prime(1001,1);\\n        for(int i=2; i<=1000; i++){\\n            if(prime[i]){\\n                v.push_back(i);\\n                for(int j=i*i; j<=1000; j+=i){\\n                    prime[j]=0;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(auto x: v){\\n            for(auto y: nums){\\n                if(y%x==0){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866164,
                "title": "number-theory-prime-factors",
                "content": "# Intuition:\\nIterate through each element of nums find its prime factors and store in the set and return size of set\\n\\n# Complexity\\n- Time complexity: N(sqrt(N))\\n\\n\\n# Code\\n```\\nclass Solution {\\n    void primes(int n, set<int>&st){\\n        if(n%2==0){\\n            st.insert(2);\\n            while(n%2==0){\\n                n/=2;\\n            }\\n        }\\n        for(int i=3; i<=sqrt(n); i+=2){\\n            if(n%i==0) st.insert(i);\\n            while(n%i==0) n/=i;\\n        }\\n        if(n>2){\\n            st.insert(n);\\n        }\\n    }\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        set<int> st;\\n        for(auto it: nums){\\n            primes(it, st);\\n        }\\n        return st.size();\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void primes(int n, set<int>&st){\\n        if(n%2==0){\\n            st.insert(2);\\n            while(n%2==0){\\n                n/=2;\\n            }\\n        }\\n        for(int i=3; i<=sqrt(n); i+=2){\\n            if(n%i==0) st.insert(i);\\n            while(n%i==0) n/=i;\\n        }\\n        if(n>2){\\n            st.insert(n);\\n        }\\n    }\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        set<int> st;\\n        for(auto it: nums){\\n            primes(it, st);\\n        }\\n        return st.size();\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857741,
                "title": "java-hashset-solution",
                "content": "\\n# Code\\n```\\nimport java.util.HashSet;\\n\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        HashSet<Integer>set=new HashSet<>();\\n        for(int n:nums){\\n            for(int i=2;i*i<=n;i++){\\n                if(n%i==0){\\n                    while(n%i==0){\\n                        n=n/i;\\n                    set.add(i);\\n                    }\\n                }\\n            }\\n            if(n>1){\\n                set.add(n);\\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.HashSet;\\n\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        HashSet<Integer>set=new HashSet<>();\\n        for(int n:nums){\\n            for(int i=2;i*i<=n;i++){\\n                if(n%i==0){\\n                    while(n%i==0){\\n                        n=n/i;\\n                    set.add(i);\\n                    }\\n                }\\n            }\\n            if(n>1){\\n                set.add(n);\\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848178,
                "title": "brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        vector<int>v;   int n;\\n     for(int i=0;i<nums.size();i++){\\n       //  n = n*nums[i]; \\n         n = nums[i];\\n        \\n       while (n % 2 == 0)\\n    {\\n        v.push_back(2); \\n        n = n/2;\\n    }\\n \\n    for (int i = 3; i <= sqrt(n); i = i + 2)\\n    {\\n        \\n        while (n % i == 0)\\n        {\\n           v.push_back(i); \\n            n = n/i;\\n        }\\n    }\\n          if(n>2)v.push_back(n);\\n     }\\n      \\n    map<int,int>mp;\\n        for(int i=0;i<v.size();i++){\\n         mp[v[i]]++; \\n        }\\n        \\n      return mp.size();  \\n    \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        vector<int>v;   int n;\\n     for(int i=0;i<nums.size();i++){\\n       //  n = n*nums[i]; \\n         n = nums[i];\\n        \\n       while (n % 2 == 0)\\n    {\\n        v.push_back(2); \\n        n = n/2;\\n    }\\n \\n    for (int i = 3; i <= sqrt(n); i = i + 2)\\n    {\\n        \\n        while (n % i == 0)\\n        {\\n           v.push_back(i); \\n            n = n/i;\\n        }\\n    }\\n          if(n>2)v.push_back(n);\\n     }\\n      \\n    map<int,int>mp;\\n        for(int i=0;i<v.size();i++){\\n         mp[v[i]]++; \\n        }\\n        \\n      return mp.size();  \\n    \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847699,
                "title": "c-using-set",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n// \\uD83D\\uDC49 function to get all prime factor of a number.\\n\\nvoid prime(int nums,set<int>&st){\\n     for(int i=2;i*i<=nums;i++){\\n            while(nums%i==0){\\n                st.insert(i);\\n                nums/=i;\\n            }\\n        }\\n        if(nums>1)st.insert(nums);\\n}\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        // int cnt=0;\\n       set<int>st;\\n       for(int i=0;i<nums.size();i++){\\n           prime(nums[i],st);\\n       }\\n       int ans=st.size();\\n        return ans;\\n    }\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/0b2240a7-fd13-45f9-9466-a76b2d489a7f_1690889445.1563203.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// \\uD83D\\uDC49 function to get all prime factor of a number.\\n\\nvoid prime(int nums,set<int>&st){\\n     for(int i=2;i*i<=nums;i++){\\n            while(nums%i==0){\\n                st.insert(i);\\n                nums/=i;\\n            }\\n        }\\n        if(nums>1)st.insert(nums);\\n}\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        // int cnt=0;\\n       set<int>st;\\n       for(int i=0;i<nums.size();i++){\\n           prime(nums[i],st);\\n       }\\n       int ans=st.size();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835468,
                "title": "distinct-prime-factors-c-solutions-different-approaches-go-lang-optimized-solution",
                "content": "For this problem, the time complexity are little bit confusing, dont focus on them too much.\\n# C++ Code\\n```\\n//***************************************** Approach 1 Code *****************************************/\\n// TC : O(p)\\n// SC : O(p)\\n// Here \"p\" is the product of all the values of nums. p >>> n\\n// Memory wont be sufficient\\n\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        int n = 1;\\n        for(int i = 0; i < nums.size(); i++) {\\n            n *= nums[i];\\n        }\\n        vector<int> leastPrime(n + 1);\\n        for(int i = 2; i <= n; i++) {\\n            leastPrime[i] = i;\\n        }\\n        for(int i = 2; i * i <= n; i++) {\\n            if(leastPrime[i] == i) {\\n                for(int j = i * i; j <= n; j += i) {\\n                    if(leastPrime[j] == j) {\\n                        leastPrime[j] = i;\\n                    }\\n                }\\n            }\\n        }\\n        map<int, int> primeFactors;\\n        while(n > 1) {\\n            int p = leastPrime[n];\\n            primeFactors[p]++;\\n            n /= p;\\n        }\\n        return primeFactors.size();\\n    }\\n};\\n\\n//***************************************** Approach 2 Code *****************************************/\\n// TC : O(p), p is the product and it is much greater than the value of n\\n// SC : O(1)\\n// Fixed Memory issue.\\n// signed integer overflow: 21092400 * 780 cannot be represented in type \\'int\\'. \\n// So this logic and above logic works when product does not exceed the limit of int or long\\n\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        int n = 1;\\n        for(int i = 0; i < nums.size(); i++) {\\n            n *= nums[i];\\n        }\\n        vector<int> primeFactors;\\n        for(int i = 2; i * i <= n; i++) {\\n            if(n % i == 0) {\\n                primeFactors.push_back(i);\\n                while(n % i == 0) {\\n                    n = n / i;\\n                }\\n            }\\n        }\\n        if(n > 1) {\\n            primeFactors.push_back(n);\\n        }\\n        return primeFactors.size();\\n    }\\n};\\n\\n//***************************************** Approach 3 Code *****************************************/\\n// TC : O(n * (maxno*log(log(maxno))) + c * p) \\n// SC : O(maxno + p),  maxno is the maximum number in nums and p is the no of distinct prime factors\\n// Fix of Approach 1 code and it is a working solution\\n\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        unordered_set<int> s;\\n        int n;\\n        for(int k = 0; k < nums.size(); k++) {\\n            n = nums[k];      \\n            vector<int> leastPrime(n + 1);\\n            for(int i = 2; i <= n; i++) {\\n                leastPrime[i] = i;\\n            }\\n            for(int i = 2; i * i <= n; i++) {\\n                if(leastPrime[i] == i) {\\n                    for(int j = i * i; j <= n; j += i) {\\n                        if(leastPrime[j] == j) {\\n                            leastPrime[j] = i;\\n                        }\\n                    }\\n                }\\n            }\\n            map<int, int> primeFactors;\\n            while(n > 1) {\\n                int p = leastPrime[n];\\n                primeFactors[p]++;\\n                n /= p;\\n                s.insert(p);\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n\\n\\n//***************************************** Approach 4 Code *****************************************/\\n// TC : O(n * (sqrt(maxno) + log(maxno) + c * p)\\n// SC : O(p),  maxno is the maximum number in nums and p is the no of distinct prime factors\\n// Fix of Approach 2 code and it is a working solution\\n\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        unordered_set<int> s;\\n        int j,n;\\n        for(int i = 0; i < nums.size(); i++) {\\n            n = nums[i];\\n            for(j = 2; j * j <= n; j++){\\n                if(n % j == 0) {\\n                    s.insert(j);\\n                    while(n % j == 0){\\n                        n /= j;\\n                    }\\n                }\\n            }\\n            if(n > 1) {\\n                s.insert(n);\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n\\n//***************************************** Approach 5 Code *****************************************/\\n// TC : O(n * (maxno + log(maxno) + c * p)\\n// SC : O(p),  maxno is the maximum number in nums and p is the no of distinct prime factors\\n// This is slight modification of appraoch 4 (tc is increased here)\\n\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        unordered_set<int> s;\\n        int j,n;\\n        for(int i = 0; i < nums.size(); i++) {\\n            n = nums[i];\\n            for(j = 2; n > 1; j++){\\n                if(n % j == 0) {\\n                    s.insert(j);\\n                    while(n % j == 0){\\n                        n /= j;\\n                    }\\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```\\n\\n# Golang Code\\n```\\n// Approach 5 and 4 go codes but we are using the map to store the frequency of the prime numbers(we can do the same in c++, according to the problem)\\n\\nfunc distinctPrimeFactors(nums []int) int {\\n\\thashmap := make(map[int]int);\\n\\tfor _, n := range nums {\\n\\t\\tfor j := 2; n > 1; j++ {\\n\\t\\t\\tfor n % j == 0 {\\n\\t\\t\\t\\thashmap[j]++;\\n\\t\\t\\t\\tn = n / j;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn len(hashmap);\\n}\\n\\nfunc distinctPrimeFactors(nums []int) int {\\n\\thashmap := make(map[int]int);\\n\\tfor _, n := range nums {\\n\\t\\tfor j := 2; j * j <= n; j++ {\\n\\t\\t\\tfor n % j == 0 {\\n\\t\\t\\t\\thashmap[j]++;\\n\\t\\t\\t\\tn = n / j;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif n > 1 {\\n\\t\\t\\t\\thashmap[n]++;\\n\\t\\t}\\n \\t}\\n\\treturn len(hashmap);\\n}\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Go"
                ],
                "code": "```\\n//***************************************** Approach 1 Code *****************************************/\\n// TC : O(p)\\n// SC : O(p)\\n// Here \"p\" is the product of all the values of nums. p >>> n\\n// Memory wont be sufficient\\n\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        int n = 1;\\n        for(int i = 0; i < nums.size(); i++) {\\n            n *= nums[i];\\n        }\\n        vector<int> leastPrime(n + 1);\\n        for(int i = 2; i <= n; i++) {\\n            leastPrime[i] = i;\\n        }\\n        for(int i = 2; i * i <= n; i++) {\\n            if(leastPrime[i] == i) {\\n                for(int j = i * i; j <= n; j += i) {\\n                    if(leastPrime[j] == j) {\\n                        leastPrime[j] = i;\\n                    }\\n                }\\n            }\\n        }\\n        map<int, int> primeFactors;\\n        while(n > 1) {\\n            int p = leastPrime[n];\\n            primeFactors[p]++;\\n            n /= p;\\n        }\\n        return primeFactors.size();\\n    }\\n};\\n\\n//***************************************** Approach 2 Code *****************************************/\\n// TC : O(p), p is the product and it is much greater than the value of n\\n// SC : O(1)\\n// Fixed Memory issue.\\n// signed integer overflow: 21092400 * 780 cannot be represented in type \\'int\\'. \\n// So this logic and above logic works when product does not exceed the limit of int or long\\n\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        int n = 1;\\n        for(int i = 0; i < nums.size(); i++) {\\n            n *= nums[i];\\n        }\\n        vector<int> primeFactors;\\n        for(int i = 2; i * i <= n; i++) {\\n            if(n % i == 0) {\\n                primeFactors.push_back(i);\\n                while(n % i == 0) {\\n                    n = n / i;\\n                }\\n            }\\n        }\\n        if(n > 1) {\\n            primeFactors.push_back(n);\\n        }\\n        return primeFactors.size();\\n    }\\n};\\n\\n//***************************************** Approach 3 Code *****************************************/\\n// TC : O(n * (maxno*log(log(maxno))) + c * p) \\n// SC : O(maxno + p),  maxno is the maximum number in nums and p is the no of distinct prime factors\\n// Fix of Approach 1 code and it is a working solution\\n\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        unordered_set<int> s;\\n        int n;\\n        for(int k = 0; k < nums.size(); k++) {\\n            n = nums[k];      \\n            vector<int> leastPrime(n + 1);\\n            for(int i = 2; i <= n; i++) {\\n                leastPrime[i] = i;\\n            }\\n            for(int i = 2; i * i <= n; i++) {\\n                if(leastPrime[i] == i) {\\n                    for(int j = i * i; j <= n; j += i) {\\n                        if(leastPrime[j] == j) {\\n                            leastPrime[j] = i;\\n                        }\\n                    }\\n                }\\n            }\\n            map<int, int> primeFactors;\\n            while(n > 1) {\\n                int p = leastPrime[n];\\n                primeFactors[p]++;\\n                n /= p;\\n                s.insert(p);\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n\\n\\n//***************************************** Approach 4 Code *****************************************/\\n// TC : O(n * (sqrt(maxno) + log(maxno) + c * p)\\n// SC : O(p),  maxno is the maximum number in nums and p is the no of distinct prime factors\\n// Fix of Approach 2 code and it is a working solution\\n\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        unordered_set<int> s;\\n        int j,n;\\n        for(int i = 0; i < nums.size(); i++) {\\n            n = nums[i];\\n            for(j = 2; j * j <= n; j++){\\n                if(n % j == 0) {\\n                    s.insert(j);\\n                    while(n % j == 0){\\n                        n /= j;\\n                    }\\n                }\\n            }\\n            if(n > 1) {\\n                s.insert(n);\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n\\n//***************************************** Approach 5 Code *****************************************/\\n// TC : O(n * (maxno + log(maxno) + c * p)\\n// SC : O(p),  maxno is the maximum number in nums and p is the no of distinct prime factors\\n// This is slight modification of appraoch 4 (tc is increased here)\\n\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        unordered_set<int> s;\\n        int j,n;\\n        for(int i = 0; i < nums.size(); i++) {\\n            n = nums[i];\\n            for(j = 2; n > 1; j++){\\n                if(n % j == 0) {\\n                    s.insert(j);\\n                    while(n % j == 0){\\n                        n /= j;\\n                    }\\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```\n```\\n// Approach 5 and 4 go codes but we are using the map to store the frequency of the prime numbers(we can do the same in c++, according to the problem)\\n\\nfunc distinctPrimeFactors(nums []int) int {\\n\\thashmap := make(map[int]int);\\n\\tfor _, n := range nums {\\n\\t\\tfor j := 2; n > 1; j++ {\\n\\t\\t\\tfor n % j == 0 {\\n\\t\\t\\t\\thashmap[j]++;\\n\\t\\t\\t\\tn = n / j;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn len(hashmap);\\n}\\n\\nfunc distinctPrimeFactors(nums []int) int {\\n\\thashmap := make(map[int]int);\\n\\tfor _, n := range nums {\\n\\t\\tfor j := 2; j * j <= n; j++ {\\n\\t\\t\\tfor n % j == 0 {\\n\\t\\t\\t\\thashmap[j]++;\\n\\t\\t\\t\\tn = n / j;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif n > 1 {\\n\\t\\t\\t\\thashmap[n]++;\\n\\t\\t}\\n \\t}\\n\\treturn len(hashmap);\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829119,
                "title": "simple-sol-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int i = 0; i < nums.length; i++){\\n            for(int j = 2; j <= nums[i]; j++){\\n                if(nums[i] % j == 0)\\n                    set.add(j);\\n                while(nums[i] % j == 0)\\n                    nums[i] = nums[i] / j; \\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int i = 0; i < nums.length; i++){\\n            for(int j = 2; j <= nums[i]; j++){\\n                if(nums[i] % j == 0)\\n                    set.add(j);\\n                while(nums[i] % j == 0)\\n                    nums[i] = nums[i] / j; \\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810734,
                "title": "simple-set-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\n    unordered_set<int> s;\\n    public:\\n        void prime(int n) \\n        {\\n            for(int i=2;i<=n;i++)\\n            {\\n                if(n%i==0)\\n                {\\n                    while(n%i==0 && n!=1)\\n                    {\\n                       n=n/i;\\n                    }\\n                    s.insert(i);        \\n                }\\n                \\n                if(n==1)\\n                  break;\\n            }\\n        }\\n    int distinctPrimeFactors(vector<int> &nums)\\n    {\\n        for (int n: nums)\\n        {\\n            prime(n);\\n        }\\n\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\n    unordered_set<int> s;\\n    public:\\n        void prime(int n) \\n        {\\n            for(int i=2;i<=n;i++)\\n            {\\n                if(n%i==0)\\n                {\\n                    while(n%i==0 && n!=1)\\n                    {\\n                       n=n/i;\\n                    }\\n                    s.insert(i);        \\n                }\\n                \\n                if(n==1)\\n                  break;\\n            }\\n        }\\n    int distinctPrimeFactors(vector<int> &nums)\\n    {\\n        for (int n: nums)\\n        {\\n            prime(n);\\n        }\\n\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784751,
                "title": "easy-and-understandable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        unordered_set<int> s;\\n        int j,k;\\n        \\n        for(int i = 0; i<nums.size(); i++) {\\n           k =  nums[i];\\n            for(int j = 2; j <=  sqrt(nums[i]); j++){\\n                if(k%j == 0){\\n                    s.insert(j);\\n                    while(k%j == 0){\\n                        k /= j;\\n                    }\\n            }\\n        }\\n\\n            if(k>1){\\n                s.insert(k);\\n            }\\n        }\\n        \\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "C#"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        unordered_set<int> s;\\n        int j,k;\\n        \\n        for(int i = 0; i<nums.size(); i++) {\\n           k =  nums[i];\\n            for(int j = 2; j <=  sqrt(nums[i]); j++){\\n                if(k%j == 0){\\n                    s.insert(j);\\n                    while(k%j == 0){\\n                        k /= j;\\n                    }\\n            }\\n        }\\n\\n            if(k>1){\\n                s.insert(k);\\n            }\\n        }\\n        \\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763810,
                "title": "easy-to-get-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n         int cnt=0;\\n        int[] a = new int[1001];\\n        for(int x:nums){\\n            primeFactors(x,a);\\n        }\\n        for(int x:a){\\n            if(x==1)\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n    \\n    private void primeFactors(int x,int[] a)\\n    {\\n        int root = (int)Math.sqrt(x);\\n        for (int i=2; i<=root; i++) {\\n            while (x%i == 0) {\\n                x/=i;\\n                a[i]=1;\\n            }\\n        }\\n\\n        if(x>=2)\\n            a[x]=1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n         int cnt=0;\\n        int[] a = new int[1001];\\n        for(int x:nums){\\n            primeFactors(x,a);\\n        }\\n        for(int x:a){\\n            if(x==1)\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n    \\n    private void primeFactors(int x,int[] a)\\n    {\\n        int root = (int)Math.sqrt(x);\\n        for (int i=2; i<=root; i++) {\\n            while (x%i == 0) {\\n                x/=i;\\n                a[i]=1;\\n            }\\n        }\\n\\n        if(x>=2)\\n            a[x]=1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759183,
                "title": "c-single-prime-list-testing-whole-number-list",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int DistinctPrimeFactors(int[] nums) {\\n        int result = 0;\\n        int maxNum = nums.Max();\\n        var primes = getPrimesUptoTarget(maxNum);\\n\\n        // now go through each number to find primes\\n        for (int i = 0; i < nums.Length; i++) {\\n            result += testPrimes(primes, nums[i]);\\n        }\\n        return result;\\n    }\\n\\n    // returns the number of prime factors found\\n    private int testPrimes(List<int> primes, int number) {\\n        List<int> factors = new List<int>();\\n        for (int i = 0; i < primes.Count; i++) {\\n            if (primes[i] > number) {\\n                break;\\n            }\\n\\n            if (number % primes[i] == 0) {\\n                factors.Add(primes[i]);\\n            }\\n        }\\n\\n        // remove found primes\\n        for (int i = 0; i < factors.Count; i++) {\\n            primes.Remove(factors[i]);\\n        }\\n\\n        return factors.Count;\\n    }\\n\\n    private List<int> getPrimesUptoTarget(int target) {\\n        List<int> result = new List<int>() { 2, 3, 5, 7, 11 };\\n        int cur = 13;\\n        while (cur <= target) {\\n            bool isPrime = false;\\n            for (int i = 0; i < result.Count; i++) {\\n                if (result[i] * result[i] > cur) {\\n                    isPrime = true;\\n                    break;\\n                }\\n\\n                if (cur % result[i] == 0) {\\n                    isPrime = false;\\n                    break;\\n                }\\n            }\\n            if (isPrime) {\\n                result.Add(cur);\\n            }\\n\\n            cur += 2;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int DistinctPrimeFactors(int[] nums) {\\n        int result = 0;\\n        int maxNum = nums.Max();\\n        var primes = getPrimesUptoTarget(maxNum);\\n\\n        // now go through each number to find primes\\n        for (int i = 0; i < nums.Length; i++) {\\n            result += testPrimes(primes, nums[i]);\\n        }\\n        return result;\\n    }\\n\\n    // returns the number of prime factors found\\n    private int testPrimes(List<int> primes, int number) {\\n        List<int> factors = new List<int>();\\n        for (int i = 0; i < primes.Count; i++) {\\n            if (primes[i] > number) {\\n                break;\\n            }\\n\\n            if (number % primes[i] == 0) {\\n                factors.Add(primes[i]);\\n            }\\n        }\\n\\n        // remove found primes\\n        for (int i = 0; i < factors.Count; i++) {\\n            primes.Remove(factors[i]);\\n        }\\n\\n        return factors.Count;\\n    }\\n\\n    private List<int> getPrimesUptoTarget(int target) {\\n        List<int> result = new List<int>() { 2, 3, 5, 7, 11 };\\n        int cur = 13;\\n        while (cur <= target) {\\n            bool isPrime = false;\\n            for (int i = 0; i < result.Count; i++) {\\n                if (result[i] * result[i] > cur) {\\n                    isPrime = true;\\n                    break;\\n                }\\n\\n                if (cur % result[i] == 0) {\\n                    isPrime = false;\\n                    break;\\n                }\\n            }\\n            if (isPrime) {\\n                result.Add(cur);\\n            }\\n\\n            cur += 2;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757277,
                "title": "simple-and-very-easy-solution-88-beats-c",
                "content": "# Intuition\\nThe problem requires finding the count of distinct prime factors across all numbers in the given array. To solve this, we can iterate through each number in the array and factorize them. For each number, we check for its prime factors by dividing it with prime numbers starting from 2 up to the square root of the number. If a prime factor is found, we divide the number by that factor repeatedly until it is no longer divisible. Finally, we insert the remaining number (if greater than 1) into a set to count it as a distinct prime factor.\\n\\n# Approach\\n1. Initialize an unordered set, `st`, to store the distinct prime factors.\\n2. Iterate through each number, `num`, in the given array `nums`.\\n3. For each `num`, iterate from 2 up to the square root of `num` (inclusive) to find its prime factors.\\n   - If `num` is divisible by `i`, divide `num` by `i` repeatedly until it is no longer divisible. Insert `i` into `st` as a distinct prime factor.\\n4. If `num` is greater than 1 after the previous steps, insert it into `st` as a distinct prime factor.\\n5. Return the size of `st`, which represents the count of distinct prime factors across all numbers in the array.\\n\\n# Complexity\\n- Time complexity: O(N * sqrt(M)), where N is the number of elements in the `nums` array and M is the maximum value in the `nums` array. The factorization process takes O(sqrt(M)) for each number in the array, resulting in a total time complexity of O(N * sqrt(M)).\\n- Space complexity: O(N), where N is the number of distinct prime factors. In the worst case, all numbers in the array have distinct prime factors, so the size of the unordered set `st` will be equal to the number of elements in the array.\\n\\n![Screenshot 2023-07-13 092607.png](https://assets.leetcode.com/users/images/89fcc3e5-b266-47f3-95c7-59cdf6bf2055_1689218785.2716756.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        unordered_set<int> st;\\n        for(int num:nums){\\n            for(int i=2;i*i<=num;i++){\\n                if(num%i==0){\\n                    while(num%i==0)num/=i;\\n                    st.insert(i);\\n                }\\n            }\\n            if(num>1) st.insert(num);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        unordered_set<int> st;\\n        for(int num:nums){\\n            for(int i=2;i*i<=num;i++){\\n                if(num%i==0){\\n                    while(num%i==0)num/=i;\\n                    st.insert(i);\\n                }\\n            }\\n            if(num>1) st.insert(num);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738789,
                "title": "primefacotrisation-and-set-very-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthe number of prime factors in the product , will be euall to the number of prime factors in each element.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn simpler terms, the code calculates the count of unique prime factors for each number in the input vector. It uses a helper function primeFactors to find the prime factors of a given number and updates a set with these factors. The main function distinctPrimeFactors calls this helper function for each element in the vector and returns the total count of unique prime factors found.\\n\\n\\n# Complexity\\n- Time complexity:O(N * sqrt(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe primeFactors function:\\n\\nIt checks for prime factors of a number n using trial division, iterating up to the square root of n.\\nThe time complexity of this function is O(sqrt(n)).\\nThe distinctPrimeFactors function:\\n\\nIt iterates over each element in the nums vector and calls the primeFactors function for each element.\\nSince there are N elements in the nums vector, the overall time complexity is **O(N * sqrt(n))**, where n is the maximum element in nums.\\n\\n\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void primeFactors(set<int> &cnt, int n) {\\n\\n        // Check if 2 is a prime factor\\n        while (n % 2 == 0) {\\n            cnt.insert(2);\\n            n /= 2;\\n        }\\n        // Check for other prime factors starting from 3\\n        for (int i = 3; i * i <= n; i += 2) {\\n            while (n % i == 0) {\\n                cnt.insert(i);\\n                n /= i;\\n            }\\n        }\\n        // If n is still greater than 2, it must be a prime factor itself\\n        if (n > 2) {\\n            cnt.insert(n);\\n        }\\n    }\\npublic:\\n\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        //set to include only unique as we need the count of distinct, not the total of how many.\\n        set<int>primeCount;\\n\\n        //if we check the number of prime in the elements of nums it will be equall to the number\\n        //of primes in their product .(BASIC MATH);\\n\\n        for(int i=0;i<nums.size();i++){\\n            primeFactors(primeCount, nums[i]);\\n        }\\n        return primeCount.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void primeFactors(set<int> &cnt, int n) {\\n\\n        // Check if 2 is a prime factor\\n        while (n % 2 == 0) {\\n            cnt.insert(2);\\n            n /= 2;\\n        }\\n        // Check for other prime factors starting from 3\\n        for (int i = 3; i * i <= n; i += 2) {\\n            while (n % i == 0) {\\n                cnt.insert(i);\\n                n /= i;\\n            }\\n        }\\n        // If n is still greater than 2, it must be a prime factor itself\\n        if (n > 2) {\\n            cnt.insert(n);\\n        }\\n    }\\npublic:\\n\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        //set to include only unique as we need the count of distinct, not the total of how many.\\n        set<int>primeCount;\\n\\n        //if we check the number of prime in the elements of nums it will be equall to the number\\n        //of primes in their product .(BASIC MATH);\\n\\n        for(int i=0;i<nums.size();i++){\\n            primeFactors(primeCount, nums[i]);\\n        }\\n        return primeCount.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664264,
                "title": "bad-scala-solution-needs-cleaning",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def distinctPrimeFactors(nums: Array[Int]): Int = {\\n      import scala.collection.mutable.ListBuffer\\n            def populateLB(n: Long): ListBuffer[Long] = {\\n      val buff = ListBuffer.empty[Long]\\n      n % 2 == 0 match {\\n        case true => {\\n          buff += 2\\n          for(i <- 3L to n if i % 2 != 0) buff += i\\n        }\\n        case    _ => for(i <- 3L to n if i % 2 != 0) buff += i\\n      }\\n      buff\\n    }\\n\\n\\n    def removeDivisible(n: Long, lon: ListBuffer[Long]): ListBuffer[Long] = {\\n      val nlon = ListBuffer.empty[Long]\\n      for{\\n        i <- lon\\n        if(i % n != 0)\\n      } nlon += i\\n      nlon\\n    }\\n\\n\\n    // above works as long as you dont hit max int size on list\\n    //below acutall works\\n    def isOddPrime(x: Long, maxSqrt: Long): Boolean = {\\n      for(i <- 3L to maxSqrt by 2){\\n        if(x % i == 0) return false\\n      }\\n      true\\n    }\\n\\n    def maxPrimeFactor(n: Long): Long = {\\n      var max = 0L\\n      val maxSqrt = scala.math.sqrt(n).toLong\\n      for(i <- 3L to maxSqrt by 2){\\n        if(n % i == 0){\\n          if(isOddPrime(i,scala.math.sqrt(i).toLong)){\\n            max = i\\n          }\\n        }\\n      }\\n      max\\n    }\\n\\n        def sieve(n: Long): ListBuffer[Long] = {\\n      if(n < 2L){\\n        ListBuffer()\\n      }else if(n == 2L){\\n        ListBuffer(2L)\\n      }else if(n % 2 != 0 && isOddPrime(n,scala.math.sqrt(n).toLong)){\\n        ListBuffer(n)\\n      }else{\\n        var buff = scala.collection.mutable.ListBuffer.empty[Long]\\n        var pop = populateLB(n)\\n\\n        if(pop(0) == 2L){\\n          buff += 2L\\n          pop  -= 2L\\n        }\\n\\n        def go(n: Long, x: Long, lon: ListBuffer[Long]): ListBuffer[Long] = lon.size == 0 match {\\n          case true => lon\\n          case    _ => {\\n            val nlon = removeDivisible(n,lon)\\n            if(nlon.size == 0){\\n              nlon\\n            }else{\\n              if(x % n == 0) buff += n\\n              go(nlon(0), x, nlon)\\n            }\\n          }\\n        }\\n        go(pop(0), n, pop)\\n        buff\\n      }\\n    }\\n\\n    nums.toList.distinct.map(x => sieve(x)).flatten.distinct.size\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def distinctPrimeFactors(nums: Array[Int]): Int = {\\n      import scala.collection.mutable.ListBuffer\\n            def populateLB(n: Long): ListBuffer[Long] = {\\n      val buff = ListBuffer.empty[Long]\\n      n % 2 == 0 match {\\n        case true => {\\n          buff += 2\\n          for(i <- 3L to n if i % 2 != 0) buff += i\\n        }\\n        case    _ => for(i <- 3L to n if i % 2 != 0) buff += i\\n      }\\n      buff\\n    }\\n\\n\\n    def removeDivisible(n: Long, lon: ListBuffer[Long]): ListBuffer[Long] = {\\n      val nlon = ListBuffer.empty[Long]\\n      for{\\n        i <- lon\\n        if(i % n != 0)\\n      } nlon += i\\n      nlon\\n    }\\n\\n\\n    // above works as long as you dont hit max int size on list\\n    //below acutall works\\n    def isOddPrime(x: Long, maxSqrt: Long): Boolean = {\\n      for(i <- 3L to maxSqrt by 2){\\n        if(x % i == 0) return false\\n      }\\n      true\\n    }\\n\\n    def maxPrimeFactor(n: Long): Long = {\\n      var max = 0L\\n      val maxSqrt = scala.math.sqrt(n).toLong\\n      for(i <- 3L to maxSqrt by 2){\\n        if(n % i == 0){\\n          if(isOddPrime(i,scala.math.sqrt(i).toLong)){\\n            max = i\\n          }\\n        }\\n      }\\n      max\\n    }\\n\\n        def sieve(n: Long): ListBuffer[Long] = {\\n      if(n < 2L){\\n        ListBuffer()\\n      }else if(n == 2L){\\n        ListBuffer(2L)\\n      }else if(n % 2 != 0 && isOddPrime(n,scala.math.sqrt(n).toLong)){\\n        ListBuffer(n)\\n      }else{\\n        var buff = scala.collection.mutable.ListBuffer.empty[Long]\\n        var pop = populateLB(n)\\n\\n        if(pop(0) == 2L){\\n          buff += 2L\\n          pop  -= 2L\\n        }\\n\\n        def go(n: Long, x: Long, lon: ListBuffer[Long]): ListBuffer[Long] = lon.size == 0 match {\\n          case true => lon\\n          case    _ => {\\n            val nlon = removeDivisible(n,lon)\\n            if(nlon.size == 0){\\n              nlon\\n            }else{\\n              if(x % n == 0) buff += n\\n              go(nlon(0), x, nlon)\\n            }\\n          }\\n        }\\n        go(pop(0), n, pop)\\n        buff\\n      }\\n    }\\n\\n    nums.toList.distinct.map(x => sieve(x)).flatten.distinct.size\\n\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3648332,
                "title": "easy-use-of-sieve-of-erasthones",
                "content": "# Intuition\\n1. The first thing we need to know is that the prime factors must come from the individual elements in the array. \\n2. The highest prime factor will be less than or equal to the largest element in the array\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First generate prime numbers upto the max value in the array.\\n2. Loop through the numbers in the array, each time checking if the number is divible by any prime. If so add the prime to the a result set.\\n3. We have used a set since some numbers may be multiple of one of the prime in which step two would add two identical primes to the result.\\n4. Return the len of the result set.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n 1. Finding the max val = $$O(n)$$, where n is the length of the array\\n 2. Find the prime number is $$O(sqrt(maxVal) log log (maxValue))$$, this was derived from the fact that sieve of erasthones is $$O(sqrt(n) log log (n))$$ where our n= maxVal\\n 3. Find the the result  is $$O((n) * n/ln(n))$$, there are approaximately $$O(n/ln(n))$$ primes between 2 and n\\n 4. Hence the overall complexity is $$O(n^2/ln(n))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(maxVal)$$, we only have to create maxVal sieve array when finding prime numbers\\n#### Please upvote this solution if you find it helpful\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n        maxV= max(nums)\\n        def generatePrimes(n):\\n            bound= n+1\\n            result=[]\\n            sieve= [True]*(bound)\\n            last= int(math.sqrt(bound-1))\\n            for i in range(2,last+1):\\n                for j in range(2*i, bound+1, i):\\n                    if(j<bound):\\n                        sieve[j]=False\\n            for i in range(2,bound):\\n                if(sieve[i]):\\n                    result.append(i)\\n            return result\\n        primes= generatePrimes(maxV)\\n        result= set()\\n        for num in nums:\\n            for prime in primes:\\n                if(num%prime==0):\\n                    result.add(prime)\\n        return len(result)\\n            \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n        maxV= max(nums)\\n        def generatePrimes(n):\\n            bound= n+1\\n            result=[]\\n            sieve= [True]*(bound)\\n            last= int(math.sqrt(bound-1))\\n            for i in range(2,last+1):\\n                for j in range(2*i, bound+1, i):\\n                    if(j<bound):\\n                        sieve[j]=False\\n            for i in range(2,bound):\\n                if(sieve[i]):\\n                    result.append(i)\\n            return result\\n        primes= generatePrimes(maxV)\\n        result= set()\\n        for num in nums:\\n            for prime in primes:\\n                if(num%prime==0):\\n                    result.add(prime)\\n        return len(result)\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647938,
                "title": "c-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n      int N = 1001;\\n      vector<bool> is_prime(N, true);\\n      vector<unordered_set<int>> factors(N);\\n      is_prime[2] = true;\\n      for (int i = 2; i < N; i++) {\\n        if (!is_prime[i])\\n          continue;\\n        int k = 1;\\n        while (i*k < N) {\\n          is_prime[i*k] = false;\\n          factors[i*k].insert(i);\\n          k++;\\n        }\\n      }\\n      unordered_set<int> prime_factors;\\n      for (auto n : nums)\\n        prime_factors.insert(factors[n].begin(), factors[n].end());\\n      return prime_factors.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n      int N = 1001;\\n      vector<bool> is_prime(N, true);\\n      vector<unordered_set<int>> factors(N);\\n      is_prime[2] = true;\\n      for (int i = 2; i < N; i++) {\\n        if (!is_prime[i])\\n          continue;\\n        int k = 1;\\n        while (i*k < N) {\\n          is_prime[i*k] = false;\\n          factors[i*k].insert(i);\\n          k++;\\n        }\\n      }\\n      unordered_set<int> prime_factors;\\n      for (auto n : nums)\\n        prime_factors.insert(factors[n].begin(), factors[n].end());\\n      return prime_factors.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628380,
                "title": "python-set-recursion",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n        res = set()\\n        memo = set()\\n\\n        def getFactors(num):\\n            if num in memo:\\n                return\\n            for i in range(2, num):\\n                if num % i == 0:\\n                    getFactors(i)\\n                    getFactors(num//i)\\n                    memo.add(i)\\n                    memo.add(num//i)\\n                    return\\n            res.add(num)\\n            return\\n        \\n        for n in nums:\\n            getFactors(n)\\n            memo.add(n)\\n        \\n        return len(res)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n        res = set()\\n        memo = set()\\n\\n        def getFactors(num):\\n            if num in memo:\\n                return\\n            for i in range(2, num):\\n                if num % i == 0:\\n                    getFactors(i)\\n                    getFactors(num//i)\\n                    memo.add(i)\\n                    memo.add(num//i)\\n                    return\\n            res.add(num)\\n            return\\n        \\n        for n in nums:\\n            getFactors(n)\\n            memo.add(n)\\n        \\n        return len(res)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592443,
                "title": "python-solutions-best-solution-with-tc-o-sqrt-n",
                "content": "# Intuition\\n-> From hint we know that, if we multiply all number of the input array and find divisors of a single number then it will be a time taking process because the single number we get will be very large, so instead we find divisors of every individual item in array and use a set to store those divisiors, so that we have distinct divisors.\\n\\n# 1st Approach\\n***Brute force Approach***\\n\\t-> Simply will traverse from through array elements, and for each element we fill run a loop from i = 2 to n\\n\\t-> Then, we will check if i is prime or not and if it divides n or not, if yes then we will add i in set a created to store the divisors\\n\\t-> keep on dividing n by i till it\\'s possible and then increment i by 1\\n\\n# Complexity\\n- Time complexity: $$O(n^2 logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: Assuming n would have k distinct prime divisors- $$O(k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\t\\tdef distinctPrimeFactors(self, nums: List[int]) -> int:\\n\\t\\t\\tdef isprime(x):\\n\\t\\t\\t\\tif x == 2 or x == 3:\\n\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\tif x%2 == 0 or x%3 == 0:\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\ty = 5\\n\\t\\t\\t\\twhile y*y < x:\\n\\t\\t\\t\\t\\tif x%y == 0 or x%(y+2) == 0:\\n\\t\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\t\\ty+=6\\n\\t\\t\\t\\treturn 1\\n\\n\\t\\t\\ta = set()\\n\\t\\t\\tfor prod in nums:\\n\\t\\t\\t\\ti = 2\\n\\t\\t\\t\\twhile prod>1:\\n\\t\\t\\t\\t\\tif prod %i == 0 and isprime(i):\\n\\t\\t\\t\\t\\t\\tprod = prod//i   \\n\\t\\t\\t\\t\\t\\ta.add(i)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\ti+=1 \\n\\n\\t\\t\\treturn len(a)\\n```\\n\\n---\\n\\n# 2nd Approach\\n***Optimized approach without checking seperatly for prime***\\n\\t-> We know that divisiors always appear in pairs: if n=12 -> (1,12), (2,6), (3,4). So, if there are two pairs x*y = n, and if x<=y, then x*x = n, x = sqrt(n)\\n\\t-> Now, we can observe that we can always write a number in multiples of prime numbers, i.e. that is prime numbers can repeat more than once but they will divide the number totally\\n\\t-> if we follow this approach, then we can see if n = 12 : 2 x 2 x 2 x 3 -> 2^3 * 3^1\\n\\t-> if we find the first prime number which divides n then, we can continuously divide the n with that number and then increase the number till n becomes 1 or can\\'t be further divided.\\n-> if n left is greater than 1, then the last if condition  is used to return the last prime divisor \\n                \\n\\n\\n# Complexity\\n- Time complexity: $$O(sqrt(n)logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: Assuming n would have k distinct prime divisors- $$O(k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\t\\tdef distinctPrimeFactors(self, nums: List[int]) -> int:\\n\\t\\t\\ta = set()\\n\\t\\t\\tfor n in nums:\\n\\t\\t\\t\\tj = 2\\n\\t\\t\\t\\twhile j*j <= n:\\n\\t\\t\\t\\t\\twhile n%j ==0:\\n\\t\\t\\t\\t\\t\\ta.add(j)\\n\\t\\t\\t\\t\\t\\tn = n//j \\n\\n\\t\\t\\t\\t\\tj+=1\\n\\n\\t\\t\\t\\tif n >1:\\t\\t\\t\\t\\n\\t\\t\\t\\t\\ta.add(n)\\n\\t\\t\\treturn len(a)\\n```\\n\\n---\\n# 3rd Approach\\n***Optimizing the above approach***\\n\\t-> If we see, if a number is divisible by 2 then it will be divisible by all even integers.\\n\\t-> Similarly, if a number is divisible by 3 then it will be divisible by all the multiples of 3\\n\\t-> If we check seperately for 2 and 3, then we can reduce many iterations for our loop\\n                \\n\\n\\n# Complexity\\n- Time complexity: $$O(sqrt(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: Assuming n would have k distinct prime divisors- $$O(k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\t\\tdef distinctPrimeFactors(self, nums: List[int]) -> int:\\n\\t\\t\\ta = set()\\n\\t\\t\\tfor n in nums:\\n                #loop to check for 2\\n\\t\\t\\t\\twhile n%2 == 0:\\n\\t\\t\\t\\t\\ta.add(2)\\n\\t\\t\\t\\t\\tn=n//2\\n\\t\\t\\t\\t#loop to check for 3\\n\\t\\t\\t\\twhile n%3 == 0:\\n\\t\\t\\t\\t\\ta.add(3)\\n\\t\\t\\t\\t\\tn = n//3\\n\\t\\t\\t\\t\\t \\n\\t\\t\\t\\tj=5\\n                #loop to check from 5 to sqrt(n), this loop will run max sqrt(n) times\\n\\t\\t\\t\\twhile j*j <= n:                                \\n\\t\\t\\t\\t\\twhile n%j ==0:\\n\\t\\t\\t\\t\\t\\ta.add(j)\\n\\t\\t\\t\\t\\t\\tn = n//j \\n\\n\\t\\t\\t\\t\\twhile n%(j+2) == 0:\\n\\t\\t\\t\\t\\t\\ta.add(j+2)\\n\\t\\t\\t\\t\\t\\tn = n//(j+2)\\n\\n\\t\\t\\t\\t\\tj+=6\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tif n >3:\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\ta.add(n)\\n\\t\\t\\treturn len(a)\\n\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\t\\tdef distinctPrimeFactors(self, nums: List[int]) -> int:\\n\\t\\t\\tdef isprime(x):\\n\\t\\t\\t\\tif x == 2 or x == 3:\\n\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\tif x%2 == 0 or x%3 == 0:\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\ty = 5\\n\\t\\t\\t\\twhile y*y < x:\\n\\t\\t\\t\\t\\tif x%y == 0 or x%(y+2) == 0:\\n\\t\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\t\\ty+=6\\n\\t\\t\\t\\treturn 1\\n\\n\\t\\t\\ta = set()\\n\\t\\t\\tfor prod in nums:\\n\\t\\t\\t\\ti = 2\\n\\t\\t\\t\\twhile prod>1:\\n\\t\\t\\t\\t\\tif prod %i == 0 and isprime(i):\\n\\t\\t\\t\\t\\t\\tprod = prod//i   \\n\\t\\t\\t\\t\\t\\ta.add(i)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\ti+=1 \\n\\n\\t\\t\\treturn len(a)\\n```\n```\\nclass Solution:\\n\\t\\tdef distinctPrimeFactors(self, nums: List[int]) -> int:\\n\\t\\t\\ta = set()\\n\\t\\t\\tfor n in nums:\\n\\t\\t\\t\\tj = 2\\n\\t\\t\\t\\twhile j*j <= n:\\n\\t\\t\\t\\t\\twhile n%j ==0:\\n\\t\\t\\t\\t\\t\\ta.add(j)\\n\\t\\t\\t\\t\\t\\tn = n//j \\n\\n\\t\\t\\t\\t\\tj+=1\\n\\n\\t\\t\\t\\tif n >1:\\t\\t\\t\\t\\n\\t\\t\\t\\t\\ta.add(n)\\n\\t\\t\\treturn len(a)\\n```\n```\\nclass Solution:\\n\\t\\tdef distinctPrimeFactors(self, nums: List[int]) -> int:\\n\\t\\t\\ta = set()\\n\\t\\t\\tfor n in nums:\\n                #loop to check for 2\\n\\t\\t\\t\\twhile n%2 == 0:\\n\\t\\t\\t\\t\\ta.add(2)\\n\\t\\t\\t\\t\\tn=n//2\\n\\t\\t\\t\\t#loop to check for 3\\n\\t\\t\\t\\twhile n%3 == 0:\\n\\t\\t\\t\\t\\ta.add(3)\\n\\t\\t\\t\\t\\tn = n//3\\n\\t\\t\\t\\t\\t \\n\\t\\t\\t\\tj=5\\n                #loop to check from 5 to sqrt(n), this loop will run max sqrt(n) times\\n\\t\\t\\t\\twhile j*j <= n:                                \\n\\t\\t\\t\\t\\twhile n%j ==0:\\n\\t\\t\\t\\t\\t\\ta.add(j)\\n\\t\\t\\t\\t\\t\\tn = n//j \\n\\n\\t\\t\\t\\t\\twhile n%(j+2) == 0:\\n\\t\\t\\t\\t\\t\\ta.add(j+2)\\n\\t\\t\\t\\t\\t\\tn = n//(j+2)\\n\\n\\t\\t\\t\\t\\tj+=6\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tif n >3:\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\ta.add(n)\\n\\t\\t\\treturn len(a)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550311,
                "title": "solution-in-cpp",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool is_prime(int n) {\\n    if (n < 2)return false;\\n    if (n >= 2 && n <= 3)return true;\\n    if (n % 2 == 0 || n % 3 == 0)return false;\\n\\n    for (int i = 5;i * i <= n;i += 6) {\\n        if (n % i == 0 || n % (i + 2) == 0)return false;\\n    }\\n    return true;\\n    }\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        int ans = 0;\\n        vector<int> prime;\\n        bool cnt[1000] = {false};\\n        for(int i = 2; i < 1000; i++){\\n           if(is_prime(i))\\n                prime.push_back(i); \\n        }\\n        for(int i = 0; i < nums.size(); i++){\\n            for(int j = 0; j < prime.size(); j++){\\n                if(nums[i] % prime[j] == 0){\\n                    cnt[prime[j]] = true;\\n                }\\n            }\\n        }\\n        for(int i = 0; i < 1000; i++){\\n            if(cnt[i])\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool is_prime(int n) {\\n    if (n < 2)return false;\\n    if (n >= 2 && n <= 3)return true;\\n    if (n % 2 == 0 || n % 3 == 0)return false;\\n\\n    for (int i = 5;i * i <= n;i += 6) {\\n        if (n % i == 0 || n % (i + 2) == 0)return false;\\n    }\\n    return true;\\n    }\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        int ans = 0;\\n        vector<int> prime;\\n        bool cnt[1000] = {false};\\n        for(int i = 2; i < 1000; i++){\\n           if(is_prime(i))\\n                prime.push_back(i); \\n        }\\n        for(int i = 0; i < nums.size(); i++){\\n            for(int j = 0; j < prime.size(); j++){\\n                if(nums[i] % prime[j] == 0){\\n                    cnt[prime[j]] = true;\\n                }\\n            }\\n        }\\n        for(int i = 0; i < 1000; i++){\\n            if(cnt[i])\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542341,
                "title": "sieveoferatosthenes-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n    bool prime[1008];\\nvoid SieveOfEratosthenes()\\n{\\n    memset(prime, true, sizeof(prime));\\n \\n    prime[1] = false;\\n \\n    for (int p = 2; p * p <= 1001; p++) {\\n        if (prime[p] == true) {\\n            for (int i = p*p ; i <= 1001; i += p)\\n                prime[i] = false;\\n        }\\n    }\\n}\\n\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        SieveOfEratosthenes();\\n        for (int &val:nums)\\n        {\\n            if (prime[val]) mp[val]++;\\n            else\\n            {\\n                 for (int i=2;i<=(val/2);i++)\\n                 {\\n                   if (val%i==0 && prime[i]==true)\\n                       mp[i]++;\\n                 }\\n            }\\n           \\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    bool prime[1008];\\nvoid SieveOfEratosthenes()\\n{\\n    memset(prime, true, sizeof(prime));\\n \\n    prime[1] = false;\\n \\n    for (int p = 2; p * p <= 1001; p++) {\\n        if (prime[p] == true) {\\n            for (int i = p*p ; i <= 1001; i += p)\\n                prime[i] = false;\\n        }\\n    }\\n}\\n\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        SieveOfEratosthenes();\\n        for (int &val:nums)\\n        {\\n            if (prime[val]) mp[val]++;\\n            else\\n            {\\n                 for (int i=2;i<=(val/2);i++)\\n                 {\\n                   if (val%i==0 && prime[i]==true)\\n                       mp[i]++;\\n                 }\\n            }\\n           \\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503798,
                "title": "java-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n       \\tArrays.sort(nums);  // sorting makes it easier to count primes\\n\\t\\t\\t\\t\\t\\t\\n\\t\\tHashSet<Integer> set= new HashSet<>();\\n\\t\\t\\n\\t\\tfor (int n :nums) {\\t\\t\\t\\n\\t\\t\\tint i=2;\\n\\t\\t\\n\\t\\t\\twhile(n>1) {  // reduce the n=0\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(n % i ==0) {  // when prime is found , add in the set\\n\\t\\t\\t\\t\\tset.add(i);\\n\\t\\t\\t\\t\\tn/=i; }  // reduce n\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\telse {  // else increase i\\n\\t\\t\\t\\t\\ti++;}}}\\n\\t\\t\\n\\treturn set.size();\\t // set size == total prime numbers\\n\\t\\t \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n       \\tArrays.sort(nums);  // sorting makes it easier to count primes\\n\\t\\t\\t\\t\\t\\t\\n\\t\\tHashSet<Integer> set= new HashSet<>();\\n\\t\\t\\n\\t\\tfor (int n :nums) {\\t\\t\\t\\n\\t\\t\\tint i=2;\\n\\t\\t\\n\\t\\t\\twhile(n>1) {  // reduce the n=0\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(n % i ==0) {  // when prime is found , add in the set\\n\\t\\t\\t\\t\\tset.add(i);\\n\\t\\t\\t\\t\\tn/=i; }  // reduce n\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\telse {  // else increase i\\n\\t\\t\\t\\t\\ti++;}}}\\n\\t\\t\\n\\treturn set.size();\\t // set size == total prime numbers\\n\\t\\t \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467692,
                "title": "easy-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHard Coding my way through this problem\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nmake a list of primes and then iterate through it to check factors of the product of the array\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport math\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n\\n        product = 1\\n\\n        for i in nums:\\n            product*=i\\n    \\n        def primeFactors(n):\\n            to_return = []\\n            primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]\\n\\n            for i in primes:\\n                if i>n:\\n                    break\\n                elif n%i == 0:\\n                    to_return.append(i)\\n            return len(to_return)\\n                \\n\\n\\n        return primeFactors(product)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n\\n        product = 1\\n\\n        for i in nums:\\n            product*=i\\n    \\n        def primeFactors(n):\\n            to_return = []\\n            primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]\\n\\n            for i in primes:\\n                if i>n:\\n                    break\\n                elif n%i == 0:\\n                    to_return.append(i)\\n            return len(to_return)\\n                \\n\\n\\n        return primeFactors(product)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450904,
                "title": "easy-java-solution-for-newbies",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe have to find the no.of distinct prime factors of multiplication of array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have to ensure that we don\\'t multiply the all the elements because it will give us tle as multiplication can be very large. so,we have to think that how each element is contributing for factors .\\nwe check the all factors of each element and check it is prime or not ,if it is prime then we add them in a set so that we don\\'t get repeated elements \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        HashSet<Integer>set=new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=1;j<=nums[i];j++){\\n                if(nums[i]%j==0 && isprime(j)){\\n                    set.add(j);\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n    static boolean isprime(int a){\\n        if(a<=1){\\n            return false;\\n        }\\n        for(int i=2;i<=Math.sqrt(a);i++){\\n            if(a%i==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        HashSet<Integer>set=new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=1;j<=nums[i];j++){\\n                if(nums[i]%j==0 && isprime(j)){\\n                    set.add(j);\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n    static boolean isprime(int a){\\n        if(a<=1){\\n            return false;\\n        }\\n        for(int i=2;i<=Math.sqrt(a);i++){\\n            if(a%i==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440033,
                "title": "c-factors-prime-easy-commented",
                "content": "# Intuition\\nWe cannot multiply all numbers to generate the final product and then find prime factors of that number because the number will be too big.\\n\\n# Approach\\n- One way is to find all the primes number in range [2,1000] and check whether there exist a multiple of that prime in the given array.\\n\\n- Second approach can be to find the prime factors of each element in nums, and store all of them in a set to avoid duplicates.\\n- I implemented the first approach .\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) \\n    {\\n       vector<int>primes; // to store all the primes\\n        for(int i=2;i<=1000;i++)  \\n        {\\n            bool any=0;\\n            for(int j=2;j*j<=i;j++)\\n            {\\n                if(i%j==0)\\n                {\\n                    any=1;\\n                    break;\\n                }\\n            }\\n            if(!any)\\n                primes.push_back(i);\\n        }\\n        int ans=0;\\n        for(auto it:primes)\\n        {\\n            bool found=0;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n                if(nums[i]%it==0) // if num is divisible by prime[i] the divide it \\n                {\\n                    found=1;\\n                    while(nums[i]%it==0)\\n                    {\\n                        nums[i]/=it;\\n                    }\\n                }\\n            }\\n            if(found)\\n                ++ans;  // if there was a multiple then increase ans \\n        }\\n        return ans;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) \\n    {\\n       vector<int>primes; // to store all the primes\\n        for(int i=2;i<=1000;i++)  \\n        {\\n            bool any=0;\\n            for(int j=2;j*j<=i;j++)\\n            {\\n                if(i%j==0)\\n                {\\n                    any=1;\\n                    break;\\n                }\\n            }\\n            if(!any)\\n                primes.push_back(i);\\n        }\\n        int ans=0;\\n        for(auto it:primes)\\n        {\\n            bool found=0;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n                if(nums[i]%it==0) // if num is divisible by prime[i] the divide it \\n                {\\n                    found=1;\\n                    while(nums[i]%it==0)\\n                    {\\n                        nums[i]/=it;\\n                    }\\n                }\\n            }\\n            if(found)\\n                ++ans;  // if there was a multiple then increase ans \\n        }\\n        return ans;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432539,
                "title": "approach-using-sieve-of-eratosthenes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen dealing with an array where the elements or their product could be very large, finding the prime factors for each element is a practical approach. As product can be very large, making the use of int or long data types is unsuitable. Hence, by finding the prime divisors of each array element and storing them in a set, we can efficiently capture the necessary information without encountering issues with overflow or memory constraints.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Find the maximum element of the array\\n2. Then find smallest prime factor for each element using \"Sieve of Eratosthenes\"\\n3. Then, for each element in array, find the prime factors and store in set\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nn = max element in array\\nO(nlog(log n)) ~ O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] A) {\\n        int l = A.length;\\n        //finding maximum element in the given array\\n        int max = A[0];\\n        for(int i=1; i<l; i++){\\n            max = Math.max(A[i], max);\\n        }\\n\\n        //forming smallest prime divisors array using \"Sieve of Eratosthenes\"\\n        int[] spd = new int[max+1];\\n        \\n        for(int i=2; i<=max; i++){\\n            spd[i] = i;\\n        }\\n\\n        for(int i=2; i*i<=max; i++){\\n            if(spd[i] == i){\\n                for(int j = i*i; j <= max; j+=i){\\n                    if(spd[j] == j)\\n                    spd[j] = i;\\n                }\\n            }\\n        }\\n\\n        //main logic\\n        HashSet<Integer> ans = new HashSet<>();\\n        int primeFac;\\n        for(int i = 0; i < l; i++){\\n                int e = A[i];\\n                while(e > 1){\\n                    primeFac = spd[e];\\n                    ans.add(primeFac);\\n                    e = e/primeFac;\\n                }\\n        }\\n        return ans.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] A) {\\n        int l = A.length;\\n        //finding maximum element in the given array\\n        int max = A[0];\\n        for(int i=1; i<l; i++){\\n            max = Math.max(A[i], max);\\n        }\\n\\n        //forming smallest prime divisors array using \"Sieve of Eratosthenes\"\\n        int[] spd = new int[max+1];\\n        \\n        for(int i=2; i<=max; i++){\\n            spd[i] = i;\\n        }\\n\\n        for(int i=2; i*i<=max; i++){\\n            if(spd[i] == i){\\n                for(int j = i*i; j <= max; j+=i){\\n                    if(spd[j] == j)\\n                    spd[j] = i;\\n                }\\n            }\\n        }\\n\\n        //main logic\\n        HashSet<Integer> ans = new HashSet<>();\\n        int primeFac;\\n        for(int i = 0; i < l; i++){\\n                int e = A[i];\\n                while(e > 1){\\n                    primeFac = spd[e];\\n                    ans.add(primeFac);\\n                    e = e/primeFac;\\n                }\\n        }\\n        return ans.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3429840,
                "title": "easy-solution-easy-to-comprehend",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        int distinctCount = 0;\\n        unordered_map<int, int> distprime;\\n        for(int i=0; i < nums.size(); i++){\\n            for(int j=2; j <= nums[i]; j++){\\n                if(nums[i]%j==0){\\n                    distprime[j]++;\\n                    nums[i]/=j;\\n                    j--;\\n                } \\n            }\\n        }\\n        for(auto it:distprime) distinctCount++; \\n        return distinctCount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        int distinctCount = 0;\\n        unordered_map<int, int> distprime;\\n        for(int i=0; i < nums.size(); i++){\\n            for(int j=2; j <= nums[i]; j++){\\n                if(nums[i]%j==0){\\n                    distprime[j]++;\\n                    nums[i]/=j;\\n                    j--;\\n                } \\n            }\\n        }\\n        for(auto it:distprime) distinctCount++; \\n        return distinctCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422749,
                "title": "individual-contribution-easy-c-solution",
                "content": "\\n\\n# Approach\\nInstead of Multiplying all the Numbers in the given array, we simply find the contribution of individual elements within the array. We make use of of a set to avoid redundantly storing same prime factor again and again. Hence, we finding the individual contribution of each element within the array, we can find the total number of distinct prime factors.\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n\\n    set<int> primefactors(int n) \\n    { \\n        set<int> s;\\n        while (n%2 == 0) \\n        { \\n            s.insert(2);\\n            n = n/2; \\n        } \\n\\n        for (int i = 3; i <= sqrt(n); i = i+2) \\n        { \\n            while (n%i == 0) \\n            { \\n                n = n/i; \\n                s.insert(i);\\n            } \\n        } \\n\\n        if(n > 2) {\\n            s.insert(n);\\n        }\\n        return s;\\n\\n    }\\n    int distinctPrimeFactors(vector<int>& nums)\\n    {\\n        unordered_set<int>s;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            set<int> primefs = primefactors(nums[i]);\\n            for(auto it : primefs) \\n            {\\n                s.insert(it);\\n                cout<<it<<\" \";\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n\\n    set<int> primefactors(int n) \\n    { \\n        set<int> s;\\n        while (n%2 == 0) \\n        { \\n            s.insert(2);\\n            n = n/2; \\n        } \\n\\n        for (int i = 3; i <= sqrt(n); i = i+2) \\n        { \\n            while (n%i == 0) \\n            { \\n                n = n/i; \\n                s.insert(i);\\n            } \\n        } \\n\\n        if(n > 2) {\\n            s.insert(n);\\n        }\\n        return s;\\n\\n    }\\n    int distinctPrimeFactors(vector<int>& nums)\\n    {\\n        unordered_set<int>s;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            set<int> primefs = primefactors(nums[i]);\\n            for(auto it : primefs) \\n            {\\n                s.insert(it);\\n                cout<<it<<\" \";\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3422739,
                "title": "simple-c-solution",
                "content": "# Intuition\\nIterate through given list, find prime factors for each number and add them to a global set.\\n\\n# Approach\\nWrite an optimised code for finding prime factors. Maintain a global set for storing unique prime factors of all numbers. At the end return the size of the global set.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    set<int> primeFactors(int n) \\n    { \\n        set<int> s;\\n        while (n%2 == 0) \\n        { \\n            s.insert(2);\\n            n = n/2; \\n        } \\n\\n        for (int i = 3; i <= sqrt(n); i = i+2) \\n        { \\n            while (n%i == 0) \\n            { \\n                n = n/i; \\n                s.insert(i);\\n            } \\n        } \\n\\n        if(n > 2) {\\n            s.insert(n);\\n        }\\n        \\n        return s;\\n\\n    }\\n\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        int cnt = 0;\\n        set<int> ans;\\n        for(int i=0;i<nums.size();i++) {\\n            set<int> s = primeFactors(nums[i]);\\n            for(auto it: s) {\\n                ans.insert(it);\\n            }\\n        }\\n\\n        return ans.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<int> primeFactors(int n) \\n    { \\n        set<int> s;\\n        while (n%2 == 0) \\n        { \\n            s.insert(2);\\n            n = n/2; \\n        } \\n\\n        for (int i = 3; i <= sqrt(n); i = i+2) \\n        { \\n            while (n%i == 0) \\n            { \\n                n = n/i; \\n                s.insert(i);\\n            } \\n        } \\n\\n        if(n > 2) {\\n            s.insert(n);\\n        }\\n        \\n        return s;\\n\\n    }\\n\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        int cnt = 0;\\n        set<int> ans;\\n        for(int i=0;i<nums.size();i++) {\\n            set<int> s = primeFactors(nums[i]);\\n            for(auto it: s) {\\n                ans.insert(it);\\n            }\\n        }\\n\\n        return ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415630,
                "title": "java-using-set-o-n-k",
                "content": "# Complexity\\n- Time complexity: O(N * K), where K is the number of prime factors of a number\\n\\n# Code\\n```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        Set<Integer> setPrimes = new HashSet<>();\\n        for (int n : nums) {\\n            int temp = n, start = 2;\\n            while (temp > 1) {\\n                if (temp % start == 0) {\\n                    temp /= start;\\n                    setPrimes.add(start);\\n                } else {\\n                    start++;\\n                }\\n            }\\n        }\\n        return setPrimes.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        Set<Integer> setPrimes = new HashSet<>();\\n        for (int n : nums) {\\n            int temp = n, start = 2;\\n            while (temp > 1) {\\n                if (temp % start == 0) {\\n                    temp /= start;\\n                    setPrimes.add(start);\\n                } else {\\n                    start++;\\n                }\\n            }\\n        }\\n        return setPrimes.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394415,
                "title": "java-solution-easy-to-understand-beats-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int distinctPrimeFactors(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        HashSet<Integer> temp = new HashSet<>();\\n        for(int i : nums){\\n            temp.add(i);\\n        }\\n        for(int i : temp){\\n            primeFactors(i,set);\\n        }\\n        return set.size();\\n    }\\n\\n    public static void primeFactors(int n,HashSet<Integer> set){\\n        int prime=2;\\n        while(n>1){\\n            if(isPrime(n)){\\n                set.add(n);\\n                return;\\n            }\\n            else{\\n                if(n%prime==0){\\n                    while((n%prime)==0){\\n                        n=n/prime;\\n                        set.add(prime);\\n                    }\\n\\n                }\\n                prime=nextPrime(prime);\\n            }\\n        }\\n    }\\n    public static int nextPrime(int n){\\n        n++;\\n        while(true){\\n            int c=0;\\n            for(int i=2;i<(int)(Math.sqrt(n)+1);i++){\\n                if(n%i==0){\\n                    c=1;\\n                    break;\\n                }\\n            }\\n            if(c==0){\\n                return n;\\n            }\\n            else n++;\\n        }\\n    }\\n    public static boolean isPrime(int n){\\n        for(int i=2;i<(int)(Math.sqrt(n)+1);i++){\\n            if(n%i==0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public static int distinctPrimeFactors(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        HashSet<Integer> temp = new HashSet<>();\\n        for(int i : nums){\\n            temp.add(i);\\n        }\\n        for(int i : temp){\\n            primeFactors(i,set);\\n        }\\n        return set.size();\\n    }\\n\\n    public static void primeFactors(int n,HashSet<Integer> set){\\n        int prime=2;\\n        while(n>1){\\n            if(isPrime(n)){\\n                set.add(n);\\n                return;\\n            }\\n            else{\\n                if(n%prime==0){\\n                    while((n%prime)==0){\\n                        n=n/prime;\\n                        set.add(prime);\\n                    }\\n\\n                }\\n                prime=nextPrime(prime);\\n            }\\n        }\\n    }\\n    public static int nextPrime(int n){\\n        n++;\\n        while(true){\\n            int c=0;\\n            for(int i=2;i<(int)(Math.sqrt(n)+1);i++){\\n                if(n%i==0){\\n                    c=1;\\n                    break;\\n                }\\n            }\\n            if(c==0){\\n                return n;\\n            }\\n            else n++;\\n        }\\n    }\\n    public static boolean isPrime(int n){\\n        for(int i=2;i<(int)(Math.sqrt(n)+1);i++){\\n            if(n%i==0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394398,
                "title": "c-solution-easy-solution-faster-than-100",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N sqrt(m))\\nwhere m is max number in array\\n\\n# Code\\n```\\npublic class Solution {\\n    public int DistinctPrimeFactors(int[] nums) {\\n        HashSet<int> set = new HashSet<int>();\\n        void getFactors(int num){\\n            for(int i = 2; i * i<= num;i++){\\n                while(num % i == 0){\\n                    set.Add(i);\\n                    num /= i;\\n                }\\n            }\\n            if(num != 1) set.Add(num);\\n        }\\n        for(int j = 0; j < nums.Length;j++)\\n            getFactors(nums[j]);\\n        return set.Count();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Number Theory"
                ],
                "code": "```\\npublic class Solution {\\n    public int DistinctPrimeFactors(int[] nums) {\\n        HashSet<int> set = new HashSet<int>();\\n        void getFactors(int num){\\n            for(int i = 2; i * i<= num;i++){\\n                while(num % i == 0){\\n                    set.Add(i);\\n                    num /= i;\\n                }\\n            }\\n            if(num != 1) set.Add(num);\\n        }\\n        for(int j = 0; j < nums.Length;j++)\\n            getFactors(nums[j]);\\n        return set.Count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389733,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n        s = set()\\n\\n        for i in range(len(nums)):\\n            start = 2\\n            while start <= nums[i]:\\n                while nums[i]% start == 0:\\n                    s.add(start)\\n                    nums[i] = nums[i] //start\\n                start +=1\\n\\n        return len(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n        s = set()\\n\\n        for i in range(len(nums)):\\n            start = 2\\n            while start <= nums[i]:\\n                while nums[i]% start == 0:\\n                    s.add(start)\\n                    nums[i] = nums[i] //start\\n                start +=1\\n\\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383443,
                "title": "java-precalculation",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        int ans = 0;\\n        LinkedHashSet<Integer> primes = getPrimes(1000);\\n        for (int n : nums) {\\n            Set<Integer> toRemove = new HashSet<> ();\\n            for (int p : primes) {\\n                if (p > n) break;\\n                if (n % p == 0) {\\n                    ans++;\\n                    toRemove.add(p);\\n                }\\n            }\\n            primes.removeAll(toRemove);\\n        }\\n        return ans;\\n    }\\n\\n    private LinkedHashSet<Integer> getPrimes(int n) {\\n        LinkedHashSet<Integer> ans = new LinkedHashSet<> ();\\n        boolean[] isPrime = new boolean[n+1];\\n        Arrays.fill(isPrime, true);\\n        isPrime[0] = isPrime[1] = false;\\n\\n        for (int i = 2; i <= n; i++) {\\n            if (!isPrime[i]) continue;\\n            for (int j = i * i; j <= n; j += i) \\n                isPrime[j] = false;\\n        }\\n        for (int i = 2; i <= n; i++) \\n            if (isPrime[i]) ans.add(i);\\n        return ans;\\n    }\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        int ans = 0;\\n        LinkedHashSet<Integer> primes = getPrimes(1000);\\n        for (int n : nums) {\\n            Set<Integer> toRemove = new HashSet<> ();\\n            for (int p : primes) {\\n                if (p > n) break;\\n                if (n % p == 0) {\\n                    ans++;\\n                    toRemove.add(p);\\n                }\\n            }\\n            primes.removeAll(toRemove);\\n        }\\n        return ans;\\n    }\\n\\n    private LinkedHashSet<Integer> getPrimes(int n) {\\n        LinkedHashSet<Integer> ans = new LinkedHashSet<> ();\\n        boolean[] isPrime = new boolean[n+1];\\n        Arrays.fill(isPrime, true);\\n        isPrime[0] = isPrime[1] = false;\\n\\n        for (int i = 2; i <= n; i++) {\\n            if (!isPrime[i]) continue;\\n            for (int j = i * i; j <= n; j += i) \\n                isPrime[j] = false;\\n        }\\n        for (int i = 2; i <= n; i++) \\n            if (isPrime[i]) ans.add(i);\\n        return ans;\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383442,
                "title": "java-precalculation",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        int ans = 0;\\n        LinkedHashSet<Integer> primes = getPrimes(1000);\\n        for (int n : nums) {\\n            Set<Integer> toRemove = new HashSet<> ();\\n            for (int p : primes) {\\n                if (p > n) break;\\n                if (n % p == 0) {\\n                    ans++;\\n                    toRemove.add(p);\\n                }\\n            }\\n            primes.removeAll(toRemove);\\n        }\\n        return ans;\\n    }\\n\\n    private LinkedHashSet<Integer> getPrimes(int n) {\\n        LinkedHashSet<Integer> ans = new LinkedHashSet<> ();\\n        boolean[] isPrime = new boolean[n+1];\\n        Arrays.fill(isPrime, true);\\n        isPrime[0] = isPrime[1] = false;\\n\\n        for (int i = 2; i <= n; i++) {\\n            if (!isPrime[i]) continue;\\n            for (int j = i * i; j <= n; j += i) \\n                isPrime[j] = false;\\n        }\\n        for (int i = 2; i <= n; i++) \\n            if (isPrime[i]) ans.add(i);\\n        return ans;\\n    }\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        int ans = 0;\\n        LinkedHashSet<Integer> primes = getPrimes(1000);\\n        for (int n : nums) {\\n            Set<Integer> toRemove = new HashSet<> ();\\n            for (int p : primes) {\\n                if (p > n) break;\\n                if (n % p == 0) {\\n                    ans++;\\n                    toRemove.add(p);\\n                }\\n            }\\n            primes.removeAll(toRemove);\\n        }\\n        return ans;\\n    }\\n\\n    private LinkedHashSet<Integer> getPrimes(int n) {\\n        LinkedHashSet<Integer> ans = new LinkedHashSet<> ();\\n        boolean[] isPrime = new boolean[n+1];\\n        Arrays.fill(isPrime, true);\\n        isPrime[0] = isPrime[1] = false;\\n\\n        for (int i = 2; i <= n; i++) {\\n            if (!isPrime[i]) continue;\\n            for (int j = i * i; j <= n; j += i) \\n                isPrime[j] = false;\\n        }\\n        for (int i = 2; i <= n; i++) \\n            if (isPrime[i]) ans.add(i);\\n        return ans;\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379332,
                "title": "easy-to-understand-just-use-prime-factorization",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n\\n         # we don\\'t have to product the array, instead we just need prime numbers for \\n        # every element which is equal to the final product prime numbers \\n        \\n        \\n        # first I write a function that can calculate prime factorization\\n        def pf(n):\\n            factors = set()\\n            d = 2 \\n            \\n            while d*d <= n:\\n                while n%d == 0:\\n                    factors.add(d)\\n                    n //= d \\n                \\n                d += 1 \\n            \\n            if n > 1:\\n                factors.add(n)\\n            return factors \\n        # then for every element we will add if there is a new prime number to ans\\n        ans = set()\\n        for i in nums:\\n            ans |= pf(i) # for every element we will see if there is a new prime number \\n            # and if we find new prime number we will add to our set \\n        \\n        \\n        \\n        return len(ans)\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n\\n         # we don\\'t have to product the array, instead we just need prime numbers for \\n        # every element which is equal to the final product prime numbers \\n        \\n        \\n        # first I write a function that can calculate prime factorization\\n        def pf(n):\\n            factors = set()\\n            d = 2 \\n            \\n            while d*d <= n:\\n                while n%d == 0:\\n                    factors.add(d)\\n                    n //= d \\n                \\n                d += 1 \\n            \\n            if n > 1:\\n                factors.add(n)\\n            return factors \\n        # then for every element we will add if there is a new prime number to ans\\n        ans = set()\\n        for i in nums:\\n            ans |= pf(i) # for every element we will see if there is a new prime number \\n            # and if we find new prime number we will add to our set \\n        \\n        \\n        \\n        return len(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363617,
                "title": "fundamental-theorem-of-arithmetic-prime-factorization-python",
                "content": "```\\n\"\"\"\\nTreatment: Prime Factorization\\nThis is a follow-up for the video of Problem 2507.\\n\\nPlan:\\n    - Write an utility fn to get the prime factors for an positive integer \\n    - Use set ADT operations to get the dinstinct prime factors \\n    \\nHere is a simple observation: the set of prime factors in the product (say\\na_1 * a_2 * ... * a_n) is equal to the union of sets of prime factors for each a_i (1 <= i <= n).\\n\\n\"\"\"\\n\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n        \\n        # step-1 util fn to get distinct prime factors for a number\\n        def prime_factors(n):\\n            \"\"\"\\n            n >= 2\\n            \"\"\"\\n            res = set()\\n            # modulo 2\\'s\\n            while n % 2 == 0:\\n                res.add(2)\\n                n //= 2\\n\\n            # get other primes\\n            for i in range(3, int(n **0.5) + 1, 2):\\n                while n % i == 0:\\n                    res.add(i)\\n                    n //= i\\n            \\n            if n > 2:\\n                res.add(n)\\n            \\n            return res\\n        \\n        # print(prime_factors(2 * 3 ** 2 * 5))\\n        \\n        # step-2 problem logic\\n        res = set()\\n        nums = set(nums)\\n        for y in nums:\\n            res |= prime_factors(y)\\n        return len(res)\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\"\"\"\\nTreatment: Prime Factorization\\nThis is a follow-up for the video of Problem 2507.\\n\\nPlan:\\n    - Write an utility fn to get the prime factors for an positive integer \\n    - Use set ADT operations to get the dinstinct prime factors \\n    \\nHere is a simple observation: the set of prime factors in the product (say\\na_1 * a_2 * ... * a_n) is equal to the union of sets of prime factors for each a_i (1 <= i <= n).\\n\\n\"\"\"\\n\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n        \\n        # step-1 util fn to get distinct prime factors for a number\\n        def prime_factors(n):\\n            \"\"\"\\n            n >= 2\\n            \"\"\"\\n            res = set()\\n            # modulo 2\\'s\\n            while n % 2 == 0:\\n                res.add(2)\\n                n //= 2\\n\\n            # get other primes\\n            for i in range(3, int(n **0.5) + 1, 2):\\n                while n % i == 0:\\n                    res.add(i)\\n                    n //= i\\n            \\n            if n > 2:\\n                res.add(n)\\n            \\n            return res\\n        \\n        # print(prime_factors(2 * 3 ** 2 * 5))\\n        \\n        # step-2 problem logic\\n        res = set()\\n        nums = set(nums)\\n        for y in nums:\\n            res |= prime_factors(y)\\n        return len(res)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345069,
                "title": "complex",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: `O(N * logN )`\\n- Space complexity: `O( count-Of-Primes-Up-to-N )`\\n\\n# i know it is very confusing code but, trust me once you know its implementation, it\\'ll be very handy\\n# this technique is taught by sanchit jain, Optimised technique to find the Prime Factors\\n\\n# Code\\n```\\nclass Solution {\\n    unordered_set<int> s;\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        int ans = 0;\\n        for(auto  &i : nums) {\\n            // if i is prime then it has only one prime factor\\n            if(isPrime(i)) {\\n                if(s.find(i) == s.end())\\n                    s.insert(i);\\n                continue;\\n            }\\n        // or else find prime factors\\n            primeFactors(i);\\n        }\\n        return s.size();\\n    }\\n\\n    int primeFactors(int n) {\\n\\n        if(n == 1 )\\n            return 0;\\n\\n        while(n % 2 == 0)\\n        {\\n            if( s.find(2) == s.end())\\n                s.insert(2);\\n            n /= 2;\\n        }\\n        while(n % 3 == 0)\\n        {\\n            if( s.find(3) == s.end()) \\n                s.insert(3);\\n            n /= 3;\\n        }\\n\\n        for(int i=5; i*i <= n; i += 6) {\\n            while(n % i == 0) {\\n                if( s.find(i) == s.end()) \\n                    s.insert(i);\\n                n /= i;\\n            }\\n            while(n % (i+2) == 0) {\\n                if( s.find((i+2)) == s.end()) \\n                    s.insert((i+2));\\n                n /= (i+2);\\n            }\\n        }\\n        if(n > 3)\\n            s.insert(n);\\n        return s.size();\\n    }\\n\\n    bool isPrime(int N){\\n        if(N == 2 or N == 3)\\n            return 1;\\n        \\n        if(N == 1 or N % 2 == 0 or N % 3 == 0) \\n            return 0;\\n        \\n        for(int i=5; i*i<= N; i = i + 6) {\\n            if( N % i == 0 or N % (i+2) == 0)\\n                return 0;\\n        }\\n        \\n        return 1;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    unordered_set<int> s;\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        int ans = 0;\\n        for(auto  &i : nums) {\\n            // if i is prime then it has only one prime factor\\n            if(isPrime(i)) {\\n                if(s.find(i) == s.end())\\n                    s.insert(i);\\n                continue;\\n            }\\n        // or else find prime factors\\n            primeFactors(i);\\n        }\\n        return s.size();\\n    }\\n\\n    int primeFactors(int n) {\\n\\n        if(n == 1 )\\n            return 0;\\n\\n        while(n % 2 == 0)\\n        {\\n            if( s.find(2) == s.end())\\n                s.insert(2);\\n            n /= 2;\\n        }\\n        while(n % 3 == 0)\\n        {\\n            if( s.find(3) == s.end()) \\n                s.insert(3);\\n            n /= 3;\\n        }\\n\\n        for(int i=5; i*i <= n; i += 6) {\\n            while(n % i == 0) {\\n                if( s.find(i) == s.end()) \\n                    s.insert(i);\\n                n /= i;\\n            }\\n            while(n % (i+2) == 0) {\\n                if( s.find((i+2)) == s.end()) \\n                    s.insert((i+2));\\n                n /= (i+2);\\n            }\\n        }\\n        if(n > 3)\\n            s.insert(n);\\n        return s.size();\\n    }\\n\\n    bool isPrime(int N){\\n        if(N == 2 or N == 3)\\n            return 1;\\n        \\n        if(N == 1 or N % 2 == 0 or N % 3 == 0) \\n            return 0;\\n        \\n        for(int i=5; i*i<= N; i = i + 6) {\\n            if( N % i == 0 or N % (i+2) == 0)\\n                return 0;\\n        }\\n        \\n        return 1;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328706,
                "title": "fundamental-approach-c-sieve-algorithm",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        vector<int> primes;\\n        vector<bool> isPrime(1001, true);\\n        for(int i=2;i<=1001;i++) {\\n            if(isPrime[i]) {\\n                primes.push_back(i);\\n                int j=i*i;\\n                while(j <= 1001) {\\n                    isPrime[j] = false;\\n                    j += i;\\n                }\\n            }\\n        }\\n        unordered_set<int> uset;\\n        for(int i=0;i<nums.size();i++) {\\n            int j=0;\\n            while(nums[i] > 1 and j != primes.size()) {\\n                if(nums[i]%primes[j] == 0) {\\n                    uset.insert(j);\\n                    while(nums[i]%primes[j] == 0) {\\n                        nums[i] /= primes[j];\\n                    }\\n                }\\n                j++;\\n            }\\n        }\\n        return uset.size();\\n    }\\n};\\n// Please consider upvoting if the solution helped! Thank you :)\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        vector<int> primes;\\n        vector<bool> isPrime(1001, true);\\n        for(int i=2;i<=1001;i++) {\\n            if(isPrime[i]) {\\n                primes.push_back(i);\\n                int j=i*i;\\n                while(j <= 1001) {\\n                    isPrime[j] = false;\\n                    j += i;\\n                }\\n            }\\n        }\\n        unordered_set<int> uset;\\n        for(int i=0;i<nums.size();i++) {\\n            int j=0;\\n            while(nums[i] > 1 and j != primes.size()) {\\n                if(nums[i]%primes[j] == 0) {\\n                    uset.insert(j);\\n                    while(nums[i]%primes[j] == 0) {\\n                        nums[i] /= primes[j];\\n                    }\\n                }\\n                j++;\\n            }\\n        }\\n        return uset.size();\\n    }\\n};\\n// Please consider upvoting if the solution helped! Thank you :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327677,
                "title": "cpp-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        for (int i = 0; i < nums.size(); i++) {\\n            for (int j = 2; j <= nums[i]; j++) {\\n                while (nums[i] % j == 0) {\\n                    nums[i] /= j;\\n                    while (nums[i] % j == 0) {\\n                        nums[i] /= j;\\n                    }\\n                    m[j]++;\\n                }\\n                if (nums[i] == 1) {\\n                    break;\\n                }\\n            }\\n        }\\n        return m.size();\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        for (int i = 0; i < nums.size(); i++) {\\n            for (int j = 2; j <= nums[i]; j++) {\\n                while (nums[i] % j == 0) {\\n                    nums[i] /= j;\\n                    while (nums[i] % j == 0) {\\n                        nums[i] /= j;\\n                    }\\n                    m[j]++;\\n                }\\n                if (nums[i] == 1) {\\n                    break;\\n                }\\n            }\\n        }\\n        return m.size();\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297804,
                "title": "c-sieve-of-eratosthenes-sets",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        vector<int> primes;\\n        // Simple Sieve\\n        vector<bool> isPrime(1001, true);\\n        for(int i=2; i<=1001; i++){\\n            if(isPrime[i]==true){\\n                primes.push_back(i);    \\n                for(int j=i*i; j<=1001; j+=i){\\n                    isPrime[j]=false;\\n                }\\n            }\\n        }\\n\\n        unordered_set<int> st;\\n        for(int i=0; i<nums.size(); i++){\\n            int j=0; // points to first prime number (primes[0]=2)\\n            while(nums[i]>1 && j!=primes.size()){\\n                // if nums[i] is a multiple of primes[j], we divide it by primes[j] untill it is no longer divisible by primes[j]\\n                if(nums[i]%primes[j]==0){\\n                    st.insert(j);\\n                    while(nums[i]%primes[j]==0){\\n                        nums[i] /= primes[j];\\n                    }\\n                }\\n                j++; // increment to access next prime number from primes\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        vector<int> primes;\\n        // Simple Sieve\\n        vector<bool> isPrime(1001, true);\\n        for(int i=2; i<=1001; i++){\\n            if(isPrime[i]==true){\\n                primes.push_back(i);    \\n                for(int j=i*i; j<=1001; j+=i){\\n                    isPrime[j]=false;\\n                }\\n            }\\n        }\\n\\n        unordered_set<int> st;\\n        for(int i=0; i<nums.size(); i++){\\n            int j=0; // points to first prime number (primes[0]=2)\\n            while(nums[i]>1 && j!=primes.size()){\\n                // if nums[i] is a multiple of primes[j], we divide it by primes[j] untill it is no longer divisible by primes[j]\\n                if(nums[i]%primes[j]==0){\\n                    st.insert(j);\\n                    while(nums[i]%primes[j]==0){\\n                        nums[i] /= primes[j];\\n                    }\\n                }\\n                j++; // increment to access next prime number from primes\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297170,
                "title": "c-using-number-theory-for-optimization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: ~ O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void findDistinctPrimeFactors(int n, set<int> &Set)\\n    {\\n        for(int i = 2; i * i <= n; i++)\\n        {\\n            if(n % i) continue;\\n            Set.insert(i);\\n            while(n % i == 0) n /= i;\\n        }\\n\\n        if(n > 1) Set.insert(n);\\n    }\\n\\n    int distinctPrimeFactors(vector<int>& a) \\n    {\\n        set<int> Set;\\n\\n        int gcd = 0; for(auto x : a) gcd = __gcd(gcd, x);\\n        \\n        for(int i = 0; i < a.size(); i++) a[i] /= gcd;\\n\\n        findDistinctPrimeFactors(gcd, Set);\\n\\n        for(int i = 0; i < a.size(); i++)\\n            findDistinctPrimeFactors(a[i], Set);\\n\\n        return Set.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void findDistinctPrimeFactors(int n, set<int> &Set)\\n    {\\n        for(int i = 2; i * i <= n; i++)\\n        {\\n            if(n % i) continue;\\n            Set.insert(i);\\n            while(n % i == 0) n /= i;\\n        }\\n\\n        if(n > 1) Set.insert(n);\\n    }\\n\\n    int distinctPrimeFactors(vector<int>& a) \\n    {\\n        set<int> Set;\\n\\n        int gcd = 0; for(auto x : a) gcd = __gcd(gcd, x);\\n        \\n        for(int i = 0; i < a.size(); i++) a[i] /= gcd;\\n\\n        findDistinctPrimeFactors(gcd, Set);\\n\\n        for(int i = 0; i < a.size(); i++)\\n            findDistinctPrimeFactors(a[i], Set);\\n\\n        return Set.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289424,
                "title": "sweets-and-simple-solution-specially-for-beginner-easy-approach-straight-forward-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N*LogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        //int mul=1;\\n        // for(auto x : nums){\\n        //     mul = mul*x;\\n        // }\\n        int count=0;\\n        map<int,int> hashMap;\\n        int len= nums.size();\\n        for(int i=0; i<len; i++){\\n        int mul = nums[i];\\n        int c=2;\\n        \\n        while(mul>1){\\n            if(mul%c==0){\\n                if(hashMap.find(c)==hashMap.end()){\\n                    count++;\\n                    hashMap[c]++;\\n                }\\n                mul/=c;\\n            }\\n            else\\n            c++;\\n        }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        //int mul=1;\\n        // for(auto x : nums){\\n        //     mul = mul*x;\\n        // }\\n        int count=0;\\n        map<int,int> hashMap;\\n        int len= nums.size();\\n        for(int i=0; i<len; i++){\\n        int mul = nums[i];\\n        int c=2;\\n        \\n        while(mul>1){\\n            if(mul%c==0){\\n                if(hashMap.find(c)==hashMap.end()){\\n                    count++;\\n                    hashMap[c]++;\\n                }\\n                mul/=c;\\n            }\\n            else\\n            c++;\\n        }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264040,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int j=0;j<nums.length;j++){\\n            int number=nums[j];\\n            for(int i = 2; i< number; i++) {\\n                \\n                while(number%i == 0) {\\n                    set.add(i);\\n                    number = number/i;\\n                }\\n            }\\n            if(number>=2)set.add(number);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int j=0;j<nums.length;j++){\\n            int number=nums[j];\\n            for(int i = 2; i< number; i++) {\\n                \\n                while(number%i == 0) {\\n                    set.add(i);\\n                    number = number/i;\\n                }\\n            }\\n            if(number>=2)set.add(number);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255285,
                "title": "using-sieve-of-eratosthenes-in-python",
                "content": "# Intuition\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\no(nlogn)\\n\\n- Space complexity:\\n\\n# Code\\n```\\nclass Solution(object):\\n    def distinctPrimeFactors(self, nums):\\n            n = max(nums)\\n            primes = []\\n            prime = [0 for i in range(n+1)]\\n            for i in range(2,n+1):\\n                if prime[i]==0:\\n                    for j in range(i*i,n+1,i):\\n                        prime[j]=1\\n            for i in range(2,n+1):\\n                if prime[i]==0:\\n                    primes.append(i)\\n            prod = 1\\n            ans = 0\\n            for i in nums:\\n                prod = prod*i\\n            for i in primes:\\n                if prod%i==0:\\n                    ans = ans+1\\n            return ans\\n     \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def distinctPrimeFactors(self, nums):\\n            n = max(nums)\\n            primes = []\\n            prime = [0 for i in range(n+1)]\\n            for i in range(2,n+1):\\n                if prime[i]==0:\\n                    for j in range(i*i,n+1,i):\\n                        prime[j]=1\\n            for i in range(2,n+1):\\n                if prime[i]==0:\\n                    primes.append(i)\\n            prod = 1\\n            ans = 0\\n            for i in nums:\\n                prod = prod*i\\n            for i in primes:\\n                if prod%i==0:\\n                    ans = ans+1\\n            return ans\\n     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250883,
                "title": "python3-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n        def get_prime_factors(n):\\n            i = 2\\n            prime_factors = []\\n            while i*i <= n:\\n                if n%i == 0:\\n                    prime_factors.append(i)\\n                    n //= i\\n                else:\\n                    i += 1\\n            \\n            if n>1:\\n                prime_factors.append(n)\\n            \\n            return prime_factors\\n        \\n\\n        pms = set()\\n        for i in nums:\\n            get_prime = get_prime_factors(i)\\n            for p in get_prime:\\n                pms.add(p)\\n        return len(pms)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n        def get_prime_factors(n):\\n            i = 2\\n            prime_factors = []\\n            while i*i <= n:\\n                if n%i == 0:\\n                    prime_factors.append(i)\\n                    n //= i\\n                else:\\n                    i += 1\\n            \\n            if n>1:\\n                prime_factors.append(n)\\n            \\n            return prime_factors\\n        \\n\\n        pms = set()\\n        for i in nums:\\n            get_prime = get_prime_factors(i)\\n            for p in get_prime:\\n                pms.add(p)\\n        return len(pms)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246326,
                "title": "c-set",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        unordered_set<int> st;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(nums[i] == 1) st.insert(1);\\n            else{\\n                int lim = nums[i];\\n                for(int j = 2; j <= lim; j++){\\n                    if(nums[i] % j == 0){\\n                        st.insert(j);\\n                        while(nums[i] % j == 0) nums[i] /= j;\\n                    }\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        unordered_set<int> st;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(nums[i] == 1) st.insert(1);\\n            else{\\n                int lim = nums[i];\\n                for(int j = 2; j <= lim; j++){\\n                    if(nums[i] % j == 0){\\n                        st.insert(j);\\n                        while(nums[i] % j == 0) nums[i] /= j;\\n                    }\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239443,
                "title": "easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will be finding prime factors for each element and adding the prime factor in se so that we can get distinct prime factors in last.\\nWe will be finding prime factors using seive of Eratosthenes.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        int m=nums.length;\\n        HashSet<Integer> set=new HashSet<>();\\n\\n        for(int i=0;i<m;i++){\\n            int n=nums[i];\\n            int c = 2;\\n            int curr=0;\\n           \\n            while (n > 1) {\\n                if (n % c == 0) {\\n                    set.add(c);\\n                    n /= c;\\n                }\\n                else\\n                    c++;\\n            }\\n        }\\n     \\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        int m=nums.length;\\n        HashSet<Integer> set=new HashSet<>();\\n\\n        for(int i=0;i<m;i++){\\n            int n=nums[i];\\n            int c = 2;\\n            int curr=0;\\n           \\n            while (n > 1) {\\n                if (n % c == 0) {\\n                    set.add(c);\\n                    n /= c;\\n                }\\n                else\\n                    c++;\\n            }\\n        }\\n     \\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233205,
                "title": "java-solution-using-hashset-and-heap-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    static HashSet<Integer> set;\\n    public int distinctPrimeFactors(int[] nums) {\\n        set=new HashSet<>();\\n        for(int i:nums){\\n            primeFactors(i);\\n        }\\n\\n        return set.size();\\n    }\\n    public static void primeFactors(int n)\\n    {\\n        while (n % 2 == 0) {\\n            set.add(2);\\n            n /= 2;\\n        }\\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\\n            while (n % i == 0) {\\n                set.add(i);\\n                n /= i;\\n            }\\n        }\\n        if (n > 2)\\n            set.add(n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static HashSet<Integer> set;\\n    public int distinctPrimeFactors(int[] nums) {\\n        set=new HashSet<>();\\n        for(int i:nums){\\n            primeFactors(i);\\n        }\\n\\n        return set.size();\\n    }\\n    public static void primeFactors(int n)\\n    {\\n        while (n % 2 == 0) {\\n            set.add(2);\\n            n /= 2;\\n        }\\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\\n            while (n % i == 0) {\\n                set.add(i);\\n                n /= i;\\n            }\\n        }\\n        if (n > 2)\\n            set.add(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231830,
                "title": "distinct-prime-factors-of-product-of-array-c-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCheck out **hint** of the question to get the intuition, then just find the prime factor of each element of nums and store it in a set to remove duplicates.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) While n is divisible by 2, print 2 and divide n by 2. \\n2) After step 1, n must be odd. Now start a loop from i = 3 to the square root of n. While i divides n, print i, and divide n by i. After i fails to divide n, increment i by 2 and continue. \\n3) If n is a prime number and is greater than 2, then n will not become 1 by the above two steps. So print n if it is greater than 2.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^3)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        set<int> s;\\n\\n        for(int i=0;i<nums.size();i++){\\n            // store element of nums in temp on each loop\\n            int temp=nums[i];\\n\\n            // Checking for the temp is divisible by 2\\n            while(temp%2==0){\\n                s.insert(2);\\n                temp=temp/2;\\n            }\\n\\n            // temp must be odd at this point. So we can skip\\n            // one element (Note j = j +2)\\n            for(int j=3;j<=sqrt(temp);j=j+2){\\n                // While j divides temp, print i and divide temp by j\\n                while(temp%j==0){\\n                    s.insert(j);\\n                    temp=temp/j;\\n                }\\n            }\\n\\n            // This condition is to handle the case when temp\\n            // is a prime number greater than 2\\n            if(temp>2)\\n                s.insert(temp);\\n        }\\n        // return set size\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        set<int> s;\\n\\n        for(int i=0;i<nums.size();i++){\\n            // store element of nums in temp on each loop\\n            int temp=nums[i];\\n\\n            // Checking for the temp is divisible by 2\\n            while(temp%2==0){\\n                s.insert(2);\\n                temp=temp/2;\\n            }\\n\\n            // temp must be odd at this point. So we can skip\\n            // one element (Note j = j +2)\\n            for(int j=3;j<=sqrt(temp);j=j+2){\\n                // While j divides temp, print i and divide temp by j\\n                while(temp%j==0){\\n                    s.insert(j);\\n                    temp=temp/j;\\n                }\\n            }\\n\\n            // This condition is to handle the case when temp\\n            // is a prime number greater than 2\\n            if(temp>2)\\n                s.insert(temp);\\n        }\\n        // return set size\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230160,
                "title": "c-easy-understanding-maths",
                "content": "just find the number of prime factors for each number and store them in map or set then return its size\\n```\\nclass Solution {\\npublic:\\n    void helper(int n,unordered_map<int,int>&ourmap){        \\n       int i=2;\\n       while(n!=1){           \\n           if(n%i==0){\\n               n=n/i;\\n               ourmap[i]++;\\n           }\\n           else{\\n               i++;\\n           }\\n       }\\n    }\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        \\n        unordered_map<int,int> ourmap;\\n        for(int i=0;i<nums.size();i++){\\n            helper(nums[i],ourmap);\\n        }\\n        return ourmap.size();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void helper(int n,unordered_map<int,int>&ourmap){        \\n       int i=2;\\n       while(n!=1){           \\n           if(n%i==0){\\n               n=n/i;\\n               ourmap[i]++;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 3219700,
                "title": "prime-factorization",
                "content": "```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        \\n        set<int>store;\\n        \\n        int x;\\n        \\n        for(int & val : nums){\\n\\n            x = sqrt(val);\\n\\n            for(int i = 2; i <=x; i++){\\n\\n                   if(val%i==0){\\n                        store.insert(i);\\n                        while(val%i==0){ val/=i; }\\n\\n                  }\\n\\n            }\\n            \\n            if(val >1)store.insert(val);\\n        }\\n\\n        \\n\\n        return store.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        \\n        set<int>store;\\n        \\n        int x;\\n        \\n        for(int & val : nums){\\n\\n            x = sqrt(val);\\n\\n            for(int i = 2; i <=x; i++){\\n\\n                   if(val%i==0){\\n                        store.insert(i);\\n                        while(val%i==0){ val/=i; }\\n\\n                  }\\n\\n            }\\n            \\n            if(val >1)store.insert(val);\\n        }\\n\\n        \\n\\n        return store.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218948,
                "title": "dart-naive-approach-with-set",
                "content": "# Complexity\\n- Time complexity:\\nO(NLogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nimport \\'dart:collection\\';\\n\\nclass Solution {\\n  int distinctPrimeFactors(List<int> nums) {\\n    HashSet<int> set = HashSet();\\n    for (var x in nums.toSet()) {\\n        set.addAll(distinctPrimeFactorsForX(x));\\n    }\\n    return set.length;\\n  }\\n  \\n  HashSet<int> distinctPrimeFactorsForX(int n) {\\n    HashSet<int> factors = HashSet();\\n    int divisor = 2;\\n    while (n > 1) {\\n        if (n % divisor == 0) {\\n        factors.add(divisor);\\n        n ~/=\\n            divisor; // divide n by divisor and round down to the nearest integer\\n        } else {\\n        divisor++;\\n        }\\n    }\\n    return factors;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nimport \\'dart:collection\\';\\n\\nclass Solution {\\n  int distinctPrimeFactors(List<int> nums) {\\n    HashSet<int> set = HashSet();\\n    for (var x in nums.toSet()) {\\n        set.addAll(distinctPrimeFactorsForX(x));\\n    }\\n    return set.length;\\n  }\\n  \\n  HashSet<int> distinctPrimeFactorsForX(int n) {\\n    HashSet<int> factors = HashSet();\\n    int divisor = 2;\\n    while (n > 1) {\\n        if (n % divisor == 0) {\\n        factors.add(divisor);\\n        n ~/=\\n            divisor; // divide n by divisor and round down to the nearest integer\\n        } else {\\n        divisor++;\\n        }\\n    }\\n    return factors;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201024,
                "title": "scala-mutalbe-divisor-set",
                "content": "# Code\\n```\\nobject Solution {\\n  def distinctPrimeFactors(nums: Array[Int]): Int = {\\n    val primes = getPrimes(List(2), 3, 1000)\\n    val divisors = scala.collection.mutable.Set.empty[Int]\\n    for {\\n      num <- nums\\n      prime <- primes\\n    } if (num % prime == 0) divisors.add(prime)\\n    divisors.size\\n  }\\n\\n  def getPrimes(known: List[Int], n: Int, limit: Int): List[Int] =\\n    if (n > limit) known\\n    else if (!known.exists(n % _ == 0)) getPrimes(n :: known, n + 1, limit)\\n    else getPrimes(known, n + 1, limit)\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def distinctPrimeFactors(nums: Array[Int]): Int = {\\n    val primes = getPrimes(List(2), 3, 1000)\\n    val divisors = scala.collection.mutable.Set.empty[Int]\\n    for {\\n      num <- nums\\n      prime <- primes\\n    } if (num % prime == 0) divisors.add(prime)\\n    divisors.size\\n  }\\n\\n  def getPrimes(known: List[Int], n: Int, limit: Int): List[Int] =\\n    if (n > limit) known\\n    else if (!known.exists(n % _ == 0)) getPrimes(n :: known, n + 1, limit)\\n    else getPrimes(known, n + 1, limit)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3196886,
                "title": "prime-factorization-o-logn-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing prime factorization technique we find the prime factors of each element of vector and store it in set ds (for getting unique factors)\\nThis PFacto technique runs in almost O(log(n)) time .\\n\\n\\n```\\nclass Solution {\\n    void f(int n,set<int>&s){\\n        int p=0;\\n        for(int i=2;i<=n;i++){\\n            if(n%i==0){\\n                 while(n%i==0){\\n                     n/=i;\\n                 }\\n                 s.insert(i);\\n            }\\n        }\\n        \\n    }\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        long long pro=1;\\n        int n=nums.size();\\n        int cnt=0;\\n        set<int>s;\\n        for(int i=0;i<n;i++){\\n            f(nums[i],s);\\n            \\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void f(int n,set<int>&s){\\n        int p=0;\\n        for(int i=2;i<=n;i++){\\n            if(n%i==0){\\n                 while(n%i==0){\\n                     n/=i;\\n                 }\\n                 s.insert(i);\\n            }\\n        }\\n        \\n    }\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        long long pro=1;\\n        int n=nums.size();\\n        int cnt=0;\\n        set<int>s;\\n        for(int i=0;i<n;i++){\\n            f(nums[i],s);\\n            \\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3191058,
                "title": "thanks-to-codencode",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        set<int>s;\\n        for(int j=0;j<nums.size();j++){\\n        for(int i=2;i<=nums[j];i++){\\n            if(nums[j]%i==0){\\n                while(nums[j]%i==0)\\n                nums[j]/=i;\\n                cout<<i;\\n                s.insert(i);\\n            }\\n        }}\\n    return s.size();}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        set<int>s;\\n        for(int j=0;j<nums.size();j++){\\n        for(int i=2;i<=nums[j];i++){\\n            if(nums[j]%i==0){\\n                while(nums[j]%i==0)\\n                nums[j]/=i;\\n                cout<<i;\\n                s.insert(i);\\n            }\\n        }}\\n    return s.size();}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3173959,
                "title": "ok",
                "content": "```\\nint distinctPrimeFactors(vector<int>& nn)\\n{\\n\\tint p[]{2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,\\n\\t\\t\\t191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,\\n\\t\\t\\t397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,\\n\\t\\t\\t617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,\\n\\t\\t\\t857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997};\\n\\tint l(size(p));\\n\\tfor(const auto & n : nn)\\n\\t\\tfor(int i{}; i<l; n%p[i] ? ++i : (swap(p[i], p[l-1]), --l));\\n\\treturn size(p)-l;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint distinctPrimeFactors(vector<int>& nn)\\n{\\n\\tint p[]{2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,\\n\\t\\t\\t191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,\\n\\t\\t\\t397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,\\n\\t\\t\\t617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,\\n\\t\\t\\t857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997};\\n\\tint l(size(p));\\n\\tfor(const auto & n : nn)\\n\\t\\tfor(int i{}; i<l; n%p[i] ? ++i : (swap(p[i], p[l-1]), --l));\\n\\treturn size(p)-l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3165729,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n       set<int> s;\\n     for(int i=0; i<nums.size(); i++){  \\n          int n=nums[i];\\n          while (n % 2 == 0)\\n    {\\n       s.insert(2);\\n        n = n/2;\\n    }\\nfor (int i =3; i<= sqrt(n); i+=2)\\n{\\n    while (n%i == 0)\\n        {\\n           s.insert(i);\\n            n = n/i;\\n        }\\n    }\\n    if (n>2)\\n      s.insert(n);\\n     }\\nreturn s.size();\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n       set<int> s;\\n     for(int i=0; i<nums.size(); i++){  \\n          int n=nums[i];\\n          while (n % 2 == 0)\\n    {\\n       s.insert(2);\\n        n = n/2;\\n    }\\nfor (int i =3; i<= sqrt(n); i+=2)\\n{\\n    while (n%i == 0)\\n        {\\n           s.insert(i);\\n            n = n/i;\\n        }\\n    }\\n    if (n>2)\\n      s.insert(n);\\n     }\\nreturn s.size();\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165320,
                "title": "using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere is no need of finding the product of array.You can just find the prime factors for each element\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere is no need of finding the product of array.You can just find the prime factors for each element\\n# Complexity\\n- Time complexity:\\n\\nO(n^2)\\n- Space complexity:\\n\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    HashSet<Integer> hs=new HashSet<>();\\n    int count=0;;\\n    public int distinctPrimeFactors(int[] nums) {\\n        int n=nums.length;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=2;j<=nums[i];j++){\\n                if(!hs.contains(j)){\\n                    if(isPrime(j)&& nums[i]%j==0){\\n                        hs.add(j);\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count; \\n    }\\n    \\n    public boolean isPrime(int number){\\n        if(number==2) return true;\\n        else if(number%2==0) return false;\\n        else {\\n            for(int i=3;i<=Math.sqrt(number);i+=2){\\n                if(number%i==0) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    HashSet<Integer> hs=new HashSet<>();\\n    int count=0;;\\n    public int distinctPrimeFactors(int[] nums) {\\n        int n=nums.length;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=2;j<=nums[i];j++){\\n                if(!hs.contains(j)){\\n                    if(isPrime(j)&& nums[i]%j==0){\\n                        hs.add(j);\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count; \\n    }\\n    \\n    public boolean isPrime(int number){\\n        if(number==2) return true;\\n        else if(number%2==0) return false;\\n        else {\\n            for(int i=3;i<=Math.sqrt(number);i+=2){\\n                if(number%i==0) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162651,
                "title": "easy-java-solutin",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        Set<Integer> set = new HashSet();\\n        //Find all the prime factors of the elements in array nums\\n        for (int num : nums) {\\n            for (int i = 2; i <= num; i++) {\\n                while (num % i == 0) {\\n                    set.add(i);\\n                    num = num / i;\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        Set<Integer> set = new HashSet();\\n        //Find all the prime factors of the elements in array nums\\n        for (int num : nums) {\\n            for (int i = 2; i <= num; i++) {\\n                while (num % i == 0) {\\n                    set.add(i);\\n                    num = num / i;\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148593,
                "title": "java-eay-solution-with-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```\\nRun a loop i for all elements in nums\\n    Run a loop j from 2 to num[i]\\n        - if the element is divisible by j, add it to a set\\n        set is used because we only want to store distinct primes\\n        - while num[i] is divisible by j, divide num[i] by j, \\n        this is done to remove all non-prime numbers like, \\n        4, 6, 8 divided by 2 will be reduced to 1, 1, 1 \\n        and 9 divided by 3 will be reduced to 1\\nReturn the size of set\\n```\\n# Code\\n```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int i = 0; i < nums.length; i++){\\n            for(int j = 2; j <= nums[i]; j++){\\n                if(nums[i] % j == 0)\\n                    set.add(j);\\n                while(nums[i] % j == 0)\\n                    nums[i] = nums[i] / j; \\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nRun a loop i for all elements in nums\\n    Run a loop j from 2 to num[i]\\n        - if the element is divisible by j, add it to a set\\n        set is used because we only want to store distinct primes\\n        - while num[i] is divisible by j, divide num[i] by j, \\n        this is done to remove all non-prime numbers like, \\n        4, 6, 8 divided by 2 will be reduced to 1, 1, 1 \\n        and 9 divided by 3 will be reduced to 1\\nReturn the size of set\\n```\n```\\nclass Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int i = 0; i < nums.length; i++){\\n            for(int j = 2; j <= nums[i]; j++){\\n                if(nums[i] % j == 0)\\n                    set.add(j);\\n                while(nums[i] % j == 0)\\n                    nums[i] = nums[i] / j; \\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146838,
                "title": "c-golang",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        vector<int> isPrime(1001, true);\\n        isPrime[0] = isPrime[1] = false;\\n        for(int i = 2; i <= 1000; i++) {\\n            if(!isPrime[i]) continue;\\n            for(int j = i + i; j <= 1000; j += i) {\\n                isPrime[j] = false;\\n            }\\n        }\\n        unordered_set<int> Set;\\n        for(int num: nums) {\\n            for(int i = 2; i <= num; i++) {\\n                if(!isPrime[i]) continue;\\n                while(num > 1 && num % i == 0) {\\n                    Set.insert(i);\\n                    num /= i;\\n                }\\n            }\\n        }\\n        return Set.size();\\n    }\\n};\\n\\nOR\\n\\n// C++\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        vector<int> prime = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31};\\n        unordered_set<int> Set;\\n        for(int num: nums) {\\n            for(int p: prime) {\\n                while(num > 1 && num % p == 0) {\\n                    Set.insert(p);\\n                    num /= p;\\n                }\\n            }\\n            if(num > 1) Set.insert(num);\\n        }\\n        return Set.size();\\n    }\\n};\\n\\n\\n// Golang\\nfunc distinctPrimeFactors(nums []int) int {\\n    notPrime := make([]bool, 1001)\\n    notPrime[0], notPrime[1] = true, true\\n    for i := 2; i <= 1000; i++ {\\n        if notPrime[i] {continue}\\n        for j := i + i; j <= 1000; j += i {\\n            notPrime[j] = true\\n        }\\n    }\\n    Set := make(map[int]bool)\\n    for _, num := range nums {\\n        for i := 2; i <= num; i++ {\\n            if notPrime[i] {continue}\\n            for num > 1 && num % i == 0 {\\n                Set[i] = true\\n                num /= i\\n            }\\n        }\\n    }\\n    return len(Set)\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        vector<int> isPrime(1001, true);\\n        isPrime[0] = isPrime[1] = false;\\n        for(int i = 2; i <= 1000; i++) {\\n            if(!isPrime[i]) continue;\\n            for(int j = i + i; j <= 1000; j += i) {\\n                isPrime[j] = false;\\n            }\\n        }\\n        unordered_set<int> Set;\\n        for(int num: nums) {\\n            for(int i = 2; i <= num; i++) {\\n                if(!isPrime[i]) continue;\\n                while(num > 1 && num % i == 0) {\\n                    Set.insert(i);\\n                    num /= i;\\n                }\\n            }\\n        }\\n        return Set.size();\\n    }\\n};\\n\\nOR\\n\\n// C++\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        vector<int> prime = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31};\\n        unordered_set<int> Set;\\n        for(int num: nums) {\\n            for(int p: prime) {\\n                while(num > 1 && num % p == 0) {\\n                    Set.insert(p);\\n                    num /= p;\\n                }\\n            }\\n            if(num > 1) Set.insert(num);\\n        }\\n        return Set.size();\\n    }\\n};\\n\\n\\n// Golang\\nfunc distinctPrimeFactors(nums []int) int {\\n    notPrime := make([]bool, 1001)\\n    notPrime[0], notPrime[1] = true, true\\n    for i := 2; i <= 1000; i++ {\\n        if notPrime[i] {continue}\\n        for j := i + i; j <= 1000; j += i {\\n            notPrime[j] = true\\n        }\\n    }\\n    Set := make(map[int]bool)\\n    for _, num := range nums {\\n        for i := 2; i <= num; i++ {\\n            if notPrime[i] {continue}\\n            for num > 1 && num % i == 0 {\\n                Set[i] = true\\n                num /= i\\n            }\\n        }\\n    }\\n    return len(Set)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145563,
                "title": "c-clean-simple-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:map<int,int> p;\\n     void check(int n)\\n     {\\n         int d=2;\\n         while(n>1)\\n         {\\n             if(n%d==0)\\n             {\\n                 p[d]++;\\n                 n=n/d;\\n             }\\n             else d++;\\n         }\\n         return ;\\n     }\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        for(auto i : nums)\\n        check(i);\\n        return p.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:map<int,int> p;\\n     void check(int n)\\n     {\\n         int d=2;\\n         while(n>1)\\n         {\\n             if(n%d==0)\\n             {\\n                 p[d]++;\\n                 n=n/d;\\n             }\\n             else d++;\\n         }\\n         return ;\\n     }\\n    int distinctPrimeFactors(vector<int>& nums) {\\n        for(auto i : nums)\\n        check(i);\\n        return p.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144494,
                "title": "combine-prime-factors",
                "content": "```\\nclass Solution:\\n    def factors(self, n):\\n        i = 2\\n        factors = set()\\n        while i * i <= n:\\n            if n % i:\\n                i += 1\\n            else:\\n                while n % i == 0:\\n                    n //= i\\n                factors.add(i)\\n        if n > 1:\\n            factors.add(n)\\n        return factors\\n    \\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n        res = set()\\n        for el in nums:\\n            res.update(self.factors(el))\\n        return len(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def factors(self, n):\\n        i = 2\\n        factors = set()\\n        while i * i <= n:\\n            if n % i:\\n                i += 1\\n            else:\\n                while n % i == 0:\\n                    n //= i\\n                factors.add(i)\\n        if n > 1:\\n            factors.add(n)\\n        return factors\\n    \\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n        res = set()\\n        for el in nums:\\n            res.update(self.factors(el))\\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140275,
                "title": "simple-java-solution",
                "content": "class Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        HashSet<Integer> obj=new HashSet<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int x=nums[i];\\n            for(int j=2;j<=x;j++)\\n            {\\n                while(x%j==0)\\n                {\\n                    if(!obj.contains(j))\\n                    {\\n                        obj.add(j);\\n                    }\\n                    x/=j;\\n                }\\n            }\\n        }\\n        return obj.size();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        HashSet<Integer> obj=new HashSet<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int x=nums[i];\\n            for(int j=2;j<=x;j++)\\n            {\\n                while(x%j==0)\\n                {\\n                    if(!obj.contains(j))\\n                    {\\n                        obj.add(j);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3138851,
                "title": "c-solution-3-approaches-2-overflow-1-optimized",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        //APPROACH 1 -> TLE , BUFFER OVERFLOW\\n        /*long long int pro=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            pro=pro*nums[i];\\n        }\\n        set<int>count;\\n        while(pro%2==0)\\n        {\\n            count.insert(2);\\n            pro=pro%2;\\n        }\\n        \\n        for(int i=3;i<=sqrt(pro);i=i+2)\\n        {\\n            while(pro%i==0)\\n            {\\n                count.insert(i);\\n                pro=pro/i;\\n            }\\n            \\n        }\\n        \\n        return count.size(); */\\n        \\n        //APPROACH 2 OVERFLOW \\n        /*int c=2;\\n        while(pro>1)\\n        {\\n            if(pro%c==0)\\n            {\\n                count.insert(c);\\n                pro/=c;\\n            }\\n            else c++;\\n        }\\n        return count.size();*/\\n\\n        //APPROAC 3 RUNNING FINE\\n        for(int i=0;i<n;i++)\\n        {\\n            int c=2;\\n            int pro=nums[i];\\n            while(pro>1)\\n            {\\n                if(pro%c==0)\\n                {\\n                    count.insert(c);\\n                    pro/=c;\\n                }\\n                else c++;\\n            }\\n        }\\n        return count.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctPrimeFactors(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        //APPROACH 1 -> TLE , BUFFER OVERFLOW\\n        /*long long int pro=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            pro=pro*nums[i];\\n        }\\n        set<int>count;\\n        while(pro%2==0)\\n        {\\n            count.insert(2);\\n            pro=pro%2;\\n        }\\n        \\n        for(int i=3;i<=sqrt(pro);i=i+2)\\n        {\\n            while(pro%i==0)\\n            {\\n                count.insert(i);\\n                pro=pro/i;\\n            }\\n            \\n        }\\n        \\n        return count.size(); */\\n        \\n        //APPROACH 2 OVERFLOW \\n        /*int c=2;\\n        while(pro>1)\\n        {\\n            if(pro%c==0)\\n            {\\n                count.insert(c);\\n                pro/=c;\\n            }\\n            else c++;\\n        }\\n        return count.size();*/\\n\\n        //APPROAC 3 RUNNING FINE\\n        for(int i=0;i<n;i++)\\n        {\\n            int c=2;\\n            int pro=nums[i];\\n            while(pro>1)\\n            {\\n                if(pro%c==0)\\n                {\\n                    count.insert(c);\\n                    pro/=c;\\n                }\\n                else c++;\\n            }\\n        }\\n        return count.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137230,
                "title": "python-7-lines-top-down-dp",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n        @cache\\n        def find(num):\\n            if num in primes: return {num}\\n            for p in primes:\\n                if not num % p: return {p} | find(num // p)\\n        primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997}\\n        return len(reduce(set.union, (find(num) for num in nums)))\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n        @cache\\n        def find(num):\\n            if num in primes: return {num}\\n            for p in primes:\\n                if not num % p: return {p} | find(num // p)\\n        primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997}\\n        return len(reduce(set.union, (find(num) for num in nums)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135144,
                "title": "python",
                "content": "Find prime factor for each element and add it to the set and return length of set !!! \\n\\n# Code\\n```\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n        factors =set()\\n\\n        for num in nums:\\n            # find prime factors and add to the set\\n            while num%2==0:\\n                if 2 not in factors:\\n                    factors.add(2)\\n                num//=2\\n\\n            for i in range(3,num+1,2):\\n                if num==1:\\n                    break\\n\\n                while num%i==0:\\n                    if i not in factors:\\n                        factors.add(i)\\n                    num//=i\\n            \\n        return len(factors)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n        factors =set()\\n\\n        for num in nums:\\n            # find prime factors and add to the set\\n            while num%2==0:\\n                if 2 not in factors:\\n                    factors.add(2)\\n                num//=2\\n\\n            for i in range(3,num+1,2):\\n                if num==1:\\n                    break\\n\\n                while num%i==0:\\n                    if i not in factors:\\n                        factors.add(i)\\n                    num//=i\\n            \\n        return len(factors)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131764,
                "title": "ruby-solution-easy-to-understand",
                "content": "```\\nrequire \\'prime\\'\\n\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef distinct_prime_factors(nums)\\n    primes = Prime.entries(1000)\\n    set = Set.new\\n\\n    nums.each do |num|\\n        i = 0\\n        while num > 1 && i < primes.size\\n            if num % primes[i] == 0\\n                num /= primes[i]\\n                set.add(primes[i])\\n            else\\n                i += 1\\n            end\\n        end\\n    end\\n    \\n    set.size\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\nrequire \\'prime\\'\\n\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef distinct_prime_factors(nums)\\n    primes = Prime.entries(1000)\\n    set = Set.new\\n\\n    nums.each do |num|\\n        i = 0\\n        while num > 1 && i < primes.size\\n            if num % primes[i] == 0\\n                num /= primes[i]\\n                set.add(primes[i])\\n            else\\n                i += 1\\n            end\\n        end\\n    end\\n    \\n    set.size\\nend\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1737501,
                "content": [
                    {
                        "username": "_BREEZE_",
                        "content": "Help me to correct this It is giving me \\'int to large to convert exception\\' or give me some suggestion to resolve this - \\n```\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n        def prime(n):\\n            for i in range(2,int(n**0.5)+1):\\n                if n%i==0:\\n                    return 0\\n            return 1\\n        p=1\\n        for i in nums:\\n            p*=i\\n        c=0\\n        for i in range(1,int(p**0.5)+1):\\n            if p%i!=0:\\n                continue\\n            if p//i==i:\\n                if prime(i):\\n                    c+=1\\n            else:\\n                if prime(p//i):\\n                    c+=1\\n                if i!=1 and prime(i):\\n                    c+=1\\n        return c\\n```"
                    },
                    {
                        "username": "tabrezahmed375",
                        "content": " `class Solution {\npublic:\n    int distinctPrimeFactors(vector<int>& nums) {\n        long long int n=nums.size(),count=0,prod=1;\n        for(long long int i=0;i<n;i++)\n        {\n            prod*=nums[i];\n        }\n       long long int j=2,t=prod,r;\n       \n        while(t!=1)\n        {\n            r=t%j;\n            if(r==0)\n            {\n                count++;\n                t=t/j;\n                while(t%j==0) //divides repeatedly untill division is not integer\n                t/=j;\n\n                if(t==1) break;\n            }\n            j++;              \n        }\n        return count;\n\n    }\n};'\n\nim getting the error as signed integer overflow. what otehr data types i can use to increase length stored by the variables??"
                    },
                    {
                        "username": "yashankg051",
                        "content": "Is there anyone who solve this question with Dictionary?\\n"
                    },
                    {
                        "username": "allenkis",
                        "content": "Hi everyone here is my solution which did not clear all test cases.\n\nPlease can anyone help, what is wrong with below approach:\n\nSolution Link: https://leetcode.com/problems/distinct-prime-factors-of-product-of-array/submissions/868892337/"
                    },
                    {
                        "username": "allenkis",
                        "content": "[@turtleman270](/turtleman270) Thanks mate!"
                    },
                    {
                        "username": "turtleman270",
                        "content": "[@allenkis](/allenkis) There can be up to 10000 numbers, and each number can be up to 1000, so the maximum product is 1000^10^4. The testcase that you failed on was [2,14,19,19,5,13,18,10,15,20] which has a product of 35479080000 which is greater than  max int (2.147 billion)\\n"
                    },
                    {
                        "username": "allenkis",
                        "content": "[@turtleman270](/turtleman270) Thanks for helping me out. However, from the given constraints \\n\\n1 <= nums.length <= 104\\n2 <= nums[i] <= 1000\\n\\nmaximum product value can be 10 power 4 * 10 power 3 which is still in integer range. Do you see any other place where there can be a overflow."
                    },
                    {
                        "username": "turtleman270",
                        "content": "[@allenkis](/allenkis) The issue is that product becomes very large, and we\\'re getting incorrect answers due to integer overflow. You could try using a long or BigInterger to store the product as they allow for larger numbers. "
                    },
                    {
                        "username": "allenkis",
                        "content": "[@HarshGajera28](/HarshGajera28) How does that differ, please can you elaborate "
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "do not find factor of product of nums, find prime factor of every element and append into set."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy and simple <br>\\nJust Find Factors for Every Element <br>\\nMy solution Link : -> https://leetcode.com/problems/distinct-prime-factors-of-product-of-array/solutions/2977245/c-easy-and-simple-solution/\\nHappy New Year Everyone "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "What you did when you got \"int to large to convert to float\" exception\\nCan anyone guide me how to resolve it...\\n... I tried many different ways but nothing worked for me \\nThe ways i tried - divide, bit manupulation,etc"
                    },
                    {
                        "username": "vishalpoddar2468",
                        "content": "Not sure why you want to convert into decimal , but in case float is not working try double."
                    },
                    {
                        "username": "masummillat",
                        "content": "Here is a JavaScript Solution\\n  `function prime_factors(num) {\\n  function is_prime(num) {\\n    for (let i = 2; i <= Math.sqrt(num); i++)\\n    {\\n      if (num % i === 0) return false;\\n    }\\n    return true;\\n  }\\n  const result = [];\\n  for (let i = 2; i <= num; i++)\\n  {\\n    while (is_prime(i) && num % i === 0) \\n    {\\n      if (!result.includes(i)) result.push(i);\\n      num /= i;\\n    }\\n  }\\n  return result;\\n}\\n\\nvar distinctPrimeFactors = function(nums) {\\n    let stack = [];\\n    for(let i =0; i< nums.length; i++){\\n            let n = prime_factors(nums[i]);\\n            n.forEach(l => {\\n                if(!(stack.includes(l)))\\n                    stack.push(l)\\n            })\\n    }\\n    return stack.length;\\n};`"
                    }
                ]
            },
            {
                "id": 1786767,
                "content": [
                    {
                        "username": "_BREEZE_",
                        "content": "Help me to correct this It is giving me \\'int to large to convert exception\\' or give me some suggestion to resolve this - \\n```\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n        def prime(n):\\n            for i in range(2,int(n**0.5)+1):\\n                if n%i==0:\\n                    return 0\\n            return 1\\n        p=1\\n        for i in nums:\\n            p*=i\\n        c=0\\n        for i in range(1,int(p**0.5)+1):\\n            if p%i!=0:\\n                continue\\n            if p//i==i:\\n                if prime(i):\\n                    c+=1\\n            else:\\n                if prime(p//i):\\n                    c+=1\\n                if i!=1 and prime(i):\\n                    c+=1\\n        return c\\n```"
                    },
                    {
                        "username": "tabrezahmed375",
                        "content": " `class Solution {\npublic:\n    int distinctPrimeFactors(vector<int>& nums) {\n        long long int n=nums.size(),count=0,prod=1;\n        for(long long int i=0;i<n;i++)\n        {\n            prod*=nums[i];\n        }\n       long long int j=2,t=prod,r;\n       \n        while(t!=1)\n        {\n            r=t%j;\n            if(r==0)\n            {\n                count++;\n                t=t/j;\n                while(t%j==0) //divides repeatedly untill division is not integer\n                t/=j;\n\n                if(t==1) break;\n            }\n            j++;              \n        }\n        return count;\n\n    }\n};'\n\nim getting the error as signed integer overflow. what otehr data types i can use to increase length stored by the variables??"
                    },
                    {
                        "username": "yashankg051",
                        "content": "Is there anyone who solve this question with Dictionary?\\n"
                    },
                    {
                        "username": "allenkis",
                        "content": "Hi everyone here is my solution which did not clear all test cases.\n\nPlease can anyone help, what is wrong with below approach:\n\nSolution Link: https://leetcode.com/problems/distinct-prime-factors-of-product-of-array/submissions/868892337/"
                    },
                    {
                        "username": "allenkis",
                        "content": "[@turtleman270](/turtleman270) Thanks mate!"
                    },
                    {
                        "username": "turtleman270",
                        "content": "[@allenkis](/allenkis) There can be up to 10000 numbers, and each number can be up to 1000, so the maximum product is 1000^10^4. The testcase that you failed on was [2,14,19,19,5,13,18,10,15,20] which has a product of 35479080000 which is greater than  max int (2.147 billion)\\n"
                    },
                    {
                        "username": "allenkis",
                        "content": "[@turtleman270](/turtleman270) Thanks for helping me out. However, from the given constraints \\n\\n1 <= nums.length <= 104\\n2 <= nums[i] <= 1000\\n\\nmaximum product value can be 10 power 4 * 10 power 3 which is still in integer range. Do you see any other place where there can be a overflow."
                    },
                    {
                        "username": "turtleman270",
                        "content": "[@allenkis](/allenkis) The issue is that product becomes very large, and we\\'re getting incorrect answers due to integer overflow. You could try using a long or BigInterger to store the product as they allow for larger numbers. "
                    },
                    {
                        "username": "allenkis",
                        "content": "[@HarshGajera28](/HarshGajera28) How does that differ, please can you elaborate "
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "do not find factor of product of nums, find prime factor of every element and append into set."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy and simple <br>\\nJust Find Factors for Every Element <br>\\nMy solution Link : -> https://leetcode.com/problems/distinct-prime-factors-of-product-of-array/solutions/2977245/c-easy-and-simple-solution/\\nHappy New Year Everyone "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "What you did when you got \"int to large to convert to float\" exception\\nCan anyone guide me how to resolve it...\\n... I tried many different ways but nothing worked for me \\nThe ways i tried - divide, bit manupulation,etc"
                    },
                    {
                        "username": "vishalpoddar2468",
                        "content": "Not sure why you want to convert into decimal , but in case float is not working try double."
                    },
                    {
                        "username": "masummillat",
                        "content": "Here is a JavaScript Solution\\n  `function prime_factors(num) {\\n  function is_prime(num) {\\n    for (let i = 2; i <= Math.sqrt(num); i++)\\n    {\\n      if (num % i === 0) return false;\\n    }\\n    return true;\\n  }\\n  const result = [];\\n  for (let i = 2; i <= num; i++)\\n  {\\n    while (is_prime(i) && num % i === 0) \\n    {\\n      if (!result.includes(i)) result.push(i);\\n      num /= i;\\n    }\\n  }\\n  return result;\\n}\\n\\nvar distinctPrimeFactors = function(nums) {\\n    let stack = [];\\n    for(let i =0; i< nums.length; i++){\\n            let n = prime_factors(nums[i]);\\n            n.forEach(l => {\\n                if(!(stack.includes(l)))\\n                    stack.push(l)\\n            })\\n    }\\n    return stack.length;\\n};`"
                    }
                ]
            },
            {
                "id": 1737628,
                "content": [
                    {
                        "username": "_BREEZE_",
                        "content": "Help me to correct this It is giving me \\'int to large to convert exception\\' or give me some suggestion to resolve this - \\n```\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n        def prime(n):\\n            for i in range(2,int(n**0.5)+1):\\n                if n%i==0:\\n                    return 0\\n            return 1\\n        p=1\\n        for i in nums:\\n            p*=i\\n        c=0\\n        for i in range(1,int(p**0.5)+1):\\n            if p%i!=0:\\n                continue\\n            if p//i==i:\\n                if prime(i):\\n                    c+=1\\n            else:\\n                if prime(p//i):\\n                    c+=1\\n                if i!=1 and prime(i):\\n                    c+=1\\n        return c\\n```"
                    },
                    {
                        "username": "tabrezahmed375",
                        "content": " `class Solution {\npublic:\n    int distinctPrimeFactors(vector<int>& nums) {\n        long long int n=nums.size(),count=0,prod=1;\n        for(long long int i=0;i<n;i++)\n        {\n            prod*=nums[i];\n        }\n       long long int j=2,t=prod,r;\n       \n        while(t!=1)\n        {\n            r=t%j;\n            if(r==0)\n            {\n                count++;\n                t=t/j;\n                while(t%j==0) //divides repeatedly untill division is not integer\n                t/=j;\n\n                if(t==1) break;\n            }\n            j++;              \n        }\n        return count;\n\n    }\n};'\n\nim getting the error as signed integer overflow. what otehr data types i can use to increase length stored by the variables??"
                    },
                    {
                        "username": "yashankg051",
                        "content": "Is there anyone who solve this question with Dictionary?\\n"
                    },
                    {
                        "username": "allenkis",
                        "content": "Hi everyone here is my solution which did not clear all test cases.\n\nPlease can anyone help, what is wrong with below approach:\n\nSolution Link: https://leetcode.com/problems/distinct-prime-factors-of-product-of-array/submissions/868892337/"
                    },
                    {
                        "username": "allenkis",
                        "content": "[@turtleman270](/turtleman270) Thanks mate!"
                    },
                    {
                        "username": "turtleman270",
                        "content": "[@allenkis](/allenkis) There can be up to 10000 numbers, and each number can be up to 1000, so the maximum product is 1000^10^4. The testcase that you failed on was [2,14,19,19,5,13,18,10,15,20] which has a product of 35479080000 which is greater than  max int (2.147 billion)\\n"
                    },
                    {
                        "username": "allenkis",
                        "content": "[@turtleman270](/turtleman270) Thanks for helping me out. However, from the given constraints \\n\\n1 <= nums.length <= 104\\n2 <= nums[i] <= 1000\\n\\nmaximum product value can be 10 power 4 * 10 power 3 which is still in integer range. Do you see any other place where there can be a overflow."
                    },
                    {
                        "username": "turtleman270",
                        "content": "[@allenkis](/allenkis) The issue is that product becomes very large, and we\\'re getting incorrect answers due to integer overflow. You could try using a long or BigInterger to store the product as they allow for larger numbers. "
                    },
                    {
                        "username": "allenkis",
                        "content": "[@HarshGajera28](/HarshGajera28) How does that differ, please can you elaborate "
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "do not find factor of product of nums, find prime factor of every element and append into set."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy and simple <br>\\nJust Find Factors for Every Element <br>\\nMy solution Link : -> https://leetcode.com/problems/distinct-prime-factors-of-product-of-array/solutions/2977245/c-easy-and-simple-solution/\\nHappy New Year Everyone "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "What you did when you got \"int to large to convert to float\" exception\\nCan anyone guide me how to resolve it...\\n... I tried many different ways but nothing worked for me \\nThe ways i tried - divide, bit manupulation,etc"
                    },
                    {
                        "username": "vishalpoddar2468",
                        "content": "Not sure why you want to convert into decimal , but in case float is not working try double."
                    },
                    {
                        "username": "masummillat",
                        "content": "Here is a JavaScript Solution\\n  `function prime_factors(num) {\\n  function is_prime(num) {\\n    for (let i = 2; i <= Math.sqrt(num); i++)\\n    {\\n      if (num % i === 0) return false;\\n    }\\n    return true;\\n  }\\n  const result = [];\\n  for (let i = 2; i <= num; i++)\\n  {\\n    while (is_prime(i) && num % i === 0) \\n    {\\n      if (!result.includes(i)) result.push(i);\\n      num /= i;\\n    }\\n  }\\n  return result;\\n}\\n\\nvar distinctPrimeFactors = function(nums) {\\n    let stack = [];\\n    for(let i =0; i< nums.length; i++){\\n            let n = prime_factors(nums[i]);\\n            n.forEach(l => {\\n                if(!(stack.includes(l)))\\n                    stack.push(l)\\n            })\\n    }\\n    return stack.length;\\n};`"
                    }
                ]
            },
            {
                "id": 1736265,
                "content": [
                    {
                        "username": "_BREEZE_",
                        "content": "Help me to correct this It is giving me \\'int to large to convert exception\\' or give me some suggestion to resolve this - \\n```\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n        def prime(n):\\n            for i in range(2,int(n**0.5)+1):\\n                if n%i==0:\\n                    return 0\\n            return 1\\n        p=1\\n        for i in nums:\\n            p*=i\\n        c=0\\n        for i in range(1,int(p**0.5)+1):\\n            if p%i!=0:\\n                continue\\n            if p//i==i:\\n                if prime(i):\\n                    c+=1\\n            else:\\n                if prime(p//i):\\n                    c+=1\\n                if i!=1 and prime(i):\\n                    c+=1\\n        return c\\n```"
                    },
                    {
                        "username": "tabrezahmed375",
                        "content": " `class Solution {\npublic:\n    int distinctPrimeFactors(vector<int>& nums) {\n        long long int n=nums.size(),count=0,prod=1;\n        for(long long int i=0;i<n;i++)\n        {\n            prod*=nums[i];\n        }\n       long long int j=2,t=prod,r;\n       \n        while(t!=1)\n        {\n            r=t%j;\n            if(r==0)\n            {\n                count++;\n                t=t/j;\n                while(t%j==0) //divides repeatedly untill division is not integer\n                t/=j;\n\n                if(t==1) break;\n            }\n            j++;              \n        }\n        return count;\n\n    }\n};'\n\nim getting the error as signed integer overflow. what otehr data types i can use to increase length stored by the variables??"
                    },
                    {
                        "username": "yashankg051",
                        "content": "Is there anyone who solve this question with Dictionary?\\n"
                    },
                    {
                        "username": "allenkis",
                        "content": "Hi everyone here is my solution which did not clear all test cases.\n\nPlease can anyone help, what is wrong with below approach:\n\nSolution Link: https://leetcode.com/problems/distinct-prime-factors-of-product-of-array/submissions/868892337/"
                    },
                    {
                        "username": "allenkis",
                        "content": "[@turtleman270](/turtleman270) Thanks mate!"
                    },
                    {
                        "username": "turtleman270",
                        "content": "[@allenkis](/allenkis) There can be up to 10000 numbers, and each number can be up to 1000, so the maximum product is 1000^10^4. The testcase that you failed on was [2,14,19,19,5,13,18,10,15,20] which has a product of 35479080000 which is greater than  max int (2.147 billion)\\n"
                    },
                    {
                        "username": "allenkis",
                        "content": "[@turtleman270](/turtleman270) Thanks for helping me out. However, from the given constraints \\n\\n1 <= nums.length <= 104\\n2 <= nums[i] <= 1000\\n\\nmaximum product value can be 10 power 4 * 10 power 3 which is still in integer range. Do you see any other place where there can be a overflow."
                    },
                    {
                        "username": "turtleman270",
                        "content": "[@allenkis](/allenkis) The issue is that product becomes very large, and we\\'re getting incorrect answers due to integer overflow. You could try using a long or BigInterger to store the product as they allow for larger numbers. "
                    },
                    {
                        "username": "allenkis",
                        "content": "[@HarshGajera28](/HarshGajera28) How does that differ, please can you elaborate "
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "do not find factor of product of nums, find prime factor of every element and append into set."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy and simple <br>\\nJust Find Factors for Every Element <br>\\nMy solution Link : -> https://leetcode.com/problems/distinct-prime-factors-of-product-of-array/solutions/2977245/c-easy-and-simple-solution/\\nHappy New Year Everyone "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "What you did when you got \"int to large to convert to float\" exception\\nCan anyone guide me how to resolve it...\\n... I tried many different ways but nothing worked for me \\nThe ways i tried - divide, bit manupulation,etc"
                    },
                    {
                        "username": "vishalpoddar2468",
                        "content": "Not sure why you want to convert into decimal , but in case float is not working try double."
                    },
                    {
                        "username": "masummillat",
                        "content": "Here is a JavaScript Solution\\n  `function prime_factors(num) {\\n  function is_prime(num) {\\n    for (let i = 2; i <= Math.sqrt(num); i++)\\n    {\\n      if (num % i === 0) return false;\\n    }\\n    return true;\\n  }\\n  const result = [];\\n  for (let i = 2; i <= num; i++)\\n  {\\n    while (is_prime(i) && num % i === 0) \\n    {\\n      if (!result.includes(i)) result.push(i);\\n      num /= i;\\n    }\\n  }\\n  return result;\\n}\\n\\nvar distinctPrimeFactors = function(nums) {\\n    let stack = [];\\n    for(let i =0; i< nums.length; i++){\\n            let n = prime_factors(nums[i]);\\n            n.forEach(l => {\\n                if(!(stack.includes(l)))\\n                    stack.push(l)\\n            })\\n    }\\n    return stack.length;\\n};`"
                    }
                ]
            },
            {
                "id": 1736090,
                "content": [
                    {
                        "username": "_BREEZE_",
                        "content": "Help me to correct this It is giving me \\'int to large to convert exception\\' or give me some suggestion to resolve this - \\n```\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n        def prime(n):\\n            for i in range(2,int(n**0.5)+1):\\n                if n%i==0:\\n                    return 0\\n            return 1\\n        p=1\\n        for i in nums:\\n            p*=i\\n        c=0\\n        for i in range(1,int(p**0.5)+1):\\n            if p%i!=0:\\n                continue\\n            if p//i==i:\\n                if prime(i):\\n                    c+=1\\n            else:\\n                if prime(p//i):\\n                    c+=1\\n                if i!=1 and prime(i):\\n                    c+=1\\n        return c\\n```"
                    },
                    {
                        "username": "tabrezahmed375",
                        "content": " `class Solution {\npublic:\n    int distinctPrimeFactors(vector<int>& nums) {\n        long long int n=nums.size(),count=0,prod=1;\n        for(long long int i=0;i<n;i++)\n        {\n            prod*=nums[i];\n        }\n       long long int j=2,t=prod,r;\n       \n        while(t!=1)\n        {\n            r=t%j;\n            if(r==0)\n            {\n                count++;\n                t=t/j;\n                while(t%j==0) //divides repeatedly untill division is not integer\n                t/=j;\n\n                if(t==1) break;\n            }\n            j++;              \n        }\n        return count;\n\n    }\n};'\n\nim getting the error as signed integer overflow. what otehr data types i can use to increase length stored by the variables??"
                    },
                    {
                        "username": "yashankg051",
                        "content": "Is there anyone who solve this question with Dictionary?\\n"
                    },
                    {
                        "username": "allenkis",
                        "content": "Hi everyone here is my solution which did not clear all test cases.\n\nPlease can anyone help, what is wrong with below approach:\n\nSolution Link: https://leetcode.com/problems/distinct-prime-factors-of-product-of-array/submissions/868892337/"
                    },
                    {
                        "username": "allenkis",
                        "content": "[@turtleman270](/turtleman270) Thanks mate!"
                    },
                    {
                        "username": "turtleman270",
                        "content": "[@allenkis](/allenkis) There can be up to 10000 numbers, and each number can be up to 1000, so the maximum product is 1000^10^4. The testcase that you failed on was [2,14,19,19,5,13,18,10,15,20] which has a product of 35479080000 which is greater than  max int (2.147 billion)\\n"
                    },
                    {
                        "username": "allenkis",
                        "content": "[@turtleman270](/turtleman270) Thanks for helping me out. However, from the given constraints \\n\\n1 <= nums.length <= 104\\n2 <= nums[i] <= 1000\\n\\nmaximum product value can be 10 power 4 * 10 power 3 which is still in integer range. Do you see any other place where there can be a overflow."
                    },
                    {
                        "username": "turtleman270",
                        "content": "[@allenkis](/allenkis) The issue is that product becomes very large, and we\\'re getting incorrect answers due to integer overflow. You could try using a long or BigInterger to store the product as they allow for larger numbers. "
                    },
                    {
                        "username": "allenkis",
                        "content": "[@HarshGajera28](/HarshGajera28) How does that differ, please can you elaborate "
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "do not find factor of product of nums, find prime factor of every element and append into set."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy and simple <br>\\nJust Find Factors for Every Element <br>\\nMy solution Link : -> https://leetcode.com/problems/distinct-prime-factors-of-product-of-array/solutions/2977245/c-easy-and-simple-solution/\\nHappy New Year Everyone "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "What you did when you got \"int to large to convert to float\" exception\\nCan anyone guide me how to resolve it...\\n... I tried many different ways but nothing worked for me \\nThe ways i tried - divide, bit manupulation,etc"
                    },
                    {
                        "username": "vishalpoddar2468",
                        "content": "Not sure why you want to convert into decimal , but in case float is not working try double."
                    },
                    {
                        "username": "masummillat",
                        "content": "Here is a JavaScript Solution\\n  `function prime_factors(num) {\\n  function is_prime(num) {\\n    for (let i = 2; i <= Math.sqrt(num); i++)\\n    {\\n      if (num % i === 0) return false;\\n    }\\n    return true;\\n  }\\n  const result = [];\\n  for (let i = 2; i <= num; i++)\\n  {\\n    while (is_prime(i) && num % i === 0) \\n    {\\n      if (!result.includes(i)) result.push(i);\\n      num /= i;\\n    }\\n  }\\n  return result;\\n}\\n\\nvar distinctPrimeFactors = function(nums) {\\n    let stack = [];\\n    for(let i =0; i< nums.length; i++){\\n            let n = prime_factors(nums[i]);\\n            n.forEach(l => {\\n                if(!(stack.includes(l)))\\n                    stack.push(l)\\n            })\\n    }\\n    return stack.length;\\n};`"
                    }
                ]
            },
            {
                "id": 1736084,
                "content": [
                    {
                        "username": "_BREEZE_",
                        "content": "Help me to correct this It is giving me \\'int to large to convert exception\\' or give me some suggestion to resolve this - \\n```\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n        def prime(n):\\n            for i in range(2,int(n**0.5)+1):\\n                if n%i==0:\\n                    return 0\\n            return 1\\n        p=1\\n        for i in nums:\\n            p*=i\\n        c=0\\n        for i in range(1,int(p**0.5)+1):\\n            if p%i!=0:\\n                continue\\n            if p//i==i:\\n                if prime(i):\\n                    c+=1\\n            else:\\n                if prime(p//i):\\n                    c+=1\\n                if i!=1 and prime(i):\\n                    c+=1\\n        return c\\n```"
                    },
                    {
                        "username": "tabrezahmed375",
                        "content": " `class Solution {\npublic:\n    int distinctPrimeFactors(vector<int>& nums) {\n        long long int n=nums.size(),count=0,prod=1;\n        for(long long int i=0;i<n;i++)\n        {\n            prod*=nums[i];\n        }\n       long long int j=2,t=prod,r;\n       \n        while(t!=1)\n        {\n            r=t%j;\n            if(r==0)\n            {\n                count++;\n                t=t/j;\n                while(t%j==0) //divides repeatedly untill division is not integer\n                t/=j;\n\n                if(t==1) break;\n            }\n            j++;              \n        }\n        return count;\n\n    }\n};'\n\nim getting the error as signed integer overflow. what otehr data types i can use to increase length stored by the variables??"
                    },
                    {
                        "username": "yashankg051",
                        "content": "Is there anyone who solve this question with Dictionary?\\n"
                    },
                    {
                        "username": "allenkis",
                        "content": "Hi everyone here is my solution which did not clear all test cases.\n\nPlease can anyone help, what is wrong with below approach:\n\nSolution Link: https://leetcode.com/problems/distinct-prime-factors-of-product-of-array/submissions/868892337/"
                    },
                    {
                        "username": "allenkis",
                        "content": "[@turtleman270](/turtleman270) Thanks mate!"
                    },
                    {
                        "username": "turtleman270",
                        "content": "[@allenkis](/allenkis) There can be up to 10000 numbers, and each number can be up to 1000, so the maximum product is 1000^10^4. The testcase that you failed on was [2,14,19,19,5,13,18,10,15,20] which has a product of 35479080000 which is greater than  max int (2.147 billion)\\n"
                    },
                    {
                        "username": "allenkis",
                        "content": "[@turtleman270](/turtleman270) Thanks for helping me out. However, from the given constraints \\n\\n1 <= nums.length <= 104\\n2 <= nums[i] <= 1000\\n\\nmaximum product value can be 10 power 4 * 10 power 3 which is still in integer range. Do you see any other place where there can be a overflow."
                    },
                    {
                        "username": "turtleman270",
                        "content": "[@allenkis](/allenkis) The issue is that product becomes very large, and we\\'re getting incorrect answers due to integer overflow. You could try using a long or BigInterger to store the product as they allow for larger numbers. "
                    },
                    {
                        "username": "allenkis",
                        "content": "[@HarshGajera28](/HarshGajera28) How does that differ, please can you elaborate "
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "do not find factor of product of nums, find prime factor of every element and append into set."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy and simple <br>\\nJust Find Factors for Every Element <br>\\nMy solution Link : -> https://leetcode.com/problems/distinct-prime-factors-of-product-of-array/solutions/2977245/c-easy-and-simple-solution/\\nHappy New Year Everyone "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "What you did when you got \"int to large to convert to float\" exception\\nCan anyone guide me how to resolve it...\\n... I tried many different ways but nothing worked for me \\nThe ways i tried - divide, bit manupulation,etc"
                    },
                    {
                        "username": "vishalpoddar2468",
                        "content": "Not sure why you want to convert into decimal , but in case float is not working try double."
                    },
                    {
                        "username": "masummillat",
                        "content": "Here is a JavaScript Solution\\n  `function prime_factors(num) {\\n  function is_prime(num) {\\n    for (let i = 2; i <= Math.sqrt(num); i++)\\n    {\\n      if (num % i === 0) return false;\\n    }\\n    return true;\\n  }\\n  const result = [];\\n  for (let i = 2; i <= num; i++)\\n  {\\n    while (is_prime(i) && num % i === 0) \\n    {\\n      if (!result.includes(i)) result.push(i);\\n      num /= i;\\n    }\\n  }\\n  return result;\\n}\\n\\nvar distinctPrimeFactors = function(nums) {\\n    let stack = [];\\n    for(let i =0; i< nums.length; i++){\\n            let n = prime_factors(nums[i]);\\n            n.forEach(l => {\\n                if(!(stack.includes(l)))\\n                    stack.push(l)\\n            })\\n    }\\n    return stack.length;\\n};`"
                    }
                ]
            },
            {
                "id": 1743155,
                "content": [
                    {
                        "username": "_BREEZE_",
                        "content": "Help me to correct this It is giving me \\'int to large to convert exception\\' or give me some suggestion to resolve this - \\n```\\nclass Solution:\\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\\n        def prime(n):\\n            for i in range(2,int(n**0.5)+1):\\n                if n%i==0:\\n                    return 0\\n            return 1\\n        p=1\\n        for i in nums:\\n            p*=i\\n        c=0\\n        for i in range(1,int(p**0.5)+1):\\n            if p%i!=0:\\n                continue\\n            if p//i==i:\\n                if prime(i):\\n                    c+=1\\n            else:\\n                if prime(p//i):\\n                    c+=1\\n                if i!=1 and prime(i):\\n                    c+=1\\n        return c\\n```"
                    },
                    {
                        "username": "tabrezahmed375",
                        "content": " `class Solution {\npublic:\n    int distinctPrimeFactors(vector<int>& nums) {\n        long long int n=nums.size(),count=0,prod=1;\n        for(long long int i=0;i<n;i++)\n        {\n            prod*=nums[i];\n        }\n       long long int j=2,t=prod,r;\n       \n        while(t!=1)\n        {\n            r=t%j;\n            if(r==0)\n            {\n                count++;\n                t=t/j;\n                while(t%j==0) //divides repeatedly untill division is not integer\n                t/=j;\n\n                if(t==1) break;\n            }\n            j++;              \n        }\n        return count;\n\n    }\n};'\n\nim getting the error as signed integer overflow. what otehr data types i can use to increase length stored by the variables??"
                    },
                    {
                        "username": "yashankg051",
                        "content": "Is there anyone who solve this question with Dictionary?\\n"
                    },
                    {
                        "username": "allenkis",
                        "content": "Hi everyone here is my solution which did not clear all test cases.\n\nPlease can anyone help, what is wrong with below approach:\n\nSolution Link: https://leetcode.com/problems/distinct-prime-factors-of-product-of-array/submissions/868892337/"
                    },
                    {
                        "username": "allenkis",
                        "content": "[@turtleman270](/turtleman270) Thanks mate!"
                    },
                    {
                        "username": "turtleman270",
                        "content": "[@allenkis](/allenkis) There can be up to 10000 numbers, and each number can be up to 1000, so the maximum product is 1000^10^4. The testcase that you failed on was [2,14,19,19,5,13,18,10,15,20] which has a product of 35479080000 which is greater than  max int (2.147 billion)\\n"
                    },
                    {
                        "username": "allenkis",
                        "content": "[@turtleman270](/turtleman270) Thanks for helping me out. However, from the given constraints \\n\\n1 <= nums.length <= 104\\n2 <= nums[i] <= 1000\\n\\nmaximum product value can be 10 power 4 * 10 power 3 which is still in integer range. Do you see any other place where there can be a overflow."
                    },
                    {
                        "username": "turtleman270",
                        "content": "[@allenkis](/allenkis) The issue is that product becomes very large, and we\\'re getting incorrect answers due to integer overflow. You could try using a long or BigInterger to store the product as they allow for larger numbers. "
                    },
                    {
                        "username": "allenkis",
                        "content": "[@HarshGajera28](/HarshGajera28) How does that differ, please can you elaborate "
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "do not find factor of product of nums, find prime factor of every element and append into set."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy and simple <br>\\nJust Find Factors for Every Element <br>\\nMy solution Link : -> https://leetcode.com/problems/distinct-prime-factors-of-product-of-array/solutions/2977245/c-easy-and-simple-solution/\\nHappy New Year Everyone "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "What you did when you got \"int to large to convert to float\" exception\\nCan anyone guide me how to resolve it...\\n... I tried many different ways but nothing worked for me \\nThe ways i tried - divide, bit manupulation,etc"
                    },
                    {
                        "username": "vishalpoddar2468",
                        "content": "Not sure why you want to convert into decimal , but in case float is not working try double."
                    },
                    {
                        "username": "masummillat",
                        "content": "Here is a JavaScript Solution\\n  `function prime_factors(num) {\\n  function is_prime(num) {\\n    for (let i = 2; i <= Math.sqrt(num); i++)\\n    {\\n      if (num % i === 0) return false;\\n    }\\n    return true;\\n  }\\n  const result = [];\\n  for (let i = 2; i <= num; i++)\\n  {\\n    while (is_prime(i) && num % i === 0) \\n    {\\n      if (!result.includes(i)) result.push(i);\\n      num /= i;\\n    }\\n  }\\n  return result;\\n}\\n\\nvar distinctPrimeFactors = function(nums) {\\n    let stack = [];\\n    for(let i =0; i< nums.length; i++){\\n            let n = prime_factors(nums[i]);\\n            n.forEach(l => {\\n                if(!(stack.includes(l)))\\n                    stack.push(l)\\n            })\\n    }\\n    return stack.length;\\n};`"
                    }
                ]
            }
        ]
    }
]