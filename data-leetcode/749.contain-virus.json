[
    {
        "title": "Generalized Abbreviation",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1566083,
                "content": [
                    {
                        "username": "leetcoder07",
                        "content": "I have couple of question:\\n\\n    1 - Why the `word` cannot represented by `1w11` or `22`, I maybe have completed misunderstood the question? Will appreciate your answers\\n    2 - Why are using `1 2 3 4` here to abbreviate a word?\\n    3 - Generally if you have a sentence like `talk to you later -> ttyl` or `for your information -> fyi`, we use the first letter from sentence? Aren't we doing something similar here? \\n\\nQuestion may sound dumb but well I am not able to understand it. Will appreciate any help! Thank you"
                    },
                    {
                        "username": "Future6",
                        "content": "It should be a very good coding problem. However, it didn't provide specific rules for abbreviation. I am not sure how could so many people get so many accepted solutions? Is there any default abbreviation rules?"
                    },
                    {
                        "username": "zysxbhp",
                        "content": "According to the example 1, there should not be contiguous digits. \\n\\nBut the description shows an example 23 who has contiguous digits. Also, I tried a sample input \"abcdefghijklm\" and there existed continugous digits in the expected output.\\n\\nHowever, I implemented a solution which did not output any contiguous digits and got accepted....\\n"
                    },
                    {
                        "username": "fchetan",
                        "content": "\\nThe problem description says -\\n\\n`For example, \"abcde\" can be abbreviated into \"a3e\" (\"bcd\" turned into \"3\"), \"1bcd1\" (\"a\" and \"e\" both turned into \"1\"), and \"23\" (\"ab\" turned into \"2\" and \"cde\" turned into \"3\")`\\n\\nMy problem is with this part -\\n`, and \"23\" (\"ab\" turned into \"2\" and \"cde\" turned into \"3\")`\\n\\n`[\"5\",\"4e\",\"3d1\",\"3de\",\"2c2\",\"2c1e\",\"2cd1\",\"2cde\",\"1b3\",\"1b2e\",\"1b1d1\",\"1b1de\",\"1bc2\",\"1bc1e\",\"1bcd1\",\"1bcde\",\"a4\",\"a3e\",\"a2d1\",\"a2de\",\"a1c2\",\"a1c1e\",\"a1cd1\",\"a1cde\",\"ab3\",\"ab2e\",\"ab1d1\",\"ab1de\",\"abc2\",\"abc1e\",\"abcd1\",\"abcde\"]`\\n\\nThis is the expected answer by the LeetCode server for input `abcde` which does not contain `23`.\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1566780,
                "content": [
                    {
                        "username": "leetcoder07",
                        "content": "I have couple of question:\\n\\n    1 - Why the `word` cannot represented by `1w11` or `22`, I maybe have completed misunderstood the question? Will appreciate your answers\\n    2 - Why are using `1 2 3 4` here to abbreviate a word?\\n    3 - Generally if you have a sentence like `talk to you later -> ttyl` or `for your information -> fyi`, we use the first letter from sentence? Aren't we doing something similar here? \\n\\nQuestion may sound dumb but well I am not able to understand it. Will appreciate any help! Thank you"
                    },
                    {
                        "username": "Future6",
                        "content": "It should be a very good coding problem. However, it didn't provide specific rules for abbreviation. I am not sure how could so many people get so many accepted solutions? Is there any default abbreviation rules?"
                    },
                    {
                        "username": "zysxbhp",
                        "content": "According to the example 1, there should not be contiguous digits. \\n\\nBut the description shows an example 23 who has contiguous digits. Also, I tried a sample input \"abcdefghijklm\" and there existed continugous digits in the expected output.\\n\\nHowever, I implemented a solution which did not output any contiguous digits and got accepted....\\n"
                    },
                    {
                        "username": "fchetan",
                        "content": "\\nThe problem description says -\\n\\n`For example, \"abcde\" can be abbreviated into \"a3e\" (\"bcd\" turned into \"3\"), \"1bcd1\" (\"a\" and \"e\" both turned into \"1\"), and \"23\" (\"ab\" turned into \"2\" and \"cde\" turned into \"3\")`\\n\\nMy problem is with this part -\\n`, and \"23\" (\"ab\" turned into \"2\" and \"cde\" turned into \"3\")`\\n\\n`[\"5\",\"4e\",\"3d1\",\"3de\",\"2c2\",\"2c1e\",\"2cd1\",\"2cde\",\"1b3\",\"1b2e\",\"1b1d1\",\"1b1de\",\"1bc2\",\"1bc1e\",\"1bcd1\",\"1bcde\",\"a4\",\"a3e\",\"a2d1\",\"a2de\",\"a1c2\",\"a1c1e\",\"a1cd1\",\"a1cde\",\"ab3\",\"ab2e\",\"ab1d1\",\"ab1de\",\"abc2\",\"abc1e\",\"abcd1\",\"abcde\"]`\\n\\nThis is the expected answer by the LeetCode server for input `abcde` which does not contain `23`.\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1568559,
                "content": [
                    {
                        "username": "leetcoder07",
                        "content": "I have couple of question:\\n\\n    1 - Why the `word` cannot represented by `1w11` or `22`, I maybe have completed misunderstood the question? Will appreciate your answers\\n    2 - Why are using `1 2 3 4` here to abbreviate a word?\\n    3 - Generally if you have a sentence like `talk to you later -> ttyl` or `for your information -> fyi`, we use the first letter from sentence? Aren't we doing something similar here? \\n\\nQuestion may sound dumb but well I am not able to understand it. Will appreciate any help! Thank you"
                    },
                    {
                        "username": "Future6",
                        "content": "It should be a very good coding problem. However, it didn't provide specific rules for abbreviation. I am not sure how could so many people get so many accepted solutions? Is there any default abbreviation rules?"
                    },
                    {
                        "username": "zysxbhp",
                        "content": "According to the example 1, there should not be contiguous digits. \\n\\nBut the description shows an example 23 who has contiguous digits. Also, I tried a sample input \"abcdefghijklm\" and there existed continugous digits in the expected output.\\n\\nHowever, I implemented a solution which did not output any contiguous digits and got accepted....\\n"
                    },
                    {
                        "username": "fchetan",
                        "content": "\\nThe problem description says -\\n\\n`For example, \"abcde\" can be abbreviated into \"a3e\" (\"bcd\" turned into \"3\"), \"1bcd1\" (\"a\" and \"e\" both turned into \"1\"), and \"23\" (\"ab\" turned into \"2\" and \"cde\" turned into \"3\")`\\n\\nMy problem is with this part -\\n`, and \"23\" (\"ab\" turned into \"2\" and \"cde\" turned into \"3\")`\\n\\n`[\"5\",\"4e\",\"3d1\",\"3de\",\"2c2\",\"2c1e\",\"2cd1\",\"2cde\",\"1b3\",\"1b2e\",\"1b1d1\",\"1b1de\",\"1bc2\",\"1bc1e\",\"1bcd1\",\"1bcde\",\"a4\",\"a3e\",\"a2d1\",\"a2de\",\"a1c2\",\"a1c1e\",\"a1cd1\",\"a1cde\",\"ab3\",\"ab2e\",\"ab1d1\",\"ab1de\",\"abc2\",\"abc1e\",\"abcd1\",\"abcde\"]`\\n\\nThis is the expected answer by the LeetCode server for input `abcde` which does not contain `23`.\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1570396,
                "content": [
                    {
                        "username": "leetcoder07",
                        "content": "I have couple of question:\\n\\n    1 - Why the `word` cannot represented by `1w11` or `22`, I maybe have completed misunderstood the question? Will appreciate your answers\\n    2 - Why are using `1 2 3 4` here to abbreviate a word?\\n    3 - Generally if you have a sentence like `talk to you later -> ttyl` or `for your information -> fyi`, we use the first letter from sentence? Aren't we doing something similar here? \\n\\nQuestion may sound dumb but well I am not able to understand it. Will appreciate any help! Thank you"
                    },
                    {
                        "username": "Future6",
                        "content": "It should be a very good coding problem. However, it didn't provide specific rules for abbreviation. I am not sure how could so many people get so many accepted solutions? Is there any default abbreviation rules?"
                    },
                    {
                        "username": "zysxbhp",
                        "content": "According to the example 1, there should not be contiguous digits. \\n\\nBut the description shows an example 23 who has contiguous digits. Also, I tried a sample input \"abcdefghijklm\" and there existed continugous digits in the expected output.\\n\\nHowever, I implemented a solution which did not output any contiguous digits and got accepted....\\n"
                    },
                    {
                        "username": "fchetan",
                        "content": "\\nThe problem description says -\\n\\n`For example, \"abcde\" can be abbreviated into \"a3e\" (\"bcd\" turned into \"3\"), \"1bcd1\" (\"a\" and \"e\" both turned into \"1\"), and \"23\" (\"ab\" turned into \"2\" and \"cde\" turned into \"3\")`\\n\\nMy problem is with this part -\\n`, and \"23\" (\"ab\" turned into \"2\" and \"cde\" turned into \"3\")`\\n\\n`[\"5\",\"4e\",\"3d1\",\"3de\",\"2c2\",\"2c1e\",\"2cd1\",\"2cde\",\"1b3\",\"1b2e\",\"1b1d1\",\"1b1de\",\"1bc2\",\"1bc1e\",\"1bcd1\",\"1bcde\",\"a4\",\"a3e\",\"a2d1\",\"a2de\",\"a1c2\",\"a1c1e\",\"a1cd1\",\"a1cde\",\"ab3\",\"ab2e\",\"ab1d1\",\"ab1de\",\"abc2\",\"abc1e\",\"abcd1\",\"abcde\"]`\\n\\nThis is the expected answer by the LeetCode server for input `abcde` which does not contain `23`.\\n\\n\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Contain Virus",
        "question_content": "<p>A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.</p>\n\n<p>The world is modeled as an <code>m x n</code> binary grid <code>isInfected</code>, where <code>isInfected[i][j] == 0</code> represents uninfected cells, and <code>isInfected[i][j] == 1</code> represents cells contaminated with the virus. A wall (and only one wall) can be installed between any two <strong>4-directionally</strong> adjacent cells, on the shared boundary.</p>\n\n<p>Every night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall. Resources are limited. Each day, you can install walls around only one region (i.e., the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night). There <strong>will never be a tie</strong>.</p>\n\n<p>Return <em>the number of walls used to quarantine all the infected regions</em>. If the world will become fully infected, return the number of walls used.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/01/virus11-grid.jpg\" style=\"width: 500px; height: 255px;\" />\n<pre>\n<strong>Input:</strong> isInfected = [[0,1,0,0,0,0,0,1],[0,1,0,0,0,0,0,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0]]\n<strong>Output:</strong> 10\n<strong>Explanation:</strong> There are 2 contaminated regions.\nOn the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/01/virus12edited-grid.jpg\" style=\"width: 500px; height: 257px;\" />\nOn the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/01/virus13edited-grid.jpg\" style=\"width: 500px; height: 261px;\" />\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/01/virus2-grid.jpg\" style=\"width: 653px; height: 253px;\" />\n<pre>\n<strong>Input:</strong> isInfected = [[1,1,1],[1,0,1],[1,1,1]]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Even though there is only one cell saved, there are 4 walls built.\nNotice that walls are only built on the shared boundary of two different cells.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> isInfected = [[1,1,1,0,0,0,0,0,0],[1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,0,0]]\n<strong>Output:</strong> 13\n<strong>Explanation:</strong> The region on the left only builds two new walls.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m ==&nbsp;isInfected.length</code></li>\n\t<li><code>n ==&nbsp;isInfected[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>isInfected[i][j]</code> is either <code>0</code> or <code>1</code>.</li>\n\t<li>There is always a contiguous viral region throughout the described process that will <strong>infect strictly more uncontaminated squares</strong> in the next round.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 847507,
                "title": "cpp-dfs-solution-explained",
                "content": "I recently got this in an assessment. \\n\\nget clusters in every step. \\n![image](https://assets.leetcode.com/users/images/2fba1bf5-a2e6-4a08-9f3b-1c204d76a2ac_1600154624.5271661.png)\\ndeal with the largest clusters and expand all the other clusters.\\n\\nlets take the sample case\\n![image](https://assets.leetcode.com/users/images/9bfa313a-66b8-48ce-9cea-5bd596982525_1600155241.5790663.png)\\n![image](https://assets.leetcode.com/users/images/7d0a1b56-35c6-4a4f-aa12-274beca688c4_1600155666.2390857.png)\\n\\n\\n\\n```\\nclass cluster\\n{\\n    public:\\n        set<pair<int,int>> c; // set of cells that are contaminated\\n        set<pair<int,int>> uc; // set of cells that are next to this cluster and are uncontaminated\\n        int wcnt = 0;       // walls required to contain this structure \\n    \\n};\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<vector<int>> &grid, int i, int j, vector<vector<bool>> &vis, cluster &cl)\\n    {\\n        if(i == grid.size() || i < 0 || j < 0 || j == grid[0].size()||vis[i][j]||grid[i][j] == -1)\\n        {\\n            // if the current src is out of grid bounds or if the cell is already visited  or current cell is already walled that is -1\\n            return;\\n        }\\n        if(grid[i][j] == 0)\\n        {\\n            // if cell is uncontaminated then add to the uncontaminatd cells (uc) and increment wall cnt \\n            cl.wcnt++;\\n            cl.uc.insert({i,j});\\n            return;\\n        }\\n        // if current cell is contaminated add to contaminated and mark vis = true\\n        cl.c.insert({i,j});\\n        vis[i][j] = true;\\n        // call dfs in all directions\\n        dfs(grid,i+1,j,vis,cl); // above\\n        dfs(grid,i-1,j,vis,cl); // below\\n        dfs(grid,i,j+1,vis,cl); // right\\n        dfs(grid,i,j-1,vis,cl); // left\\n        \\n    }\\n\\n    int containVirus(vector<vector<int>>& grid) {\\n    \\n        // row ka size\\n        int n = grid.size();\\n        // col ka size\\n        int m = grid[0].size();\\n        int ans = 0;\\n        while(1)\\n        {\\n            // visisted matrix\\n            vector<vector<bool>> vis(n,vector<bool>(m));\\n            // comparator for pq to sort it according to size of uncontaminated cells in cluster\\n            auto comp=[](const cluster& A,const cluster& B)\\n            { \\n                return A.uc.size()<B.uc.size();\\n            };\\n            // initialise priority queue\\n            priority_queue<cluster,vector<cluster>, decltype(comp)> pq(comp);\\n            // search for a contaminated cell in the grid\\n            for(int i = 0; i<n; i++)\\n            {\\n                for(int j = 0; j<m; j++)\\n                {\\n                    if(!vis[i][j]&&grid[i][j] == 1)\\n                    {\\n                        // create a cluster\\n                        cluster c;\\n                        // call dfs\\n                        dfs(grid,i,j,vis,c);\\n                        pq.push(c);\\n\\n                    }\\n                }\\n            }\\n            // if size of priority queue is 0 the termination condition is reached ie all contaminated cells are contained.\\n            if(pq.size()==0)\\n            break;\\n            // get the biggest cluster is found make em all -1 and add the walls reqd to contain them \\n            cluster k = pq.top();\\n            pq.pop();\\n            for(auto x: k.c)\\n            {\\n                grid[x.first][x.second] = -1;\\n            }\\n            ans += k.wcnt;\\n\\n            // for the rest of the clusters make their uncontaminated cells as contaminated\\n            while(!pq.empty())\\n            {\\n                cluster k1 = pq.top();\\n                pq.pop();\\n                for(auto x: k1.uc)\\n                {\\n                    grid[x.first][x.second] = 1;\\n                }   \\n            }\\n         \\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass cluster\\n{\\n    public:\\n        set<pair<int,int>> c; // set of cells that are contaminated\\n        set<pair<int,int>> uc; // set of cells that are next to this cluster and are uncontaminated\\n        int wcnt = 0;       // walls required to contain this structure \\n    \\n};\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<vector<int>> &grid, int i, int j, vector<vector<bool>> &vis, cluster &cl)\\n    {\\n        if(i == grid.size() || i < 0 || j < 0 || j == grid[0].size()||vis[i][j]||grid[i][j] == -1)\\n        {\\n            // if the current src is out of grid bounds or if the cell is already visited  or current cell is already walled that is -1\\n            return;\\n        }\\n        if(grid[i][j] == 0)\\n        {\\n            // if cell is uncontaminated then add to the uncontaminatd cells (uc) and increment wall cnt \\n            cl.wcnt++;\\n            cl.uc.insert({i,j});\\n            return;\\n        }\\n        // if current cell is contaminated add to contaminated and mark vis = true\\n        cl.c.insert({i,j});\\n        vis[i][j] = true;\\n        // call dfs in all directions\\n        dfs(grid,i+1,j,vis,cl); // above\\n        dfs(grid,i-1,j,vis,cl); // below\\n        dfs(grid,i,j+1,vis,cl); // right\\n        dfs(grid,i,j-1,vis,cl); // left\\n        \\n    }\\n\\n    int containVirus(vector<vector<int>>& grid) {\\n    \\n        // row ka size\\n        int n = grid.size();\\n        // col ka size\\n        int m = grid[0].size();\\n        int ans = 0;\\n        while(1)\\n        {\\n            // visisted matrix\\n            vector<vector<bool>> vis(n,vector<bool>(m));\\n            // comparator for pq to sort it according to size of uncontaminated cells in cluster\\n            auto comp=[](const cluster& A,const cluster& B)\\n            { \\n                return A.uc.size()<B.uc.size();\\n            };\\n            // initialise priority queue\\n            priority_queue<cluster,vector<cluster>, decltype(comp)> pq(comp);\\n            // search for a contaminated cell in the grid\\n            for(int i = 0; i<n; i++)\\n            {\\n                for(int j = 0; j<m; j++)\\n                {\\n                    if(!vis[i][j]&&grid[i][j] == 1)\\n                    {\\n                        // create a cluster\\n                        cluster c;\\n                        // call dfs\\n                        dfs(grid,i,j,vis,c);\\n                        pq.push(c);\\n\\n                    }\\n                }\\n            }\\n            // if size of priority queue is 0 the termination condition is reached ie all contaminated cells are contained.\\n            if(pq.size()==0)\\n            break;\\n            // get the biggest cluster is found make em all -1 and add the walls reqd to contain them \\n            cluster k = pq.top();\\n            pq.pop();\\n            for(auto x: k.c)\\n            {\\n                grid[x.first][x.second] = -1;\\n            }\\n            ans += k.wcnt;\\n\\n            // for the rest of the clusters make their uncontaminated cells as contaminated\\n            while(!pq.empty())\\n            {\\n                cluster k1 = pq.top();\\n                pq.pop();\\n                for(auto x: k1.uc)\\n                {\\n                    grid[x.first][x.second] = 1;\\n                }   \\n            }\\n         \\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526848,
                "title": "java-dfs-9-ms-explanation-with-comments",
                "content": "This class **Region** hold the information for each region.\\n```\\nprivate class Region {\\n    // Using Set<Integer> instead of List<int[]> (int[] -> row and col pair),\\n    // as need to de-dupe the elements.\\n    // If N rows and M cols.\\n    // Total elements = NxM.\\n    // Given row and col calculate X as: X = row * M + col.\\n    // Given X calculate row and col as: row = X / M and col = X % M.\\n\\t\\n    // Infected nodes represented by 1.\\n    Set<Integer> infected = new HashSet<>();\\n\\n    // Uninfected neighbors represented by 0 are the ones this region can infect if not contained.\\n    Set<Integer> uninfectedNeighbors = new HashSet<>();\\n   \\n    // Number of walls required to contain all the infected nodes (1s) in this region.\\n    // Note that two infected 1s can infect the same 0, so in this case we need two walls to save one 0 from two 1s.\\n    int wallsRequired = 0;\\n}\\n```\\n\\n**Steps**:\\n1. Find all the regions.\\n2. Get the region which has most number of uninfected neighbors. This region will cause maximum damage.\\n3. For region in (2) contain the region. Mark all the infected nodes in this region as `2` to denote that these nodes are now contained and will not cause any more damage.\\n4. For the remaining regions, expand by infecting the uninfected neighbors around these regions.\\n5. Repeat steps (1) to (4) until there are no more regions with uninfected neighbors.\\n\\n```\\npublic int containVirus(int[][] grid) {\\n    if (grid == null || grid.length == 0) {\\n        return 0;\\n    }\\n\\n    int rows = grid.length;\\n    int cols = grid[0].length;\\n\\n    int result = 0;\\n\\n    while (true) {\\n        List<Region> regions = new ArrayList<>();\\n\\n        // Find all the regions using DFS (or can also use BFS).\\n        boolean[][] visited = new boolean[rows][cols];\\n        for (int row = 0; row < rows; row++) {\\n            for (int col = 0; col < cols; col++) {\\n                if (grid[row][col] == 1 && !visited[row][col]) {\\n                    Region region = new Region();\\n                    dfs(grid, row, col, visited, region);\\n\\n                    // Add region to list of regions only if it can cause infection.\\n                    if (region.uninfectedNeighbors.size() > 0) {\\n                        regions.add(region);\\n                    }\\n                }\\n            }\\n        }\\n\\n        // No more regions that can cause further infection, we are done.\\n        if (regions.size() == 0) {\\n            break;\\n        }\\n\\n        // Sort the regions. Region which can infected most neighbors first.\\n        regions.sort(new Comparator<Region>() {\\n            @Override\\n            public int compare(Region o1, Region o2) {\\n                return o2.uninfectedNeighbors.size() - o1.uninfectedNeighbors.size();\\n            }\\n        });\\n\\n        // Build wall around region which can infect most neighbors.\\n        Region regionThatCauseMostInfection = regions.remove(0);\\n        result += regionThatCauseMostInfection.wallsRequired;\\n\\n        for (int neighbor : regionThatCauseMostInfection.infected) {\\n            int row = neighbor / cols;\\n            int col = neighbor % cols;\\n\\n            // Choosing 2 as to denote that this cell is now contained\\n            // and will not cause any more infection.\\n            grid[row][col] = 2;\\n        }\\n\\n        // For remaining regions, expand (neighbors are now infected).\\n        for (Region region : regions) {\\n            for (int neighbor : region.uninfectedNeighbors) {\\n                int row = neighbor / cols;\\n                int col = neighbor % cols;\\n                grid[row][col] = 1;\\n            }\\n        }\\n    }\\n\\n    return result;\\n}\\n\\nprivate void dfs(int[][] grid, int row, int col, boolean[][] visited, Region region) {\\n    int rows = grid.length;\\n    int cols = grid[0].length;\\n\\n    if (row < 0 || row >= rows || col < 0 || col >= cols || grid[row][col] == 2) {\\n        return;\\n    }\\n\\n    if (grid[row][col] == 1) {\\n        // 1 is already infected.\\n        // Add to the list, since we are using Set it will be deduped if added multiple times.\\n        region.infected.add(row * cols + col);\\n\\n        // If already visited, return as we do not want to go into infinite recursion.\\n        if (visited[row][col]) {\\n            return;\\n        }\\n    }\\n\\n    visited[row][col] = true;\\n\\n    if (grid[row][col] == 0) {\\n        // If 0 it is uninfected neighbor, we need a wall.\\n        // Remeber we can reach this 0 multiple times from different infected neighbors i.e. 1s,\\n        // and this will account for numbers of walls need to be built around this 0.\\n        region.wallsRequired++;\\n\\n        // Add to uninfected list, it will be de-duped as we use Set.\\n        region.uninfectedNeighbors.add(row * cols + col);\\n        return;\\n    }\\n\\n    // Visit neighbors.\\n    dfs(grid, row + 1, col, visited, region);\\n    dfs(grid, row - 1, col, visited, region);\\n    dfs(grid, row, col + 1, visited, region);\\n    dfs(grid, row, col - 1, visited, region);\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nprivate class Region {\\n    // Using Set<Integer> instead of List<int[]> (int[] -> row and col pair),\\n    // as need to de-dupe the elements.\\n    // If N rows and M cols.\\n    // Total elements = NxM.\\n    // Given row and col calculate X as: X = row * M + col.\\n    // Given X calculate row and col as: row = X / M and col = X % M.\\n\\t\\n    // Infected nodes represented by 1.\\n    Set<Integer> infected = new HashSet<>();\\n\\n    // Uninfected neighbors represented by 0 are the ones this region can infect if not contained.\\n    Set<Integer> uninfectedNeighbors = new HashSet<>();\\n   \\n    // Number of walls required to contain all the infected nodes (1s) in this region.\\n    // Note that two infected 1s can infect the same 0, so in this case we need two walls to save one 0 from two 1s.\\n    int wallsRequired = 0;\\n}\\n```\n```\\npublic int containVirus(int[][] grid) {\\n    if (grid == null || grid.length == 0) {\\n        return 0;\\n    }\\n\\n    int rows = grid.length;\\n    int cols = grid[0].length;\\n\\n    int result = 0;\\n\\n    while (true) {\\n        List<Region> regions = new ArrayList<>();\\n\\n        // Find all the regions using DFS (or can also use BFS).\\n        boolean[][] visited = new boolean[rows][cols];\\n        for (int row = 0; row < rows; row++) {\\n            for (int col = 0; col < cols; col++) {\\n                if (grid[row][col] == 1 && !visited[row][col]) {\\n                    Region region = new Region();\\n                    dfs(grid, row, col, visited, region);\\n\\n                    // Add region to list of regions only if it can cause infection.\\n                    if (region.uninfectedNeighbors.size() > 0) {\\n                        regions.add(region);\\n                    }\\n                }\\n            }\\n        }\\n\\n        // No more regions that can cause further infection, we are done.\\n        if (regions.size() == 0) {\\n            break;\\n        }\\n\\n        // Sort the regions. Region which can infected most neighbors first.\\n        regions.sort(new Comparator<Region>() {\\n            @Override\\n            public int compare(Region o1, Region o2) {\\n                return o2.uninfectedNeighbors.size() - o1.uninfectedNeighbors.size();\\n            }\\n        });\\n\\n        // Build wall around region which can infect most neighbors.\\n        Region regionThatCauseMostInfection = regions.remove(0);\\n        result += regionThatCauseMostInfection.wallsRequired;\\n\\n        for (int neighbor : regionThatCauseMostInfection.infected) {\\n            int row = neighbor / cols;\\n            int col = neighbor % cols;\\n\\n            // Choosing 2 as to denote that this cell is now contained\\n            // and will not cause any more infection.\\n            grid[row][col] = 2;\\n        }\\n\\n        // For remaining regions, expand (neighbors are now infected).\\n        for (Region region : regions) {\\n            for (int neighbor : region.uninfectedNeighbors) {\\n                int row = neighbor / cols;\\n                int col = neighbor % cols;\\n                grid[row][col] = 1;\\n            }\\n        }\\n    }\\n\\n    return result;\\n}\\n\\nprivate void dfs(int[][] grid, int row, int col, boolean[][] visited, Region region) {\\n    int rows = grid.length;\\n    int cols = grid[0].length;\\n\\n    if (row < 0 || row >= rows || col < 0 || col >= cols || grid[row][col] == 2) {\\n        return;\\n    }\\n\\n    if (grid[row][col] == 1) {\\n        // 1 is already infected.\\n        // Add to the list, since we are using Set it will be deduped if added multiple times.\\n        region.infected.add(row * cols + col);\\n\\n        // If already visited, return as we do not want to go into infinite recursion.\\n        if (visited[row][col]) {\\n            return;\\n        }\\n    }\\n\\n    visited[row][col] = true;\\n\\n    if (grid[row][col] == 0) {\\n        // If 0 it is uninfected neighbor, we need a wall.\\n        // Remeber we can reach this 0 multiple times from different infected neighbors i.e. 1s,\\n        // and this will account for numbers of walls need to be built around this 0.\\n        region.wallsRequired++;\\n\\n        // Add to uninfected list, it will be de-duped as we use Set.\\n        region.uninfectedNeighbors.add(row * cols + col);\\n        return;\\n    }\\n\\n    // Visit neighbors.\\n    dfs(grid, row + 1, col, visited, region);\\n    dfs(grid, row - 1, col, visited, region);\\n    dfs(grid, row, col + 1, visited, region);\\n    dfs(grid, row, col - 1, visited, region);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 110186,
                "title": "c-dfs-12ms",
                "content": "The solution simply models the process. \\n1) Build walls = set those connected virus inactive, i.e. set as -1;\\n2) Affected area != walls; For example, one 0 surrounded by all 1s have area = 1, but walls = 4.\\n\\nDFS\\n```\\nclass Solution {\\npublic:\\n    int containVirus(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        while (true) {\\n            int walls = process(grid);\\n            if (walls == 0) break; // No more walls to build\\n            ans += walls;\\n        }\\n        return ans;\\n    }\\nprivate:\\n    int process(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        // cnt is max area to be affected by a single virus region; ans is corresponding walls\\n        int cnt = 0, ans = 0, color = -1, row = -1, col = -1;\\n        // visited virus as 1, visited 0 using different color to indicate being affected by different virus\\n        vector<vector<int>> visited(m, vector<int>(n, 0)); \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1 && visited[i][j] == 0) {\\n                    int walls = 0, area = dfs(grid, visited, i, j, color, walls);\\n                    if (area > cnt) {\\n                        ans = walls;\\n                        cnt = area;\\n                        row = i; \\n                        col = j;\\n                    }\\n                    color--;\\n                }\\n            }\\n        }\\n        // set this virus region inactive\\n        buildWall(grid, row, col);\\n        // propagate other virus by 1 step\\n        visited = vector<vector<int>>(m, vector<int>(n, 0));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1 && visited[i][j] == 0) \\n                    spread(grid, visited, i, j);\\n            }\\n        }\\n        return ans;\\n    }\\n    int dfs(vector<vector<int>>& grid, vector<vector<int>>& visited, int row, int col, int color, int& walls) {\\n        int m = grid.size(), n = grid[0].size(), ans = 0;\\n        if (row < 0 || row >= m || col < 0 || col >= n) return 0;\\n        if (grid[row][col] == 0) {\\n            walls++; \\n            if (visited[row][col] == color) return 0;\\n            visited[row][col] = color;\\n            return 1;\\n        }\\n        // grid[row][col] could be -1, inactive virus\\n        if (visited[row][col] == 1 || grid[row][col] != 1) return 0; \\n        visited[row][col] = 1;\\n        vector<int> dir = {-1, 0, 1, 0, -1};\\n        for (int i = 0; i < 4; i++) \\n            ans += dfs(grid, visited, row+dir[i], col+dir[i+1], color, walls);\\n        return ans;\\n    }\\n    void buildWall(vector<vector<int>>& grid, int row, int col) {\\n        int m = grid.size(), n = grid[0].size();\\n        if (row < 0 || row >= m || col < 0 || col >= n || grid[row][col] != 1) return;\\n        grid[row][col] = -1; //set inactive\\n        vector<int> dir = {-1, 0, 1, 0, -1};\\n        for (int i = 0; i < 4; i++) \\n            buildWall(grid, row+dir[i], col+dir[i+1]);\\n    }\\n    void spread(vector<vector<int>>& grid, vector<vector<int>>& visited, int row, int col) {\\n        int m = grid.size(), n = grid[0].size();\\n        if (row < 0 || row >= m || col < 0 || col >= n || visited[row][col] == 1) return;\\n        if (grid[row][col] == 0) {\\n            grid[row][col] = 1;\\n            visited[row][col] = 1;\\n        }\\n        else if (grid[row][col] == 1) {\\n           visited[row][col] = 1;\\n           vector<int> dir = {-1, 0, 1, 0, -1};\\n           for (int i = 0; i < 4; i++) \\n               spread(grid, visited, row+dir[i], col+dir[i+1]);\\n        }\\n    }\\n};\\n```\\n\\nDFS, single pass with intermediate results saved, 19 ms\\n```\\nclass Solution {\\npublic:\\n    int containVirus(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        while (true) {\\n            int walls = model(grid);\\n            if (walls == 0) break;\\n            ans += walls;\\n        }\\n        return ans;\\n    }\\nprivate:\\n    int model(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), N = 100;\\n        vector<unordered_set<int>> virus, toInfect;\\n        vector<vector<int>> visited(m, vector<int>(n, 0));\\n        vector<int> walls;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1 && visited[i][j] == 0) {\\n                    virus.push_back(unordered_set<int>());\\n                    toInfect.push_back(unordered_set<int>());\\n                    walls.push_back(0);\\n                    dfs(grid, visited, virus.back(), toInfect.back(), walls.back(), i, j);\\n                }\\n            }\\n        }\\n        int maxArea = 0, idx = -1;\\n        for (int i = 0; i < toInfect.size(); i++) {\\n            if (toInfect[i].size() > maxArea) {\\n                maxArea = toInfect[i].size();\\n                idx = i;\\n            }\\n        }\\n        if (idx == -1) return 0;\\n        for (int i = 0; i < toInfect.size(); i++) {\\n            if (i != idx) {\\n                for (int key : toInfect[i]) \\n                    grid[key/N][key%N] = 1;\\n            }\\n            else {\\n                for (int key: virus[i]) \\n                    grid[key/N][key%N] = -1;\\n            }\\n        }\\n        return walls[idx];\\n    }\\nprivate:\\n    void dfs(vector<vector<int>>& grid, vector<vector<int>>& visited, unordered_set<int>& virus, unordered_set<int>& toInfect, int& wall, int row, int col) {\\n        int m = grid.size(), n = grid[0].size(), N = 100;\\n        if (row < 0 || row >= m || col < 0 || col >= n || visited[row][col] == 1) return;\\n        if (grid[row][col] == 1) {\\n            visited[row][col] = 1;\\n            virus.insert(row*N + col);\\n            vector<int> dir = {0, -1, 0, 1, 0};\\n            for (int i = 0; i < 4; i++)\\n                dfs(grid, visited, virus, toInfect, wall, row+dir[i], col+dir[i+1]);\\n        }\\n        else if (grid[row][col] == 0) {\\n            wall++;\\n            toInfect.insert(row*N + col);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int containVirus(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        while (true) {\\n            int walls = process(grid);\\n            if (walls == 0) break; // No more walls to build\\n            ans += walls;\\n        }\\n        return ans;\\n    }\\nprivate:\\n    int process(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        // cnt is max area to be affected by a single virus region; ans is corresponding walls\\n        int cnt = 0, ans = 0, color = -1, row = -1, col = -1;\\n        // visited virus as 1, visited 0 using different color to indicate being affected by different virus\\n        vector<vector<int>> visited(m, vector<int>(n, 0)); \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1 && visited[i][j] == 0) {\\n                    int walls = 0, area = dfs(grid, visited, i, j, color, walls);\\n                    if (area > cnt) {\\n                        ans = walls;\\n                        cnt = area;\\n                        row = i; \\n                        col = j;\\n                    }\\n                    color--;\\n                }\\n            }\\n        }\\n        // set this virus region inactive\\n        buildWall(grid, row, col);\\n        // propagate other virus by 1 step\\n        visited = vector<vector<int>>(m, vector<int>(n, 0));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1 && visited[i][j] == 0) \\n                    spread(grid, visited, i, j);\\n            }\\n        }\\n        return ans;\\n    }\\n    int dfs(vector<vector<int>>& grid, vector<vector<int>>& visited, int row, int col, int color, int& walls) {\\n        int m = grid.size(), n = grid[0].size(), ans = 0;\\n        if (row < 0 || row >= m || col < 0 || col >= n) return 0;\\n        if (grid[row][col] == 0) {\\n            walls++; \\n            if (visited[row][col] == color) return 0;\\n            visited[row][col] = color;\\n            return 1;\\n        }\\n        // grid[row][col] could be -1, inactive virus\\n        if (visited[row][col] == 1 || grid[row][col] != 1) return 0; \\n        visited[row][col] = 1;\\n        vector<int> dir = {-1, 0, 1, 0, -1};\\n        for (int i = 0; i < 4; i++) \\n            ans += dfs(grid, visited, row+dir[i], col+dir[i+1], color, walls);\\n        return ans;\\n    }\\n    void buildWall(vector<vector<int>>& grid, int row, int col) {\\n        int m = grid.size(), n = grid[0].size();\\n        if (row < 0 || row >= m || col < 0 || col >= n || grid[row][col] != 1) return;\\n        grid[row][col] = -1; //set inactive\\n        vector<int> dir = {-1, 0, 1, 0, -1};\\n        for (int i = 0; i < 4; i++) \\n            buildWall(grid, row+dir[i], col+dir[i+1]);\\n    }\\n    void spread(vector<vector<int>>& grid, vector<vector<int>>& visited, int row, int col) {\\n        int m = grid.size(), n = grid[0].size();\\n        if (row < 0 || row >= m || col < 0 || col >= n || visited[row][col] == 1) return;\\n        if (grid[row][col] == 0) {\\n            grid[row][col] = 1;\\n            visited[row][col] = 1;\\n        }\\n        else if (grid[row][col] == 1) {\\n           visited[row][col] = 1;\\n           vector<int> dir = {-1, 0, 1, 0, -1};\\n           for (int i = 0; i < 4; i++) \\n               spread(grid, visited, row+dir[i], col+dir[i+1]);\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int containVirus(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        while (true) {\\n            int walls = model(grid);\\n            if (walls == 0) break;\\n            ans += walls;\\n        }\\n        return ans;\\n    }\\nprivate:\\n    int model(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), N = 100;\\n        vector<unordered_set<int>> virus, toInfect;\\n        vector<vector<int>> visited(m, vector<int>(n, 0));\\n        vector<int> walls;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1 && visited[i][j] == 0) {\\n                    virus.push_back(unordered_set<int>());\\n                    toInfect.push_back(unordered_set<int>());\\n                    walls.push_back(0);\\n                    dfs(grid, visited, virus.back(), toInfect.back(), walls.back(), i, j);\\n                }\\n            }\\n        }\\n        int maxArea = 0, idx = -1;\\n        for (int i = 0; i < toInfect.size(); i++) {\\n            if (toInfect[i].size() > maxArea) {\\n                maxArea = toInfect[i].size();\\n                idx = i;\\n            }\\n        }\\n        if (idx == -1) return 0;\\n        for (int i = 0; i < toInfect.size(); i++) {\\n            if (i != idx) {\\n                for (int key : toInfect[i]) \\n                    grid[key/N][key%N] = 1;\\n            }\\n            else {\\n                for (int key: virus[i]) \\n                    grid[key/N][key%N] = -1;\\n            }\\n        }\\n        return walls[idx];\\n    }\\nprivate:\\n    void dfs(vector<vector<int>>& grid, vector<vector<int>>& visited, unordered_set<int>& virus, unordered_set<int>& toInfect, int& wall, int row, int col) {\\n        int m = grid.size(), n = grid[0].size(), N = 100;\\n        if (row < 0 || row >= m || col < 0 || col >= n || visited[row][col] == 1) return;\\n        if (grid[row][col] == 1) {\\n            visited[row][col] = 1;\\n            virus.insert(row*N + col);\\n            vector<int> dir = {0, -1, 0, 1, 0};\\n            for (int i = 0; i < 4; i++)\\n                dfs(grid, visited, virus, toInfect, wall, row+dir[i], col+dir[i+1]);\\n        }\\n        else if (grid[row][col] == 0) {\\n            wall++;\\n            toInfect.insert(row*N + col);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 488594,
                "title": "contain-the-virus-contain-the-new-coronavirus-fighting",
                "content": "\\n```\\ndef containVirus(self, grid: List[List[int]]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        dirs=[(0,1),(1,0),(0,-1),(-1,0)]\\n        \\n        def dfs(x,y,sn):\\n            if grid[x][y]==1:\\n                v[sn].add((x,y))\\n                seen.add((x,y))\\n                for dx,dy in dirs:\\n                    nx=x+dx\\n                    ny=y+dy\\n                    if 0<=nx<m and 0<=ny<n:                             \\n                        if grid[nx][ny]==0:\\n                            f[sn].add((nx,ny))\\n                            w[sn]+=1\\n                        if grid[nx][ny]==1 and (nx,ny) not in v[sn]:\\n                            v[sn].add((nx,ny))\\n                            dfs(nx,ny,sn)\\n                                   \\n        res=0\\n        while True:\\n            v=collections.defaultdict(set)  # infected area\\n            f=collections.defaultdict(set)  # potential risk area\\n            w=collections.defaultdict(int)  # walls in need\\n            seen=set()\\n                        \\n            for i in range(m):\\n                for j in range(n):\\n                    if grid[i][j]==1 and (i,j) not in seen:\\n                        dfs(i,j,(i,j))\\n             \\n            if len(f)==0:   \\n                break\\n\\n            nnfrontiers = sorted(f,key=lambda x:len(f[x]),reverse=True)\\n            if len(nnfrontiers)>0:\\n                nnfrontier = nnfrontiers[0]                \\n                res+=w[nnfrontier]\\n\\n                for x,y in v[nnfrontier]:   # get isolated\\n                    grid[x][y]=2\\n                \\n                if len(nnfrontiers)>1:      # spread the frontiers\\n                    for i in range(1,len(nnfrontiers)):\\n                        nnfrontier2 = nnfrontiers[i]\\n                        for x,y in f[nnfrontier2]:\\n                            grid[x][y]=1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef containVirus(self, grid: List[List[int]]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        dirs=[(0,1),(1,0),(0,-1),(-1,0)]\\n        \\n        def dfs(x,y,sn):\\n            if grid[x][y]==1:\\n                v[sn].add((x,y))\\n                seen.add((x,y))\\n                for dx,dy in dirs:\\n                    nx=x+dx\\n                    ny=y+dy\\n                    if 0<=nx<m and 0<=ny<n:                             \\n                        if grid[nx][ny]==0:\\n                            f[sn].add((nx,ny))\\n                            w[sn]+=1\\n                        if grid[nx][ny]==1 and (nx,ny) not in v[sn]:\\n                            v[sn].add((nx,ny))\\n                            dfs(nx,ny,sn)\\n                                   \\n        res=0\\n        while True:\\n            v=collections.defaultdict(set)  # infected area\\n            f=collections.defaultdict(set)  # potential risk area\\n            w=collections.defaultdict(int)  # walls in need\\n            seen=set()\\n                        \\n            for i in range(m):\\n                for j in range(n):\\n                    if grid[i][j]==1 and (i,j) not in seen:\\n                        dfs(i,j,(i,j))\\n             \\n            if len(f)==0:   \\n                break\\n\\n            nnfrontiers = sorted(f,key=lambda x:len(f[x]),reverse=True)\\n            if len(nnfrontiers)>0:\\n                nnfrontier = nnfrontiers[0]                \\n                res+=w[nnfrontier]\\n\\n                for x,y in v[nnfrontier]:   # get isolated\\n                    grid[x][y]=2\\n                \\n                if len(nnfrontiers)>1:      # spread the frontiers\\n                    for i in range(1,len(nnfrontiers)):\\n                        nnfrontier2 = nnfrontiers[i]\\n                        for x,y in f[nnfrontier2]:\\n                            grid[x][y]=1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2224726,
                "title": "pyhon-easy-solution-dfs-time-o-m-n-max-m-n-faster",
                "content": "```\\n class Solution:\\n    def containVirus(self, mat: List[List[int]]) -> int:\\n        m,n = len(mat),len(mat[0])\\n\\n        def dfs(i,j,visited,nextInfected):  # return no. of walls require to quarantined dfs area\\n            if 0<=i<m and 0<=j<n and (i,j) not in visited:\\n                if mat[i][j]==2: # Already quarantined cell\\n                    return 0\\n                if mat[i][j]==0:\\n                    nextInfected.add((i,j)) # add cell which will be infected next day\\n                    return 1   # require one wall to quarantined cell from one side\\n                    \\n                else:\\n                    visited.add((i,j))\\n                    return dfs(i-1,j,visited,nextInfected) + dfs(i+1,j,visited,nextInfected) + dfs(i,j-1,visited,nextInfected) + dfs(i,j+1,visited,nextInfected)  # traverse all four direction\\n            else:\\n                return 0\\n\\t\\t\\t\\t\\n        ans = 0 \\n        while True:   # this loop running \"how many days we should installing the walls\" times\\n            # For every day check which area infect more cells\\n            visited = set()  # Using in dfs\\n            All_nextinfect  = set()\\n            stop , walls = set(),0   # here stop store the indices of maximum no. of cells in which we stop spreading of virus this day\\n            \\n            for i in range(m):\\n                for j in range(n):\\n                    if mat[i][j]==1 and (i,j) not in visited:\\n                        nextInfected = set()\\n                        a = dfs(i,j,visited,nextInfected)\\n                        \\n                        if len(stop)<len(nextInfected):\\n                            All_nextinfect  = All_nextinfect | stop # leave previous saved area from virus\\n                            stop = nextInfected  # pick new area which we want to save\\n                            walls = a  # require walls\\n                            p,q = i,j  # starting position(indices) of this area\\n                        else:\\n                            All_nextinfect  = All_nextinfect | nextInfected   \\n                            \\n            if not stop : # if our job is done i.e. No cell will be infect Later\\n                break\\n            ans += walls  # add new walls installed this day\\n            \\n            # change each cell value to 2 which will be covered by quarantined area\\n            def fun(p,q):\\n                if 0<=p<m and 0<=q<n and mat[p][q]==1:\\n                    mat[p][q]=2\\n                    fun(p+1,q)\\n                    fun(p-1,q)\\n                    fun(p,q-1)\\n                    fun(p,q+1)\\n            fun(p,q) # start dfs from start point of quarantined area\\n            \\n            for a,b in All_nextinfect: # set new infected cell value = 1 for iterating next day\\n                mat[a][b] = 1\\n\\n        return ans   # Final answer \\n```\\t\\t\\n\\t\\t\\n\\t\\t\\n**if you like the solution : please  Upvote    :)**\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n class Solution:\\n    def containVirus(self, mat: List[List[int]]) -> int:\\n        m,n = len(mat),len(mat[0])\\n\\n        def dfs(i,j,visited,nextInfected):  # return no. of walls require to quarantined dfs area\\n            if 0<=i<m and 0<=j<n and (i,j) not in visited:\\n                if mat[i][j]==2: # Already quarantined cell\\n                    return 0\\n                if mat[i][j]==0:\\n                    nextInfected.add((i,j)) # add cell which will be infected next day\\n                    return 1   # require one wall to quarantined cell from one side\\n                    \\n                else:\\n                    visited.add((i,j))\\n                    return dfs(i-1,j,visited,nextInfected) + dfs(i+1,j,visited,nextInfected) + dfs(i,j-1,visited,nextInfected) + dfs(i,j+1,visited,nextInfected)  # traverse all four direction\\n            else:\\n                return 0\\n\\t\\t\\t\\t\\n        ans = 0 \\n        while True:   # this loop running \"how many days we should installing the walls\" times\\n            # For every day check which area infect more cells\\n            visited = set()  # Using in dfs\\n            All_nextinfect  = set()\\n            stop , walls = set(),0   # here stop store the indices of maximum no. of cells in which we stop spreading of virus this day\\n            \\n            for i in range(m):\\n                for j in range(n):\\n                    if mat[i][j]==1 and (i,j) not in visited:\\n                        nextInfected = set()\\n                        a = dfs(i,j,visited,nextInfected)\\n                        \\n                        if len(stop)<len(nextInfected):\\n                            All_nextinfect  = All_nextinfect | stop # leave previous saved area from virus\\n                            stop = nextInfected  # pick new area which we want to save\\n                            walls = a  # require walls\\n                            p,q = i,j  # starting position(indices) of this area\\n                        else:\\n                            All_nextinfect  = All_nextinfect | nextInfected   \\n                            \\n            if not stop : # if our job is done i.e. No cell will be infect Later\\n                break\\n            ans += walls  # add new walls installed this day\\n            \\n            # change each cell value to 2 which will be covered by quarantined area\\n            def fun(p,q):\\n                if 0<=p<m and 0<=q<n and mat[p][q]==1:\\n                    mat[p][q]=2\\n                    fun(p+1,q)\\n                    fun(p-1,q)\\n                    fun(p,q-1)\\n                    fun(p,q+1)\\n            fun(p,q) # start dfs from start point of quarantined area\\n            \\n            for a,b in All_nextinfect: # set new infected cell value = 1 for iterating next day\\n                mat[a][b] = 1\\n\\n        return ans   # Final answer \\n```",
                "codeTag": "Java"
            },
            {
                "id": 752571,
                "title": "c-dfs-simulation-20-ms",
                "content": "1. After each dfs, the matrix can contain only three types of numbers:\\na) 1: infected cell\\nb) 0: healthy cell\\nc) 1e9: blocked cell\\n\\n2. If no cell becomes infected the following night, the simulation breaks and returns answer\\n\\n3. The unordered set is used to find the total number of cells infected by a connected component the following night\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int> > g;\\n    int n, m, c, mx, w, r, ans, itr;\\n    unordered_set<int> s;\\n    \\n    int dfs(int i, int j){\\n        if(i<0 || i>=n || j<0 || j>=m || g[i][j]!=1)\\n            return 0;\\n        int ans=0;\\n        if(i+1<n && g[i+1][j]==0){\\n            s.insert((i+1)*m+j);\\n            ans++;\\n        }\\n        if(i-1>=0 && g[i-1][j]==0){\\n            s.insert((i-1)*m+j);\\n            ans++;\\n        }\\n        if(j+1<m && g[i][j+1]==0){\\n            s.insert(i*m+(j+1));\\n            ans++;\\n        }\\n        if(j-1>=0 && g[i][j-1]==0){\\n            s.insert(i*m+(j-1));\\n            ans++;\\n        }\\n        g[i][j]=c;\\n        ans+=dfs(i+1, j);\\n        ans+=dfs(i-1, j);\\n        ans+=dfs(i, j+1);\\n        ans+=dfs(i, j-1);\\n        return ans; // total number of walls needed to block this connected component\\n    }\\n    \\n    int containVirus(vector<vector<int>>& grid) {\\n        g=grid, n=g.size(), m=g[0].size(), ans=0;\\n        while(true){\\n            c=2, mx=0;\\n            for(int i=0; i<n; i++){\\n                for(int j=0; j<m; j++){\\n                    if(g[i][j]==1){\\n                        s.clear();\\n                        int walls=dfs(i, j);\\n                        if(mx<s.size()){\\n                            mx=s.size();\\n                            w=walls;\\n                            r=c;\\n                        }\\n                        c++;\\n                    }\\n                }\\n            }\\n            if(mx==0)\\n                break;\\n            ans+=w;\\n            for(int i=0; i<n; i++){\\n                for(int j=0; j<m; j++){\\n                    if(g[i][j]==r)\\n                        g[i][j]=1e9;\\n                    else if(g[i][j]>1 && g[i][j]!=1e9){\\n                        g[i][j]=1;\\n                        if(i+1<n && !g[i+1][j]) g[i+1][j]=1;\\n                        if(i-1>=0 && !g[i-1][j]) g[i-1][j]=1;\\n                        if(j+1<m && !g[i][j+1]) g[i][j+1]=1;\\n                        if(j-1>=0 && !g[i][j-1]) g[i][j-1]=1;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int> > g;\\n    int n, m, c, mx, w, r, ans, itr;\\n    unordered_set<int> s;\\n    \\n    int dfs(int i, int j){\\n        if(i<0 || i>=n || j<0 || j>=m || g[i][j]!=1)\\n            return 0;\\n        int ans=0;\\n        if(i+1<n && g[i+1][j]==0){\\n            s.insert((i+1)*m+j);\\n            ans++;\\n        }\\n        if(i-1>=0 && g[i-1][j]==0){\\n            s.insert((i-1)*m+j);\\n            ans++;\\n        }\\n        if(j+1<m && g[i][j+1]==0){\\n            s.insert(i*m+(j+1));\\n            ans++;\\n        }\\n        if(j-1>=0 && g[i][j-1]==0){\\n            s.insert(i*m+(j-1));\\n            ans++;\\n        }\\n        g[i][j]=c;\\n        ans+=dfs(i+1, j);\\n        ans+=dfs(i-1, j);\\n        ans+=dfs(i, j+1);\\n        ans+=dfs(i, j-1);\\n        return ans; // total number of walls needed to block this connected component\\n    }\\n    \\n    int containVirus(vector<vector<int>>& grid) {\\n        g=grid, n=g.size(), m=g[0].size(), ans=0;\\n        while(true){\\n            c=2, mx=0;\\n            for(int i=0; i<n; i++){\\n                for(int j=0; j<m; j++){\\n                    if(g[i][j]==1){\\n                        s.clear();\\n                        int walls=dfs(i, j);\\n                        if(mx<s.size()){\\n                            mx=s.size();\\n                            w=walls;\\n                            r=c;\\n                        }\\n                        c++;\\n                    }\\n                }\\n            }\\n            if(mx==0)\\n                break;\\n            ans+=w;\\n            for(int i=0; i<n; i++){\\n                for(int j=0; j<m; j++){\\n                    if(g[i][j]==r)\\n                        g[i][j]=1e9;\\n                    else if(g[i][j]>1 && g[i][j]!=1e9){\\n                        g[i][j]=1;\\n                        if(i+1<n && !g[i+1][j]) g[i+1][j]=1;\\n                        if(i-1>=0 && !g[i-1][j]) g[i-1][j]=1;\\n                        if(j+1<m && !g[i][j+1]) g[i][j+1]=1;\\n                        if(j-1>=0 && !g[i][j-1]) g[i][j-1]=1;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 230891,
                "title": "commented-python-using-dfs-with-explanation",
                "content": "1. Find most threatening region (would infect most normal cells next night) via DFS and at same time count the walls needed to wall off, and return it\\'s coordinates\\n2. Quarantine that region by doing DFS and walling that region off by setting 1\\'s to -1\\'s\\n3. Simulate night virus spread: find a \\'1\\' do a DFS on it and set perimeter empty spaces to 2. Once done this for all cells, set 2\\'s to 1. This is so that while iterating it doesn\\'t see newly infected cells as cells next to the empty perimeter (then it would spread all in one night)\\n\\nRT: O(M*N * infected_regions)\\nSpc: O(M*N) (could be a deep DFS)\\n\\n```\\n    def containVirus(self, grid):\\n        dirs = [(0, 1), (1, 0), (-1, 0), (0, -1)]\\n\\n        def cells():\\n            for r in range(R):\\n                for c in range(C):\\n                    yield (r, c)\\n\\n        def is_valid(i, j):\\n            return 0 <= i < R and 0 <= j < C\\n\\n        def neighbours(r, c):\\n            \"\"\"Get valid neighbour cells\"\"\"\\n            for dr, dc in dirs:\\n                if is_valid(r+dr, c+dc):\\n                    yield (r+dr, c+dc)\\n\\n        def pick_most_threatening_region():\\n            visited = set()\\n\\n            def dfs(r, c):\\n                \"\"\"Returns number of walls needed to quarantine infected region\\n                starting at (r,c)\"\"\"\\n                # Avoid already visited or quarantined cells.\\n                if (r, c) in visited or grid[r][c] == -1:\\n                    return 0\\n                # Found an empty perimeter space\\n                if grid[r][c] == 0:\\n                    perimeter.add((r, c))\\n                    # Counts as one wall needed to contain infected cell.\\n                    return 1\\n                \\n                visited.add((r, c))\\n                # Explore neighbours and return the sum of the walls needed to\\n                # contain their perimeter.\\n                return sum(dfs(nr, nc) for (nr, nc) in neighbours(r, c))\\n\\n            max_perimeter, max_p_walls, max_start = 0, 0, (0, 0)\\n            for r, c in cells():\\n                # Find cells that have not yet been visited and are infected.\\n                if (r, c) not in visited and grid[r][c] == 1:\\n                    perimeter = set()\\n                    # Get the total walls needed to quarantine the infected region.\\n                    walls = dfs(r, c)\\n                    # If the parameter we could save is the biggest we\\'ve seen...\\n                    if len(perimeter) > max_perimeter:\\n                         # update the walls needed to quarantine, and an infected cell\\n                         # from which we might mark the infected region as quarantined (setting -1)\\n                        max_perimeter, max_p_walls, max_start = len(perimeter), walls, (r, c)\\n            return max_p_walls, max_start\\n\\n        def quarantine(r, c):\\n            \"\"\"Mark an infected region as quarantined by setting cells to -1\"\"\"\\n            grid[r][c] = -1\\n            # Explore neighbours to quarantine them too.\\n            for nr, nc in neighbours(r, c):\\n                if grid[nr][nc] == 1:\\n                    quarantine(nr, nc)\\n                \\n        def simulate_night():\\n            \"\"\"Spreads the infection by one night of non-quarntined regions.\"\"\"\\n            \\n            def infected_neighbour(r, c):\\n                \"\"\"Returns True if an orthogonally adjacent square is infected.\"\"\"\\n                return any(grid[nr][nc] == 1 for nr, nc in neighbours(r, c))\\n \\n            for r, c in cells():\\n                # Find clean cells that are next to infected cells\\n                if grid[r][c] == 0 and infected_neighbour(r, c):\\n                    # Set them temporarily to 2, so that further iterations do not\\n                    # count them as infected (otherwise it would spread endlessly\\n                    # in one night).\\n                    grid[r][c] = 2\\n            \\n            # Go over a second time and set the temporarily marked newly infected cells\\n            # to permanently infected.\\n            for r, c in cells():\\n                if grid[r][c] == 2:\\n                    grid[r][c] = 1\\n\\n        if not grid or not grid[0]:\\n            return 0\\n        R, C = len(grid), len(grid[0])\\n\\n        walls = 0\\n        while True:\\n            new_walls, (r, c) = pick_most_threatening_region()\\n            # Stop when there are no more infected regions, i.e. only\\n            # -1 (quarantined by us) and 0\\'s are left.\\n            if new_walls == 0:\\n                return walls\\n            quarantine(r, c)\\n            walls += new_walls\\n            simulate_night()\\n        return walls\\n```",
                "solutionTags": [],
                "code": "```\\n    def containVirus(self, grid):\\n        dirs = [(0, 1), (1, 0), (-1, 0), (0, -1)]\\n\\n        def cells():\\n            for r in range(R):\\n                for c in range(C):\\n                    yield (r, c)\\n\\n        def is_valid(i, j):\\n            return 0 <= i < R and 0 <= j < C\\n\\n        def neighbours(r, c):\\n            \"\"\"Get valid neighbour cells\"\"\"\\n            for dr, dc in dirs:\\n                if is_valid(r+dr, c+dc):\\n                    yield (r+dr, c+dc)\\n\\n        def pick_most_threatening_region():\\n            visited = set()\\n\\n            def dfs(r, c):\\n                \"\"\"Returns number of walls needed to quarantine infected region\\n                starting at (r,c)\"\"\"\\n                # Avoid already visited or quarantined cells.\\n                if (r, c) in visited or grid[r][c] == -1:\\n                    return 0\\n                # Found an empty perimeter space\\n                if grid[r][c] == 0:\\n                    perimeter.add((r, c))\\n                    # Counts as one wall needed to contain infected cell.\\n                    return 1\\n                \\n                visited.add((r, c))\\n                # Explore neighbours and return the sum of the walls needed to\\n                # contain their perimeter.\\n                return sum(dfs(nr, nc) for (nr, nc) in neighbours(r, c))\\n\\n            max_perimeter, max_p_walls, max_start = 0, 0, (0, 0)\\n            for r, c in cells():\\n                # Find cells that have not yet been visited and are infected.\\n                if (r, c) not in visited and grid[r][c] == 1:\\n                    perimeter = set()\\n                    # Get the total walls needed to quarantine the infected region.\\n                    walls = dfs(r, c)\\n                    # If the parameter we could save is the biggest we\\'ve seen...\\n                    if len(perimeter) > max_perimeter:\\n                         # update the walls needed to quarantine, and an infected cell\\n                         # from which we might mark the infected region as quarantined (setting -1)\\n                        max_perimeter, max_p_walls, max_start = len(perimeter), walls, (r, c)\\n            return max_p_walls, max_start\\n\\n        def quarantine(r, c):\\n            \"\"\"Mark an infected region as quarantined by setting cells to -1\"\"\"\\n            grid[r][c] = -1\\n            # Explore neighbours to quarantine them too.\\n            for nr, nc in neighbours(r, c):\\n                if grid[nr][nc] == 1:\\n                    quarantine(nr, nc)\\n                \\n        def simulate_night():\\n            \"\"\"Spreads the infection by one night of non-quarntined regions.\"\"\"\\n            \\n            def infected_neighbour(r, c):\\n                \"\"\"Returns True if an orthogonally adjacent square is infected.\"\"\"\\n                return any(grid[nr][nc] == 1 for nr, nc in neighbours(r, c))\\n \\n            for r, c in cells():\\n                # Find clean cells that are next to infected cells\\n                if grid[r][c] == 0 and infected_neighbour(r, c):\\n                    # Set them temporarily to 2, so that further iterations do not\\n                    # count them as infected (otherwise it would spread endlessly\\n                    # in one night).\\n                    grid[r][c] = 2\\n            \\n            # Go over a second time and set the temporarily marked newly infected cells\\n            # to permanently infected.\\n            for r, c in cells():\\n                if grid[r][c] == 2:\\n                    grid[r][c] = 1\\n\\n        if not grid or not grid[0]:\\n            return 0\\n        R, C = len(grid), len(grid[0])\\n\\n        walls = 0\\n        while True:\\n            new_walls, (r, c) = pick_most_threatening_region()\\n            # Stop when there are no more infected regions, i.e. only\\n            # -1 (quarantined by us) and 0\\'s are left.\\n            if new_walls == 0:\\n                return walls\\n            quarantine(r, c)\\n            walls += new_walls\\n            simulate_night()\\n        return walls\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 112926,
                "title": "contian-virus-do-i-misunstand-something",
                "content": "For input \\n[[0,1,0,1,1,1,1,1,1,0],\\n[0,0,0,1,0,0,0,0,0,0],\\n[0,0,1,1,1,0,0,0,1,0],\\n[0,0,0,1,1,0,0,1,1,0],\\n[0,1,0,0,1,0,1,1,0,1],\\n[0,0,0,1,0,1,0,1,1,1],\\n[0,1,0,0,1,0,0,1,1,0],\\n[0,1,0,1,0,0,0,1,1,0],\\n[0,1,1,0,0,1,1,0,0,1],\\n[1,0,1,1,0,1,0,1,0,1]]\\nMy solution gives answer=40 but the answer=38. \\nI calculated manually, first all we should contain the infected area in the right(I change it to 2), and we need 22 walls;\\n\\t\\t{ 0, 1, 0, 1, 1, 1, 1, 1, 1, 0 },\\n\\t\\t{ 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },\\n\\t\\t{ 0, 0, 1, 1, 1, 0, 0, 0, 2, 0 }, // 3 walls\\n\\t\\t{ 0, 0, 0, 1, 1, 0, 0, 2, 2, 0 }, // 2 walls, 2 walls\\n\\t\\t{ 0, 1, 0, 0, 1, 0, 2, 2, 0, 2 }, // 3 walls, 1 walls, 2 walls\\n\\t\\t{ 0, 0, 0, 1, 0, 1, 0, 2, 2, 2 }, // 1 walls, 1 walls, 1 walls\\n\\t\\t{ 0, 1, 0, 0, 1, 0, 0, 2, 2, 0 }, // 1 walls, 1 walls\\n\\t\\t{ 0, 1, 0, 1, 0, 0, 0, 2, 2, 0 }, // 2 walls, 2 walls\\n\\t\\t{ 0, 1, 1, 0, 0, 1, 1, 0, 0, 1 },\\n\\t\\t{ 1, 0, 1, 1, 0, 1, 0, 1, 0, 1 };\\nafter one day, it will be like this (* is newly affected cells)\\n\\t\\t{ *, 1, *, 1, 1, 1, 1, 1, 1, * },\\n\\t\\t{ 0, *, *, 1, *,  *,  *, *,  *, 0 },  \\n\\t\\t{ 0, *, 1, 1, 1, *, 0, 0, 2, 0 },  \\n\\t\\t{ 0, *, *, 1, 1, *, 0, 2, 2, 0 },\\n\\t\\t{ *, 1, *, *, 1, *, 2, 2, 0, 2 },\\n\\t\\t{ 0, *, *, 1, *, 1, *, 2, 2, 2 },\\n\\t\\t{ *, 1, *, *, 1, *,  0, 2, 2, 0 },\\n\\t\\t{ *, 1, *, 1, *, *,  *,  2, 2, * },\\n\\t\\t{ *, 1, 1, *, *, 1, 1,  *,  *, 1 },\\n\\t\\t{ 1, *, 1, 1, *, 1, *, 1,  *, 1 };\\nand we need 18 walls to protect unaffected cells. Could any one tell me what is wrong with my answer? Do I misunderstand something?\\n\\nAny comments are welcome!",
                "solutionTags": [],
                "code": "For input \\n[[0,1,0,1,1,1,1,1,1,0],\\n[0,0,0,1,0,0,0,0,0,0],\\n[0,0,1,1,1,0,0,0,1,0],\\n[0,0,0,1,1,0,0,1,1,0],\\n[0,1,0,0,1,0,1,1,0,1],\\n[0,0,0,1,0,1,0,1,1,1],\\n[0,1,0,0,1,0,0,1,1,0],\\n[0,1,0,1,0,0,0,1,1,0],\\n[0,1,1,0,0,1,1,0,0,1],\\n[1,0,1,1,0,1,0,1,0,1]]\\nMy solution gives answer=40 but the answer=38. \\nI calculated manually, first all we should contain the infected area in the right(I change it to 2), and we need 22 walls;\\n\\t\\t{ 0, 1, 0, 1, 1, 1, 1, 1, 1, 0 },\\n\\t\\t{ 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },\\n\\t\\t{ 0, 0, 1, 1, 1, 0, 0, 0, 2, 0 }, // 3 walls\\n\\t\\t{ 0, 0, 0, 1, 1, 0, 0, 2, 2, 0 }, // 2 walls, 2 walls\\n\\t\\t{ 0, 1, 0, 0, 1, 0, 2, 2, 0, 2 }, // 3 walls, 1 walls, 2 walls\\n\\t\\t{ 0, 0, 0, 1, 0, 1, 0, 2, 2, 2 }, // 1 walls, 1 walls, 1 walls\\n\\t\\t{ 0, 1, 0, 0, 1, 0, 0, 2, 2, 0 }, // 1 walls, 1 walls\\n\\t\\t{ 0, 1, 0, 1, 0, 0, 0, 2, 2, 0 }, // 2 walls, 2 walls\\n\\t\\t{ 0, 1, 1, 0, 0, 1, 1, 0, 0, 1 },\\n\\t\\t{ 1, 0, 1, 1, 0, 1, 0, 1, 0, 1 };\\nafter one day, it will be like this (* is newly affected cells)\\n\\t\\t{ *, 1, *, 1, 1, 1, 1, 1, 1, * },\\n\\t\\t{ 0, *, *, 1, *,  *,  *, *,  *, 0 },  \\n\\t\\t{ 0, *, 1, 1, 1, *, 0, 0, 2, 0 },  \\n\\t\\t{ 0, *, *, 1, 1, *, 0, 2, 2, 0 },\\n\\t\\t{ *, 1, *, *, 1, *, 2, 2, 0, 2 },\\n\\t\\t{ 0, *, *, 1, *, 1, *, 2, 2, 2 },\\n\\t\\t{ *, 1, *, *, 1, *,  0, 2, 2, 0 },\\n\\t\\t{ *, 1, *, 1, *, *,  *,  2, 2, * },\\n\\t\\t{ *, 1, 1, *, *, 1, 1,  *,  *, 1 },\\n\\t\\t{ 1, *, 1, 1, *, 1, *, 1,  *, 1 };\\nand we need 18 walls to protect unaffected cells. Could any one tell me what is wrong with my answer? Do I misunderstand something?\\n\\nAny comments are welcome!",
                "codeTag": "Unknown"
            },
            {
                "id": 931134,
                "title": "a-visualization-tool",
                "content": "This is a tricky problem to debug, however visualizing the spread of the virus helps.\\nHere is a visualization tool that shows how the grid changes each day.\\n1 means the cell is infected and 2 means the cell has been contained with walls.\\nHere is an example output with a few notes added:\\n\\n```html5\\n<b>Grid status on day 0: Virus has not begun to spread.</b>\\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, <b>1</b>, 0, 0]\\n[<b>1</b>, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, <b>1</b>, 0, 0, 0, <b>1</b>, 0, 0, 0]   #\\n[0, 0, 0, 0, 0, 0, <b>1</b>, 0, 0, 0]   # Notice this group of 1s will be walled first and will not spread\\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, <b>1</b>, 0]\\n[0, 0, 0, 0, <b>1</b>, 0, <b>1</b>, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n```\\n```html5\\n<b>Grid status on day 1</b>\\n[0, 0, 0, 0, 0, 0, 0, <b>1</b>, 0, 0]\\n[<b>1</b>, 0, 0, 0, 0, 0, <b>1</b>, <b>1</b>, <b>1</b>, 0]\\n[<b>1</b>, <b>1</b>, <b>1</b>, 0, 0, 0, 0, <b>1</b>, 0, 0]\\n[<b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>, 0, 0, <b>2</b>, 0, 0, 0]   #\\n[0, 0, <b>1</b>, 0, 0, 0, <b>2</b>, 0, 0, 0]   # 2 Means the group of infected nodes has been contained\\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, <b>1</b>, 0]   #\\n[0, 0, 0, 0, <b>1</b>, 0, <b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>]   #\\n[0, 0, 0, <b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>, 0]   # Three groups of 1s have merged into one large group of 1s.\\n[0, 0, 0, 0, <b>1</b>, 0, <b>1</b>, 0, 0, 0]   #\\n```\\n```html5\\n<b>Grid status on day 2</b>\\n[<b>1</b>, 0, 0, 0, 0, 0, <b>1</b>, <b>1</b>, <b>1</b>, 0]   #\\n[<b>1</b>, <b>1</b>, <b>1</b>, 0, 0, <b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>]   # These two groups will not merge\\n[<b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>, 0, 0, <b>1</b>, <b>1</b>, <b>1</b>, 0]   # because one of them {(3,6), (4,6)} is walled off\\n[<b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>, 0, <b>2</b>, <b>1</b>, 0, 0]   #\\n[<b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>, 0, 0, <b>2</b>, 0, 0, 0]   #\\n[0, 0, <b>1</b>, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, <b>2</b>, 0]\\n[0, 0, 0, 0, <b>2</b>, 0, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>]\\n[0, 0, 0, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, 0]\\n[0, 0, 0, 0, <b>2</b>, 0, <b>2</b>, 0, 0, 0]\\n```\\n```html5\\n<b>Grid status on day 3</b>\\n[<b>2</b>, 0, 0, 0, 0, <b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>]\\n[<b>2</b>, <b>2</b>, <b>2</b>, 0, <b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>]\\n[<b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, 0, <b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>]\\n[<b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, 0, <b>2</b>, <b>1</b>, <b>1</b>, 0]\\n[<b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, 0, 0, <b>2</b>, <b>1</b>, 0, 0]\\n[0, 0, <b>2</b>, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, <b>2</b>, 0]\\n[0, 0, 0, 0, <b>2</b>, 0, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>]\\n[0, 0, 0, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, 0]\\n[0, 0, 0, 0, <b>2</b>, 0, <b>2</b>, 0, 0, 0]\\n```\\n```html5\\n<b>Grid status on day 4: Virus fully contained. No growth between day 3 and day 4.</b>\\n[<b>2</b>, 0, 0, 0, 0, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>]\\n[<b>2</b>, <b>2</b>, <b>2</b>, 0, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>]\\n[<b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, 0, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>]\\n[<b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, 0, <b>2</b>, <b>2</b>, <b>2</b>, 0]\\n[<b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, 0, 0, <b>2</b>, <b>2</b>, 0, 0]\\n[0, 0, <b>2</b>, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, <b>2</b>, 0]\\n[0, 0, 0, 0, <b>2</b>, 0, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>]\\n[0, 0, 0, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, 0]\\n[0, 0, 0, 0, <b>2</b>, 0, <b>2</b>, 0, 0, 0]\\n```\\n\\n<br>\\n\\nTo print a day by day visualization of the virus spread, run the following **Python3** code with a test-case of your choice as the input:\\n\\n<br>\\n\\n```python\\nclass Group_By_ID(object):\\n    def __init__(self, arr = [[]], walls = set(), day = 0, contained = set()):\\n        self.group_id = 0\\n        self.group = {}\\n        self.node_id = {}\\n        self.arr = arr\\n        self.walls = walls\\n        self.quarantine_not_complete = True\\n        self.day = day\\n        self.contained = contained\\n        self.step()\\n        self.show()\\n    \\n    def step(self) -> None:\\n        \\'\\'\\'Identifies groups of infected nodes. Places a wall around the most dangerous group.  Spreads the virus by 1 step.\\'\\'\\'\\n        self.get_edges()\\n        self.group_infections()\\n        self.wall_dangerous_group()\\n        self.spread_virus()\\n    \\n    def show(self) -> None:\\n        \\'\\'\\'Prints the current status of the array.\\'\\'\\'\\n        print(\\'\\\\nGrid status on day {}\\'.format(self.day))\\n        for r in range(len(self.arr)):\\n            print([2 if (r,c) in self.contained else self.arr[r][c] for c in range(len(self.arr[0]))])\\n    \\n    def get_edges(self) -> None:\\n        \\'\\'\\'Identifies infected_edges between two infected nodes and other_edges that have at least one un-infected node.\\'\\'\\'\\n        self.infected_edges = set()\\n        self.other_edges = set()\\n        R, C = len(self.arr), len(self.arr[0])\\n        for r in range(R):\\n            for c in range(C):\\n                for i, j in ((r,c),(r+1,c),(r-1,c),(r,c+1),(r,c-1)):\\n                    if (0 <= i < R) and (0 <= j < C):\\n                        edge = ((r, c), (i, j))\\n                        if edge not in self.walls:\\n                            self.infected_edges.add(edge) if self.arr[i][j] == self.arr[r][c] == 1 else self.other_edges.add(edge)\\n        \\n    def group_infections(self) -> None:\\n        \\'\\'\\'Collects infected edges into groups where each group consists of connected infected nodes.\\'\\'\\'\\n        for a, b in self.infected_edges:\\n            self.union(a, b)\\n    \\n    def union(self, a, b) -> None:\\n        \\'\\'\\'Connects infected nodes a and b.  Updates the infected groups to reflect the new connection.\\'\\'\\'\\n        if (a in self.node_id) and (b in self.node_id) and (self.node_id[a] != self.node_id[b]):\\n            self.merge_groups(a, b)\\n        elif (a in self.node_id) or (b in self.node_id):\\n            self.insert_node(a, b)\\n        else:\\n            self.create_new_group(a, b)\\n    \\n    def merge_groups(self, a, b) -> None:\\n        \\'\\'\\'Both a and b belong to a group.  Merge the smaller group into the larger group.\\'\\'\\'\\n        obsolete_id, target_id = sorted((self.node_id[a], self.node_id[b]), key = lambda id: len(self.group[id]))\\n        for node in self.group[obsolete_id]:\\n            self.node_id[node] = target_id\\n        self.group[target_id] |= self.group[obsolete_id]\\n        del self.group[obsolete_id]\\n    \\n    def insert_node(self, a, b) -> None:\\n        \\'\\'\\'Only a or only b belongs to a group, add the new node to the existing group.\\'\\'\\'\\n        a, b = (a, b) if a in self.node_id else (b, a)\\n        target_id = self.node_id[a]\\n        self.node_id[b] = target_id\\n        self.group[target_id] |= set([b])\\n    \\n    def create_new_group(self, a, b) -> None:\\n        \\'\\'\\'Node a and node b do not belong to a group, create a new group {a, b}.\\'\\'\\'\\n        self.group[self.group_id] = set([a,b])\\n        self.node_id[a] = self.node_id[b] = self.group_id\\n        self.group_id += 1\\n    \\n    def wall_dangerous_group(self) -> int:\\n        \\'\\'\\'Identifies the most dangerous group and places a wall around it.\\'\\'\\'\\n        most_infected_nodes = set()\\n        new_walls = set()\\n        new_contain = -1\\n        R, C = len(self.arr), len(self.arr[0])\\n        for g in self.group:\\n            projected_infected_nodes = set()\\n            projected_infected_edges = set()\\n            for r, c in self.group[g]:\\n                for i, j in ((r+1,c),(r-1,c),(r,c+1),(r,c-1)):\\n                    if (0 <= i < R) and (0 <= j < C):\\n                        edge = ((r, c), (i, j))\\n                        if (edge in self.other_edges) and (edge not in self.walls):\\n                            projected_infected_edges.add(edge)\\n                            projected_infected_edges.add(edge[::-1])\\n                            projected_infected_nodes.add((i, j))\\n            if len(projected_infected_nodes) > len(most_infected_nodes):\\n                most_infected_nodes = projected_infected_nodes.copy()\\n                new_walls = projected_infected_edges.copy()\\n                new_contain = g\\n        \\n        if new_contain != -1: self.contained |= self.group[new_contain]\\n        self.walls |= new_walls\\n        self.quarantine_not_complete = True if new_walls else False\\n    \\n    def spread_virus(self) -> None:\\n        \\'\\'\\'Spreads virus by one step\\'\\'\\'\\n        R, C = len(self.arr), len(self.arr[0])\\n        for g in self.group:\\n            for r, c in self.group[g]:\\n                for i, j in ((r+1,c),(r-1,c),(r,c+1),(r,c-1)):\\n                    if (0 <= i < R) and (0 <= j < C):\\n                        edge = ((r,c),(i,j))\\n                        if edge not in self.walls:\\n                            self.arr[i][j] = 1\\n        \\n    def __repr__(self):\\n        \\'\\'\\'Returns a dictionary of class attributes that represents the current state of the class instance.\\'\\'\\'\\n        return {\\'arr\\': [row[:] for row in self.arr],\\n                \\'walls\\': self.walls.copy(),\\n                \\'day\\': self.day + 1,\\n                \\'contained\\': self.contained.copy()}\\n    \\nclass Solution:\\n    def containVirus(self, arr: List[List[int]]) -> int:\\n        print(\\'Grid status on day 0\\')\\n        for row in arr: print(row)\\n            \\n        sol = Group_By_ID(arr = arr, walls = set(), day = 1, contained = set())\\n        while sol.quarantine_not_complete:\\n            sol = Group_By_ID(**sol.__repr__())\\n        return len(sol.walls) // 2\\n```",
                "solutionTags": [],
                "code": "```html5\\n<b>Grid status on day 0: Virus has not begun to spread.</b>\\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, <b>1</b>, 0, 0]\\n[<b>1</b>, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, <b>1</b>, 0, 0, 0, <b>1</b>, 0, 0, 0]   #\\n[0, 0, 0, 0, 0, 0, <b>1</b>, 0, 0, 0]   # Notice this group of 1s will be walled first and will not spread\\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, <b>1</b>, 0]\\n[0, 0, 0, 0, <b>1</b>, 0, <b>1</b>, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n```\n```html5\\n<b>Grid status on day 1</b>\\n[0, 0, 0, 0, 0, 0, 0, <b>1</b>, 0, 0]\\n[<b>1</b>, 0, 0, 0, 0, 0, <b>1</b>, <b>1</b>, <b>1</b>, 0]\\n[<b>1</b>, <b>1</b>, <b>1</b>, 0, 0, 0, 0, <b>1</b>, 0, 0]\\n[<b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>, 0, 0, <b>2</b>, 0, 0, 0]   #\\n[0, 0, <b>1</b>, 0, 0, 0, <b>2</b>, 0, 0, 0]   # 2 Means the group of infected nodes has been contained\\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, <b>1</b>, 0]   #\\n[0, 0, 0, 0, <b>1</b>, 0, <b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>]   #\\n[0, 0, 0, <b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>, 0]   # Three groups of 1s have merged into one large group of 1s.\\n[0, 0, 0, 0, <b>1</b>, 0, <b>1</b>, 0, 0, 0]   #\\n```\n```html5\\n<b>Grid status on day 2</b>\\n[<b>1</b>, 0, 0, 0, 0, 0, <b>1</b>, <b>1</b>, <b>1</b>, 0]   #\\n[<b>1</b>, <b>1</b>, <b>1</b>, 0, 0, <b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>]   # These two groups will not merge\\n[<b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>, 0, 0, <b>1</b>, <b>1</b>, <b>1</b>, 0]   # because one of them {(3,6), (4,6)} is walled off\\n[<b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>, 0, <b>2</b>, <b>1</b>, 0, 0]   #\\n[<b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>, 0, 0, <b>2</b>, 0, 0, 0]   #\\n[0, 0, <b>1</b>, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, <b>2</b>, 0]\\n[0, 0, 0, 0, <b>2</b>, 0, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>]\\n[0, 0, 0, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, 0]\\n[0, 0, 0, 0, <b>2</b>, 0, <b>2</b>, 0, 0, 0]\\n```\n```html5\\n<b>Grid status on day 3</b>\\n[<b>2</b>, 0, 0, 0, 0, <b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>]\\n[<b>2</b>, <b>2</b>, <b>2</b>, 0, <b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>]\\n[<b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, 0, <b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>, <b>1</b>]\\n[<b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, 0, <b>2</b>, <b>1</b>, <b>1</b>, 0]\\n[<b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, 0, 0, <b>2</b>, <b>1</b>, 0, 0]\\n[0, 0, <b>2</b>, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, <b>2</b>, 0]\\n[0, 0, 0, 0, <b>2</b>, 0, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>]\\n[0, 0, 0, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, 0]\\n[0, 0, 0, 0, <b>2</b>, 0, <b>2</b>, 0, 0, 0]\\n```\n```html5\\n<b>Grid status on day 4: Virus fully contained. No growth between day 3 and day 4.</b>\\n[<b>2</b>, 0, 0, 0, 0, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>]\\n[<b>2</b>, <b>2</b>, <b>2</b>, 0, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>]\\n[<b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, 0, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>]\\n[<b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, 0, <b>2</b>, <b>2</b>, <b>2</b>, 0]\\n[<b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, 0, 0, <b>2</b>, <b>2</b>, 0, 0]\\n[0, 0, <b>2</b>, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, <b>2</b>, 0]\\n[0, 0, 0, 0, <b>2</b>, 0, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>]\\n[0, 0, 0, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, <b>2</b>, 0]\\n[0, 0, 0, 0, <b>2</b>, 0, <b>2</b>, 0, 0, 0]\\n```\n```python\\nclass Group_By_ID(object):\\n    def __init__(self, arr = [[]], walls = set(), day = 0, contained = set()):\\n        self.group_id = 0\\n        self.group = {}\\n        self.node_id = {}\\n        self.arr = arr\\n        self.walls = walls\\n        self.quarantine_not_complete = True\\n        self.day = day\\n        self.contained = contained\\n        self.step()\\n        self.show()\\n    \\n    def step(self) -> None:\\n        \\'\\'\\'Identifies groups of infected nodes. Places a wall around the most dangerous group.  Spreads the virus by 1 step.\\'\\'\\'\\n        self.get_edges()\\n        self.group_infections()\\n        self.wall_dangerous_group()\\n        self.spread_virus()\\n    \\n    def show(self) -> None:\\n        \\'\\'\\'Prints the current status of the array.\\'\\'\\'\\n        print(\\'\\\\nGrid status on day {}\\'.format(self.day))\\n        for r in range(len(self.arr)):\\n            print([2 if (r,c) in self.contained else self.arr[r][c] for c in range(len(self.arr[0]))])\\n    \\n    def get_edges(self) -> None:\\n        \\'\\'\\'Identifies infected_edges between two infected nodes and other_edges that have at least one un-infected node.\\'\\'\\'\\n        self.infected_edges = set()\\n        self.other_edges = set()\\n        R, C = len(self.arr), len(self.arr[0])\\n        for r in range(R):\\n            for c in range(C):\\n                for i, j in ((r,c),(r+1,c),(r-1,c),(r,c+1),(r,c-1)):\\n                    if (0 <= i < R) and (0 <= j < C):\\n                        edge = ((r, c), (i, j))\\n                        if edge not in self.walls:\\n                            self.infected_edges.add(edge) if self.arr[i][j] == self.arr[r][c] == 1 else self.other_edges.add(edge)\\n        \\n    def group_infections(self) -> None:\\n        \\'\\'\\'Collects infected edges into groups where each group consists of connected infected nodes.\\'\\'\\'\\n        for a, b in self.infected_edges:\\n            self.union(a, b)\\n    \\n    def union(self, a, b) -> None:\\n        \\'\\'\\'Connects infected nodes a and b.  Updates the infected groups to reflect the new connection.\\'\\'\\'\\n        if (a in self.node_id) and (b in self.node_id) and (self.node_id[a] != self.node_id[b]):\\n            self.merge_groups(a, b)\\n        elif (a in self.node_id) or (b in self.node_id):\\n            self.insert_node(a, b)\\n        else:\\n            self.create_new_group(a, b)\\n    \\n    def merge_groups(self, a, b) -> None:\\n        \\'\\'\\'Both a and b belong to a group.  Merge the smaller group into the larger group.\\'\\'\\'\\n        obsolete_id, target_id = sorted((self.node_id[a], self.node_id[b]), key = lambda id: len(self.group[id]))\\n        for node in self.group[obsolete_id]:\\n            self.node_id[node] = target_id\\n        self.group[target_id] |= self.group[obsolete_id]\\n        del self.group[obsolete_id]\\n    \\n    def insert_node(self, a, b) -> None:\\n        \\'\\'\\'Only a or only b belongs to a group, add the new node to the existing group.\\'\\'\\'\\n        a, b = (a, b) if a in self.node_id else (b, a)\\n        target_id = self.node_id[a]\\n        self.node_id[b] = target_id\\n        self.group[target_id] |= set([b])\\n    \\n    def create_new_group(self, a, b) -> None:\\n        \\'\\'\\'Node a and node b do not belong to a group, create a new group {a, b}.\\'\\'\\'\\n        self.group[self.group_id] = set([a,b])\\n        self.node_id[a] = self.node_id[b] = self.group_id\\n        self.group_id += 1\\n    \\n    def wall_dangerous_group(self) -> int:\\n        \\'\\'\\'Identifies the most dangerous group and places a wall around it.\\'\\'\\'\\n        most_infected_nodes = set()\\n        new_walls = set()\\n        new_contain = -1\\n        R, C = len(self.arr), len(self.arr[0])\\n        for g in self.group:\\n            projected_infected_nodes = set()\\n            projected_infected_edges = set()\\n            for r, c in self.group[g]:\\n                for i, j in ((r+1,c),(r-1,c),(r,c+1),(r,c-1)):\\n                    if (0 <= i < R) and (0 <= j < C):\\n                        edge = ((r, c), (i, j))\\n                        if (edge in self.other_edges) and (edge not in self.walls):\\n                            projected_infected_edges.add(edge)\\n                            projected_infected_edges.add(edge[::-1])\\n                            projected_infected_nodes.add((i, j))\\n            if len(projected_infected_nodes) > len(most_infected_nodes):\\n                most_infected_nodes = projected_infected_nodes.copy()\\n                new_walls = projected_infected_edges.copy()\\n                new_contain = g\\n        \\n        if new_contain != -1: self.contained |= self.group[new_contain]\\n        self.walls |= new_walls\\n        self.quarantine_not_complete = True if new_walls else False\\n    \\n    def spread_virus(self) -> None:\\n        \\'\\'\\'Spreads virus by one step\\'\\'\\'\\n        R, C = len(self.arr), len(self.arr[0])\\n        for g in self.group:\\n            for r, c in self.group[g]:\\n                for i, j in ((r+1,c),(r-1,c),(r,c+1),(r,c-1)):\\n                    if (0 <= i < R) and (0 <= j < C):\\n                        edge = ((r,c),(i,j))\\n                        if edge not in self.walls:\\n                            self.arr[i][j] = 1\\n        \\n    def __repr__(self):\\n        \\'\\'\\'Returns a dictionary of class attributes that represents the current state of the class instance.\\'\\'\\'\\n        return {\\'arr\\': [row[:] for row in self.arr],\\n                \\'walls\\': self.walls.copy(),\\n                \\'day\\': self.day + 1,\\n                \\'contained\\': self.contained.copy()}\\n    \\nclass Solution:\\n    def containVirus(self, arr: List[List[int]]) -> int:\\n        print(\\'Grid status on day 0\\')\\n        for row in arr: print(row)\\n            \\n        sol = Group_By_ID(arr = arr, walls = set(), day = 1, contained = set())\\n        while sol.quarantine_not_complete:\\n            sol = Group_By_ID(**sol.__repr__())\\n        return len(sol.walls) // 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 110174,
                "title": "my-neat-java-solution-using-dfs",
                "content": "```\\nclass Solution {\\n    public int containVirus(int[][] grid) {\\n        int[] cost = new int[]{0};\\n        while(check(grid, cost));\\n        return cost[0];\\n    }\\n    \\n    private boolean check(int[][] grid, int[] cost) {\\n// update every day information and return false if no improvement can be made\\n        int count = 1;\\n        int max = -1;\\n        boolean flag = false;\\n        List<int[]> info = new ArrayList<>();\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1) {\\n                    count++;\\n                    int[][] walls = new int[grid.length][grid[0].length];\\n                    int[] res = new int[2];\\n                    grid[i][j] = count;\\n                    dfs(i, j, grid, count, walls, res);\\n                    if (res[0] != 0) flag = true;\\n                    if (max == -1 || res[0] > info.get(max)[0]) {\\n                        max = count - 2;\\n                    }\\n                    info.add(res);\\n                }\\n            }\\n        }\\n        if (count == 1) {\\n            return false;\\n        }\\n        cost[0] += info.get(max)[1];\\n        update(grid, max + 2);\\n        return flag;\\n    }\\n    \\n    \\n    private void dfs(int row, int col, int[][] grid, int count, int[][] walls, int[] res) {\\n//dfs and record number of walls need to block this area and how many 0s are under infection\\n        int[] shiftX = new int[]{1, 0, -1, 0};\\n        int[] shiftY = new int[]{0, 1, 0, -1};\\n        \\n        for(int i = 0; i < 4; i++) {\\n            int newRow = row + shiftX[i];\\n            int newCol = col + shiftY[i];\\n            if (newRow >= 0 && newRow < grid.length && newCol >= 0 && newCol < grid[0].length) {\\n                if (grid[newRow][newCol] == 1) {\\n                    grid[newRow][newCol] = count;\\n                    dfs(newRow, newCol, grid, count, walls, res);\\n                } else if (grid[newRow][newCol] == 0) {\\n                    if (walls[newRow][newCol] == 0) res[0]++;\\n                    if ((walls[newRow][newCol] & 1 << i) == 0) {\\n                        res[1]++;\\n                        walls[newRow][newCol] |= 1 << i;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n        \\n        \\n    private void update(int[][] grid, int quarantine) {\\n//set the new infected area and set blocked area to be -1\\n        int[] shiftX = new int[]{1, 0, -1, 0};\\n        int[] shiftY = new int[]{0, 1, 0, -1};\\n            \\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] > 1 && grid[i][j] != quarantine) {\\n                    for (int k = 0; k < 4; k++) {\\n                        int newRow = i + shiftX[k];\\n                        int newCol = j + shiftY[k];\\n                        if (newRow >= 0 && newRow < grid.length && newCol >= 0 && newCol < grid[0].length && grid[newRow][newCol] == 0) {\\n                            grid[newRow][newCol] = 1;\\n                        }\\n                    }\\n                    grid[i][j] = 1;\\n                } else if (grid[i][j] == quarantine) {\\n                    grid[i][j] = -1;\\n                }\\n            }\\n        }\\n    }     \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int containVirus(int[][] grid) {\\n        int[] cost = new int[]{0};\\n        while(check(grid, cost));\\n        return cost[0];\\n    }\\n    \\n    private boolean check(int[][] grid, int[] cost) {\\n// update every day information and return false if no improvement can be made\\n        int count = 1;\\n        int max = -1;\\n        boolean flag = false;\\n        List<int[]> info = new ArrayList<>();\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1) {\\n                    count++;\\n                    int[][] walls = new int[grid.length][grid[0].length];\\n                    int[] res = new int[2];\\n                    grid[i][j] = count;\\n                    dfs(i, j, grid, count, walls, res);\\n                    if (res[0] != 0) flag = true;\\n                    if (max == -1 || res[0] > info.get(max)[0]) {\\n                        max = count - 2;\\n                    }\\n                    info.add(res);\\n                }\\n            }\\n        }\\n        if (count == 1) {\\n            return false;\\n        }\\n        cost[0] += info.get(max)[1];\\n        update(grid, max + 2);\\n        return flag;\\n    }\\n    \\n    \\n    private void dfs(int row, int col, int[][] grid, int count, int[][] walls, int[] res) {\\n//dfs and record number of walls need to block this area and how many 0s are under infection\\n        int[] shiftX = new int[]{1, 0, -1, 0};\\n        int[] shiftY = new int[]{0, 1, 0, -1};\\n        \\n        for(int i = 0; i < 4; i++) {\\n            int newRow = row + shiftX[i];\\n            int newCol = col + shiftY[i];\\n            if (newRow >= 0 && newRow < grid.length && newCol >= 0 && newCol < grid[0].length) {\\n                if (grid[newRow][newCol] == 1) {\\n                    grid[newRow][newCol] = count;\\n                    dfs(newRow, newCol, grid, count, walls, res);\\n                } else if (grid[newRow][newCol] == 0) {\\n                    if (walls[newRow][newCol] == 0) res[0]++;\\n                    if ((walls[newRow][newCol] & 1 << i) == 0) {\\n                        res[1]++;\\n                        walls[newRow][newCol] |= 1 << i;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n        \\n        \\n    private void update(int[][] grid, int quarantine) {\\n//set the new infected area and set blocked area to be -1\\n        int[] shiftX = new int[]{1, 0, -1, 0};\\n        int[] shiftY = new int[]{0, 1, 0, -1};\\n            \\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] > 1 && grid[i][j] != quarantine) {\\n                    for (int k = 0; k < 4; k++) {\\n                        int newRow = i + shiftX[k];\\n                        int newCol = j + shiftY[k];\\n                        if (newRow >= 0 && newRow < grid.length && newCol >= 0 && newCol < grid[0].length && grid[newRow][newCol] == 0) {\\n                            grid[newRow][newCol] = 1;\\n                        }\\n                    }\\n                    grid[i][j] = 1;\\n                } else if (grid[i][j] == quarantine) {\\n                    grid[i][j] = -1;\\n                }\\n            }\\n        }\\n    }     \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 110183,
                "title": "concise-c-solution-with-bfs-12ms",
                "content": "```\\nint containVirus(vector<vector<int>>& g) {\\n    int res = 0, c = 1; // c increments for visited cells\\n\\n    while (true) {\\n        // tuple components: walls, inside coords with value c, border coords with value 0\\n        vector<tuple<int, vector<pair<int, int>>, set<pair<int, int>>>> areas;\\n        int mx = 0, idx;\\n\\n        for (int i = 0; i < g.size(); i++) {\\n            for (int j = 0; j < g[0].size(); j++) {\\n                if (g[i][j] == c) {\\n                    areas.resize(areas.size() + 1); // found a new area\\n\\n                    int &walls = get<0>(areas.back());\\n                    auto &inside = get<1>(areas.back());\\n                    auto &border = get<2>(areas.back());\\n\\n                    g[i][j] = c + 1; // mark as visited\\n                    inside.emplace_back(i, j);\\n\\n                    queue<pair<int, int>> q;\\n                    q.emplace(i, j);\\n\\n                    while (!q.empty()) {\\n                        int x, y;\\n                        tie(x, y) = q.front();\\n                        q.pop();\\n\\n                        for_4neighbors(g, x, y, [&](int a, int b) {\\n                            if (g[a][b] == c) {\\n                                q.emplace(a, b);\\n                                g[a][b] = c + 1; // mark as visited\\n                                inside.emplace_back(a, b);\\n                            } else if (g[a][b] == 0) {\\n                                border.emplace(a, b);\\n                                walls++;\\n                            }\\n                        });\\n                    }\\n\\n                    if (border.size() > mx) {\\n                        mx = border.size();\\n                        idx = areas.size() - 1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (mx == 0) break;\\n        c++; // all visited viruses are back\\n\\n        for (auto &p : get<1>(areas[idx]))\\n            g[p.first][p.second] = -1; // mark as dead\\n        get<2>(areas[idx]).clear(); // dead viruses no longer spread\\n\\n        for (auto &a : areas)\\n            for (auto &p : get<2>(a))\\n                g[p.first][p.second] = c; // mark as contaminated\\n\\n        res += get<0>(areas[idx]);\\n    }\\n\\n    return res;\\n}\\n```\\n\\nWith a helper defined:\\n```\\ntemplate<typename Ctnr, typename Func>\\ninline void for_4neighbors(const Ctnr &ctnr, int row, int col, Func func) {\\n    if (row - 1 >= 0)\\n        func(row - 1, col);\\n    if (row + 1 < ctnr.size())\\n        func(row + 1, col);\\n    if (col - 1 >= 0)\\n        func(row, col - 1);\\n    if (col + 1 < ctnr[0].size())\\n        func(row, col + 1);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint containVirus(vector<vector<int>>& g) {\\n    int res = 0, c = 1; // c increments for visited cells\\n\\n    while (true) {\\n        // tuple components: walls, inside coords with value c, border coords with value 0\\n        vector<tuple<int, vector<pair<int, int>>, set<pair<int, int>>>> areas;\\n        int mx = 0, idx;\\n\\n        for (int i = 0; i < g.size(); i++) {\\n            for (int j = 0; j < g[0].size(); j++) {\\n                if (g[i][j] == c) {\\n                    areas.resize(areas.size() + 1); // found a new area\\n\\n                    int &walls = get<0>(areas.back());\\n                    auto &inside = get<1>(areas.back());\\n                    auto &border = get<2>(areas.back());\\n\\n                    g[i][j] = c + 1; // mark as visited\\n                    inside.emplace_back(i, j);\\n\\n                    queue<pair<int, int>> q;\\n                    q.emplace(i, j);\\n\\n                    while (!q.empty()) {\\n                        int x, y;\\n                        tie(x, y) = q.front();\\n                        q.pop();\\n\\n                        for_4neighbors(g, x, y, [&](int a, int b) {\\n                            if (g[a][b] == c) {\\n                                q.emplace(a, b);\\n                                g[a][b] = c + 1; // mark as visited\\n                                inside.emplace_back(a, b);\\n                            } else if (g[a][b] == 0) {\\n                                border.emplace(a, b);\\n                                walls++;\\n                            }\\n                        });\\n                    }\\n\\n                    if (border.size() > mx) {\\n                        mx = border.size();\\n                        idx = areas.size() - 1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (mx == 0) break;\\n        c++; // all visited viruses are back\\n\\n        for (auto &p : get<1>(areas[idx]))\\n            g[p.first][p.second] = -1; // mark as dead\\n        get<2>(areas[idx]).clear(); // dead viruses no longer spread\\n\\n        for (auto &a : areas)\\n            for (auto &p : get<2>(a))\\n                g[p.first][p.second] = c; // mark as contaminated\\n\\n        res += get<0>(areas[idx]);\\n    }\\n\\n    return res;\\n}\\n```\n```\\ntemplate<typename Ctnr, typename Func>\\ninline void for_4neighbors(const Ctnr &ctnr, int row, int col, Func func) {\\n    if (row - 1 >= 0)\\n        func(row - 1, col);\\n    if (row + 1 < ctnr.size())\\n        func(row + 1, col);\\n    if (col - 1 >= 0)\\n        func(row, col - 1);\\n    if (col + 1 < ctnr[0].size())\\n        func(row, col + 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1291751,
                "title": "c-exactly-what-the-hint-said",
                "content": "**Algorithm**\\n1. Iterate over all regions and get the coordinates of region with maximum area threatened\\n2. Mark the max threatened region obtained in step 1 as -1 signifying it is disinfected. Add perimeter to answer.\\n3. Expand the remaining regions\\n4. Repeat step 1 to 3 till max area threatened = 0\\n\\n***Note:*** \\n* For area threatened calculation we cannot repeat the 0 cells adjoining the region therefore we use visited set\\n* For perimeter calculation we don\\'t have such restrictions\\n* For both of the above cases we cannot goto a cell marked -1 which signifies as disinfected\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    int ans = 0;\\n    \\n    // -1 means disinfected\\n    int color = 2;\\n    \\n    // for perimeter calculation we cannot go to cells marked -1 but we can goto all other cells\\n    int perimeter = 0;\\n    \\n    // we can go to cells marked as 0 only\\n    // this will store the area being threatened\\n    int areat = 0;\\n    \\n    int containVirus(vector<vector<int>>& a) {\\n        m = a.size();\\n        n = a[0].size();\\n\\n        while(1){\\n            int restrictX, restrictY;\\n            int big = -1;\\n            for(int i = 0 ; i < m ; i++){\\n                for(int j = 0 ; j < n ; j++){\\n                    if(a[i][j] == color-1){\\n                        \\n                        //capture this region and color it with color\\n                        dfs(a, i, j);\\n                        areat = 0;\\n                        set<pair<int, int>> visited;\\n                        calculateAreat(a, i, j, visited);\\n                        //calculateAreat marks the region with -2 so we will restore\\n                        restore(a, i, j);\\n                        if(big < areat){\\n                            big = areat;\\n                            restrictX = i;\\n                            restrictY = j;\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            if(big != -1){\\n                perimeter = 0;\\n                calculatePerimeter(a, restrictX, restrictY);\\n                ans += perimeter;\\n                int temp = color;\\n                color = -1;\\n                // disinfect this region by marking as -1\\n                restore(a, restrictX, restrictY);\\n                \\n                color = temp+1;\\n                for(int i = 0 ; i < m ; i++){\\n                    for(int j = 0 ; j < n ; j++){\\n                        if(a[i][j] == color-1){\\n                            expand(a, i, j, a[i][j]);\\n                            // expand marks the region as -2 so we restore it to color\\n                            restore(a, i, j);\\n                        }\\n                    }\\n                }\\n                color++;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    void expand(vector<vector<int>>& a, int x, int y, int currcolor){\\n        if(x < 0 || y < 0 || x >= m || y >= n){\\n            return;\\n        }\\n        \\n        if(a[x][y] == 0){\\n            a[x][y] = -2;\\n            return;\\n        }\\n        \\n        if(a[x][y] == -2 || a[x][y] == -1 || a[x][y] != currcolor){\\n            return;\\n        }\\n        \\n        a[x][y] = -2;\\n        expand(a, x+1, y, currcolor);\\n        expand(a, x, y+1, currcolor);\\n        expand(a, x, y-1, currcolor);\\n        expand(a, x-1, y, currcolor);\\n    }\\n    \\n    void dfs(vector<vector<int>>& a, int x, int y){\\n        if(x < 0 || y < 0 || x >= m || y >= n || a[x][y] == 0 || a[x][y] == -1){\\n            return;\\n        }\\n        \\n        if(a[x][y] == color){\\n            return;\\n        }\\n        \\n        a[x][y] = color;\\n        dfs(a, x+1, y);\\n        dfs(a, x, y+1);\\n        dfs(a, x, y-1);\\n        dfs(a, x-1, y);\\n    }\\n    \\n    void restore(vector<vector<int>>& a, int x, int y){\\n        if(x < 0 || y < 0 || x >= m || y >= n || a[x][y] == 0 || a[x][y] != -2){\\n            return;\\n        }\\n        \\n        a[x][y] = color;\\n        restore(a, x+1, y);\\n        restore(a, x, y+1);\\n        restore(a, x, y-1);\\n        restore(a, x-1, y);\\n    }\\n    \\n    // -2 is under processing\\n    void calculatePerimeter(vector<vector<int>>& a, int x, int y){\\n        if(x < 0 || y < 0 || x >= m || y >= n || a[x][y] == -1 || a[x][y] == -2){\\n            return;\\n        }\\n        \\n        if(a[x][y] == 0){\\n            perimeter++;\\n            return;\\n        }\\n        \\n        a[x][y] = -2;\\n        calculatePerimeter(a, x+1, y);\\n        calculatePerimeter(a, x, y+1);\\n        calculatePerimeter(a, x, y-1);\\n        calculatePerimeter(a, x-1, y);\\n    }\\n    \\n    // -2 is under processing\\n    void calculateAreat(vector<vector<int>>& a, int x, int y, set<pair<int, int>> &visited){\\n        if(x < 0 || y < 0 || x >= m || y >= n || a[x][y] == -2 \\n           || a[x][y] == -1 || visited.count({x,y})){\\n            return;\\n        }\\n        \\n        if(a[x][y] == 0){\\n            visited.insert({x,y});\\n            areat++;\\n            return;\\n        }\\n        \\n        a[x][y] = -2;\\n        calculateAreat(a, x+1, y, visited);\\n        calculateAreat(a, x, y+1, visited);\\n        calculateAreat(a, x, y-1, visited);\\n        calculateAreat(a, x-1, y, visited);\\n    }\\n    \\n    void print(vector<vector<int>> &a){\\n        for(int i = 0 ; i < m ; i++){\\n            for(int j = 0 ; j < n ; j++){\\n                cout<<a[i][j]<<\"\\\\t\";\\n            }\\n            cout<<endl;\\n        }\\n        cout<<endl;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m, n;\\n    int ans = 0;\\n    \\n    // -1 means disinfected\\n    int color = 2;\\n    \\n    // for perimeter calculation we cannot go to cells marked -1 but we can goto all other cells\\n    int perimeter = 0;\\n    \\n    // we can go to cells marked as 0 only\\n    // this will store the area being threatened\\n    int areat = 0;\\n    \\n    int containVirus(vector<vector<int>>& a) {\\n        m = a.size();\\n        n = a[0].size();\\n\\n        while(1){\\n            int restrictX, restrictY;\\n            int big = -1;\\n            for(int i = 0 ; i < m ; i++){\\n                for(int j = 0 ; j < n ; j++){\\n                    if(a[i][j] == color-1){\\n                        \\n                        //capture this region and color it with color\\n                        dfs(a, i, j);\\n                        areat = 0;\\n                        set<pair<int, int>> visited;\\n                        calculateAreat(a, i, j, visited);\\n                        //calculateAreat marks the region with -2 so we will restore\\n                        restore(a, i, j);\\n                        if(big < areat){\\n                            big = areat;\\n                            restrictX = i;\\n                            restrictY = j;\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            if(big != -1){\\n                perimeter = 0;\\n                calculatePerimeter(a, restrictX, restrictY);\\n                ans += perimeter;\\n                int temp = color;\\n                color = -1;\\n                // disinfect this region by marking as -1\\n                restore(a, restrictX, restrictY);\\n                \\n                color = temp+1;\\n                for(int i = 0 ; i < m ; i++){\\n                    for(int j = 0 ; j < n ; j++){\\n                        if(a[i][j] == color-1){\\n                            expand(a, i, j, a[i][j]);\\n                            // expand marks the region as -2 so we restore it to color\\n                            restore(a, i, j);\\n                        }\\n                    }\\n                }\\n                color++;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    void expand(vector<vector<int>>& a, int x, int y, int currcolor){\\n        if(x < 0 || y < 0 || x >= m || y >= n){\\n            return;\\n        }\\n        \\n        if(a[x][y] == 0){\\n            a[x][y] = -2;\\n            return;\\n        }\\n        \\n        if(a[x][y] == -2 || a[x][y] == -1 || a[x][y] != currcolor){\\n            return;\\n        }\\n        \\n        a[x][y] = -2;\\n        expand(a, x+1, y, currcolor);\\n        expand(a, x, y+1, currcolor);\\n        expand(a, x, y-1, currcolor);\\n        expand(a, x-1, y, currcolor);\\n    }\\n    \\n    void dfs(vector<vector<int>>& a, int x, int y){\\n        if(x < 0 || y < 0 || x >= m || y >= n || a[x][y] == 0 || a[x][y] == -1){\\n            return;\\n        }\\n        \\n        if(a[x][y] == color){\\n            return;\\n        }\\n        \\n        a[x][y] = color;\\n        dfs(a, x+1, y);\\n        dfs(a, x, y+1);\\n        dfs(a, x, y-1);\\n        dfs(a, x-1, y);\\n    }\\n    \\n    void restore(vector<vector<int>>& a, int x, int y){\\n        if(x < 0 || y < 0 || x >= m || y >= n || a[x][y] == 0 || a[x][y] != -2){\\n            return;\\n        }\\n        \\n        a[x][y] = color;\\n        restore(a, x+1, y);\\n        restore(a, x, y+1);\\n        restore(a, x, y-1);\\n        restore(a, x-1, y);\\n    }\\n    \\n    // -2 is under processing\\n    void calculatePerimeter(vector<vector<int>>& a, int x, int y){\\n        if(x < 0 || y < 0 || x >= m || y >= n || a[x][y] == -1 || a[x][y] == -2){\\n            return;\\n        }\\n        \\n        if(a[x][y] == 0){\\n            perimeter++;\\n            return;\\n        }\\n        \\n        a[x][y] = -2;\\n        calculatePerimeter(a, x+1, y);\\n        calculatePerimeter(a, x, y+1);\\n        calculatePerimeter(a, x, y-1);\\n        calculatePerimeter(a, x-1, y);\\n    }\\n    \\n    // -2 is under processing\\n    void calculateAreat(vector<vector<int>>& a, int x, int y, set<pair<int, int>> &visited){\\n        if(x < 0 || y < 0 || x >= m || y >= n || a[x][y] == -2 \\n           || a[x][y] == -1 || visited.count({x,y})){\\n            return;\\n        }\\n        \\n        if(a[x][y] == 0){\\n            visited.insert({x,y});\\n            areat++;\\n            return;\\n        }\\n        \\n        a[x][y] = -2;\\n        calculateAreat(a, x+1, y, visited);\\n        calculateAreat(a, x, y+1, visited);\\n        calculateAreat(a, x, y-1, visited);\\n        calculateAreat(a, x-1, y, visited);\\n    }\\n    \\n    void print(vector<vector<int>> &a){\\n        for(int i = 0 ; i < m ; i++){\\n            for(int j = 0 ; j < n ; j++){\\n                cout<<a[i][j]<<\"\\\\t\";\\n            }\\n            cout<<endl;\\n        }\\n        cout<<endl;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 189594,
                "title": "trying-to-understand-a-test-case",
                "content": "Can someone please explain why the expected output is 38 for the below input?\\n\\nInput:\\n[[0,1,0,1,1,1,1,1,1,0],[0,0,0,1,0,0,0,0,0,0],[0,0,1,1,1,0,0,0,1,0],[0,0,0,1,1,0,0,1,1,0],[0,1,0,0,1,0,1,1,0,1],[0,0,0,1,0,1,0,1,1,1],[0,1,0,0,1,0,0,1,1,0],[0,1,0,1,0,0,0,1,1,0],[0,1,1,0,0,1,1,0,0,1],[1,0,1,1,0,1,0,1,0,1]]\\n\\nExpected: 38\\nMy output: 40\\n\\n```\\nH= Healthy Q = Quarentine\\nI = Infected W = Wall\\nInitial:\\nH, ,I, ,H, ,I, ,I, ,I, ,I, ,I, ,I, ,H,\\n , , , , , , , , , , , , , , , , , , ,\\nH, ,H, ,H, ,I, ,H, ,H, ,H, ,H, ,H, ,H,\\n , , , , , , , , , , , , , , , , , , ,\\nH, ,H, ,I, ,I, ,I, ,H, ,H, ,H, ,I, ,H,\\n , , , , , , , , , , , , , , , , , , ,\\nH, ,H, ,H, ,I, ,I, ,H, ,H, ,I, ,I, ,H,\\n , , , , , , , , , , , , , , , , , , ,\\nH, ,I, ,H, ,H, ,I, ,H, ,I, ,I, ,H, ,I,\\n , , , , , , , , , , , , , , , , , , ,\\nH, ,H, ,H, ,I, ,H, ,I, ,H, ,I, ,I, ,I,\\n , , , , , , , , , , , , , , , , , , ,\\nH, ,I, ,H, ,H, ,I, ,H, ,H, ,I, ,I, ,H,\\n , , , , , , , , , , , , , , , , , , ,\\nH, ,I, ,H, ,I, ,H, ,H, ,H, ,I, ,I, ,H,\\n , , , , , , , , , , , , , , , , , , ,\\nH, ,I, ,I, ,H, ,H, ,I, ,I, ,H, ,H, ,I,\\n , , , , , , , , , , , , , , , , , , ,\\nI, ,H, ,I, ,I, ,H, ,I, ,H, ,I, ,H, ,I,\\n\\nAfter first quarentine: Total walls = 22\\n\\nH, ,I, ,H, ,I, ,I, ,I, ,I, ,I, ,I, ,H,\\n , , , , , , , , , , , , , , , , , , ,\\nH, ,H, ,H, ,I, ,H, ,H, ,H, ,H, ,H, ,H,\\n , , , , , , , , , , , , , , , ,W, , ,\\nH, ,H, ,I, ,I, ,I, ,H, ,H, ,H,W,Q,W,H,\\n , , , , , , , , , , , , , ,W, , , , ,\\nH, ,H, ,H, ,I, ,I, ,H, ,H,W,Q, ,Q,W,H,\\n , , , , , , , , , , , ,W, , , ,W, ,W,\\nH, ,I, ,H, ,H, ,I, ,H,W,Q, ,Q,W,H,W,Q,\\n , , , , , , , , , , , ,W, , , ,W, , ,\\nH, ,H, ,H, ,I, ,H, ,I, ,H,W,Q, ,Q, ,Q,\\n , , , , , , , , , , , , , , , , , ,W,\\nH, ,I, ,H, ,H, ,I, ,H, ,H,W,Q, ,Q,W,H,\\n , , , , , , , , , , , , , , , , , , ,\\nH, ,I, ,H, ,I, ,H, ,H, ,H,W,Q, ,Q,W,H,\\n , , , , , , , , , , , , , ,W, ,W, , ,\\nH, ,I, ,I, ,H, ,H, ,I, ,I, ,H, ,H, ,I,\\n , , , , , , , , , , , , , , , , , , ,\\nI, ,H, ,I, ,I, ,H, ,I, ,H, ,I, ,H, ,I,\\n\\nAfter first spread:\\n\\nI, ,I, ,I, ,I, ,I, ,I, ,I, ,I, ,I, ,I,\\n , , , , , , , , , , , , , , , , , , ,\\nH, ,I, ,I, ,I, ,I, ,I, ,I, ,I, ,I, ,H,\\n , , , , , , , , , , , , , , , ,W, , ,\\nH, ,I, ,I, ,I, ,I, ,I, ,H, ,H,W,Q,W,H,\\n , , , , , , , , , , , , , ,W, , , , ,\\nH, ,I, ,I, ,I, ,I, ,I, ,H,W,Q, ,Q,W,H,\\n , , , , , , , , , , , ,W, , , ,W, ,W,\\nI, ,I, ,I, ,I, ,I, ,I,W,Q, ,Q,W,H,W,Q,\\n , , , , , , , , , , , ,W, , , ,W, , ,\\nH, ,I, ,I, ,I, ,I, ,I, ,I,W,Q, ,Q, ,Q,\\n , , , , , , , , , , , , , , , , , ,W,\\nI, ,I, ,I, ,I, ,I, ,I, ,H,W,Q, ,Q,W,H,\\n , , , , , , , , , , , , , , , , , , ,\\nI, ,I, ,I, ,I, ,I, ,I, ,I,W,Q, ,Q,W,I,\\n , , , , , , , , , , , , , ,W, ,W, , ,\\nI, ,I, ,I, ,I, ,I, ,I, ,I, ,I, ,I, ,I,\\n , , , , , , , , , , , , , , , , , , ,\\nI, ,I, ,I, ,I, ,I, ,I, ,I, ,I, ,I, ,I,\\n\\nAfter second quarentine: Total walls = 40\\nQ, ,Q, ,Q, ,Q, ,Q, ,Q, ,Q, ,Q, ,Q, ,Q,\\nW, , , , , , , , , , , , , , , , , ,W,\\nH,W,Q, ,Q, ,Q, ,Q, ,Q, ,Q, ,Q, ,Q,W,H,\\n , , , , , , , , , , , ,W, ,W, ,W, , ,\\nH,W,Q, ,Q, ,Q, ,Q, ,Q,W,H, ,H,W,Q,W,H,\\n , , , , , , , , , , , , , ,W, , , , ,\\nH,W,Q, ,Q, ,Q, ,Q, ,Q,W,H,W,Q, ,Q,W,H,\\nW, , , , , , , , , , , ,W, , , ,W, ,W,\\nQ, ,Q, ,Q, ,Q, ,Q, ,Q,W,Q, ,Q,W,H,W,Q,\\nW, , , , , , , , , , , ,W, , , ,W, , ,\\nH,W,Q, ,Q, ,Q, ,Q, ,Q, ,Q,W,Q, ,Q, ,Q,\\nW, , , , , , , , , , , ,W, , , , , ,W,\\nQ, ,Q, ,Q, ,Q, ,Q, ,Q,W,H,W,Q, ,Q,W,H,\\n , , , , , , , , , , , ,W, , , , , ,W,\\nQ, ,Q, ,Q, ,Q, ,Q, ,Q, ,Q,W,Q, ,Q,W,Q,\\n , , , , , , , , , , , , , ,W, ,W, , ,\\nQ, ,Q, ,Q, ,Q, ,Q, ,Q, ,Q, ,Q, ,Q, ,Q,\\n , , , , , , , , , , , , , , , , , , ,\\nQ, ,Q, ,Q, ,Q, ,Q, ,Q, ,Q, ,Q, ,Q, ,Q,\\n```",
                "solutionTags": [],
                "code": "```\\nH= Healthy Q = Quarentine\\nI = Infected W = Wall\\nInitial:\\nH, ,I, ,H, ,I, ,I, ,I, ,I, ,I, ,I, ,H,\\n , , , , , , , , , , , , , , , , , , ,\\nH, ,H, ,H, ,I, ,H, ,H, ,H, ,H, ,H, ,H,\\n , , , , , , , , , , , , , , , , , , ,\\nH, ,H, ,I, ,I, ,I, ,H, ,H, ,H, ,I, ,H,\\n , , , , , , , , , , , , , , , , , , ,\\nH, ,H, ,H, ,I, ,I, ,H, ,H, ,I, ,I, ,H,\\n , , , , , , , , , , , , , , , , , , ,\\nH, ,I, ,H, ,H, ,I, ,H, ,I, ,I, ,H, ,I,\\n , , , , , , , , , , , , , , , , , , ,\\nH, ,H, ,H, ,I, ,H, ,I, ,H, ,I, ,I, ,I,\\n , , , , , , , , , , , , , , , , , , ,\\nH, ,I, ,H, ,H, ,I, ,H, ,H, ,I, ,I, ,H,\\n , , , , , , , , , , , , , , , , , , ,\\nH, ,I, ,H, ,I, ,H, ,H, ,H, ,I, ,I, ,H,\\n , , , , , , , , , , , , , , , , , , ,\\nH, ,I, ,I, ,H, ,H, ,I, ,I, ,H, ,H, ,I,\\n , , , , , , , , , , , , , , , , , , ,\\nI, ,H, ,I, ,I, ,H, ,I, ,H, ,I, ,H, ,I,\\n\\nAfter first quarentine: Total walls = 22\\n\\nH, ,I, ,H, ,I, ,I, ,I, ,I, ,I, ,I, ,H,\\n , , , , , , , , , , , , , , , , , , ,\\nH, ,H, ,H, ,I, ,H, ,H, ,H, ,H, ,H, ,H,\\n , , , , , , , , , , , , , , , ,W, , ,\\nH, ,H, ,I, ,I, ,I, ,H, ,H, ,H,W,Q,W,H,\\n , , , , , , , , , , , , , ,W, , , , ,\\nH, ,H, ,H, ,I, ,I, ,H, ,H,W,Q, ,Q,W,H,\\n , , , , , , , , , , , ,W, , , ,W, ,W,\\nH, ,I, ,H, ,H, ,I, ,H,W,Q, ,Q,W,H,W,Q,\\n , , , , , , , , , , , ,W, , , ,W, , ,\\nH, ,H, ,H, ,I, ,H, ,I, ,H,W,Q, ,Q, ,Q,\\n , , , , , , , , , , , , , , , , , ,W,\\nH, ,I, ,H, ,H, ,I, ,H, ,H,W,Q, ,Q,W,H,\\n , , , , , , , , , , , , , , , , , , ,\\nH, ,I, ,H, ,I, ,H, ,H, ,H,W,Q, ,Q,W,H,\\n , , , , , , , , , , , , , ,W, ,W, , ,\\nH, ,I, ,I, ,H, ,H, ,I, ,I, ,H, ,H, ,I,\\n , , , , , , , , , , , , , , , , , , ,\\nI, ,H, ,I, ,I, ,H, ,I, ,H, ,I, ,H, ,I,\\n\\nAfter first spread:\\n\\nI, ,I, ,I, ,I, ,I, ,I, ,I, ,I, ,I, ,I,\\n , , , , , , , , , , , , , , , , , , ,\\nH, ,I, ,I, ,I, ,I, ,I, ,I, ,I, ,I, ,H,\\n , , , , , , , , , , , , , , , ,W, , ,\\nH, ,I, ,I, ,I, ,I, ,I, ,H, ,H,W,Q,W,H,\\n , , , , , , , , , , , , , ,W, , , , ,\\nH, ,I, ,I, ,I, ,I, ,I, ,H,W,Q, ,Q,W,H,\\n , , , , , , , , , , , ,W, , , ,W, ,W,\\nI, ,I, ,I, ,I, ,I, ,I,W,Q, ,Q,W,H,W,Q,\\n , , , , , , , , , , , ,W, , , ,W, , ,\\nH, ,I, ,I, ,I, ,I, ,I, ,I,W,Q, ,Q, ,Q,\\n , , , , , , , , , , , , , , , , , ,W,\\nI, ,I, ,I, ,I, ,I, ,I, ,H,W,Q, ,Q,W,H,\\n , , , , , , , , , , , , , , , , , , ,\\nI, ,I, ,I, ,I, ,I, ,I, ,I,W,Q, ,Q,W,I,\\n , , , , , , , , , , , , , ,W, ,W, , ,\\nI, ,I, ,I, ,I, ,I, ,I, ,I, ,I, ,I, ,I,\\n , , , , , , , , , , , , , , , , , , ,\\nI, ,I, ,I, ,I, ,I, ,I, ,I, ,I, ,I, ,I,\\n\\nAfter second quarentine: Total walls = 40\\nQ, ,Q, ,Q, ,Q, ,Q, ,Q, ,Q, ,Q, ,Q, ,Q,\\nW, , , , , , , , , , , , , , , , , ,W,\\nH,W,Q, ,Q, ,Q, ,Q, ,Q, ,Q, ,Q, ,Q,W,H,\\n , , , , , , , , , , , ,W, ,W, ,W, , ,\\nH,W,Q, ,Q, ,Q, ,Q, ,Q,W,H, ,H,W,Q,W,H,\\n , , , , , , , , , , , , , ,W, , , , ,\\nH,W,Q, ,Q, ,Q, ,Q, ,Q,W,H,W,Q, ,Q,W,H,\\nW, , , , , , , , , , , ,W, , , ,W, ,W,\\nQ, ,Q, ,Q, ,Q, ,Q, ,Q,W,Q, ,Q,W,H,W,Q,\\nW, , , , , , , , , , , ,W, , , ,W, , ,\\nH,W,Q, ,Q, ,Q, ,Q, ,Q, ,Q,W,Q, ,Q, ,Q,\\nW, , , , , , , , , , , ,W, , , , , ,W,\\nQ, ,Q, ,Q, ,Q, ,Q, ,Q,W,H,W,Q, ,Q,W,H,\\n , , , , , , , , , , , ,W, , , , , ,W,\\nQ, ,Q, ,Q, ,Q, ,Q, ,Q, ,Q,W,Q, ,Q,W,Q,\\n , , , , , , , , , , , , , ,W, ,W, , ,\\nQ, ,Q, ,Q, ,Q, ,Q, ,Q, ,Q, ,Q, ,Q, ,Q,\\n , , , , , , , , , , , , , , , , , , ,\\nQ, ,Q, ,Q, ,Q, ,Q, ,Q, ,Q, ,Q, ,Q, ,Q,\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2765337,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int> > g;\\n    int n, m, c, mx, w, r, ans, itr;\\n    unordered_set<int> s;\\n    \\n    int dfs(int i, int j){\\n        if(i<0 || i>=n || j<0 || j>=m || g[i][j]!=1)\\n            return 0;\\n        int ans=0;\\n        if(i+1<n && g[i+1][j]==0){\\n            s.insert((i+1)*m+j);\\n            ans++;\\n        }\\n        if(i-1>=0 && g[i-1][j]==0){\\n            s.insert((i-1)*m+j);\\n            ans++;\\n        }\\n        if(j+1<m && g[i][j+1]==0){\\n            s.insert(i*m+(j+1));\\n            ans++;\\n        }\\n        if(j-1>=0 && g[i][j-1]==0){\\n            s.insert(i*m+(j-1));\\n            ans++;\\n        }\\n        g[i][j]=c;\\n        ans+=dfs(i+1, j);\\n        ans+=dfs(i-1, j);\\n        ans+=dfs(i, j+1);\\n        ans+=dfs(i, j-1);\\n        return ans; // total number of walls needed to block this connected component\\n    }\\n    \\n    int containVirus(vector<vector<int>>& grid) {\\n        g=grid, n=g.size(), m=g[0].size(), ans=0;\\n        while(true){\\n            c=2, mx=0;\\n            for(int i=0; i<n; i++){\\n                for(int j=0; j<m; j++){\\n                    if(g[i][j]==1){\\n                        s.clear();\\n                        int walls=dfs(i, j);\\n                        if(mx<s.size()){\\n                            mx=s.size();\\n                            w=walls;\\n                            r=c;\\n                        }\\n                        c++;\\n                    }\\n                }\\n            }\\n            if(mx==0)\\n                break;\\n            ans+=w;\\n            for(int i=0; i<n; i++){\\n                for(int j=0; j<m; j++){\\n                    if(g[i][j]==r)\\n                        g[i][j]=1e9;\\n                    else if(g[i][j]>1 && g[i][j]!=1e9){\\n                        g[i][j]=1;\\n                        if(i+1<n && !g[i+1][j]) g[i+1][j]=1;\\n                        if(i-1>=0 && !g[i-1][j]) g[i-1][j]=1;\\n                        if(j+1<m && !g[i][j+1]) g[i][j+1]=1;\\n                        if(j-1>=0 && !g[i][j-1]) g[i][j-1]=1;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int> > g;\\n    int n, m, c, mx, w, r, ans, itr;\\n    unordered_set<int> s;\\n    \\n    int dfs(int i, int j){\\n        if(i<0 || i>=n || j<0 || j>=m || g[i][j]!=1)\\n            return 0;\\n        int ans=0;\\n        if(i+1<n && g[i+1][j]==0){\\n            s.insert((i+1)*m+j);\\n            ans++;\\n        }\\n        if(i-1>=0 && g[i-1][j]==0){\\n            s.insert((i-1)*m+j);\\n            ans++;\\n        }\\n        if(j+1<m && g[i][j+1]==0){\\n            s.insert(i*m+(j+1));\\n            ans++;\\n        }\\n        if(j-1>=0 && g[i][j-1]==0){\\n            s.insert(i*m+(j-1));\\n            ans++;\\n        }\\n        g[i][j]=c;\\n        ans+=dfs(i+1, j);\\n        ans+=dfs(i-1, j);\\n        ans+=dfs(i, j+1);\\n        ans+=dfs(i, j-1);\\n        return ans; // total number of walls needed to block this connected component\\n    }\\n    \\n    int containVirus(vector<vector<int>>& grid) {\\n        g=grid, n=g.size(), m=g[0].size(), ans=0;\\n        while(true){\\n            c=2, mx=0;\\n            for(int i=0; i<n; i++){\\n                for(int j=0; j<m; j++){\\n                    if(g[i][j]==1){\\n                        s.clear();\\n                        int walls=dfs(i, j);\\n                        if(mx<s.size()){\\n                            mx=s.size();\\n                            w=walls;\\n                            r=c;\\n                        }\\n                        c++;\\n                    }\\n                }\\n            }\\n            if(mx==0)\\n                break;\\n            ans+=w;\\n            for(int i=0; i<n; i++){\\n                for(int j=0; j<m; j++){\\n                    if(g[i][j]==r)\\n                        g[i][j]=1e9;\\n                    else if(g[i][j]>1 && g[i][j]!=1e9){\\n                        g[i][j]=1;\\n                        if(i+1<n && !g[i+1][j]) g[i+1][j]=1;\\n                        if(i-1>=0 && !g[i-1][j]) g[i-1][j]=1;\\n                        if(j+1<m && !g[i][j+1]) g[i][j+1]=1;\\n                        if(j-1>=0 && !g[i][j-1]) g[i][j-1]=1;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219582,
                "title": "python-bfs-simulation-solution-nothing-convoluted",
                "content": "I guess one should attempt Leetcode 695. Max Area of Island before doing this problem. Just speeds up everything tremendously, no complicated algorithms or concepts at all\\nAlso, I highly recommend padding the boundary with 2, as a rigid wall is equivalent to a quarantined region\\n```\\nclass Solution:\\n    # Use 2 to pad the boundary\\n    # Cycle start\\n    # Use BFS to identify connected components\\n    # In the process also calculate the perimeter\\n    # Important point to note: we choose group with largest number of 0 cells neighboring the 1s, not the perimeter\\n    # Choose region with the affected neighbours to install wall (perimeter), mark the region to be 2\\n    # Then for all infected regions, expand the boundary for 1\\n    # Repeat the cycle until all regions become 2 (len(points) <= 1)\\n    \\n    def containVirus(self, isInfected: List[List[int]]) -> int:\\n        # Boundary padding\\n        self.grid = [[2]*(len(isInfected[0])+2)]\\n        for row in isInfected:\\n            self.grid.append([2] + row + [2])\\n        self.grid.append([2]*(len(isInfected[0])+2))\\n        \\n        # reused Leetcode 695. Max Area of Island code\\n        # BFS from each point with 1 \\n        m, n = len(self.grid), len(self.grid[0])\\n        neig = [[1,0],[-1,0],[0,1],[0,-1]]\\n        wall = 0\\n        finished = False\\n        \\n        while not finished:\\n            island_perimeters = []\\n            affected_cells = []\\n            points = []\\n            visited = set()\\n            for i in range(1,m-1):\\n                for j in range(1,n-1):\\n                    if self.grid[i][j] == 1 and (i,j) not in visited:\\n                        # BFS\\n                        points.append(set())\\n                        affected_cells.append(set())\\n                        dq = deque()\\n                        dq.append((i,j))\\n                        visited.add((i,j))\\n                        perimeter = 0\\n                        while dq:\\n                            x = dq.popleft()\\n                            for k in range(4):\\n                                xn, yn = x[0]+neig[k][0], x[1]+neig[k][1]\\n                                if (xn,yn) not in visited and self.grid[xn][yn]==1:\\n                                    dq.append((xn,yn))\\n                                    visited.add((xn,yn))\\n                                elif self.grid[xn][yn] == 0:\\n                                    perimeter += 1\\n                                    affected_cells[-1].add((xn,yn))\\n                            points[-1].add(x)\\n                        island_perimeters.append(perimeter)\\n            if not points:\\n                return wall\\n            max_affected, max_group = 0, 0\\n            for i, cells in enumerate(affected_cells):\\n                if len(cells) > max_affected:\\n                    max_group =  i\\n                    max_affected = len(cells)\\n            wall += island_perimeters[max_group]\\n                                       \\n            # quarantined regions\\n            for point in points[max_group]:\\n                self.grid[point[0]][point[1]] = 2\\n            # evolve the infection\\n            if len(points) == 1:\\n                finished = True\\n            else:\\n                for j, point_set in enumerate(points):\\n                    if j != max_group:\\n                        for point in point_set:\\n                            for k in range(4):\\n                                xn, yn = point[0]+neig[k][0], point[1]+neig[k][1]\\n                                if self.grid[xn][yn] == 0:\\n                                    self.grid[xn][yn] = 1\\n        return wall\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # Use 2 to pad the boundary\\n    # Cycle start\\n    # Use BFS to identify connected components\\n    # In the process also calculate the perimeter\\n    # Important point to note: we choose group with largest number of 0 cells neighboring the 1s, not the perimeter\\n    # Choose region with the affected neighbours to install wall (perimeter), mark the region to be 2\\n    # Then for all infected regions, expand the boundary for 1\\n    # Repeat the cycle until all regions become 2 (len(points) <= 1)\\n    \\n    def containVirus(self, isInfected: List[List[int]]) -> int:\\n        # Boundary padding\\n        self.grid = [[2]*(len(isInfected[0])+2)]\\n        for row in isInfected:\\n            self.grid.append([2] + row + [2])\\n        self.grid.append([2]*(len(isInfected[0])+2))\\n        \\n        # reused Leetcode 695. Max Area of Island code\\n        # BFS from each point with 1 \\n        m, n = len(self.grid), len(self.grid[0])\\n        neig = [[1,0],[-1,0],[0,1],[0,-1]]\\n        wall = 0\\n        finished = False\\n        \\n        while not finished:\\n            island_perimeters = []\\n            affected_cells = []\\n            points = []\\n            visited = set()\\n            for i in range(1,m-1):\\n                for j in range(1,n-1):\\n                    if self.grid[i][j] == 1 and (i,j) not in visited:\\n                        # BFS\\n                        points.append(set())\\n                        affected_cells.append(set())\\n                        dq = deque()\\n                        dq.append((i,j))\\n                        visited.add((i,j))\\n                        perimeter = 0\\n                        while dq:\\n                            x = dq.popleft()\\n                            for k in range(4):\\n                                xn, yn = x[0]+neig[k][0], x[1]+neig[k][1]\\n                                if (xn,yn) not in visited and self.grid[xn][yn]==1:\\n                                    dq.append((xn,yn))\\n                                    visited.add((xn,yn))\\n                                elif self.grid[xn][yn] == 0:\\n                                    perimeter += 1\\n                                    affected_cells[-1].add((xn,yn))\\n                            points[-1].add(x)\\n                        island_perimeters.append(perimeter)\\n            if not points:\\n                return wall\\n            max_affected, max_group = 0, 0\\n            for i, cells in enumerate(affected_cells):\\n                if len(cells) > max_affected:\\n                    max_group =  i\\n                    max_affected = len(cells)\\n            wall += island_perimeters[max_group]\\n                                       \\n            # quarantined regions\\n            for point in points[max_group]:\\n                self.grid[point[0]][point[1]] = 2\\n            # evolve the infection\\n            if len(points) == 1:\\n                finished = True\\n            else:\\n                for j, point_set in enumerate(points):\\n                    if j != max_group:\\n                        for point in point_set:\\n                            for k in range(4):\\n                                xn, yn = point[0]+neig[k][0], point[1]+neig[k][1]\\n                                if self.grid[xn][yn] == 0:\\n                                    self.grid[xn][yn] = 1\\n        return wall\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2184734,
                "title": "easy-to-understand-dfs",
                "content": "```\\nclass Group{\\n    public:\\n    \\n    set<pair<int,int>>ne;\\n    set<pair<int,int>>affected;\\n    \\n    int w;\\n    \\n    Group(){\\n        w = 0;\\n    }\\n};\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    bool isValid(int i,int j,int n,int m){\\n        return i>=0 && j>=0 && i<n && j<m;\\n    }\\n    \\n    int dir[4][2]={\\n        {1,0},\\n        {0,1},\\n        {-1,0},\\n        {0,-1}\\n    };\\n    \\n\\n    void dfs(vector<vector<int>>&in,int i,int j,int n,int m,vector<vector<bool>>&vis,Group *g){\\n        \\n        if(in[i][j]==-1) return;\\n        \\n        if(in[i][j] ==0 ){\\n            g->w++;\\n            g->ne.insert({i,j});\\n            return;\\n        }\\n        \\n        vis[i][j] = 1;\\n        \\n        if(in[i][j] == 1)\\n            g->affected.insert({i,j});\\n           \\n        \\n        for(int k=0;k<4;k++){\\n            \\n            int x = i+dir[k][0], y = j+dir[k][1];\\n            \\n            if(isValid(x,y,n,m) && !vis[x][y]) \\n                dfs(in,i+dir[k][0],j+dir[k][1],n,m,vis,g);\\n        }\\n        \\n    }\\n    \\n    \\n    int containVirus(vector<vector<int>>& in) {\\n        \\n        int n = in.size(),m = in[0].size(),ans = 0;\\n        \\n        \\n        while(1){\\n            \\n            vector<Group *>v;\\n            \\n            vector<vector<bool>>visited(n,vector<bool>(m,0));\\n            \\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<m;j++){\\n                    if(!visited[i][j] && in[i][j]==1){\\n                        \\n                        Group *g  = new Group();\\n                        dfs(in,i,j,n,m,visited,g);\\n                        \\n                        v.push_back(g);\\n                    }\\n                        \\n                }\\n            }\\n            \\n            \\n            if(v.size()==0) break;\\n            \\n            \\n            int mx = 0,index = 0;\\n            \\n            for(int i=0;i<v.size();i++){\\n                if(v[i]->ne.size()>mx){\\n                    mx = v[i]->ne.size();\\n                    index = i;\\n                }\\n            }\\n            \\n            Group * x = v[index];\\n            \\n            ans+=(x->w);\\n            \\n            \\n            for(auto itr:x->affected){\\n                in[itr.first][itr.second] = -1;\\n            }\\n            \\n            \\n            for(int i=0;i<v.size();i++){\\n                if(i==index) continue;\\n                x = v[i];\\n                for(auto itr:x->ne){\\n                    in[itr.first][itr.second] = 1;\\n                }\\n                \\n            }\\n            \\n \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Group{\\n    public:\\n    \\n    set<pair<int,int>>ne;\\n    set<pair<int,int>>affected;\\n    \\n    int w;\\n    \\n    Group(){\\n        w = 0;\\n    }\\n};\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    bool isValid(int i,int j,int n,int m){\\n        return i>=0 && j>=0 && i<n && j<m;\\n    }\\n    \\n    int dir[4][2]={\\n        {1,0},\\n        {0,1},\\n        {-1,0},\\n        {0,-1}\\n    };\\n    \\n\\n    void dfs(vector<vector<int>>&in,int i,int j,int n,int m,vector<vector<bool>>&vis,Group *g){\\n        \\n        if(in[i][j]==-1) return;\\n        \\n        if(in[i][j] ==0 ){\\n            g->w++;\\n            g->ne.insert({i,j});\\n            return;\\n        }\\n        \\n        vis[i][j] = 1;\\n        \\n        if(in[i][j] == 1)\\n            g->affected.insert({i,j});\\n           \\n        \\n        for(int k=0;k<4;k++){\\n            \\n            int x = i+dir[k][0], y = j+dir[k][1];\\n            \\n            if(isValid(x,y,n,m) && !vis[x][y]) \\n                dfs(in,i+dir[k][0],j+dir[k][1],n,m,vis,g);\\n        }\\n        \\n    }\\n    \\n    \\n    int containVirus(vector<vector<int>>& in) {\\n        \\n        int n = in.size(),m = in[0].size(),ans = 0;\\n        \\n        \\n        while(1){\\n            \\n            vector<Group *>v;\\n            \\n            vector<vector<bool>>visited(n,vector<bool>(m,0));\\n            \\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<m;j++){\\n                    if(!visited[i][j] && in[i][j]==1){\\n                        \\n                        Group *g  = new Group();\\n                        dfs(in,i,j,n,m,visited,g);\\n                        \\n                        v.push_back(g);\\n                    }\\n                        \\n                }\\n            }\\n            \\n            \\n            if(v.size()==0) break;\\n            \\n            \\n            int mx = 0,index = 0;\\n            \\n            for(int i=0;i<v.size();i++){\\n                if(v[i]->ne.size()>mx){\\n                    mx = v[i]->ne.size();\\n                    index = i;\\n                }\\n            }\\n            \\n            Group * x = v[index];\\n            \\n            ans+=(x->w);\\n            \\n            \\n            for(auto itr:x->affected){\\n                in[itr.first][itr.second] = -1;\\n            }\\n            \\n            \\n            for(int i=0;i<v.size();i++){\\n                if(i==index) continue;\\n                x = v[i];\\n                for(auto itr:x->ne){\\n                    in[itr.first][itr.second] = 1;\\n                }\\n                \\n            }\\n            \\n \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 619818,
                "title": "java-clean",
                "content": "Very short Java\\n\\n1. we calculate score of island(means how many island it can infect next), border of island\\n2. pick the max score island and delete it, add border of that island to result\\n3. extend infection to next day, all remaining island expand.\\n\\n```\\nclass Solution {\\n    int m, n, id;\\n    int[][] dirs = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n    public int containVirus(int[][] grid) {\\n        m = grid.length; n = grid[0].length; \\n        int res = 0;\\n        while (true) {\\n            id = 0;\\n            Set<Integer> visited = new HashSet<>();\\n            Map<Integer, Set<Integer>> islands = new HashMap<>(), scores = new HashMap<>();\\n            Map<Integer, Integer> walls = new HashMap<>();\\n            for (int i = 0; i < m; i++) \\n                for (int j = 0; j < n; j++)\\n                    if (grid[i][j] == 1 && !visited.contains(i * n + j))\\n                        dfs(i, j, visited, grid, islands, scores, walls, id++);\\n            if (islands.isEmpty()) break;\\n            int maxVirus = 0;\\n            for (int i = 0; i < id; i++)\\n                if (scores.getOrDefault(maxVirus, new HashSet<>()).size() < scores.getOrDefault(i, new HashSet<>()).size())\\n                    maxVirus = i;\\n            res += walls.getOrDefault(maxVirus, 0);\\n            for (int i = 0; i < islands.size(); i++)\\n                for (int island : islands.get(i)) {\\n                    int x = island / n, y = island % n;\\n                    if (i == maxVirus) grid[x][y] = -1; \\n                    else {                             \\n                        for (int [] dir : dirs) {\\n                            int nx = x + dir[0], ny = y + dir[1];\\n                            if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == 0) \\n                                grid[nx][ny] = 1;\\n                        }\\n                    }                           \\n                }\\n        }\\n        return res;\\n    }\\n    \\n    private void dfs(int i, int j, Set<Integer> visited, int[][] grid, Map<Integer, Set<Integer>> islands, Map<Integer, Set<Integer>> scores, Map<Integer, Integer> walls, int id) {\\n        if (!visited.add(i * n + j)) return;\\n        islands.computeIfAbsent(id, value -> new HashSet<>()).add(i * n + j);\\n        for (int[] dir : dirs) {\\n            int x = i + dir[0], y = j + dir[1];\\n            if (x < 0 || x >= m || y < 0 || y >= n) continue;\\n            if (grid[x][y] == 1) dfs(x, y, visited, grid, islands, scores, walls, id);\\n            if (grid[x][y] == 0) {\\n                scores.computeIfAbsent(id, value -> new HashSet<>()).add(x * n + y);\\n                walls.put(id, walls.getOrDefault(id, 0) + 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int m, n, id;\\n    int[][] dirs = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n    public int containVirus(int[][] grid) {\\n        m = grid.length; n = grid[0].length; \\n        int res = 0;\\n        while (true) {\\n            id = 0;\\n            Set<Integer> visited = new HashSet<>();\\n            Map<Integer, Set<Integer>> islands = new HashMap<>(), scores = new HashMap<>();\\n            Map<Integer, Integer> walls = new HashMap<>();\\n            for (int i = 0; i < m; i++) \\n                for (int j = 0; j < n; j++)\\n                    if (grid[i][j] == 1 && !visited.contains(i * n + j))\\n                        dfs(i, j, visited, grid, islands, scores, walls, id++);\\n            if (islands.isEmpty()) break;\\n            int maxVirus = 0;\\n            for (int i = 0; i < id; i++)\\n                if (scores.getOrDefault(maxVirus, new HashSet<>()).size() < scores.getOrDefault(i, new HashSet<>()).size())\\n                    maxVirus = i;\\n            res += walls.getOrDefault(maxVirus, 0);\\n            for (int i = 0; i < islands.size(); i++)\\n                for (int island : islands.get(i)) {\\n                    int x = island / n, y = island % n;\\n                    if (i == maxVirus) grid[x][y] = -1; \\n                    else {                             \\n                        for (int [] dir : dirs) {\\n                            int nx = x + dir[0], ny = y + dir[1];\\n                            if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == 0) \\n                                grid[nx][ny] = 1;\\n                        }\\n                    }                           \\n                }\\n        }\\n        return res;\\n    }\\n    \\n    private void dfs(int i, int j, Set<Integer> visited, int[][] grid, Map<Integer, Set<Integer>> islands, Map<Integer, Set<Integer>> scores, Map<Integer, Integer> walls, int id) {\\n        if (!visited.add(i * n + j)) return;\\n        islands.computeIfAbsent(id, value -> new HashSet<>()).add(i * n + j);\\n        for (int[] dir : dirs) {\\n            int x = i + dir[0], y = j + dir[1];\\n            if (x < 0 || x >= m || y < 0 || y >= n) continue;\\n            if (grid[x][y] == 1) dfs(x, y, visited, grid, islands, scores, walls, id);\\n            if (grid[x][y] == 0) {\\n                scores.computeIfAbsent(id, value -> new HashSet<>()).add(x * n + y);\\n                walls.put(id, walls.getOrDefault(id, 0) + 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 125644,
                "title": "longest-solution-i-ve-ever-written-on-leetcode-1a-love-u-all",
                "content": "```\\nclass Pos {\\n    int x;\\n    int y;\\n\\n    Pos(int x, int y) {\\n        this.x = x;\\n        this.y = y;\\n    }\\n}\\n\\nclass Solution {\\n    private static final int MAX_N = 50;\\n    private static final int dr[] = {-1, 1, 0, 0};\\n    private static final int dc[] = {0, 0, -1, 1};\\n\\n    private static boolean[][] vis = new boolean[MAX_N][MAX_N];\\n\\n    private int numVirus(int[][] grid, int x, int y) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n\\n        int res = 0;\\n        vis[x][y] = true;\\n        for (int i = 0; i < 4; ++i) {\\n            int nx = x + dr[i];\\n            int ny = y + dc[i];\\n            if (nx >= 0 && nx < row && ny >= 0 && ny < col ) {\\n                if (grid[nx][ny] == 0) {\\n                    ++res;\\n                    grid[nx][ny] = 3;\\n                } else if (grid[nx][ny] == 1 && !vis[nx][ny]) {\\n                    res += numVirus(grid, nx, ny);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    private Pos maxRegion(int[][] grid) {\\n        int x = -1;\\n        int y = -1;\\n        int cnt = 0;\\n\\n        for (int i = 0; i < MAX_N; ++i) {\\n            for (int j = 0; j < MAX_N; ++j) {\\n                vis[i][j] = false;\\n            }\\n        }\\n\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        for (int i = 0; i < row; ++i) {\\n            for (int j = 0; j < col; ++j) {\\n                if (grid[i][j] == 1 && !vis[i][j]) {\\n                    int num = numVirus(grid, i, j);\\n                    if (num > cnt) {\\n                        x = i;\\n                        y = j;\\n                        cnt = num;\\n                    }\\n                    for (int a = 0; a < row; ++a) {\\n                        for (int b = 0; b < col; ++b) {\\n                            if (grid[a][b] == 3) {\\n                                grid[a][b] = 0;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new Pos(x, y);\\n    }\\n\\n    private int buildWalls(int[][] grid, int x, int y) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n\\n        grid[x][y] = 2;\\n        int res = 0;\\n        for (int i = 0; i < 4; ++i) {\\n            int nx = x + dr[i];\\n            int ny = y + dc[i];\\n            if (nx >= 0 && nx < row && ny >= 0 && ny < col) {\\n                if (grid[nx][ny] == 0) {\\n                    ++res;\\n                } else if (grid[nx][ny] == 1) {\\n                    res += buildWalls(grid, nx, ny);\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    private void expand(int[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        for (int i = 0; i < row; ++i) {\\n            for (int j = 0; j < col; ++j) {\\n                if (grid[i][j] == 1) {\\n                    for (int d = 0; d < 4; ++d) {\\n                        int ni = i + dr[d];\\n                        int nj = j + dc[d];\\n                        if (ni >= 0 && ni < row && nj >= 0 && nj < col && grid[ni][nj] == 0) {\\n                            grid[ni][nj] = 3;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < row; ++i) {\\n            for (int j = 0; j < col; ++j) {\\n                if (grid[i][j] == 3) {\\n                    grid[i][j] = 1;\\n                }\\n            } \\n        }\\n    }\\n\\n    public int containVirus(int[][] grid) {\\n        int res = 0;\\n        Pos pos = maxRegion(grid);\\n\\n        while (pos.x != -1 && pos.y != -1) {\\n            res += buildWalls(grid, pos.x, pos.y);\\n            expand(grid);\\n            pos = maxRegion(grid);\\n        }\\n\\n        return res;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Pos {\\n    int x;\\n    int y;\\n\\n    Pos(int x, int y) {\\n        this.x = x;\\n        this.y = y;\\n    }\\n}\\n\\nclass Solution {\\n    private static final int MAX_N = 50;\\n    private static final int dr[] = {-1, 1, 0, 0};\\n    private static final int dc[] = {0, 0, -1, 1};\\n\\n    private static boolean[][] vis = new boolean[MAX_N][MAX_N];\\n\\n    private int numVirus(int[][] grid, int x, int y) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n\\n        int res = 0;\\n        vis[x][y] = true;\\n        for (int i = 0; i < 4; ++i) {\\n            int nx = x + dr[i];\\n            int ny = y + dc[i];\\n            if (nx >= 0 && nx < row && ny >= 0 && ny < col ) {\\n                if (grid[nx][ny] == 0) {\\n                    ++res;\\n                    grid[nx][ny] = 3;\\n                } else if (grid[nx][ny] == 1 && !vis[nx][ny]) {\\n                    res += numVirus(grid, nx, ny);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    private Pos maxRegion(int[][] grid) {\\n        int x = -1;\\n        int y = -1;\\n        int cnt = 0;\\n\\n        for (int i = 0; i < MAX_N; ++i) {\\n            for (int j = 0; j < MAX_N; ++j) {\\n                vis[i][j] = false;\\n            }\\n        }\\n\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        for (int i = 0; i < row; ++i) {\\n            for (int j = 0; j < col; ++j) {\\n                if (grid[i][j] == 1 && !vis[i][j]) {\\n                    int num = numVirus(grid, i, j);\\n                    if (num > cnt) {\\n                        x = i;\\n                        y = j;\\n                        cnt = num;\\n                    }\\n                    for (int a = 0; a < row; ++a) {\\n                        for (int b = 0; b < col; ++b) {\\n                            if (grid[a][b] == 3) {\\n                                grid[a][b] = 0;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new Pos(x, y);\\n    }\\n\\n    private int buildWalls(int[][] grid, int x, int y) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n\\n        grid[x][y] = 2;\\n        int res = 0;\\n        for (int i = 0; i < 4; ++i) {\\n            int nx = x + dr[i];\\n            int ny = y + dc[i];\\n            if (nx >= 0 && nx < row && ny >= 0 && ny < col) {\\n                if (grid[nx][ny] == 0) {\\n                    ++res;\\n                } else if (grid[nx][ny] == 1) {\\n                    res += buildWalls(grid, nx, ny);\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    private void expand(int[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        for (int i = 0; i < row; ++i) {\\n            for (int j = 0; j < col; ++j) {\\n                if (grid[i][j] == 1) {\\n                    for (int d = 0; d < 4; ++d) {\\n                        int ni = i + dr[d];\\n                        int nj = j + dc[d];\\n                        if (ni >= 0 && ni < row && nj >= 0 && nj < col && grid[ni][nj] == 0) {\\n                            grid[ni][nj] = 3;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < row; ++i) {\\n            for (int j = 0; j < col; ++j) {\\n                if (grid[i][j] == 3) {\\n                    grid[i][j] = 1;\\n                }\\n            } \\n        }\\n    }\\n\\n    public int containVirus(int[][] grid) {\\n        int res = 0;\\n        Pos pos = maxRegion(grid);\\n\\n        while (pos.x != -1 && pos.y != -1) {\\n            res += buildWalls(grid, pos.x, pos.y);\\n            expand(grid);\\n            pos = maxRegion(grid);\\n        }\\n\\n        return res;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 110175,
                "title": "concise-solution-no-index-tracking-detailed-explanation-with-illustration",
                "content": "The idea is to find all infected regions and identify the most dangerous one (i.e., infecting most uninfected cells), then update all regions by the rule and repeat this process until no more infected regions found.\\n\\nTo accomplish this algorithm, it is useful to define structure `Region` as\\n```cpp\\n    struct Region {\\n        unordered_set<int*> inner, border;\\n        size_t perimeter = 0;\\n    };\\n```\\nwhere \\n* `inner`: reference to values of inner infected cells \\n* `border`: reference to values of *uninfected* cells surrounding inner cells\\n* `perimeter`: count of edges between `inner` and `border`\\n![0_1513704710688_Region.jpg](/assets/uploads/files/1513704708943-region.jpg) \\n**NOTE:** Define `inner` and `border` as value references instead of tracking `(i,j)` indices to save space and avoid copies.\\n\\n**Algorithm Outline:**\\n1. For each day, scan entire grid to find all infected regions `regions` and the max count of `border`. This could be accomplished by either DFS or BFS.\\n1. if `regions` is empty, quit; \\notherwise,\\n   * for the most dangerous region `r`, set `r.inner` to value `-1` (i.e., quarantined);\\n   * for other regions `r`, set `r.border` to value `1` (i.e., infected), and accumulate `r.perimeter` (i.e., build new walls)  \\n\\n```cpp        \\n    int containVirus(vector<vector<int>>& grid) \\n    {                            \\n        for (size_t walls = 0, maxborder = 0; true; )\\n        {       \\n            // find all infected regions\\n            auto regions = findRegions(grid, maxborder);             \\n            if (regions.empty()) return walls; // no more infection\\n            \\n            // update all regions\\n            for (auto& r : regions)\\n                if (r.border.size() != maxborder) { // infected\\n                    for (auto& cell : r.inner) *cell = 1;\\n                    for (auto& cell : r.border) *cell = 1;\\n                }\\n                else walls += r.perimeter; // quarantined\\n        }        \\n    }    \\n```\\nDFS routine to explore a region starting at cell `(i,j)`:\\n```cpp    \\n    void dfs(vector<vector<int>>& grid, int i, int j, Region& r) \\n    {\\n        // no need to explore if already quarantined\\n        if (min(i,j)<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]<0) return;\\n        \\n        if (grid[i][j]) { // infected\\n            r.inner.insert(&(grid[i][j]=-1));\\n            dfs(grid,i+1,j,r), dfs(grid,i,j+1,r), dfs(grid,i-1,j,r), dfs(grid,i,j-1,r);\\n        } // border found\\n        else r.border.insert(&grid[i][j]), ++r.perimeter;      \\n    };    \\n```\\nFind all infected regions and get max border:\\n```cpp    \\n    vector<Region> findRegions(vector<vector<int>>& grid, size_t& maxborder) \\n    {\\n        vector<Region> regions; maxborder = 0;\\n        for (int i = 0; i < grid.size(); ++i)\\n            for (int j = 0; j < grid[0].size(); ++j)\\n                if (grid[i][j] == 1) {\\n                    Region r; dfs(grid, i, j, r);\\n                    regions.push_back(r);       \\n                    maxborder = max(maxborder, r.border.size());\\n                }     \\n        return regions;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```cpp\\n    struct Region {\\n        unordered_set<int*> inner, border;\\n        size_t perimeter = 0;\\n    };\\n```\n```cpp        \\n    int containVirus(vector<vector<int>>& grid) \\n    {                            \\n        for (size_t walls = 0, maxborder = 0; true; )\\n        {       \\n            // find all infected regions\\n            auto regions = findRegions(grid, maxborder);             \\n            if (regions.empty()) return walls; // no more infection\\n            \\n            // update all regions\\n            for (auto& r : regions)\\n                if (r.border.size() != maxborder) { // infected\\n                    for (auto& cell : r.inner) *cell = 1;\\n                    for (auto& cell : r.border) *cell = 1;\\n                }\\n                else walls += r.perimeter; // quarantined\\n        }        \\n    }    \\n```\n```cpp    \\n    void dfs(vector<vector<int>>& grid, int i, int j, Region& r) \\n    {\\n        // no need to explore if already quarantined\\n        if (min(i,j)<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]<0) return;\\n        \\n        if (grid[i][j]) { // infected\\n            r.inner.insert(&(grid[i][j]=-1));\\n            dfs(grid,i+1,j,r), dfs(grid,i,j+1,r), dfs(grid,i-1,j,r), dfs(grid,i,j-1,r);\\n        } // border found\\n        else r.border.insert(&grid[i][j]), ++r.perimeter;      \\n    };    \\n```\n```cpp    \\n    vector<Region> findRegions(vector<vector<int>>& grid, size_t& maxborder) \\n    {\\n        vector<Region> regions; maxborder = 0;\\n        for (int i = 0; i < grid.size(); ++i)\\n            for (int j = 0; j < grid[0].size(); ++j)\\n                if (grid[i][j] == 1) {\\n                    Region r; dfs(grid, i, j, r);\\n                    regions.push_back(r);       \\n                    maxborder = max(maxborder, r.border.size());\\n                }     \\n        return regions;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 110173,
                "title": "clean-python-solution",
                "content": "```\\nclass Solution(object):\\n    def containVirus(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid: return None\\n        N,M=len(grid),len(grid[0])\\n        \\n        def around(r,c,t=None):\\n            # all cells 1-step away from (r,c)\\n            # optionally, if t!=None, target value must be t\\n            for d in (-1,1):\\n                for (rr,cc) in ((r+d,c), (r,c+d)):\\n                    if 0<=rr<N and 0<=cc<M and (t == None or grid[rr][cc]==t):\\n                        yield (rr,cc)\\n        \\n        def regions():\\n            regs=[]\\n            seen=set()\\n            for r in xrange(N):\\n                for c in xrange(M):\\n                    if grid[r][c]==1 and (r,c) not in seen:\\n                        # this is a new region. do a BFS to find all contiguous ones\\n                        reg=set()\\n                        front, newfront=[(r,c)], []\\n                        while front:\\n                            reg.update(front)\\n                            while front:\\n                                (r,c) = front.pop()\\n                                for (rr,cc) in around(r,c,1):\\n                                    if (rr, cc) not in reg:\\n                                        newfront.append((rr,cc))\\n                                        reg.add((rr, cc))\\n                            front,newfront=newfront,front\\n                        regs.append(reg)\\n                        seen.update(reg)\\n            return regs\\n        \\n        def reg_boundary(reg):\\n            # cells that would become infected by cells in reg\\n            bound=set()\\n            for (r,c) in reg:\\n                for (rr,cc) in around(r,c,0):\\n                    bound.add((rr,cc))\\n\\n            return bound\\n        \\n        def reg_walls(reg,bound):\\n            # number of walls that would need to be built to contain reg\\n            walls=0\\n            for (r,c) in bound:\\n                for (rr,cc) in around(r,c,1):\\n                    if (rr,cc) in reg:\\n                        walls+=1    \\n            return walls\\n        gwalls=0\\n        \\n        while True:\\n            \\n            regs=regions()\\n            \\n            if not regs: break\\n            reg = max(regs, key=lambda reg: len(reg_boundary(reg)))\\n            walls=reg_walls(reg, reg_boundary(reg))\\n            gwalls+=walls\\n            \\n            # neutralize region\\n            for (r,c) in reg:\\n                grid[r][c]=2\\n\\n            # compute next grid iteration after new infections\\n            infected=set()\\n            for r in xrange(N):\\n                for c in xrange(M):\\n                    if grid[r][c]==1:\\n                        for (rr, cc) in around(r, c, 0):\\n                            infected.add((rr, cc))\\n\\n            for r, c in infected:\\n                grid[r][c]=1\\n\\n            if not infected: break\\n\\n        return gwalls\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def containVirus(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid: return None\\n        N,M=len(grid),len(grid[0])\\n        \\n        def around(r,c,t=None):\\n            # all cells 1-step away from (r,c)\\n            # optionally, if t!=None, target value must be t\\n            for d in (-1,1):\\n                for (rr,cc) in ((r+d,c), (r,c+d)):\\n                    if 0<=rr<N and 0<=cc<M and (t == None or grid[rr][cc]==t):\\n                        yield (rr,cc)\\n        \\n        def regions():\\n            regs=[]\\n            seen=set()\\n            for r in xrange(N):\\n                for c in xrange(M):\\n                    if grid[r][c]==1 and (r,c) not in seen:\\n                        # this is a new region. do a BFS to find all contiguous ones\\n                        reg=set()\\n                        front, newfront=[(r,c)], []\\n                        while front:\\n                            reg.update(front)\\n                            while front:\\n                                (r,c) = front.pop()\\n                                for (rr,cc) in around(r,c,1):\\n                                    if (rr, cc) not in reg:\\n                                        newfront.append((rr,cc))\\n                                        reg.add((rr, cc))\\n                            front,newfront=newfront,front\\n                        regs.append(reg)\\n                        seen.update(reg)\\n            return regs\\n        \\n        def reg_boundary(reg):\\n            # cells that would become infected by cells in reg\\n            bound=set()\\n            for (r,c) in reg:\\n                for (rr,cc) in around(r,c,0):\\n                    bound.add((rr,cc))\\n\\n            return bound\\n        \\n        def reg_walls(reg,bound):\\n            # number of walls that would need to be built to contain reg\\n            walls=0\\n            for (r,c) in bound:\\n                for (rr,cc) in around(r,c,1):\\n                    if (rr,cc) in reg:\\n                        walls+=1    \\n            return walls\\n        gwalls=0\\n        \\n        while True:\\n            \\n            regs=regions()\\n            \\n            if not regs: break\\n            reg = max(regs, key=lambda reg: len(reg_boundary(reg)))\\n            walls=reg_walls(reg, reg_boundary(reg))\\n            gwalls+=walls\\n            \\n            # neutralize region\\n            for (r,c) in reg:\\n                grid[r][c]=2\\n\\n            # compute next grid iteration after new infections\\n            infected=set()\\n            for r in xrange(N):\\n                for c in xrange(M):\\n                    if grid[r][c]==1:\\n                        for (rr, cc) in around(r, c, 0):\\n                            infected.add((rr, cc))\\n\\n            for r, c in infected:\\n                grid[r][c]=1\\n\\n            if not infected: break\\n\\n        return gwalls\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655936,
                "title": "one-of-the-hardest-questions-i-ever-solved-dfs-30-ms-java",
                "content": "# Code\\n```\\nclass AreaInfo {\\n    Set<List<Integer>> nodes;\\n    int id;\\n    int numExposed;\\n\\n    public AreaInfo(int id) {\\n        this.nodes = new HashSet<>();\\n        this.id = id;\\n        this.numExposed = 0;\\n    }\\n}\\n\\nclass Solution {\\n    private final int HEALTHY = 0, UNHEALTHY = 1, FOUND = 2, CONTAMINATED = 3;\\n    private final List<Integer[]> directions = List.of(\\n            new Integer[] {0, 1}, new Integer[] {0, -1},\\n            new Integer[] {1, 0}, new Integer[] {-1, 0}\\n    );\\n    private Set<List<Integer>> exposed = new HashSet<>();\\n\\n    public int containVirus(int[][] isInfected) {\\n        Map<Integer, AreaInfo> infectedAreas = getInfectedAreas(isInfected);\\n        int currentArea = infectedAreas.values().stream().sorted((o1, o2) -> o2.numExposed - o1.numExposed)\\n                .map(i-> i.id).limit(1).findFirst().orElse(-1);\\n        int numWalls = 0;\\n        while (currentArea != -1) {\\n            AreaInfo areaInfo = infectedAreas.get(currentArea);\\n            List<Integer> start = areaInfo.nodes.stream().limit(1).collect(Collectors.toList()).get(0);\\n            numWalls += surroundWithWalls(start.get(0), start.get(1), isInfected, 0);\\n            int finalCurrentArea = currentArea;\\n            infectedAreas.values().forEach(area-> {\\n                if(area.id != finalCurrentArea) {\\n                    Set<List<Integer>> initialNodes = new HashSet<>(area.nodes);\\n                    initialNodes.forEach(node -> {\\n                        expandVirus(node.get(0), node.get(1), isInfected, area, 0);\\n                    });\\n                }\\n            });\\n            infectedAreas = getInfectedAreas(isInfected);\\n            currentArea = infectedAreas.values().stream().sorted((o1, o2) -> o2.numExposed - o1.numExposed)\\n                    .map(i-> i.id).limit(1).findFirst().orElse(-1);\\n        }\\n        return numWalls;\\n    }\\n\\n    private void expandVirus(Integer i, Integer j, int[][] isInfected, AreaInfo areaInfo, int depth) {\\n        if(isInfected[i][j] == CONTAMINATED) return;\\n        areaInfo.nodes.add(List.of(i, j));\\n        isInfected[i][j] = 1;\\n        for (Integer[] direction: directions) {\\n            int x = direction[0] + i, y = direction[1] + j;\\n            if(depth == 0 && isValid(x, y , isInfected) && isInfected[x][y] == HEALTHY)\\n                expandVirus(x, y, isInfected, areaInfo, depth + 1);\\n        }\\n    }\\n\\n    private int surroundWithWalls(int i, int j, int[][] isInfected, int walls) {\\n        if(isInfected[i][j] == CONTAMINATED) return 0;\\n        isInfected[i][j] = CONTAMINATED;\\n        for (Integer[] direction: directions) {\\n            int x = direction[0] + i, y = direction[1] + j;\\n            if(isValid(x, y , isInfected) && isInfected[x][y] == HEALTHY) {\\n                walls++;\\n            }\\n        }\\n        for (Integer[] direction: directions) {\\n            int x = direction[0] + i, y = direction[1] + j;\\n            if(isValid(x, y , isInfected) && isInfected[x][y] == FOUND)\\n                walls = surroundWithWalls(x, y, isInfected, walls);\\n        }\\n        return walls;\\n    }\\n\\n    private Map<Integer, AreaInfo> getInfectedAreas(int[][] isInfected) {\\n        Map<Integer, AreaInfo> infectedAreas = new HashMap<>();\\n        int areaId =  0;\\n        for (int i = 0; i < isInfected.length; i++) {\\n            for (int j = 0; j < isInfected[0].length; j++) {\\n                if(isInfected[i][j] == 1) {\\n                    AreaInfo areaInfo = new AreaInfo(areaId);\\n                    exposed = new HashSet<>();\\n                    searchInfected(i, j, isInfected, areaInfo);\\n                    infectedAreas.put(areaInfo.id, areaInfo);\\n                    areaId++;\\n                }\\n            }\\n        }\\n        return infectedAreas;\\n    }\\n\\n    private void searchInfected(int i, int j, int[][] isInfected, AreaInfo areaInfo) {\\n        if(isInfected[i][j] == CONTAMINATED) return;\\n        areaInfo.nodes.add(List.of(i, j));\\n        isInfected[i][j] = FOUND;\\n        for (Integer[] direction: directions) {\\n            int x = direction[0] + i, y = direction[1] + j;\\n            if(isValid(x, y , isInfected) && !exposed.contains(List.of(x, y)) && isInfected[x][y] == HEALTHY) {\\n                areaInfo.numExposed++;\\n                exposed.add(List.of(x, y));\\n            }\\n        }\\n        for (Integer[] direction: directions) {\\n            int x = direction[0] + i, y = direction[1] + j;\\n            if(isValid(x, y , isInfected) && isInfected[x][y] == UNHEALTHY)\\n                searchInfected(x, y, isInfected, areaInfo);\\n        }\\n    }\\n\\n    private boolean isValid(int i, int j, int[][] isInfected) {\\n        return i >= 0 && i < isInfected.length && j >= 0 && j < isInfected[0].length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\nclass AreaInfo {\\n    Set<List<Integer>> nodes;\\n    int id;\\n    int numExposed;\\n\\n    public AreaInfo(int id) {\\n        this.nodes = new HashSet<>();\\n        this.id = id;\\n        this.numExposed = 0;\\n    }\\n}\\n\\nclass Solution {\\n    private final int HEALTHY = 0, UNHEALTHY = 1, FOUND = 2, CONTAMINATED = 3;\\n    private final List<Integer[]> directions = List.of(\\n            new Integer[] {0, 1}, new Integer[] {0, -1},\\n            new Integer[] {1, 0}, new Integer[] {-1, 0}\\n    );\\n    private Set<List<Integer>> exposed = new HashSet<>();\\n\\n    public int containVirus(int[][] isInfected) {\\n        Map<Integer, AreaInfo> infectedAreas = getInfectedAreas(isInfected);\\n        int currentArea = infectedAreas.values().stream().sorted((o1, o2) -> o2.numExposed - o1.numExposed)\\n                .map(i-> i.id).limit(1).findFirst().orElse(-1);\\n        int numWalls = 0;\\n        while (currentArea != -1) {\\n            AreaInfo areaInfo = infectedAreas.get(currentArea);\\n            List<Integer> start = areaInfo.nodes.stream().limit(1).collect(Collectors.toList()).get(0);\\n            numWalls += surroundWithWalls(start.get(0), start.get(1), isInfected, 0);\\n            int finalCurrentArea = currentArea;\\n            infectedAreas.values().forEach(area-> {\\n                if(area.id != finalCurrentArea) {\\n                    Set<List<Integer>> initialNodes = new HashSet<>(area.nodes);\\n                    initialNodes.forEach(node -> {\\n                        expandVirus(node.get(0), node.get(1), isInfected, area, 0);\\n                    });\\n                }\\n            });\\n            infectedAreas = getInfectedAreas(isInfected);\\n            currentArea = infectedAreas.values().stream().sorted((o1, o2) -> o2.numExposed - o1.numExposed)\\n                    .map(i-> i.id).limit(1).findFirst().orElse(-1);\\n        }\\n        return numWalls;\\n    }\\n\\n    private void expandVirus(Integer i, Integer j, int[][] isInfected, AreaInfo areaInfo, int depth) {\\n        if(isInfected[i][j] == CONTAMINATED) return;\\n        areaInfo.nodes.add(List.of(i, j));\\n        isInfected[i][j] = 1;\\n        for (Integer[] direction: directions) {\\n            int x = direction[0] + i, y = direction[1] + j;\\n            if(depth == 0 && isValid(x, y , isInfected) && isInfected[x][y] == HEALTHY)\\n                expandVirus(x, y, isInfected, areaInfo, depth + 1);\\n        }\\n    }\\n\\n    private int surroundWithWalls(int i, int j, int[][] isInfected, int walls) {\\n        if(isInfected[i][j] == CONTAMINATED) return 0;\\n        isInfected[i][j] = CONTAMINATED;\\n        for (Integer[] direction: directions) {\\n            int x = direction[0] + i, y = direction[1] + j;\\n            if(isValid(x, y , isInfected) && isInfected[x][y] == HEALTHY) {\\n                walls++;\\n            }\\n        }\\n        for (Integer[] direction: directions) {\\n            int x = direction[0] + i, y = direction[1] + j;\\n            if(isValid(x, y , isInfected) && isInfected[x][y] == FOUND)\\n                walls = surroundWithWalls(x, y, isInfected, walls);\\n        }\\n        return walls;\\n    }\\n\\n    private Map<Integer, AreaInfo> getInfectedAreas(int[][] isInfected) {\\n        Map<Integer, AreaInfo> infectedAreas = new HashMap<>();\\n        int areaId =  0;\\n        for (int i = 0; i < isInfected.length; i++) {\\n            for (int j = 0; j < isInfected[0].length; j++) {\\n                if(isInfected[i][j] == 1) {\\n                    AreaInfo areaInfo = new AreaInfo(areaId);\\n                    exposed = new HashSet<>();\\n                    searchInfected(i, j, isInfected, areaInfo);\\n                    infectedAreas.put(areaInfo.id, areaInfo);\\n                    areaId++;\\n                }\\n            }\\n        }\\n        return infectedAreas;\\n    }\\n\\n    private void searchInfected(int i, int j, int[][] isInfected, AreaInfo areaInfo) {\\n        if(isInfected[i][j] == CONTAMINATED) return;\\n        areaInfo.nodes.add(List.of(i, j));\\n        isInfected[i][j] = FOUND;\\n        for (Integer[] direction: directions) {\\n            int x = direction[0] + i, y = direction[1] + j;\\n            if(isValid(x, y , isInfected) && !exposed.contains(List.of(x, y)) && isInfected[x][y] == HEALTHY) {\\n                areaInfo.numExposed++;\\n                exposed.add(List.of(x, y));\\n            }\\n        }\\n        for (Integer[] direction: directions) {\\n            int x = direction[0] + i, y = direction[1] + j;\\n            if(isValid(x, y , isInfected) && isInfected[x][y] == UNHEALTHY)\\n                searchInfected(x, y, isInfected, areaInfo);\\n        }\\n    }\\n\\n    private boolean isValid(int i, int j, int[][] isInfected) {\\n        return i >= 0 && i < isInfected.length && j >= 0 && j < isInfected[0].length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449961,
                "title": "solution",
                "content": "```C++ []\\nint mp[2652], *zp[2652], zc[2652], step, mk;\\n\\nint dfs(int *p) {\\n    *p = 2;\\n    int res = 0;\\n    for (int *nb : {p-step, p-1, p+1, p+step}) {\\n        int v = *nb;\\n        if (v == mk || v > 1) continue;\\n        if (v <= 0) *nb = mk, ++res; else res += dfs(nb);\\n    }\\n    return res;\\n}\\nint dfs2(int *p) {\\n    *p = 1000;\\n    int res = 0;\\n    for (int *nb : {p-step, p-1, p+1, p+step}) {\\n        int v = *nb;\\n        if (v == 2) res += dfs2(nb); else if (v <= 0) ++res, *nb = 0;\\n    }\\n    return res;\\n}\\nvoid dfs3(int *p) {\\n    *p = 1;\\n    for (int *nb : {p-step, p-1, p+1, p+step}) {\\n        int v = *nb;\\n        if (v == 2) dfs3(nb); else if (v <= 0) *nb = 1;\\n    }\\n}\\nclass Solution {\\npublic:\\n    int containVirus(vector<vector<int>>& isInfected) {\\n        step = isInfected[0].size() + 1; mk = 0;\\n        {\\n            int *p = mp+step;\\n            fill(mp, p, 1000);\\n            for (const auto &r : isInfected) {\\n                for (int x : r) *p++ = x;\\n                *p++ = 1000;\\n            }\\n            fill(p, p+step, 1000);\\n        }\\n        int *lo = mp+step, *hi = lo + step*isInfected.size(), res = 0;\\n        while(1) {\\n            int nb = 0;\\n            for (int *p = lo; p != hi; ++p) if (*p == 1) zp[nb] = p, --mk, zc[nb++] = dfs(p);\\n            if (nb == 0) break;\\n\\n            int best = 0;\\n            for (int i = 1; i < nb; ++i) if (zc[i] > zc[best]) best = i;\\n            if (!zc[best]) break;\\n            res += dfs2(zp[best]);\\n\\n            for (int *p = lo; p != hi; ++p) if (*p == 2) dfs3(p);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n```Python3 []\\nimport math\\n\\nclass Solution:\\n    def containVirus(self, isInfected: List[List[int]]) -> int:\\n\\n        def traverse_infected(r,c):\\n\\n            q = [(r,c)]\\n            infected_cells = set(q)\\n            perimeter = 0\\n            bordering_cells = set()\\n\\n            while len(q) > 0:\\n                next_iter = []\\n\\n                for r,c in q:\\n                    neighbors = [(r+1,c),(r-1,c),(r,c+1),(r,c-1)]\\n                    for adj_r,adj_c in neighbors:\\n                        if m > adj_r >= 0 and n > adj_c >= 0:\\n                            if isInfected[adj_r][adj_c] == 1:\\n                                if (adj_r,adj_c) not in infected_cells:\\n                                    infected_cells.add((adj_r,adj_c))\\n                                    next_iter.append((adj_r,adj_c))\\n                            elif isInfected[adj_r][adj_c] == 0:\\n                                perimeter += 1\\n                                bordering_cells.add((adj_r,adj_c))\\n                q = next_iter\\n            \\n            return infected_cells,bordering_cells,perimeter\\n        \\n        m,n = len(isInfected),len(isInfected[0])\\n\\n        walls = 0\\n        while 1:\\n            all_infected_cells = set()\\n\\n            most_threatening = (0, None)\\n\\n            regions_this_iter = []\\n            i = 0\\n            for r in range(m):\\n                for c in range(n):\\n                    if isInfected[r][c] == 1 and (r,c) not in all_infected_cells:\\n                        infected_region,region_borders,perimeter = traverse_infected(r,c)\\n\\n                        regions_this_iter.append((infected_region,region_borders,perimeter))\\n\\n                        if len(region_borders) > most_threatening[0]:\\n                            most_threatening = (len(region_borders), i)\\n                        \\n                        all_infected_cells.update(infected_region)\\n                        i += 1\\n            \\n            if most_threatening[0] != 0:\\n                walls += regions_this_iter[most_threatening[1]][2]\\n                for r,c in regions_this_iter[most_threatening[1]][0]:\\n                    isInfected[r][c] = 2\\n                \\n                for i in range(len(regions_this_iter)):\\n                    if i != most_threatening[1]:\\n                        for r,c in regions_this_iter[i][1]:\\n                            isInfected[r][c] = 1\\n            else:\\n                break\\n        return walls\\n```\\n\\n```Java []\\nclass Solution {\\n    class Region {\\n        Set<Integer> infected = new HashSet<>();\\n        Set<Integer> unInfected = new HashSet<>();\\n        int walls = 0;\\n    } \\n    public int containVirus(int[][] isInfected) {\\n        int ans = 0;\\n        int re = isInfected.length;\\n        int ce = isInfected[0].length;\\n\\n        while (true) {\\n            List<Region> holder = new ArrayList<>();\\n            boolean[][] v = new boolean[re][ce];\\n            for (int r = 0; r < re; r++) {\\n                for (int c = 0; c < ce; c++) {\\n                    if (isInfected[r][c] == 1 && !v[r][c]) {\\n                        Region region = new Region();\\n                        getRegion(isInfected, region, re, ce, v, r, c);\\n                        holder.add(region);\\n                    }\\n                }\\n            }\\n            int indexOfMaxUnInfected = 0;\\n            int sizeOfMaxUnInfected = 0;\\n            for (int i = 0; i < holder.size(); i++) {\\n                Region region = holder.get(i);\\n\\n                if (region.unInfected.size() > sizeOfMaxUnInfected) {\\n                    sizeOfMaxUnInfected = region.unInfected.size();\\n                    indexOfMaxUnInfected = i;\\n                }\\n            }\\n            if (holder.size() == 0) {\\n                break;\\n            }\\n            Set<Integer> maxSet = holder.get(indexOfMaxUnInfected).infected;\\n            for (int rowCol : maxSet) {\\n                int r = rowCol / ce;\\n                int c = rowCol % ce;\\n                isInfected[r][c] = 2;\\n            }\\n            ans += holder.get(indexOfMaxUnInfected).walls;\\n            for (int i = 0; i < holder.size(); i++) {\\n                \\n                if (i == indexOfMaxUnInfected) {\\n                    continue;\\n                }\\n                Region region = holder.get(i);\\n                Set<Integer> unInfected = region.unInfected;\\n\\n                for (int rowCol : unInfected) {\\n                    int r = rowCol / ce;\\n                    int c = rowCol % ce;\\n                    isInfected[r][c] = 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    private void getRegion(int[][] isInfected, Region region, int re, int ce, \\n        boolean[][] v, int r, int c) {\\n        if (r < 0 || c < 0 || r == re || c == ce || isInfected[r][c] == 2) {\\n            return;\\n        }\\n        if (isInfected[r][c] == 1) {\\n            if (v[r][c]) {\\n                return;\\n            }\\n            region.infected.add(r * ce + c);\\n        }\\n        if (isInfected[r][c] == 0) {\\n            region.unInfected.add(r * ce + c);\\n            region.walls++;\\n            return;\\n        }\\n        v[r][c] = true;\\n        for (int[] dir : dirs) {\\n            int nr = r + dir[0];\\n            int nc = c + dir[1];\\n            getRegion(isInfected, region, re, ce, v, nr, nc);\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nint mp[2652], *zp[2652], zc[2652], step, mk;\\n\\nint dfs(int *p) {\\n    *p = 2;\\n    int res = 0;\\n    for (int *nb : {p-step, p-1, p+1, p+step}) {\\n        int v = *nb;\\n        if (v == mk || v > 1) continue;\\n        if (v <= 0) *nb = mk, ++res; else res += dfs(nb);\\n    }\\n    return res;\\n}\\nint dfs2(int *p) {\\n    *p = 1000;\\n    int res = 0;\\n    for (int *nb : {p-step, p-1, p+1, p+step}) {\\n        int v = *nb;\\n        if (v == 2) res += dfs2(nb); else if (v <= 0) ++res, *nb = 0;\\n    }\\n    return res;\\n}\\nvoid dfs3(int *p) {\\n    *p = 1;\\n    for (int *nb : {p-step, p-1, p+1, p+step}) {\\n        int v = *nb;\\n        if (v == 2) dfs3(nb); else if (v <= 0) *nb = 1;\\n    }\\n}\\nclass Solution {\\npublic:\\n    int containVirus(vector<vector<int>>& isInfected) {\\n        step = isInfected[0].size() + 1; mk = 0;\\n        {\\n            int *p = mp+step;\\n            fill(mp, p, 1000);\\n            for (const auto &r : isInfected) {\\n                for (int x : r) *p++ = x;\\n                *p++ = 1000;\\n            }\\n            fill(p, p+step, 1000);\\n        }\\n        int *lo = mp+step, *hi = lo + step*isInfected.size(), res = 0;\\n        while(1) {\\n            int nb = 0;\\n            for (int *p = lo; p != hi; ++p) if (*p == 1) zp[nb] = p, --mk, zc[nb++] = dfs(p);\\n            if (nb == 0) break;\\n\\n            int best = 0;\\n            for (int i = 1; i < nb; ++i) if (zc[i] > zc[best]) best = i;\\n            if (!zc[best]) break;\\n            res += dfs2(zp[best]);\\n\\n            for (int *p = lo; p != hi; ++p) if (*p == 2) dfs3(p);\\n        }\\n        return res;\\n    }\\n};\\n```\n```Python3 []\\nimport math\\n\\nclass Solution:\\n    def containVirus(self, isInfected: List[List[int]]) -> int:\\n\\n        def traverse_infected(r,c):\\n\\n            q = [(r,c)]\\n            infected_cells = set(q)\\n            perimeter = 0\\n            bordering_cells = set()\\n\\n            while len(q) > 0:\\n                next_iter = []\\n\\n                for r,c in q:\\n                    neighbors = [(r+1,c),(r-1,c),(r,c+1),(r,c-1)]\\n                    for adj_r,adj_c in neighbors:\\n                        if m > adj_r >= 0 and n > adj_c >= 0:\\n                            if isInfected[adj_r][adj_c] == 1:\\n                                if (adj_r,adj_c) not in infected_cells:\\n                                    infected_cells.add((adj_r,adj_c))\\n                                    next_iter.append((adj_r,adj_c))\\n                            elif isInfected[adj_r][adj_c] == 0:\\n                                perimeter += 1\\n                                bordering_cells.add((adj_r,adj_c))\\n                q = next_iter\\n            \\n            return infected_cells,bordering_cells,perimeter\\n        \\n        m,n = len(isInfected),len(isInfected[0])\\n\\n        walls = 0\\n        while 1:\\n            all_infected_cells = set()\\n\\n            most_threatening = (0, None)\\n\\n            regions_this_iter = []\\n            i = 0\\n            for r in range(m):\\n                for c in range(n):\\n                    if isInfected[r][c] == 1 and (r,c) not in all_infected_cells:\\n                        infected_region,region_borders,perimeter = traverse_infected(r,c)\\n\\n                        regions_this_iter.append((infected_region,region_borders,perimeter))\\n\\n                        if len(region_borders) > most_threatening[0]:\\n                            most_threatening = (len(region_borders), i)\\n                        \\n                        all_infected_cells.update(infected_region)\\n                        i += 1\\n            \\n            if most_threatening[0] != 0:\\n                walls += regions_this_iter[most_threatening[1]][2]\\n                for r,c in regions_this_iter[most_threatening[1]][0]:\\n                    isInfected[r][c] = 2\\n                \\n                for i in range(len(regions_this_iter)):\\n                    if i != most_threatening[1]:\\n                        for r,c in regions_this_iter[i][1]:\\n                            isInfected[r][c] = 1\\n            else:\\n                break\\n        return walls\\n```\n```Java []\\nclass Solution {\\n    class Region {\\n        Set<Integer> infected = new HashSet<>();\\n        Set<Integer> unInfected = new HashSet<>();\\n        int walls = 0;\\n    } \\n    public int containVirus(int[][] isInfected) {\\n        int ans = 0;\\n        int re = isInfected.length;\\n        int ce = isInfected[0].length;\\n\\n        while (true) {\\n            List<Region> holder = new ArrayList<>();\\n            boolean[][] v = new boolean[re][ce];\\n            for (int r = 0; r < re; r++) {\\n                for (int c = 0; c < ce; c++) {\\n                    if (isInfected[r][c] == 1 && !v[r][c]) {\\n                        Region region = new Region();\\n                        getRegion(isInfected, region, re, ce, v, r, c);\\n                        holder.add(region);\\n                    }\\n                }\\n            }\\n            int indexOfMaxUnInfected = 0;\\n            int sizeOfMaxUnInfected = 0;\\n            for (int i = 0; i < holder.size(); i++) {\\n                Region region = holder.get(i);\\n\\n                if (region.unInfected.size() > sizeOfMaxUnInfected) {\\n                    sizeOfMaxUnInfected = region.unInfected.size();\\n                    indexOfMaxUnInfected = i;\\n                }\\n            }\\n            if (holder.size() == 0) {\\n                break;\\n            }\\n            Set<Integer> maxSet = holder.get(indexOfMaxUnInfected).infected;\\n            for (int rowCol : maxSet) {\\n                int r = rowCol / ce;\\n                int c = rowCol % ce;\\n                isInfected[r][c] = 2;\\n            }\\n            ans += holder.get(indexOfMaxUnInfected).walls;\\n            for (int i = 0; i < holder.size(); i++) {\\n                \\n                if (i == indexOfMaxUnInfected) {\\n                    continue;\\n                }\\n                Region region = holder.get(i);\\n                Set<Integer> unInfected = region.unInfected;\\n\\n                for (int rowCol : unInfected) {\\n                    int r = rowCol / ce;\\n                    int c = rowCol % ce;\\n                    isInfected[r][c] = 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    private void getRegion(int[][] isInfected, Region region, int re, int ce, \\n        boolean[][] v, int r, int c) {\\n        if (r < 0 || c < 0 || r == re || c == ce || isInfected[r][c] == 2) {\\n            return;\\n        }\\n        if (isInfected[r][c] == 1) {\\n            if (v[r][c]) {\\n                return;\\n            }\\n            region.infected.add(r * ce + c);\\n        }\\n        if (isInfected[r][c] == 0) {\\n            region.unInfected.add(r * ce + c);\\n            region.walls++;\\n            return;\\n        }\\n        v[r][c] = true;\\n        for (int[] dir : dirs) {\\n            int nr = r + dir[0];\\n            int nc = c + dir[1];\\n            getRegion(isInfected, region, re, ce, v, nr, nc);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260761,
                "title": "bfs-a-step-by-step-guide-with-comments",
                "content": "# Template for BFS\\n```\\n1. bfs = deque() # to store the node first meets the requirements\\n2. while bfs: # there are still nodes to visit\\n3.     node = bfs.popleft()\\n4.     # Mark as visited\\n5.     # Expand the node in all four directions\\n6.     if not visited and within the valid range:\\n7.         # update and do something\\n```\\n# Breaking Down the Solution\"\\n\\n```\\n# 1. BFS\\n#    Get to-spread/to-put-wall area. \\n#    Get nums of walls for every area. \\n\\n# Situation 1:\\n# 2. none infected areas\\n    if not neighbors:\\n        break\\n\\n# Situation 2:            \\n# 3. Keep going\\n#    calculate the largest area:\\n# 4. update the ans\\n\\n# 5. mark as processed and modify the unprocessed\\n            \\n# 6. mark the spreaded\\n            \\n```\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def containVirus(self, isInfected: List[List[int]]) -> int:\\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        m, n = len(isInfected), len(isInfected[0])\\n        ans = 0\\n        while True:\\n            # 1. BFS\\n            #   neighbors stores every to-spread/to-put-wall area. \\n            #   firewalls stores the countings for every area. \\n            neighbors, firewalls = list(), list()\\n            for i in range(m):\\n                for j in range(n):\\n                    if isInfected[i][j] == 1:\\n                        # detect the infected area \\n                        q = deque([(i, j)])\\n                        # index of this area\\n                        idx = len(neighbors) + 1\\n                        # record all cells in this to-spread/to-put-wall area\\n                        neighbor = set()\\n                        # count walls needed\\n                        firewall = 0\\n                        # mark as visited\\n                        isInfected[i][j] = -idx\\n\\n                        while q:\\n                            x, y = q.popleft()\\n                            for d in range(4):\\n                                # detect around\\n                                nx, ny = x + dirs[d][0], y + dirs[d][1]\\n                                # ensure within the matrix\\n                                if 0 <= nx < m and 0 <= ny < n:\\n                                    if isInfected[nx][ny] == 1:\\n                                        # update infected area\\n                                        q.append((nx, ny))\\n                                        # mark as visited\\n                                        isInfected[nx][ny] = -idx\\n                                    elif isInfected[nx][ny] == 0:\\n                                        # update counting and neighbor\\n                                        firewall += 1\\n                                        neighbor.add((nx, ny))\\n\\n                        \\n                        \\n                        # update neighbors and firewalls\\n                        neighbors.append(neighbor)\\n                        firewalls.append(firewall)\\n\\n            # 2. none infected areas\\n            if not neighbors:\\n                break\\n            \\n            # 3. calculate the largest area:\\n            idx = 0\\n            for i in range(1, len(neighbors)):\\n                if len(neighbors[i]) > len(neighbors[idx]):\\n                    idx = i\\n                    \\n            # 4. update the ans\\n            ans += firewalls[idx]\\n\\n            # if only 1 area in total, this is the final answer\\n            if len(neighbors) == 1:\\n                # return ans\\n                break \\n            \\n\\n            # 5. mark as processed and modify the unprocessed\\n            for i in range(m):\\n                for j in range(n):\\n                    if isInfected[i][j] < 0:\\n                        # unprocess\\n                        if isInfected[i][j] != - (idx + 1):\\n                            isInfected[i][j] = 1\\n                        else:\\n                            isInfected[i][j] = 2\\n            # 6. mark the spreaded\\n            for i, neighbor in enumerate(neighbors):\\n                if i != idx:\\n                    # spread\\n                    for x, y in neighbor:\\n                        isInfected[x][y] = 1\\n            \\n            \\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\n1. bfs = deque() # to store the node first meets the requirements\\n2. while bfs: # there are still nodes to visit\\n3.     node = bfs.popleft()\\n4.     # Mark as visited\\n5.     # Expand the node in all four directions\\n6.     if not visited and within the valid range:\\n7.         # update and do something\\n```\n```\\n# 1. BFS\\n#    Get to-spread/to-put-wall area. \\n#    Get nums of walls for every area. \\n\\n# Situation 1:\\n# 2. none infected areas\\n    if not neighbors:\\n        break\\n\\n# Situation 2:            \\n# 3. Keep going\\n#    calculate the largest area:\\n# 4. update the ans\\n\\n# 5. mark as processed and modify the unprocessed\\n            \\n# 6. mark the spreaded\\n            \\n```\n```\\nclass Solution:\\n    def containVirus(self, isInfected: List[List[int]]) -> int:\\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        m, n = len(isInfected), len(isInfected[0])\\n        ans = 0\\n        while True:\\n            # 1. BFS\\n            #   neighbors stores every to-spread/to-put-wall area. \\n            #   firewalls stores the countings for every area. \\n            neighbors, firewalls = list(), list()\\n            for i in range(m):\\n                for j in range(n):\\n                    if isInfected[i][j] == 1:\\n                        # detect the infected area \\n                        q = deque([(i, j)])\\n                        # index of this area\\n                        idx = len(neighbors) + 1\\n                        # record all cells in this to-spread/to-put-wall area\\n                        neighbor = set()\\n                        # count walls needed\\n                        firewall = 0\\n                        # mark as visited\\n                        isInfected[i][j] = -idx\\n\\n                        while q:\\n                            x, y = q.popleft()\\n                            for d in range(4):\\n                                # detect around\\n                                nx, ny = x + dirs[d][0], y + dirs[d][1]\\n                                # ensure within the matrix\\n                                if 0 <= nx < m and 0 <= ny < n:\\n                                    if isInfected[nx][ny] == 1:\\n                                        # update infected area\\n                                        q.append((nx, ny))\\n                                        # mark as visited\\n                                        isInfected[nx][ny] = -idx\\n                                    elif isInfected[nx][ny] == 0:\\n                                        # update counting and neighbor\\n                                        firewall += 1\\n                                        neighbor.add((nx, ny))\\n\\n                        \\n                        \\n                        # update neighbors and firewalls\\n                        neighbors.append(neighbor)\\n                        firewalls.append(firewall)\\n\\n            # 2. none infected areas\\n            if not neighbors:\\n                break\\n            \\n            # 3. calculate the largest area:\\n            idx = 0\\n            for i in range(1, len(neighbors)):\\n                if len(neighbors[i]) > len(neighbors[idx]):\\n                    idx = i\\n                    \\n            # 4. update the ans\\n            ans += firewalls[idx]\\n\\n            # if only 1 area in total, this is the final answer\\n            if len(neighbors) == 1:\\n                # return ans\\n                break \\n            \\n\\n            # 5. mark as processed and modify the unprocessed\\n            for i in range(m):\\n                for j in range(n):\\n                    if isInfected[i][j] < 0:\\n                        # unprocess\\n                        if isInfected[i][j] != - (idx + 1):\\n                            isInfected[i][j] = 1\\n                        else:\\n                            isInfected[i][j] = 2\\n            # 6. mark the spreaded\\n            for i, neighbor in enumerate(neighbors):\\n                if i != idx:\\n                    # spread\\n                    for x, y in neighbor:\\n                        isInfected[x][y] = 1\\n            \\n            \\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2537505,
                "title": "python3-brute-force",
                "content": "\\n```\\nclass Solution:\\n    def containVirus(self, isInfected: List[List[int]]) -> int:\\n        m, n = len(isInfected), len(isInfected[0])\\n        ans = 0 \\n        while True: \\n            regions = []\\n            fronts = []\\n            walls = []\\n            seen = set()\\n            for i in range(m): \\n                for j in range(n): \\n                    if isInfected[i][j] == 1 and (i, j) not in seen: \\n                        seen.add((i, j))\\n                        stack = [(i, j)]\\n                        regions.append([(i, j)])\\n                        fronts.append(set())\\n                        walls.append(0)\\n                        while stack: \\n                            r, c = stack.pop()\\n                            for rr, cc in (r-1, c), (r, c-1), (r, c+1), (r+1, c): \\n                                if 0 <= rr < m and 0 <= cc < n: \\n                                    if isInfected[rr][cc] == 1 and (rr, cc) not in seen: \\n                                        seen.add((rr, cc))\\n                                        stack.append((rr, cc))\\n                                        regions[-1].append((rr, cc))\\n                                    elif isInfected[rr][cc] == 0: \\n                                        fronts[-1].add((rr, cc))\\n                                        walls[-1] += 1\\n            if not regions: break\\n            idx = fronts.index(max(fronts, key = len))\\n            ans += walls[idx]\\n            for i, region in enumerate(regions): \\n                if i == idx: \\n                    for r, c in region: isInfected[r][c] = -1 # mark as quaranteened \\n                else: \\n                    for r, c in fronts[i]: isInfected[r][c] = 1 # mark as infected \\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containVirus(self, isInfected: List[List[int]]) -> int:\\n        m, n = len(isInfected), len(isInfected[0])\\n        ans = 0 \\n        while True: \\n            regions = []\\n            fronts = []\\n            walls = []\\n            seen = set()\\n            for i in range(m): \\n                for j in range(n): \\n                    if isInfected[i][j] == 1 and (i, j) not in seen: \\n                        seen.add((i, j))\\n                        stack = [(i, j)]\\n                        regions.append([(i, j)])\\n                        fronts.append(set())\\n                        walls.append(0)\\n                        while stack: \\n                            r, c = stack.pop()\\n                            for rr, cc in (r-1, c), (r, c-1), (r, c+1), (r+1, c): \\n                                if 0 <= rr < m and 0 <= cc < n: \\n                                    if isInfected[rr][cc] == 1 and (rr, cc) not in seen: \\n                                        seen.add((rr, cc))\\n                                        stack.append((rr, cc))\\n                                        regions[-1].append((rr, cc))\\n                                    elif isInfected[rr][cc] == 0: \\n                                        fronts[-1].add((rr, cc))\\n                                        walls[-1] += 1\\n            if not regions: break\\n            idx = fronts.index(max(fronts, key = len))\\n            ans += walls[idx]\\n            for i, region in enumerate(regions): \\n                if i == idx: \\n                    for r, c in region: isInfected[r][c] = -1 # mark as quaranteened \\n                else: \\n                    for r, c in fronts[i]: isInfected[r][c] = 1 # mark as infected \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298540,
                "title": "dfs-with-marker-15-ms",
                "content": "This problem is just a simulation.\\nThe whole process is:\\n1. Find which group of virus would infect most uninfected area. If no group of virus could infect more uninfected area, break.\\n2. Deactive that group of virus.\\n3. Let the rest group of virus spread.\\nWe could use dfs to implement 1, 2, and 3. \\nThe trickest part is to determine how many uninfected grid would a group of virus would infect in this round. \\nIn case: \\n1 0 \\n1 1\\n0 might be visited three times, however it should only appears once. If we simply use a \"visited\" array to memorize, the following case might happpen:\\n1 0 1 0\\n1 0 1 0\\nDfs on the left group of virus would make the two 0 been \"visited\", but the right group needs to count these two 0 in its \"infected number\". If we do a memset for the whole \"visited\" array after each dfs call, it might cause TLE. \\n\\nSo we could use a marker to mark the \"visited\" array. Each dfs call would use a different marker, and the dfs would stop only when current marker == marker that marked the visited array.\\n\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\nint visited[51][51];\\nint fx[] = {1, 0, -1, 0};\\nint fy[] = {0, 1, 0, -1};\\nclass Solution {\\npublic:\\n\\tint m, n;\\n\\tbool valid(int i, int j) {\\n\\t\\treturn i >= 0 && j >= 0 && i < m && j < n;\\n\\t}\\n\\n\\tint dfs(int i, int j, vector<vector<int>>& isInfected, int marker) {\\n\\t\\tif (!valid(i, j) || visited[i][j] || isInfected[i][j] != 1) return 0;\\n\\t\\tvisited[i][j] = 1;\\n\\t\\tint cnt = 0;\\n\\t\\tfor (int k = 0; k < 4; k++) {\\n\\t\\t\\tint x = i + fx[k], y = j + fy[k];\\n\\t\\t\\tif (!valid(x, y)) continue;\\n\\t\\t\\tif (isInfected[x][y] == 0 && visited[x][y] != marker) {\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\tvisited[x][y] = marker;\\n\\t\\t\\t} else if (isInfected[x][y] == 1) {\\n\\t\\t\\t\\tcnt += dfs(x, y, isInfected, marker);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn cnt;\\n\\t}\\n\\n\\tint buildWall(int i, int j, vector<vector<int>>& isInfected) {\\n\\t\\tint cnt = 0;\\n\\t\\tisInfected[i][j] = -1;\\n\\t\\tfor (int k = 0; k < 4; k++) {\\n\\t\\t\\tint x = i + fx[k], y = j + fy[k];\\n\\t\\t\\tif (!valid(x, y)) continue;\\n\\t\\t\\tif (isInfected[x][y] == 1) {\\n\\t\\t\\t\\tcnt += buildWall(x, y, isInfected);\\n\\t\\t\\t} else if (isInfected[x][y] == 0) {\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn cnt;\\n\\t}\\n\\n\\tvoid spread(vector<vector<int>>& isInfected) {\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tif (isInfected[i][j] != 0) continue;\\n\\t\\t\\t\\tbool infect = 0;\\n\\t\\t\\t\\tfor (int k = 0; k < 4; k++) {\\n\\t\\t\\t\\t\\tint x = i + fx[k], y = j + fy[k];\\n\\t\\t\\t\\t\\tif (valid(x, y) && isInfected[x][y] == 1) {\\n\\t\\t\\t\\t\\t\\tinfect = true;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (infect) isInfected[i][j] = -2;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tif (isInfected[i][j] == -2) {\\n\\t\\t\\t\\t\\tisInfected[i][j] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvoid print(vector<vector<int>>& isInfected) {\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tcout << isInfected[i][j] << \" \";\\n\\t\\t\\t}\\n\\t\\t\\tcout << endl;\\n\\t\\t}\\n\\t\\t\\t\\n\\t}\\n    int containVirus(vector<vector<int>>& isInfected) {\\n\\t\\tint res = 0;\\n\\t\\tm = isInfected.size();\\n\\t\\tn = isInfected[0].size();\\n        while (true) {\\n\\t\\t\\tmemset(visited, 0, sizeof(visited));\\n\\t\\t\\tint cx = -1, cy = -1, cv = 0;\\n\\t\\t\\tint hasGood = 0, marker = 4;\\n\\t\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\t\\tfor (int j = 0; j < n; j++) {\\n                    hasGood = hasGood || isInfected[i][j] == 0;\\n                    if (isInfected[i][j] != 1) continue;\\n\\t\\t\\t\\t\\tint tmp = dfs(i, j, isInfected, marker++);\\n\\t\\t\\t\\t\\tif (tmp > cv) {\\n\\t\\t\\t\\t\\t\\tcv = tmp;\\n\\t\\t\\t\\t\\t\\tcx = i;\\n\\t\\t\\t\\t\\t\\tcy = j;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (!cv || !hasGood) break;\\n\\t\\t\\tres += buildWall(cx, cy, isInfected);\\n\\t\\t\\tspread(isInfected);\\n\\t\\t}\\n\\t\\treturn res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Simulation"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\nint visited[51][51];\\nint fx[] = {1, 0, -1, 0};\\nint fy[] = {0, 1, 0, -1};\\nclass Solution {\\npublic:\\n\\tint m, n;\\n\\tbool valid(int i, int j) {\\n\\t\\treturn i >= 0 && j >= 0 && i < m && j < n;\\n\\t}\\n\\n\\tint dfs(int i, int j, vector<vector<int>>& isInfected, int marker) {\\n\\t\\tif (!valid(i, j) || visited[i][j] || isInfected[i][j] != 1) return 0;\\n\\t\\tvisited[i][j] = 1;\\n\\t\\tint cnt = 0;\\n\\t\\tfor (int k = 0; k < 4; k++) {\\n\\t\\t\\tint x = i + fx[k], y = j + fy[k];\\n\\t\\t\\tif (!valid(x, y)) continue;\\n\\t\\t\\tif (isInfected[x][y] == 0 && visited[x][y] != marker) {\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\tvisited[x][y] = marker;\\n\\t\\t\\t} else if (isInfected[x][y] == 1) {\\n\\t\\t\\t\\tcnt += dfs(x, y, isInfected, marker);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn cnt;\\n\\t}\\n\\n\\tint buildWall(int i, int j, vector<vector<int>>& isInfected) {\\n\\t\\tint cnt = 0;\\n\\t\\tisInfected[i][j] = -1;\\n\\t\\tfor (int k = 0; k < 4; k++) {\\n\\t\\t\\tint x = i + fx[k], y = j + fy[k];\\n\\t\\t\\tif (!valid(x, y)) continue;\\n\\t\\t\\tif (isInfected[x][y] == 1) {\\n\\t\\t\\t\\tcnt += buildWall(x, y, isInfected);\\n\\t\\t\\t} else if (isInfected[x][y] == 0) {\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn cnt;\\n\\t}\\n\\n\\tvoid spread(vector<vector<int>>& isInfected) {\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tif (isInfected[i][j] != 0) continue;\\n\\t\\t\\t\\tbool infect = 0;\\n\\t\\t\\t\\tfor (int k = 0; k < 4; k++) {\\n\\t\\t\\t\\t\\tint x = i + fx[k], y = j + fy[k];\\n\\t\\t\\t\\t\\tif (valid(x, y) && isInfected[x][y] == 1) {\\n\\t\\t\\t\\t\\t\\tinfect = true;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (infect) isInfected[i][j] = -2;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tif (isInfected[i][j] == -2) {\\n\\t\\t\\t\\t\\tisInfected[i][j] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvoid print(vector<vector<int>>& isInfected) {\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tcout << isInfected[i][j] << \" \";\\n\\t\\t\\t}\\n\\t\\t\\tcout << endl;\\n\\t\\t}\\n\\t\\t\\t\\n\\t}\\n    int containVirus(vector<vector<int>>& isInfected) {\\n\\t\\tint res = 0;\\n\\t\\tm = isInfected.size();\\n\\t\\tn = isInfected[0].size();\\n        while (true) {\\n\\t\\t\\tmemset(visited, 0, sizeof(visited));\\n\\t\\t\\tint cx = -1, cy = -1, cv = 0;\\n\\t\\t\\tint hasGood = 0, marker = 4;\\n\\t\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\t\\tfor (int j = 0; j < n; j++) {\\n                    hasGood = hasGood || isInfected[i][j] == 0;\\n                    if (isInfected[i][j] != 1) continue;\\n\\t\\t\\t\\t\\tint tmp = dfs(i, j, isInfected, marker++);\\n\\t\\t\\t\\t\\tif (tmp > cv) {\\n\\t\\t\\t\\t\\t\\tcv = tmp;\\n\\t\\t\\t\\t\\t\\tcx = i;\\n\\t\\t\\t\\t\\t\\tcy = j;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (!cv || !hasGood) break;\\n\\t\\t\\tres += buildWall(cx, cy, isInfected);\\n\\t\\t\\tspread(isInfected);\\n\\t\\t}\\n\\t\\treturn res;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2169784,
                "title": "infinite-grid-dsu-dfs-modular-w-diagram",
                "content": "**General Idea**\\n\\n- If the board is huge, we\\'d want to avoid traverse it every time to process everything. \\n  *[My solution will work even if the grid is infinitely large as long as we are given a list of virus coordinates.]*\\n\\n- There is a way to do that - *Union Find* - we can traverse the board 1 time to get all the virus\\'s group. \\nAnd from there, we do multi source DFS **outward from the virus borders** 1 step per loop. \\nAny cell visitied will be marked as visited **because there is no reason to traverse inward.**\\nThis way, we only traverse the board **at worst 2 times, at best 1 time, and if we are given virus coordinates, it\\'d be at best 0 time.**\\n\\n- In order to know which group the virus is it, we will assign a group ID to them.\\nThe root of each virus group is what we will be using to determined the number of walls and clean cells around it.\\n</br>\\n\\n**Some Details**\\n- To track the number of clean cells, we use `i*n+j` as the id for `isInfected[i][j]` along with a HashSet.\\n\\n- Virus Group ID begins at 2 because 0 and 1 are used by `isInfected[][]` already.\\n\\n- VIRUS (=1) means a pending virus (that is about to get explored) with no group assigned to it.\\n\\n- Walled virus will not be explored from other alive, spreading virus.\\n\\n- Do not kill (set to null) any alive virus that is not the root of the group because other groups of virus may union it.\\n</br>\\n\\n**Simulation (Diagram)**\\nTake this testcase for example:\\n```\\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 1, 0, 0]\\n[1, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 1, 0, 0, 0, 1, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 1, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, 1, 0]\\n[0, 0, 0, 0, 1, 0, 1, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n```\\nIt will be processed like so:\\n```\\nSTART: \\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 2, 0, 0]\\n[3, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 4, 0, 0, 0, 5, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 5, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, 6, 0]\\n[0, 0, 0, 0, 7, 0, 8, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n------------------------------\\n\\nVirus Group 5 Walled.\\n# of Clean Cells: 6\\nWalls Gained: 6\\nCurrent ans: 6\\n\\nVirus Group 4 and 3 United.\\nVirus Group 8 and 6 United.\\nVirus Group 8 and 7 United.\\n\\nCurrent board: \\n[0, 0, 0, 0, 0, 0, 0, 2, 0, 0]\\n[3, 0, 0, 0, 0, 0, 2, 2, 2, 0]\\n[3, 4, 4, 0, 0, 0, 0, 2, 0, 0]\\n[4, 4, 4, 4, 0, 0, 5, 0, 0, 0]\\n[0, 0, 4, 0, 0, 0, 5, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, 6, 0]\\n[0, 0, 0, 0, 7, 0, 8, 8, 6, 6]\\n[0, 0, 0, 7, 7, 8, 8, 8, 8, 0]\\n[0, 0, 0, 0, 7, 0, 8, 0, 0, 0]\\n------------------------------\\n\\nVirus Group 6 Walled.\\n# of Clean Cells: 13\\nWalls Gained: 23\\nCurrent ans: 29\\n\\n\\nCurrent board: \\n[3, 0, 0, 0, 0, 0, 2, 2, 2, 0]\\n[3, 3, 3, 0, 0, 2, 2, 2, 2, 2]\\n[3, 4, 4, 3, 0, 0, 2, 2, 2, 0]\\n[4, 4, 4, 4, 3, 0, 5, 2, 0, 0]\\n[3, 3, 4, 3, 0, 0, 5, 0, 0, 0]\\n[0, 0, 3, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, 6, 0]\\n[0, 0, 0, 0, 7, 0, 8, 8, 6, 6]\\n[0, 0, 0, 7, 7, 8, 8, 8, 8, 0]\\n[0, 0, 0, 0, 7, 0, 8, 0, 0, 0]\\n------------------------------\\n\\nVirus Group 3 Walled.\\n# of Clean Cells: 10\\nWalls Gained: 16\\nCurrent ans: 45\\n\\n\\nCurrent board: \\n[3, 0, 0, 0, 0, 2, 2, 2, 2, 2]\\n[3, 3, 3, 0, 2, 2, 2, 2, 2, 2]\\n[3, 4, 4, 3, 0, 2, 2, 2, 2, 2]\\n[4, 4, 4, 4, 3, 0, 5, 2, 2, 0]\\n[3, 3, 4, 3, 0, 0, 5, 2, 0, 0]\\n[0, 0, 3, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, 6, 0]\\n[0, 0, 0, 0, 7, 0, 8, 8, 6, 6]\\n[0, 0, 0, 7, 7, 8, 8, 8, 8, 0]\\n[0, 0, 0, 0, 7, 0, 8, 0, 0, 0]\\n------------------------------\\n\\nVirus Group 2 Walled.\\n# of Clean Cells: 7\\nWalls Gained: 11\\nCurrent ans: 56\\n\\n\\nCurrent board: \\n[3, 0, 0, 0, 0, 2, 2, 2, 2, 2]\\n[3, 3, 3, 0, 2, 2, 2, 2, 2, 2]\\n[3, 4, 4, 3, 0, 2, 2, 2, 2, 2]\\n[4, 4, 4, 4, 3, 0, 5, 2, 2, 0]\\n[3, 3, 4, 3, 0, 0, 5, 2, 0, 0]\\n[0, 0, 3, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, 6, 0]\\n[0, 0, 0, 0, 7, 0, 8, 8, 6, 6]\\n[0, 0, 0, 7, 7, 8, 8, 8, 8, 0]\\n[0, 0, 0, 0, 7, 0, 8, 0, 0, 0]\\n------------------------------\\nDone\\n```\\n\\nBelow, I use PriorityQueue to make things simple. We can also use a HashSet and track the max element. \\nTreeSet, on the other hand, is quite difficult to make it work for this problem.\\n```Java\\nclass Solution {\\n    int m, n;\\n    int VIRUS = 1;\\n    int ID = 2;\\n    public int containVirus(int[][] isInfected) {\\n        m = isInfected.length;\\n        n = isInfected[0].length;\\n        int ans = 0;\\n        Comparator<Virus> comp = Comparator.comparingInt(o -> -o.border.size());\\n        PriorityQueue<Virus> maxheap = new PriorityQueue<>(comp);\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                if (isInfected[i][j]==VIRUS){ // mark all virus cells as visited and populate all groups\\n                    Set<Integer> border = new HashSet<>();\\n                    int id = maxheap.size()+ID;\\n                    int walls = mark(i, j, id, isInfected, border, null, null);\\n                    maxheap.offer(new Virus(id, walls, border));\\n                }\\n            }\\n        }\\n\\n        Virus[] virus = new Virus[maxheap.size()+ID]; // lookup virus by ID\\n        UF uf = new UF(virus.length); // union find\\n\\n        while(!maxheap.isEmpty()){ // loop until no more virus group\\n            Virus killed = maxheap.poll();\\n            ans += killed.walls;\\n            virus[killed.id]=null; // kill this virus\\n            PriorityQueue<Virus> next = new PriorityQueue<>(comp);\\n            for (Virus v : maxheap){\\n                for (int p : v.border){\\n                    isInfected[p/n][p%n]=VIRUS; // new turn starts, all boarders are now virus\\n                }\\n            }\\n            for (Virus v : maxheap){ // populate the next border and wall count, and union virus groups (if any)\\n                int walls = 0;\\n                Set<Integer> nb = new HashSet<>();\\n                for (int p : v.border){\\n                    walls += mark(p/n, p%n, v.id, isInfected, nb, uf, virus);\\n                }\\n                virus[v.id]=new Virus(v.id, walls, nb);\\n            }\\n            for (int i = ID; i < virus.length; i++){ // let the root of the virus have it all, and reset the rest\\n                if (isAliveVirus(i, uf, virus) && !uf.isRoot(i)){\\n                    virus[uf.find(i)].walls+=virus[i].walls;\\n                    virus[uf.find(i)].border.addAll(virus[i].border);\\n                    virus[i] = new Virus(i, 0, new HashSet<>());\\n                }\\n            }\\n            for (int i = ID; i < virus.length; i++){ // enqueue the root virus for the next round.\\n                if (isAliveVirus(i, uf, virus) && uf.isRoot(i)){\\n                    next.offer(virus[i]);\\n                }\\n            }\\n            maxheap = next;\\n        }\\n\\n        return ans;\\n    }\\n\\n    private boolean isAliveVirus(int id, UF uf, Virus[] virus){\\n        return virus[uf.find(id)]!=null;\\n    }\\n\\n    private boolean isVirus(int id){\\n        return id >= ID;\\n    }\\n\\n    private boolean isDeadVirus(int id, UF uf, Virus[] virus){\\n        return isVirus(id) && !isAliveVirus(id, uf, virus);\\n    }\\n\\n    private int mark(int i, int j, int id, int[][] grid, Set<Integer> border, UF uf, Virus[] virus){\\n        if (i < 0 || j < 0 || i == m || j == n || grid[i][j]==id || isDeadVirus(grid[i][j], uf, virus))\\n            return 0;\\n        if (isVirus(grid[i][j])){ // union another virus group and exit\\n            uf.union(grid[i][j], id);\\n            return 0;\\n        }\\n        if (grid[i][j]==0){\\n            border.add(i*n+j);\\n            return 1;\\n        }\\n        grid[i][j]=id;\\n        return mark(i+1, j, id, grid, border, uf, virus)\\n            +  mark(i-1, j, id, grid, border, uf, virus)\\n            +  mark(i, j+1, id, grid, border, uf, virus)\\n            +  mark(i, j-1, id, grid, border, uf, virus);\\n    }\\n\\n    private class Virus {\\n        int id;\\n        int walls;\\n        Set<Integer> border;\\n        Virus(int id, int walls, Set<Integer> border){\\n            this.id = id;\\n            this.walls = walls;\\n            this.border = border;\\n        }\\n        Virus(){}\\n    }\\n\\n    private class UF {\\n        int[] parent;\\n        int[] rank;\\n        UF (int n){\\n            parent = IntStream.range(0, n).toArray();\\n            rank = new int[n];\\n        }\\n\\n        private int find(int x){\\n            return x == parent[x]? x : (parent[x]=find(parent[x]));\\n        }\\n\\n        private boolean isRoot(int x){\\n            return x == parent[x];\\n        }\\n\\n        private void union(int x, int y){\\n            x = find(x);\\n            y = find(y);\\n            if (x==y)\\n                return;\\n            if (rank[x]>rank[y]){\\n                parent[y]=x;\\n            }else{\\n                parent[x]=y;\\n                if (rank[x]==rank[y]){\\n                    rank[y]++;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 1, 0, 0]\\n[1, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 1, 0, 0, 0, 1, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 1, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, 1, 0]\\n[0, 0, 0, 0, 1, 0, 1, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n```\n```\\nSTART: \\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 2, 0, 0]\\n[3, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 4, 0, 0, 0, 5, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 5, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, 6, 0]\\n[0, 0, 0, 0, 7, 0, 8, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n------------------------------\\n\\nVirus Group 5 Walled.\\n# of Clean Cells: 6\\nWalls Gained: 6\\nCurrent ans: 6\\n\\nVirus Group 4 and 3 United.\\nVirus Group 8 and 6 United.\\nVirus Group 8 and 7 United.\\n\\nCurrent board: \\n[0, 0, 0, 0, 0, 0, 0, 2, 0, 0]\\n[3, 0, 0, 0, 0, 0, 2, 2, 2, 0]\\n[3, 4, 4, 0, 0, 0, 0, 2, 0, 0]\\n[4, 4, 4, 4, 0, 0, 5, 0, 0, 0]\\n[0, 0, 4, 0, 0, 0, 5, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, 6, 0]\\n[0, 0, 0, 0, 7, 0, 8, 8, 6, 6]\\n[0, 0, 0, 7, 7, 8, 8, 8, 8, 0]\\n[0, 0, 0, 0, 7, 0, 8, 0, 0, 0]\\n------------------------------\\n\\nVirus Group 6 Walled.\\n# of Clean Cells: 13\\nWalls Gained: 23\\nCurrent ans: 29\\n\\n\\nCurrent board: \\n[3, 0, 0, 0, 0, 0, 2, 2, 2, 0]\\n[3, 3, 3, 0, 0, 2, 2, 2, 2, 2]\\n[3, 4, 4, 3, 0, 0, 2, 2, 2, 0]\\n[4, 4, 4, 4, 3, 0, 5, 2, 0, 0]\\n[3, 3, 4, 3, 0, 0, 5, 0, 0, 0]\\n[0, 0, 3, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, 6, 0]\\n[0, 0, 0, 0, 7, 0, 8, 8, 6, 6]\\n[0, 0, 0, 7, 7, 8, 8, 8, 8, 0]\\n[0, 0, 0, 0, 7, 0, 8, 0, 0, 0]\\n------------------------------\\n\\nVirus Group 3 Walled.\\n# of Clean Cells: 10\\nWalls Gained: 16\\nCurrent ans: 45\\n\\n\\nCurrent board: \\n[3, 0, 0, 0, 0, 2, 2, 2, 2, 2]\\n[3, 3, 3, 0, 2, 2, 2, 2, 2, 2]\\n[3, 4, 4, 3, 0, 2, 2, 2, 2, 2]\\n[4, 4, 4, 4, 3, 0, 5, 2, 2, 0]\\n[3, 3, 4, 3, 0, 0, 5, 2, 0, 0]\\n[0, 0, 3, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, 6, 0]\\n[0, 0, 0, 0, 7, 0, 8, 8, 6, 6]\\n[0, 0, 0, 7, 7, 8, 8, 8, 8, 0]\\n[0, 0, 0, 0, 7, 0, 8, 0, 0, 0]\\n------------------------------\\n\\nVirus Group 2 Walled.\\n# of Clean Cells: 7\\nWalls Gained: 11\\nCurrent ans: 56\\n\\n\\nCurrent board: \\n[3, 0, 0, 0, 0, 2, 2, 2, 2, 2]\\n[3, 3, 3, 0, 2, 2, 2, 2, 2, 2]\\n[3, 4, 4, 3, 0, 2, 2, 2, 2, 2]\\n[4, 4, 4, 4, 3, 0, 5, 2, 2, 0]\\n[3, 3, 4, 3, 0, 0, 5, 2, 0, 0]\\n[0, 0, 3, 0, 0, 0, 0, 0, 0, 0]\\n[0, 0, 0, 0, 0, 0, 0, 0, 6, 0]\\n[0, 0, 0, 0, 7, 0, 8, 8, 6, 6]\\n[0, 0, 0, 7, 7, 8, 8, 8, 8, 0]\\n[0, 0, 0, 0, 7, 0, 8, 0, 0, 0]\\n------------------------------\\nDone\\n```\n```Java\\nclass Solution {\\n    int m, n;\\n    int VIRUS = 1;\\n    int ID = 2;\\n    public int containVirus(int[][] isInfected) {\\n        m = isInfected.length;\\n        n = isInfected[0].length;\\n        int ans = 0;\\n        Comparator<Virus> comp = Comparator.comparingInt(o -> -o.border.size());\\n        PriorityQueue<Virus> maxheap = new PriorityQueue<>(comp);\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                if (isInfected[i][j]==VIRUS){ // mark all virus cells as visited and populate all groups\\n                    Set<Integer> border = new HashSet<>();\\n                    int id = maxheap.size()+ID;\\n                    int walls = mark(i, j, id, isInfected, border, null, null);\\n                    maxheap.offer(new Virus(id, walls, border));\\n                }\\n            }\\n        }\\n\\n        Virus[] virus = new Virus[maxheap.size()+ID]; // lookup virus by ID\\n        UF uf = new UF(virus.length); // union find\\n\\n        while(!maxheap.isEmpty()){ // loop until no more virus group\\n            Virus killed = maxheap.poll();\\n            ans += killed.walls;\\n            virus[killed.id]=null; // kill this virus\\n            PriorityQueue<Virus> next = new PriorityQueue<>(comp);\\n            for (Virus v : maxheap){\\n                for (int p : v.border){\\n                    isInfected[p/n][p%n]=VIRUS; // new turn starts, all boarders are now virus\\n                }\\n            }\\n            for (Virus v : maxheap){ // populate the next border and wall count, and union virus groups (if any)\\n                int walls = 0;\\n                Set<Integer> nb = new HashSet<>();\\n                for (int p : v.border){\\n                    walls += mark(p/n, p%n, v.id, isInfected, nb, uf, virus);\\n                }\\n                virus[v.id]=new Virus(v.id, walls, nb);\\n            }\\n            for (int i = ID; i < virus.length; i++){ // let the root of the virus have it all, and reset the rest\\n                if (isAliveVirus(i, uf, virus) && !uf.isRoot(i)){\\n                    virus[uf.find(i)].walls+=virus[i].walls;\\n                    virus[uf.find(i)].border.addAll(virus[i].border);\\n                    virus[i] = new Virus(i, 0, new HashSet<>());\\n                }\\n            }\\n            for (int i = ID; i < virus.length; i++){ // enqueue the root virus for the next round.\\n                if (isAliveVirus(i, uf, virus) && uf.isRoot(i)){\\n                    next.offer(virus[i]);\\n                }\\n            }\\n            maxheap = next;\\n        }\\n\\n        return ans;\\n    }\\n\\n    private boolean isAliveVirus(int id, UF uf, Virus[] virus){\\n        return virus[uf.find(id)]!=null;\\n    }\\n\\n    private boolean isVirus(int id){\\n        return id >= ID;\\n    }\\n\\n    private boolean isDeadVirus(int id, UF uf, Virus[] virus){\\n        return isVirus(id) && !isAliveVirus(id, uf, virus);\\n    }\\n\\n    private int mark(int i, int j, int id, int[][] grid, Set<Integer> border, UF uf, Virus[] virus){\\n        if (i < 0 || j < 0 || i == m || j == n || grid[i][j]==id || isDeadVirus(grid[i][j], uf, virus))\\n            return 0;\\n        if (isVirus(grid[i][j])){ // union another virus group and exit\\n            uf.union(grid[i][j], id);\\n            return 0;\\n        }\\n        if (grid[i][j]==0){\\n            border.add(i*n+j);\\n            return 1;\\n        }\\n        grid[i][j]=id;\\n        return mark(i+1, j, id, grid, border, uf, virus)\\n            +  mark(i-1, j, id, grid, border, uf, virus)\\n            +  mark(i, j+1, id, grid, border, uf, virus)\\n            +  mark(i, j-1, id, grid, border, uf, virus);\\n    }\\n\\n    private class Virus {\\n        int id;\\n        int walls;\\n        Set<Integer> border;\\n        Virus(int id, int walls, Set<Integer> border){\\n            this.id = id;\\n            this.walls = walls;\\n            this.border = border;\\n        }\\n        Virus(){}\\n    }\\n\\n    private class UF {\\n        int[] parent;\\n        int[] rank;\\n        UF (int n){\\n            parent = IntStream.range(0, n).toArray();\\n            rank = new int[n];\\n        }\\n\\n        private int find(int x){\\n            return x == parent[x]? x : (parent[x]=find(parent[x]));\\n        }\\n\\n        private boolean isRoot(int x){\\n            return x == parent[x];\\n        }\\n\\n        private void union(int x, int y){\\n            x = find(x);\\n            y = find(y);\\n            if (x==y)\\n                return;\\n            if (rank[x]>rank[y]){\\n                parent[y]=x;\\n            }else{\\n                parent[x]=y;\\n                if (rank[x]==rank[y]){\\n                    rank[y]++;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2131304,
                "title": "c-dfs-dsu",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    int d[4][2] = {{0,1},{1,0},{-1,0},{0,-1}};\\n    int find(vector<int>& nums,int i){\\n        if(nums[i]==-1) return i;\\n        else return nums[i] = find(nums,nums[i]);\\n    }\\n    void union_(vector<int>& nums,int x,int y){\\n        int i = find(nums,x), j = find(nums,y);\\n        if(i!=j){\\n            if(i<j) nums[j] = i;\\n            else nums[i] = j;\\n        }\\n    }\\n    int dfs(vector<vector<int>>& nums,int i,int j){  // returns no. of wall arround the infected region\\n        if(nums[i][j]==0) return 1;\\n        nums[i][j] = 2;\\n        int re = 0;\\n        for(int k = 0; k<4;++k){\\n            int x = i+d[k][0], y = j+d[k][1];\\n            if(!(x<0||x>=n||y<0||y>=m) && nums[x][y]!=2) re+=dfs(nums,x,y);\\n        }\\n        return re;\\n    }\\n    int dfs2(vector<vector<int>>& nums,vector<int>& dp,int p){  // returns no. of blocks going to infect in next 1 sec.\\n        int re = 0;\\n        for(int i = 0; i<n;++i){\\n            for(int j = 0; j<m; ++j){\\n                if(nums[i][j]!=0) continue;\\n                for(int k = 0; k<4;++k){\\n                    int x = i+d[k][0], y = j+d[k][1];\\n                    if(!(x<0||x>=n||y<0||y>=m) && nums[x][y]==1 && p==find(dp,x*m+y)){\\n                        re++; break;\\n                    }\\n                }\\n            }\\n        }\\n        return re;\\n    }\\n    int containVirus(vector<vector<int>>& nums) {\\n         n = nums.size(), m = nums[0].size();\\n        vector<int> dp(n*m+1,-1);\\n        for(int i = 0; i<n;++i){  // union all adjacent infected region\\n            for(int j = 0; j<m; ++j){\\n                if(nums[i][j]!=1) continue;\\n                for(int k = 0; k<4;++k){\\n                    int x = i+d[k][0], y = j+d[k][1];\\n                    if(!(x<0||x>=n||y<0||y>=m) && nums[x][y]==1)\\n                        union_(dp,i*m+j,x*m+y);\\n                }\\n            }\\n        }\\n        int re = 0;\\n        while(1){\\n            int p = -1,max_ = -1;\\n            for(int k = 0; k<n*m;++k){  // find the region going to infect maximum uninfected region in next 1 sec.\\n                int i = k/m; int j = k-i*m;\\n                if(dp[k]==-1 && nums[i][j]==1){\\n                    int t = dfs2(nums,dp,k);  // no. of uninfected going to infect in next 1 sec by some infect whose parent node if k.\\n                    if(t>max_){\\n                        max_ = t; p = k;\\n                    }\\n                }\\n            }\\n            if(p==-1) break; // break if there are no blocks to infect\\n            int i = p/m; int j = p-i*m;\\n            int tre = dfs(nums,i,j); // no. of wall\\n            re+=tre;\\n            vector<pair<int,int>> temp;\\n            for(int i = 0; i<n;++i){  // infect the uninfected region in next sec.\\n                for(int j = 0;j<m;++j){\\n                    if(nums[i][j]!=0) continue;\\n                    bool is= 0;\\n                    for(int k = 0; k<4;++k){\\n                        int x = i+d[k][0], y = j+d[k][1];\\n                        if(!(x<0||x>=n||y<0||y>=m) && nums[x][y]==1) {is = 1; break;}\\n                    }\\n                    if(is) temp.push_back({i,j});\\n                }\\n            }\\n            for(int i = 0; i<temp.size();++i) nums[temp[i].first][temp[i].second] = 1;  \\n            for(int k = 0; k<temp.size(); ++k){  // union newly infected cells to there adjacent\\n                int i = temp[k].first, j = temp[k].second;\\n                for(int l = 0; l<4;++l){\\n                    int x = i+d[l][0], y = j+d[l][1];\\n                    if(!(x<0||x>=n||y<0||y>=m) && nums[x][y]==1) union_(dp,i*m+j,x*m+y);\\n                } \\n            }\\n        }\\n        return re;\\n    }\\n};\\n// Try for larger TestCase\\n// [[0,0,1,1,1,0,1,0,0,0],[1,1,1,0,0,0,1,1,0,1],[0,0,0,0,0,0,1,0,0,0],[0,0,0,0,1,0,1,0,0,0],[1,0,0,0,1,1,1,0,0,0],[0,0,0,1,0,1,1,0,0,0],[1,0,0,0,0,1,0,0,0,1],[1,0,0,0,0,0,0,0,0,1],[0,1,0,0,0,0,0,0,1,0],[1,1,0,0,0,1,0,1,0,0]]\\n\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    int d[4][2] = {{0,1},{1,0},{-1,0},{0,-1}};\\n    int find(vector<int>& nums,int i){\\n        if(nums[i]==-1) return i;\\n        else return nums[i] = find(nums,nums[i]);\\n    }\\n    void union_(vector<int>& nums,int x,int y){\\n        int i = find(nums,x), j = find(nums,y);\\n        if(i!=j){\\n            if(i<j) nums[j] = i;\\n            else nums[i] = j;\\n        }\\n    }\\n    int dfs(vector<vector<int>>& nums,int i,int j){  // returns no. of wall arround the infected region\\n        if(nums[i][j]==0) return 1;\\n        nums[i][j] = 2;\\n        int re = 0;\\n        for(int k = 0; k<4;++k){\\n            int x = i+d[k][0], y = j+d[k][1];\\n            if(!(x<0||x>=n||y<0||y>=m) && nums[x][y]!=2) re+=dfs(nums,x,y);\\n        }\\n        return re;\\n    }\\n    int dfs2(vector<vector<int>>& nums,vector<int>& dp,int p){  // returns no. of blocks going to infect in next 1 sec.\\n        int re = 0;\\n        for(int i = 0; i<n;++i){\\n            for(int j = 0; j<m; ++j){\\n                if(nums[i][j]!=0) continue;\\n                for(int k = 0; k<4;++k){\\n                    int x = i+d[k][0], y = j+d[k][1];\\n                    if(!(x<0||x>=n||y<0||y>=m) && nums[x][y]==1 && p==find(dp,x*m+y)){\\n                        re++; break;\\n                    }\\n                }\\n            }\\n        }\\n        return re;\\n    }\\n    int containVirus(vector<vector<int>>& nums) {\\n         n = nums.size(), m = nums[0].size();\\n        vector<int> dp(n*m+1,-1);\\n        for(int i = 0; i<n;++i){  // union all adjacent infected region\\n            for(int j = 0; j<m; ++j){\\n                if(nums[i][j]!=1) continue;\\n                for(int k = 0; k<4;++k){\\n                    int x = i+d[k][0], y = j+d[k][1];\\n                    if(!(x<0||x>=n||y<0||y>=m) && nums[x][y]==1)\\n                        union_(dp,i*m+j,x*m+y);\\n                }\\n            }\\n        }\\n        int re = 0;\\n        while(1){\\n            int p = -1,max_ = -1;\\n            for(int k = 0; k<n*m;++k){  // find the region going to infect maximum uninfected region in next 1 sec.\\n                int i = k/m; int j = k-i*m;\\n                if(dp[k]==-1 && nums[i][j]==1){\\n                    int t = dfs2(nums,dp,k);  // no. of uninfected going to infect in next 1 sec by some infect whose parent node if k.\\n                    if(t>max_){\\n                        max_ = t; p = k;\\n                    }\\n                }\\n            }\\n            if(p==-1) break; // break if there are no blocks to infect\\n            int i = p/m; int j = p-i*m;\\n            int tre = dfs(nums,i,j); // no. of wall\\n            re+=tre;\\n            vector<pair<int,int>> temp;\\n            for(int i = 0; i<n;++i){  // infect the uninfected region in next sec.\\n                for(int j = 0;j<m;++j){\\n                    if(nums[i][j]!=0) continue;\\n                    bool is= 0;\\n                    for(int k = 0; k<4;++k){\\n                        int x = i+d[k][0], y = j+d[k][1];\\n                        if(!(x<0||x>=n||y<0||y>=m) && nums[x][y]==1) {is = 1; break;}\\n                    }\\n                    if(is) temp.push_back({i,j});\\n                }\\n            }\\n            for(int i = 0; i<temp.size();++i) nums[temp[i].first][temp[i].second] = 1;  \\n            for(int k = 0; k<temp.size(); ++k){  // union newly infected cells to there adjacent\\n                int i = temp[k].first, j = temp[k].second;\\n                for(int l = 0; l<4;++l){\\n                    int x = i+d[l][0], y = j+d[l][1];\\n                    if(!(x<0||x>=n||y<0||y>=m) && nums[x][y]==1) union_(dp,i*m+j,x*m+y);\\n                } \\n            }\\n        }\\n        return re;\\n    }\\n};\\n// Try for larger TestCase\\n// [[0,0,1,1,1,0,1,0,0,0],[1,1,1,0,0,0,1,1,0,1],[0,0,0,0,0,0,1,0,0,0],[0,0,0,0,1,0,1,0,0,0],[1,0,0,0,1,1,1,0,0,0],[0,0,0,1,0,1,1,0,0,0],[1,0,0,0,0,1,0,0,0,1],[1,0,0,0,0,0,0,0,0,1],[0,1,0,0,0,0,0,0,1,0],[1,1,0,0,0,1,0,1,0,0]]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1882263,
                "title": "c-clean-code-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\\n    int walls=0;\\n    \\n    bool isValid(int i,int j,int m,int n,vector<vector<int>> &vis)\\n    {\\n        return (i>=0 && i<m && j>=0 && j<n && !vis[i][j]); \\n    }\\n    \\n    int find(int i,int j,int m,int n,vector<vector<int>>& a)\\n    {\\n        int c=0;\\n        \\n        queue<pair<int,int>> q;\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        \\n        a[i][j]=2;\\n        q.push({i,j});\\n        \\n        while(!q.empty())\\n        {\\n            i=q.front().first;\\n            j=q.front().second;\\n            q.pop();\\n            \\n            for(int k=0;k<4;k++)\\n            {\\n                if(isValid(i+dx[k],j+dy[k],m,n,vis))\\n                {\\n                    if(a[i+dx[k]][j+dy[k]]==0)\\n                        c++;\\n                    else if(a[i+dx[k]][j+dy[k]]==1)\\n                    {\\n                        a[i+dx[k]][j+dy[k]]=2;\\n                        q.push({i+dx[k],j+dy[k]});\\n                    }\\n                                            \\n                    vis[i+dx[k]][j+dy[k]]=1;\\n                    \\n                }\\n            }\\n        }\\n        \\n        return c;\\n    }\\n    \\n    void putwalls(pair<int,int> &change,int m,int n,vector<vector<int>>& a)\\n    {\\n        int i,j;\\n        i=change.first;\\n        j=change.second;\\n        \\n        queue<pair<int,int>> q;\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        \\n        q.push({i,j});\\n        \\n        while(!q.empty())\\n        {\\n            i=q.front().first;\\n            j=q.front().second;\\n            a[i][j]=-1;\\n            q.pop();\\n            \\n            \\n            for(int k=0;k<4;k++)\\n            {\\n                if(isValid(i+dx[k],j+dy[k],m,n,vis))\\n                {\\n                    if(a[i+dx[k]][j+dy[k]]==2)\\n                    {\\n                        q.push({i+dx[k],j+dy[k]});\\n                        a[i+dx[k]][j+dy[k]]=-1;\\n                        vis[i+dx[k]][j+dy[k]]=1;    \\n                    } \\n                    else if(a[i+dx[k]][j+dy[k]]==0)\\n                        walls++;\\n                }\\n            }\\n        }\\n    }\\n    \\n    void spread(int m,int n,vector<vector<int>>& a)\\n    {\\n        int i,j;\\n        queue<pair<int,int>> q;\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        \\n        for(i=0;i<m;i++)\\n        {\\n            for(j=0;j<n;j++)\\n            {\\n                if(a[i][j]==2)\\n                {\\n                    a[i][j]=1;\\n                    q.push({i,j});\\n\\n                }\\n            }\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            i=q.front().first;\\n            j=q.front().second;\\n            q.pop();\\n            \\n            for(int k=0;k<4;k++)\\n            {\\n                if(isValid(i+dx[k],j+dy[k],m,n,vis) && a[i+dx[k]][j+dy[k]]==0)\\n                {\\n                    a[i+dx[k]][j+dy[k]]=1;\\n                    vis[i+dx[k]][j+dy[k]]=1;     \\n                }\\n            }\\n        }\\n    }\\n    \\n    int containVirus(vector<vector<int>>& a) {\\n        int m=a.size(),n=a[0].size();\\n        int i,j;\\n        \\n        int infected=INT_MIN;\\n        pair<int,int> change;\\n        \\n        while(infected!=0)\\n        {\\n            infected=0;\\n            for(i=0;i<m;i++)\\n            {\\n                for(j=0;j<n;j++)\\n                {\\n                    if(a[i][j]==1)\\n                    {\\n                        int x=find(i,j,m,n,a);\\n                        if(x>infected)\\n                        {\\n                            change={i,j};\\n                            infected=x;\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            if(infected!=0)\\n            {\\n                putwalls(change,m,n,a);\\n                spread(m,n,a);\\n            }\\n        }\\n        \\n        return walls;\\n    }\\n};\\n```\\n\\n**Do share your views & upvote if you like !!!** \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\\n    int walls=0;\\n    \\n    bool isValid(int i,int j,int m,int n,vector<vector<int>> &vis)\\n    {\\n        return (i>=0 && i<m && j>=0 && j<n && !vis[i][j]); \\n    }\\n    \\n    int find(int i,int j,int m,int n,vector<vector<int>>& a)\\n    {\\n        int c=0;\\n        \\n        queue<pair<int,int>> q;\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        \\n        a[i][j]=2;\\n        q.push({i,j});\\n        \\n        while(!q.empty())\\n        {\\n            i=q.front().first;\\n            j=q.front().second;\\n            q.pop();\\n            \\n            for(int k=0;k<4;k++)\\n            {\\n                if(isValid(i+dx[k],j+dy[k],m,n,vis))\\n                {\\n                    if(a[i+dx[k]][j+dy[k]]==0)\\n                        c++;\\n                    else if(a[i+dx[k]][j+dy[k]]==1)\\n                    {\\n                        a[i+dx[k]][j+dy[k]]=2;\\n                        q.push({i+dx[k],j+dy[k]});\\n                    }\\n                                            \\n                    vis[i+dx[k]][j+dy[k]]=1;\\n                    \\n                }\\n            }\\n        }\\n        \\n        return c;\\n    }\\n    \\n    void putwalls(pair<int,int> &change,int m,int n,vector<vector<int>>& a)\\n    {\\n        int i,j;\\n        i=change.first;\\n        j=change.second;\\n        \\n        queue<pair<int,int>> q;\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        \\n        q.push({i,j});\\n        \\n        while(!q.empty())\\n        {\\n            i=q.front().first;\\n            j=q.front().second;\\n            a[i][j]=-1;\\n            q.pop();\\n            \\n            \\n            for(int k=0;k<4;k++)\\n            {\\n                if(isValid(i+dx[k],j+dy[k],m,n,vis))\\n                {\\n                    if(a[i+dx[k]][j+dy[k]]==2)\\n                    {\\n                        q.push({i+dx[k],j+dy[k]});\\n                        a[i+dx[k]][j+dy[k]]=-1;\\n                        vis[i+dx[k]][j+dy[k]]=1;    \\n                    } \\n                    else if(a[i+dx[k]][j+dy[k]]==0)\\n                        walls++;\\n                }\\n            }\\n        }\\n    }\\n    \\n    void spread(int m,int n,vector<vector<int>>& a)\\n    {\\n        int i,j;\\n        queue<pair<int,int>> q;\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        \\n        for(i=0;i<m;i++)\\n        {\\n            for(j=0;j<n;j++)\\n            {\\n                if(a[i][j]==2)\\n                {\\n                    a[i][j]=1;\\n                    q.push({i,j});\\n\\n                }\\n            }\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            i=q.front().first;\\n            j=q.front().second;\\n            q.pop();\\n            \\n            for(int k=0;k<4;k++)\\n            {\\n                if(isValid(i+dx[k],j+dy[k],m,n,vis) && a[i+dx[k]][j+dy[k]]==0)\\n                {\\n                    a[i+dx[k]][j+dy[k]]=1;\\n                    vis[i+dx[k]][j+dy[k]]=1;     \\n                }\\n            }\\n        }\\n    }\\n    \\n    int containVirus(vector<vector<int>>& a) {\\n        int m=a.size(),n=a[0].size();\\n        int i,j;\\n        \\n        int infected=INT_MIN;\\n        pair<int,int> change;\\n        \\n        while(infected!=0)\\n        {\\n            infected=0;\\n            for(i=0;i<m;i++)\\n            {\\n                for(j=0;j<n;j++)\\n                {\\n                    if(a[i][j]==1)\\n                    {\\n                        int x=find(i,j,m,n,a);\\n                        if(x>infected)\\n                        {\\n                            change={i,j};\\n                            infected=x;\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            if(infected!=0)\\n            {\\n                putwalls(change,m,n,a);\\n                spread(m,n,a);\\n            }\\n        }\\n        \\n        return walls;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1811295,
                "title": "unable-to-find-issue-in-code-failing-test-case-added",
                "content": "```\\nclass Solution {\\n    public int containVirus(int[][] isInfected) {\\n        int m = isInfected.length;\\n        int n = isInfected[0].length;\\n        int[] dx = {0, 0, 1, -1};\\n        int[] dy = {1, -1, 0, 0};\\n        int total = 0;\\n        int count = 0;\\n        int maxWalls = 0;\\n        print(isInfected, m, n);\\n        do {\\n            DSU dsu = new DSU(m*n);\\n            for (int i = 0; i < m; i++) {\\n               for (int j = 0; j < n; j++) {\\n                   if (isInfected[i][j] == 1) {\\n                      for (int k = 0; k < 4; k++) {\\n                        int x = i + dx[k];\\n                        int y = j + dy[k];\\n                        if (isInBorder(m, n, x, y) && isInfected[x][y] == 1) {\\n                            dsu.unionBySize(i*n + j, x*n + y);\\n                        }\\n                      }\\n                   }\\n                } \\n            }\\n            Map<Integer, List<int[]>> components = new HashMap<>();\\n            for (int i = 0; i < m; i++) {\\n               for (int j = 0; j < n; j++) {\\n                   if (isInfected[i][j] == 1) {\\n                      int group = dsu.findRepresentative(i*n + j);\\n                      if (!components.containsKey(group)) {\\n                           components.put(group, new ArrayList<>());\\n                      }\\n                      components.get(group).add(new int[]{i, j});\\n                   }\\n               }\\n            }\\n            maxWalls = 0;\\n            int surroundGroup = 0;\\n            for (Map.Entry<Integer, List<int[]>> entry : components.entrySet()) {\\n                int walls = 0;\\n                List<int[]> cells = entry.getValue();\\n                for (int[] cell : cells) {\\n                    for (int k = 0; k < 4; k++) {\\n                        int x = cell[0] + dx[k];\\n                        int y = cell[1] + dy[k];\\n                        if (isInBorder(m, n, x, y) && isInfected[x][y] == 0) {\\n                          walls++;\\n                        }\\n                    }  \\n                }\\n                if (maxWalls < walls) {\\n                    surroundGroup = entry.getKey();\\n                    maxWalls = walls;\\n                }\\n            }\\n            if (maxWalls == 0) {\\n                break;\\n            }\\n            System.out.println(\"maxWalls \" + maxWalls);\\n            total += maxWalls;\\n            List<int[]> cellsToBlock = components.get(surroundGroup);\\n            for (int[] cell : cellsToBlock) {\\n                isInfected[cell[0]][cell[1]] = -1;\\n            }\\n            System.out.println(\"surroundGroup \" + surroundGroup);\\n            System.out.println(\"keys \" + components.keySet());\\n            components.remove(surroundGroup);\\n            for (List<int[]> cells : components.values()) {\\n                for (int[] cell : cells) {\\n                    for (int k = 0; k < 4; k++) {\\n                        int x = cell[0] + dx[k];\\n                        int y = cell[1] + dy[k];\\n                        if (isInBorder(m, n, x, y)) {\\n                          isInfected[x][y] = 1;\\n                        }\\n                    } \\n                }\\n            }\\n            print(isInfected, m, n);\\n        } while(true);\\n        return total;\\n    }\\n    \\n    void print(int[][] isInfected, int m, int n) {\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                System.out.print(\" \" + isInfected[i][j]);\\n            }\\n            System.out.println();\\n        }\\n    }\\n    \\n    boolean isInBorder(int m, int n, int x, int y) {\\n        if (x >=0 && y>=0 && x<m && y< n) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n\\nclass DSU {\\n    int representative [];\\n    int size [];\\n    \\n    DSU(int sz) {\\n        representative = new int[sz];\\n        size = new int[sz];\\n        \\n        for (int i = 0; i < sz; ++i) {\\n            // Initially each group is its own representative\\n            representative[i] = i;\\n            // Intialize the size of all groups to 1\\n            size[i] = 1;\\n        }\\n    }\\n    \\n    // Finds the representative of group x\\n    public int findRepresentative(int x) {\\n        if (x == representative[x]) {\\n            return x;\\n        }\\n        \\n        // This is path compression\\n        return representative[x] = findRepresentative(representative[x]);\\n    }\\n    \\n    // Unite the group that contains \"a\" with the group that contains \"b\"\\n    public void unionBySize(int a, int b) {\\n        int representativeA = findRepresentative(a);\\n        int representativeB = findRepresentative(b);\\n        \\n        // If nodes a and b already belong to the same group, do nothing.\\n        if (representativeA == representativeB) {\\n            return;\\n        }\\n        \\n        // Union by size: point the representative of the smaller\\n        // group to the representative of the larger group.\\n        if (size[representativeA] >= size[representativeB]) {\\n            size[representativeA] += size[representativeB];\\n            representative[representativeB] = representativeA;\\n        } else {\\n            size[representativeB] += size[representativeA];\\n            representative[representativeA] = representativeB;\\n        }\\n    }\\n}\\n```\\n\\nTest case which is failing:\\n[[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,1,0,0],[1,0,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,1,0,0,0],[0,0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,0,0],[0,0,0,0,0,0,0,0,0,0]]",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int containVirus(int[][] isInfected) {\\n        int m = isInfected.length;\\n        int n = isInfected[0].length;\\n        int[] dx = {0, 0, 1, -1};\\n        int[] dy = {1, -1, 0, 0};\\n        int total = 0;\\n        int count = 0;\\n        int maxWalls = 0;\\n        print(isInfected, m, n);\\n        do {\\n            DSU dsu = new DSU(m*n);\\n            for (int i = 0; i < m; i++) {\\n               for (int j = 0; j < n; j++) {\\n                   if (isInfected[i][j] == 1) {\\n                      for (int k = 0; k < 4; k++) {\\n                        int x = i + dx[k];\\n                        int y = j + dy[k];\\n                        if (isInBorder(m, n, x, y) && isInfected[x][y] == 1) {\\n                            dsu.unionBySize(i*n + j, x*n + y);\\n                        }\\n                      }\\n                   }\\n                } \\n            }\\n            Map<Integer, List<int[]>> components = new HashMap<>();\\n            for (int i = 0; i < m; i++) {\\n               for (int j = 0; j < n; j++) {\\n                   if (isInfected[i][j] == 1) {\\n                      int group = dsu.findRepresentative(i*n + j);\\n                      if (!components.containsKey(group)) {\\n                           components.put(group, new ArrayList<>());\\n                      }\\n                      components.get(group).add(new int[]{i, j});\\n                   }\\n               }\\n            }\\n            maxWalls = 0;\\n            int surroundGroup = 0;\\n            for (Map.Entry<Integer, List<int[]>> entry : components.entrySet()) {\\n                int walls = 0;\\n                List<int[]> cells = entry.getValue();\\n                for (int[] cell : cells) {\\n                    for (int k = 0; k < 4; k++) {\\n                        int x = cell[0] + dx[k];\\n                        int y = cell[1] + dy[k];\\n                        if (isInBorder(m, n, x, y) && isInfected[x][y] == 0) {\\n                          walls++;\\n                        }\\n                    }  \\n                }\\n                if (maxWalls < walls) {\\n                    surroundGroup = entry.getKey();\\n                    maxWalls = walls;\\n                }\\n            }\\n            if (maxWalls == 0) {\\n                break;\\n            }\\n            System.out.println(\"maxWalls \" + maxWalls);\\n            total += maxWalls;\\n            List<int[]> cellsToBlock = components.get(surroundGroup);\\n            for (int[] cell : cellsToBlock) {\\n                isInfected[cell[0]][cell[1]] = -1;\\n            }\\n            System.out.println(\"surroundGroup \" + surroundGroup);\\n            System.out.println(\"keys \" + components.keySet());\\n            components.remove(surroundGroup);\\n            for (List<int[]> cells : components.values()) {\\n                for (int[] cell : cells) {\\n                    for (int k = 0; k < 4; k++) {\\n                        int x = cell[0] + dx[k];\\n                        int y = cell[1] + dy[k];\\n                        if (isInBorder(m, n, x, y)) {\\n                          isInfected[x][y] = 1;\\n                        }\\n                    } \\n                }\\n            }\\n            print(isInfected, m, n);\\n        } while(true);\\n        return total;\\n    }\\n    \\n    void print(int[][] isInfected, int m, int n) {\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                System.out.print(\" \" + isInfected[i][j]);\\n            }\\n            System.out.println();\\n        }\\n    }\\n    \\n    boolean isInBorder(int m, int n, int x, int y) {\\n        if (x >=0 && y>=0 && x<m && y< n) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n\\nclass DSU {\\n    int representative [];\\n    int size [];\\n    \\n    DSU(int sz) {\\n        representative = new int[sz];\\n        size = new int[sz];\\n        \\n        for (int i = 0; i < sz; ++i) {\\n            // Initially each group is its own representative\\n            representative[i] = i;\\n            // Intialize the size of all groups to 1\\n            size[i] = 1;\\n        }\\n    }\\n    \\n    // Finds the representative of group x\\n    public int findRepresentative(int x) {\\n        if (x == representative[x]) {\\n            return x;\\n        }\\n        \\n        // This is path compression\\n        return representative[x] = findRepresentative(representative[x]);\\n    }\\n    \\n    // Unite the group that contains \"a\" with the group that contains \"b\"\\n    public void unionBySize(int a, int b) {\\n        int representativeA = findRepresentative(a);\\n        int representativeB = findRepresentative(b);\\n        \\n        // If nodes a and b already belong to the same group, do nothing.\\n        if (representativeA == representativeB) {\\n            return;\\n        }\\n        \\n        // Union by size: point the representative of the smaller\\n        // group to the representative of the larger group.\\n        if (size[representativeA] >= size[representativeB]) {\\n            size[representativeA] += size[representativeB];\\n            representative[representativeB] = representativeA;\\n        } else {\\n            size[representativeB] += size[representativeA];\\n            representative[representativeA] = representativeB;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552742,
                "title": "c-dfs-solution-easy-understand",
                "content": "```c++\\nclass Solution {\\n    \\n    int M, N;\\n    \\n    //marking those cells as -1\\n    void buildWall(vector<vector<int>>& fec, int r, int c){\\n        //if it is already marked or empty, just return.\\n        if(r < 0 || c < 0 || r >= M || c >= N || fec[r][c] <= 0) return;\\n        fec[r][c] = -1;//mark this cell.\\n        buildWall(fec, r-1, c);\\n        buildWall(fec, r, c-1);\\n        buildWall(fec, r+1, c);\\n        buildWall(fec, r, c+1);\\n        return;\\n    }\\n    //the returning parameter is the number of walls you need to build.\\n    int calcWalls(vector<vector<int>>& fec, vector<vector<bool>>& vis, int r, int c, unordered_set<int>& ca){\\n        if(r < 0 || c < 0 || r >= fec.size() || c >= fec[0].size() || vis[r][c] || fec[r][c] < 0) return 0;\\n        if(fec[r][c] == 0){\\n            ca.insert(r*N+c);//a possible expand position\\n            return 1;//you need to build a wall here\\n        }\\n        vis[r][c] = true;\\n        return calcWalls(fec, vis, r-1, c, ca) + calcWalls(fec, vis, r+1, c, ca) + calcWalls(fec, vis, r, c-1, ca) + \\n            calcWalls(fec, vis, r, c+1, ca);\\n    }\\n    \\npublic:\\n    int containVirus(vector<vector<int>>& isInfected) {\\n        this->M = isInfected.size(), this->N = isInfected[0].size();\\n        int res = 0, indx = 0;//indx is a candidate block position.\\n        while(indx != -1){\\n            vector<vector<bool>> vis(M, vector<bool>(N));\\n            int needbuildwalls = 0, msize = 0;\\n            indx = -1;\\n            unordered_map<int, unordered_set<int>> conta;//for storing the threatened cells for (i,j) = i*N+j\\n            for(int i = 0;i < M;++i ){\\n                for(int j = 0;j < N;++j ){\\n                    if(!vis[i][j] && isInfected[i][j] == 1){\\n                        int tmp = calcWalls(isInfected, vis, i, j, conta[i*N+j]);\\n                        if(conta[i*N+j].size() > msize){//updating the candidate position.\\n                            needbuildwalls = tmp;\\n                            msize = conta[i*N+j].size();\\n                            indx = i*N+j;\\n                        }\\n                    }\\n                }//for\\n            }//for\\n            res += needbuildwalls;\\n            if(indx >= 0) buildWall(isInfected, indx/N, indx%N);\\n            //the virus spreads to all neighboring cells\\n            for(auto iter = conta.begin();iter != conta.end();++iter){\\n                if(iter->first != indx){\\n                    for(int pos:iter->second){\\n                        isInfected[pos/N][pos%N] = 1;//marked as 1\\n                    }\\n                }\\n            }\\n        }//while\\n        return res;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    int M, N;\\n    \\n    //marking those cells as -1\\n    void buildWall(vector<vector<int>>& fec, int r, int c){\\n        //if it is already marked or empty, just return.\\n        if(r < 0 || c < 0 || r >= M || c >= N || fec[r][c] <= 0) return;\\n        fec[r][c] = -1;//mark this cell.\\n        buildWall(fec, r-1, c);\\n        buildWall(fec, r, c-1);\\n        buildWall(fec, r+1, c);\\n        buildWall(fec, r, c+1);\\n        return;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 770108,
                "title": "java-no-brain-approach",
                "content": "```\\nclass Solution {\\n    class Info{\\n        int wallsToBuild;\\n        Set<Integer> threatenArea;\\n        Set<Integer> origArea;\\n        public Info(int x, Set<Integer> threatenArea, Set<Integer> origArea){\\n            this.wallsToBuild = x;\\n            this.threatenArea = threatenArea;\\n            this.origArea = origArea;\\n        }\\n    }\\n    int res = 0;\\n    public int containVirus(int[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        PriorityQueue<Info> threatenAreas = new PriorityQueue<Info>((a,b)->b.threatenArea.size()-a.threatenArea.size());\\n        for(int i=0; i<rows; i++){\\n            for(int j=0; j<cols; j++){\\n                if(grid[i][j] == 1){\\n                    Set<Integer> threatenArea = new HashSet();\\n                    Set<Integer> origArea = new HashSet();\\n                    int wallsToBuild = dfs(i, j, grid, threatenArea, origArea);\\n                    if(threatenArea.size()>0)\\n                        threatenAreas.offer(new Info(wallsToBuild, threatenArea, origArea));\\n                }\\n            }\\n        }\\n        if(threatenAreas.isEmpty()) return res;\\n        Info largestArea = threatenAreas.poll();\\n        res += largestArea.wallsToBuild;\\n        buildWalls(largestArea.origArea, grid);\\n        while(!threatenAreas.isEmpty()){\\n            Info nextArea = threatenAreas.poll();\\n            Set<Integer> origThreatenArea = nextArea.threatenArea;\\n            Set<Integer> newArea = new HashSet();\\n            Iterator<Integer> iter = origThreatenArea.iterator();\\n            while(iter.hasNext()){\\n                int pos = iter.next();\\n                int i = pos/51;\\n                int j = pos%51;\\n                grid[i][j] = 1;\\n            }    \\n        }\\n        resetGrid(grid);\\n        return containVirus(grid);\\n    }\\n    \\n    public void resetGrid(int[][] grid){\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        for(int i=0; i<rows; i++){\\n            for(int j=0; j<cols; j++){\\n                if(grid[i][j] > 0)\\n                    grid[i][j] = 1;\\n            }\\n        }\\n    }\\n    \\n    public void buildWalls(Set<Integer> area, int[][] grid){\\n        Iterator<Integer> iter = area.iterator();\\n        while(iter.hasNext()){\\n            int next = iter.next();\\n            grid[next/51][next%51] = -1;\\n        }\\n    }\\n    \\n    public int dfs(int i, int j, int[][] grid, Set<Integer> threatenArea, Set<Integer> origArea){\\n        if(i < 0 || j < 0 || i == grid.length || j == grid[0].length || grid[i][j] == 2 || grid[i][j] == -1)\\n            return 0;\\n        if(grid[i][j] == 0){\\n            threatenArea.add(i*51 + j);\\n            return 1;\\n        }\\n        origArea.add(i*51+j);\\n        grid[i][j] = 2;\\n        int res = 0;\\n        res += dfs(i-1, j, grid, threatenArea, origArea);\\n        res += dfs(i+1, j, grid, threatenArea, origArea);\\n        res += dfs(i, j-1, grid, threatenArea, origArea);\\n        res += dfs(i, j+1, grid, threatenArea, origArea);\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    class Info{\\n        int wallsToBuild;\\n        Set<Integer> threatenArea;\\n        Set<Integer> origArea;\\n        public Info(int x, Set<Integer> threatenArea, Set<Integer> origArea){\\n            this.wallsToBuild = x;\\n            this.threatenArea = threatenArea;\\n            this.origArea = origArea;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 637158,
                "title": "straight-forward-python-solution",
                "content": "```\\nclass Solution:\\n    def containVirus(self, grid: List[List[int]]) -> int:\\n\\n        rows, cols = len(grid), len(grid[0])\\n\\n        def adj_cells(row, col):\\n            for r, c in [\\n                (row + 1, col),\\n                (row - 1, col),\\n                (row, col + 1),\\n                (row, col - 1),\\n            ]:\\n                if 0 <= r < rows and 0 <= c < cols:\\n                    yield r, c\\n\\n        def no_of_elements_in_2d_list(list_2d):\\n            return sum(len(li) for li in list_2d)\\n\\n        def get_contaminated_areas():\\n            areas = []\\n            dangers = []\\n            walls = []\\n            seen = [[False] * cols for i in range(rows)]\\n\\n            for r in range(rows):\\n                for c in range(cols):\\n                    if grid[r][c] == 1 and not seen[r][c]:\\n                        area = [(r, c)]\\n                        danger = set()\\n                        queue = [(r, c)]\\n                        seen[r][c] = True\\n                        wall = 0\\n\\n                        while queue:\\n                            m, n = queue.pop(0)\\n                            for i, j in adj_cells(m, n):\\n                                index = (i, j)\\n                                if grid[i][j] == 1 and not seen[i][j]:\\n                                    seen[i][j] = True\\n                                    queue.append(index)\\n                                    area.append(index)\\n                                elif grid[i][j] == 0:\\n                                    wall += 1\\n                                    danger.add(index)\\n                        areas.append(area)\\n                        dangers.append(danger)\\n                        walls.append(wall)\\n\\n            return areas, dangers, walls\\n\\n        def spread_virus(dangers):\\n            for danger in dangers:\\n                for row, col in danger:\\n                    grid[row][col] = 1\\n\\n        wall = 0\\n        areas, dangers, walls = get_contaminated_areas()\\n\\n        while areas:\\n            area_count = len(areas)\\n\\n            if no_of_elements_in_2d_list(areas) == rows * cols:\\n                return wall\\n\\n            dangerest_index = 0\\n\\n            for i in range(area_count):\\n                if len(dangers[i]) > len(dangers[dangerest_index]):\\n                    dangerest_index = i\\n\\n            wall += walls[dangerest_index]\\n\\n            for i, j in areas[dangerest_index]:\\n                grid[i][j] = -1\\n\\n            spread_virus(dangers[:dangerest_index] + dangers[dangerest_index + 1 :])\\n\\n            areas, dangers, walls = get_contaminated_areas()\\n\\n        return wall\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def containVirus(self, grid: List[List[int]]) -> int:\\n\\n        rows, cols = len(grid), len(grid[0])\\n\\n        def adj_cells(row, col):\\n            for r, c in [\\n                (row + 1, col),\\n                (row - 1, col),\\n                (row, col + 1),\\n                (row, col - 1),\\n            ]:\\n                if 0 <= r < rows and 0 <= c < cols:\\n                    yield r, c\\n\\n        def no_of_elements_in_2d_list(list_2d):\\n            return sum(len(li) for li in list_2d)\\n\\n        def get_contaminated_areas():\\n            areas = []\\n            dangers = []\\n            walls = []\\n            seen = [[False] * cols for i in range(rows)]\\n\\n            for r in range(rows):\\n                for c in range(cols):\\n                    if grid[r][c] == 1 and not seen[r][c]:\\n                        area = [(r, c)]\\n                        danger = set()\\n                        queue = [(r, c)]\\n                        seen[r][c] = True\\n                        wall = 0\\n\\n                        while queue:\\n                            m, n = queue.pop(0)\\n                            for i, j in adj_cells(m, n):\\n                                index = (i, j)\\n                                if grid[i][j] == 1 and not seen[i][j]:\\n                                    seen[i][j] = True\\n                                    queue.append(index)\\n                                    area.append(index)\\n                                elif grid[i][j] == 0:\\n                                    wall += 1\\n                                    danger.add(index)\\n                        areas.append(area)\\n                        dangers.append(danger)\\n                        walls.append(wall)\\n\\n            return areas, dangers, walls\\n\\n        def spread_virus(dangers):\\n            for danger in dangers:\\n                for row, col in danger:\\n                    grid[row][col] = 1\\n\\n        wall = 0\\n        areas, dangers, walls = get_contaminated_areas()\\n\\n        while areas:\\n            area_count = len(areas)\\n\\n            if no_of_elements_in_2d_list(areas) == rows * cols:\\n                return wall\\n\\n            dangerest_index = 0\\n\\n            for i in range(area_count):\\n                if len(dangers[i]) > len(dangers[dangerest_index]):\\n                    dangerest_index = i\\n\\n            wall += walls[dangerest_index]\\n\\n            for i, j in areas[dangerest_index]:\\n                grid[i][j] = -1\\n\\n            spread_virus(dangers[:dangerest_index] + dangers[dangerest_index + 1 :])\\n\\n            areas, dangers, walls = get_contaminated_areas()\\n\\n        return wall\\n```",
                "codeTag": "Java"
            },
            {
                "id": 545217,
                "title": "accepted-c-solution-with-union-find",
                "content": "```\\n    public class Solution\\n    {\\n        private static readonly (int di, int dj)[] _directions = { (0, 1), (0, -1), (1, 0), (-1, 0) };\\n\\n        private class Unions\\n        {\\n            private readonly int[] _parents;\\n            private readonly int[] _ranks;\\n\\n            public Unions(int n)\\n            {\\n                _parents = new int[n];\\n                _ranks = new int[n];\\n                for (int i = 0; i < n; i++)\\n                {\\n                    _parents[i] = i;\\n                }\\n            }\\n\\n            public int Find(int x)\\n            {\\n                if (x != _parents[x])\\n                {\\n                    x = Find(_parents[x]);\\n                }\\n                return _parents[x];\\n            }\\n\\n            public bool Union(int x, int y)\\n            {\\n                int px = Find(x);\\n                int py = Find(y);\\n                if (px == py)\\n                {\\n                    return false;\\n                }\\n                if (_ranks[px] > _ranks[py])\\n                {\\n                    _parents[py] = px;\\n                    _ranks[px]++;\\n                }\\n                else\\n                {\\n                    _parents[px] = py;\\n                    _ranks[py]++;\\n                }\\n                return true;\\n            }\\n        }\\n\\n        public int ContainVirus(int[][] grid)\\n        {\\n            int n = grid.Length;\\n            int m = grid[0].Length;\\n\\n            int res = 0;\\n            while (true)\\n            {\\n                Unions dsu = new Unions(n * m);\\n\\n                for (int i = 0; i < n; i++)\\n                {\\n                    for (int j = 0; j < m; j++)\\n                    {\\n                        int linear = i * m + j;\\n\\n                        if (grid[i][j] == 1)\\n                        {\\n                            foreach (var dir in _directions)\\n                            {\\n                                int newI = i + dir.di;\\n                                int newJ = j + dir.dj;\\n\\n                                if (newI >= 0 && newI < n && newJ >= 0 && newJ < m && grid[newI][newJ] == 1)\\n                                {\\n                                    dsu.Union(linear, newI * m + newJ);\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                IDictionary<int, ISet<int>> root2Cells = new Dictionary<int, ISet<int>>();\\n\\n                for (int i = 0; i < n; i++)\\n                {\\n                    for (int j = 0; j < m; j++)\\n                    {\\n                        if (grid[i][j] == 1)\\n                        {\\n                            var root = dsu.Find(i * m + j);\\n                            if (!root2Cells.ContainsKey(root))\\n                            {\\n                                root2Cells[root] = new HashSet<int>();\\n                            }\\n\\n                            root2Cells[root].Add(i * m + j);\\n                        }\\n                    }\\n                }\\n\\n\\n                IList<(ISet<int> set, int root)> nextCellCollections =\\n                    new List<(ISet<int> set, int root)>(root2Cells.Count);\\n\\n                foreach (var r2c in root2Cells)\\n                {\\n                    ISet<int> next = new HashSet<int>();\\n\\n                    foreach (var lidx in r2c.Value)\\n                    {\\n                        int i = lidx / m;\\n                        int j = lidx % m;\\n\\n                        foreach (var dir in _directions)\\n                        {\\n                            int newI = i + dir.di;\\n                            int newJ = j + dir.dj;\\n\\n                            if (newI >= 0 && newI < n && newJ >= 0 && newJ < m && (grid[newI][newJ] == 0 || grid[newI][newJ] == 2))\\n                            {\\n                                next.Add(newI * m + newJ);\\n                                grid[newI][newJ] = 2;\\n                            }\\n                        }\\n                    }\\n\\n                    nextCellCollections.Add((next, r2c.Key));\\n                }\\n\\n                if (nextCellCollections.Count == 0)\\n                {\\n                    break;\\n                }\\n\\n                (ISet<int> set, int root)? max = null;\\n                foreach (var cand in nextCellCollections)\\n                {\\n                    max = max ?? cand;\\n                    if (cand.set.Count > max.Value.set.Count)\\n                    {\\n                        max = cand;\\n                    }\\n                }\\n\\n\\n                foreach (var lidx in max.Value.set)\\n                {\\n                    int i = lidx / m;\\n                    int j = lidx % m;\\n\\n                    foreach (var dir in _directions)\\n                    {\\n                        int newI = i + dir.di;\\n                        int newJ = j + dir.dj;\\n\\n                        if (newI >= 0 && newI < n && newJ >= 0 && newJ < m && grid[newI][newJ] == 1)\\n                        {\\n                            if (dsu.Find(newI * m + newJ) == max.Value.root)\\n                            {\\n                                res++;\\n                            }\\n                        }\\n                    }\\n                }\\n\\n\\n                foreach (var lidx in root2Cells[max.Value.root])\\n                {\\n                    int i = lidx / m;\\n                    int j = lidx % m;\\n                    grid[i][j] = 3;\\n                }\\n\\n\\n                nextCellCollections.Remove(max.Value);\\n                for (int collectionIdx = 0; collectionIdx < nextCellCollections.Count; collectionIdx++)\\n                {\\n                    var cells = nextCellCollections[collectionIdx];\\n\\n                    foreach (var lidx in cells.set)\\n                    {\\n                        int i = lidx / m;\\n                        int j = lidx % m;\\n\\n                        grid[i][j] = 1;\\n                    }\\n                }\\n                 \\n                if (nextCellCollections.Count == 0)\\n                {\\n                    break;\\n                }\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        private static readonly (int di, int dj)[] _directions = { (0, 1), (0, -1), (1, 0), (-1, 0) };\\n\\n        private class Unions\\n        {\\n            private readonly int[] _parents;\\n            private readonly int[] _ranks;\\n\\n            public Unions(int n)\\n            {\\n                _parents = new int[n];\\n                _ranks = new int[n];\\n                for (int i = 0; i < n; i++)\\n                {\\n                    _parents[i] = i;\\n                }\\n            }\\n\\n            public int Find(int x)\\n            {\\n                if (x != _parents[x])\\n                {\\n                    x = Find(_parents[x]);\\n                }\\n                return _parents[x];\\n            }\\n\\n            public bool Union(int x, int y)\\n            {\\n                int px = Find(x);\\n                int py = Find(y);\\n                if (px == py)\\n                {\\n                    return false;\\n                }\\n                if (_ranks[px] > _ranks[py])\\n                {\\n                    _parents[py] = px;\\n                    _ranks[px]++;\\n                }\\n                else\\n                {\\n                    _parents[px] = py;\\n                    _ranks[py]++;\\n                }\\n                return true;\\n            }\\n        }\\n\\n        public int ContainVirus(int[][] grid)\\n        {\\n            int n = grid.Length;\\n            int m = grid[0].Length;\\n\\n            int res = 0;\\n            while (true)\\n            {\\n                Unions dsu = new Unions(n * m);\\n\\n                for (int i = 0; i < n; i++)\\n                {\\n                    for (int j = 0; j < m; j++)\\n                    {\\n                        int linear = i * m + j;\\n\\n                        if (grid[i][j] == 1)\\n                        {\\n                            foreach (var dir in _directions)\\n                            {\\n                                int newI = i + dir.di;\\n                                int newJ = j + dir.dj;\\n\\n                                if (newI >= 0 && newI < n && newJ >= 0 && newJ < m && grid[newI][newJ] == 1)\\n                                {\\n                                    dsu.Union(linear, newI * m + newJ);\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                IDictionary<int, ISet<int>> root2Cells = new Dictionary<int, ISet<int>>();\\n\\n                for (int i = 0; i < n; i++)\\n                {\\n                    for (int j = 0; j < m; j++)\\n                    {\\n                        if (grid[i][j] == 1)\\n                        {\\n                            var root = dsu.Find(i * m + j);\\n                            if (!root2Cells.ContainsKey(root))\\n                            {\\n                                root2Cells[root] = new HashSet<int>();\\n                            }\\n\\n                            root2Cells[root].Add(i * m + j);\\n                        }\\n                    }\\n                }\\n\\n\\n                IList<(ISet<int> set, int root)> nextCellCollections =\\n                    new List<(ISet<int> set, int root)>(root2Cells.Count);\\n\\n                foreach (var r2c in root2Cells)\\n                {\\n                    ISet<int> next = new HashSet<int>();\\n\\n                    foreach (var lidx in r2c.Value)\\n                    {\\n                        int i = lidx / m;\\n                        int j = lidx % m;\\n\\n                        foreach (var dir in _directions)\\n                        {\\n                            int newI = i + dir.di;\\n                            int newJ = j + dir.dj;\\n\\n                            if (newI >= 0 && newI < n && newJ >= 0 && newJ < m && (grid[newI][newJ] == 0 || grid[newI][newJ] == 2))\\n                            {\\n                                next.Add(newI * m + newJ);\\n                                grid[newI][newJ] = 2;\\n                            }\\n                        }\\n                    }\\n\\n                    nextCellCollections.Add((next, r2c.Key));\\n                }\\n\\n                if (nextCellCollections.Count == 0)\\n                {\\n                    break;\\n                }\\n\\n                (ISet<int> set, int root)? max = null;\\n                foreach (var cand in nextCellCollections)\\n                {\\n                    max = max ?? cand;\\n                    if (cand.set.Count > max.Value.set.Count)\\n                    {\\n                        max = cand;\\n                    }\\n                }\\n\\n\\n                foreach (var lidx in max.Value.set)\\n                {\\n                    int i = lidx / m;\\n                    int j = lidx % m;\\n\\n                    foreach (var dir in _directions)\\n                    {\\n                        int newI = i + dir.di;\\n                        int newJ = j + dir.dj;\\n\\n                        if (newI >= 0 && newI < n && newJ >= 0 && newJ < m && grid[newI][newJ] == 1)\\n                        {\\n                            if (dsu.Find(newI * m + newJ) == max.Value.root)\\n                            {\\n                                res++;\\n                            }\\n                        }\\n                    }\\n                }\\n\\n\\n                foreach (var lidx in root2Cells[max.Value.root])\\n                {\\n                    int i = lidx / m;\\n                    int j = lidx % m;\\n                    grid[i][j] = 3;\\n                }\\n\\n\\n                nextCellCollections.Remove(max.Value);\\n                for (int collectionIdx = 0; collectionIdx < nextCellCollections.Count; collectionIdx++)\\n                {\\n                    var cells = nextCellCollections[collectionIdx];\\n\\n                    foreach (var lidx in cells.set)\\n                    {\\n                        int i = lidx / m;\\n                        int j = lidx % m;\\n\\n                        grid[i][j] = 1;\\n                    }\\n                }\\n                 \\n                if (nextCellCollections.Count == 0)\\n                {\\n                    break;\\n                }\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 472924,
                "title": "cell-contained-python-bfs",
                "content": "0: is a free cell\\n1: is a contaminated cell that is spreading\\n-1: is a contaminated cell that we stopped spreading\\n\\nfor each connected component of 1s\\n1. a hashset of all the connected cells under this same connected component\\n2. the number of walls it would take to quarantine this cc\\n3. the number of cells it would contaminate if we let it spread one turn\\n\\npseudo code\\n```\\nareas = getallccs()\\nwhile(areas):\\n\\tget the max area aka the one that stop the spread of the max number of cells\\n\\tarea = the max among all areas\\n\\ttotal += the number of walls for that area\\n\\tturn this area into -1 aka stop the propagation\\n\\tareas = getallccs() # recompute the areas\\n```\\n\\nhow many walls given a cc?\\n\\ngiven a cell , look at its 4 neighbors, \\nit one of them is a zero , it needs one wall\\ndo that for all the cells\\n\\n\\nhow many walls possible contaminations?\\n\\ngiven a cell , look at its 4 neighbors, \\nit one of them is a zero , add it to a hashset\\ndo that for all the cells\\nand the length of that hashset if \\nthe number of possible contamination\\nhashset because a zero could be surrounded and counted multiple times\\n\\n\\n\\n\\n\\n```\\nclass Solution(object):\\n    def containVirus(self, grid):\\n        total,areas = 0,self.f(grid)\\n        while(areas):\\n            areas.sort(key = lambda x: (x[2], -x[1]))\\n            total += areas[-1][1]\\n            self.quarantine(areas[-1][0],grid)\\n            areas.pop()\\n            self.spread(grid)\\n            areas = self.f(grid)\\n        return total\\n    \\n    def f(self,grid):\\n        areas = []\\n        gv = set([])\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1 and (i,j) not in gv: \\n                    nw = 0\\n                    q = collections.deque([(i,j)])\\n                    vis = set([(i,j)])\\n                    nb = set([])\\n                    while(q):\\n                        u = q.popleft()\\n                        for v in [(u[0]+1,u[1]), (u[0]-1,u[1]), (u[0],u[1]+1), (u[0],u[1]-1)]:\\n                            if 0<= v[0] < len(grid) and 0 <= v[1] < len(grid[0]) and v not in vis:\\n                                if grid[v[0]][v[1]] == 1:\\n                                    q.append(v)\\n                                    gv.add(v)\\n                                    vis.add(v)\\n                                elif grid[v[0]][v[1]] == 0:\\n                                    nb.add(v)\\n                                    nw +=1\\n                    areas.append([vis,nw,len(nb)])\\n        return areas\\n    def quarantine(self,area,grid): for ei,ej in area: grid[ei][ej] = -1\\n    def spread(self,grid):\\n        ta = [(i,j) for i in range(len(grid)) for j in range(len(grid[0])) if grid[i][j] ==1]\\n        for u in ta:\\n            for v in [(u[0]+1,u[1]), (u[0]-1,u[1]), (u[0],u[1]+1), (u[0],u[1]-1)]:\\n                if 0<= v[0] < len(grid) and 0 <= v[1] < len(grid[0]) and grid[v[0]][v[1]] == 0: grid[v[0]][v[1]] = 1\\n```",
                "solutionTags": [],
                "code": "```\\nareas = getallccs()\\nwhile(areas):\\n\\tget the max area aka the one that stop the spread of the max number of cells\\n\\tarea = the max among all areas\\n\\ttotal += the number of walls for that area\\n\\tturn this area into -1 aka stop the propagation\\n\\tareas = getallccs() # recompute the areas\\n```\n```\\nclass Solution(object):\\n    def containVirus(self, grid):\\n        total,areas = 0,self.f(grid)\\n        while(areas):\\n            areas.sort(key = lambda x: (x[2], -x[1]))\\n            total += areas[-1][1]\\n            self.quarantine(areas[-1][0],grid)\\n            areas.pop()\\n            self.spread(grid)\\n            areas = self.f(grid)\\n        return total\\n    \\n    def f(self,grid):\\n        areas = []\\n        gv = set([])\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1 and (i,j) not in gv: \\n                    nw = 0\\n                    q = collections.deque([(i,j)])\\n                    vis = set([(i,j)])\\n                    nb = set([])\\n                    while(q):\\n                        u = q.popleft()\\n                        for v in [(u[0]+1,u[1]), (u[0]-1,u[1]), (u[0],u[1]+1), (u[0],u[1]-1)]:\\n                            if 0<= v[0] < len(grid) and 0 <= v[1] < len(grid[0]) and v not in vis:\\n                                if grid[v[0]][v[1]] == 1:\\n                                    q.append(v)\\n                                    gv.add(v)\\n                                    vis.add(v)\\n                                elif grid[v[0]][v[1]] == 0:\\n                                    nb.add(v)\\n                                    nw +=1\\n                    areas.append([vis,nw,len(nb)])\\n        return areas\\n    def quarantine(self,area,grid): for ei,ej in area: grid[ei][ej] = -1\\n    def spread(self,grid):\\n        ta = [(i,j) for i in range(len(grid)) for j in range(len(grid[0])) if grid[i][j] ==1]\\n        for u in ta:\\n            for v in [(u[0]+1,u[1]), (u[0]-1,u[1]), (u[0],u[1]+1), (u[0],u[1]-1)]:\\n                if 0<= v[0] < len(grid) and 0 <= v[1] < len(grid[0]) and grid[v[0]][v[1]] == 0: grid[v[0]][v[1]] = 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 405427,
                "title": "c-4ms-dfs-beats-100",
                "content": "```\\npublic:\\n    int containVirus(vector<vector<int>>& grid) {\\n        while (build_wall(grid)) {}\\n        return res;\\n    }\\n    \\nprivate:\\n    int res = 0;\\n    int dfs(vector<vector<int>>& grid, int i, int j, int k, int& wall, vector<vector<int>>& infected_grid) {\\n        if (i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || grid[i][j] < 0) return 0;\\n        if (grid[i][j] == k) {\\n            if (infected_grid[i][j] > 0) wall++; // only build wall on boundary\\n            return 0;\\n        }\\n        \\n        if (grid[i][j] == 1) {\\n            grid[i][j] = k; // grid[i][j] = 1 -> k, not boundary, don\\'t build wall\\n            return dfs(grid, i + 1, j, k, wall, infected_grid) + dfs(grid, i, j + 1, k, wall, infected_grid)\\n                 + dfs(grid, i - 1, j, k, wall, infected_grid) + dfs(grid, i, j - 1, k, wall, infected_grid);\\n        }\\n        \\n        grid[i][j] = k; // grid[i][j] = 0 -> k\\n        infected_grid[i][j]++; // record the boundary\\n        wall++; // only build wall on boundary\\n        return 1;\\n    }\\n    \\n    bool build_wall(vector<vector<int>>& grid) {\\n        int k = 1, m = grid.size(), n = grid[0].size(), max_infected = -1, K = 0, add_wall = 0;\\n        vector<vector<int>> infected_grid(m, vector<int>(n, 0));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    int wall = 0, infected = dfs(grid, i, j, ++k, wall, infected_grid);\\n                    if (max_infected < infected) {\\n                        max_infected = infected;\\n                        add_wall = wall;\\n                        K = k;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if (k == 1) return false; // no free infected area exists, stop\\n        \\n        res += add_wall;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] > 0) grid[i][j] = (grid[i][j] == K && infected_grid[i][j] <= 1) ? infected_grid[i][j] - 1 : 1; // set area inside new wall as -1, else where as 1\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic:\\n    int containVirus(vector<vector<int>>& grid) {\\n        while (build_wall(grid)) {}\\n        return res;\\n    }\\n    \\nprivate:\\n    int res = 0;\\n    int dfs(vector<vector<int>>& grid, int i, int j, int k, int& wall, vector<vector<int>>& infected_grid) {\\n        if (i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || grid[i][j] < 0) return 0;\\n        if (grid[i][j] == k) {\\n            if (infected_grid[i][j] > 0) wall++; // only build wall on boundary\\n            return 0;\\n        }\\n        \\n        if (grid[i][j] == 1) {\\n            grid[i][j] = k; // grid[i][j] = 1 -> k, not boundary, don\\'t build wall\\n            return dfs(grid, i + 1, j, k, wall, infected_grid) + dfs(grid, i, j + 1, k, wall, infected_grid)\\n                 + dfs(grid, i - 1, j, k, wall, infected_grid) + dfs(grid, i, j - 1, k, wall, infected_grid);\\n        }\\n        \\n        grid[i][j] = k; // grid[i][j] = 0 -> k\\n        infected_grid[i][j]++; // record the boundary\\n        wall++; // only build wall on boundary\\n        return 1;\\n    }\\n    \\n    bool build_wall(vector<vector<int>>& grid) {\\n        int k = 1, m = grid.size(), n = grid[0].size(), max_infected = -1, K = 0, add_wall = 0;\\n        vector<vector<int>> infected_grid(m, vector<int>(n, 0));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    int wall = 0, infected = dfs(grid, i, j, ++k, wall, infected_grid);\\n                    if (max_infected < infected) {\\n                        max_infected = infected;\\n                        add_wall = wall;\\n                        K = k;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if (k == 1) return false; // no free infected area exists, stop\\n        \\n        res += add_wall;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] > 0) grid[i][j] = (grid[i][j] == K && infected_grid[i][j] <= 1) ? infected_grid[i][j] - 1 : 1; // set area inside new wall as -1, else where as 1\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 341527,
                "title": "simple-java-dfs",
                "content": "~~~java\\n\\nclass Solution {\\n    int m, n;\\n    int[] dx = new int[]{1,-1,0,0};\\n    int[] dy = new int[]{0,0,1,-1};\\n    \\n    boolean[][] visited;\\n    List<Set<Integer>> region;\\n    List<Set<Integer>> frontier;\\n    List<Integer> perimeter;\\n    \\n    public int containVirus(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        int ans = 0;\\n        \\n        while (true) {\\n            visited = new boolean[m][n];\\n            region = new ArrayList<>();\\n            frontier = new ArrayList<>();\\n            perimeter = new ArrayList<>();\\n            \\n            for (int i = 0; i < m; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    if (grid[i][j] == 1 && !visited[i][j]) {\\n                        frontier.add(new HashSet<>());\\n                        region.add(new HashSet<>());\\n                        perimeter.add(0);\\n                        dfs(grid, i, j);\\n                    }\\n                }\\n            }\\n        \\n            if (region.size() == 0) return ans;\\n            \\n            int max = 0;\\n            for (int i = 1; i < frontier.size(); i++) {\\n                if (frontier.get(i).size() > frontier.get(max).size()) max = i;\\n            }\\n            ans += perimeter.get(max);\\n            \\n            for (int i = 0; i < region.size(); ++i) {\\n                if (i == max) {\\n                    for (int code: region.get(i))\\n                        grid[code / n][code % n] = -1;\\n                } else {\\n                    for (int code: region.get(i)) {\\n                        int r = code / n, c = code % n;\\n                        for (int k = 0; k < 4; k++) {\\n                            int nr = r + dx[k], nc = c + dy[k];\\n                            if (nr >= 0 && nr < m && \\n                                nc >= 0 && nc < n && \\n                                grid[nr][nc] == 0)\\n                                grid[nr][nc] = 1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    private void dfs(int[][] grid, int x, int y) {\\n        int len = region.size();\\n        region.get(len-1).add(x * n + y);\\n        visited[x][y] = true;\\n        for (int k = 0; k < 4; k++) {\\n            int nx = x + dx[k], ny = y + dy[k];\\n            if (nx < 0 || ny < 0 || nx >= m || ny >= n) continue;\\n            if (grid[nx][ny] == 1 && !visited[nx][ny]) dfs(grid, nx, ny);\\n            else if (grid[nx][ny] == 0) {\\n                frontier.get(len-1).add(nx * n + ny);\\n                perimeter.set(len-1, perimeter.get(len-1)+1);\\n            }\\n        }\\n    }\\n}\\n\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\n    int m, n;\\n    int[] dx = new int[]{1,-1,0,0}",
                "codeTag": "Java"
            },
            {
                "id": 190941,
                "title": "simulation-with-union-find-c-12ms",
                "content": "This is a straight forward solution without any algorithmic tricks. I applied union-find here instead of DFS. Code is clear enough to understand. \\n```C++\\nclass Solution {\\n    int M, N, K;\\n    vector<int> root, affect;\\n    \\n    // operations of Union-Find\\n    int find_root(int i) {\\n        if (root[i] == -1) return -1;       // -1: this union cannot spread any more\\n        if (root[i] == i) return i;\\n        root[i] = find_root(root[i]);\\n        return root[i];\\n    }\\n    void union_set(int i, int j) {\\n        root[find_root(j)] = find_root(i);\\n    }\\n    \\n    void showGrid(vector<vector<int>>& grid) {\\n        for (int i=0; i<M; i++) {\\n            for (int j=0; j<N; j++) \\n                cout << grid[i][j] << \\' \\';\\n            cout << endl;\\n        }\\n    }\\n    \\n    void constructUnions(vector<vector<int>>& grid) {\\n        K = M * N;\\n        root.resize(K);\\n        affect.resize(K, 0);\\n        for (int i=0; i<K; i++) {\\n            int a = i / N, b = i % N;\\n            if (!grid[a][b]) \\n                root[i] = -1;\\n            else {\\n                root[i] = i;\\n                if (a && grid[a-1][b] && find_root(i) != find_root(i-N)) union_set(i-N, i);\\n                if (b && grid[a][b-1] && find_root(i) != find_root(i-1)) union_set(i-1, i);\\n            }\\n        }\\n        //showGrid(grid);\\n    }\\n        \\n    pair<int, int> findMostAffect(vector<vector<int>>& grid) {\\n        fill(affect.begin(), affect.end(), 0);\\n        for (int i=0; i<K; i++) {\\n            int a = i / N, b = i % N;\\n            if (grid[a][b]) continue;\\n            unordered_set<int> nei;         // to avoid duplicate adding\\n            if (a>0   && grid[a-1][b] && find_root(i-N) != -1) nei.insert(root[i-N]);\\n            if (b>0   && grid[a][b-1] && find_root(i-1) != -1) nei.insert(root[i-1]);\\n            if (a<M-1 && grid[a+1][b] && find_root(i+N) != -1) nei.insert(root[i+N]);\\n            if (b<N-1 && grid[a][b+1] && find_root(i+1) != -1) nei.insert(root[i+1]);\\n            for (int n : nei) affect[n] ++;\\n        }\\n        int maxUnion = -1, mayAffect = 0, maxAffect = 0;\\n        for (int r=0; r<K; r++) {\\n            if (affect[r] > maxAffect) {\\n                maxAffect = affect[r];\\n                maxUnion = r;\\n            }\\n            mayAffect += affect[r];\\n        }\\n        //cout << \"maxUnion:\" << maxUnion << \", mayAffect:\" << mayAffect << endl;\\n        return {maxUnion, mayAffect};\\n    }\\n        \\n    int buildWallAndGrow(vector<vector<int>>& grid, int maxUnion) {\\n        int walls = 0;\\n        \\n        // build walls\\n        for (int i=0; i<K; i++) {\\n            int a = i / N, b = i % N;\\n            if (grid[a][b] && find_root(i) == maxUnion) {\\n                if (a>0   && !grid[a-1][b]) walls ++;\\n                if (b>0   && !grid[a][b-1]) walls ++;\\n                if (a<M-1 && !grid[a+1][b]) walls ++;\\n                if (b<N-1 && !grid[a][b+1]) walls ++;\\n            }\\n        }\\n        \\n        // disable current union\\n        root[maxUnion] = -1;\\n        \\n        // growth of other unions\\n        vector<int> toAffect;\\n        for (int i=0; i<K; i++) {\\n            int a = i / N, b = i % N;\\n            if (!grid[a][b]) {\\n                if ((a>0   && grid[a-1][b] && find_root(i-N) != -1) ||\\n                    (b>0   && grid[a][b-1] && find_root(i-1) != -1) ||\\n                    (a<M-1 && grid[a+1][b] && find_root(i+N) != -1) ||\\n                    (b<N-1 && grid[a][b+1] && find_root(i+1) != -1))\\n                {\\n                    toAffect.push_back(i);\\n                }\\n            }\\n        }\\n        for (int i : toAffect) {\\n            int a = i / N, b = i % N;\\n            root[i] = i;\\n            grid[a][b] = 1;\\n            if (a>0   && grid[a-1][b] && find_root(i-N) != -1) union_set(i-N, i);\\n            if (b>0   && grid[a][b-1] && find_root(i-1) != -1) union_set(i-1, i);\\n            if (a<M-1 && grid[a+1][b] && find_root(i+N) != -1) union_set(i+N, i);\\n            if (b<N-1 && grid[a][b+1] && find_root(i+1) != -1) union_set(i+1, i);\\n        }\\n       \\n        //cout << \"Walls:\" << walls << endl;\\n        //showGrid(grid);\\n        return walls;\\n    }\\n    \\npublic:\\n    \\n    int containVirus(vector<vector<int>>& grid) {\\n        if (!(M = grid.size()) || !(N = grid[0].size())) return 0;\\n        constructUnions(grid);\\n        \\n        int walls = 0;\\n        while (true) {\\n            auto p = findMostAffect(grid);\\n            int maxUnion = p.first;\\n            int mayAffect = p.second;\\n            \\n            if (mayAffect) \\n                walls += buildWallAndGrow(grid, maxUnion); \\n            else break;\\n        }\\n        \\n        return walls;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\n    int M, N, K;\\n    vector<int> root, affect;\\n    \\n    // operations of Union-Find\\n    int find_root(int i) {\\n        if (root[i] == -1) return -1;       // -1: this union cannot spread any more\\n        if (root[i] == i) return i;\\n        root[i] = find_root(root[i]);\\n        return root[i];\\n    }\\n    void union_set(int i, int j) {\\n        root[find_root(j)] = find_root(i);\\n    }\\n    \\n    void showGrid(vector<vector<int>>& grid) {\\n        for (int i=0; i<M; i++) {\\n            for (int j=0; j<N; j++) \\n                cout << grid[i][j] << \\' \\';\\n            cout << endl;\\n        }\\n    }\\n    \\n    void constructUnions(vector<vector<int>>& grid) {\\n        K = M * N;\\n        root.resize(K);\\n        affect.resize(K, 0);\\n        for (int i=0; i<K; i++) {\\n            int a = i / N, b = i % N;\\n            if (!grid[a][b]) \\n                root[i] = -1;\\n            else {\\n                root[i] = i;\\n                if (a && grid[a-1][b] && find_root(i) != find_root(i-N)) union_set(i-N, i);\\n                if (b && grid[a][b-1] && find_root(i) != find_root(i-1)) union_set(i-1, i);\\n            }\\n        }\\n        //showGrid(grid);\\n    }\\n        \\n    pair<int, int> findMostAffect(vector<vector<int>>& grid) {\\n        fill(affect.begin(), affect.end(), 0);\\n        for (int i=0; i<K; i++) {\\n            int a = i / N, b = i % N;\\n            if (grid[a][b]) continue;\\n            unordered_set<int> nei;         // to avoid duplicate adding\\n            if (a>0   && grid[a-1][b] && find_root(i-N) != -1) nei.insert(root[i-N]);\\n            if (b>0   && grid[a][b-1] && find_root(i-1) != -1) nei.insert(root[i-1]);\\n            if (a<M-1 && grid[a+1][b] && find_root(i+N) != -1) nei.insert(root[i+N]);\\n            if (b<N-1 && grid[a][b+1] && find_root(i+1) != -1) nei.insert(root[i+1]);\\n            for (int n : nei) affect[n] ++;\\n        }\\n        int maxUnion = -1, mayAffect = 0, maxAffect = 0;\\n        for (int r=0; r<K; r++) {\\n            if (affect[r] > maxAffect) {\\n                maxAffect = affect[r];\\n                maxUnion = r;\\n            }\\n            mayAffect += affect[r];\\n        }\\n        //cout << \"maxUnion:\" << maxUnion << \", mayAffect:\" << mayAffect << endl;\\n        return {maxUnion, mayAffect};\\n    }\\n        \\n    int buildWallAndGrow(vector<vector<int>>& grid, int maxUnion) {\\n        int walls = 0;\\n        \\n        // build walls\\n        for (int i=0; i<K; i++) {\\n            int a = i / N, b = i % N;\\n            if (grid[a][b] && find_root(i) == maxUnion) {\\n                if (a>0   && !grid[a-1][b]) walls ++;\\n                if (b>0   && !grid[a][b-1]) walls ++;\\n                if (a<M-1 && !grid[a+1][b]) walls ++;\\n                if (b<N-1 && !grid[a][b+1]) walls ++;\\n            }\\n        }\\n        \\n        // disable current union\\n        root[maxUnion] = -1;\\n        \\n        // growth of other unions\\n        vector<int> toAffect;\\n        for (int i=0; i<K; i++) {\\n            int a = i / N, b = i % N;\\n            if (!grid[a][b]) {\\n                if ((a>0   && grid[a-1][b] && find_root(i-N) != -1) ||\\n                    (b>0   && grid[a][b-1] && find_root(i-1) != -1) ||\\n                    (a<M-1 && grid[a+1][b] && find_root(i+N) != -1) ||\\n                    (b<N-1 && grid[a][b+1] && find_root(i+1) != -1))\\n                {\\n                    toAffect.push_back(i);\\n                }\\n            }\\n        }\\n        for (int i : toAffect) {\\n            int a = i / N, b = i % N;\\n            root[i] = i;\\n            grid[a][b] = 1;\\n            if (a>0   && grid[a-1][b] && find_root(i-N) != -1) union_set(i-N, i);\\n            if (b>0   && grid[a][b-1] && find_root(i-1) != -1) union_set(i-1, i);\\n            if (a<M-1 && grid[a+1][b] && find_root(i+N) != -1) union_set(i+N, i);\\n            if (b<N-1 && grid[a][b+1] && find_root(i+1) != -1) union_set(i+1, i);\\n        }\\n       \\n        //cout << \"Walls:\" << walls << endl;\\n        //showGrid(grid);\\n        return walls;\\n    }\\n    \\npublic:\\n    \\n    int containVirus(vector<vector<int>>& grid) {\\n        if (!(M = grid.size()) || !(N = grid[0].size())) return 0;\\n        constructUnions(grid);\\n        \\n        int walls = 0;\\n        while (true) {\\n            auto p = findMostAffect(grid);\\n            int maxUnion = p.first;\\n            int mayAffect = p.second;\\n            \\n            if (mayAffect) \\n                walls += buildWallAndGrow(grid, maxUnion); \\n            else break;\\n        }\\n        \\n        return walls;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 184047,
                "title": "java-dfs-beats-88-as-of-10-21-18",
                "content": "```\nclass Solution {\n    \n    static int[] dir = {-1, 0, 1, 0, -1};\n    \n    public int containVirus(int[][] grid) {\n        if (grid == null || grid.length == 0 || grid[0].length == 0) return 0;\n        int m = grid.length, n = grid[0].length, target = 0, walls = 0;\n        for (int[] row: grid) {\n            for (int e: row) {\n                if (e == 1) target++;\n            }\n        }\n        while (target > 0) {\n            List<Set<Integer>> zeroList = new ArrayList<>();\n            List<List<int[]>> oneList = new ArrayList<>();\n            boolean[][] visited = new boolean[m][n];\n            for (int x = 0; x < m; x++) {\n                for (int y = 0; y < n; y++) {\n                    if (grid[x][y] == 1 && !visited[x][y]) {\n                        Set<Integer> zero = new HashSet<>();\n                        List<int[]> one = new ArrayList<>();\n                        nav(x, y, grid, visited, zero, one);\n                        zeroList.add(zero);\n                        oneList.add(one);\n                    }\n                }\n            }\n            int index = -1, max = -1;\n            for (int i = 0; i < zeroList.size(); i++) {\n                Set<Integer> zeros = zeroList.get(i);\n                if (zeros.size() > max) {\n                    max = zeros.size();\n                    index = i;\n                }\n            }\n            List<int[]> ones = oneList.get(index);\n            for (int[] one: ones) {\n                grid[one[0]][one[1]] = -1;\n                for (int i = 0; i < 4; i++) {\n                    int nx = one[0] + dir[i], ny = one[1] + dir[i + 1];\n                    if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == 0) {\n                        walls++;\n                    }\n                }\n            }\n            target -= ones.size();\n            Set<Integer> merged = new HashSet<>();\n            for (int i = 0; i < zeroList.size(); i++) {\n                if (i == index) continue;\n                merged.addAll(zeroList.get(i));\n            }\n            for (int z: merged) {\n                int x = z / n, y = z % n;\n                grid[x][y] = 1;\n            }\n            target += merged.size();\n        }\n        return walls;\n    }\n    \n    private void nav(int x, int y, int[][] grid, boolean[][] visited, Set<Integer> zeros, List<int[]> ones) {\n        int m = grid.length, n = grid[0].length;\n        visited[x][y] = true;\n        ones.add(new int[] {x, y});\n        for (int i = 0; i < 4; i++) {\n            int nextX = x + dir[i], nextY = y + dir[i + 1];\n            if (nextX < 0 || nextX >= m ||\n                nextY < 0 || nextY >= n || visited[nextX][nextY]) continue;\n            if (grid[nextX][nextY] == 0) {\n                zeros.add(nextX * n + nextY);\n            } else if (grid[nextX][nextY] == 1) {\n                nav(nextX, nextY, grid, visited, zeros, ones);\n            }\n        }\n    }\n}\n```\n",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    \n    static int[] dir = {-1, 0, 1, 0, -1};\n    \n    public int containVirus(int[][] grid) {\n        if (grid == null || grid.length == 0 || grid[0].length == 0) return 0;\n        int m = grid.length, n = grid[0].length, target = 0, walls = 0;\n        for (int[] row: grid) {\n            for (int e: row) {\n                if (e == 1) target++;\n            }\n        }\n        while (target > 0) {\n            List<Set<Integer>> zeroList = new ArrayList<>();\n            List<List<int[]>> oneList = new ArrayList<>();\n            boolean[][] visited = new boolean[m][n];\n            for (int x = 0; x < m; x++) {\n                for (int y = 0; y < n; y++) {\n                    if (grid[x][y] == 1 && !visited[x][y]) {\n                        Set<Integer> zero = new HashSet<>();\n                        List<int[]> one = new ArrayList<>();\n                        nav(x, y, grid, visited, zero, one);\n                        zeroList.add(zero);\n                        oneList.add(one);\n                    }\n                }\n            }\n            int index = -1, max = -1;\n            for (int i = 0; i < zeroList.size(); i++) {\n                Set<Integer> zeros = zeroList.get(i);\n                if (zeros.size() > max) {\n                    max = zeros.size();\n                    index = i;\n                }\n            }\n            List<int[]> ones = oneList.get(index);\n            for (int[] one: ones) {\n                grid[one[0]][one[1]] = -1;\n                for (int i = 0; i < 4; i++) {\n                    int nx = one[0] + dir[i], ny = one[1] + dir[i + 1];\n                    if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == 0) {\n                        walls++;\n                    }\n                }\n            }\n            target -= ones.size();\n            Set<Integer> merged = new HashSet<>();\n            for (int i = 0; i < zeroList.size(); i++) {\n                if (i == index) continue;\n                merged.addAll(zeroList.get(i));\n            }\n            for (int z: merged) {\n                int x = z / n, y = z % n;\n                grid[x][y] = 1;\n            }\n            target += merged.size();\n        }\n        return walls;\n    }\n    \n    private void nav(int x, int y, int[][] grid, boolean[][] visited, Set<Integer> zeros, List<int[]> ones) {\n        int m = grid.length, n = grid[0].length;\n        visited[x][y] = true;\n        ones.add(new int[] {x, y});\n        for (int i = 0; i < 4; i++) {\n            int nextX = x + dir[i], nextY = y + dir[i + 1];\n            if (nextX < 0 || nextX >= m ||\n                nextY < 0 || nextY >= n || visited[nextX][nextY]) continue;\n            if (grid[nextX][nextY] == 0) {\n                zeros.add(nextX * n + nextY);\n            } else if (grid[nextX][nextY] == 1) {\n                nav(nextX, nextY, grid, visited, zeros, ones);\n            }\n        }\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 112925,
                "title": "java-union-find-solution-simulate-the-evolution",
                "content": "Just provide another way to solve the problem. Although the code is lengthy, but the idea is simple and commented inline. \\n```\\nclass Solution {\\n    public int containVirus(int[][] grid) {\\n        int rst = 0;\\n        int s = solve(grid);\\n        while (s != 0) {\\n            rst += s;\\n            s = solve(grid);\\n        }\\n        return rst;\\n    }\\n\\n    private int solve(int[][] g) {\\n        int r = g.length;\\n        int c = g[0].length;\\n        int[] uf = new int[getIdx(g, r - 1, c - 1) + 1];\\n        initUF(uf);\\n        int[][] dir = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        // First mark connected components into same group.\\n        for (int i = 0; i < r; ++i) {\\n            for (int j = 0; j < c; ++j) {\\n                if (g[i][j] <= 0) {\\n                    continue;\\n                }\\n                for (int k = 0; k < 4; ++k) {\\n                    int x = i + dir[k][0];\\n                    int y = j + dir[k][1];\\n                    if (x >= 0 && x < r && y >= 0 && y < c && g[x][y] > 0) {\\n                        union(uf, getIdx(g, x, y), getIdx(g, i, j));\\n                    }\\n                }\\n            }\\n        }\\n        // blankSets, key is group index, value set contains all adjacent 0s.\\n        Map<Integer, Set<Integer>> blankSets = new HashMap<>();\\n        // wallCounts, key is group index, value is count of walls to build.\\n        Map<Integer, Integer> wallCounts = new HashMap<>();\\n        // And then iterate graph, count adjacent 0s and walls to build.\\n        for (int i = 0; i < r; ++i) {\\n            for (int j = 0; j < c; ++j) {\\n                if (g[i][j] <= 0) {\\n                    continue;\\n                }\\n                int idx = find(uf, getIdx(g, i, j));\\n                if (!blankSets.containsKey(idx)) {\\n                    blankSets.put(idx, new HashSet<>());\\n                }\\n                for (int k = 0; k < 4; ++k) {\\n                    int x = i + dir[k][0];\\n                    int y = j + dir[k][1];\\n                    if (x >= 0 && x < r && y >= 0 && y < c && g[x][y] == 0) {\\n                        int blankIdx = getIdx(g, x, y);\\n                        blankSets.get(idx).add(blankIdx);\\n                        wallCounts.put(idx, wallCounts.getOrDefault(idx, 0) + 1);\\n                    }\\n                }\\n            }\\n        }\\n        // And then find the connected component with max adjacent 0s.\\n        int maxIdx = 0;\\n        int maxSize = 0;\\n        int walls = 0;\\n        for (int idx : blankSets.keySet()) {\\n            Set<Integer> s = blankSets.get(idx);\\n            if (s.size() > maxSize) {\\n                maxSize = s.size();\\n                maxIdx = idx;\\n                walls = wallCounts.get(idx);\\n            }\\n        }\\n        if (maxSize == 0) {\\n            return 0;\\n        }\\n        // And finally, update the graph in-place, mark contained virus to be -1, \\n        // and spread other virus to adjacent 0s.\\n        int[][] tmp = cp(g);\\n        for (int i = 0; i < r; ++i) {\\n            for (int j = 0; j < c; ++j) {\\n                if (tmp[i][j] <= 0) {\\n                    continue;\\n                }\\n                int idx = find(uf, getIdx(g, i, j));\\n                if (idx == maxIdx) {\\n                    g[i][j] = -1;\\n                    continue;\\n                }\\n                for (int k = 0; k < 4; ++k) {\\n                    int x = i + dir[k][0];\\n                    int y = j + dir[k][1];\\n                    if (x >= 0 && x < r && y >= 0 && y < c && tmp[x][y] == 0) {\\n                        g[x][y] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        return walls;\\n    }\\n\\n    // 2d to 1d index mapping.\\n    private int getIdx(int[][] g, int x, int y) {\\n        return g[0].length * x + y;\\n    }\\n\\n    // methods for union find set.\\n    private void initUF(int[] uf) {\\n        for (int i = 0; i < uf.length; ++i) {\\n            uf[i] = i;\\n        }\\n    }\\n\\n    private int find(int[] uf, int a) {\\n        if (uf[a] == a) {\\n            return a;\\n        }\\n        int r = find(uf, uf[a]);\\n        uf[a] = r;\\n        return r;\\n    }\\n\\n    private void union(int[] uf, int a, int b) {\\n        int ga = find(uf, a);\\n        int gb = find(uf, b);\\n        uf[gb] = ga;\\n    }\\n\\n    private int[][] cp(int[][] g) {\\n        int[][] r = new int[g.length][g[0].length];\\n        for (int i = 0; i < g.length; ++i) {\\n            for (int j = 0; j < g[0].length; ++j) {\\n                r[i][j] = g[i][j];\\n            }\\n        }\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int containVirus(int[][] grid) {\\n        int rst = 0;\\n        int s = solve(grid);\\n        while (s != 0) {\\n            rst += s;\\n            s = solve(grid);\\n        }\\n        return rst;\\n    }\\n\\n    private int solve(int[][] g) {\\n        int r = g.length;\\n        int c = g[0].length;\\n        int[] uf = new int[getIdx(g, r - 1, c - 1) + 1];\\n        initUF(uf);\\n        int[][] dir = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        // First mark connected components into same group.\\n        for (int i = 0; i < r; ++i) {\\n            for (int j = 0; j < c; ++j) {\\n                if (g[i][j] <= 0) {\\n                    continue;\\n                }\\n                for (int k = 0; k < 4; ++k) {\\n                    int x = i + dir[k][0];\\n                    int y = j + dir[k][1];\\n                    if (x >= 0 && x < r && y >= 0 && y < c && g[x][y] > 0) {\\n                        union(uf, getIdx(g, x, y), getIdx(g, i, j));\\n                    }\\n                }\\n            }\\n        }\\n        // blankSets, key is group index, value set contains all adjacent 0s.\\n        Map<Integer, Set<Integer>> blankSets = new HashMap<>();\\n        // wallCounts, key is group index, value is count of walls to build.\\n        Map<Integer, Integer> wallCounts = new HashMap<>();\\n        // And then iterate graph, count adjacent 0s and walls to build.\\n        for (int i = 0; i < r; ++i) {\\n            for (int j = 0; j < c; ++j) {\\n                if (g[i][j] <= 0) {\\n                    continue;\\n                }\\n                int idx = find(uf, getIdx(g, i, j));\\n                if (!blankSets.containsKey(idx)) {\\n                    blankSets.put(idx, new HashSet<>());\\n                }\\n                for (int k = 0; k < 4; ++k) {\\n                    int x = i + dir[k][0];\\n                    int y = j + dir[k][1];\\n                    if (x >= 0 && x < r && y >= 0 && y < c && g[x][y] == 0) {\\n                        int blankIdx = getIdx(g, x, y);\\n                        blankSets.get(idx).add(blankIdx);\\n                        wallCounts.put(idx, wallCounts.getOrDefault(idx, 0) + 1);\\n                    }\\n                }\\n            }\\n        }\\n        // And then find the connected component with max adjacent 0s.\\n        int maxIdx = 0;\\n        int maxSize = 0;\\n        int walls = 0;\\n        for (int idx : blankSets.keySet()) {\\n            Set<Integer> s = blankSets.get(idx);\\n            if (s.size() > maxSize) {\\n                maxSize = s.size();\\n                maxIdx = idx;\\n                walls = wallCounts.get(idx);\\n            }\\n        }\\n        if (maxSize == 0) {\\n            return 0;\\n        }\\n        // And finally, update the graph in-place, mark contained virus to be -1, \\n        // and spread other virus to adjacent 0s.\\n        int[][] tmp = cp(g);\\n        for (int i = 0; i < r; ++i) {\\n            for (int j = 0; j < c; ++j) {\\n                if (tmp[i][j] <= 0) {\\n                    continue;\\n                }\\n                int idx = find(uf, getIdx(g, i, j));\\n                if (idx == maxIdx) {\\n                    g[i][j] = -1;\\n                    continue;\\n                }\\n                for (int k = 0; k < 4; ++k) {\\n                    int x = i + dir[k][0];\\n                    int y = j + dir[k][1];\\n                    if (x >= 0 && x < r && y >= 0 && y < c && tmp[x][y] == 0) {\\n                        g[x][y] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        return walls;\\n    }\\n\\n    // 2d to 1d index mapping.\\n    private int getIdx(int[][] g, int x, int y) {\\n        return g[0].length * x + y;\\n    }\\n\\n    // methods for union find set.\\n    private void initUF(int[] uf) {\\n        for (int i = 0; i < uf.length; ++i) {\\n            uf[i] = i;\\n        }\\n    }\\n\\n    private int find(int[] uf, int a) {\\n        if (uf[a] == a) {\\n            return a;\\n        }\\n        int r = find(uf, uf[a]);\\n        uf[a] = r;\\n        return r;\\n    }\\n\\n    private void union(int[] uf, int a, int b) {\\n        int ga = find(uf, a);\\n        int gb = find(uf, b);\\n        uf[gb] = ga;\\n    }\\n\\n    private int[][] cp(int[][] g) {\\n        int[][] r = new int[g.length][g[0].length];\\n        for (int i = 0; i < g.length; ++i) {\\n            for (int j = 0; j < g[0].length; ++j) {\\n                r[i][j] = g[i][j];\\n            }\\n        }\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 110181,
                "title": "749-contain-virus-c-ac-16ms-dfs",
                "content": "Pretty straightforward problem, by using DFS and following the requirements of this problem.\\n\\n    class Solution {\\n    public:\\n    int containVirus(vector<vector<int>>& grid) {\\n        if(grid.empty()) return 0;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int res = 0;\\n        //The number of rows and columns of grid will each be in the range [1, 50]. i*100 + j as the \"index number\"\\n        while(true){\\n            vector<vector<bool>> check(m, vector<bool>(n, false));\\n            //for dfs, find the continuous region\\n\\n            unordered_map<int, unordered_set<int>> cells;\\n            // the cells(value = 0) will be affected by the region\\n\\n            unordered_map<int, int> length;\\n            //the length of each region\\n            \\n            int max_region_id = 0;\\n            int max_region_length = 0;\\n            int max_region_cells = 0;\\n            for(int i = 0; i < m; ++i){\\n                for(int j = 0; j < n; ++j){\\n                    if(grid[i][j] == 1 && !check[i][j]) {//go into the region search\\n                        int id = i * 100 + j;\\n                        find_bound(grid, length, check, i, j, m, n, cells, id);\\n                        if(length[id]){\\n                                if(cells[id].size() > max_region_cells){\\n          //if the current region is much more serious\\n                                    max_region_cells = cells[id].size();\\n                                    max_region_length = length[id];\\n                                    max_region_id = id;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            if(max_region_length == 0) break;\\n            res += max_region_length;\\n            set_wall(grid, max_region_id/100, max_region_id%100, m, n);\\n            cells.erase(max_region_id);\\n            for(auto v : cells){\\n                update(grid, v.second, m, n);\\n            }\\n        }\\n        return res;\\n        \\n    }\\n    void set_wall(vector<vector<int>>& grid, int i, int j, int m, int n){\\n        grid[i][j] = -1;\\n        if(i-1 >= 0 && grid[i-1][j] == 1) set_wall(grid, i-1, j, m, n);\\n        if(i+1 < m && grid[i+1][j] == 1) set_wall(grid, i+1, j, m, n);\\n        if(j-1 >= 0 && grid[i][j-1] == 1) set_wall(grid, i, j-1, m, n);\\n        if(j+1 < n && grid[i][j+1] == 1) set_wall(grid, i, j+1, m, n);\\n    }\\n    \\n    void find_bound(vector<vector<int>>& grid, unordered_map<int, int>& length, vector<vector<bool>>& check, int i, int j, int m, int n, unordered_map<int, unordered_set<int>>& cells, int id){\\n        check[i][j] = true;\\n        if(i-1 >= 0 && grid[i-1][j] == 0) {length[id]++; cells[id].insert((i-1)*100 + j);}\\n        if(j-1 >= 0 && grid[i][j-1] == 0) {length[id]++; cells[id].insert(i*100 + j-1);}\\n        if(i+1 < m && grid[i+1][j] == 0) {length[id]++; cells[id].insert((i+1)*100 + j);}\\n        if(j+1 < n && grid[i][j+1] == 0) {length[id]++; cells[id].insert(i*100 + j + 1);}\\n        if(i-1 >= 0 && grid[i-1][j] == 1 && !check[i-1][j]) find_bound(grid, length, check, i-1, j, m, n, cells, id);\\n        if(j-1 >= 0 && grid[i][j-1] == 1 && !check[i][j-1]) find_bound(grid, length, check, i, j-1, m, n, cells, id);\\n        if(i+1 < m && grid[i+1][j] == 1 && !check[i+1][j]) find_bound(grid, length, check, i+1, j, m, n, cells, id);\\n        if(j+1 < n && grid[i][j+1] == 1 && !check[i][j+1]) find_bound(grid, length, check, i, j+1, m, n, cells, id);\\n    }\\n    \\n    void update(vector<vector<int>>& grid, unordered_set<int>& bound, int m, int n){\\n        for(auto idx : bound){\\n            int i = idx/100;\\n            int j = idx%100;\\n            grid[i][j] = 1;\\n        }\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int containVirus(vector<vector<int>>& grid) {\\n        if(grid.empty()) return 0;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int res = 0;\\n        //The number of rows and columns of grid will each be in the range [1, 50]. i*100 + j as the \"index number\"\\n        while(true){\\n            vector<vector<bool>> check(m, vector<bool>(n, false));\\n            //for dfs, find the continuous region\\n\\n            unordered_map<int, unordered_set<int>> cells;\\n            // the cells(value = 0) will be affected by the region\\n\\n            unordered_map<int, int> length;\\n            //the length of each region\\n            \\n            int max_region_id = 0;\\n            int max_region_length = 0;\\n            int max_region_cells = 0;\\n            for(int i = 0; i < m; ++i){\\n                for(int j = 0; j < n; ++j){\\n                    if(grid[i][j] == 1 && !check[i][j]) {//go into the region search\\n                        int id = i * 100 + j;\\n                        find_bound(grid, length, check, i, j, m, n, cells, id);\\n                        if(length[id]){\\n                                if(cells[id].size() > max_region_cells){\\n          //if the current region is much more serious\\n                                    max_region_cells = cells[id].size();\\n                                    max_region_length = length[id];\\n                                    max_region_id = id;\\n                            }",
                "codeTag": "Java"
            },
            {
                "id": 110187,
                "title": "my-ugly-java-dfs-solution-19-ms-with-explaination",
                "content": "The test case 3 is wrong. It should be 13 instead of 11.\\nThe idea is to use dfs for each group of virus to find out how many cells will be infected and how many walls will be needed. If an adjacent good cells has been visited, next time it is reached by dfs, the count for walls still need to increase 1.\\nThen we selected the group of virus with maximum number of new cells to be infected, and label/fix them. We keep this process until no new cells will be infected, which means either the spread is stopped or all the cells are infected.\\n```\\nclass Solution {\\n    int[][] dir = {{0,1},{0,-1},{-1,0},{1,0}};\\n    int m, n;\\n    public int containVirus(int[][] grid) {\\n    \\tm = grid.length; n = grid[0].length;\\n    \\tint res = 0;\\n    \\twhile (true) {\\n\\t    \\tboolean [][] v = new boolean[m][n];\\n\\t    \\tint[] cur = new int[4];\\t\\t// cur[0] represents how many cell will be infected by this group tomorrow, cur[1] represents how many walls will be built if this group is chosen. cur[2] and cur[3] represents the start of the selected group   \\n\\t    \\tfor (int i=0;i<m;i++) {\\n\\t    \\t\\tfor (int j=0;j<n;j++) {\\n\\t    \\t\\t\\tif (grid[i][j]==1 && !v[i][j]) {\\n\\t    \\t\\t\\t\\tboolean[][] z = new boolean[m][n];\\t// z[i][j] represents if the cell is checked. if it's checked, cur[0] won't be counted, but cur[1] still need to increase 1;\\n\\t    \\t\\t\\t\\tint[] rt = new int[2];\\n\\t    \\t\\t\\t\\tdfs(grid,v,z,rt,i,j);\\n\\t    \\t\\t\\t\\tif (rt[0]>cur[0]) {\\n\\t    \\t\\t\\t\\t\\tcur[0] = rt[0];\\n\\t    \\t\\t\\t\\t\\tcur[1] = rt[1];\\n\\t    \\t\\t\\t\\t\\tcur[2] = i;\\n\\t    \\t\\t\\t\\t\\tcur[3] = j;\\n\\t    \\t\\t\\t\\t}\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n\\t    \\t}\\n\\t    \\tif (cur[0] == 0) {\\n\\t    \\t\\treturn res;\\n\\t    \\t}\\n\\t    \\tres += cur[1];\\n\\t    \\tdfs1(grid, cur[2], cur[3]);\\n\\t    \\tfor (int i=0;i<m;i++) {\\n\\t    \\t\\tfor (int j=0;j<n;j++) {\\n\\t    \\t\\t\\tif (grid[i][j]==0) {\\n\\t    \\t\\t\\t\\tfor(int k=0;k<4;k++) {\\n\\t    \\t\\t    \\t\\tint x = i+dir[k][0], y = j+dir[k][1];\\n\\t    \\t\\t    \\t\\tif (x>=0 && x<m && y>=0 && y<n) {\\n\\t    \\t\\t    \\t\\t\\tif (grid[x][y]==1) {\\n\\t    \\t\\t    \\t\\t\\t\\tgrid[i][j] = 3;\\n\\t    \\t\\t    \\t\\t\\t\\tbreak;\\n\\t    \\t\\t    \\t\\t\\t}\\n\\t    \\t\\t    \\t\\t}\\n\\t    \\t\\t\\t\\t}\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n    \\t\\t}\\n\\t    \\tfor (int i=0;i<m;i++) {\\n\\t    \\t\\tfor (int j=0;j<n;j++) {\\n\\t    \\t\\t\\tif (grid[i][j]==3) {\\n\\t    \\t\\t\\t\\tgrid[i][j]=1;\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n    \\t\\t}\\n    \\t}\\n    }\\n    void dfs1(int[][]grid, int i, int j) {\\t\\t// change the selected cells from 1 to 2. these cells will be fixed and we won't touch them anymore. \\n    \\tgrid[i][j] = 2;\\n    \\tfor(int k=0;k<4;k++) {\\n    \\t\\tint x = i+dir[k][0], y = j+dir[k][1];\\n    \\t\\tif (x>=0 && x<m && y>=0 && y<n) {\\n    \\t\\t\\tif (grid[x][y]==1) {\\n    \\t\\t\\t\\tdfs1(grid,x,y);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    }\\n    void dfs(int[][]grid, boolean[][]v, boolean[][] z, int[] rt,int i, int j) {\\n    \\tint[] res = new int[2];\\n    \\tv[i][j] = true;\\n    \\tfor(int k=0;k<4;k++) {\\n    \\t\\tint x = i+dir[k][0], y = j+dir[k][1];\\n    \\t\\tif (x>=0 && x<m && y>=0 && y<n) {\\n    \\t\\t\\tif (grid[x][y]==0) {\\n    \\t\\t\\t\\trt[1]++;\\n    \\t\\t\\t\\tif (!z[x][y]) {\\n    \\t\\t\\t\\t\\tz[x][y] = true;\\n    \\t\\t\\t\\t\\trt[0]++;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t\\tif (grid[x][y]==1 && !v[x][y]) {\\n    \\t\\t\\t\\tdfs(grid,v,z,rt,x,y);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] dir = {{0,1},{0,-1},{-1,0},{1,0}};\\n    int m, n;\\n    public int containVirus(int[][] grid) {\\n    \\tm = grid.length; n = grid[0].length;\\n    \\tint res = 0;\\n    \\twhile (true) {\\n\\t    \\tboolean [][] v = new boolean[m][n];\\n\\t    \\tint[] cur = new int[4];\\t\\t// cur[0] represents how many cell will be infected by this group tomorrow, cur[1] represents how many walls will be built if this group is chosen. cur[2] and cur[3] represents the start of the selected group   \\n\\t    \\tfor (int i=0;i<m;i++) {\\n\\t    \\t\\tfor (int j=0;j<n;j++) {\\n\\t    \\t\\t\\tif (grid[i][j]==1 && !v[i][j]) {\\n\\t    \\t\\t\\t\\tboolean[][] z = new boolean[m][n];\\t// z[i][j] represents if the cell is checked. if it's checked, cur[0] won't be counted, but cur[1] still need to increase 1;\\n\\t    \\t\\t\\t\\tint[] rt = new int[2];\\n\\t    \\t\\t\\t\\tdfs(grid,v,z,rt,i,j);\\n\\t    \\t\\t\\t\\tif (rt[0]>cur[0]) {\\n\\t    \\t\\t\\t\\t\\tcur[0] = rt[0];\\n\\t    \\t\\t\\t\\t\\tcur[1] = rt[1];\\n\\t    \\t\\t\\t\\t\\tcur[2] = i;\\n\\t    \\t\\t\\t\\t\\tcur[3] = j;\\n\\t    \\t\\t\\t\\t}\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n\\t    \\t}\\n\\t    \\tif (cur[0] == 0) {\\n\\t    \\t\\treturn res;\\n\\t    \\t}\\n\\t    \\tres += cur[1];\\n\\t    \\tdfs1(grid, cur[2], cur[3]);\\n\\t    \\tfor (int i=0;i<m;i++) {\\n\\t    \\t\\tfor (int j=0;j<n;j++) {\\n\\t    \\t\\t\\tif (grid[i][j]==0) {\\n\\t    \\t\\t\\t\\tfor(int k=0;k<4;k++) {\\n\\t    \\t\\t    \\t\\tint x = i+dir[k][0], y = j+dir[k][1];\\n\\t    \\t\\t    \\t\\tif (x>=0 && x<m && y>=0 && y<n) {\\n\\t    \\t\\t    \\t\\t\\tif (grid[x][y]==1) {\\n\\t    \\t\\t    \\t\\t\\t\\tgrid[i][j] = 3;\\n\\t    \\t\\t    \\t\\t\\t\\tbreak;\\n\\t    \\t\\t    \\t\\t\\t}\\n\\t    \\t\\t    \\t\\t}\\n\\t    \\t\\t\\t\\t}\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n    \\t\\t}\\n\\t    \\tfor (int i=0;i<m;i++) {\\n\\t    \\t\\tfor (int j=0;j<n;j++) {\\n\\t    \\t\\t\\tif (grid[i][j]==3) {\\n\\t    \\t\\t\\t\\tgrid[i][j]=1;\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n    \\t\\t}\\n    \\t}\\n    }\\n    void dfs1(int[][]grid, int i, int j) {\\t\\t// change the selected cells from 1 to 2. these cells will be fixed and we won't touch them anymore. \\n    \\tgrid[i][j] = 2;\\n    \\tfor(int k=0;k<4;k++) {\\n    \\t\\tint x = i+dir[k][0], y = j+dir[k][1];\\n    \\t\\tif (x>=0 && x<m && y>=0 && y<n) {\\n    \\t\\t\\tif (grid[x][y]==1) {\\n    \\t\\t\\t\\tdfs1(grid,x,y);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    }\\n    void dfs(int[][]grid, boolean[][]v, boolean[][] z, int[] rt,int i, int j) {\\n    \\tint[] res = new int[2];\\n    \\tv[i][j] = true;\\n    \\tfor(int k=0;k<4;k++) {\\n    \\t\\tint x = i+dir[k][0], y = j+dir[k][1];\\n    \\t\\tif (x>=0 && x<m && y>=0 && y<n) {\\n    \\t\\t\\tif (grid[x][y]==0) {\\n    \\t\\t\\t\\trt[1]++;\\n    \\t\\t\\t\\tif (!z[x][y]) {\\n    \\t\\t\\t\\t\\tz[x][y] = true;\\n    \\t\\t\\t\\t\\trt[0]++;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t\\tif (grid[x][y]==1 && !v[x][y]) {\\n    \\t\\t\\t\\tdfs(grid,v,z,rt,x,y);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 110180,
                "title": "naive-c-solution-using-bfs",
                "content": "Just follow the instruction of the problem. You can run it to see the output of every stage. Hope to find a more elegant algorithm.\\n```\\nclass Solution {\\npublic:\\n    int containVirus(vector<vector<int>>& grid) {\\n        size_t row = grid.size(), col = grid[0].size();\\n        int dirs[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        \\n        vector<vector<bool>> control = vector<vector<bool>>(row, vector<bool>(col, false));\\n        int numWalls = 0;\\n        while (true) {\\n            vector<vector<bool>> visited = vector<vector<bool>>(row, vector<bool>(col, false));\\n            vector<vector<int>> infection = vector<vector<int>>(row, vector<int>(col, 0));\\n            int mostInfection = 0;\\n            for (int x = 0; x < row; x++) {\\n                for (int y = 0; y < col; y++) {\\n                    if (!control[x][y] && !visited[x][y] && grid[x][y] == 1) {\\n                        vector<vector<bool>> infectionVisited = vector<vector<bool>>(row, vector<bool>(col, false));\\n                        visited[x][y] = true;\\n                        int infectionSize = 0;\\n                        queue<pair<int, int>> bfs;\\n                        bfs.push({x, y});\\n                        while (!bfs.empty()) {\\n                            auto point = bfs.front();\\n                            int px = point.first, py = point.second;\\n                            bfs.pop();\\n                            \\n                            for (size_t i = 0; i < 4; i++) {\\n                                int newx = px + dirs[i][0], newy = py + dirs[i][1];\\n                                if (newx >= 0 && newx < row && newy >= 0 && newy < col) {\\n                                    if (!control[newx][newy] && !visited[newx][newy]) {\\n                                        if (grid[newx][newy] == 1) {\\n                                            visited[newx][newy] = true;\\n                                            bfs.push({newx, newy});\\n                                        } else if (!infectionVisited[newx][newy]){\\n                                            infectionVisited[newx][newy] = true;\\n                                            infectionSize ++;\\n                                        }\\n                                    }\\n                                }\\n                            }\\n                        }\\n                        cout << \"(\" << x << \", \" << y << \") infects: \" << infectionSize << endl;\\n                        infection[x][y] = infectionSize;\\n                        mostInfection = max(mostInfection, infectionSize);\\n                    }\\n                }\\n            }\\n            \\n            if (mostInfection == 0) {\\n                break;\\n            }\\n            \\n            for (int x = 0; x < row; x++) {\\n                bool complete = false;\\n                for (int y = 0; y < col; y++) {\\n                    if (infection[x][y] == mostInfection) {\\n                        visited = vector<vector<bool>>(row, vector<bool>(col, false));\\n                        visited[x][y] = true;\\n                        queue<pair<int, int>> bfs;\\n                        bfs.push({x, y});\\n                        while (!bfs.empty()) {\\n                            auto point = bfs.front();\\n                            int px = point.first, py = point.second;\\n                            bfs.pop();\\n                            \\n                            control[x][y] = true;\\n                            for (size_t i = 0; i < 4; i++) {\\n                                int newx = px + dirs[i][0], newy = py + dirs[i][1];\\n                                if (newx >= 0 && newx < row && newy >= 0 && newy < col) {\\n                                    if (!control[newx][newy] && !visited[newx][newy]) {\\n                                        if (grid[newx][newy] == 1) {\\n                                            control[newx][newy] = true;\\n                                            visited[newx][newy] = true;\\n                                            bfs.push({newx, newy});\\n                                        } else {\\n                                            numWalls ++;\\n                                        }\\n                                    }\\n                                }\\n                            }\\n                        }\\n                        infection[x][y] = 0;\\n                        complete = true;\\n                        break;\\n                    }\\n                }\\n                if (complete) {\\n                    break;\\n                }\\n            }\\n            cout << \"Walls: \" << numWalls << endl;\\n            \\n            vector<vector<int>> newGrid = grid;\\n            for (int x = 0; x < row; x++) {\\n                for (int y = 0; y < col; y++) {\\n                    if (infection[x][y] > 0) {\\n                        visited = vector<vector<bool>>(row, vector<bool>(col, false));\\n                        visited[x][y] = true;\\n                        queue<pair<int, int>> bfs;\\n                        bfs.push({x, y});\\n                        while (!bfs.empty()) {\\n                            auto point = bfs.front();\\n                            int px = point.first, py = point.second;\\n                            bfs.pop();\\n                            \\n                            for (size_t i = 0; i < 4; i++) {\\n                                int newx = px + dirs[i][0], newy = py + dirs[i][1];\\n                                if (newx >= 0 && newx < row && newy >= 0 && newy < col) {\\n                                    if (!control[newx][newy] && !visited[newx][newy]) {\\n                                        if (grid[newx][newy] == 1) {\\n                                            visited[newx][newy] = true;\\n                                            bfs.push({newx, newy});\\n                                        } else {\\n                                            newGrid[newx][newy] = 1;\\n                                        }\\n                                    }\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            grid = newGrid;\\n            for (auto line : newGrid) {\\n                for (auto item : line) {\\n                    cout << item << ' ';\\n                }\\n                cout << endl;\\n            }\\n            cout << \"===\" << endl;\\n        }\\n        return numWalls;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int containVirus(vector<vector<int>>& grid) {\\n        size_t row = grid.size(), col = grid[0].size();\\n        int dirs[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        \\n        vector<vector<bool>> control = vector<vector<bool>>(row, vector<bool>(col, false));\\n        int numWalls = 0;\\n        while (true) {\\n            vector<vector<bool>> visited = vector<vector<bool>>(row, vector<bool>(col, false));\\n            vector<vector<int>> infection = vector<vector<int>>(row, vector<int>(col, 0));\\n            int mostInfection = 0;\\n            for (int x = 0; x < row; x++) {\\n                for (int y = 0; y < col; y++) {\\n                    if (!control[x][y] && !visited[x][y] && grid[x][y] == 1) {\\n                        vector<vector<bool>> infectionVisited = vector<vector<bool>>(row, vector<bool>(col, false));\\n                        visited[x][y] = true;\\n                        int infectionSize = 0;\\n                        queue<pair<int, int>> bfs;\\n                        bfs.push({x, y});\\n                        while (!bfs.empty()) {\\n                            auto point = bfs.front();\\n                            int px = point.first, py = point.second;\\n                            bfs.pop();\\n                            \\n                            for (size_t i = 0; i < 4; i++) {\\n                                int newx = px + dirs[i][0], newy = py + dirs[i][1];\\n                                if (newx >= 0 && newx < row && newy >= 0 && newy < col) {\\n                                    if (!control[newx][newy] && !visited[newx][newy]) {\\n                                        if (grid[newx][newy] == 1) {\\n                                            visited[newx][newy] = true;\\n                                            bfs.push({newx, newy});\\n                                        } else if (!infectionVisited[newx][newy]){\\n                                            infectionVisited[newx][newy] = true;\\n                                            infectionSize ++;\\n                                        }\\n                                    }\\n                                }\\n                            }\\n                        }\\n                        cout << \"(\" << x << \", \" << y << \") infects: \" << infectionSize << endl;\\n                        infection[x][y] = infectionSize;\\n                        mostInfection = max(mostInfection, infectionSize);\\n                    }\\n                }\\n            }\\n            \\n            if (mostInfection == 0) {\\n                break;\\n            }\\n            \\n            for (int x = 0; x < row; x++) {\\n                bool complete = false;\\n                for (int y = 0; y < col; y++) {\\n                    if (infection[x][y] == mostInfection) {\\n                        visited = vector<vector<bool>>(row, vector<bool>(col, false));\\n                        visited[x][y] = true;\\n                        queue<pair<int, int>> bfs;\\n                        bfs.push({x, y});\\n                        while (!bfs.empty()) {\\n                            auto point = bfs.front();\\n                            int px = point.first, py = point.second;\\n                            bfs.pop();\\n                            \\n                            control[x][y] = true;\\n                            for (size_t i = 0; i < 4; i++) {\\n                                int newx = px + dirs[i][0], newy = py + dirs[i][1];\\n                                if (newx >= 0 && newx < row && newy >= 0 && newy < col) {\\n                                    if (!control[newx][newy] && !visited[newx][newy]) {\\n                                        if (grid[newx][newy] == 1) {\\n                                            control[newx][newy] = true;\\n                                            visited[newx][newy] = true;\\n                                            bfs.push({newx, newy});\\n                                        } else {\\n                                            numWalls ++;\\n                                        }\\n                                    }\\n                                }\\n                            }\\n                        }\\n                        infection[x][y] = 0;\\n                        complete = true;\\n                        break;\\n                    }\\n                }\\n                if (complete) {\\n                    break;\\n                }\\n            }\\n            cout << \"Walls: \" << numWalls << endl;\\n            \\n            vector<vector<int>> newGrid = grid;\\n            for (int x = 0; x < row; x++) {\\n                for (int y = 0; y < col; y++) {\\n                    if (infection[x][y] > 0) {\\n                        visited = vector<vector<bool>>(row, vector<bool>(col, false));\\n                        visited[x][y] = true;\\n                        queue<pair<int, int>> bfs;\\n                        bfs.push({x, y});\\n                        while (!bfs.empty()) {\\n                            auto point = bfs.front();\\n                            int px = point.first, py = point.second;\\n                            bfs.pop();\\n                            \\n                            for (size_t i = 0; i < 4; i++) {\\n                                int newx = px + dirs[i][0], newy = py + dirs[i][1];\\n                                if (newx >= 0 && newx < row && newy >= 0 && newy < col) {\\n                                    if (!control[newx][newy] && !visited[newx][newy]) {\\n                                        if (grid[newx][newy] == 1) {\\n                                            visited[newx][newy] = true;\\n                                            bfs.push({newx, newy});\\n                                        } else {\\n                                            newGrid[newx][newy] = 1;\\n                                        }\\n                                    }\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            grid = newGrid;\\n            for (auto line : newGrid) {\\n                for (auto item : line) {\\n                    cout << item << ' ';\\n                }\\n                cout << endl;\\n            }\\n            cout << \"===\" << endl;\\n        }\\n        return numWalls;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4084505,
                "title": "efficient-js-solution-beat-100-both-time-and-memory",
                "content": "![image.png](https://assets.leetcode.com/users/images/493ed78a-e2d2-42ae-af85-71868c93ddda_1695554753.422481.png)\\n\\n# Intuition\\nFirst BFS, then BFS, and BFS right after that. Finally, BFS.\\n*Edit: I forgot that we also need BFS.\\n\\n# Complexity\\n- Time complexity: $$O((mn)^2)$$\\n- Space complexity: $$O(mn)$$\\n\\n# Code\\n```js\\n/**\\n * @template TItem\\n */\\nclass CircularQueue {\\n  /**\\n   * @param {number} capacity\\n   */\\n  constructor(capacity) {\\n    /**\\n     * @private\\n     * @type {number}\\n     */\\n    this._capacity = capacity;\\n    /**\\n     * @private\\n     * @type {number}\\n     */\\n    this._size = 0;\\n    /**\\n     * @private\\n     * @type {number}\\n     */\\n    this._bottom = 0;\\n\\n    /**\\n     * @private\\n     * @type {TItem[]}\\n     */\\n    this._data = Array(capacity).fill(undefined);\\n  }\\n\\n  /**\\n   * @private\\n   * @param {number} index\\n   * @returns {number}\\n   */\\n  _getCircularIndex(index) {\\n    const result = index % this._capacity;\\n    if (result < 0) result += this._capacity;\\n    return result;\\n  }\\n\\n  get capacity() {\\n    return this._capacity;\\n  }\\n\\n  get size() {\\n    return this._size;\\n  }\\n\\n  get nextItem() {\\n    return this._size ? this._data[this._bottom] : undefined;\\n  }\\n\\n  get lastItem() {\\n    return this._size\\n      ? this._data[this._getCircularIndex(this._bottom + this._size - 1)]\\n      : undefined;\\n  }\\n\\n  /**\\n   * @param  {...TItem} items\\n   */\\n  enqueue(...items) {\\n    if (this._size + items.length > this._capacity)\\n      throw new Error(\"Queue capacity exceeded.\");\\n\\n    let queueIndex = (this._bottom + this._size) % this._capacity;\\n    this._size += items.length;\\n    for (let i = 0; i < items.length; i++) {\\n      this._data[queueIndex] = items[i];\\n      queueIndex = (queueIndex + 1) % this._capacity;\\n    }\\n  }\\n\\n  /**\\n   * @returns {TItem | undefined}\\n   */\\n  dequeue() {\\n    if (!this._size) return undefined;\\n\\n    const result = this._data[this._bottom];\\n    this._bottom = (this._bottom + 1) % this._capacity;\\n    this._size--;\\n\\n    return result;\\n  }\\n\\n  clear() {\\n    this._size = 0;\\n  }\\n}\\n\\nconst qr = new CircularQueue(2500);\\nconst qc = new CircularQueue(2500);\\n\\nconst threats = [];\\nconst fences = [];\\nfunction initLabel(x) {\\n  while (x >= threats.length) {\\n    threats.push(0);\\n    fences.push(0);\\n  }\\n  threats[x] = 0;\\n  fences[x] = 0;\\n}\\n\\nconst DIR_R = [0, 0, 1, -1];\\nconst DIR_C = [1, -1, 0, 0];\\n\\n/**\\n * guideline:\\n * &7\\n * 0: uninfected and not (yet) threaten\\n * 1: infected but unvisited\\n * 2: infected and visited\\n * 3: uninfected and threaten\\n * 4: locked up\\n * >>3\\n * label\\n */\\n\\n/**\\n * @param {number[][]} isInfected\\n * @return {number}\\n */\\nvar containVirus = function (isInfected) {\\n  let n = isInfected[0].length;\\n  let m = isInfected.length;\\n  let label = 0;\\n  let res = 0;\\n\\n  function bfs(ir, ic, label) {\\n    qr.enqueue(ir);\\n    qc.enqueue(ic);\\n    let labelState = (label << 3) | 2;\\n    isInfected[ir][ic] = labelState;\\n    initLabel(label);\\n\\n    while (qr.size) {\\n      let r = qr.dequeue();\\n      let c = qc.dequeue();\\n\\n      for (let i = 0; i < 4; i++) {\\n        let rr = r + DIR_R[i];\\n        let cc = c + DIR_C[i];\\n        let state = isInfected[rr]?.[cc];\\n        if (state == undefined) continue;\\n\\n        switch (state & 7) {\\n          case 0: {\\n            isInfected[rr][cc] = (label << 3) | 3;\\n            fences[label]++;\\n            threats[label]++;\\n            break;\\n          }\\n          case 1: {\\n            qr.enqueue(rr);\\n            qc.enqueue(cc);\\n            isInfected[rr][cc] = labelState;\\n            break;\\n          }\\n          case 3: {\\n            fences[label]++;\\n            if ((state >> 3) != label) {\\n              threats[label]++;\\n              isInfected[rr][cc] = (label << 3) | 3;\\n            }\\n            break;\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  function isStillThreaten(r, c, lockedLabel) {\\n    for (let i = 0; i < 4; i++) {\\n      let rr = r + DIR_R[i];\\n      let cc = c + DIR_C[i];\\n      let state = isInfected[rr]?.[cc];\\n      if ((state & 7) == 2 && (state >> 3) != lockedLabel) return true;\\n    }\\n  }\\n\\n  while (true) {\\n    label = 0;\\n    let lockedLabel = 0;\\n\\n    for (let r = 0; r < m; r++) {\\n      for (let c = 0; c < n; c++) {\\n        if (isInfected[r][c] == 1) {\\n          bfs(r, c, label);\\n          if (threats[label] > threats[lockedLabel]) lockedLabel = label;\\n          label++;\\n        }\\n      }\\n    }\\n\\n    if (!label) return res;\\n\\n    res += fences[lockedLabel];\\n\\n    for (let r = 0; r < m; r++) {\\n      for (let c = 0; c < n; c++) {\\n        if ((isInfected[r][c] & 7) == 3) {\\n          if (isStillThreaten(r, c, lockedLabel)) isInfected[r][c] = 1;\\n          else isInfected[r][c] = 0;\\n        }\\n      }\\n    }\\n\\n    for (let r = 0; r < m; r++) {\\n      for (let c = 0; c < n; c++) {\\n        let state = isInfected[r][c];\\n        if ((state & 7) == 2) {\\n          if ((state >> 3) == lockedLabel) isInfected[r][c] = 4;\\n          else isInfected[r][c] = 1;\\n        }\\n      }\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```js\\n/**\\n * @template TItem\\n */\\nclass CircularQueue {\\n  /**\\n   * @param {number} capacity\\n   */\\n  constructor(capacity) {\\n    /**\\n     * @private\\n     * @type {number}\\n     */\\n    this._capacity = capacity;\\n    /**\\n     * @private\\n     * @type {number}\\n     */\\n    this._size = 0;\\n    /**\\n     * @private\\n     * @type {number}\\n     */\\n    this._bottom = 0;\\n\\n    /**\\n     * @private\\n     * @type {TItem[]}\\n     */\\n    this._data = Array(capacity).fill(undefined);\\n  }\\n\\n  /**\\n   * @private\\n   * @param {number} index\\n   * @returns {number}\\n   */\\n  _getCircularIndex(index) {\\n    const result = index % this._capacity;\\n    if (result < 0) result += this._capacity;\\n    return result;\\n  }\\n\\n  get capacity() {\\n    return this._capacity;\\n  }\\n\\n  get size() {\\n    return this._size;\\n  }\\n\\n  get nextItem() {\\n    return this._size ? this._data[this._bottom] : undefined;\\n  }\\n\\n  get lastItem() {\\n    return this._size\\n      ? this._data[this._getCircularIndex(this._bottom + this._size - 1)]\\n      : undefined;\\n  }\\n\\n  /**\\n   * @param  {...TItem} items\\n   */\\n  enqueue(...items) {\\n    if (this._size + items.length > this._capacity)\\n      throw new Error(\"Queue capacity exceeded.\");\\n\\n    let queueIndex = (this._bottom + this._size) % this._capacity;\\n    this._size += items.length;\\n    for (let i = 0; i < items.length; i++) {\\n      this._data[queueIndex] = items[i];\\n      queueIndex = (queueIndex + 1) % this._capacity;\\n    }\\n  }\\n\\n  /**\\n   * @returns {TItem | undefined}\\n   */\\n  dequeue() {\\n    if (!this._size) return undefined;\\n\\n    const result = this._data[this._bottom];\\n    this._bottom = (this._bottom + 1) % this._capacity;\\n    this._size--;\\n\\n    return result;\\n  }\\n\\n  clear() {\\n    this._size = 0;\\n  }\\n}\\n\\nconst qr = new CircularQueue(2500);\\nconst qc = new CircularQueue(2500);\\n\\nconst threats = [];\\nconst fences = [];\\nfunction initLabel(x) {\\n  while (x >= threats.length) {\\n    threats.push(0);\\n    fences.push(0);\\n  }\\n  threats[x] = 0;\\n  fences[x] = 0;\\n}\\n\\nconst DIR_R = [0, 0, 1, -1];\\nconst DIR_C = [1, -1, 0, 0];\\n\\n/**\\n * guideline:\\n * &7\\n * 0: uninfected and not (yet) threaten\\n * 1: infected but unvisited\\n * 2: infected and visited\\n * 3: uninfected and threaten\\n * 4: locked up\\n * >>3\\n * label\\n */\\n\\n/**\\n * @param {number[][]} isInfected\\n * @return {number}\\n */\\nvar containVirus = function (isInfected) {\\n  let n = isInfected[0].length;\\n  let m = isInfected.length;\\n  let label = 0;\\n  let res = 0;\\n\\n  function bfs(ir, ic, label) {\\n    qr.enqueue(ir);\\n    qc.enqueue(ic);\\n    let labelState = (label << 3) | 2;\\n    isInfected[ir][ic] = labelState;\\n    initLabel(label);\\n\\n    while (qr.size) {\\n      let r = qr.dequeue();\\n      let c = qc.dequeue();\\n\\n      for (let i = 0; i < 4; i++) {\\n        let rr = r + DIR_R[i];\\n        let cc = c + DIR_C[i];\\n        let state = isInfected[rr]?.[cc];\\n        if (state == undefined) continue;\\n\\n        switch (state & 7) {\\n          case 0: {\\n            isInfected[rr][cc] = (label << 3) | 3;\\n            fences[label]++;\\n            threats[label]++;\\n            break;\\n          }\\n          case 1: {\\n            qr.enqueue(rr);\\n            qc.enqueue(cc);\\n            isInfected[rr][cc] = labelState;\\n            break;\\n          }\\n          case 3: {\\n            fences[label]++;\\n            if ((state >> 3) != label) {\\n              threats[label]++;\\n              isInfected[rr][cc] = (label << 3) | 3;\\n            }\\n            break;\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  function isStillThreaten(r, c, lockedLabel) {\\n    for (let i = 0; i < 4; i++) {\\n      let rr = r + DIR_R[i];\\n      let cc = c + DIR_C[i];\\n      let state = isInfected[rr]?.[cc];\\n      if ((state & 7) == 2 && (state >> 3) != lockedLabel) return true;\\n    }\\n  }\\n\\n  while (true) {\\n    label = 0;\\n    let lockedLabel = 0;\\n\\n    for (let r = 0; r < m; r++) {\\n      for (let c = 0; c < n; c++) {\\n        if (isInfected[r][c] == 1) {\\n          bfs(r, c, label);\\n          if (threats[label] > threats[lockedLabel]) lockedLabel = label;\\n          label++;\\n        }\\n      }\\n    }\\n\\n    if (!label) return res;\\n\\n    res += fences[lockedLabel];\\n\\n    for (let r = 0; r < m; r++) {\\n      for (let c = 0; c < n; c++) {\\n        if ((isInfected[r][c] & 7) == 3) {\\n          if (isStillThreaten(r, c, lockedLabel)) isInfected[r][c] = 1;\\n          else isInfected[r][c] = 0;\\n        }\\n      }\\n    }\\n\\n    for (let r = 0; r < m; r++) {\\n      for (let c = 0; c < n; c++) {\\n        let state = isInfected[r][c];\\n        if ((state & 7) == 2) {\\n          if ((state >> 3) == lockedLabel) isInfected[r][c] = 4;\\n          else isInfected[r][c] = 1;\\n        }\\n      }\\n    }\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987217,
                "title": "only-god-knows",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int bfs(int r,int c,vector<vector<int>>& isInfected,vector<vector<bool>>& vis,vector<vector<bool>>& cont){\\n        int count=0;\\n        int row=isInfected.size();\\n        int col=isInfected[0].size(); \\n\\n        queue<pair<int,int>> q;\\n        q.push({r,c});      \\n        vis[r][c]=true;\\n\\n        int dx[4]={0,-1,0,1};\\n        int dy[4]={1,0,-1,0};\\n\\n        vector<vector<bool>> seen(row,vector<bool>(col,false)); \\n\\n        while(!q.empty()){\\n\\n             int u=q.front().first;\\n             int v=q.front().second;\\n             q.pop();\\n\\n             for(int k=0;k<4;++k){\\n                int nr=u+dx[k];\\n                int nc=v+dy[k];\\n\\n                if(0<=nr && nr<row && 0<=nc && nc<col && !vis[nr][nc] && !cont[nr][nc]){\\n                   if(isInfected[nr][nc]){\\n                      vis[nr][nc]=true;\\n                      q.push({nr,nc});   \\n                   }\\n                   else if(!isInfected[nr][nc]){\\n                      if(!seen[nr][nc]){\\n                         seen[nr][nc]=true;\\n                         count++;  \\n                      } \\n                   }        \\n                }   \\n             }       \\n        }\\n\\n        return count; \\n    }  \\n\\n    int quarantine(int r,int c,vector<vector<int>>& isInfected,vector<vector<bool>>& cont){\\n        \\n        int row=isInfected.size();\\n        int col=isInfected[0].size();\\n\\n        int dx[4]={0,-1,0,1};\\n        int dy[4]={1,0,-1,0};\\n\\n        int walls=0;\\n\\n        queue<pair<int,int>> q;\\n\\n        vector<vector<bool>> vis(row,vector<bool>(col,false));\\n\\n        vis[r][c]=true; \\n        cont[r][c]=true;\\n        q.push({r,c});\\n  \\n        while(!q.empty()){\\n\\n             int u=q.front().first;\\n             int v=q.front().second; \\n             q.pop();\\n\\n             for(int k=0;k<4;++k){\\n                 int nr=u+dx[k];\\n                 int nc=v+dy[k];\\n\\n                 if(0<=nr && nr<row && 0<=nc && nc<col){\\n                    if(!vis[nr][nc] && isInfected[nr][nc] && !cont[nr][nc]){\\n                       vis[nr][nc]=true;\\n                       cont[nr][nc]=true;\\n                       q.push({nr,nc}); \\n                    } \\n                    else if(!isInfected[nr][nc])\\n                       walls++;\\n                 }     \\n             }\\n        }\\n        //std::cout<<\"Returning\"<<std::endl;\\n        return walls;         \\n    } \\n\\n   void spread(int r,int c,vector<vector<int>>& isInfected,vector<vector<bool>>& seen,vector<vector<bool>>& mark,vector<vector<bool>>& cont){\\n         \\n        int row=isInfected.size();\\n        int col=isInfected[0].size();\\n        \\n        int dx[4]={0,-1,0,1};\\n        int dy[4]={1,0,-1,0};\\n\\n        queue<pair<int,int>> q;\\n\\n        q.push({r,c});\\n        seen[r][c]=true;\\n\\n        while(!q.empty()){\\n\\n             int u=q.front().first;\\n             int v=q.front().second;\\n\\n             q.pop();\\n\\n             for(int k=0;k<4;++k){\\n\\n                 int nr=u+dx[k];\\n                 int nc=v+dy[k];\\n\\n                 if(0<=nr && nr<row && 0<=nc && nc<col){\\n                    if(!seen[nr][nc] && isInfected[nr][nc] && !cont[nr][nc] && !mark[nr][nc]){\\n                       seen[nr][nc]=true;\\n                       q.push({nr,nc});\\n                    } \\n                    else if(!isInfected[nr][nc]){\\n                       isInfected[nr][nc]=1;\\n                       mark[nr][nc]=true;  \\n                    }  \\n                 }   \\n             }  \\n        }   \\n\\n        std::cout<<\"No control here\"<<std::endl;     \\n   } \\n\\n    int containVirus(vector<vector<int>>& isInfected) {\\n        int row=isInfected.size();\\n        int col=isInfected[0].size();\\n\\n        int walls=0;\\n        vector<vector<bool>> cont(row,vector<bool>(col,false));\\n\\n        while(true){\\n\\n             vector<vector<bool>> vis(row,vector<bool>(col,false));\\n         \\n             int maxm=0;\\n             int maxr;\\n             int maxc;\\n\\n             for(int i=0;i<row;++i){\\n                 for(int j=0;j<col;++j){\\n                     if(isInfected[i][j] && !vis[i][j] && !cont[i][j]){\\n                        int infect=bfs(i,j,isInfected,vis,cont);\\n\\n                        //std::cout<<\"Infected=\"<<infect<<std::endl;\\n                        \\n                        if(maxm<infect){\\n                           maxm=infect;\\n                           maxr=i;\\n                           maxc=j;  \\n                        }         \\n                     }   \\n                 }  \\n             }\\n\\n             std::cout<<\"First Iteration completed\"<<std::endl;\\n\\n             std::cout<<\"Maximum Infected=\"<<maxm<<std::endl;\\n             if(maxm==0)\\n                break;\\n\\n             walls+=quarantine(maxr,maxc,isInfected,cont);\\n\\n             std::cout<<\"Walls required=\"<<walls<<std::endl;\\n             \\n             vector<vector<bool>> seen(row,vector<bool>(col,false));\\n             vector<vector<bool>> mark(row,vector<bool>(col,false));\\n\\n             for(int i=0;i<row;++i){\\n                 for(int j=0;j<col;++j){\\n                     if(isInfected[i][j] && !seen[i][j] && !cont[i][j] && !mark[i][j])\\n                        spread(i,j,isInfected,seen,mark,cont);  \\n                 }  \\n             }      \\n\\n             std::cout<<\"Spread Done\"<<std::endl;            \\n        }\\n        return walls;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int bfs(int r,int c,vector<vector<int>>& isInfected,vector<vector<bool>>& vis,vector<vector<bool>>& cont){\\n        int count=0;\\n        int row=isInfected.size();\\n        int col=isInfected[0].size(); \\n\\n        queue<pair<int,int>> q;\\n        q.push({r,c});      \\n        vis[r][c]=true;\\n\\n        int dx[4]={0,-1,0,1};\\n        int dy[4]={1,0,-1,0};\\n\\n        vector<vector<bool>> seen(row,vector<bool>(col,false)); \\n\\n        while(!q.empty()){\\n\\n             int u=q.front().first;\\n             int v=q.front().second;\\n             q.pop();\\n\\n             for(int k=0;k<4;++k){\\n                int nr=u+dx[k];\\n                int nc=v+dy[k];\\n\\n                if(0<=nr && nr<row && 0<=nc && nc<col && !vis[nr][nc] && !cont[nr][nc]){\\n                   if(isInfected[nr][nc]){\\n                      vis[nr][nc]=true;\\n                      q.push({nr,nc});   \\n                   }\\n                   else if(!isInfected[nr][nc]){\\n                      if(!seen[nr][nc]){\\n                         seen[nr][nc]=true;\\n                         count++;  \\n                      } \\n                   }        \\n                }   \\n             }       \\n        }\\n\\n        return count; \\n    }  \\n\\n    int quarantine(int r,int c,vector<vector<int>>& isInfected,vector<vector<bool>>& cont){\\n        \\n        int row=isInfected.size();\\n        int col=isInfected[0].size();\\n\\n        int dx[4]={0,-1,0,1};\\n        int dy[4]={1,0,-1,0};\\n\\n        int walls=0;\\n\\n        queue<pair<int,int>> q;\\n\\n        vector<vector<bool>> vis(row,vector<bool>(col,false));\\n\\n        vis[r][c]=true; \\n        cont[r][c]=true;\\n        q.push({r,c});\\n  \\n        while(!q.empty()){\\n\\n             int u=q.front().first;\\n             int v=q.front().second; \\n             q.pop();\\n\\n             for(int k=0;k<4;++k){\\n                 int nr=u+dx[k];\\n                 int nc=v+dy[k];\\n\\n                 if(0<=nr && nr<row && 0<=nc && nc<col){\\n                    if(!vis[nr][nc] && isInfected[nr][nc] && !cont[nr][nc]){\\n                       vis[nr][nc]=true;\\n                       cont[nr][nc]=true;\\n                       q.push({nr,nc}); \\n                    } \\n                    else if(!isInfected[nr][nc])\\n                       walls++;\\n                 }     \\n             }\\n        }\\n        //std::cout<<\"Returning\"<<std::endl;\\n        return walls;         \\n    } \\n\\n   void spread(int r,int c,vector<vector<int>>& isInfected,vector<vector<bool>>& seen,vector<vector<bool>>& mark,vector<vector<bool>>& cont){\\n         \\n        int row=isInfected.size();\\n        int col=isInfected[0].size();\\n        \\n        int dx[4]={0,-1,0,1};\\n        int dy[4]={1,0,-1,0};\\n\\n        queue<pair<int,int>> q;\\n\\n        q.push({r,c});\\n        seen[r][c]=true;\\n\\n        while(!q.empty()){\\n\\n             int u=q.front().first;\\n             int v=q.front().second;\\n\\n             q.pop();\\n\\n             for(int k=0;k<4;++k){\\n\\n                 int nr=u+dx[k];\\n                 int nc=v+dy[k];\\n\\n                 if(0<=nr && nr<row && 0<=nc && nc<col){\\n                    if(!seen[nr][nc] && isInfected[nr][nc] && !cont[nr][nc] && !mark[nr][nc]){\\n                       seen[nr][nc]=true;\\n                       q.push({nr,nc});\\n                    } \\n                    else if(!isInfected[nr][nc]){\\n                       isInfected[nr][nc]=1;\\n                       mark[nr][nc]=true;  \\n                    }  \\n                 }   \\n             }  \\n        }   \\n\\n        std::cout<<\"No control here\"<<std::endl;     \\n   } \\n\\n    int containVirus(vector<vector<int>>& isInfected) {\\n        int row=isInfected.size();\\n        int col=isInfected[0].size();\\n\\n        int walls=0;\\n        vector<vector<bool>> cont(row,vector<bool>(col,false));\\n\\n        while(true){\\n\\n             vector<vector<bool>> vis(row,vector<bool>(col,false));\\n         \\n             int maxm=0;\\n             int maxr;\\n             int maxc;\\n\\n             for(int i=0;i<row;++i){\\n                 for(int j=0;j<col;++j){\\n                     if(isInfected[i][j] && !vis[i][j] && !cont[i][j]){\\n                        int infect=bfs(i,j,isInfected,vis,cont);\\n\\n                        //std::cout<<\"Infected=\"<<infect<<std::endl;\\n                        \\n                        if(maxm<infect){\\n                           maxm=infect;\\n                           maxr=i;\\n                           maxc=j;  \\n                        }         \\n                     }   \\n                 }  \\n             }\\n\\n             std::cout<<\"First Iteration completed\"<<std::endl;\\n\\n             std::cout<<\"Maximum Infected=\"<<maxm<<std::endl;\\n             if(maxm==0)\\n                break;\\n\\n             walls+=quarantine(maxr,maxc,isInfected,cont);\\n\\n             std::cout<<\"Walls required=\"<<walls<<std::endl;\\n             \\n             vector<vector<bool>> seen(row,vector<bool>(col,false));\\n             vector<vector<bool>> mark(row,vector<bool>(col,false));\\n\\n             for(int i=0;i<row;++i){\\n                 for(int j=0;j<col;++j){\\n                     if(isInfected[i][j] && !seen[i][j] && !cont[i][j] && !mark[i][j])\\n                        spread(i,j,isInfected,seen,mark,cont);  \\n                 }  \\n             }      \\n\\n             std::cout<<\"Spread Done\"<<std::endl;            \\n        }\\n        return walls;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3972193,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n``` java []\\nclass Solution {\\n    \\n    private static final int[][] DIR = new int[][]{\\n        {1, 0}, {-1, 0}, {0, 1}, {0, -1}\\n    };\\n    \\n    public int containVirus(int[][] isInfected) {\\n        int m = isInfected.length, n = isInfected[0].length;\\n        int ans = 0;\\n        \\n        while( true ) {\\n            // infected regions, sorted desc according to the number of nearby \\n            // uninfected nodes\\n            PriorityQueue<Region> pq = new PriorityQueue<Region>();\\n            // already visited cells\\n            boolean[][] visited = new boolean[m][n];\\n            \\n            // find regions\\n            for(int i=0; i<m; i++) {\\n                for(int j=0; j<n; j++) {\\n                    \\n                    // if current cell is infected, and it\\'s not visited\\n                    if( isInfected[i][j] != 1 || visited[i][j] ) \\n                        continue;\\n                    \\n                    // we found a new region, dfs to find all the infected\\n                    // and uninfected cells in the current region\\n                    Region reg = new Region();\\n                    dfs(i, j, reg, isInfected, visited, new boolean[m][n], m, n);\\n                    \\n                    // if there are some uninfected nodes in this region, \\n                    // we can contain it, so add it to priority queue\\n                    if( reg.uninfected.size() != 0)\\n                        pq.offer(reg);\\n                }\\n            }\\n            \\n            // if there are no regions to contain, break\\n            if( pq.isEmpty() )\\n                break;\\n\\n            // Contain region with most uninfected nodes\\n            Region containReg = pq.poll();\\n            ans += containReg.wallsRequired;\\n            \\n            // use (2) to mark a cell as contained\\n            for(int[] cell : containReg.infected)\\n                isInfected[cell[0]][cell[1]] = 2;\\n            \\n            // Spread infection to uninfected nodes in other regions\\n            while( !pq.isEmpty() ) {\\n                Region spreadReg = pq.poll();\\n                \\n                for(int[] cell : spreadReg.uninfected)\\n                    isInfected[cell[0]][cell[1]] = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private void dfs(int i, int j, Region reg, int[][] grid, boolean[][] visited, boolean[][] uninfectedVis, int m, int n) {\\n        visited[i][j] = true;\\n        reg.addInfected(i, j);\\n        \\n        for(int[] dir : DIR) {\\n            int di = i + dir[0];\\n            int dj = j + dir[1];\\n            \\n            // continue, if out of bounds OR contained OR already visited\\n            if( di < 0 || dj < 0 || di == m || dj == n || grid[di][dj] == 2 || visited[di][dj] )\\n                continue;\\n            \\n            // if neighbour node is not infected\\n            if( grid[di][dj] == 0 ) {\\n                // a wall will require to stop the spread from cell (i,j) to (di, dj)\\n                reg.wallsRequired++;\\n                \\n                // if this uninfected node is not already visited for current region\\n                if( !uninfectedVis[di][dj] ) {\\n                    uninfectedVis[di][dj] = true;\\n                    reg.addUninfected(di, dj);\\n                }\\n            } else \\n                dfs(di, dj, reg, grid, visited, uninfectedVis, m, n);\\n        }\\n    }\\n}\\nclass Region implements Comparable<Region> {\\n    public List<int[]> infected;\\n    public List<int[]> uninfected;\\n    public int wallsRequired;\\n    \\n    public Region() {\\n        infected = new ArrayList();\\n        uninfected = new ArrayList();\\n    }\\n    \\n    public void addInfected(int row, int col) {\\n        infected.add(new int[]{ row, col });\\n    }\\n    \\n    public void addUninfected(int row, int col) {\\n        uninfected.add(new int[]{ row, col });\\n    }\\n    \\n    @Override\\n    public int compareTo(Region r2) {\\n        return Integer.compare(r2.uninfected.size(), uninfected.size());\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\\n    int walls=0;\\n    \\n    bool isValid(int i,int j,int m,int n,vector<vector<int>> &vis)\\n    {\\n        return (i>=0 && i<m && j>=0 && j<n && !vis[i][j]); \\n    }\\n    \\n    int find(int i,int j,int m,int n,vector<vector<int>>& a)\\n    {\\n        int c=0;\\n        \\n        queue<pair<int,int>> q;\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        \\n        a[i][j]=2;\\n        q.push({i,j});\\n        \\n        while(!q.empty())\\n        {\\n            i=q.front().first;\\n            j=q.front().second;\\n            q.pop();\\n            \\n            for(int k=0;k<4;k++)\\n            {\\n                if(isValid(i+dx[k],j+dy[k],m,n,vis))\\n                {\\n                    if(a[i+dx[k]][j+dy[k]]==0)\\n                        c++;\\n                    else if(a[i+dx[k]][j+dy[k]]==1)\\n                    {\\n                        a[i+dx[k]][j+dy[k]]=2;\\n                        q.push({i+dx[k],j+dy[k]});\\n                    }\\n                                            \\n                    vis[i+dx[k]][j+dy[k]]=1;\\n                    \\n                }\\n            }\\n        }\\n        \\n        return c;\\n    }\\n    \\n    void putwalls(pair<int,int> &change,int m,int n,vector<vector<int>>& a)\\n    {\\n        int i,j;\\n        i=change.first;\\n        j=change.second;\\n        \\n        queue<pair<int,int>> q;\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        \\n        q.push({i,j});\\n        \\n        while(!q.empty())\\n        {\\n            i=q.front().first;\\n            j=q.front().second;\\n            a[i][j]=-1;\\n            q.pop();\\n            \\n            \\n            for(int k=0;k<4;k++)\\n            {\\n                if(isValid(i+dx[k],j+dy[k],m,n,vis))\\n                {\\n                    if(a[i+dx[k]][j+dy[k]]==2)\\n                    {\\n                        q.push({i+dx[k],j+dy[k]});\\n                        a[i+dx[k]][j+dy[k]]=-1;\\n                        vis[i+dx[k]][j+dy[k]]=1;    \\n                    } \\n                    else if(a[i+dx[k]][j+dy[k]]==0)\\n                        walls++;\\n                }\\n            }\\n        }\\n    }\\n    \\n    void spread(int m,int n,vector<vector<int>>& a)\\n    {\\n        int i,j;\\n        queue<pair<int,int>> q;\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        \\n        for(i=0;i<m;i++)\\n        {\\n            for(j=0;j<n;j++)\\n            {\\n                if(a[i][j]==2)\\n                {\\n                    a[i][j]=1;\\n                    q.push({i,j});\\n\\n                }\\n            }\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            i=q.front().first;\\n            j=q.front().second;\\n            q.pop();\\n            \\n            for(int k=0;k<4;k++)\\n            {\\n                if(isValid(i+dx[k],j+dy[k],m,n,vis) && a[i+dx[k]][j+dy[k]]==0)\\n                {\\n                    a[i+dx[k]][j+dy[k]]=1;\\n                    vis[i+dx[k]][j+dy[k]]=1;     \\n                }\\n            }\\n        }\\n    }\\n    \\n    int containVirus(vector<vector<int>>& a) {\\n        int m=a.size(),n=a[0].size();\\n        int i,j;\\n        \\n        int infected=INT_MIN;\\n        pair<int,int> change;\\n        \\n        while(infected!=0)\\n        {\\n            infected=0;\\n            for(i=0;i<m;i++)\\n            {\\n                for(j=0;j<n;j++)\\n                {\\n                    if(a[i][j]==1)\\n                    {\\n                        int x=find(i,j,m,n,a);\\n                        if(x>infected)\\n                        {\\n                            change={i,j};\\n                            infected=x;\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            if(infected!=0)\\n            {\\n                putwalls(change,m,n,a);\\n                spread(m,n,a);\\n            }\\n        }\\n        \\n        return walls;\\n    }\\n};\\n```\\n```python3 []\\nclass Solution:\\n    def containVirus(self, isInfected: List[List[int]]) -> int:\\n        \\'\\'\\'\\n        isInfected[r][c]:\\n            0 : Uninfected\\n            1 : Infected\\n            2 : Infected & restricted\\n        \\'\\'\\'\\n        m = len(isInfected)\\n        n = len(isInfected[0])\\n\\n        borders = 0\\n        threatened = 0\\n        def dfs(r, c, id):\\n            nonlocal borders, threatened\\n            if r < 0 or r>=m or c < 0 or c>=n:\\n                return\\n\\n            if isInfected[r][c] == 1:\\n                if visited[r][c] == 0:\\n                    visited[r][c] = 1\\n                    dfs(r-1, c, id)\\n                    dfs(r+1, c, id)\\n                    dfs(r, c-1, id)\\n                    dfs(r, c+1, id)\\n                else:\\n                    pass\\n            elif isInfected[r][c] == 0:\\n                if visited[r][c] == id:\\n                    borders += 1\\n                else:\\n                    borders += 1\\n                    threatened += 1\\n                    visited[r][c] = id\\n        \\n        def flood(r, c, find, repl):\\n            if r < 0 or r>=m or c < 0 or c>=n or isInfected[r][c] != find:\\n                return\\n            isInfected[r][c] = repl\\n            flood(r-1, c, find, repl)\\n            flood(r+1, c, find, repl)\\n            flood(r, c-1, find, repl)\\n            flood(r, c+1, find, repl)\\n        \\n        def expand(r, c, id):\\n            if r < 0 or r>=m or c < 0 or c>=n or visited[r][c] == 1:\\n                return\\n            visited[r][c] = 1\\n            if isInfected[r][c] == 0:\\n                isInfected[r][c] = 1\\n            elif isInfected[r][c] == 1:\\n                expand(r+1, c, id)\\n                expand(r-1, c, id)\\n                expand(r, c-1, id)\\n                expand(r, c+1, id)   \\n\\n        total_walls = 0\\n\\n        while True:\\n            # Day ---------------------------------------------------\\n            max_th = 0\\n            max_th_loc = (None, None)\\n            max_th_border = 0\\n            id = 3\\n            visited = [[0] * n for _ in range(m)]\\n\\n            for r in range(m):\\n                for c in range(n):\\n                    if isInfected[r][c]==1 and visited[r][c] == 0:\\n                        \\n                        borders = 0\\n                        threatened = 0\\n                        dfs(r, c, id)\\n                        id += 1\\n                        if threatened > max_th:\\n                            max_th = threatened\\n                            max_th_loc = r, c\\n                            max_th_border = borders\\n            \\n            if max_th == 0:\\n                break\\n            total_walls += max_th_border\\n            # Restrict bordered region by making them dormant\\n            flood(*max_th_loc, 1, 2)\\n\\n            # Night -------------------------------------------------\\n\\n            visited = [[0] * n for _ in range(m)]\\n            for r in range(m):\\n                for c in range(n):\\n                    if isInfected[r][c]==1 and visited[r][c] == 0:\\n                        expand(r, c, id)\\n                        id += 1\\n\\n        return total_walls\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "``` java []\\nclass Solution {\\n    \\n    private static final int[][] DIR = new int[][]{\\n        {1, 0}, {-1, 0}, {0, 1}, {0, -1}\\n    };\\n    \\n    public int containVirus(int[][] isInfected) {\\n        int m = isInfected.length, n = isInfected[0].length;\\n        int ans = 0;\\n        \\n        while( true ) {\\n            // infected regions, sorted desc according to the number of nearby \\n            // uninfected nodes\\n            PriorityQueue<Region> pq = new PriorityQueue<Region>();\\n            // already visited cells\\n            boolean[][] visited = new boolean[m][n];\\n            \\n            // find regions\\n            for(int i=0; i<m; i++) {\\n                for(int j=0; j<n; j++) {\\n                    \\n                    // if current cell is infected, and it\\'s not visited\\n                    if( isInfected[i][j] != 1 || visited[i][j] ) \\n                        continue;\\n                    \\n                    // we found a new region, dfs to find all the infected\\n                    // and uninfected cells in the current region\\n                    Region reg = new Region();\\n                    dfs(i, j, reg, isInfected, visited, new boolean[m][n], m, n);\\n                    \\n                    // if there are some uninfected nodes in this region, \\n                    // we can contain it, so add it to priority queue\\n                    if( reg.uninfected.size() != 0)\\n                        pq.offer(reg);\\n                }\\n            }\\n            \\n            // if there are no regions to contain, break\\n            if( pq.isEmpty() )\\n                break;\\n\\n            // Contain region with most uninfected nodes\\n            Region containReg = pq.poll();\\n            ans += containReg.wallsRequired;\\n            \\n            // use (2) to mark a cell as contained\\n            for(int[] cell : containReg.infected)\\n                isInfected[cell[0]][cell[1]] = 2;\\n            \\n            // Spread infection to uninfected nodes in other regions\\n            while( !pq.isEmpty() ) {\\n                Region spreadReg = pq.poll();\\n                \\n                for(int[] cell : spreadReg.uninfected)\\n                    isInfected[cell[0]][cell[1]] = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private void dfs(int i, int j, Region reg, int[][] grid, boolean[][] visited, boolean[][] uninfectedVis, int m, int n) {\\n        visited[i][j] = true;\\n        reg.addInfected(i, j);\\n        \\n        for(int[] dir : DIR) {\\n            int di = i + dir[0];\\n            int dj = j + dir[1];\\n            \\n            // continue, if out of bounds OR contained OR already visited\\n            if( di < 0 || dj < 0 || di == m || dj == n || grid[di][dj] == 2 || visited[di][dj] )\\n                continue;\\n            \\n            // if neighbour node is not infected\\n            if( grid[di][dj] == 0 ) {\\n                // a wall will require to stop the spread from cell (i,j) to (di, dj)\\n                reg.wallsRequired++;\\n                \\n                // if this uninfected node is not already visited for current region\\n                if( !uninfectedVis[di][dj] ) {\\n                    uninfectedVis[di][dj] = true;\\n                    reg.addUninfected(di, dj);\\n                }\\n            } else \\n                dfs(di, dj, reg, grid, visited, uninfectedVis, m, n);\\n        }\\n    }\\n}\\nclass Region implements Comparable<Region> {\\n    public List<int[]> infected;\\n    public List<int[]> uninfected;\\n    public int wallsRequired;\\n    \\n    public Region() {\\n        infected = new ArrayList();\\n        uninfected = new ArrayList();\\n    }\\n    \\n    public void addInfected(int row, int col) {\\n        infected.add(new int[]{ row, col });\\n    }\\n    \\n    public void addUninfected(int row, int col) {\\n        uninfected.add(new int[]{ row, col });\\n    }\\n    \\n    @Override\\n    public int compareTo(Region r2) {\\n        return Integer.compare(r2.uninfected.size(), uninfected.size());\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\\n    int walls=0;\\n    \\n    bool isValid(int i,int j,int m,int n,vector<vector<int>> &vis)\\n    {\\n        return (i>=0 && i<m && j>=0 && j<n && !vis[i][j]); \\n    }\\n    \\n    int find(int i,int j,int m,int n,vector<vector<int>>& a)\\n    {\\n        int c=0;\\n        \\n        queue<pair<int,int>> q;\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        \\n        a[i][j]=2;\\n        q.push({i,j});\\n        \\n        while(!q.empty())\\n        {\\n            i=q.front().first;\\n            j=q.front().second;\\n            q.pop();\\n            \\n            for(int k=0;k<4;k++)\\n            {\\n                if(isValid(i+dx[k],j+dy[k],m,n,vis))\\n                {\\n                    if(a[i+dx[k]][j+dy[k]]==0)\\n                        c++;\\n                    else if(a[i+dx[k]][j+dy[k]]==1)\\n                    {\\n                        a[i+dx[k]][j+dy[k]]=2;\\n                        q.push({i+dx[k],j+dy[k]});\\n                    }\\n                                            \\n                    vis[i+dx[k]][j+dy[k]]=1;\\n                    \\n                }\\n            }\\n        }\\n        \\n        return c;\\n    }\\n    \\n    void putwalls(pair<int,int> &change,int m,int n,vector<vector<int>>& a)\\n    {\\n        int i,j;\\n        i=change.first;\\n        j=change.second;\\n        \\n        queue<pair<int,int>> q;\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        \\n        q.push({i,j});\\n        \\n        while(!q.empty())\\n        {\\n            i=q.front().first;\\n            j=q.front().second;\\n            a[i][j]=-1;\\n            q.pop();\\n            \\n            \\n            for(int k=0;k<4;k++)\\n            {\\n                if(isValid(i+dx[k],j+dy[k],m,n,vis))\\n                {\\n                    if(a[i+dx[k]][j+dy[k]]==2)\\n                    {\\n                        q.push({i+dx[k],j+dy[k]});\\n                        a[i+dx[k]][j+dy[k]]=-1;\\n                        vis[i+dx[k]][j+dy[k]]=1;    \\n                    } \\n                    else if(a[i+dx[k]][j+dy[k]]==0)\\n                        walls++;\\n                }\\n            }\\n        }\\n    }\\n    \\n    void spread(int m,int n,vector<vector<int>>& a)\\n    {\\n        int i,j;\\n        queue<pair<int,int>> q;\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        \\n        for(i=0;i<m;i++)\\n        {\\n            for(j=0;j<n;j++)\\n            {\\n                if(a[i][j]==2)\\n                {\\n                    a[i][j]=1;\\n                    q.push({i,j});\\n\\n                }\\n            }\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            i=q.front().first;\\n            j=q.front().second;\\n            q.pop();\\n            \\n            for(int k=0;k<4;k++)\\n            {\\n                if(isValid(i+dx[k],j+dy[k],m,n,vis) && a[i+dx[k]][j+dy[k]]==0)\\n                {\\n                    a[i+dx[k]][j+dy[k]]=1;\\n                    vis[i+dx[k]][j+dy[k]]=1;     \\n                }\\n            }\\n        }\\n    }\\n    \\n    int containVirus(vector<vector<int>>& a) {\\n        int m=a.size(),n=a[0].size();\\n        int i,j;\\n        \\n        int infected=INT_MIN;\\n        pair<int,int> change;\\n        \\n        while(infected!=0)\\n        {\\n            infected=0;\\n            for(i=0;i<m;i++)\\n            {\\n                for(j=0;j<n;j++)\\n                {\\n                    if(a[i][j]==1)\\n                    {\\n                        int x=find(i,j,m,n,a);\\n                        if(x>infected)\\n                        {\\n                            change={i,j};\\n                            infected=x;\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            if(infected!=0)\\n            {\\n                putwalls(change,m,n,a);\\n                spread(m,n,a);\\n            }\\n        }\\n        \\n        return walls;\\n    }\\n};\\n```\n```python3 []\\nclass Solution:\\n    def containVirus(self, isInfected: List[List[int]]) -> int:\\n        \\'\\'\\'\\n        isInfected[r][c]:\\n            0 : Uninfected\\n            1 : Infected\\n            2 : Infected & restricted\\n        \\'\\'\\'\\n        m = len(isInfected)\\n        n = len(isInfected[0])\\n\\n        borders = 0\\n        threatened = 0\\n        def dfs(r, c, id):\\n            nonlocal borders, threatened\\n            if r < 0 or r>=m or c < 0 or c>=n:\\n                return\\n\\n            if isInfected[r][c] == 1:\\n                if visited[r][c] == 0:\\n                    visited[r][c] = 1\\n                    dfs(r-1, c, id)\\n                    dfs(r+1, c, id)\\n                    dfs(r, c-1, id)\\n                    dfs(r, c+1, id)\\n                else:\\n                    pass\\n            elif isInfected[r][c] == 0:\\n                if visited[r][c] == id:\\n                    borders += 1\\n                else:\\n                    borders += 1\\n                    threatened += 1\\n                    visited[r][c] = id\\n        \\n        def flood(r, c, find, repl):\\n            if r < 0 or r>=m or c < 0 or c>=n or isInfected[r][c] != find:\\n                return\\n            isInfected[r][c] = repl\\n            flood(r-1, c, find, repl)\\n            flood(r+1, c, find, repl)\\n            flood(r, c-1, find, repl)\\n            flood(r, c+1, find, repl)\\n        \\n        def expand(r, c, id):\\n            if r < 0 or r>=m or c < 0 or c>=n or visited[r][c] == 1:\\n                return\\n            visited[r][c] = 1\\n            if isInfected[r][c] == 0:\\n                isInfected[r][c] = 1\\n            elif isInfected[r][c] == 1:\\n                expand(r+1, c, id)\\n                expand(r-1, c, id)\\n                expand(r, c-1, id)\\n                expand(r, c+1, id)   \\n\\n        total_walls = 0\\n\\n        while True:\\n            # Day ---------------------------------------------------\\n            max_th = 0\\n            max_th_loc = (None, None)\\n            max_th_border = 0\\n            id = 3\\n            visited = [[0] * n for _ in range(m)]\\n\\n            for r in range(m):\\n                for c in range(n):\\n                    if isInfected[r][c]==1 and visited[r][c] == 0:\\n                        \\n                        borders = 0\\n                        threatened = 0\\n                        dfs(r, c, id)\\n                        id += 1\\n                        if threatened > max_th:\\n                            max_th = threatened\\n                            max_th_loc = r, c\\n                            max_th_border = borders\\n            \\n            if max_th == 0:\\n                break\\n            total_walls += max_th_border\\n            # Restrict bordered region by making them dormant\\n            flood(*max_th_loc, 1, 2)\\n\\n            # Night -------------------------------------------------\\n\\n            visited = [[0] * n for _ in range(m)]\\n            for r in range(m):\\n                for c in range(n):\\n                    if isInfected[r][c]==1 and visited[r][c] == 0:\\n                        expand(r, c, id)\\n                        id += 1\\n\\n        return total_walls\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872875,
                "title": "c-faster-than-92",
                "content": "First get the new infection count for every region without spreading the infection. Also save the infected area cells for spreading the infection later. To count the possibly infected cells for every region, I am using different area/region code for visited matrix to not skip the non-infected cells. \\n\\nAfter that get the wall count for maximum infected area and spread infection from other areas.\\n\\n```\\nclass Solution {\\n    int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    \\n    int getInfectionCount(vector<vector<int>>& grid, vector<vector<int>>& isVis, vector<pair<int, int>>& areaCells, int areaCode, int i, int j) {\\n        if (i < 0 or j < 0 or i >= grid.size() or j >= grid[0].size() or isVis[i][j] == areaCode or grid[i][j] == 2) {\\n            return 0;\\n        }\\n\\n        isVis[i][j] = areaCode;\\n        if (grid[i][j] == 0) {\\n            return 1;\\n        }\\n        \\n        areaCells.push_back({i, j});\\n        \\n        int infectedCellsCount = 0;\\n        for (int d = 0; d < 4; d++) {\\n            infectedCellsCount += getInfectionCount(grid, isVis, areaCells, areaCode, i + dir[d][0], j + dir[d][1]);\\n        }\\n        \\n        return infectedCellsCount;\\n    }\\n    \\n    int infectAndGetWallCount(vector<vector<int>>& grid, vector<pair<int, int>>& areaCells, bool infect) {\\n        int wallCount = 0;\\n        \\n        for (auto[i, j] : areaCells) {\\n            if (!infect) {\\n                grid[i][j] = 2;\\n            }\\n            for (int d = 0; d < 4; d++) {\\n                int ii = i + dir[d][0];\\n                int jj = j + dir[d][1];\\n                \\n                if (ii < 0 or jj < 0 or ii >= grid.size() or jj >= grid[0].size()) continue;\\n                \\n                if (grid[ii][jj] == 0) {\\n                    if (infect) {\\n                        grid[ii][jj] = 1;\\n                    }\\n                    else {\\n                        wallCount++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return wallCount;\\n    }\\n    \\npublic:\\n    int containVirus(vector<vector<int>>& isInfected) {\\n        int m = isInfected.size(), n = isInfected[0].size(), totalWalls = 0;\\n        \\n        while (true) {\\n            int maxInfectionCount = 0, maxArea = -1;\\n            vector<vector<pair<int, int>>> areas;\\n            vector<vector<int>> isVis(m, vector<int>(n, 0));\\n            int areaCode = 1;\\n\\n            for (int i = 0; i < m; i++) { \\n                for (int j = 0; j < n; j++) {\\n                    if (isInfected[i][j] == 1 and isVis[i][j] == 0) {\\n                        vector<pair<int, int>> areaCells;\\n                        int infectionCount = getInfectionCount(isInfected, isVis, areaCells, areaCode, i, j);\\n                        areaCode++;\\n                        \\n                        if (infectionCount > maxInfectionCount) {\\n                            maxInfectionCount = infectionCount;\\n                            maxArea = areas.size();\\n                        }\\n                        areas.push_back(areaCells);\\n                    }\\n                }\\n            }\\n            \\n            if (maxArea == -1) break;\\n            \\n            totalWalls += infectAndGetWallCount(isInfected, areas[maxArea], false);\\n            for (int i = 0; i < areas.size(); i++) {\\n                if (i == maxArea) continue;\\n                infectAndGetWallCount(isInfected, areas[i], true);\\n            }\\n        }\\n        \\n        return totalWalls;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    \\n    int getInfectionCount(vector<vector<int>>& grid, vector<vector<int>>& isVis, vector<pair<int, int>>& areaCells, int areaCode, int i, int j) {\\n        if (i < 0 or j < 0 or i >= grid.size() or j >= grid[0].size() or isVis[i][j] == areaCode or grid[i][j] == 2) {\\n            return 0;\\n        }\\n\\n        isVis[i][j] = areaCode;\\n        if (grid[i][j] == 0) {\\n            return 1;\\n        }\\n        \\n        areaCells.push_back({i, j});\\n        \\n        int infectedCellsCount = 0;\\n        for (int d = 0; d < 4; d++) {\\n            infectedCellsCount += getInfectionCount(grid, isVis, areaCells, areaCode, i + dir[d][0], j + dir[d][1]);\\n        }\\n        \\n        return infectedCellsCount;\\n    }\\n    \\n    int infectAndGetWallCount(vector<vector<int>>& grid, vector<pair<int, int>>& areaCells, bool infect) {\\n        int wallCount = 0;\\n        \\n        for (auto[i, j] : areaCells) {\\n            if (!infect) {\\n                grid[i][j] = 2;\\n            }\\n            for (int d = 0; d < 4; d++) {\\n                int ii = i + dir[d][0];\\n                int jj = j + dir[d][1];\\n                \\n                if (ii < 0 or jj < 0 or ii >= grid.size() or jj >= grid[0].size()) continue;\\n                \\n                if (grid[ii][jj] == 0) {\\n                    if (infect) {\\n                        grid[ii][jj] = 1;\\n                    }\\n                    else {\\n                        wallCount++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return wallCount;\\n    }\\n    \\npublic:\\n    int containVirus(vector<vector<int>>& isInfected) {\\n        int m = isInfected.size(), n = isInfected[0].size(), totalWalls = 0;\\n        \\n        while (true) {\\n            int maxInfectionCount = 0, maxArea = -1;\\n            vector<vector<pair<int, int>>> areas;\\n            vector<vector<int>> isVis(m, vector<int>(n, 0));\\n            int areaCode = 1;\\n\\n            for (int i = 0; i < m; i++) { \\n                for (int j = 0; j < n; j++) {\\n                    if (isInfected[i][j] == 1 and isVis[i][j] == 0) {\\n                        vector<pair<int, int>> areaCells;\\n                        int infectionCount = getInfectionCount(isInfected, isVis, areaCells, areaCode, i, j);\\n                        areaCode++;\\n                        \\n                        if (infectionCount > maxInfectionCount) {\\n                            maxInfectionCount = infectionCount;\\n                            maxArea = areas.size();\\n                        }\\n                        areas.push_back(areaCells);\\n                    }\\n                }\\n            }\\n            \\n            if (maxArea == -1) break;\\n            \\n            totalWalls += infectAndGetWallCount(isInfected, areas[maxArea], false);\\n            for (int i = 0; i < areas.size(); i++) {\\n                if (i == maxArea) continue;\\n                infectAndGetWallCount(isInfected, areas[i], true);\\n            }\\n        }\\n        \\n        return totalWalls;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839176,
                "title": "beat-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint mp[2652], *zp[2652], zc[2652], step, mk;\\n\\nint dfs(int *p) {\\n    *p = 2;\\n    int res = 0;\\n    for (int *nb : {p-step, p-1, p+1, p+step}) {\\n        int v = *nb;\\n        if (v == mk || v > 1) continue;\\n        if (v <= 0) *nb = mk, ++res; else res += dfs(nb);\\n    }\\n    return res;\\n}\\nint dfs2(int *p) {\\n    *p = 1000;\\n    int res = 0;\\n    for (int *nb : {p-step, p-1, p+1, p+step}) {\\n        int v = *nb;\\n        if (v == 2) res += dfs2(nb); else if (v <= 0) ++res, *nb = 0;\\n    }\\n    return res;\\n}\\nvoid dfs3(int *p) {\\n    *p = 1;\\n    for (int *nb : {p-step, p-1, p+1, p+step}) {\\n        int v = *nb;\\n        if (v == 2) dfs3(nb); else if (v <= 0) *nb = 1;\\n    }\\n}\\nclass Solution {\\npublic:\\n    int containVirus(vector<vector<int>>& isInfected) {\\n        step = isInfected[0].size() + 1; mk = 0;\\n        {\\n            int *p = mp+step;\\n            fill(mp, p, 1000);\\n            for (const auto &r : isInfected) {\\n                for (int x : r) *p++ = x;\\n                *p++ = 1000;\\n            }\\n            fill(p, p+step, 1000);\\n        }\\n        int *lo = mp+step, *hi = lo + step*isInfected.size(), res = 0;\\n        while(1) {\\n            int nb = 0;\\n            for (int *p = lo; p != hi; ++p) if (*p == 1) zp[nb] = p, --mk, zc[nb++] = dfs(p);\\n            if (nb == 0) break;\\n\\n            int best = 0;\\n            for (int i = 1; i < nb; ++i) if (zc[i] > zc[best]) best = i;\\n            if (!zc[best]) break;\\n            res += dfs2(zp[best]);\\n\\n            for (int *p = lo; p != hi; ++p) if (*p == 2) dfs3(p);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint mp[2652], *zp[2652], zc[2652], step, mk;\\n\\nint dfs(int *p) {\\n    *p = 2;\\n    int res = 0;\\n    for (int *nb : {p-step, p-1, p+1, p+step}) {\\n        int v = *nb;\\n        if (v == mk || v > 1) continue;\\n        if (v <= 0) *nb = mk, ++res; else res += dfs(nb);\\n    }\\n    return res;\\n}\\nint dfs2(int *p) {\\n    *p = 1000;\\n    int res = 0;\\n    for (int *nb : {p-step, p-1, p+1, p+step}) {\\n        int v = *nb;\\n        if (v == 2) res += dfs2(nb); else if (v <= 0) ++res, *nb = 0;\\n    }\\n    return res;\\n}\\nvoid dfs3(int *p) {\\n    *p = 1;\\n    for (int *nb : {p-step, p-1, p+1, p+step}) {\\n        int v = *nb;\\n        if (v == 2) dfs3(nb); else if (v <= 0) *nb = 1;\\n    }\\n}\\nclass Solution {\\npublic:\\n    int containVirus(vector<vector<int>>& isInfected) {\\n        step = isInfected[0].size() + 1; mk = 0;\\n        {\\n            int *p = mp+step;\\n            fill(mp, p, 1000);\\n            for (const auto &r : isInfected) {\\n                for (int x : r) *p++ = x;\\n                *p++ = 1000;\\n            }\\n            fill(p, p+step, 1000);\\n        }\\n        int *lo = mp+step, *hi = lo + step*isInfected.size(), res = 0;\\n        while(1) {\\n            int nb = 0;\\n            for (int *p = lo; p != hi; ++p) if (*p == 1) zp[nb] = p, --mk, zc[nb++] = dfs(p);\\n            if (nb == 0) break;\\n\\n            int best = 0;\\n            for (int i = 1; i < nb; ++i) if (zc[i] > zc[best]) best = i;\\n            if (!zc[best]) break;\\n            res += dfs2(zp[best]);\\n\\n            for (int *p = lo; p != hi; ++p) if (*p == 2) dfs3(p);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812048,
                "title": "another-explanation-python3-o-r-c-max-r-c-time-and-o-r-c-space-faster-than-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThis is a pretty hard problem, there\\'s a lot going on. There are a lot of considerations to make. But the idea is that the problem asks us to wall of clusters according to what happens each day/night, and explains the rules. So we simulate.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nI didn\\'t come up with the solution, but thought that the existing solutions are kind of hard to read and understand what they\\'re doing. So I made a `Cluster` structure and `findCluster` method to help break things up. The main loop is a lot easier to read after that.\\n\\nAs the problem says, for each day/night cycle:\\n1. during the day, we find the cluster that threatens the most cells, then wall it off\\n2. at night, the remaining cluster(s) expand by 1 in each cardinal direction\\n\\nSo to break it down, we need the following\\n1. we need to identify all of the clusters\\n2. for each cluster we need to know the cells in that cluster so we can wall it off, the adjacent healthy cells so we know how many there are, and the number of walls required to wall it off\\n\\nWhen we wall off a cluster, we set all of its cells to some marker value `-1`. Originally I struggled with marking off only the boundary to be more efficient. But that was making the solution too complicated so I simplified and just marked them all off.\\n\\nFollowing another solution, I made a little `Cluster` class that contains the details.\\n\\n**NOTE:** I struggled a lot initially because I tried to be fancy about unioning `Cluster`s together to avoid re-finding clusters at each step. Eventually I gave up because it was getting to complicated.\\n\\nTo make it work I\\'d use something along the lines of union-find:\\n* have an array that maps (r,c) to the index of the cluster containing it\\n* have the usual findRoot and union methods of union-find to quickly unify clusters each night when they expand\\n  * having a set of coordinates for adjacent cells is easy to union: just merge the cells\\n  * to merge the number of walls, that\\'s more complicated and where I started getting really confused. There\\'s probably a simple expression after working through all the edge cases though\\n\\nIn the end, if all the complications are worked out and you only track boundary cells, the complexity of the solution problably drops to $O((R+C)*\\\\max(R,C))$.\\n\\n# Complexity\\n- Time complexity: $$O(R*C*\\\\max(R,C)))$$\\n\\nI think that\\'s right but I\\'m not sure. The worst-case scenario is we have a bunch of isolated little clusters so we need a lot of iterations. The most iterations we will do is order $\\\\max(R,C)$ since clusters can\\'t grow for more than that number of steps. In each iteration we do $O(R*C)$ work to find all the clusters.\\n\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(R*C)$$\\n\\nAt worst we store every infected cell in 1 `Cluster`, and every healthy cel in 4 `Cluster`s. We also have the `visited` array with $R*C$ entries. So overall it\\'s order $R*C$.\\n\\n# Code\\n```\\nclass Solution:\\n    def containVirus(self, isInfected: List[List[int]]) -> int:\\n        # ruh-roh...\\n\\n        #   each night we want to find\\n        #     (1) all of the clusters\\n        #           cells in the cluster\\n        #           adjacent healthy cells\\n        #           number of adjoining walls\\n        #     (2) order clusters by num adjacent healthy cells\\n        #     (3) pick cluster with most healthy cells\\n\\n        R = len(isInfected)\\n        C = len(isInfected[0])\\n\\n        class Cluster:\\n            def __init__(self):\\n                self.cells = set() # (r,c) of all infected cells in here\\n                self.risked = set() # (r,c) of all adjacent healthy cells\\n                self.walls = 0 # number of walls required to fence of this cluster\\n\\n            def numRisked(self):\\n                return len(self.risked)\\n\\n            def __repr__(self):\\n                return \"Cluster(%i cells, %i risked, %i walls)\" % (len(self.cells), len(self.risked), self.walls)\\n\\n        fenced = -1\\n\\n        def getCluster(i: int, j: int, visited: list[list[bool]]) -> \\'Cluster\\':\\n            cluster = Cluster()\\n            stack = [(i,j)]\\n            visited[i][j] = True\\n            while stack:\\n                (r,c) = stack.pop()\\n                cluster.cells.add((r,c))\\n\\n                for dr,dc in [(-1,0), (+1,0), (0,-1), (0,+1)]:\\n                    rr = r + dr\\n                    cc = c + dc\\n                    if rr >= 0 and rr < R and cc >= 0 and cc < C:\\n                        if visited[rr][cc]:\\n                            continue\\n                        \\n                        # not visited: is healthy or fenced off or infected\\n                        if isInfected[rr][cc] == 1:\\n                            # infected: add to stack and visited\\n                            stack.append((rr,cc))\\n                            visited[rr][cc] = True\\n                        elif isInfected[rr][cc] == 0:\\n                            # healthy\\n                            cluster.walls += 1 # there\\'s a border between (r,c) and (rr,cc)\\n                            # print(\"  added wall between\", (r,c), (rr,cc))\\n                            cluster.risked.add((rr,cc))\\n\\n            return cluster\\n\\n        # when are we done? when there are no clusters\\n        # if there\\'s one big cluster at the end (all infected), then number of fences will be zero because evrything is either\\n        # a fence for a boundary already\\n\\n        walls = 0\\n\\n        while True:\\n            clusters = []\\n            visited = [[False]*C for _ in range(R)]\\n            for r in range(R):\\n                for c in range(C):\\n                    if isInfected[r][c] == 1 and not visited[r][c]:\\n                        clusters.append(getCluster(r,c,visited))\\n\\n            if not clusters:\\n                return walls\\n\\n            # print(clusters)\\n            clusters.sort(key=lambda cluster: cluster.numRisked())\\n\\n            # wall off the cluster that threatens the most cells\\n            walls += clusters[-1].walls\\n\\n            # mark those cells as walled-off for the sake of later getCluster calls\\n            for (r,c) in clusters[-1].cells:\\n                isInfected[r][c] = -1\\n\\n            # grow all other clusters\\n            clusters.pop()\\n            for cluster in clusters:\\n                for (r,c) in cluster.risked:\\n                    isInfected[r][c] = 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containVirus(self, isInfected: List[List[int]]) -> int:\\n        # ruh-roh...\\n\\n        #   each night we want to find\\n        #     (1) all of the clusters\\n        #           cells in the cluster\\n        #           adjacent healthy cells\\n        #           number of adjoining walls\\n        #     (2) order clusters by num adjacent healthy cells\\n        #     (3) pick cluster with most healthy cells\\n\\n        R = len(isInfected)\\n        C = len(isInfected[0])\\n\\n        class Cluster:\\n            def __init__(self):\\n                self.cells = set() # (r,c) of all infected cells in here\\n                self.risked = set() # (r,c) of all adjacent healthy cells\\n                self.walls = 0 # number of walls required to fence of this cluster\\n\\n            def numRisked(self):\\n                return len(self.risked)\\n\\n            def __repr__(self):\\n                return \"Cluster(%i cells, %i risked, %i walls)\" % (len(self.cells), len(self.risked), self.walls)\\n\\n        fenced = -1\\n\\n        def getCluster(i: int, j: int, visited: list[list[bool]]) -> \\'Cluster\\':\\n            cluster = Cluster()\\n            stack = [(i,j)]\\n            visited[i][j] = True\\n            while stack:\\n                (r,c) = stack.pop()\\n                cluster.cells.add((r,c))\\n\\n                for dr,dc in [(-1,0), (+1,0), (0,-1), (0,+1)]:\\n                    rr = r + dr\\n                    cc = c + dc\\n                    if rr >= 0 and rr < R and cc >= 0 and cc < C:\\n                        if visited[rr][cc]:\\n                            continue\\n                        \\n                        # not visited: is healthy or fenced off or infected\\n                        if isInfected[rr][cc] == 1:\\n                            # infected: add to stack and visited\\n                            stack.append((rr,cc))\\n                            visited[rr][cc] = True\\n                        elif isInfected[rr][cc] == 0:\\n                            # healthy\\n                            cluster.walls += 1 # there\\'s a border between (r,c) and (rr,cc)\\n                            # print(\"  added wall between\", (r,c), (rr,cc))\\n                            cluster.risked.add((rr,cc))\\n\\n            return cluster\\n\\n        # when are we done? when there are no clusters\\n        # if there\\'s one big cluster at the end (all infected), then number of fences will be zero because evrything is either\\n        # a fence for a boundary already\\n\\n        walls = 0\\n\\n        while True:\\n            clusters = []\\n            visited = [[False]*C for _ in range(R)]\\n            for r in range(R):\\n                for c in range(C):\\n                    if isInfected[r][c] == 1 and not visited[r][c]:\\n                        clusters.append(getCluster(r,c,visited))\\n\\n            if not clusters:\\n                return walls\\n\\n            # print(clusters)\\n            clusters.sort(key=lambda cluster: cluster.numRisked())\\n\\n            # wall off the cluster that threatens the most cells\\n            walls += clusters[-1].walls\\n\\n            # mark those cells as walled-off for the sake of later getCluster calls\\n            for (r,c) in clusters[-1].cells:\\n                isInfected[r][c] = -1\\n\\n            # grow all other clusters\\n            clusters.pop()\\n            for cluster in clusters:\\n                for (r,c) in cluster.risked:\\n                    isInfected[r][c] = 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802848,
                "title": "c-solution-which-is-easy-to-understand",
                "content": "# Intuition\\n The objective is to identify the region that affects the maximum   number of blocks and construct walls around it. This process is repeated until there are no remaining open regions\\n\\n# Approach\\n\\n1. find region which impacts maximum blocks\\n2. contruct walls around it and deidentify the region and add walls to the ans.\\n3. spread contamination to 1 neighbour blocks for each region present with virus\\n4. repat step 1 until there  is no region left\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int containVirus(vector<vector<int>>& inf) {\\n\\n \\n        int m  = inf.size();\\n        int n = inf[0].size();\\n        int ans = FindWalls(m,n,inf);  \\n        return ans;    \\n\\n    }\\n\\n    int FindWalls(int m , int n , vector<vector<int>>& inf)\\n    {\\n       \\n         int ans = 0;\\n         int maxima = 0 ;\\n         int start_x = 0;\\n         int start_y = 0;\\n         \\n         while(true)\\n         {\\n            maxima = 0;\\n            int local_ans = 0;\\n            vector<vector<int>> v(m,vector<int>(n,0));\\n            for(int i = 0 ; i< m;i++)\\n            {\\n                for(int j = 0 ;j<n;j++)\\n                {\\n                      \\n                   \\n                    if(inf[i][j]==1&&v[i][j]==0)\\n                    {\\n                        initialize(v,m,n,inf);\\n                        local_ans = blocks(i,j,v,inf,m,n);\\n                        if(local_ans>maxima)\\n                        {\\n                            start_x = i;\\n                            start_y = j;\\n                        }\\n                        maxima = max(maxima,local_ans);\\n                    }\\n\\n                }\\n\\n             }\\n\\n             if(maxima == 0)\\n                return ans;\\n            \\n            for(int i = 0 ;i<m;i++)\\n                for(int j =0 ; j<n;j++)\\n                    v[i][j]=0;\\n            ans+=blockToSpread(start_x,start_y,v,inf,m,n);\\n            vector<vector<int>> G(m,vector<int>(n,0));\\n            Dismantle(start_x,start_y,inf,G,m,n);\\n            ContaminateMarking(inf,m,n);   \\n            Contaminate(inf,m,n);     \\n         }\\n    }\\n\\n  \\nvoid initialize(vector<vector<int>>& v, int m , int n,vector<vector<int>>& inf)\\n    {\\n        for(int i = 0 ;i<m;i++)\\n        {\\n            for(int j = 0 ; j<n;j++)\\n            {\\n                if(inf[i][j]==0)\\n                    v[i][j]=0;\\n            }\\n        }\\n    }\\n\\n   int blocks(int x, int y,vector<vector<int>>& v,  vector<vector<int>>& inf , int m , int n)\\n    {\\n          if(x<0||x>=m||y<0||y>=n)\\n            return 0 ;\\n            \\n           \\n\\n            if(v[x][y]==1)\\n                return 0;\\n\\n            v[x][y] = 1;\\n            \\n            if(inf[x][y]==0)\\n                return 1;\\n            if(inf[x][y]==-1)\\n                return 0; \\n\\n\\n            int sum = 0 ;\\n            if(inf[x][y]==1)\\n            {\\n                sum+=blocks(x+1,y,v,inf,m,n);\\n                sum+=blocks(x-1,y,v,inf,m,n);\\n                sum+=blocks(x,y-1,v,inf,m,n);\\n                sum+=blocks(x,y+1,v,inf,m,n);\\n            }\\n            return sum;\\n\\n\\n    }\\n\\n    int blockToSpread(int x, int y,vector<vector<int>>& v,  vector<vector<int>>& inf , int m , int n)\\n    {\\n          if(x<0||x>=m||y<0||y>=n)\\n            return 0 ;\\n            \\n             if(inf[x][y]==0)\\n                {\\n                 return 1;\\n                }\\n\\n            if(v[x][y]==1)\\n                return 0;\\n\\n            v[x][y] = 1;\\n            \\n            int sum = 0 ;\\n            if(inf[x][y]==1)\\n            {\\n                sum+=blockToSpread(x+1,y,v,inf,m,n);\\n                sum+=blockToSpread(x-1,y,v,inf,m,n);\\n                sum+=blockToSpread(x,y-1,v,inf,m,n);\\n                sum+=blockToSpread(x,y+1,v,inf,m,n);\\n            }\\n            return sum;\\n\\n\\n    }\\n\\n\\n    void Dismantle(int x, int y, vector<vector<int>>& inf , vector<vector<int>>& G , int  m, int n)\\n    {\\n        if(x<0||x>=m||y<0||y>=n)\\n            return;\\n\\n        if(G[x][y]==1)\\n            return;\\n\\n        G[x][y]=1;\\n\\n        if(inf[x][y]==1)\\n        {\\n            inf[x][y]=-1;\\n            Dismantle(x+1,y,inf,G,m,n);\\n            Dismantle(x-1,y,inf,G,m,n);\\n            Dismantle(x,y+1,inf,G,m,n);\\n            Dismantle(x,y-1,inf,G,m,n);\\n\\n        }\\n        else\\n        {\\n            return;\\n        }\\n                    \\n    }\\n\\n    void ContaminateMarking(vector<vector<int>>& inf , int m , int n)\\n    {\\n        \\n\\n        for(int i  = 0 ;i<m;i++)\\n           {\\n               for(int j = 0 ; j<n;j++)\\n                {\\n                    if(inf[i][j]==1)\\n                        {\\n                            ContaminateBlockMarking(i+1,j,inf,m,n);\\n                            ContaminateBlockMarking(i-1,j,inf,m,n);\\n                            ContaminateBlockMarking(i,j+1,inf,m,n);\\n                            ContaminateBlockMarking(i,j-1,inf,m,n);\\n                        }\\n                }\\n           }\\n        \\n       \\n        return;\\n\\n    }\\n\\n     void ContaminateBlockMarking(int x , int y , vector<vector<int>>& inf, int m ,int  n )\\n    {\\n          if(x<0||x>=m||y<0||y>=n)\\n            return;\\n           \\n          if(inf[x][y] == 0)\\n            inf[x][y] = -2;\\n\\n        return;\\n\\n    }\\n\\n    void Contaminate(vector<vector<int>>& inf , int m , int n)\\n    {\\n           for(int i  = 0 ;i<m;i++)\\n           {\\n               for(int j = 0 ; j<n;j++)\\n                {\\n                    if(inf[i][j]==-2)\\n                        inf[i][j]= 1;\\n                }\\n           }\\n           return;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int containVirus(vector<vector<int>>& inf) {\\n\\n \\n        int m  = inf.size();\\n        int n = inf[0].size();\\n        int ans = FindWalls(m,n,inf);  \\n        return ans;    \\n\\n    }\\n\\n    int FindWalls(int m , int n , vector<vector<int>>& inf)\\n    {\\n       \\n         int ans = 0;\\n         int maxima = 0 ;\\n         int start_x = 0;\\n         int start_y = 0;\\n         \\n         while(true)\\n         {\\n            maxima = 0;\\n            int local_ans = 0;\\n            vector<vector<int>> v(m,vector<int>(n,0));\\n            for(int i = 0 ; i< m;i++)\\n            {\\n                for(int j = 0 ;j<n;j++)\\n                {\\n                      \\n                   \\n                    if(inf[i][j]==1&&v[i][j]==0)\\n                    {\\n                        initialize(v,m,n,inf);\\n                        local_ans = blocks(i,j,v,inf,m,n);\\n                        if(local_ans>maxima)\\n                        {\\n                            start_x = i;\\n                            start_y = j;\\n                        }\\n                        maxima = max(maxima,local_ans);\\n                    }\\n\\n                }\\n\\n             }\\n\\n             if(maxima == 0)\\n                return ans;\\n            \\n            for(int i = 0 ;i<m;i++)\\n                for(int j =0 ; j<n;j++)\\n                    v[i][j]=0;\\n            ans+=blockToSpread(start_x,start_y,v,inf,m,n);\\n            vector<vector<int>> G(m,vector<int>(n,0));\\n            Dismantle(start_x,start_y,inf,G,m,n);\\n            ContaminateMarking(inf,m,n);   \\n            Contaminate(inf,m,n);     \\n         }\\n    }\\n\\n  \\nvoid initialize(vector<vector<int>>& v, int m , int n,vector<vector<int>>& inf)\\n    {\\n        for(int i = 0 ;i<m;i++)\\n        {\\n            for(int j = 0 ; j<n;j++)\\n            {\\n                if(inf[i][j]==0)\\n                    v[i][j]=0;\\n            }\\n        }\\n    }\\n\\n   int blocks(int x, int y,vector<vector<int>>& v,  vector<vector<int>>& inf , int m , int n)\\n    {\\n          if(x<0||x>=m||y<0||y>=n)\\n            return 0 ;\\n            \\n           \\n\\n            if(v[x][y]==1)\\n                return 0;\\n\\n            v[x][y] = 1;\\n            \\n            if(inf[x][y]==0)\\n                return 1;\\n            if(inf[x][y]==-1)\\n                return 0; \\n\\n\\n            int sum = 0 ;\\n            if(inf[x][y]==1)\\n            {\\n                sum+=blocks(x+1,y,v,inf,m,n);\\n                sum+=blocks(x-1,y,v,inf,m,n);\\n                sum+=blocks(x,y-1,v,inf,m,n);\\n                sum+=blocks(x,y+1,v,inf,m,n);\\n            }\\n            return sum;\\n\\n\\n    }\\n\\n    int blockToSpread(int x, int y,vector<vector<int>>& v,  vector<vector<int>>& inf , int m , int n)\\n    {\\n          if(x<0||x>=m||y<0||y>=n)\\n            return 0 ;\\n            \\n             if(inf[x][y]==0)\\n                {\\n                 return 1;\\n                }\\n\\n            if(v[x][y]==1)\\n                return 0;\\n\\n            v[x][y] = 1;\\n            \\n            int sum = 0 ;\\n            if(inf[x][y]==1)\\n            {\\n                sum+=blockToSpread(x+1,y,v,inf,m,n);\\n                sum+=blockToSpread(x-1,y,v,inf,m,n);\\n                sum+=blockToSpread(x,y-1,v,inf,m,n);\\n                sum+=blockToSpread(x,y+1,v,inf,m,n);\\n            }\\n            return sum;\\n\\n\\n    }\\n\\n\\n    void Dismantle(int x, int y, vector<vector<int>>& inf , vector<vector<int>>& G , int  m, int n)\\n    {\\n        if(x<0||x>=m||y<0||y>=n)\\n            return;\\n\\n        if(G[x][y]==1)\\n            return;\\n\\n        G[x][y]=1;\\n\\n        if(inf[x][y]==1)\\n        {\\n            inf[x][y]=-1;\\n            Dismantle(x+1,y,inf,G,m,n);\\n            Dismantle(x-1,y,inf,G,m,n);\\n            Dismantle(x,y+1,inf,G,m,n);\\n            Dismantle(x,y-1,inf,G,m,n);\\n\\n        }\\n        else\\n        {\\n            return;\\n        }\\n                    \\n    }\\n\\n    void ContaminateMarking(vector<vector<int>>& inf , int m , int n)\\n    {\\n        \\n\\n        for(int i  = 0 ;i<m;i++)\\n           {\\n               for(int j = 0 ; j<n;j++)\\n                {\\n                    if(inf[i][j]==1)\\n                        {\\n                            ContaminateBlockMarking(i+1,j,inf,m,n);\\n                            ContaminateBlockMarking(i-1,j,inf,m,n);\\n                            ContaminateBlockMarking(i,j+1,inf,m,n);\\n                            ContaminateBlockMarking(i,j-1,inf,m,n);\\n                        }\\n                }\\n           }\\n        \\n       \\n        return;\\n\\n    }\\n\\n     void ContaminateBlockMarking(int x , int y , vector<vector<int>>& inf, int m ,int  n )\\n    {\\n          if(x<0||x>=m||y<0||y>=n)\\n            return;\\n           \\n          if(inf[x][y] == 0)\\n            inf[x][y] = -2;\\n\\n        return;\\n\\n    }\\n\\n    void Contaminate(vector<vector<int>>& inf , int m , int n)\\n    {\\n           for(int i  = 0 ;i<m;i++)\\n           {\\n               for(int j = 0 ; j<n;j++)\\n                {\\n                    if(inf[i][j]==-2)\\n                        inf[i][j]= 1;\\n                }\\n           }\\n           return;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414543,
                "title": "detailed-and-clear-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def containVirus(self, isInfected: List[List[int]]) -> int:\\n        \\'\\'\\'\\n        isInfected[r][c]:\\n            0 : Uninfected\\n            1 : Infected\\n            2 : Infected & restricted\\n        \\'\\'\\'\\n        m = len(isInfected)\\n        n = len(isInfected[0])\\n\\n        borders = 0\\n        threatened = 0\\n        def dfs(r, c, id):\\n            nonlocal borders, threatened\\n            if r < 0 or r>=m or c < 0 or c>=n:\\n                return\\n\\n            if isInfected[r][c] == 1:\\n                if visited[r][c] == 0:\\n                    visited[r][c] = 1\\n                    dfs(r-1, c, id)\\n                    dfs(r+1, c, id)\\n                    dfs(r, c-1, id)\\n                    dfs(r, c+1, id)\\n                else:\\n                    pass\\n            elif isInfected[r][c] == 0:\\n                if visited[r][c] == id:\\n                    borders += 1\\n                else:\\n                    borders += 1\\n                    threatened += 1\\n                    visited[r][c] = id\\n        \\n        def flood(r, c, find, repl):\\n            if r < 0 or r>=m or c < 0 or c>=n or isInfected[r][c] != find:\\n                return\\n            isInfected[r][c] = repl\\n            flood(r-1, c, find, repl)\\n            flood(r+1, c, find, repl)\\n            flood(r, c-1, find, repl)\\n            flood(r, c+1, find, repl)\\n        \\n        def expand(r, c, id):\\n            if r < 0 or r>=m or c < 0 or c>=n or visited[r][c] == 1:\\n                return\\n            visited[r][c] = 1\\n            if isInfected[r][c] == 0:\\n                isInfected[r][c] = 1\\n            elif isInfected[r][c] == 1:\\n                expand(r+1, c, id)\\n                expand(r-1, c, id)\\n                expand(r, c-1, id)\\n                expand(r, c+1, id)   \\n\\n        total_walls = 0\\n\\n        while True:\\n            # Day ---------------------------------------------------\\n            max_th = 0\\n            max_th_loc = (None, None)\\n            max_th_border = 0\\n            id = 3\\n            visited = [[0] * n for _ in range(m)]\\n\\n            for r in range(m):\\n                for c in range(n):\\n                    if isInfected[r][c]==1 and visited[r][c] == 0:\\n                        \\n                        borders = 0\\n                        threatened = 0\\n                        dfs(r, c, id)\\n                        id += 1\\n                        if threatened > max_th:\\n                            max_th = threatened\\n                            max_th_loc = r, c\\n                            max_th_border = borders\\n            \\n            if max_th == 0:\\n                break\\n            total_walls += max_th_border\\n            # Restrict bordered region by making them dormant\\n            flood(*max_th_loc, 1, 2)\\n\\n            # Night -------------------------------------------------\\n\\n            visited = [[0] * n for _ in range(m)]\\n            for r in range(m):\\n                for c in range(n):\\n                    if isInfected[r][c]==1 and visited[r][c] == 0:\\n                        expand(r, c, id)\\n                        id += 1\\n\\n        return total_walls\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containVirus(self, isInfected: List[List[int]]) -> int:\\n        \\'\\'\\'\\n        isInfected[r][c]:\\n            0 : Uninfected\\n            1 : Infected\\n            2 : Infected & restricted\\n        \\'\\'\\'\\n        m = len(isInfected)\\n        n = len(isInfected[0])\\n\\n        borders = 0\\n        threatened = 0\\n        def dfs(r, c, id):\\n            nonlocal borders, threatened\\n            if r < 0 or r>=m or c < 0 or c>=n:\\n                return\\n\\n            if isInfected[r][c] == 1:\\n                if visited[r][c] == 0:\\n                    visited[r][c] = 1\\n                    dfs(r-1, c, id)\\n                    dfs(r+1, c, id)\\n                    dfs(r, c-1, id)\\n                    dfs(r, c+1, id)\\n                else:\\n                    pass\\n            elif isInfected[r][c] == 0:\\n                if visited[r][c] == id:\\n                    borders += 1\\n                else:\\n                    borders += 1\\n                    threatened += 1\\n                    visited[r][c] = id\\n        \\n        def flood(r, c, find, repl):\\n            if r < 0 or r>=m or c < 0 or c>=n or isInfected[r][c] != find:\\n                return\\n            isInfected[r][c] = repl\\n            flood(r-1, c, find, repl)\\n            flood(r+1, c, find, repl)\\n            flood(r, c-1, find, repl)\\n            flood(r, c+1, find, repl)\\n        \\n        def expand(r, c, id):\\n            if r < 0 or r>=m or c < 0 or c>=n or visited[r][c] == 1:\\n                return\\n            visited[r][c] = 1\\n            if isInfected[r][c] == 0:\\n                isInfected[r][c] = 1\\n            elif isInfected[r][c] == 1:\\n                expand(r+1, c, id)\\n                expand(r-1, c, id)\\n                expand(r, c-1, id)\\n                expand(r, c+1, id)   \\n\\n        total_walls = 0\\n\\n        while True:\\n            # Day ---------------------------------------------------\\n            max_th = 0\\n            max_th_loc = (None, None)\\n            max_th_border = 0\\n            id = 3\\n            visited = [[0] * n for _ in range(m)]\\n\\n            for r in range(m):\\n                for c in range(n):\\n                    if isInfected[r][c]==1 and visited[r][c] == 0:\\n                        \\n                        borders = 0\\n                        threatened = 0\\n                        dfs(r, c, id)\\n                        id += 1\\n                        if threatened > max_th:\\n                            max_th = threatened\\n                            max_th_loc = r, c\\n                            max_th_border = borders\\n            \\n            if max_th == 0:\\n                break\\n            total_walls += max_th_border\\n            # Restrict bordered region by making them dormant\\n            flood(*max_th_loc, 1, 2)\\n\\n            # Night -------------------------------------------------\\n\\n            visited = [[0] * n for _ in range(m)]\\n            for r in range(m):\\n                for c in range(n):\\n                    if isInfected[r][c]==1 and visited[r][c] == 0:\\n                        expand(r, c, id)\\n                        id += 1\\n\\n        return total_walls\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175629,
                "title": "simple-explained-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    int ans = 0;\\n    \\n    // -1 means disinfected\\n    int color = 2;\\n    \\n    // for perimeter calculation we cannot go to cells marked -1 but we can goto all other cells\\n    int perimeter = 0;\\n    \\n    // we can go to cells marked as 0 only\\n    // this will store the area being threatened\\n    int areat = 0;\\n    \\n    int containVirus(vector<vector<int>>& a) {\\n        m = a.size();\\n        n = a[0].size();\\n\\n        while(1){\\n            int restrictX, restrictY;\\n            int big = -1;\\n            for(int i = 0 ; i < m ; i++){\\n                for(int j = 0 ; j < n ; j++){\\n                    if(a[i][j] == color-1){\\n                        \\n                        //capture this region and color it with color\\n                        dfs(a, i, j);\\n                        areat = 0;\\n                        set<pair<int, int>> visited;\\n                        calculateAreat(a, i, j, visited);\\n                        //calculateAreat marks the region with -2 so we will restore\\n                        restore(a, i, j);\\n                        if(big < areat){\\n                            big = areat;\\n                            restrictX = i;\\n                            restrictY = j;\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            if(big != -1){\\n                perimeter = 0;\\n                calculatePerimeter(a, restrictX, restrictY);\\n                ans += perimeter;\\n                int temp = color;\\n                color = -1;\\n                // disinfect this region by marking as -1\\n                restore(a, restrictX, restrictY);\\n                \\n                color = temp+1;\\n                for(int i = 0 ; i < m ; i++){\\n                    for(int j = 0 ; j < n ; j++){\\n                        if(a[i][j] == color-1){\\n                            expand(a, i, j, a[i][j]);\\n                            // expand marks the region as -2 so we restore it to color\\n                            restore(a, i, j);\\n                        }\\n                    }\\n                }\\n                color++;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    void expand(vector<vector<int>>& a, int x, int y, int currcolor){\\n        if(x < 0 || y < 0 || x >= m || y >= n){\\n            return;\\n        }\\n        \\n        if(a[x][y] == 0){\\n            a[x][y] = -2;\\n            return;\\n        }\\n        \\n        if(a[x][y] == -2 || a[x][y] == -1 || a[x][y] != currcolor){\\n            return;\\n        }\\n        \\n        a[x][y] = -2;\\n        expand(a, x+1, y, currcolor);\\n        expand(a, x, y+1, currcolor);\\n        expand(a, x, y-1, currcolor);\\n        expand(a, x-1, y, currcolor);\\n    }\\n    \\n    void dfs(vector<vector<int>>& a, int x, int y){\\n        if(x < 0 || y < 0 || x >= m || y >= n || a[x][y] == 0 || a[x][y] == -1){\\n            return;\\n        }\\n        \\n        if(a[x][y] == color){\\n            return;\\n        }\\n        \\n        a[x][y] = color;\\n        dfs(a, x+1, y);\\n        dfs(a, x, y+1);\\n        dfs(a, x, y-1);\\n        dfs(a, x-1, y);\\n    }\\n    \\n    void restore(vector<vector<int>>& a, int x, int y){\\n        if(x < 0 || y < 0 || x >= m || y >= n || a[x][y] == 0 || a[x][y] != -2){\\n            return;\\n        }\\n        \\n        a[x][y] = color;\\n        restore(a, x+1, y);\\n        restore(a, x, y+1);\\n        restore(a, x, y-1);\\n        restore(a, x-1, y);\\n    }\\n    \\n    // -2 is under processing\\n    void calculatePerimeter(vector<vector<int>>& a, int x, int y){\\n        if(x < 0 || y < 0 || x >= m || y >= n || a[x][y] == -1 || a[x][y] == -2){\\n            return;\\n        }\\n        \\n        if(a[x][y] == 0){\\n            perimeter++;\\n            return;\\n        }\\n        \\n        a[x][y] = -2;\\n        calculatePerimeter(a, x+1, y);\\n        calculatePerimeter(a, x, y+1);\\n        calculatePerimeter(a, x, y-1);\\n        calculatePerimeter(a, x-1, y);\\n    }\\n    \\n    // -2 is under processing\\n    void calculateAreat(vector<vector<int>>& a, int x, int y, set<pair<int, int>> &visited){\\n        if(x < 0 || y < 0 || x >= m || y >= n || a[x][y] == -2 \\n           || a[x][y] == -1 || visited.count({x,y})){\\n            return;\\n        }\\n        \\n        if(a[x][y] == 0){\\n            visited.insert({x,y});\\n            areat++;\\n            return;\\n        }\\n        \\n        a[x][y] = -2;\\n        calculateAreat(a, x+1, y, visited);\\n        calculateAreat(a, x, y+1, visited);\\n        calculateAreat(a, x, y-1, visited);\\n        calculateAreat(a, x-1, y, visited);\\n    }\\n    \\n    void print(vector<vector<int>> &a){\\n        for(int i = 0 ; i < m ; i++){\\n            for(int j = 0 ; j < n ; j++){\\n                cout<<a[i][j]<<\"\\\\t\";\\n            }\\n            cout<<endl;\\n        }\\n        cout<<endl;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "JavaScript",
                    "Ruby",
                    "Scala",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m, n;\\n    int ans = 0;\\n    \\n    // -1 means disinfected\\n    int color = 2;\\n    \\n    // for perimeter calculation we cannot go to cells marked -1 but we can goto all other cells\\n    int perimeter = 0;\\n    \\n    // we can go to cells marked as 0 only\\n    // this will store the area being threatened\\n    int areat = 0;\\n    \\n    int containVirus(vector<vector<int>>& a) {\\n        m = a.size();\\n        n = a[0].size();\\n\\n        while(1){\\n            int restrictX, restrictY;\\n            int big = -1;\\n            for(int i = 0 ; i < m ; i++){\\n                for(int j = 0 ; j < n ; j++){\\n                    if(a[i][j] == color-1){\\n                        \\n                        //capture this region and color it with color\\n                        dfs(a, i, j);\\n                        areat = 0;\\n                        set<pair<int, int>> visited;\\n                        calculateAreat(a, i, j, visited);\\n                        //calculateAreat marks the region with -2 so we will restore\\n                        restore(a, i, j);\\n                        if(big < areat){\\n                            big = areat;\\n                            restrictX = i;\\n                            restrictY = j;\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            if(big != -1){\\n                perimeter = 0;\\n                calculatePerimeter(a, restrictX, restrictY);\\n                ans += perimeter;\\n                int temp = color;\\n                color = -1;\\n                // disinfect this region by marking as -1\\n                restore(a, restrictX, restrictY);\\n                \\n                color = temp+1;\\n                for(int i = 0 ; i < m ; i++){\\n                    for(int j = 0 ; j < n ; j++){\\n                        if(a[i][j] == color-1){\\n                            expand(a, i, j, a[i][j]);\\n                            // expand marks the region as -2 so we restore it to color\\n                            restore(a, i, j);\\n                        }\\n                    }\\n                }\\n                color++;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    void expand(vector<vector<int>>& a, int x, int y, int currcolor){\\n        if(x < 0 || y < 0 || x >= m || y >= n){\\n            return;\\n        }\\n        \\n        if(a[x][y] == 0){\\n            a[x][y] = -2;\\n            return;\\n        }\\n        \\n        if(a[x][y] == -2 || a[x][y] == -1 || a[x][y] != currcolor){\\n            return;\\n        }\\n        \\n        a[x][y] = -2;\\n        expand(a, x+1, y, currcolor);\\n        expand(a, x, y+1, currcolor);\\n        expand(a, x, y-1, currcolor);\\n        expand(a, x-1, y, currcolor);\\n    }\\n    \\n    void dfs(vector<vector<int>>& a, int x, int y){\\n        if(x < 0 || y < 0 || x >= m || y >= n || a[x][y] == 0 || a[x][y] == -1){\\n            return;\\n        }\\n        \\n        if(a[x][y] == color){\\n            return;\\n        }\\n        \\n        a[x][y] = color;\\n        dfs(a, x+1, y);\\n        dfs(a, x, y+1);\\n        dfs(a, x, y-1);\\n        dfs(a, x-1, y);\\n    }\\n    \\n    void restore(vector<vector<int>>& a, int x, int y){\\n        if(x < 0 || y < 0 || x >= m || y >= n || a[x][y] == 0 || a[x][y] != -2){\\n            return;\\n        }\\n        \\n        a[x][y] = color;\\n        restore(a, x+1, y);\\n        restore(a, x, y+1);\\n        restore(a, x, y-1);\\n        restore(a, x-1, y);\\n    }\\n    \\n    // -2 is under processing\\n    void calculatePerimeter(vector<vector<int>>& a, int x, int y){\\n        if(x < 0 || y < 0 || x >= m || y >= n || a[x][y] == -1 || a[x][y] == -2){\\n            return;\\n        }\\n        \\n        if(a[x][y] == 0){\\n            perimeter++;\\n            return;\\n        }\\n        \\n        a[x][y] = -2;\\n        calculatePerimeter(a, x+1, y);\\n        calculatePerimeter(a, x, y+1);\\n        calculatePerimeter(a, x, y-1);\\n        calculatePerimeter(a, x-1, y);\\n    }\\n    \\n    // -2 is under processing\\n    void calculateAreat(vector<vector<int>>& a, int x, int y, set<pair<int, int>> &visited){\\n        if(x < 0 || y < 0 || x >= m || y >= n || a[x][y] == -2 \\n           || a[x][y] == -1 || visited.count({x,y})){\\n            return;\\n        }\\n        \\n        if(a[x][y] == 0){\\n            visited.insert({x,y});\\n            areat++;\\n            return;\\n        }\\n        \\n        a[x][y] = -2;\\n        calculateAreat(a, x+1, y, visited);\\n        calculateAreat(a, x, y+1, visited);\\n        calculateAreat(a, x, y-1, visited);\\n        calculateAreat(a, x-1, y, visited);\\n    }\\n    \\n    void print(vector<vector<int>> &a){\\n        for(int i = 0 ; i < m ; i++){\\n            for(int j = 0 ; j < n ; j++){\\n                cout<<a[i][j]<<\"\\\\t\";\\n            }\\n            cout<<endl;\\n        }\\n        cout<<endl;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3030370,
                "title": "golang-dfs-easy-to-understand",
                "content": "```go\\nfunc containVirus(isInfected [][]int) int {\\n  m, n := len(isInfected), len(isInfected[0])\\n  var res int\\n  for {\\n    // Let\\'s do a depth first search and find the region that spread the most cells\\n    // (i.e) needs more walls to be built\\n    visited := make([][]bool, m)\\n    for i := 0; i < m; i++ {\\n      visited[i] = make([]bool, n)\\n    }\\n    // We want to focus on the region that can affect the most unaffected neighbors\\n    // The unaffected neighbors and the walls needed is different because an unaffected neighbor\\n    // can be infected by multiple neighbors and hence will need multiple walls.\\n    var wallsNeeded [][4]int // <x, y, uninfectedNeighbors, walls>\\n    for i := 0; i < m; i++ {\\n      for j := 0; j < n; j++ {\\n        if isInfected[i][j] == 1 && !visited[i][j] {\\n          visited[i][j] = true\\n          uninfectedNeighbors := make(map[[2]int]bool)\\n          count := countWalls(isInfected, visited, i, j, uninfectedNeighbors)\\n          wallsNeeded = append(wallsNeeded, [4]int{i, j, len(uninfectedNeighbors), count})\\n        }\\n      }\\n    }\\n    if len(wallsNeeded) == 0 {\\n      break\\n    }\\n    // Let\\'s sort wallsNeeded in descending order on the number of walls\\n    sort.Slice(wallsNeeded, func(i, j int) bool {\\n      return wallsNeeded[i][2] > wallsNeeded[j][2]\\n    })\\n    res += wallsNeeded[0][3]\\n    buildWall(isInfected, wallsNeeded[0][0], wallsNeeded[0][1])\\n    spread(isInfected)\\n  }\\n  return res\\n}\\n\\nvar directions = [4][2]int{{0, -1}, {-1, 0}, {1, 0}, {0, 1}}\\n\\nfunc countWalls(isInfected [][]int, visited [][]bool, row, col int, uninfectedNeighbors map[[2]int]bool) int {\\n  m, n := len(isInfected), len(isInfected[0])\\n  var walls int\\n  for _, dir := range directions {\\n    x, y := row + dir[0], col + dir[1]\\n    if x >= 0 && x < m && y >= 0 && y < n && !visited[x][y] {\\n      if isInfected[x][y] == 0 {\\n        uninfectedNeighbors[[2]int{x, y}] = true\\n        walls++\\n      } else if isInfected[x][y] == 1 {\\n        visited[x][y] = true\\n        walls += countWalls(isInfected, visited, x, y, uninfectedNeighbors)\\n      }\\n    }\\n  }\\n  return walls\\n}\\n\\n// buildWall builds the wall around the given region (specified by a single cell)\\n// It uses DFS and marks the cells with -1 which means the region is contained\\nfunc buildWall(isInfected [][]int, row, col int) {\\n  m, n := len(isInfected), len(isInfected[0])\\n  isInfected[row][col] = -1\\n  for _, dir := range directions {\\n    x, y := row+dir[0], col+dir[1]\\n    if x >= 0 && x < m && y >= 0 && y < n && isInfected[x][y] == 1 {\\n      buildWall(isInfected, x, y)\\n    }\\n  }\\n}\\n\\n// spread spreads the virus from the infected positions to their neighbor cells\\nfunc spread(isInfected [][]int) {\\n  m, n := len(isInfected), len(isInfected[0])\\n  for i := 0; i < m; i++ {\\n    for j := 0; j < n; j++ {\\n      if isInfected[i][j] == 1 {\\n        for _, dir := range directions {\\n          x, y := i+dir[0], j+dir[1]\\n          if x >= 0 && x < m && y >= 0 && y < n && isInfected[x][y] == 0 {\\n            // newly infected cells with special character since we don\\'t want the neighbor\\n            // of this cell to be infected\\n            isInfected[x][y] = 2 \\n          }\\n        }\\n      }\\n    }\\n  }\\n  // Remove the special marking\\n  for i := 0; i < m; i++ {\\n    for j := 0; j < n; j++ {\\n      if isInfected[i][j] == 2 {\\n        isInfected[i][j] = 1\\n      }\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc containVirus(isInfected [][]int) int {\\n  m, n := len(isInfected), len(isInfected[0])\\n  var res int\\n  for {\\n    // Let\\'s do a depth first search and find the region that spread the most cells\\n    // (i.e) needs more walls to be built\\n    visited := make([][]bool, m)\\n    for i := 0; i < m; i++ {\\n      visited[i] = make([]bool, n)\\n    }\\n    // We want to focus on the region that can affect the most unaffected neighbors\\n    // The unaffected neighbors and the walls needed is different because an unaffected neighbor\\n    // can be infected by multiple neighbors and hence will need multiple walls.\\n    var wallsNeeded [][4]int // <x, y, uninfectedNeighbors, walls>\\n    for i := 0; i < m; i++ {\\n      for j := 0; j < n; j++ {\\n        if isInfected[i][j] == 1 && !visited[i][j] {\\n          visited[i][j] = true\\n          uninfectedNeighbors := make(map[[2]int]bool)\\n          count := countWalls(isInfected, visited, i, j, uninfectedNeighbors)\\n          wallsNeeded = append(wallsNeeded, [4]int{i, j, len(uninfectedNeighbors), count})\\n        }\\n      }\\n    }\\n    if len(wallsNeeded) == 0 {\\n      break\\n    }\\n    // Let\\'s sort wallsNeeded in descending order on the number of walls\\n    sort.Slice(wallsNeeded, func(i, j int) bool {\\n      return wallsNeeded[i][2] > wallsNeeded[j][2]\\n    })\\n    res += wallsNeeded[0][3]\\n    buildWall(isInfected, wallsNeeded[0][0], wallsNeeded[0][1])\\n    spread(isInfected)\\n  }\\n  return res\\n}\\n\\nvar directions = [4][2]int{{0, -1}, {-1, 0}, {1, 0}, {0, 1}}\\n\\nfunc countWalls(isInfected [][]int, visited [][]bool, row, col int, uninfectedNeighbors map[[2]int]bool) int {\\n  m, n := len(isInfected), len(isInfected[0])\\n  var walls int\\n  for _, dir := range directions {\\n    x, y := row + dir[0], col + dir[1]\\n    if x >= 0 && x < m && y >= 0 && y < n && !visited[x][y] {\\n      if isInfected[x][y] == 0 {\\n        uninfectedNeighbors[[2]int{x, y}] = true\\n        walls++\\n      } else if isInfected[x][y] == 1 {\\n        visited[x][y] = true\\n        walls += countWalls(isInfected, visited, x, y, uninfectedNeighbors)\\n      }\\n    }\\n  }\\n  return walls\\n}\\n\\n// buildWall builds the wall around the given region (specified by a single cell)\\n// It uses DFS and marks the cells with -1 which means the region is contained\\nfunc buildWall(isInfected [][]int, row, col int) {\\n  m, n := len(isInfected), len(isInfected[0])\\n  isInfected[row][col] = -1\\n  for _, dir := range directions {\\n    x, y := row+dir[0], col+dir[1]\\n    if x >= 0 && x < m && y >= 0 && y < n && isInfected[x][y] == 1 {\\n      buildWall(isInfected, x, y)\\n    }\\n  }\\n}\\n\\n// spread spreads the virus from the infected positions to their neighbor cells\\nfunc spread(isInfected [][]int) {\\n  m, n := len(isInfected), len(isInfected[0])\\n  for i := 0; i < m; i++ {\\n    for j := 0; j < n; j++ {\\n      if isInfected[i][j] == 1 {\\n        for _, dir := range directions {\\n          x, y := i+dir[0], j+dir[1]\\n          if x >= 0 && x < m && y >= 0 && y < n && isInfected[x][y] == 0 {\\n            // newly infected cells with special character since we don\\'t want the neighbor\\n            // of this cell to be infected\\n            isInfected[x][y] = 2 \\n          }\\n        }\\n      }\\n    }\\n  }\\n  // Remove the special marking\\n  for i := 0; i < m; i++ {\\n    for j := 0; j < n; j++ {\\n      if isInfected[i][j] == 2 {\\n        isInfected[i][j] = 1\\n      }\\n    }\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2958642,
                "title": "python-short-and-easy-to-understand-solution",
                "content": "\\n```\\nclass Solution:\\n    def containVirus(self, isInfected: List[List[int]]) -> int:\\n        walls_needed = 0\\n\\n        # identify infected and uninfected cells\\n        infected = [(i, j) for i in range(len(isInfected)) for j in range(len(isInfected[0])) if isInfected[i][j] == 1]\\n        uninfected = [(i, j) for i in range(len(isInfected)) for j in range(len(isInfected[0])) if isInfected[i][j] != 1]\\n\\n        # group infected cells\\n        def grp_infected(infected):\\n            grp = []\\n            while infected:\\n                cur = [infected.pop()]\\n                cur_grp = [cur[0]]\\n                while cur:\\n                    cur_dot = cur.pop()\\n                    south = (cur_dot[0] - 1, cur_dot[1]); north = (cur_dot[0] + 1, cur_dot[1])\\n                    west = (cur_dot[0], cur_dot[1] - 1); east = (cur_dot[0], cur_dot[1] + 1)\\n                    for i in [south, north, west, east]:\\n                        if i in infected:\\n                            cur_grp.append(i)\\n                            cur.append(i)\\n                            infected.remove(i)\\n                grp.append(cur_grp)\\n            return grp\\n        grp = grp_infected(infected)\\n\\n        # identify next-to-be infected cells and select the correct group to quarantine\\n        while grp and uninfected:\\n            next_grp = []\\n            for i in grp:\\n                next_grp_temp = []\\n                for cur_dot in i:\\n                    south = (cur_dot[0] - 1, cur_dot[1]); north = (cur_dot[0] + 1, cur_dot[1])\\n                    west = (cur_dot[0], cur_dot[1] - 1); east = (cur_dot[0], cur_dot[1] + 1)\\n                    for k in [south, north, west, east]:\\n                        if k in uninfected:\\n                            next_grp_temp.append(k)\\n                next_grp.append(next_grp_temp)\\n\\n            max_infected = [len(set(i)) for i in next_grp]\\n            idx = max_infected.index(max(max_infected))\\n            walls_needed += len(next_grp[idx])\\n\\n            del next_grp[idx]\\n            del grp[idx]\\n            grp = [i + j for i, j in zip(next_grp, grp)]\\n            next_grp = list(set(j for i in next_grp for j in i))\\n            for i in next_grp:\\n                uninfected.remove(i)\\n            grp = grp_infected(list(set(j for i in grp for j in i)))\\n        return walls_needed\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containVirus(self, isInfected: List[List[int]]) -> int:\\n        walls_needed = 0\\n\\n        # identify infected and uninfected cells\\n        infected = [(i, j) for i in range(len(isInfected)) for j in range(len(isInfected[0])) if isInfected[i][j] == 1]\\n        uninfected = [(i, j) for i in range(len(isInfected)) for j in range(len(isInfected[0])) if isInfected[i][j] != 1]\\n\\n        # group infected cells\\n        def grp_infected(infected):\\n            grp = []\\n            while infected:\\n                cur = [infected.pop()]\\n                cur_grp = [cur[0]]\\n                while cur:\\n                    cur_dot = cur.pop()\\n                    south = (cur_dot[0] - 1, cur_dot[1]); north = (cur_dot[0] + 1, cur_dot[1])\\n                    west = (cur_dot[0], cur_dot[1] - 1); east = (cur_dot[0], cur_dot[1] + 1)\\n                    for i in [south, north, west, east]:\\n                        if i in infected:\\n                            cur_grp.append(i)\\n                            cur.append(i)\\n                            infected.remove(i)\\n                grp.append(cur_grp)\\n            return grp\\n        grp = grp_infected(infected)\\n\\n        # identify next-to-be infected cells and select the correct group to quarantine\\n        while grp and uninfected:\\n            next_grp = []\\n            for i in grp:\\n                next_grp_temp = []\\n                for cur_dot in i:\\n                    south = (cur_dot[0] - 1, cur_dot[1]); north = (cur_dot[0] + 1, cur_dot[1])\\n                    west = (cur_dot[0], cur_dot[1] - 1); east = (cur_dot[0], cur_dot[1] + 1)\\n                    for k in [south, north, west, east]:\\n                        if k in uninfected:\\n                            next_grp_temp.append(k)\\n                next_grp.append(next_grp_temp)\\n\\n            max_infected = [len(set(i)) for i in next_grp]\\n            idx = max_infected.index(max(max_infected))\\n            walls_needed += len(next_grp[idx])\\n\\n            del next_grp[idx]\\n            del grp[idx]\\n            grp = [i + j for i, j in zip(next_grp, grp)]\\n            next_grp = list(set(j for i in next_grp for j in i))\\n            for i in next_grp:\\n                uninfected.remove(i)\\n            grp = grp_infected(list(set(j for i in grp for j in i)))\\n        return walls_needed\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937168,
                "title": "python-dfs-and-simulation-explained",
                "content": "* (1) DFS to find all the infected regions\\n* (2) Pick the region that will infect the largetest number of cells in the next day, and build a wall around it\\n* (3) Update the infected regions\\nthe cells that are in the wall is updated with \"controlled\" state (i.e., value 2)\\nthe cells that is on the boundary of uncontrolled regions are updated with \"infected\" state (i.e., value 1)\\n* (4) Go back to step (1) until all the regions are controlled or all the cells are infected.\\n\\n```\\nimport heapq\\n\\nclass Solution:\\n    def containVirus(self, isInfected: List[List[int]]) -> int:\\n        self.n_row = len(isInfected)\\n        self.n_col = len(isInfected[0])\\n        self.ifstat = isInfected\\n        \\n        self.visited = []\\n        for _ in range(self.n_row):\\n            self.visited.append([False for _ in range(self.n_col)])\\n        self.directions = {(0, 1), (1, 0), (0, -1), (-1, 0)}\\n        self.infect_region = []\\n        self.infect_boundary_wall_cnt = []  # a list of the number of walls required to control a region\\n        self.infect_boundary_mheap = [] \\n        \\n\\t\\t# step 1: find all the regions that are infected, including the number of walls required to \"control\" this region\\n        visited = copy.deepcopy(self.visited)\\n        region_idx = 0\\n        for i in range(self.n_row):\\n            for j in range(self.n_col):\\n                if self.ifstat[i][j] == 1 and (not visited[i][j]):\\n                    tr, tb, tbc = list(), set(), [0]\\n                    self.dfsFindVirus(i, j, tr, tb, tbc, visited)\\n                    self.infect_region.append(tr)\\n                    self.infect_boundary_wall_cnt.append(tbc[0])\\n                    heapq.heappush(self.infect_boundary_mheap, (-(len(tb)), region_idx, list(tb)))\\n                    region_idx += 1\\n        \\n        # step 2, simulation the progress of virus infection\\n        ans = 0\\n        while self.infect_boundary_mheap:\\n            # pick the region that can infect largest region next day, and build a wall for it\\n            _, ridx, _ = heapq.heappop(self.infect_boundary_mheap)\\n            for i, j in self.infect_region[ridx]:\\n                self.ifstat[i][j] = 2\\n            ans += self.infect_boundary_wall_cnt[ridx]\\n\\t\\t\\t\\n            # update the cells will be infected next day\\n            while self.infect_boundary_mheap:\\n                _, _, b_list = heapq.heappop(self.infect_boundary_mheap)\\n                for i, j in b_list:\\n                    self.ifstat[i][j] = 1\\n            # check the map and find the new region and boundary\\n            visited = copy.deepcopy(self.visited)\\n            region_idx = 0\\n            t_ir = []\\n            t_ibc = []\\n            self.infect_boundary_wall_cnt.clear()\\n            while self.infect_region:\\n                start = self.infect_region.pop()\\n                i, j = start[0]\\n                if self.ifstat[i][j] == 1 and (not visited[i][j]):\\n                    tr, tb, tbc = list(), set(), [0]\\n                    self.dfsFindVirus(i, j, tr, tb, tbc, visited)\\n                    t_ir.append(tr)\\n                    t_ibc.append(tbc[0])\\n                    heapq.heappush(self.infect_boundary_mheap, (-(len(tb)), region_idx, list(tb)))\\n                    region_idx += 1\\n            self.infect_boundary_wall_cnt = t_ibc\\n            self.infect_region = t_ir\\n        return ans\\n        \\n        \\n    def dfsFindVirus(self, i, j, region, boundary, bcnt, visited):\\n        if visited[i][j] or self.ifstat[i][j] == 2:\\n            return\\n        \\n        if self.ifstat[i][j] == 0:\\n            # this is a boundary\\n            boundary.add((i, j))\\n            bcnt[0] += 1\\n            return\\n        \\n        visited[i][j] = True\\n        region.append((i, j))\\n        \\n        for nidx in self.directions:\\n            ni = i + nidx[0]\\n            nj = j + nidx[1]\\n            \\n            if ni >= 0 and ni < self.n_row and nj >= 0 and nj < self.n_col and (not visited[ni][nj]):\\n                self.dfsFindVirus(ni, nj, region, boundary, bcnt, visited)\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def containVirus(self, isInfected: List[List[int]]) -> int:\\n        self.n_row = len(isInfected)\\n        self.n_col = len(isInfected[0])\\n        self.ifstat = isInfected\\n        \\n        self.visited = []\\n        for _ in range(self.n_row):\\n            self.visited.append([False for _ in range(self.n_col)])\\n        self.directions = {(0, 1), (1, 0), (0, -1), (-1, 0)}\\n        self.infect_region = []\\n        self.infect_boundary_wall_cnt = []  # a list of the number of walls required to control a region\\n        self.infect_boundary_mheap = [] \\n        \\n\\t\\t# step 1: find all the regions that are infected, including the number of walls required to \"control\" this region\\n        visited = copy.deepcopy(self.visited)\\n        region_idx = 0\\n        for i in range(self.n_row):\\n            for j in range(self.n_col):\\n                if self.ifstat[i][j] == 1 and (not visited[i][j]):\\n                    tr, tb, tbc = list(), set(), [0]\\n                    self.dfsFindVirus(i, j, tr, tb, tbc, visited)\\n                    self.infect_region.append(tr)\\n                    self.infect_boundary_wall_cnt.append(tbc[0])\\n                    heapq.heappush(self.infect_boundary_mheap, (-(len(tb)), region_idx, list(tb)))\\n                    region_idx += 1\\n        \\n        # step 2, simulation the progress of virus infection\\n        ans = 0\\n        while self.infect_boundary_mheap:\\n            # pick the region that can infect largest region next day, and build a wall for it\\n            _, ridx, _ = heapq.heappop(self.infect_boundary_mheap)\\n            for i, j in self.infect_region[ridx]:\\n                self.ifstat[i][j] = 2\\n            ans += self.infect_boundary_wall_cnt[ridx]\\n\\t\\t\\t\\n            # update the cells will be infected next day\\n            while self.infect_boundary_mheap:\\n                _, _, b_list = heapq.heappop(self.infect_boundary_mheap)\\n                for i, j in b_list:\\n                    self.ifstat[i][j] = 1\\n            # check the map and find the new region and boundary\\n            visited = copy.deepcopy(self.visited)\\n            region_idx = 0\\n            t_ir = []\\n            t_ibc = []\\n            self.infect_boundary_wall_cnt.clear()\\n            while self.infect_region:\\n                start = self.infect_region.pop()\\n                i, j = start[0]\\n                if self.ifstat[i][j] == 1 and (not visited[i][j]):\\n                    tr, tb, tbc = list(), set(), [0]\\n                    self.dfsFindVirus(i, j, tr, tb, tbc, visited)\\n                    t_ir.append(tr)\\n                    t_ibc.append(tbc[0])\\n                    heapq.heappush(self.infect_boundary_mheap, (-(len(tb)), region_idx, list(tb)))\\n                    region_idx += 1\\n            self.infect_boundary_wall_cnt = t_ibc\\n            self.infect_region = t_ir\\n        return ans\\n        \\n        \\n    def dfsFindVirus(self, i, j, region, boundary, bcnt, visited):\\n        if visited[i][j] or self.ifstat[i][j] == 2:\\n            return\\n        \\n        if self.ifstat[i][j] == 0:\\n            # this is a boundary\\n            boundary.add((i, j))\\n            bcnt[0] += 1\\n            return\\n        \\n        visited[i][j] = True\\n        region.append((i, j))\\n        \\n        for nidx in self.directions:\\n            ni = i + nidx[0]\\n            nj = j + nidx[1]\\n            \\n            if ni >= 0 and ni < self.n_row and nj >= 0 and nj < self.n_col and (not visited[ni][nj]):\\n                self.dfsFindVirus(ni, nj, region, boundary, bcnt, visited)\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931201,
                "title": "python-object-oriented-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is Python version:\\nFor explanation please refer [CPP Version](https://leetcode.com/problems/contain-virus/solutions/847507/cpp-dfs-solution-explained/)\\nCredit goes to: [rai02](https://leetcode.com/rai02/)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS with Creating Cluster objects(for walls,tobeContaminated cells)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(M*N)^^2\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(M*N)\\n# Code\\n```\\nfrom heapq import heapify,heappush,heappop\\nclass Cluster:\\n    def __init__(self):\\n        self.contaminated = set()\\n        self.toBeContaminated = set()\\n        self.wallCnt = 0\\n    # sorting based on # of toBeContaminated in reverse order\\n    def __lt__(self,nxt):\\n        return len(self.toBeContaminated) > len(nxt.toBeContaminated)\\n\\nclass Solution:\\n\\n    def containVirus(self, isInfected: List[List[int]]) -> int:\\n        rows = len(isInfected)\\n        cols = len(isInfected[0])\\n        ans = 0\\n        \\n        def dfs(i,j,cluster):\\n            dirs = [(1,0),(-1,0),(0,1),(0,-1)]\\n            for r,c in dirs:\\n                nr = i + r\\n                nc = j + c\\n                if 0<=nr<rows and 0<=nc<cols:\\n                    if isInfected[nr][nc]==1 and (nr,nc) not in visited:\\n                        cluster.contaminated.add((nr,nc))\\n                        visited.add((nr,nc))\\n                        dfs(nr,nc,cluster)\\n                    elif isInfected[nr][nc]==0:\\n                 # note: we dont add to visited here as two virus cells can attack common normal cell\\n                        cluster.wallCnt += 1\\n                        cluster.toBeContaminated.add((nr,nc))\\n\\n\\n        while True:\\n            visited = set()\\n            hh = []\\n            for i in range(rows):\\n                for j in range(cols):\\n                    if isInfected[i][j]==1 and (i,j) not in visited:\\n                        cluster = Cluster()\\n                        cluster.contaminated.add((i,j))\\n                        visited.add((i,j))\\n                        dfs(i,j,cluster)\\n                        hh.append(cluster)\\n            if not hh:\\n                break\\n            heapify(hh)\\n            # this will return cluster with max toBeContaminated cells\\n            cluster = heappop(hh)\\n            # stopping the virus by building walls\\n            for i,j in cluster.contaminated:\\n                isInfected[i][j] = -1\\n            ans += cluster.wallCnt\\n\\n            while hh:\\n                cluster = hh.pop()\\n                for i,j in cluster.toBeContaminated:\\n                    isInfected[i][j] = 1\\n\\n        return ans\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nfrom heapq import heapify,heappush,heappop\\nclass Cluster:\\n    def __init__(self):\\n        self.contaminated = set()\\n        self.toBeContaminated = set()\\n        self.wallCnt = 0\\n    # sorting based on # of toBeContaminated in reverse order\\n    def __lt__(self,nxt):\\n        return len(self.toBeContaminated) > len(nxt.toBeContaminated)\\n\\nclass Solution:\\n\\n    def containVirus(self, isInfected: List[List[int]]) -> int:\\n        rows = len(isInfected)\\n        cols = len(isInfected[0])\\n        ans = 0\\n        \\n        def dfs(i,j,cluster):\\n            dirs = [(1,0),(-1,0),(0,1),(0,-1)]\\n            for r,c in dirs:\\n                nr = i + r\\n                nc = j + c\\n                if 0<=nr<rows and 0<=nc<cols:\\n                    if isInfected[nr][nc]==1 and (nr,nc) not in visited:\\n                        cluster.contaminated.add((nr,nc))\\n                        visited.add((nr,nc))\\n                        dfs(nr,nc,cluster)\\n                    elif isInfected[nr][nc]==0:\\n                 # note: we dont add to visited here as two virus cells can attack common normal cell\\n                        cluster.wallCnt += 1\\n                        cluster.toBeContaminated.add((nr,nc))\\n\\n\\n        while True:\\n            visited = set()\\n            hh = []\\n            for i in range(rows):\\n                for j in range(cols):\\n                    if isInfected[i][j]==1 and (i,j) not in visited:\\n                        cluster = Cluster()\\n                        cluster.contaminated.add((i,j))\\n                        visited.add((i,j))\\n                        dfs(i,j,cluster)\\n                        hh.append(cluster)\\n            if not hh:\\n                break\\n            heapify(hh)\\n            # this will return cluster with max toBeContaminated cells\\n            cluster = heappop(hh)\\n            # stopping the virus by building walls\\n            for i,j in cluster.contaminated:\\n                isInfected[i][j] = -1\\n            ans += cluster.wallCnt\\n\\n            while hh:\\n                cluster = hh.pop()\\n                for i,j in cluster.toBeContaminated:\\n                    isInfected[i][j] = 1\\n\\n        return ans\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2910579,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nstruct MySolution {\\n    infected: Vec<Vec<i32>>,\\n    n: usize,\\n    m: usize,\\n    c: i32,\\n    mx: usize,\\n    w: i32,\\n    r: i32,\\n    ans: i32,\\n    itr: i32,\\n    s: std::collections::HashSet<usize>,\\n}\\n\\nimpl MySolution {\\n    fn new() -> Self {\\n        MySolution {\\n            infected: vec![vec![]],\\n            n: 0,\\n            m: 0,\\n            c: 2,\\n            mx: 0,\\n            w: 0,\\n            r: 0,\\n            ans: 0,\\n            itr: 0,\\n            s: std::collections::HashSet::new(),\\n        }\\n    }\\n\\n    fn dfs(&mut self, i: i32, j: i32) -> i32 {\\n        if i < 0 || j < 0 {\\n            return 0;\\n        }\\n        let (i, j) = (i as usize, j as usize);\\n        if i >= self.n || j >= self.m || self.infected[i][j] != 1 {\\n            return 0;\\n        }\\n        let mut ans = 0;\\n        if i + 1 < self.n && self.infected[i + 1][j] == 0 {\\n            self.s.insert((i + 1) * self.m + j);\\n            ans += 1;\\n        }\\n        if i >= 1 && self.infected[i - 1][j] == 0 {\\n            self.s.insert((i - 1) * self.m + j);\\n            ans += 1;\\n        }\\n        if j + 1 < self.m && self.infected[i][j + 1] == 0 {\\n            self.s.insert(i * self.m + (j + 1));\\n            ans += 1;\\n        }\\n        if j >= 1 && self.infected[i][j - 1] == 0 {\\n            self.s.insert(i * self.m + (j - 1));\\n            ans += 1;\\n        }\\n        self.infected[i][j] = self.c;\\n        ans += self.dfs(i as i32 + 1, j as i32);\\n        ans += self.dfs(i as i32 - 1, j as i32);\\n        ans += self.dfs(i as i32, j as i32 + 1);\\n        ans += self.dfs(i as i32, j as i32 - 1);\\n        ans\\n    }\\n\\n    fn contain_virus(&mut self, infected: Vec<Vec<i32>>) -> i32 {\\n        self.infected = infected;\\n        self.n = self.infected.len();\\n        self.m = self.infected[0].len();\\n        self.ans = 0;\\n        loop {\\n            self.c = 2;\\n            self.mx = 0;\\n            for i in 0..self.n {\\n                for j in 0..self.m {\\n                    if self.infected[i][j] == 1 {\\n                        self.s.clear();\\n                        let walls = self.dfs(i as i32, j as i32);\\n                        if self.mx < self.s.len() {\\n                            self.mx = self.s.len();\\n                            self.w = walls;\\n                            self.r = self.c;\\n                        }\\n                        self.c += 1;\\n                    }\\n                }\\n            }\\n            if self.mx == 0 {\\n                break;\\n            }\\n            self.ans += self.w;\\n            for i in 0..self.n {\\n                for j in 0..self.m {\\n                    if self.infected[i][j] == self.r {\\n                        self.infected[i][j] = 1e9 as i32;\\n                    } else if self.infected[i][j] > 1 && self.infected[i][j] != 1e9 as i32 {\\n                        self.infected[i][j] = 1;\\n                        if i + 1 < self.n && self.infected[i + 1][j] == 0 {\\n                            self.infected[i + 1][j] = 1;\\n                        }\\n                        if i >= 1 && self.infected[i - 1][j] == 0 {\\n                            self.infected[i - 1][j] = 1;\\n                        }\\n                        if j + 1 < self.m && self.infected[i][j + 1] == 0 {\\n                            self.infected[i][j + 1] = 1;\\n                        }\\n                        if j >= 1 && self.infected[i][j - 1] == 0 {\\n                            self.infected[i][j - 1] = 1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        self.ans\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn contain_virus(is_infected: Vec<Vec<i32>>) -> i32 {\\n        let mut my_solution = MySolution::new();\\n        my_solution.contain_virus(is_infected)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nstruct MySolution {\\n    infected: Vec<Vec<i32>>,\\n    n: usize,\\n    m: usize,\\n    c: i32,\\n    mx: usize,\\n    w: i32,\\n    r: i32,\\n    ans: i32,\\n    itr: i32,\\n    s: std::collections::HashSet<usize>,\\n}\\n\\nimpl MySolution {\\n    fn new() -> Self {\\n        MySolution {\\n            infected: vec![vec![]],\\n            n: 0,\\n            m: 0,\\n            c: 2,\\n            mx: 0,\\n            w: 0,\\n            r: 0,\\n            ans: 0,\\n            itr: 0,\\n            s: std::collections::HashSet::new(),\\n        }\\n    }\\n\\n    fn dfs(&mut self, i: i32, j: i32) -> i32 {\\n        if i < 0 || j < 0 {\\n            return 0;\\n        }\\n        let (i, j) = (i as usize, j as usize);\\n        if i >= self.n || j >= self.m || self.infected[i][j] != 1 {\\n            return 0;\\n        }\\n        let mut ans = 0;\\n        if i + 1 < self.n && self.infected[i + 1][j] == 0 {\\n            self.s.insert((i + 1) * self.m + j);\\n            ans += 1;\\n        }\\n        if i >= 1 && self.infected[i - 1][j] == 0 {\\n            self.s.insert((i - 1) * self.m + j);\\n            ans += 1;\\n        }\\n        if j + 1 < self.m && self.infected[i][j + 1] == 0 {\\n            self.s.insert(i * self.m + (j + 1));\\n            ans += 1;\\n        }\\n        if j >= 1 && self.infected[i][j - 1] == 0 {\\n            self.s.insert(i * self.m + (j - 1));\\n            ans += 1;\\n        }\\n        self.infected[i][j] = self.c;\\n        ans += self.dfs(i as i32 + 1, j as i32);\\n        ans += self.dfs(i as i32 - 1, j as i32);\\n        ans += self.dfs(i as i32, j as i32 + 1);\\n        ans += self.dfs(i as i32, j as i32 - 1);\\n        ans\\n    }\\n\\n    fn contain_virus(&mut self, infected: Vec<Vec<i32>>) -> i32 {\\n        self.infected = infected;\\n        self.n = self.infected.len();\\n        self.m = self.infected[0].len();\\n        self.ans = 0;\\n        loop {\\n            self.c = 2;\\n            self.mx = 0;\\n            for i in 0..self.n {\\n                for j in 0..self.m {\\n                    if self.infected[i][j] == 1 {\\n                        self.s.clear();\\n                        let walls = self.dfs(i as i32, j as i32);\\n                        if self.mx < self.s.len() {\\n                            self.mx = self.s.len();\\n                            self.w = walls;\\n                            self.r = self.c;\\n                        }\\n                        self.c += 1;\\n                    }\\n                }\\n            }\\n            if self.mx == 0 {\\n                break;\\n            }\\n            self.ans += self.w;\\n            for i in 0..self.n {\\n                for j in 0..self.m {\\n                    if self.infected[i][j] == self.r {\\n                        self.infected[i][j] = 1e9 as i32;\\n                    } else if self.infected[i][j] > 1 && self.infected[i][j] != 1e9 as i32 {\\n                        self.infected[i][j] = 1;\\n                        if i + 1 < self.n && self.infected[i + 1][j] == 0 {\\n                            self.infected[i + 1][j] = 1;\\n                        }\\n                        if i >= 1 && self.infected[i - 1][j] == 0 {\\n                            self.infected[i - 1][j] = 1;\\n                        }\\n                        if j + 1 < self.m && self.infected[i][j + 1] == 0 {\\n                            self.infected[i][j + 1] = 1;\\n                        }\\n                        if j >= 1 && self.infected[i][j - 1] == 0 {\\n                            self.infected[i][j - 1] = 1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        self.ans\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn contain_virus(is_infected: Vec<Vec<i32>>) -> i32 {\\n        let mut my_solution = MySolution::new();\\n        my_solution.contain_virus(is_infected)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2868419,
                "title": "simulation-approach-utilizing-union-find-to-keep-track-of-regions-and-bfs-to-expand-a-virus-region",
                "content": "# Intuition\\nWe will perform an actual simulation of the virus infection.\\n\\n# Approach\\nThe logical approach isn\\'t a complicated one, rather it\\'s even presented in the problem statement:\\n- Keep track of the virus regions\\n- For each virus region, find the cells threatened by that region.\\n    - all these cells will either be used to help build a border or they will be used to allow the virus to expand into them.\\n- For the region which threatens the most unaffected cells, border it.\\n- For all the other regions, expand into the threatened cells.\\n- If any regions touch, they become one region.\\n\\nThe difficulty comes when deciding how to best represent the data, and it seems that UnionFind fits the bill decently (especially good at handling regions coming into contact). (but even so, it requires decent amount of coding).\\n\\n# Complexity\\n- Time complexity:\\n    - Union-find operations require O(1) amortized time.\\n    - for each simulation day, we swipe once over the matrix with a BFS per region, total cumulating under O(m*n)\\n    - initial number of regions can be O(m*n), but, without doing too much crazy math, it seems that the more regions there are, the faster they would connect, reducing fast the number of iterations.\\n        - upper bound time complexity O(m^2*n^2), but in practice should be lower\\n\\n- Space complexity:\\nO(m*n) since we\\'re keeping track of the grid, the union-find forest, and the cumulated regional BFSes do not go over the size of the matrix.\\n\\n# Code\\n```\\nimport scala.collection._\\nimport VirusQuarantine._\\n\\nobject Solution {\\n    def containVirus(isInfected: Array[Array[Int]]): Int = {\\n        val positions = (for {\\n            r <- isInfected.indices\\n            c <- isInfected(r).indices\\n        } yield {\\n            Position(r, c)\\n        })\\n        new VirusQuarantine(isInfected, positions).quarantine()\\n    }\\n}\\n\\nobject VirusQuarantine {\\n    case class Position(r: Int, c: Int)\\n\\n    case class ThreatenedCells(virusCellThreat: Position, uninfectedCells: Seq[Position])\\n\\n    implicit class PositionOps(p: Position) {\\n        def +(q: Position): Position = Position(p.r + q.r, p.c + q.c)\\n    }\\n\\n    val Directions = Seq(Position(1, 0), Position(-1, 0), Position(0, 1), Position(0, -1))\\n}\\n\\nclass VirusQuarantine(grid: Array[Array[Int]], positions: Seq[Position]) extends UnionFind[Position](positions) {\\n    private val rows = grid.size\\n    private val cols = grid(0).size\\n\\n    // init the union-find forest.\\n    for {\\n        r <- 0 until rows\\n        c <- 0 until cols\\n        p = Position(r, c)\\n        if p.isInfected()\\n    } {\\n        if (c < cols - 1 && grid(r)(c + 1) == 1)\\n            union(p)(Position(r, c + 1))\\n        if (r < rows - 1 && grid(r + 1)(c) == 1)\\n            union(p)(Position(r + 1, c))\\n    }\\n\\n    def quarantine(): Int = {\\n        var wallsCount = 0\\n\\n        val containedRegionsRoots = mutable.Set[Position]()\\n\\n        while (true) {\\n            val uncontainedRegionsRoots = roots().filter(_.isInfected).toSet.diff(containedRegionsRoots)\\n            \\n            if (uncontainedRegionsRoots.isEmpty) return wallsCount\\n\\n            val threatenedCellsByRegion = uncontainedRegionsRoots.map(findThreatenedCells)\\n            val maxCellCountThreatenedByOneRegion = threatenedCellsByRegion.map(_.uninfectedCells.size).max\\n\\n            val threatenedCellsToBorder = threatenedCellsByRegion.find(_.uninfectedCells.size == maxCellCountThreatenedByOneRegion).get\\n            \\n            val remainingUncontainedRegions = threatenedCellsByRegion - threatenedCellsToBorder\\n            \\n            wallsCount += border(threatenedCellsToBorder)\\n            containedRegionsRoots += find(threatenedCellsToBorder.virusCellThreat)\\n            \\n            remainingUncontainedRegions.map(_.uninfectedCells.map(_.infect))\\n        }\\n\\n        throw new IllegalStateException(\"unreachable statement\")\\n    }\\n\\n    private implicit class GridPositionOps(p: Position) {\\n        def isWithinBounds(): Boolean = \\n            0 <= p.r && p.r < rows && 0 <= p.c && p.c < cols\\n\\n        def isInfected(): Boolean = grid(p.r)(p.c) == 1\\n\\n        def infect(): Unit = {\\n            grid(p.r)(p.c) = 1\\n            getReachableNeighbors(p)\\n                .filter(_.isInfected)\\n                .foreach(union(p))\\n        }\\n    }\\n\\n    private def findThreatenedCells(infectedPosition: Position): ThreatenedCells = {\\n        val root = find(infectedPosition)\\n        val q = mutable.Queue[Position](root)\\n        val vis = mutable.Set[Position](root)\\n\\n        val uninfectedCells = mutable.Set[Position]()\\n\\n        while (q.nonEmpty) {\\n            val currPosition = q.dequeue()\\n\\n            val (virusNeighbors, uninfectedNeighbors) = \\n                getReachableNeighbors(currPosition)\\n                    .filterNot(vis.contains)\\n                    .partition(_.isInfected)\\n\\n            q ++= virusNeighbors\\n            vis ++= virusNeighbors\\n\\n            uninfectedCells ++= uninfectedNeighbors\\n        }\\n\\n        ThreatenedCells(infectedPosition, uninfectedCells.toSeq)\\n    }\\n\\n    private def border(threatenedCells: ThreatenedCells): Int =\\n        threatenedCells.uninfectedCells.map { uninfectedCell =>\\n            getReachableNeighbors(uninfectedCell).collect { \\n                case neigh if find(neigh) == find(threatenedCells.virusCellThreat) => addBorder(neigh, uninfectedCell)\\n            }.size\\n        }.sum\\n\\n    private def getReachableNeighbors(p: Position): Seq[Position] = \\n        Directions\\n            .map(_ + p)\\n            .filter(_.isWithinBounds)\\n            .filterNot(isBorderPresent(p))\\n\\n    private val borders = mutable.Set[(Position, Position)]()\\n    \\n    def addBorder(a: Position, b: Position): Unit = borders ++= Set((a, b), (b, a))\\n\\n    def isBorderPresent(a: Position)(b: Position): Boolean = borders.contains((a, b))\\n}\\n\\n\\nclass UnionFind[T](collection: Iterable[T]) {\\n\\n    private val parent: mutable.Map[T, T] = collection.map(item => item -> item).to(mutable.Map)\\n\\n    def roots(): Set[T] = parent.keys.map(find).toSet\\n\\n    def union(a: T)(b: T): T = {\\n        val aAncestor = find(a)\\n        val bAncestor = find(b)\\n        if (aAncestor != bAncestor) {\\n            parent(aAncestor) = bAncestor\\n        }\\n        bAncestor\\n    }\\n\\n    def find(a: T): T = {\\n        val aParent = parent(a)\\n        if (parent(a) != a) {\\n            parent(a) = find(parent(a))\\n        }\\n        parent(a)\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "Scala",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```\\nimport scala.collection._\\nimport VirusQuarantine._\\n\\nobject Solution {\\n    def containVirus(isInfected: Array[Array[Int]]): Int = {\\n        val positions = (for {\\n            r <- isInfected.indices\\n            c <- isInfected(r).indices\\n        } yield {\\n            Position(r, c)\\n        })\\n        new VirusQuarantine(isInfected, positions).quarantine()\\n    }\\n}\\n\\nobject VirusQuarantine {\\n    case class Position(r: Int, c: Int)\\n\\n    case class ThreatenedCells(virusCellThreat: Position, uninfectedCells: Seq[Position])\\n\\n    implicit class PositionOps(p: Position) {\\n        def +(q: Position): Position = Position(p.r + q.r, p.c + q.c)\\n    }\\n\\n    val Directions = Seq(Position(1, 0), Position(-1, 0), Position(0, 1), Position(0, -1))\\n}\\n\\nclass VirusQuarantine(grid: Array[Array[Int]], positions: Seq[Position]) extends UnionFind[Position](positions) {\\n    private val rows = grid.size\\n    private val cols = grid(0).size\\n\\n    // init the union-find forest.\\n    for {\\n        r <- 0 until rows\\n        c <- 0 until cols\\n        p = Position(r, c)\\n        if p.isInfected()\\n    } {\\n        if (c < cols - 1 && grid(r)(c + 1) == 1)\\n            union(p)(Position(r, c + 1))\\n        if (r < rows - 1 && grid(r + 1)(c) == 1)\\n            union(p)(Position(r + 1, c))\\n    }\\n\\n    def quarantine(): Int = {\\n        var wallsCount = 0\\n\\n        val containedRegionsRoots = mutable.Set[Position]()\\n\\n        while (true) {\\n            val uncontainedRegionsRoots = roots().filter(_.isInfected).toSet.diff(containedRegionsRoots)\\n            \\n            if (uncontainedRegionsRoots.isEmpty) return wallsCount\\n\\n            val threatenedCellsByRegion = uncontainedRegionsRoots.map(findThreatenedCells)\\n            val maxCellCountThreatenedByOneRegion = threatenedCellsByRegion.map(_.uninfectedCells.size).max\\n\\n            val threatenedCellsToBorder = threatenedCellsByRegion.find(_.uninfectedCells.size == maxCellCountThreatenedByOneRegion).get\\n            \\n            val remainingUncontainedRegions = threatenedCellsByRegion - threatenedCellsToBorder\\n            \\n            wallsCount += border(threatenedCellsToBorder)\\n            containedRegionsRoots += find(threatenedCellsToBorder.virusCellThreat)\\n            \\n            remainingUncontainedRegions.map(_.uninfectedCells.map(_.infect))\\n        }\\n\\n        throw new IllegalStateException(\"unreachable statement\")\\n    }\\n\\n    private implicit class GridPositionOps(p: Position) {\\n        def isWithinBounds(): Boolean = \\n            0 <= p.r && p.r < rows && 0 <= p.c && p.c < cols\\n\\n        def isInfected(): Boolean = grid(p.r)(p.c) == 1\\n\\n        def infect(): Unit = {\\n            grid(p.r)(p.c) = 1\\n            getReachableNeighbors(p)\\n                .filter(_.isInfected)\\n                .foreach(union(p))\\n        }\\n    }\\n\\n    private def findThreatenedCells(infectedPosition: Position): ThreatenedCells = {\\n        val root = find(infectedPosition)\\n        val q = mutable.Queue[Position](root)\\n        val vis = mutable.Set[Position](root)\\n\\n        val uninfectedCells = mutable.Set[Position]()\\n\\n        while (q.nonEmpty) {\\n            val currPosition = q.dequeue()\\n\\n            val (virusNeighbors, uninfectedNeighbors) = \\n                getReachableNeighbors(currPosition)\\n                    .filterNot(vis.contains)\\n                    .partition(_.isInfected)\\n\\n            q ++= virusNeighbors\\n            vis ++= virusNeighbors\\n\\n            uninfectedCells ++= uninfectedNeighbors\\n        }\\n\\n        ThreatenedCells(infectedPosition, uninfectedCells.toSeq)\\n    }\\n\\n    private def border(threatenedCells: ThreatenedCells): Int =\\n        threatenedCells.uninfectedCells.map { uninfectedCell =>\\n            getReachableNeighbors(uninfectedCell).collect { \\n                case neigh if find(neigh) == find(threatenedCells.virusCellThreat) => addBorder(neigh, uninfectedCell)\\n            }.size\\n        }.sum\\n\\n    private def getReachableNeighbors(p: Position): Seq[Position] = \\n        Directions\\n            .map(_ + p)\\n            .filter(_.isWithinBounds)\\n            .filterNot(isBorderPresent(p))\\n\\n    private val borders = mutable.Set[(Position, Position)]()\\n    \\n    def addBorder(a: Position, b: Position): Unit = borders ++= Set((a, b), (b, a))\\n\\n    def isBorderPresent(a: Position)(b: Position): Boolean = borders.contains((a, b))\\n}\\n\\n\\nclass UnionFind[T](collection: Iterable[T]) {\\n\\n    private val parent: mutable.Map[T, T] = collection.map(item => item -> item).to(mutable.Map)\\n\\n    def roots(): Set[T] = parent.keys.map(find).toSet\\n\\n    def union(a: T)(b: T): T = {\\n        val aAncestor = find(a)\\n        val bAncestor = find(b)\\n        if (aAncestor != bAncestor) {\\n            parent(aAncestor) = bAncestor\\n        }\\n        bAncestor\\n    }\\n\\n    def find(a: T): T = {\\n        val aParent = parent(a)\\n        if (parent(a) != a) {\\n            parent(a) = find(parent(a))\\n        }\\n        parent(a)\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828611,
                "title": "contain-virus-o-n-m-max-n-m-dfs-leetcode-hard",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically I am trying to traverse First ifected cell then dfs after that spreading the infected case by adjacent untill I get the optimal answer,So that\\'s why while(true) every time I chck that infected cell then dfs and it will repaeting\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBasically using through DFS when the infected cell is found then it will return wall number it will comparison through the set. after that when one traversal iscompleted and it addded 1 as adjacent after checking that will not violate the rules of matrix overflow\\n\\n# Complexity\\n- Time complexity: O(n*m*max(m,n))\\nn =isinfectedd.size()\\nm = isinfectedd[0].size()\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(n*m)\\nwhere \\nn =isinfectedd.size()\\nm = isinfectedd[0].size()\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n,m,r,mx;\\n    int col;\\n    int ans;\\n    unordered_set<int> st;\\n    int wall;\\n    vector<vector<int>> isInfected;\\n\\n    int dfs(int i,int j)\\n    {\\n        if(i<0 || j<0 || i>=n || j>=m || isInfected[i][j]!=1)\\n        {\\n            return 0;\\n        }\\n\\n        int ans  = 0;\\n\\n        if(i-1>=0 && isInfected[i-1][j] == 0)\\n        {\\n            st.insert((i-1)*m + j);\\n            ans++;\\n        }\\n        if(i+1<n && isInfected[i+1][j] == 0)\\n        {\\n            st.insert((i+1)*m + j);\\n            ans++;\\n        }\\n\\n        if(j-1>=0 && isInfected[i][j-1] == 0)\\n        {\\n            st.insert(i*m + (j-1));\\n            ans++;\\n        }\\n\\n        if(j+1<m && isInfected[i][j+1] == 0)\\n        {\\n            st.insert(i*m + (j+1));\\n            ans++;\\n        }\\n\\n\\n        isInfected[i][j] = col;\\n\\n        ans+=dfs(i+1,j);\\n        ans+=dfs(i-1,j);\\n        ans+=dfs(i,j-1);\\n        ans+=dfs(i,j+1);\\n\\n\\n        return ans;\\n\\n\\n    }\\n    int containVirus(vector<vector<int>>& isInfectedd) {\\n\\n\\n        n = isInfectedd.size();\\n        m = isInfectedd[0].size();\\n\\n        isInfected = isInfectedd;\\n        ans = 0;\\n\\n       \\n        while(true)\\n        {\\n             mx = 0;\\n             col = 2;\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=0;j<m;j++)\\n                {\\n                    if(isInfected[i][j] == 1)\\n                    {\\n                        st.clear();\\n                        int w = dfs(i,j);\\n                        if(mx<st.size())\\n                        {\\n                            mx = st.size();\\n                            wall = w;\\n                            r = col;\\n                        }\\n                        col++;\\n                    }\\n        \\n                }\\n            }\\n\\n            if(mx == 0)\\n            {\\n                break;\\n            }\\n            ans+=wall;\\n\\n\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=0;j<m;j++)\\n                {\\n                    if(isInfected[i][j] == r)\\n                    {\\n                        isInfected[i][j] = 1e9;\\n                    }\\n                    else if(isInfected[i][j] > 1 and isInfected[i][j] != 1e9)\\n                    {\\n                        isInfected[i][j] = 1;\\n                        if(i-1>=0 and !isInfected[i-1][j])\\n                        {\\n                            isInfected[i-1][j] = 1;\\n                        }\\n                         if(i+1<n and !isInfected[i+1][j])\\n                        {\\n                            isInfected[i+1][j] = 1;\\n                        }\\n                         if(j-1>=0 and !isInfected[i][j-1])\\n                        {\\n                            isInfected[i][j-1] = 1;\\n                        }\\n                         if(j+1<m and !isInfected[i][j+1])\\n                        {\\n                            isInfected[i][j+1] = 1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m,r,mx;\\n    int col;\\n    int ans;\\n    unordered_set<int> st;\\n    int wall;\\n    vector<vector<int>> isInfected;\\n\\n    int dfs(int i,int j)\\n    {\\n        if(i<0 || j<0 || i>=n || j>=m || isInfected[i][j]!=1)\\n        {\\n            return 0;\\n        }\\n\\n        int ans  = 0;\\n\\n        if(i-1>=0 && isInfected[i-1][j] == 0)\\n        {\\n            st.insert((i-1)*m + j);\\n            ans++;\\n        }\\n        if(i+1<n && isInfected[i+1][j] == 0)\\n        {\\n            st.insert((i+1)*m + j);\\n            ans++;\\n        }\\n\\n        if(j-1>=0 && isInfected[i][j-1] == 0)\\n        {\\n            st.insert(i*m + (j-1));\\n            ans++;\\n        }\\n\\n        if(j+1<m && isInfected[i][j+1] == 0)\\n        {\\n            st.insert(i*m + (j+1));\\n            ans++;\\n        }\\n\\n\\n        isInfected[i][j] = col;\\n\\n        ans+=dfs(i+1,j);\\n        ans+=dfs(i-1,j);\\n        ans+=dfs(i,j-1);\\n        ans+=dfs(i,j+1);\\n\\n\\n        return ans;\\n\\n\\n    }\\n    int containVirus(vector<vector<int>>& isInfectedd) {\\n\\n\\n        n = isInfectedd.size();\\n        m = isInfectedd[0].size();\\n\\n        isInfected = isInfectedd;\\n        ans = 0;\\n\\n       \\n        while(true)\\n        {\\n             mx = 0;\\n             col = 2;\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=0;j<m;j++)\\n                {\\n                    if(isInfected[i][j] == 1)\\n                    {\\n                        st.clear();\\n                        int w = dfs(i,j);\\n                        if(mx<st.size())\\n                        {\\n                            mx = st.size();\\n                            wall = w;\\n                            r = col;\\n                        }\\n                        col++;\\n                    }\\n        \\n                }\\n            }\\n\\n            if(mx == 0)\\n            {\\n                break;\\n            }\\n            ans+=wall;\\n\\n\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=0;j<m;j++)\\n                {\\n                    if(isInfected[i][j] == r)\\n                    {\\n                        isInfected[i][j] = 1e9;\\n                    }\\n                    else if(isInfected[i][j] > 1 and isInfected[i][j] != 1e9)\\n                    {\\n                        isInfected[i][j] = 1;\\n                        if(i-1>=0 and !isInfected[i-1][j])\\n                        {\\n                            isInfected[i-1][j] = 1;\\n                        }\\n                         if(i+1<n and !isInfected[i+1][j])\\n                        {\\n                            isInfected[i+1][j] = 1;\\n                        }\\n                         if(j-1>=0 and !isInfected[i][j-1])\\n                        {\\n                            isInfected[i][j-1] = 1;\\n                        }\\n                         if(j+1<m and !isInfected[i][j+1])\\n                        {\\n                            isInfected[i][j+1] = 1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828375,
                "title": "c-dfs",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int> > g;\\n    int n, m, c, mx, w, r, ans, itr;\\n    unordered_set<int> s;\\n    \\n    int dfs(int i, int j){\\n        if(i<0 || i>=n || j<0 || j>=m || g[i][j]!=1)\\n            return 0;\\n        int ans=0;\\n        if(i+1<n && g[i+1][j]==0){\\n            s.insert((i+1)*m+j);\\n            ans++;\\n        }\\n        if(i-1>=0 && g[i-1][j]==0){\\n            s.insert((i-1)*m+j);\\n            ans++;\\n        }\\n        if(j+1<m && g[i][j+1]==0){\\n            s.insert(i*m+(j+1));\\n            ans++;\\n        }\\n        if(j-1>=0 && g[i][j-1]==0){\\n            s.insert(i*m+(j-1));\\n            ans++;\\n        }\\n        g[i][j]=c;\\n        ans+=dfs(i+1, j);\\n        ans+=dfs(i-1, j);\\n        ans+=dfs(i, j+1);\\n        ans+=dfs(i, j-1);\\n        return ans; // total number of walls needed to block this connected component\\n    }\\n    \\n    int containVirus(vector<vector<int>>& grid) {\\n        g=grid, n=g.size(), m=g[0].size(), ans=0;\\n        while(true){\\n            c=2, mx=0;\\n            for(int i=0; i<n; i++){\\n                for(int j=0; j<m; j++){\\n                    if(g[i][j]==1){\\n                        s.clear();\\n                        int walls=dfs(i, j);\\n                        if(mx<s.size()){\\n                            mx=s.size();\\n                            w=walls;\\n                            r=c;\\n                        }\\n                        c++;\\n                    }\\n                }\\n            }\\n            if(mx==0)\\n                break;\\n            ans+=w;\\n            for(int i=0; i<n; i++){\\n                for(int j=0; j<m; j++){\\n                    if(g[i][j]==r)\\n                        g[i][j]=1e9;\\n                    else if(g[i][j]>1 && g[i][j]!=1e9){\\n                        g[i][j]=1;\\n                        if(i+1<n && !g[i+1][j]) g[i+1][j]=1;\\n                        if(i-1>=0 && !g[i-1][j]) g[i-1][j]=1;\\n                        if(j+1<m && !g[i][j+1]) g[i][j+1]=1;\\n                        if(j-1>=0 && !g[i][j-1]) g[i][j-1]=1;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph",
                    "Matrix"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int> > g;\\n    int n, m, c, mx, w, r, ans, itr;\\n    unordered_set<int> s;\\n    \\n    int dfs(int i, int j){\\n        if(i<0 || i>=n || j<0 || j>=m || g[i][j]!=1)\\n            return 0;\\n        int ans=0;\\n        if(i+1<n && g[i+1][j]==0){\\n            s.insert((i+1)*m+j);\\n            ans++;\\n        }\\n        if(i-1>=0 && g[i-1][j]==0){\\n            s.insert((i-1)*m+j);\\n            ans++;\\n        }\\n        if(j+1<m && g[i][j+1]==0){\\n            s.insert(i*m+(j+1));\\n            ans++;\\n        }\\n        if(j-1>=0 && g[i][j-1]==0){\\n            s.insert(i*m+(j-1));\\n            ans++;\\n        }\\n        g[i][j]=c;\\n        ans+=dfs(i+1, j);\\n        ans+=dfs(i-1, j);\\n        ans+=dfs(i, j+1);\\n        ans+=dfs(i, j-1);\\n        return ans; // total number of walls needed to block this connected component\\n    }\\n    \\n    int containVirus(vector<vector<int>>& grid) {\\n        g=grid, n=g.size(), m=g[0].size(), ans=0;\\n        while(true){\\n            c=2, mx=0;\\n            for(int i=0; i<n; i++){\\n                for(int j=0; j<m; j++){\\n                    if(g[i][j]==1){\\n                        s.clear();\\n                        int walls=dfs(i, j);\\n                        if(mx<s.size()){\\n                            mx=s.size();\\n                            w=walls;\\n                            r=c;\\n                        }\\n                        c++;\\n                    }\\n                }\\n            }\\n            if(mx==0)\\n                break;\\n            ans+=w;\\n            for(int i=0; i<n; i++){\\n                for(int j=0; j<m; j++){\\n                    if(g[i][j]==r)\\n                        g[i][j]=1e9;\\n                    else if(g[i][j]>1 && g[i][j]!=1e9){\\n                        g[i][j]=1;\\n                        if(i+1<n && !g[i+1][j]) g[i+1][j]=1;\\n                        if(i-1>=0 && !g[i-1][j]) g[i-1][j]=1;\\n                        if(j+1<m && !g[i][j+1]) g[i][j+1]=1;\\n                        if(j-1>=0 && !g[i][j-1]) g[i][j-1]=1;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766271,
                "title": "simulation",
                "content": "```\\n   #define ii pair<int,int>\\n#define F first\\n#define S second\\n\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<vector<int>> grid;\\n    vector<pair<int,pair<int,vector<ii>>>> comp;\\n    vector<ii> com;\\n    vector<vector<int>> vis;\\n    set<ii> newhouses;\\n    int curper =0;\\n    int sol =0;\\n    \\n    int dx[4] = {1,0,-1,0};\\n    int dy[4] = {0,-1,0,1};\\n   \\n    bool check(int x,int y){\\n        if(x<0 || x>= n || y<0 || y>= m)return false;\\n        return true;\\n    }\\n    \\n    void dfs(ii node){\\n        vis[node.F][node.S] = 1;\\n        com.push_back(node);\\n        \\n        for(int i=0;i<4;i++){\\n            ii  nei = {node.F + dx[i] , node.S + dy[i]};\\n            \\n            if(check(nei.F,nei.S) && !vis[nei.F][nei.S] && grid[nei.F][nei.S] == 1){\\n                dfs(nei);\\n            }\\n            else if(check(nei.F,nei.S) && grid[nei.F][nei.S] == 0){\\n               newhouses.insert(nei);\\n                curper++;\\n            }\\n        }\\n    }\\n\\n    void spreadVirus(){\\n        \\n        for(int i=1;i<comp.size();i++){\\n            for(int j=0;j<comp[i].S.S.size();j++){\\n                for(int k=0;k<4;k++){\\n                    ii nei = {comp[i].S.S[j].F + dx[k], comp[i].S.S[j].S + dy[k]};\\n                    \\n                    if(check(nei.F,nei.S) && grid[nei.F][nei.S] == 0){\\n                        grid[nei.F][nei.S] = 1;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool checkVirus(){\\n        \\n        for(int i =0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 1){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    void process(){\\n        \\n        vis.assign(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 1 && !vis[i][j]){\\n                    dfs({i,j});\\n                    comp.push_back({newhouses.size(),{curper,com}});\\n                    com.clear();\\n                    newhouses.clear();\\n                    curper= 0;\\n                }\\n                    \\n            }\\n        }\\n        \\n        sort(comp.rbegin(),comp.rend());\\n        \\n        for(int i=0;i<comp[0].S.S.size();i++){\\n             grid[comp[0].S.S[i].F][comp[0].S.S[i].S] = 3;\\n        }\\n        \\n        sol += comp[0].S.F;\\n    \\n        spreadVirus();\\n        comp.clear();\\n    }\\n    \\n    \\n    int containVirus(vector<vector<int>>& isInfected) {\\n        \\n        grid = isInfected;\\n       \\n        n = grid.size();\\n        m = grid[0].size();\\n     \\n        while(checkVirus()){\\n            process();\\n        }\\n        \\n        return sol;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n   #define ii pair<int,int>\\n#define F first\\n#define S second\\n\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<vector<int>> grid;\\n    vector<pair<int,pair<int,vector<ii>>>> comp;\\n    vector<ii> com;\\n    vector<vector<int>> vis;\\n    set<ii> newhouses;\\n    int curper =0;\\n    int sol =0;\\n    \\n    int dx[4] = {1,0,-1,0};\\n    int dy[4] = {0,-1,0,1};\\n   \\n    bool check(int x,int y){\\n        if(x<0 || x>= n || y<0 || y>= m)return false;\\n        return true;\\n    }\\n    \\n    void dfs(ii node){\\n        vis[node.F][node.S] = 1;\\n        com.push_back(node);\\n        \\n        for(int i=0;i<4;i++){\\n            ii  nei = {node.F + dx[i] , node.S + dy[i]};\\n            \\n            if(check(nei.F,nei.S) && !vis[nei.F][nei.S] && grid[nei.F][nei.S] == 1){\\n                dfs(nei);\\n            }\\n            else if(check(nei.F,nei.S) && grid[nei.F][nei.S] == 0){\\n               newhouses.insert(nei);\\n                curper++;\\n            }\\n        }\\n    }\\n\\n    void spreadVirus(){\\n        \\n        for(int i=1;i<comp.size();i++){\\n            for(int j=0;j<comp[i].S.S.size();j++){\\n                for(int k=0;k<4;k++){\\n                    ii nei = {comp[i].S.S[j].F + dx[k], comp[i].S.S[j].S + dy[k]};\\n                    \\n                    if(check(nei.F,nei.S) && grid[nei.F][nei.S] == 0){\\n                        grid[nei.F][nei.S] = 1;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool checkVirus(){\\n        \\n        for(int i =0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 1){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    void process(){\\n        \\n        vis.assign(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 1 && !vis[i][j]){\\n                    dfs({i,j});\\n                    comp.push_back({newhouses.size(),{curper,com}});\\n                    com.clear();\\n                    newhouses.clear();\\n                    curper= 0;\\n                }\\n                    \\n            }\\n        }\\n        \\n        sort(comp.rbegin(),comp.rend());\\n        \\n        for(int i=0;i<comp[0].S.S.size();i++){\\n             grid[comp[0].S.S[i].F][comp[0].S.S[i].S] = 3;\\n        }\\n        \\n        sol += comp[0].S.F;\\n    \\n        spreadVirus();\\n        comp.clear();\\n    }\\n    \\n    \\n    int containVirus(vector<vector<int>>& isInfected) {\\n        \\n        grid = isInfected;\\n       \\n        n = grid.size();\\n        m = grid[0].size();\\n     \\n        while(checkVirus()){\\n            process();\\n        }\\n        \\n        return sol;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730469,
                "title": "javascript-simulate-it-easier-said-than-done",
                "content": "```\\nvar containVirus = function(grid) {\\n    const R = grid.length\\n    const C = grid[0].length\\n    const DIRS = [[1,0],[0,1],[-1,0],[0,-1]]\\n    let res = 0\\n    \\n while(true) {\\n    const visited = new Set() \\n    const pq = new Heap((a,b) => b.futureInfected.size - a.futureInfected.size)\\n    \\n    for(let i = 0; i < R; i++) {\\n        for(let j = 0; j < C; j++) {\\n            if(!visited.has([i,j].join(\\',\\')) && grid[i][j]===1) {\\n                const cluster = new Cluster()\\n                dfs(i,j, cluster)\\n                \\n                pq.add(cluster)\\n            }\\n        }\\n    }\\n     \\n    if(pq.size===0) return res \\n     const top = pq.pop()[0] // {currInfected}\\n     res += top.walls\\n     \\n     for(const cell of top.currentInfected) {\\n         const [row,col] = cell.split(\\',\\')\\n         \\n         grid[row][col] = -1\\n     }\\n     \\n     while(pq.size) {\\n         const top = pq.pop()[0] // {currInfected}\\n\\n         for(const cell of top.futureInfected) {\\n             const [row,col] = cell.split(\\',\\')\\n\\n             grid[row][col] = 1\\n         }\\n     }\\n     \\n     function dfs(r,c,cluster) {\\n         if(r < 0 || c < 0 || r > R - 1 || c > C - 1) return \\n         if(grid[r][c] ===-1) return\\n         if(grid[r][c] === 0) {\\n             cluster.walls++\\n             cluster.futureInfected.add([r,c].join(\\',\\'))\\n             return \\n         } \\n         \\n         if(visited.has([r,c].join(\\',\\'))) return\\n         visited.add([r,c].join(\\',\\'))\\n         \\n         cluster.currentInfected.add([r,c].join(\\',\\'))\\n         \\n         for(const [rowDir, colDir] of DIRS) {\\n             const nextRow = rowDir + r\\n             const nextCol = colDir + c\\n             \\n             dfs(nextRow, nextCol, cluster)\\n         }\\n     }\\n }   \\n};\\n\\nclass Cluster {\\n    constructor() {\\n        this.walls = 0\\n        this.futureInfected = new Set()\\n        this.currentInfected = new Set()\\n    }\\n}\\n\\nclass Heap {\\n  constructor(cmpFn, array = []) {\\n    this.name = cmpFn == undefined? \\'min\\': \\'custom\\';\\n    this.cmpFn = cmpFn || this.internalCmpFn;\\n    this.tree = [];\\n    this.size = 0;\\n    this.count = 0;\\n    this.idxMap = new Map();\\n    this.idxRevMap = new Map();\\n    for(let value of array) {\\n      this.add(value);\\n    }\\n  }\\n  _left(idx) {\\n    return 2 * idx + 1;\\n  }\\n  _right(idx) {\\n    return 2 * idx + 2;\\n  }\\n  _parent(idx) {\\n    return (idx - 1) / 2 >> 0;\\n  }\\n  _swap(i, j) {\\n    let countI = this.idxMap.get(i);\\n    let countJ = this.idxMap.get(j);\\n    let idxI = this.idxRevMap.get(countI);\\n    let idxJ = this.idxRevMap.get(countJ);\\n    this.idxMap.set(i, countJ);\\n    this.idxMap.set(j, countI);\\n    this.idxRevMap.set(countI, j);\\n    this.idxRevMap.set(countJ, i);\\n    [this.tree[i], this.tree[j]] = [this.tree[j], this.tree[i]];\\n  }\\n  \\n  internalCmpFn(value1, value2) {\\n    return value1 - value2;\\n  }\\n  _heapifyUp(idx) {\\n    let parent = this._parent(idx);\\n     while(parent != idx && this.cmpFn(this.tree[idx], this.tree[parent]) < 0) {\\n      this._swap(idx, parent);\\n      idx = parent;\\n      parent = this._parent(idx);\\n    }\\n  }\\n  \\n  add(value, count) {\\n    count = count == undefined? this.count: count;\\n    this.tree[this.size] = value;\\n    this.idxMap.set(this.size, count);\\n    this.idxRevMap.set(count, this.size);\\n    let idx = this.size;\\n    this._heapifyUp(idx);\\n    this.size++;\\n    this.count++;\\n  }\\n  \\n  heapify(idx) {\\n    let left = this._left(idx);\\n    let right = this._right(idx);\\n    let current = idx;\\n    if(left < this.size && this.cmpFn(this.tree[left], this.tree[idx]) < 0) {\\n      current = left;\\n    }\\n    if(right < this.size && this.cmpFn(this.tree[right], this.tree[current]) < 0) {\\n      current = right;\\n    }\\n    if(current != idx) {\\n      this._swap(idx, current);\\n      this.heapify(current);\\n    }\\n  }\\n  \\n  pop() {\\n    if(this.size == 0) {\\n      return null;\\n    }\\n    let value = this.tree[0];\\n    let count = this.idxMap.get(0);\\n    this._swap(0, this.size - 1);\\n    this.size--;\\n    this.tree.length = this.size;\\n    this.heapify(0);\\n    this.idxRevMap.delete(count);\\n    this.idxMap.delete(this.size);\\n    return [value, count];\\n  }\\n  \\n  popAt(count) {\\n    if(!this.idxRevMap.has(count) || this.size == 0) {\\n      return null;\\n    }\\n    let idx = this.idxRevMap.get(count);\\n    let value = this.tree[idx];\\n    this._swap(idx, this.size - 1);\\n    this.size--;\\n    this.tree.length = this.size;\\n    this.heapify(idx);\\n    this._heapifyUp(idx);\\n    this.idxRevMap.delete(count);\\n    this.idxMap.delete(this.size);\\n    return [value, count];\\n  }\\n  \\n  peek() {\\n    return this.tree[0];\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar containVirus = function(grid) {\\n    const R = grid.length\\n    const C = grid[0].length\\n    const DIRS = [[1,0],[0,1],[-1,0],[0,-1]]\\n    let res = 0\\n    \\n while(true) {\\n    const visited = new Set() \\n    const pq = new Heap((a,b) => b.futureInfected.size - a.futureInfected.size)\\n    \\n    for(let i = 0; i < R; i++) {\\n        for(let j = 0; j < C; j++) {\\n            if(!visited.has([i,j].join(\\',\\')) && grid[i][j]===1) {\\n                const cluster = new Cluster()\\n                dfs(i,j, cluster)\\n                \\n                pq.add(cluster)\\n            }\\n        }\\n    }\\n     \\n    if(pq.size===0) return res \\n     const top = pq.pop()[0] // {currInfected}\\n     res += top.walls\\n     \\n     for(const cell of top.currentInfected) {\\n         const [row,col] = cell.split(\\',\\')\\n         \\n         grid[row][col] = -1\\n     }\\n     \\n     while(pq.size) {\\n         const top = pq.pop()[0] // {currInfected}\\n\\n         for(const cell of top.futureInfected) {\\n             const [row,col] = cell.split(\\',\\')\\n\\n             grid[row][col] = 1\\n         }\\n     }\\n     \\n     function dfs(r,c,cluster) {\\n         if(r < 0 || c < 0 || r > R - 1 || c > C - 1) return \\n         if(grid[r][c] ===-1) return\\n         if(grid[r][c] === 0) {\\n             cluster.walls++\\n             cluster.futureInfected.add([r,c].join(\\',\\'))\\n             return \\n         } \\n         \\n         if(visited.has([r,c].join(\\',\\'))) return\\n         visited.add([r,c].join(\\',\\'))\\n         \\n         cluster.currentInfected.add([r,c].join(\\',\\'))\\n         \\n         for(const [rowDir, colDir] of DIRS) {\\n             const nextRow = rowDir + r\\n             const nextCol = colDir + c\\n             \\n             dfs(nextRow, nextCol, cluster)\\n         }\\n     }\\n }   \\n};\\n\\nclass Cluster {\\n    constructor() {\\n        this.walls = 0\\n        this.futureInfected = new Set()\\n        this.currentInfected = new Set()\\n    }\\n}\\n\\nclass Heap {\\n  constructor(cmpFn, array = []) {\\n    this.name = cmpFn == undefined? \\'min\\': \\'custom\\';\\n    this.cmpFn = cmpFn || this.internalCmpFn;\\n    this.tree = [];\\n    this.size = 0;\\n    this.count = 0;\\n    this.idxMap = new Map();\\n    this.idxRevMap = new Map();\\n    for(let value of array) {\\n      this.add(value);\\n    }\\n  }\\n  _left(idx) {\\n    return 2 * idx + 1;\\n  }\\n  _right(idx) {\\n    return 2 * idx + 2;\\n  }\\n  _parent(idx) {\\n    return (idx - 1) / 2 >> 0;\\n  }\\n  _swap(i, j) {\\n    let countI = this.idxMap.get(i);\\n    let countJ = this.idxMap.get(j);\\n    let idxI = this.idxRevMap.get(countI);\\n    let idxJ = this.idxRevMap.get(countJ);\\n    this.idxMap.set(i, countJ);\\n    this.idxMap.set(j, countI);\\n    this.idxRevMap.set(countI, j);\\n    this.idxRevMap.set(countJ, i);\\n    [this.tree[i], this.tree[j]] = [this.tree[j], this.tree[i]];\\n  }\\n  \\n  internalCmpFn(value1, value2) {\\n    return value1 - value2;\\n  }\\n  _heapifyUp(idx) {\\n    let parent = this._parent(idx);\\n     while(parent != idx && this.cmpFn(this.tree[idx], this.tree[parent]) < 0) {\\n      this._swap(idx, parent);\\n      idx = parent;\\n      parent = this._parent(idx);\\n    }\\n  }\\n  \\n  add(value, count) {\\n    count = count == undefined? this.count: count;\\n    this.tree[this.size] = value;\\n    this.idxMap.set(this.size, count);\\n    this.idxRevMap.set(count, this.size);\\n    let idx = this.size;\\n    this._heapifyUp(idx);\\n    this.size++;\\n    this.count++;\\n  }\\n  \\n  heapify(idx) {\\n    let left = this._left(idx);\\n    let right = this._right(idx);\\n    let current = idx;\\n    if(left < this.size && this.cmpFn(this.tree[left], this.tree[idx]) < 0) {\\n      current = left;\\n    }\\n    if(right < this.size && this.cmpFn(this.tree[right], this.tree[current]) < 0) {\\n      current = right;\\n    }\\n    if(current != idx) {\\n      this._swap(idx, current);\\n      this.heapify(current);\\n    }\\n  }\\n  \\n  pop() {\\n    if(this.size == 0) {\\n      return null;\\n    }\\n    let value = this.tree[0];\\n    let count = this.idxMap.get(0);\\n    this._swap(0, this.size - 1);\\n    this.size--;\\n    this.tree.length = this.size;\\n    this.heapify(0);\\n    this.idxRevMap.delete(count);\\n    this.idxMap.delete(this.size);\\n    return [value, count];\\n  }\\n  \\n  popAt(count) {\\n    if(!this.idxRevMap.has(count) || this.size == 0) {\\n      return null;\\n    }\\n    let idx = this.idxRevMap.get(count);\\n    let value = this.tree[idx];\\n    this._swap(idx, this.size - 1);\\n    this.size--;\\n    this.tree.length = this.size;\\n    this.heapify(idx);\\n    this._heapifyUp(idx);\\n    this.idxRevMap.delete(count);\\n    this.idxMap.delete(this.size);\\n    return [value, count];\\n  }\\n  \\n  peek() {\\n    return this.tree[0];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2643762,
                "title": "dfs-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n    # isInfected: 0 for uninfected; 1 for infected; -1 for contained;\\n    # use DFS to traverse the whole board to find \\n    # - the infected area (any cell);\\n    # - its risky cells;\\n    # - the number of walls needed to contain it\\n    # make the risky cells array a heap:\\n    # - single out the area with max risky cells\\n    # - mark the rest of the risky cell infected\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def containVirus(self, isInfected: List[List[int]]) -> int:\\n\\n        # return number of walls needed\\n        def dfs(r, c):\\n\\n            # return\\n            if (r, c) in visited or r < 0 or c < 0 or r >= m or c >= n:\\n                return 0\\n\\n            # contained cells\\n            if isInfected[r][c] == -1:\\n                return 0\\n            \\n            # uninfected cells\\n            if isInfected[r][c] == 0:\\n                risky.add((r, c))\\n                return 1\\n            \\n            # infected cells\\n            visited.add((r ,c))\\n            walls = 0\\n            if isInfected[r][c] == 1:\\n                walls += dfs(r+1, c)\\n                walls += dfs(r-1, c)\\n                walls += dfs(r, c+1)\\n                walls += dfs(r, c-1)\\n\\n            return walls\\n        \\n        m, n = len(isInfected), len(isInfected[0])\\n        total_wall = 0\\n\\n        while True:\\n            # store (len(risky), risky, wall, starting points)\\n            gettingInfected = []\\n            visited = set()\\n            for i in range(m):\\n                for j in range(n):\\n                    if isInfected[i][j] == 1 and isInfected[i][j] not in visited:\\n                        risky = set()\\n                        w = dfs(i, j)\\n                        gettingInfected.append((-len(risky), risky, w, i, j))\\n\\n            \\n            # heapy the gettingInfectious array to get the max len of risky\\n            heapq.heapify(gettingInfected)\\n\\n            if not gettingInfected or gettingInfected[0][2] == 0:\\n                return total_wall\\n\\n            # mark the infected cells as contained starting from (i, j)\\n            lr, risky, w, i, j = heapq.heappop(gettingInfected)\\n            # maybe a dfs for marking the cells?\\n            queue = collections.deque([(i, j)])\\n            while queue:\\n                r, c = queue.pop()\\n                if r < 0 or c < 0 or r >= m or c >= n or isInfected[r][c] != 1:\\n                    continue\\n\\n                isInfected[r][c] = -1\\n\\n                queue.append((r+1, c))\\n                queue.append((r-1, c))\\n                queue.append((r, c+1))\\n                queue.append((r, c-1))\\n\\n            # increment the total walls\\n            total_wall += w\\n            for area in gettingInfected:\\n                riskyCells = area[1]\\n                for cell in riskyCells:\\n                    r, c = cell\\n                    isInfected[r][c] = 1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containVirus(self, isInfected: List[List[int]]) -> int:\\n\\n        # return number of walls needed\\n        def dfs(r, c):\\n\\n            # return\\n            if (r, c) in visited or r < 0 or c < 0 or r >= m or c >= n:\\n                return 0\\n\\n            # contained cells\\n            if isInfected[r][c] == -1:\\n                return 0\\n            \\n            # uninfected cells\\n            if isInfected[r][c] == 0:\\n                risky.add((r, c))\\n                return 1\\n            \\n            # infected cells\\n            visited.add((r ,c))\\n            walls = 0\\n            if isInfected[r][c] == 1:\\n                walls += dfs(r+1, c)\\n                walls += dfs(r-1, c)\\n                walls += dfs(r, c+1)\\n                walls += dfs(r, c-1)\\n\\n            return walls\\n        \\n        m, n = len(isInfected), len(isInfected[0])\\n        total_wall = 0\\n\\n        while True:\\n            # store (len(risky), risky, wall, starting points)\\n            gettingInfected = []\\n            visited = set()\\n            for i in range(m):\\n                for j in range(n):\\n                    if isInfected[i][j] == 1 and isInfected[i][j] not in visited:\\n                        risky = set()\\n                        w = dfs(i, j)\\n                        gettingInfected.append((-len(risky), risky, w, i, j))\\n\\n            \\n            # heapy the gettingInfectious array to get the max len of risky\\n            heapq.heapify(gettingInfected)\\n\\n            if not gettingInfected or gettingInfected[0][2] == 0:\\n                return total_wall\\n\\n            # mark the infected cells as contained starting from (i, j)\\n            lr, risky, w, i, j = heapq.heappop(gettingInfected)\\n            # maybe a dfs for marking the cells?\\n            queue = collections.deque([(i, j)])\\n            while queue:\\n                r, c = queue.pop()\\n                if r < 0 or c < 0 or r >= m or c >= n or isInfected[r][c] != 1:\\n                    continue\\n\\n                isInfected[r][c] = -1\\n\\n                queue.append((r+1, c))\\n                queue.append((r-1, c))\\n                queue.append((r, c+1))\\n                queue.append((r, c-1))\\n\\n            # increment the total walls\\n            total_wall += w\\n            for area in gettingInfected:\\n                riskyCells = area[1]\\n                for cell in riskyCells:\\n                    r, c = cell\\n                    isInfected[r][c] = 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2536904,
                "title": "749-contain-virus",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        #dict\\n        #key: infected region id\\n        #val: [[will infect cells], number of walls]\\n        self.curr_infected_region_coord = {}\\n        self.next_infected_region_coord = {}\\n        self.region_walls = {}\\n        self.visited = set()\\n        self.result = 0\\n\\n    def containVirus(self, isInfected):\\n        m = len(isInfected)  #rows\\n        n = len(isInfected[0]) #cols\\n\\n        while True:\\n            # at the beginning, we have to reset our dictionary\\n            self.curr_infected_region_coord = {}\\n            self.next_infected_region_coord = {}\\n            self.region_walls = {}\\n            self.visited = set()\\n            region_id = 0\\n\\n            for row in range(m):\\n                for col in range(n):\\n                    if (row, col) in self.visited:\\n                        continue\\n                    if isInfected[row][col] == 1: #find a start point for the infected region\\n                        self.dfs(isInfected, row, col, region_id)\\n                        region_id += 1\\n\\n            # if no cells can be infected, then we have to stop\\n            if not self.next_infected_region_coord:\\n                break\\n\\n            #now, we need to find the region which will infect most cells\\n            #please pay attention that, we need to sort them by the maximum next affected cells\\n            #NOT BY the NUMBER of Walls!\\n            #temp_sorted = sorted(self.region_walls.items(), key=lambda x: x[1], reverse=True)\\n            walled_region_id = -1*float(\\'inf\\')\\n            max_next_cells = -1*float(\\'inf\\')\\n            for item in self.next_infected_region_coord:\\n                cur_len = len(self.next_infected_region_coord[item])\\n                if cur_len >= max_next_cells:\\n                    max_next_cells = cur_len\\n                    walled_region_id = item\\n\\n            self.result += self.region_walls[walled_region_id]\\n            # we reset the walled region to be 2\\n            for walled_item in self.curr_infected_region_coord[walled_region_id]:\\n                walled_row = walled_item[0]\\n                walled_col = walled_item[1]\\n                isInfected[walled_row][walled_col] = 2\\n\\n            for other_region_id in self.next_infected_region_coord:\\n                if other_region_id == walled_region_id:\\n                    continue\\n                for infected_item in self.next_infected_region_coord[other_region_id]:\\n                    infected_row = infected_item[0]\\n                    infected_col = infected_item[1]\\n                    isInfected[infected_row][infected_col] = 1\\n                    \\n        return self.result\\n\\n\\n\\n    def dfs(self, isInfected, row, col, region_id):\\n\\n        #check whether row and col are valid\\n        m = len(isInfected)  #rows\\n        n = len(isInfected[0]) #cols\\n\\n        if row<0 or row>=m or col<0 or col>=n or isInfected[row][col]!=1 or (row,col) in self.visited:\\n            return\\n\\n        #now, if it is an infected cell, then\\n        #1) we need to record how many cells it may infect\\n        #2) how many walls we need to stop the spread\\n        self.visited.add((row, col))\\n\\n        if region_id not in self.curr_infected_region_coord:\\n            self.curr_infected_region_coord[region_id] = set()\\n            self.curr_infected_region_coord[region_id].add((row, col))\\n        else:\\n            self.curr_infected_region_coord[region_id].add((row, col))\\n\\n        # check up\\n        if row - 1 >= 0 and row - 1 < m and isInfected[row - 1][col] == 0:\\n            if region_id not in self.next_infected_region_coord:\\n                self.next_infected_region_coord[region_id] = set()\\n                self.next_infected_region_coord[region_id].add((row - 1, col))\\n                self.region_walls[region_id] = 1\\n            else:\\n                self.next_infected_region_coord[region_id].add((row - 1, col))\\n                self.region_walls[region_id] += 1\\n\\n        # check down\\n        if row + 1 >= 0 and row + 1 < m and isInfected[row + 1][col] == 0:\\n            if region_id not in self.next_infected_region_coord:\\n                self.next_infected_region_coord[region_id] = set()\\n                self.next_infected_region_coord[region_id].add((row + 1, col))\\n                self.region_walls[region_id] = 1\\n            else:\\n                self.next_infected_region_coord[region_id].add((row + 1, col))\\n                self.region_walls[region_id] += 1\\n\\n        # check left\\n        if col - 1 >= 0 and col - 1 < n and isInfected[row][col - 1] == 0:\\n            if region_id not in self.next_infected_region_coord:\\n                self.next_infected_region_coord[region_id] = set()\\n                self.next_infected_region_coord[region_id].add((row, col - 1))\\n                self.region_walls[region_id] = 1\\n            else:\\n                self.next_infected_region_coord[region_id].add((row, col - 1))\\n                self.region_walls[region_id] += 1\\n\\n        # check right\\n        if col + 1 >= 0 and col + 1 < n and isInfected[row][col + 1] == 0:\\n            if region_id not in self.next_infected_region_coord:\\n                self.next_infected_region_coord[region_id] = set()\\n                self.next_infected_region_coord[region_id].add((row, col + 1))\\n                self.region_walls[region_id] = 1\\n            else:\\n                self.next_infected_region_coord[region_id].add((row, col + 1))\\n                self.region_walls[region_id] += 1\\n\\n        # we continue to check its neighbors to see whehter they are infected cells\\n        self.dfs(isInfected, row-1, col, region_id) #up\\n        self.dfs(isInfected, row+1, col, region_id) #down\\n        self.dfs(isInfected, row, col-1, region_id) #left\\n        self.dfs(isInfected, row, col+1, region_id) #right\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        #dict\\n        #key: infected region id\\n        #val: [[will infect cells], number of walls]\\n        self.curr_infected_region_coord = {}\\n        self.next_infected_region_coord = {}\\n        self.region_walls = {}\\n        self.visited = set()\\n        self.result = 0\\n\\n    def containVirus(self, isInfected):\\n        m = len(isInfected)  #rows\\n        n = len(isInfected[0]) #cols\\n\\n        while True:\\n            # at the beginning, we have to reset our dictionary\\n            self.curr_infected_region_coord = {}\\n            self.next_infected_region_coord = {}\\n            self.region_walls = {}\\n            self.visited = set()\\n            region_id = 0\\n\\n            for row in range(m):\\n                for col in range(n):\\n                    if (row, col) in self.visited:\\n                        continue\\n                    if isInfected[row][col] == 1: #find a start point for the infected region\\n                        self.dfs(isInfected, row, col, region_id)\\n                        region_id += 1\\n\\n            # if no cells can be infected, then we have to stop\\n            if not self.next_infected_region_coord:\\n                break\\n\\n            #now, we need to find the region which will infect most cells\\n            #please pay attention that, we need to sort them by the maximum next affected cells\\n            #NOT BY the NUMBER of Walls!\\n            #temp_sorted = sorted(self.region_walls.items(), key=lambda x: x[1], reverse=True)\\n            walled_region_id = -1*float(\\'inf\\')\\n            max_next_cells = -1*float(\\'inf\\')\\n            for item in self.next_infected_region_coord:\\n                cur_len = len(self.next_infected_region_coord[item])\\n                if cur_len >= max_next_cells:\\n                    max_next_cells = cur_len\\n                    walled_region_id = item\\n\\n            self.result += self.region_walls[walled_region_id]\\n            # we reset the walled region to be 2\\n            for walled_item in self.curr_infected_region_coord[walled_region_id]:\\n                walled_row = walled_item[0]\\n                walled_col = walled_item[1]\\n                isInfected[walled_row][walled_col] = 2\\n\\n            for other_region_id in self.next_infected_region_coord:\\n                if other_region_id == walled_region_id:\\n                    continue\\n                for infected_item in self.next_infected_region_coord[other_region_id]:\\n                    infected_row = infected_item[0]\\n                    infected_col = infected_item[1]\\n                    isInfected[infected_row][infected_col] = 1\\n                    \\n        return self.result\\n\\n\\n\\n    def dfs(self, isInfected, row, col, region_id):\\n\\n        #check whether row and col are valid\\n        m = len(isInfected)  #rows\\n        n = len(isInfected[0]) #cols\\n\\n        if row<0 or row>=m or col<0 or col>=n or isInfected[row][col]!=1 or (row,col) in self.visited:\\n            return\\n\\n        #now, if it is an infected cell, then\\n        #1) we need to record how many cells it may infect\\n        #2) how many walls we need to stop the spread\\n        self.visited.add((row, col))\\n\\n        if region_id not in self.curr_infected_region_coord:\\n            self.curr_infected_region_coord[region_id] = set()\\n            self.curr_infected_region_coord[region_id].add((row, col))\\n        else:\\n            self.curr_infected_region_coord[region_id].add((row, col))\\n\\n        # check up\\n        if row - 1 >= 0 and row - 1 < m and isInfected[row - 1][col] == 0:\\n            if region_id not in self.next_infected_region_coord:\\n                self.next_infected_region_coord[region_id] = set()\\n                self.next_infected_region_coord[region_id].add((row - 1, col))\\n                self.region_walls[region_id] = 1\\n            else:\\n                self.next_infected_region_coord[region_id].add((row - 1, col))\\n                self.region_walls[region_id] += 1\\n\\n        # check down\\n        if row + 1 >= 0 and row + 1 < m and isInfected[row + 1][col] == 0:\\n            if region_id not in self.next_infected_region_coord:\\n                self.next_infected_region_coord[region_id] = set()\\n                self.next_infected_region_coord[region_id].add((row + 1, col))\\n                self.region_walls[region_id] = 1\\n            else:\\n                self.next_infected_region_coord[region_id].add((row + 1, col))\\n                self.region_walls[region_id] += 1\\n\\n        # check left\\n        if col - 1 >= 0 and col - 1 < n and isInfected[row][col - 1] == 0:\\n            if region_id not in self.next_infected_region_coord:\\n                self.next_infected_region_coord[region_id] = set()\\n                self.next_infected_region_coord[region_id].add((row, col - 1))\\n                self.region_walls[region_id] = 1\\n            else:\\n                self.next_infected_region_coord[region_id].add((row, col - 1))\\n                self.region_walls[region_id] += 1\\n\\n        # check right\\n        if col + 1 >= 0 and col + 1 < n and isInfected[row][col + 1] == 0:\\n            if region_id not in self.next_infected_region_coord:\\n                self.next_infected_region_coord[region_id] = set()\\n                self.next_infected_region_coord[region_id].add((row, col + 1))\\n                self.region_walls[region_id] = 1\\n            else:\\n                self.next_infected_region_coord[region_id].add((row, col + 1))\\n                self.region_walls[region_id] += 1\\n\\n        # we continue to check its neighbors to see whehter they are infected cells\\n        self.dfs(isInfected, row-1, col, region_id) #up\\n        self.dfs(isInfected, row+1, col, region_id) #down\\n        self.dfs(isInfected, row, col-1, region_id) #left\\n        self.dfs(isInfected, row, col+1, region_id) #right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2515969,
                "title": "rust-dfs-all-the-way",
                "content": "```rust\\n\\nconst DIRECTION: [(isize, isize); 4] = [(-1, 0), (0, -1), (0, 1), (1, 0)];\\n\\nconst HEALTHY: i32 = 0;\\nconst INFECTED: i32 = 1;\\nconst MARKED_HEALTHY: i32 = 2;\\nconst MARKED_INFECTED: i32 = 3;\\nconst WALLED: i32 = 4;\\n\\npub fn contain_virus(mut grid: Vec<Vec<i32>>) -> i32 {\\n    let mut total = 0;\\n\\n    // Loop until we have stopped the infection or the whole world has become infected\\n    loop {\\n        let mut max_infected = 0;\\n        let mut border = 0;\\n        let mut rx = 0;\\n        let mut cx = 0;\\n\\n        // Measure the border length and the newly_infected \\n        // neighbours for each infection cluster\\n        for r in 0..grid.len() {\\n            for c in 0..grid[r].len() {\\n                if grid[r][c] == INFECTED {\\n                    let (infected, perimeter) = measure_border_and_infectiousness(&mut grid, r, c);\\n                    if infected > max_infected {\\n                        max_infected = infected;\\n                        border = perimeter;\\n                        rx = r;\\n                        cx = c;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // If there are no newly infected, then we can terminate and print the result\\n        if border == 0 {\\n            break;\\n        }\\n\\n        total += border;\\n\\n        // \"WALL\" the most infectious cluster\\n        mark_walled(&mut grid, rx, cx);\\n\\n        // Expand the other infectious clusters\\n        for r in 0..grid.len() {\\n            for c in 0..grid[r].len() {\\n                if grid[r][c] == MARKED_INFECTED {\\n                    expand_infection(&mut grid, r, c);\\n                }\\n            }\\n        }\\n    }\\n\\n    total\\n}\\n\\nfn measure_border_and_infectiousness(grid: &mut [Vec<i32>], r: usize, c: usize) -> (i32, i32) {\\n    let mut newly_infected = 0;\\n    let mut border = 0;\\n\\n    let mut marked = vec![];\\n    let mut stack = vec![(r, c)];\\n    grid[r][c] = MARKED_INFECTED;\\n\\n    while let Some((r, c)) = stack.pop() {\\n        for (dr, dc) in DIRECTION {\\n            let rx = r as isize + dr;\\n            let cx = c as isize + dc;\\n            if rx < 0 || cx < 0 {\\n                continue;\\n            }\\n\\n            let rx = rx as usize;\\n            let cx = cx as usize;\\n            if rx >= grid.len() || cx >= grid[rx].len() {\\n                continue;\\n            }\\n\\n            if grid[rx][cx] == HEALTHY {\\n                border += 1;\\n                newly_infected += 1;\\n\\n                // mark the newly infected cell in order to count it only once\\n                grid[rx][cx] = MARKED_HEALTHY;\\n\\n                // remember its coordinates in order to \"unmark it\" at the end\\n                marked.push((rx, cx));\\n            } else if grid[rx][cx] == MARKED_HEALTHY {\\n                // already included in the newly infected, but it still \\n                // contributes to the border length\\n                border += 1;\\n            } else if grid[rx][cx] == INFECTED {\\n                grid[rx][cx] = MARKED_INFECTED;\\n                stack.push((rx, cx));\\n            }\\n        }\\n    }\\n\\n    // unmark the marked healthy cells\\n    for (rx, cx) in marked {\\n        grid[rx][cx] = HEALTHY;\\n    }\\n\\n    (newly_infected, border)\\n}\\n\\nfn mark_walled(grid: &mut [Vec<i32>], r: usize, c: usize) {\\n    let mut stack = vec![(r, c)];\\n    grid[r][c] = WALLED;\\n\\n    while let Some((r, c)) = stack.pop() {\\n        for (dr, dc) in DIRECTION {\\n            let rx = r as isize + dr;\\n            let cx = c as isize + dc;\\n            if rx < 0 || cx < 0 {\\n                continue;\\n            }\\n\\n            let rx = rx as usize;\\n            let cx = cx as usize;\\n            if rx >= grid.len() || cx >= grid[rx].len() {\\n                continue;\\n            }\\n\\n            if grid[rx][cx] == MARKED_INFECTED {\\n                grid[rx][cx] = WALLED;\\n                stack.push((rx, cx));\\n            }\\n        }\\n    }\\n}\\n\\nfn expand_infection(grid: &mut [Vec<i32>], r: usize, c: usize) {\\n    let mut stack = vec![(r, c)];\\n    grid[r][c] = INFECTED;\\n\\n    while let Some((r, c)) = stack.pop() {\\n        for (dr, dc) in DIRECTION {\\n            let rx = r as isize + dr;\\n            let cx = c as isize + dc;\\n            if rx < 0 || cx < 0 {\\n                continue;\\n            }\\n\\n            let rx = rx as usize;\\n            let cx = cx as usize;\\n            if rx >= grid.len() || cx >= grid[rx].len() {\\n                continue;\\n            }\\n\\n            if grid[rx][cx] == HEALTHY {\\n                grid[rx][cx] = INFECTED;\\n            } else if grid[rx][cx] == MARKED_INFECTED {\\n                grid[rx][cx] = INFECTED;\\n                stack.push((rx, cx));\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Depth-First Search"
                ],
                "code": "```rust\\n\\nconst DIRECTION: [(isize, isize); 4] = [(-1, 0), (0, -1), (0, 1), (1, 0)];\\n\\nconst HEALTHY: i32 = 0;\\nconst INFECTED: i32 = 1;\\nconst MARKED_HEALTHY: i32 = 2;\\nconst MARKED_INFECTED: i32 = 3;\\nconst WALLED: i32 = 4;\\n\\npub fn contain_virus(mut grid: Vec<Vec<i32>>) -> i32 {\\n    let mut total = 0;\\n\\n    // Loop until we have stopped the infection or the whole world has become infected\\n    loop {\\n        let mut max_infected = 0;\\n        let mut border = 0;\\n        let mut rx = 0;\\n        let mut cx = 0;\\n\\n        // Measure the border length and the newly_infected \\n        // neighbours for each infection cluster\\n        for r in 0..grid.len() {\\n            for c in 0..grid[r].len() {\\n                if grid[r][c] == INFECTED {\\n                    let (infected, perimeter) = measure_border_and_infectiousness(&mut grid, r, c);\\n                    if infected > max_infected {\\n                        max_infected = infected;\\n                        border = perimeter;\\n                        rx = r;\\n                        cx = c;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // If there are no newly infected, then we can terminate and print the result\\n        if border == 0 {\\n            break;\\n        }\\n\\n        total += border;\\n\\n        // \"WALL\" the most infectious cluster\\n        mark_walled(&mut grid, rx, cx);\\n\\n        // Expand the other infectious clusters\\n        for r in 0..grid.len() {\\n            for c in 0..grid[r].len() {\\n                if grid[r][c] == MARKED_INFECTED {\\n                    expand_infection(&mut grid, r, c);\\n                }\\n            }\\n        }\\n    }\\n\\n    total\\n}\\n\\nfn measure_border_and_infectiousness(grid: &mut [Vec<i32>], r: usize, c: usize) -> (i32, i32) {\\n    let mut newly_infected = 0;\\n    let mut border = 0;\\n\\n    let mut marked = vec![];\\n    let mut stack = vec![(r, c)];\\n    grid[r][c] = MARKED_INFECTED;\\n\\n    while let Some((r, c)) = stack.pop() {\\n        for (dr, dc) in DIRECTION {\\n            let rx = r as isize + dr;\\n            let cx = c as isize + dc;\\n            if rx < 0 || cx < 0 {\\n                continue;\\n            }\\n\\n            let rx = rx as usize;\\n            let cx = cx as usize;\\n            if rx >= grid.len() || cx >= grid[rx].len() {\\n                continue;\\n            }\\n\\n            if grid[rx][cx] == HEALTHY {\\n                border += 1;\\n                newly_infected += 1;\\n\\n                // mark the newly infected cell in order to count it only once\\n                grid[rx][cx] = MARKED_HEALTHY;\\n\\n                // remember its coordinates in order to \"unmark it\" at the end\\n                marked.push((rx, cx));\\n            } else if grid[rx][cx] == MARKED_HEALTHY {\\n                // already included in the newly infected, but it still \\n                // contributes to the border length\\n                border += 1;\\n            } else if grid[rx][cx] == INFECTED {\\n                grid[rx][cx] = MARKED_INFECTED;\\n                stack.push((rx, cx));\\n            }\\n        }\\n    }\\n\\n    // unmark the marked healthy cells\\n    for (rx, cx) in marked {\\n        grid[rx][cx] = HEALTHY;\\n    }\\n\\n    (newly_infected, border)\\n}\\n\\nfn mark_walled(grid: &mut [Vec<i32>], r: usize, c: usize) {\\n    let mut stack = vec![(r, c)];\\n    grid[r][c] = WALLED;\\n\\n    while let Some((r, c)) = stack.pop() {\\n        for (dr, dc) in DIRECTION {\\n            let rx = r as isize + dr;\\n            let cx = c as isize + dc;\\n            if rx < 0 || cx < 0 {\\n                continue;\\n            }\\n\\n            let rx = rx as usize;\\n            let cx = cx as usize;\\n            if rx >= grid.len() || cx >= grid[rx].len() {\\n                continue;\\n            }\\n\\n            if grid[rx][cx] == MARKED_INFECTED {\\n                grid[rx][cx] = WALLED;\\n                stack.push((rx, cx));\\n            }\\n        }\\n    }\\n}\\n\\nfn expand_infection(grid: &mut [Vec<i32>], r: usize, c: usize) {\\n    let mut stack = vec![(r, c)];\\n    grid[r][c] = INFECTED;\\n\\n    while let Some((r, c)) = stack.pop() {\\n        for (dr, dc) in DIRECTION {\\n            let rx = r as isize + dr;\\n            let cx = c as isize + dc;\\n            if rx < 0 || cx < 0 {\\n                continue;\\n            }\\n\\n            let rx = rx as usize;\\n            let cx = cx as usize;\\n            if rx >= grid.len() || cx >= grid[rx].len() {\\n                continue;\\n            }\\n\\n            if grid[rx][cx] == HEALTHY {\\n                grid[rx][cx] = INFECTED;\\n            } else if grid[rx][cx] == MARKED_INFECTED {\\n                grid[rx][cx] = INFECTED;\\n                stack.push((rx, cx));\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2443898,
                "title": "c-dfs",
                "content": "```\\n#define fi first\\n#define si second\\nint dx[4] = {1,0,-1,0};\\nint dy[4] = {0,1,0,-1};\\nint n,m;\\nint isvalid(int x,int y)\\n{\\n    if(x<0 || y<0 || x>=n || y>=m)return 0;\\n    return 1;\\n}\\nvoid dfs(int x,int y,vector<vector<int>>& g,vector<vector<int>>& vis,vector<pair<int,int>>& cc)\\n{\\n    vis[x][y]=1;\\n    cc.push_back({x,y});\\n    for(int i=0;i<4;i++)\\n    {\\n        int l = x+dx[i] , r = y+dy[i];\\n        if(isvalid(l,r) && vis[l][r]==0 && g[l][r]==1)\\n        {\\n            dfs(l,r,g,vis,cc);\\n        }\\n    }\\n}\\nint solve(vector<pair<int,int>>& a,vector<vector<int>>& g)\\n{\\n    set<pair<int,int>> st;\\n    for(auto &i:a)\\n    {\\n        int x = i.fi , y = i.si;\\n        for(int i=0;i<4;i++)\\n        {\\n            int l = x+dx[i] , r = y+dy[i];\\n            if(isvalid(l,r)==0)continue;\\n            if(g[l][r]==0)st.insert({l,r});\\n        }   \\n    }\\n    return st.size();\\n}\\nint solve1(vector<pair<int,int>>& a,vector<vector<int>>& g)\\n{\\n    int ans = 0;\\n    for(auto &i:a)\\n    {\\n        int x = i.fi , y = i.si;\\n        g[x][y]=-1;\\n        for(int i=0;i<4;i++)\\n        {\\n            int l = x+dx[i] , r = y+dy[i];\\n            if(isvalid(l,r)==0)continue;\\n            if(g[l][r]==0)ans++;\\n        }   \\n    }\\n    return ans;\\n}\\nvoid update(vector<pair<int,int>>& a,vector<vector<int>>& g)\\n{\\n    for(auto &i:a)\\n    {\\n        int x = i.fi , y = i.si;\\n        for(int i=0;i<4;i++)\\n        {\\n            int l = x+dx[i] , r = y+dy[i];\\n            if(isvalid(l,r)==0)continue;\\n            if(g[l][r]==0)g[l][r]=1;\\n        }   \\n    }\\n}\\nclass Solution {\\npublic:\\n    int containVirus(vector<vector<int>>& g) {\\n        n = g.size();\\n        m = g[0].size();\\n        vector<vector<pair<int,int>>> v;\\n        vector<pair<int,int>> cc;\\n        int ans = 0;\\n        while(true)\\n        {\\n            vector<vector<int>> vis(n,vector<int>(m,0));\\n            v.clear();\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=0;j<m;j++)\\n                {\\n                    if(vis[i][j]!=0 || g[i][j]!=1)continue;\\n                    cc.clear();\\n                    dfs(i,j,g,vis,cc);\\n                    v.push_back(cc);\\n                }\\n            }\\n            int mx = -1 , j = -1;\\n            for(int i=0;i<v.size();i++)\\n            {\\n                int t = solve(v[i],g);\\n                if(t>mx){j=i;mx=t;}\\n            }\\n            if(j==-1)break;\\n            ans+=solve1(v[j],g);\\n            for(int i=0;i<v.size();i++)\\n            {\\n                if(i==j)continue;\\n                update(v[i],g);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define fi first\\n#define si second\\nint dx[4] = {1,0,-1,0};\\nint dy[4] = {0,1,0,-1};\\nint n,m;\\nint isvalid(int x,int y)\\n{\\n    if(x<0 || y<0 || x>=n || y>=m)return 0;\\n    return 1;\\n}\\nvoid dfs(int x,int y,vector<vector<int>>& g,vector<vector<int>>& vis,vector<pair<int,int>>& cc)\\n{\\n    vis[x][y]=1;\\n    cc.push_back({x,y});\\n    for(int i=0;i<4;i++)\\n    {\\n        int l = x+dx[i] , r = y+dy[i];\\n        if(isvalid(l,r) && vis[l][r]==0 && g[l][r]==1)\\n        {\\n            dfs(l,r,g,vis,cc);\\n        }\\n    }\\n}\\nint solve(vector<pair<int,int>>& a,vector<vector<int>>& g)\\n{\\n    set<pair<int,int>> st;\\n    for(auto &i:a)\\n    {\\n        int x = i.fi , y = i.si;\\n        for(int i=0;i<4;i++)\\n        {\\n            int l = x+dx[i] , r = y+dy[i];\\n            if(isvalid(l,r)==0)continue;\\n            if(g[l][r]==0)st.insert({l,r});\\n        }   \\n    }\\n    return st.size();\\n}\\nint solve1(vector<pair<int,int>>& a,vector<vector<int>>& g)\\n{\\n    int ans = 0;\\n    for(auto &i:a)\\n    {\\n        int x = i.fi , y = i.si;\\n        g[x][y]=-1;\\n        for(int i=0;i<4;i++)\\n        {\\n            int l = x+dx[i] , r = y+dy[i];\\n            if(isvalid(l,r)==0)continue;\\n            if(g[l][r]==0)ans++;\\n        }   \\n    }\\n    return ans;\\n}\\nvoid update(vector<pair<int,int>>& a,vector<vector<int>>& g)\\n{\\n    for(auto &i:a)\\n    {\\n        int x = i.fi , y = i.si;\\n        for(int i=0;i<4;i++)\\n        {\\n            int l = x+dx[i] , r = y+dy[i];\\n            if(isvalid(l,r)==0)continue;\\n            if(g[l][r]==0)g[l][r]=1;\\n        }   \\n    }\\n}\\nclass Solution {\\npublic:\\n    int containVirus(vector<vector<int>>& g) {\\n        n = g.size();\\n        m = g[0].size();\\n        vector<vector<pair<int,int>>> v;\\n        vector<pair<int,int>> cc;\\n        int ans = 0;\\n        while(true)\\n        {\\n            vector<vector<int>> vis(n,vector<int>(m,0));\\n            v.clear();\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=0;j<m;j++)\\n                {\\n                    if(vis[i][j]!=0 || g[i][j]!=1)continue;\\n                    cc.clear();\\n                    dfs(i,j,g,vis,cc);\\n                    v.push_back(cc);\\n                }\\n            }\\n            int mx = -1 , j = -1;\\n            for(int i=0;i<v.size();i++)\\n            {\\n                int t = solve(v[i],g);\\n                if(t>mx){j=i;mx=t;}\\n            }\\n            if(j==-1)break;\\n            ans+=solve1(v[j],g);\\n            for(int i=0;i<v.size();i++)\\n            {\\n                if(i==j)continue;\\n                update(v[i],g);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2287965,
                "title": "rust-dfs-recursive-with-a-max-heap",
                "content": "Solution - [github](https://github.com/An7One/lc_soln_rust_leon/tree/main/src/leetcode/lvl6/lc0749)\\n\\n<b>Problem List</b>\\n#DFSRecursive - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_algorithm/search/depth_first_search)\\n#BFS - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_algorithm/search/breath_first_search)\\n#UnionFind - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_algorithm/union_find)\\n#UndirectedGraph - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_data_structure/graph/by_data_structure/undirected_graph)\\n#Island - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/blob/main/txt/by_data_structure/array/by_topic/island.txt)\\n\\n```rust\\nuse std::cmp::{Ord, Ordering, PartialOrd};\\nuse std::collections::{BinaryHeap, HashSet};\\n/// @author: Leon\\n/// https://leetcode.com/problems/contain-virus/\\n/// Time Complexity:    O(`len_rs` * `len_cs` * lg(`len_rs` * `len_cs`))\\n/// Space Complexity:   O(`len_rs` * `len_cs`)\\n/// Reference:\\n/// https://leetcode.com/problems/contain-virus/discuss/526848/Java-DFS-9-ms-Explanation-with-comments/803930\\n/// https://leetcode.com/problems/contain-virus/discuss/526848/Java-DFS-9-ms-Explanation-with-comments\\n/// https://leetcode.com/problems/contain-virus/discuss/2169784/Infinite-Grid-DSU-and-DFS-Modular-w-Diagram\\nimpl Solution {\\n    const DIRS: &\\'static [isize] = &[0, -1, 0, 1, 0];\\n    const INFECTED: i32 = 1;\\n    const UNINFECTED: i32 = 0;\\n\\tconst BLOCKED: i32 = -1;\\n    pub fn contain_virus(mut grid: Vec<Vec<i32>>) -> i32 {\\n        let _len_rs: usize = grid.len();\\n        let len_cs: usize = grid[0].len();\\n        let mut cnt: i32 = 0;\\n        let mut phase: i32 = 1;\\n        let mut heap: BinaryHeap<Region> = {\\n            let mut heap: BinaryHeap<Region> = BinaryHeap::new();\\n            Self::add(phase, &mut grid, &mut heap);\\n            heap\\n        };\\n        while let Some(Region {\\n            infected,\\n            uninfected_neighbors: _,\\n            walls_needed,\\n        }) = heap.pop()\\n        {\\n            cnt += walls_needed;\\n            for hash in infected {\\n                grid[hash / len_cs][hash % len_cs] = Self::BLOCKED;\\n            }\\n            phase += 1;\\n            while let Some(Region {\\n                infected: _,\\n                uninfected_neighbors,\\n                walls_needed: _,\\n            }) = heap.pop()\\n            {\\n                for hash in uninfected_neighbors {\\n                    grid[hash / len_cs][hash % len_cs] = phase;\\n                }\\n            }\\n            Self::add(phase, &mut grid, &mut heap);\\n        }\\n        cnt\\n    }\\n    fn add(phase: i32, grid: &mut Vec<Vec<i32>>, heap: &mut BinaryHeap<Region>) {\\n        let len_rs: usize = grid.len();\\n        let len_cs: usize = grid[0].len();\\n        for r in 0..len_rs {\\n            for c in 0..len_cs {\\n                if grid[r][c] == phase {\\n                    let mut region = Region::new();\\n                    Self::dfs((r as isize, c as isize), phase, grid, &mut region);\\n                    if !region.uninfected_neighbors.is_empty() {\\n                        heap.push(region);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    fn dfs(coord: (isize, isize), phase: i32, grid: &mut Vec<Vec<i32>>, region: &mut Region) {\\n        let len_rs: isize = grid.len() as isize;\\n        let len_cs: isize = grid[0].len() as isize;\\n        let (r, c) = coord;\\n        if r < 0\\n            || c < 0\\n            || r >= len_rs\\n            || c >= len_cs\\n            || grid[r as usize][c as usize] == -1\\n            || grid[r as usize][c as usize] > phase\\n        {\\n            return;\\n        }\\n        if grid[r as usize][c as usize] == Self::UNINFECTED {\\n            region.uninfected_neighbors.insert(Self::hash(r, c, len_cs));\\n            region.walls_needed += 1;\\n            return;\\n        }\\n        grid[r as usize][c as usize] += 1;\\n        region.infected.insert(Self::hash(r, c, len_cs));\\n        for d in 0..4 {\\n            let r_nxt: isize = r + Self::DIRS[d];\\n            let c_nxt: isize = c + Self::DIRS[d + 1];\\n            Self::dfs((r_nxt, c_nxt), phase, grid, region);\\n        }\\n    }\\n    fn hash(r: isize, c: isize, len_cs: isize) -> usize {\\n        (r * len_cs + c) as usize\\n    }\\n}\\n\\nstruct Region {\\n    infected: HashSet<usize>,\\n    uninfected_neighbors: HashSet<usize>,\\n    walls_needed: i32,\\n}\\n\\nimpl Region {\\n    pub fn new() -> Self {\\n        Region {\\n            infected: HashSet::new(),\\n            uninfected_neighbors: HashSet::new(),\\n            walls_needed: 0,\\n        }\\n    }\\n}\\n\\nimpl Ord for Region {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        self.uninfected_neighbors\\n            .len()\\n            .cmp(&other.uninfected_neighbors.len())\\n    }\\n}\\n\\nimpl PartialOrd for Region {\\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\\n        Some(self.cmp(other))\\n    }\\n}\\n\\nimpl PartialEq for Region {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.uninfected_neighbors.len() == other.uninfected_neighbors.len()\\n    }\\n}\\n\\nimpl Eq for Region {}\\n```",
                "solutionTags": [
                    "Rust",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```rust\\nuse std::cmp::{Ord, Ordering, PartialOrd};\\nuse std::collections::{BinaryHeap, HashSet};\\n/// @author: Leon\\n/// https://leetcode.com/problems/contain-virus/\\n/// Time Complexity:    O(`len_rs` * `len_cs` * lg(`len_rs` * `len_cs`))\\n/// Space Complexity:   O(`len_rs` * `len_cs`)\\n/// Reference:\\n/// https://leetcode.com/problems/contain-virus/discuss/526848/Java-DFS-9-ms-Explanation-with-comments/803930\\n/// https://leetcode.com/problems/contain-virus/discuss/526848/Java-DFS-9-ms-Explanation-with-comments\\n/// https://leetcode.com/problems/contain-virus/discuss/2169784/Infinite-Grid-DSU-and-DFS-Modular-w-Diagram\\nimpl Solution {\\n    const DIRS: &\\'static [isize] = &[0, -1, 0, 1, 0];\\n    const INFECTED: i32 = 1;\\n    const UNINFECTED: i32 = 0;\\n\\tconst BLOCKED: i32 = -1;\\n    pub fn contain_virus(mut grid: Vec<Vec<i32>>) -> i32 {\\n        let _len_rs: usize = grid.len();\\n        let len_cs: usize = grid[0].len();\\n        let mut cnt: i32 = 0;\\n        let mut phase: i32 = 1;\\n        let mut heap: BinaryHeap<Region> = {\\n            let mut heap: BinaryHeap<Region> = BinaryHeap::new();\\n            Self::add(phase, &mut grid, &mut heap);\\n            heap\\n        };\\n        while let Some(Region {\\n            infected,\\n            uninfected_neighbors: _,\\n            walls_needed,\\n        }) = heap.pop()\\n        {\\n            cnt += walls_needed;\\n            for hash in infected {\\n                grid[hash / len_cs][hash % len_cs] = Self::BLOCKED;\\n            }\\n            phase += 1;\\n            while let Some(Region {\\n                infected: _,\\n                uninfected_neighbors,\\n                walls_needed: _,\\n            }) = heap.pop()\\n            {\\n                for hash in uninfected_neighbors {\\n                    grid[hash / len_cs][hash % len_cs] = phase;\\n                }\\n            }\\n            Self::add(phase, &mut grid, &mut heap);\\n        }\\n        cnt\\n    }\\n    fn add(phase: i32, grid: &mut Vec<Vec<i32>>, heap: &mut BinaryHeap<Region>) {\\n        let len_rs: usize = grid.len();\\n        let len_cs: usize = grid[0].len();\\n        for r in 0..len_rs {\\n            for c in 0..len_cs {\\n                if grid[r][c] == phase {\\n                    let mut region = Region::new();\\n                    Self::dfs((r as isize, c as isize), phase, grid, &mut region);\\n                    if !region.uninfected_neighbors.is_empty() {\\n                        heap.push(region);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    fn dfs(coord: (isize, isize), phase: i32, grid: &mut Vec<Vec<i32>>, region: &mut Region) {\\n        let len_rs: isize = grid.len() as isize;\\n        let len_cs: isize = grid[0].len() as isize;\\n        let (r, c) = coord;\\n        if r < 0\\n            || c < 0\\n            || r >= len_rs\\n            || c >= len_cs\\n            || grid[r as usize][c as usize] == -1\\n            || grid[r as usize][c as usize] > phase\\n        {\\n            return;\\n        }\\n        if grid[r as usize][c as usize] == Self::UNINFECTED {\\n            region.uninfected_neighbors.insert(Self::hash(r, c, len_cs));\\n            region.walls_needed += 1;\\n            return;\\n        }\\n        grid[r as usize][c as usize] += 1;\\n        region.infected.insert(Self::hash(r, c, len_cs));\\n        for d in 0..4 {\\n            let r_nxt: isize = r + Self::DIRS[d];\\n            let c_nxt: isize = c + Self::DIRS[d + 1];\\n            Self::dfs((r_nxt, c_nxt), phase, grid, region);\\n        }\\n    }\\n    fn hash(r: isize, c: isize, len_cs: isize) -> usize {\\n        (r * len_cs + c) as usize\\n    }\\n}\\n\\nstruct Region {\\n    infected: HashSet<usize>,\\n    uninfected_neighbors: HashSet<usize>,\\n    walls_needed: i32,\\n}\\n\\nimpl Region {\\n    pub fn new() -> Self {\\n        Region {\\n            infected: HashSet::new(),\\n            uninfected_neighbors: HashSet::new(),\\n            walls_needed: 0,\\n        }\\n    }\\n}\\n\\nimpl Ord for Region {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        self.uninfected_neighbors\\n            .len()\\n            .cmp(&other.uninfected_neighbors.len())\\n    }\\n}\\n\\nimpl PartialOrd for Region {\\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\\n        Some(self.cmp(other))\\n    }\\n}\\n\\nimpl PartialEq for Region {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.uninfected_neighbors.len() == other.uninfected_neighbors.len()\\n    }\\n}\\n\\nimpl Eq for Region {}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2286729,
                "title": "java-dfs-minheap-explained",
                "content": "```\\nclass Solution {\\n    \\n    private static final int[][] DIR = new int[][]{\\n        {1, 0}, {-1, 0}, {0, 1}, {0, -1}\\n    };\\n    \\n    public int containVirus(int[][] isInfected) {\\n        int m = isInfected.length, n = isInfected[0].length;\\n        int ans = 0;\\n        \\n        while( true ) {\\n            // infected regions, sorted desc according to the number of nearby \\n            // uninfected nodes\\n            PriorityQueue<Region> pq = new PriorityQueue<Region>();\\n            // already visited cells\\n            boolean[][] visited = new boolean[m][n];\\n            \\n            // find regions\\n            for(int i=0; i<m; i++) {\\n                for(int j=0; j<n; j++) {\\n                    \\n                    // if current cell is infected, and it\\'s not visited\\n                    if( isInfected[i][j] != 1 || visited[i][j] ) \\n                        continue;\\n                    \\n                    // we found a new region, dfs to find all the infected\\n                    // and uninfected cells in the current region\\n                    Region reg = new Region();\\n                    dfs(i, j, reg, isInfected, visited, new boolean[m][n], m, n);\\n                    \\n                    // if there are some uninfected nodes in this region, \\n                    // we can contain it, so add it to priority queue\\n                    if( reg.uninfected.size() != 0)\\n                        pq.offer(reg);\\n                }\\n            }\\n            \\n            // if there are no regions to contain, break\\n            if( pq.isEmpty() )\\n                break;\\n\\n            // Contain region with most uninfected nodes\\n            Region containReg = pq.poll();\\n            ans += containReg.wallsRequired;\\n            \\n            // use (2) to mark a cell as contained\\n            for(int[] cell : containReg.infected)\\n                isInfected[cell[0]][cell[1]] = 2;\\n            \\n            // Spread infection to uninfected nodes in other regions\\n            while( !pq.isEmpty() ) {\\n                Region spreadReg = pq.poll();\\n                \\n                for(int[] cell : spreadReg.uninfected)\\n                    isInfected[cell[0]][cell[1]] = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private void dfs(int i, int j, Region reg, int[][] grid, boolean[][] visited, boolean[][] uninfectedVis, int m, int n) {\\n        visited[i][j] = true;\\n        reg.addInfected(i, j);\\n        \\n        for(int[] dir : DIR) {\\n            int di = i + dir[0];\\n            int dj = j + dir[1];\\n            \\n            // continue, if out of bounds OR contained OR already visited\\n            if( di < 0 || dj < 0 || di == m || dj == n || grid[di][dj] == 2 || visited[di][dj] )\\n                continue;\\n            \\n            // if neighbour node is not infected\\n            if( grid[di][dj] == 0 ) {\\n                // a wall will require to stop the spread from cell (i,j) to (di, dj)\\n                reg.wallsRequired++;\\n                \\n                // if this uninfected node is not already visited for current region\\n                if( !uninfectedVis[di][dj] ) {\\n                    uninfectedVis[di][dj] = true;\\n                    reg.addUninfected(di, dj);\\n                }\\n            } else \\n                dfs(di, dj, reg, grid, visited, uninfectedVis, m, n);\\n        }\\n    }\\n}\\nclass Region implements Comparable<Region> {\\n    public List<int[]> infected;\\n    public List<int[]> uninfected;\\n    public int wallsRequired;\\n    \\n    public Region() {\\n        infected = new ArrayList();\\n        uninfected = new ArrayList();\\n    }\\n    \\n    public void addInfected(int row, int col) {\\n        infected.add(new int[]{ row, col });\\n    }\\n    \\n    public void addUninfected(int row, int col) {\\n        uninfected.add(new int[]{ row, col });\\n    }\\n    \\n    @Override\\n    public int compareTo(Region r2) {\\n        return Integer.compare(r2.uninfected.size(), uninfected.size());\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private static final int[][] DIR = new int[][]{\\n        {1, 0}, {-1, 0}, {0, 1}, {0, -1}\\n    };\\n    \\n    public int containVirus(int[][] isInfected) {\\n        int m = isInfected.length, n = isInfected[0].length;\\n        int ans = 0;\\n        \\n        while( true ) {\\n            // infected regions, sorted desc according to the number of nearby \\n            // uninfected nodes\\n            PriorityQueue<Region> pq = new PriorityQueue<Region>();\\n            // already visited cells\\n            boolean[][] visited = new boolean[m][n];\\n            \\n            // find regions\\n            for(int i=0; i<m; i++) {\\n                for(int j=0; j<n; j++) {\\n                    \\n                    // if current cell is infected, and it\\'s not visited\\n                    if( isInfected[i][j] != 1 || visited[i][j] ) \\n                        continue;\\n                    \\n                    // we found a new region, dfs to find all the infected\\n                    // and uninfected cells in the current region\\n                    Region reg = new Region();\\n                    dfs(i, j, reg, isInfected, visited, new boolean[m][n], m, n);\\n                    \\n                    // if there are some uninfected nodes in this region, \\n                    // we can contain it, so add it to priority queue\\n                    if( reg.uninfected.size() != 0)\\n                        pq.offer(reg);\\n                }\\n            }\\n            \\n            // if there are no regions to contain, break\\n            if( pq.isEmpty() )\\n                break;\\n\\n            // Contain region with most uninfected nodes\\n            Region containReg = pq.poll();\\n            ans += containReg.wallsRequired;\\n            \\n            // use (2) to mark a cell as contained\\n            for(int[] cell : containReg.infected)\\n                isInfected[cell[0]][cell[1]] = 2;\\n            \\n            // Spread infection to uninfected nodes in other regions\\n            while( !pq.isEmpty() ) {\\n                Region spreadReg = pq.poll();\\n                \\n                for(int[] cell : spreadReg.uninfected)\\n                    isInfected[cell[0]][cell[1]] = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private void dfs(int i, int j, Region reg, int[][] grid, boolean[][] visited, boolean[][] uninfectedVis, int m, int n) {\\n        visited[i][j] = true;\\n        reg.addInfected(i, j);\\n        \\n        for(int[] dir : DIR) {\\n            int di = i + dir[0];\\n            int dj = j + dir[1];\\n            \\n            // continue, if out of bounds OR contained OR already visited\\n            if( di < 0 || dj < 0 || di == m || dj == n || grid[di][dj] == 2 || visited[di][dj] )\\n                continue;\\n            \\n            // if neighbour node is not infected\\n            if( grid[di][dj] == 0 ) {\\n                // a wall will require to stop the spread from cell (i,j) to (di, dj)\\n                reg.wallsRequired++;\\n                \\n                // if this uninfected node is not already visited for current region\\n                if( !uninfectedVis[di][dj] ) {\\n                    uninfectedVis[di][dj] = true;\\n                    reg.addUninfected(di, dj);\\n                }\\n            } else \\n                dfs(di, dj, reg, grid, visited, uninfectedVis, m, n);\\n        }\\n    }\\n}\\nclass Region implements Comparable<Region> {\\n    public List<int[]> infected;\\n    public List<int[]> uninfected;\\n    public int wallsRequired;\\n    \\n    public Region() {\\n        infected = new ArrayList();\\n        uninfected = new ArrayList();\\n    }\\n    \\n    public void addInfected(int row, int col) {\\n        infected.add(new int[]{ row, col });\\n    }\\n    \\n    public void addUninfected(int row, int col) {\\n        uninfected.add(new int[]{ row, col });\\n    }\\n    \\n    @Override\\n    public int compareTo(Region r2) {\\n        return Integer.compare(r2.uninfected.size(), uninfected.size());\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262313,
                "title": "java-oo-dfs-explained",
                "content": "```\\nclass Solution {\\n    int rows, cols;\\n    int[][] directions = {\\n        {0,1},{0,-1},{1,0},{-1,0}\\n    };\\n    int[][] isInfected;\\n    public int containVirus(int[][] isInfected) {\\n        // 1. getRegions\\n        // 2. Sort in a decreasing order by most uninfected neighbours\\n        // 3. pick up the first element and mark it is as contained\\n        // 4. add the walls required in the result\\n        // 5. rest of the regions, we will mark infected for the uninfected neighbours\\n        rows = isInfected.length;\\n        cols = isInfected[0].length;\\n        this.isInfected = isInfected;\\n        if (this.isInfected == null || this.isInfected.length == 0) {\\n            return 0;\\n        }\\n        int result = 0;\\n        while (true) {\\n            List<Region> regions = new ArrayList();\\n            boolean[][] visited = new boolean[rows][cols];\\n            for (int row = 0; row < rows; row++) {\\n                for (int col = 0; col < cols; col++) {\\n                    if (this.isInfected[row][col] == 1) {\\n                        Region region = new Region();\\n                        traverseRegion(row, col, region, visited);\\n                        \\n                        if (region.neighbours.size() > 0) {\\n                            regions.add(region);\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            if (regions.size() == 0) {\\n                break;\\n            }\\n            \\n            Collections.sort(regions);\\n            \\n            Region mostContagiousRegion = regions.remove(0);\\n            result += mostContagiousRegion.wallsRequired;\\n            \\n            for (int infectedArea: mostContagiousRegion.infected) {\\n                int row = infectedArea / cols, col = infectedArea % cols;\\n                this.isInfected[row][col] = 2;\\n            }\\n            \\n            for (Region region: regions) {\\n                for (int neighbour: region.neighbours) {\\n                    int row = neighbour / cols, col = neighbour % cols;\\n                    this.isInfected[row][col] = 1;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private void traverseRegion(int row, int col, Region region, boolean[][] visited) {\\n        if (outOfBoundary(row, col)) {\\n            return;\\n        }\\n        \\n        if (this.isInfected[row][col] == 2) {\\n            return; // contained already\\n        }\\n        \\n        if (this.isInfected[row][col] == 1) {\\n            region.infected.add(row * cols + col);\\n            if (visited[row][col]) {\\n                return;\\n            }\\n        }\\n\\n        visited[row][col] = true;\\n        if (this.isInfected[row][col] == 0) {\\n            region.neighbours.add(row * cols + col);\\n            region.wallsRequired++;\\n            return;\\n        }\\n        \\n        // traverse 4 directionally connected cells\\n        for (int[] direction: directions) {\\n            traverseRegion(direction[0] + row, direction[1] + col, region, visited);\\n        }\\n    }\\n    \\n    private boolean outOfBoundary(int row, int col) {\\n        return row < 0 || col < 0 || row >= rows || col >= cols;\\n    }\\n    \\n    static class Region implements Comparable {\\n        Set<Integer> infected;\\n        Set<Integer> neighbours;\\n        int wallsRequired;\\n        \\n        Region() {\\n            this.infected = new HashSet();\\n            this.neighbours = new HashSet();\\n            this.wallsRequired =0;\\n        }\\n\\n        @Override\\n        public int compareTo(Object o) {\\n            Region r = (Region) o;\\n            return r.neighbours.size() - this.neighbours.size();\\n        }\\n        \\n        @Override\\n        public String toString() {\\n            return \"Region{\" +\\n                    \"infected=\" + infected +\\n                    \", neighbours=\" + neighbours +\\n                    \", wallsRequired=\" + wallsRequired +\\n                    \\'}\\';\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int rows, cols;\\n    int[][] directions = {\\n        {0,1},{0,-1},{1,0},{-1,0}\\n    };\\n    int[][] isInfected;\\n    public int containVirus(int[][] isInfected) {\\n        // 1. getRegions\\n        // 2. Sort in a decreasing order by most uninfected neighbours\\n        // 3. pick up the first element and mark it is as contained\\n        // 4. add the walls required in the result\\n        // 5. rest of the regions, we will mark infected for the uninfected neighbours\\n        rows = isInfected.length;\\n        cols = isInfected[0].length;\\n        this.isInfected = isInfected;\\n        if (this.isInfected == null || this.isInfected.length == 0) {\\n            return 0;\\n        }\\n        int result = 0;\\n        while (true) {\\n            List<Region> regions = new ArrayList();\\n            boolean[][] visited = new boolean[rows][cols];\\n            for (int row = 0; row < rows; row++) {\\n                for (int col = 0; col < cols; col++) {\\n                    if (this.isInfected[row][col] == 1) {\\n                        Region region = new Region();\\n                        traverseRegion(row, col, region, visited);\\n                        \\n                        if (region.neighbours.size() > 0) {\\n                            regions.add(region);\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            if (regions.size() == 0) {\\n                break;\\n            }\\n            \\n            Collections.sort(regions);\\n            \\n            Region mostContagiousRegion = regions.remove(0);\\n            result += mostContagiousRegion.wallsRequired;\\n            \\n            for (int infectedArea: mostContagiousRegion.infected) {\\n                int row = infectedArea / cols, col = infectedArea % cols;\\n                this.isInfected[row][col] = 2;\\n            }\\n            \\n            for (Region region: regions) {\\n                for (int neighbour: region.neighbours) {\\n                    int row = neighbour / cols, col = neighbour % cols;\\n                    this.isInfected[row][col] = 1;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private void traverseRegion(int row, int col, Region region, boolean[][] visited) {\\n        if (outOfBoundary(row, col)) {\\n            return;\\n        }\\n        \\n        if (this.isInfected[row][col] == 2) {\\n            return; // contained already\\n        }\\n        \\n        if (this.isInfected[row][col] == 1) {\\n            region.infected.add(row * cols + col);\\n            if (visited[row][col]) {\\n                return;\\n            }\\n        }\\n\\n        visited[row][col] = true;\\n        if (this.isInfected[row][col] == 0) {\\n            region.neighbours.add(row * cols + col);\\n            region.wallsRequired++;\\n            return;\\n        }\\n        \\n        // traverse 4 directionally connected cells\\n        for (int[] direction: directions) {\\n            traverseRegion(direction[0] + row, direction[1] + col, region, visited);\\n        }\\n    }\\n    \\n    private boolean outOfBoundary(int row, int col) {\\n        return row < 0 || col < 0 || row >= rows || col >= cols;\\n    }\\n    \\n    static class Region implements Comparable {\\n        Set<Integer> infected;\\n        Set<Integer> neighbours;\\n        int wallsRequired;\\n        \\n        Region() {\\n            this.infected = new HashSet();\\n            this.neighbours = new HashSet();\\n            this.wallsRequired =0;\\n        }\\n\\n        @Override\\n        public int compareTo(Object o) {\\n            Region r = (Region) o;\\n            return r.neighbours.size() - this.neighbours.size();\\n        }\\n        \\n        @Override\\n        public String toString() {\\n            return \"Region{\" +\\n                    \"infected=\" + infected +\\n                    \", neighbours=\" + neighbours +\\n                    \", wallsRequired=\" + wallsRequired +\\n                    \\'}\\';\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2221286,
                "title": "what-the-right-answer",
                "content": "Hello! Can anybody explain the right answer for this matrix:\\n{ {0,1,1,1,1,0,1,1,0,0 },\\n { 0,0,0,0,0,0,1,1,0,0 },\\n { 0,0,0,0,0,1,0,0,0,1 },\\n { 0,0,1,0,0,0,0,1,0,0 },\\n { 1,0,0,0,0,0,1,0,0,0 },\\n { 0,0,1,1,0,1,0,0,1,0 },\\n { 0,0,0,0,0,0,0,0,0,1 },\\n { 0,0,0,0,0,1,1,0,0,0 },\\n { 0,0,0,1,0,1,0,0,0,0 },\\n { 0,0,1,0,0,0,0,0,1,0 }};\\n",
                "solutionTags": [],
                "code": "Hello! Can anybody explain the right answer for this matrix:\\n{ {0,1,1,1,1,0,1,1,0,0 },\\n { 0,0,0,0,0,0,1,1,0,0 },\\n { 0,0,0,0,0,1,0,0,0,1 },\\n { 0,0,1,0,0,0,0,1,0,0 },\\n { 1,0,0,0,0,0,1,0,0,0 },\\n { 0,0,1,1,0,1,0,0,1,0 },\\n { 0,0,0,0,0,0,0,0,0,1 },\\n { 0,0,0,0,0,1,1,0,0,0 },\\n { 0,0,0,1,0,1,0,0,0,0 },\\n { 0,0,1,0,0,0,0,0,1,0 }};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2058837,
                "title": "dfs-c",
                "content": "```\\nInspired by: https://leetcode.com/problems/contain-virus/discuss/752571/C%2B%2B-DFS-simulation-(20-ms)\\n\\nclass Solution {\\n    // DFS on a particular cluster, counting boundary walls and exposed neighbours\\n    int dfs(vector<vector<int>>& g, int x, int y, int& exposed, int label) {\\n        if (x < 0 || y < 0 || x == g.size() || y == g[0].size())\\n            return 0;\\n        if (g[x][y] != 1)\\n            return 0;\\n        int res = 0;\\n        // A wall is required between an infected cell and an exposed (i.e. non-infected)\\n        // neighbour\\n        if (x > 0 && g[x - 1][y] <= 0) {\\n            res++;\\n            exposed += (g[x - 1][y] != -label);\\n            // Make sure we don\\'t count this neighbour again\\n            g[x - 1][y] = -label;\\n        }\\n        if (x < g.size() - 1 && g[x + 1][y] <= 0) {\\n            res++;\\n            exposed += (g[x + 1][y] != -label);\\n            g[x + 1][y] = -label;\\n        }\\n        if (y > 0 && g[x][y - 1] <= 0) {\\n            res++;\\n            exposed += (g[x][y - 1] != -label);\\n            g[x][y - 1] = -label;\\n        }\\n        if (y < g[0].size() - 1 && g[x][y + 1] <= 0) {\\n            res++;\\n            exposed += (g[x][y + 1] != -label);\\n            g[x][y + 1] = -label;\\n        }\\n        // Mark each cell in this cluster as having gone through a DFS during\\n        // this particular iteration\\n        g[x][y] = label;\\n        res += dfs(g, x - 1, y, exposed, label);\\n        res += dfs(g, x + 1, y, exposed, label);\\n        res += dfs(g, x, y - 1, exposed, label);\\n        res += dfs(g, x, y + 1, exposed, label);\\n        return res;\\n    }\\npublic:\\n    int containVirus(vector<vector<int>>& g) {\\n        int m = g.size();\\n        int n = g[0].size();\\n        int label = 2;\\n        int res = 0;\\n        while (1) {\\n            int maxwalls = 0;\\n            int maxexposed = 0;\\n            // The label of the cluster which we will next identify to be having the\\n            // maximum exposed neighbours, i.e. peak spreader\\n            int quarlabel = INT_MIN;\\n            for (int i = 0; i < m; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    if (g[i][j] != 1)\\n                        continue;\\n                    int exposed = 0;\\n                    int w = dfs(g, i, j, exposed, label);\\n                    // Identify cluster with maximum number of exposed neighbours\\n                    if (exposed > maxexposed) {\\n                        maxexposed = exposed;\\n                        // Number of walls needed to seal off this cluster\\n                        maxwalls = w;\\n                        // The cells of this cluster contain this value\\n                        quarlabel = label;\\n                    }\\n                    label++;\\n                }\\n            }\\n            // No more \\'progress\\' can be made\\n            if (maxexposed == 0)\\n                break;\\n            res += maxwalls;\\n            // For each non-isolated cluster, spread the virus to immediate neighbours\\n            for (int i = 0; i < m; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    // If this cell belongs to the cluster which has been identified to be\\n                    // isolated / quarantined\\n                    if (g[i][j] == quarlabel) {\\n                        // Mark this cell as belonging to a cluster isolated by walls\\n                        g[i][j] = INT_MAX;\\n                    } else if (g[i][j] > 1 && g[i][j] != INT_MAX) {\\n                        // Infected cell; infect exposed neighbours\\n                        g[i][j] = 1;\\n                        if (i > 0 && g[i - 1][j] <= 0)\\n                            g[i - 1][j] = 1;\\n                        if (i < m - 1 && g[i + 1][j] <= 0)\\n                            g[i + 1][j] = 1;\\n                        if (j > 0 && g[i][j - 1] <= 0)\\n                            g[i][j - 1] = 1;\\n                        if (j < n - 1 && g[i][j + 1] <= 0)\\n                            g[i][j + 1] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n```\\n```\\n",
                "solutionTags": [],
                "code": "```\\nInspired by: https://leetcode.com/problems/contain-virus/discuss/752571/C%2B%2B-DFS-simulation-(20-ms)\\n\\nclass Solution {\\n    // DFS on a particular cluster, counting boundary walls and exposed neighbours\\n    int dfs(vector<vector<int>>& g, int x, int y, int& exposed, int label) {\\n        if (x < 0 || y < 0 || x == g.size() || y == g[0].size())\\n            return 0;\\n        if (g[x][y] != 1)\\n            return 0;\\n        int res = 0;\\n        // A wall is required between an infected cell and an exposed (i.e. non-infected)\\n        // neighbour\\n        if (x > 0 && g[x - 1][y] <= 0) {\\n            res++;\\n            exposed += (g[x - 1][y] != -label);\\n            // Make sure we don\\'t count this neighbour again\\n            g[x - 1][y] = -label;\\n        }\\n        if (x < g.size() - 1 && g[x + 1][y] <= 0) {\\n            res++;\\n            exposed += (g[x + 1][y] != -label);\\n            g[x + 1][y] = -label;\\n        }\\n        if (y > 0 && g[x][y - 1] <= 0) {\\n            res++;\\n            exposed += (g[x][y - 1] != -label);\\n            g[x][y - 1] = -label;\\n        }\\n        if (y < g[0].size() - 1 && g[x][y + 1] <= 0) {\\n            res++;\\n            exposed += (g[x][y + 1] != -label);\\n            g[x][y + 1] = -label;\\n        }\\n        // Mark each cell in this cluster as having gone through a DFS during\\n        // this particular iteration\\n        g[x][y] = label;\\n        res += dfs(g, x - 1, y, exposed, label);\\n        res += dfs(g, x + 1, y, exposed, label);\\n        res += dfs(g, x, y - 1, exposed, label);\\n        res += dfs(g, x, y + 1, exposed, label);\\n        return res;\\n    }\\npublic:\\n    int containVirus(vector<vector<int>>& g) {\\n        int m = g.size();\\n        int n = g[0].size();\\n        int label = 2;\\n        int res = 0;\\n        while (1) {\\n            int maxwalls = 0;\\n            int maxexposed = 0;\\n            // The label of the cluster which we will next identify to be having the\\n            // maximum exposed neighbours, i.e. peak spreader\\n            int quarlabel = INT_MIN;\\n            for (int i = 0; i < m; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    if (g[i][j] != 1)\\n                        continue;\\n                    int exposed = 0;\\n                    int w = dfs(g, i, j, exposed, label);\\n                    // Identify cluster with maximum number of exposed neighbours\\n                    if (exposed > maxexposed) {\\n                        maxexposed = exposed;\\n                        // Number of walls needed to seal off this cluster\\n                        maxwalls = w;\\n                        // The cells of this cluster contain this value\\n                        quarlabel = label;\\n                    }\\n                    label++;\\n                }\\n            }\\n            // No more \\'progress\\' can be made\\n            if (maxexposed == 0)\\n                break;\\n            res += maxwalls;\\n            // For each non-isolated cluster, spread the virus to immediate neighbours\\n            for (int i = 0; i < m; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    // If this cell belongs to the cluster which has been identified to be\\n                    // isolated / quarantined\\n                    if (g[i][j] == quarlabel) {\\n                        // Mark this cell as belonging to a cluster isolated by walls\\n                        g[i][j] = INT_MAX;\\n                    } else if (g[i][j] > 1 && g[i][j] != INT_MAX) {\\n                        // Infected cell; infect exposed neighbours\\n                        g[i][j] = 1;\\n                        if (i > 0 && g[i - 1][j] <= 0)\\n                            g[i - 1][j] = 1;\\n                        if (i < m - 1 && g[i + 1][j] <= 0)\\n                            g[i + 1][j] = 1;\\n                        if (j > 0 && g[i][j - 1] <= 0)\\n                            g[i][j - 1] = 1;\\n                        if (j < n - 1 && g[i][j + 1] <= 0)\\n                            g[i][j + 1] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1988629,
                "title": "c-bfs-easy-understanding-with-debug-message-and-comment",
                "content": "```\\nclass Solution {\\npublic:\\n    int containVirus(vector<vector<int>>& isInfected) {\\n        if (!isInfected[0].size()) return 0;\\n        //initialize\\n        vector<vector<bool>> isVisited; // mark if the infected cell is visited.\\n        vector<vector<int>> tobeInfected; // use int rather than bool, because one cell can be infected by multiple groups, use int to avoid error when we remove the quarantined group\\'s to-br infected.\\n        vector<vector<bool>> isQuarantined;// mark if the infected cell is quarantined.\\n        for (int j = 0; j < isInfected.size(); j++) {\\n            vector<bool> tmp;\\n            vector<int> tmpi;\\n            for (int i = 0; i < isInfected[j].size(); i++) {\\n                tmp.push_back(false);\\n                tmpi.push_back(0);\\n            }\\n            isVisited.push_back(tmp);\\n            tobeInfected.push_back(tmpi);\\n            isQuarantined.push_back(tmp);\\n        }\\n        int ans = 0;\\n        bool virus_spreading = true;\\n        int day = 0;\\n        while (virus_spreading) {\\n            // iterate whole matrix to calculate which group to be quarantined, and the walls it need.\\n            day++;\\n            cout<<\"Day \"<<day<<\": \"<<endl;\\n            vector<vector<int>> lg;  // store the largest infected group \\n            int nl = 0;     // the number of cells that lg will infect if not quarantined. \\n            int wl = 0;     // the number of walls to quarantin lg.\\n            for (int j = 0; j < isInfected.size(); j++) {\\n                for (int i = 0; i < isInfected[j].size(); i++) {\\n                    //cout<<\"Iterate \"<<j<<\" \"<<i<<\": \"<<endl;\\n                    if (isInfected[j][i] && !isVisited[j][i] && !isQuarantined[j][i]) {\\n                        // use BFS to iterate one infected group, \\n                        //and calculate its walls number and to-be infected cells number\\n                        vector<vector<int>> cg;  // store the current infected group \\n                        int nc = 0;     // the number of cells that cg will infect if not quarantined. \\n                        int wc = 0;     // the number of walls to quarantin cg.\\n                        queue<vector<int>> q;\\n                        q.push({j,i});\\n                        cg.push_back({j,i});\\n                        isVisited[j][i] = true;\\n                        while (q.size()) {\\n                            int s = q.size();\\n                            while (s--) {\\n                                int y = q.front()[0];\\n                                int x = q.front()[1];\\n                                cout<<\"Expand Infected Cell: {\"<<y<<\",\"<<x<<\"} \";\\n                                cout<<\"To be infected: \";\\n                                wc += 4;\\n                                if (x == 0 || x == isInfected[0].size() -1) {\\n                                    wc--;\\n                                }\\n                                if (y == 0 || y == isInfected.size() - 1) {\\n                                    wc--;\\n                                }\\n                                if (x < isInfected[0].size() -1) {\\n                                    if (isInfected[y][x+1]) {\\n                                        wc--;\\n                                        if (!isVisited[y][x+1] && !isQuarantined[y][x+1]) {\\n                                            q.push({y, x+1});\\n                                            cg.push_back({y, x+1});\\n                                            isVisited[y][x+1] = true;\\n                                        }\\n                                    } else {\\n                                        tobeInfected[y][x+1]++;\\n                                        if (!isVisited[y][x+1]) {\\n                                            isVisited[y][x+1] = true;\\n                                            nc++;\\n                                        }\\n                                        cout<<\"{\"<<y<<\",\"<<x+1<<\"} \";\\n                                    }\\n                                }\\n                                if (x) {\\n                                    if (isInfected[y][x-1]) {\\n                                        wc--;\\n                                        if (!isVisited[y][x-1] && !isQuarantined[y][x-1]) {\\n                                            q.push({y, x-1});\\n                                            cg.push_back({y, x-1});\\n                                            isVisited[y][x-1] = true;\\n                                        }\\n                                    } else {\\n                                        tobeInfected[y][x-1]++;\\n                                        if (!isVisited[y][x-1]) {\\n                                            isVisited[y][x-1] = true;\\n                                            nc++;\\n                                        }\\n                                        cout<<\"{\"<<y<<\",\"<<x-1<<\"} \";\\n                                        \\n                                    }\\n                                }                            \\n                                if (y < isInfected.size() - 1) {\\n                                    if (isInfected[y+1][x]) {\\n                                        wc--;\\n                                        if (!isVisited[y+1][x] && !isQuarantined[y+1][x]) {\\n                                            q.push({y+1, x});\\n                                            cg.push_back({y+1, x});\\n                                            isVisited[y+1][x] = true;\\n                                        } \\n                                    } else {\\n                                        tobeInfected[y+1][x]++;\\n                                        if (!isVisited[y+1][x]) {\\n                                            isVisited[y+1][x] = true;\\n                                            nc++;\\n                                        }\\n                                        cout<<\"{\"<<y+1<<\",\"<<x<<\"} \";\\n                                    }\\n                                }\\n                                if (y) {\\n                                    if (isInfected[y-1][x]) {\\n                                        wc--;\\n                                        if (!isVisited[y-1][x] && !isQuarantined[y-1][x]) {\\n                                            q.push({y-1, x});\\n                                            cg.push_back({y-1, x});\\n                                            isVisited[y-1][x] = true;\\n                                        }\\n                                    } else {\\n                                        tobeInfected[y-1][x]++;\\n                                        if (!isVisited[y-1][x]) {\\n                                            isVisited[y-1][x] = true;\\n                                            nc++;\\n                                        }\\n                                        cout<<\"{\"<<y-1<<\",\"<<x<<\"} \";\\n                                    } \\n                                }        \\n                                cout<<\"nc: \"<<nc<<\" wc: \"<<wc<<endl;\\n                                q.pop();\\n                            }\\n                        }  \\n                        //restore to be infected visited info\\n                        for (int i = 0; i < cg.size(); i++) {\\n                            int y = cg[i][0];\\n                            int x = cg[i][1];\\n                            if ((x < isInfected[0].size() -1) && !isInfected[y][x+1]) {\\n                                isVisited[y][x+1] = false;\\n                            }\\n                            if (x && !isInfected[y][x-1]) {\\n                                isVisited[y][x-1] = false;\\n                            }\\n                            if ((y < isInfected.size() - 1) && !isInfected[y+1][x]) {\\n                                isVisited[y+1][x] = false;\\n                            }\\n                            if (y && !isInfected[y-1][x]) {\\n                                isVisited[y-1][x] = false;\\n                            }           \\n                        }\\n                        // update tonight quarantine plan\\n                        if (nc > nl) {\\n                            nl = nc;\\n                            wl = wc;\\n                            if (lg.size()) lg.clear();\\n                            lg.assign(cg.begin(), cg.end());\\n                        }\\n                    } \\n                }\\n            }\\n            cout<<\"need wall: \"<<wl<<endl;\\n            // remove the quarantine group\\'s to-be infected. update quarantine matrix\\n            ans += wl;\\n            cout<<\"Quarantine Cell: \";\\n            for (int i = 0; i < lg.size(); i++) {\\n                int y = lg[i][0];\\n                int x = lg[i][1];\\n                cout<<\"{\"<<y<<\",\"<<x<<\"}\";\\n                isQuarantined[y][x] = true;\\n                if ((x < isInfected[0].size() -1) && !isInfected[y][x+1]) {\\n                    tobeInfected[y][x+1]--;\\n                }\\n                if (x && !isInfected[y][x-1]) {\\n                    tobeInfected[y][x-1]--;\\n                }\\n                if ((y < isInfected.size() - 1) && !isInfected[y+1][x]) {\\n                    tobeInfected[y+1][x]--;\\n                }\\n                if (y && !isInfected[y-1][x]) {\\n                    tobeInfected[y-1][x]--;\\n                }           \\n            }\\n            cout<<endl;\\n            cout<<\"To be infected cell:\";\\n            //update isInfected[][] and reset isVisited[][]\\n            bool no_infect = true;\\n            bool all_infected = true;                    \\n            for (int j = 0; j < isInfected.size(); j++) {\\n                for (int i = 0; i < isInfected[j].size(); i++) {\\n                    isVisited[j][i] = false;\\n                    if (tobeInfected[j][i]) {\\n                        cout<<\"{\"<<j<<\",\"<<i<<\"}\";\\n                        no_infect = false;\\n                        isInfected[j][i] = 1;\\n                    } else if (!isInfected[j][i]) {\\n                        all_infected = false;\\n                    }   \\n                    tobeInfected[j][i] = false;\\n                }   \\n            }\\n            cout<<endl;\\n            if (no_infect || all_infected) {\\n                virus_spreading = false;\\n            }\\n        }\\n        return ans;   \\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int containVirus(vector<vector<int>>& isInfected) {\\n        if (!isInfected[0].size()) return 0;\\n        //initialize\\n        vector<vector<bool>> isVisited; // mark if the infected cell is visited.\\n        vector<vector<int>> tobeInfected; // use int rather than bool, because one cell can be infected by multiple groups, use int to avoid error when we remove the quarantined group\\'s to-br infected.\\n        vector<vector<bool>> isQuarantined;// mark if the infected cell is quarantined.\\n        for (int j = 0; j < isInfected.size(); j++) {\\n            vector<bool> tmp;\\n            vector<int> tmpi;\\n            for (int i = 0; i < isInfected[j].size(); i++) {\\n                tmp.push_back(false);\\n                tmpi.push_back(0);\\n            }\\n            isVisited.push_back(tmp);\\n            tobeInfected.push_back(tmpi);\\n            isQuarantined.push_back(tmp);\\n        }\\n        int ans = 0;\\n        bool virus_spreading = true;\\n        int day = 0;\\n        while (virus_spreading) {\\n            // iterate whole matrix to calculate which group to be quarantined, and the walls it need.\\n            day++;\\n            cout<<\"Day \"<<day<<\": \"<<endl;\\n            vector<vector<int>> lg;  // store the largest infected group \\n            int nl = 0;     // the number of cells that lg will infect if not quarantined. \\n            int wl = 0;     // the number of walls to quarantin lg.\\n            for (int j = 0; j < isInfected.size(); j++) {\\n                for (int i = 0; i < isInfected[j].size(); i++) {\\n                    //cout<<\"Iterate \"<<j<<\" \"<<i<<\": \"<<endl;\\n                    if (isInfected[j][i] && !isVisited[j][i] && !isQuarantined[j][i]) {\\n                        // use BFS to iterate one infected group, \\n                        //and calculate its walls number and to-be infected cells number\\n                        vector<vector<int>> cg;  // store the current infected group \\n                        int nc = 0;     // the number of cells that cg will infect if not quarantined. \\n                        int wc = 0;     // the number of walls to quarantin cg.\\n                        queue<vector<int>> q;\\n                        q.push({j,i});\\n                        cg.push_back({j,i});\\n                        isVisited[j][i] = true;\\n                        while (q.size()) {\\n                            int s = q.size();\\n                            while (s--) {\\n                                int y = q.front()[0];\\n                                int x = q.front()[1];\\n                                cout<<\"Expand Infected Cell: {\"<<y<<\",\"<<x<<\"} \";\\n                                cout<<\"To be infected: \";\\n                                wc += 4;\\n                                if (x == 0 || x == isInfected[0].size() -1) {\\n                                    wc--;\\n                                }\\n                                if (y == 0 || y == isInfected.size() - 1) {\\n                                    wc--;\\n                                }\\n                                if (x < isInfected[0].size() -1) {\\n                                    if (isInfected[y][x+1]) {\\n                                        wc--;\\n                                        if (!isVisited[y][x+1] && !isQuarantined[y][x+1]) {\\n                                            q.push({y, x+1});\\n                                            cg.push_back({y, x+1});\\n                                            isVisited[y][x+1] = true;\\n                                        }\\n                                    } else {\\n                                        tobeInfected[y][x+1]++;\\n                                        if (!isVisited[y][x+1]) {\\n                                            isVisited[y][x+1] = true;\\n                                            nc++;\\n                                        }\\n                                        cout<<\"{\"<<y<<\",\"<<x+1<<\"} \";\\n                                    }\\n                                }\\n                                if (x) {\\n                                    if (isInfected[y][x-1]) {\\n                                        wc--;\\n                                        if (!isVisited[y][x-1] && !isQuarantined[y][x-1]) {\\n                                            q.push({y, x-1});\\n                                            cg.push_back({y, x-1});\\n                                            isVisited[y][x-1] = true;\\n                                        }\\n                                    } else {\\n                                        tobeInfected[y][x-1]++;\\n                                        if (!isVisited[y][x-1]) {\\n                                            isVisited[y][x-1] = true;\\n                                            nc++;\\n                                        }\\n                                        cout<<\"{\"<<y<<\",\"<<x-1<<\"} \";\\n                                        \\n                                    }\\n                                }                            \\n                                if (y < isInfected.size() - 1) {\\n                                    if (isInfected[y+1][x]) {\\n                                        wc--;\\n                                        if (!isVisited[y+1][x] && !isQuarantined[y+1][x]) {\\n                                            q.push({y+1, x});\\n                                            cg.push_back({y+1, x});\\n                                            isVisited[y+1][x] = true;\\n                                        } \\n                                    } else {\\n                                        tobeInfected[y+1][x]++;\\n                                        if (!isVisited[y+1][x]) {\\n                                            isVisited[y+1][x] = true;\\n                                            nc++;\\n                                        }\\n                                        cout<<\"{\"<<y+1<<\",\"<<x<<\"} \";\\n                                    }\\n                                }\\n                                if (y) {\\n                                    if (isInfected[y-1][x]) {\\n                                        wc--;\\n                                        if (!isVisited[y-1][x] && !isQuarantined[y-1][x]) {\\n                                            q.push({y-1, x});\\n                                            cg.push_back({y-1, x});\\n                                            isVisited[y-1][x] = true;\\n                                        }\\n                                    } else {\\n                                        tobeInfected[y-1][x]++;\\n                                        if (!isVisited[y-1][x]) {\\n                                            isVisited[y-1][x] = true;\\n                                            nc++;\\n                                        }\\n                                        cout<<\"{\"<<y-1<<\",\"<<x<<\"} \";\\n                                    } \\n                                }        \\n                                cout<<\"nc: \"<<nc<<\" wc: \"<<wc<<endl;\\n                                q.pop();\\n                            }\\n                        }  \\n                        //restore to be infected visited info\\n                        for (int i = 0; i < cg.size(); i++) {\\n                            int y = cg[i][0];\\n                            int x = cg[i][1];\\n                            if ((x < isInfected[0].size() -1) && !isInfected[y][x+1]) {\\n                                isVisited[y][x+1] = false;\\n                            }\\n                            if (x && !isInfected[y][x-1]) {\\n                                isVisited[y][x-1] = false;\\n                            }\\n                            if ((y < isInfected.size() - 1) && !isInfected[y+1][x]) {\\n                                isVisited[y+1][x] = false;\\n                            }\\n                            if (y && !isInfected[y-1][x]) {\\n                                isVisited[y-1][x] = false;\\n                            }           \\n                        }\\n                        // update tonight quarantine plan\\n                        if (nc > nl) {\\n                            nl = nc;\\n                            wl = wc;\\n                            if (lg.size()) lg.clear();\\n                            lg.assign(cg.begin(), cg.end());\\n                        }\\n                    } \\n                }\\n            }\\n            cout<<\"need wall: \"<<wl<<endl;\\n            // remove the quarantine group\\'s to-be infected. update quarantine matrix\\n            ans += wl;\\n            cout<<\"Quarantine Cell: \";\\n            for (int i = 0; i < lg.size(); i++) {\\n                int y = lg[i][0];\\n                int x = lg[i][1];\\n                cout<<\"{\"<<y<<\",\"<<x<<\"}\";\\n                isQuarantined[y][x] = true;\\n                if ((x < isInfected[0].size() -1) && !isInfected[y][x+1]) {\\n                    tobeInfected[y][x+1]--;\\n                }\\n                if (x && !isInfected[y][x-1]) {\\n                    tobeInfected[y][x-1]--;\\n                }\\n                if ((y < isInfected.size() - 1) && !isInfected[y+1][x]) {\\n                    tobeInfected[y+1][x]--;\\n                }\\n                if (y && !isInfected[y-1][x]) {\\n                    tobeInfected[y-1][x]--;\\n                }           \\n            }\\n            cout<<endl;\\n            cout<<\"To be infected cell:\";\\n            //update isInfected[][] and reset isVisited[][]\\n            bool no_infect = true;\\n            bool all_infected = true;                    \\n            for (int j = 0; j < isInfected.size(); j++) {\\n                for (int i = 0; i < isInfected[j].size(); i++) {\\n                    isVisited[j][i] = false;\\n                    if (tobeInfected[j][i]) {\\n                        cout<<\"{\"<<j<<\",\"<<i<<\"}\";\\n                        no_infect = false;\\n                        isInfected[j][i] = 1;\\n                    } else if (!isInfected[j][i]) {\\n                        all_infected = false;\\n                    }   \\n                    tobeInfected[j][i] = false;\\n                }   \\n            }\\n            cout<<endl;\\n            if (no_infect || all_infected) {\\n                virus_spreading = false;\\n            }\\n        }\\n        return ans;   \\n    }\\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1937779,
                "title": "javascript-recursive-dfs",
                "content": "```\\nvar containVirus = function(isInfected) {\\n    const directions = [[1, 0], [-1, 0], [0, 1], [0, -1]];\\n    let walls = 0;\\n\\n    function findContaminated() {\\n        let visited = {}, infected = [];\\n        let mostViral;\\n        for (let i = 0; i < isInfected.length; i++) {\\n            for (let j = 0; j < isInfected[i].length; j++) {\\n                if (isInfected[i][j] === 1) {\\n                    let key = `${i}-${j}`;\\n                    if (key in visited) continue;\\n                    else infected.push([i, j]);\\n                    \\n                    let zeroes = new Set();\\n                    let perimeter = findPerimeter(i, j, visited, zeroes);\\n\\n                    // Find the largest potential infection perimeter based on the number of 0\\'s neighboring infected cells\\n                    if (!mostViral) mostViral = {i, j, perimeter, zeroes: zeroes.size};\\n                    else if (zeroes.size > mostViral.zeroes) mostViral = {i, j, perimeter, zeroes: zeroes.size};\\n                }\\n            }\\n        }\\n        if (mostViral) {\\n            walls += mostViral.perimeter;\\n\\n            // Quarantine the most viral area\\n            quarantine(mostViral.i, mostViral.j);\\n\\n            // Spread the infection throughout the remaining infected areas\\n            let alreadyInfected = {};\\n            for (let [row, col] of infected) {\\n                if (mostViral.i === row && mostViral.j === col) continue;\\n                else infect(row, col, alreadyInfected);\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    \\n    while (findContaminated()) continue;\\n    return walls;\\n\\n    \\n    function findPerimeter(row, col, visited, zeroes) {\\n        if (row < 0 || col < 0 || row >= isInfected.length || col >= isInfected[0].length) return 0;\\n        let key = `${row}-${col}`;\\n\\n        // If the current cell is visited or quarantined, leave the perimeter unchanged\\n        if (visited[key] || isInfected[row][col] === -1) return 0;\\n        \\n        // If the current cell is not infected and not quarantined, increase the perimeter\\n        if (isInfected[row][col] === 0) {\\n            zeroes.add(key);\\n            return 1;\\n        }\\n        \\n        visited[key] = true;\\n        let perimeter = 0;\\n        for (let [r, c] of directions) {\\n            perimeter += findPerimeter(row + r, col + c, visited, zeroes);\\n        }\\n        return perimeter;\\n    }\\n\\n    function quarantine(row, col) {\\n        if (row < 0 || col < 0 || row >= isInfected.length || col >= isInfected[0].length) return;\\n\\n        // Only quarantine infected cells and neighboring infected cells\\n        if (isInfected[row][col] === 1) isInfected[row][col] = -1;\\n        else return;\\n\\n        for (let [r, c] of directions) quarantine(row + r, col + c);\\n    }\\n    \\n    function infect(row, col, alreadyInfected, neighbor = 0) {\\n        if (row < 0 || col < 0 || row >= isInfected.length || col >= isInfected[0].length) return;\\n        let key = `${row}-${col}`;\\n        \\n        // If the current cell is already infected or quarantined\\n        if (alreadyInfected[key] || isInfected[row][col] === -1) return;\\n\\n        // If the current cell is clear but neighbors an infected cell, infect it\\n        if (isInfected[row][col] === 0 && neighbor === 1) {\\n            alreadyInfected[key] = true;\\n            return isInfected[row][col] = 1;\\n        }\\n        else if (isInfected[row][col] === 1 && neighbor === 1) {\\n            alreadyInfected[key] = true;\\n            neighbor = 0;\\n        }\\n\\n        for (let [r, c] of directions) infect(row + r, col + c, alreadyInfected, neighbor + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar containVirus = function(isInfected) {\\n    const directions = [[1, 0], [-1, 0], [0, 1], [0, -1]];\\n    let walls = 0;\\n\\n    function findContaminated() {\\n        let visited = {}, infected = [];\\n        let mostViral;\\n        for (let i = 0; i < isInfected.length; i++) {\\n            for (let j = 0; j < isInfected[i].length; j++) {\\n                if (isInfected[i][j] === 1) {\\n                    let key = `${i}-${j}`;\\n                    if (key in visited) continue;\\n                    else infected.push([i, j]);\\n                    \\n                    let zeroes = new Set();\\n                    let perimeter = findPerimeter(i, j, visited, zeroes);\\n\\n                    // Find the largest potential infection perimeter based on the number of 0\\'s neighboring infected cells\\n                    if (!mostViral) mostViral = {i, j, perimeter, zeroes: zeroes.size};\\n                    else if (zeroes.size > mostViral.zeroes) mostViral = {i, j, perimeter, zeroes: zeroes.size};\\n                }\\n            }\\n        }\\n        if (mostViral) {\\n            walls += mostViral.perimeter;\\n\\n            // Quarantine the most viral area\\n            quarantine(mostViral.i, mostViral.j);\\n\\n            // Spread the infection throughout the remaining infected areas\\n            let alreadyInfected = {};\\n            for (let [row, col] of infected) {\\n                if (mostViral.i === row && mostViral.j === col) continue;\\n                else infect(row, col, alreadyInfected);\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    \\n    while (findContaminated()) continue;\\n    return walls;\\n\\n    \\n    function findPerimeter(row, col, visited, zeroes) {\\n        if (row < 0 || col < 0 || row >= isInfected.length || col >= isInfected[0].length) return 0;\\n        let key = `${row}-${col}`;\\n\\n        // If the current cell is visited or quarantined, leave the perimeter unchanged\\n        if (visited[key] || isInfected[row][col] === -1) return 0;\\n        \\n        // If the current cell is not infected and not quarantined, increase the perimeter\\n        if (isInfected[row][col] === 0) {\\n            zeroes.add(key);\\n            return 1;\\n        }\\n        \\n        visited[key] = true;\\n        let perimeter = 0;\\n        for (let [r, c] of directions) {\\n            perimeter += findPerimeter(row + r, col + c, visited, zeroes);\\n        }\\n        return perimeter;\\n    }\\n\\n    function quarantine(row, col) {\\n        if (row < 0 || col < 0 || row >= isInfected.length || col >= isInfected[0].length) return;\\n\\n        // Only quarantine infected cells and neighboring infected cells\\n        if (isInfected[row][col] === 1) isInfected[row][col] = -1;\\n        else return;\\n\\n        for (let [r, c] of directions) quarantine(row + r, col + c);\\n    }\\n    \\n    function infect(row, col, alreadyInfected, neighbor = 0) {\\n        if (row < 0 || col < 0 || row >= isInfected.length || col >= isInfected[0].length) return;\\n        let key = `${row}-${col}`;\\n        \\n        // If the current cell is already infected or quarantined\\n        if (alreadyInfected[key] || isInfected[row][col] === -1) return;\\n\\n        // If the current cell is clear but neighbors an infected cell, infect it\\n        if (isInfected[row][col] === 0 && neighbor === 1) {\\n            alreadyInfected[key] = true;\\n            return isInfected[row][col] = 1;\\n        }\\n        else if (isInfected[row][col] === 1 && neighbor === 1) {\\n            alreadyInfected[key] = true;\\n            neighbor = 0;\\n        }\\n\\n        for (let [r, c] of directions) infect(row + r, col + c, alreadyInfected, neighbor + 1);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1935321,
                "title": "contain-virus-solution-java",
                "content": "class Region {\\n  // given m = # of rows and n = # of cols, (x, y) will be hashed as x * n + y\\n  public Set<Integer> infected = new HashSet<>();\\n  public Set<Integer> noninfected = new HashSet<>(); // noninfected neighbors\\n  public int wallsRequired = 0;\\n};\\n\\nclass Solution {\\n  public int containVirus(int[][] grid) {\\n    final int m = grid.length;\\n    final int n = grid[0].length;\\n    int ans = 0;\\n\\n    while (true) {\\n      List<Region> regions = new ArrayList<>();\\n      boolean[][] seen = new boolean[m][n];\\n\\n      for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j)\\n          if (grid[i][j] == 1 && !seen[i][j]) {\\n            Region region = new Region();\\n            dfs(grid, i, j, region, seen); // use DFS to find all regions (1s)\\n            if (!region.noninfected.isEmpty())\\n              regions.add(region);\\n          }\\n\\n      if (regions.isEmpty())\\n        break; // no region causes further infection\\n\\n      // region which infects most neighbors is in the back\\n      Collections.sort(regions, (a, b) -> a.noninfected.size() - b.noninfected.size());\\n\\n      // build walls around the region which infects most neighbors\\n      Region mostInfectedRegion = regions.get(regions.size() - 1);\\n      regions.remove(regions.size() - 1);\\n      ans += mostInfectedRegion.wallsRequired;\\n\\n      for (final int neighbor : mostInfectedRegion.infected) {\\n        final int i = neighbor / n;\\n        final int j = neighbor % n;\\n        // the grid is now contained and won\\'t be infected anymore\\n        grid[i][j] = 2;\\n      }\\n\\n      // for remaining regions, expand (infect their neighbors)\\n      for (final Region region : regions)\\n        for (final int neighbor : region.noninfected) {\\n          final int i = neighbor / n;\\n          final int j = neighbor % n;\\n          grid[i][j] = 1;\\n        }\\n    }\\n\\n    return ans;\\n  }\\n\\n  private void dfs(int[][] grid, int i, int j, Region region, boolean[][] seen) {\\n    if (i < 0 || i == grid.length || j < 0 || j == grid[0].length)\\n      return;\\n    if (seen[i][j] || grid[i][j] == 2)\\n      return;\\n    if (grid[i][j] == 0) {\\n      region.noninfected.add(i * grid[0].length + j);\\n      ++region.wallsRequired;\\n      return;\\n    }\\n\\n    // grid[i][j] == 1\\n    seen[i][j] = true;\\n    region.infected.add(i * grid[0].length + j);\\n\\n    dfs(grid, i + 1, j, region, seen);\\n    dfs(grid, i - 1, j, region, seen);\\n    dfs(grid, i, j + 1, region, seen);\\n    dfs(grid, i, j - 1, region, seen);\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Matrix",
                    "Simulation"
                ],
                "code": "class Solution {\\n  public int containVirus(int[][] grid) {\\n    final int m = grid.length;\\n    final int n = grid[0].length;\\n    int ans = 0;\\n\\n    while (true) {\\n      List<Region> regions = new ArrayList<>();\\n      boolean[][] seen = new boolean[m][n];\\n\\n      for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j)\\n          if (grid[i][j] == 1 && !seen[i][j]) {\\n            Region region = new Region();\\n            dfs(grid, i, j, region, seen); // use DFS to find all regions (1s)\\n            if (!region.noninfected.isEmpty())\\n              regions.add(region);\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 1753807,
                "title": "c-bfs-solution-simulation",
                "content": "```\\n\\tclass InfectedArea {\\n        public int Id {get; private set; }\\n        public HashSet<(int row, int col)> InfectedCells {get; private set;}\\n        public HashSet<(int row, int col)> CanInfectCells {get; private set;}\\n        public int RequiredWallsToIsolate {get; private set;}\\n        \\n        public InfectedArea(int id, \\n                            HashSet<(int row, int col)> infectedCells, \\n                            HashSet<(int row, int col)> canInfectCells, \\n                            int requiredWallsToIsolate) {\\n            Id = id;\\n            InfectedCells = infectedCells;\\n            CanInfectCells = canInfectCells;\\n            RequiredWallsToIsolate = requiredWallsToIsolate;\\n        }\\n        \\n        public override string ToString() \\n            => $\"Id = {Id}, InfectedCells: {string.Join(\\',\\', InfectedCells)}, CanInfectCells: {string.Join(\\',\\', CanInfectCells)}, RequiredWallsToIsolate = {RequiredWallsToIsolate}\";\\n    }\\n    \\n    private readonly (int row, int col)[] Moves = new []{(1,0), (-1,0), (0,1), (0,-1)};    \\n\\n    public int ContainVirus(int[][] isInfected) {\\n        var rowCount = isInfected.Length;\\n        var colCount = isInfected[0].Length;\\n        var wallsCount = 0;\\n        while(true) {\\n            int areaId = 0;\\n            var areas = new List<InfectedArea>();\\n            var visited = new bool[rowCount][];\\n            for (int i=0; i<rowCount; i++)\\n                visited[i] = new bool[colCount];\\n        \\n            for (int row=0; row<rowCount; row++) \\n                for (int col=0; col<colCount; col++) \\n                    if (isInfected[row][col] == 1 && !visited[row][col]) \\n                        areas.Add(GetArea(++areaId, (row, col), isInfected, visited)); // add infected area\\n            \\n            if (areas.Count == 0)  \\n                return wallsCount;\\n            \\n            // isolate most dangerous area\\n            var maxInfectedCellsCount = areas.Max(a => a.CanInfectCells.Count);\\n            var mostDangerousArea = areas.First(a => a.CanInfectCells.Count == maxInfectedCellsCount);\\n            foreach (var cell in mostDangerousArea.InfectedCells) {\\n                isInfected[cell.row][cell.col] = 2; // isolated\\n            }\\n            wallsCount += mostDangerousArea.RequiredWallsToIsolate;\\n\\n            // spread virus\\n            foreach (var area in areas.Where(a => a.Id != mostDangerousArea.Id)) {\\n                foreach (var cell in area.CanInfectCells) {\\n                    isInfected[cell.row][cell.col] = 1;    \\n                }\\n            }\\n        }\\n    }\\n    \\n     private InfectedArea GetArea(int areaId, (int row, int col) start, int[][] isInfected, bool[][] visited) {\\n        var wallsCount = 0;\\n        var canInfectCells = new HashSet<(int row, int col)>();\\n        var infectedCells = new HashSet<(int row, int col)>();\\n        var queue = new Queue<(int row, int col)>();\\n        queue.Enqueue(start);\\n        visited[start.row][start.col] = true;\\n        infectedCells.Add(start);\\n        while (queue.Count > 0) {\\n            var count = queue.Count;\\n            for (int k=0; k<count; k++) {\\n                (int row, int col) pos = queue.Dequeue();\\n                if (isInfected[pos.row][pos.col] == 2) // isolated\\n                    continue;\\n                if (isInfected[pos.row][pos.col] == 0) { // nonInfected \\n                    canInfectCells.Add(pos);\\n                    wallsCount++;\\n                    continue;\\n                }\\n                foreach (var move in Moves) {\\n                    (int row, int col) newPos = (pos.row+move.row, pos.col+move.col);\\n                    if (!IsOutOfGrid(isInfected, newPos.row, newPos.col) && !visited[newPos.row][newPos.col]) {\\n                        if (isInfected[newPos.row][newPos.col] == 1) {\\n                            visited[newPos.row][newPos.col] = true;\\n                            infectedCells.Add(newPos);\\n                        }\\n                        queue.Enqueue(newPos);\\n                    }\\n                }\\n            }    \\n        }\\n        return new InfectedArea(areaId, infectedCells, canInfectCells, wallsCount);\\n    }\\n    \\n    private bool IsOutOfGrid(int[][] grid, int row, int col) \\n        => row < 0 || row >= grid.Length || col < 0 || col >= grid[0].Length;\\n\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n\\tclass InfectedArea {\\n        public int Id {get; private set; }\\n        public HashSet<(int row, int col)> InfectedCells {get; private set;}\\n        public HashSet<(int row, int col)> CanInfectCells {get; private set;}\\n        public int RequiredWallsToIsolate {get; private set;}\\n        \\n        public InfectedArea(int id, \\n                            HashSet<(int row, int col)> infectedCells, \\n                            HashSet<(int row, int col)> canInfectCells, \\n                            int requiredWallsToIsolate) {\\n            Id = id;\\n            InfectedCells = infectedCells;\\n            CanInfectCells = canInfectCells;\\n            RequiredWallsToIsolate = requiredWallsToIsolate;\\n        }\\n        \\n        public override string ToString() \\n            => $\"Id = {Id}, InfectedCells: {string.Join(\\',\\', InfectedCells)}, CanInfectCells: {string.Join(\\',\\', CanInfectCells)}, RequiredWallsToIsolate = {RequiredWallsToIsolate}\";\\n    }\\n    \\n    private readonly (int row, int col)[] Moves = new []{(1,0), (-1,0), (0,1), (0,-1)};    \\n\\n    public int ContainVirus(int[][] isInfected) {\\n        var rowCount = isInfected.Length;\\n        var colCount = isInfected[0].Length;\\n        var wallsCount = 0;\\n        while(true) {\\n            int areaId = 0;\\n            var areas = new List<InfectedArea>();\\n            var visited = new bool[rowCount][];\\n            for (int i=0; i<rowCount; i++)\\n                visited[i] = new bool[colCount];\\n        \\n            for (int row=0; row<rowCount; row++) \\n                for (int col=0; col<colCount; col++) \\n                    if (isInfected[row][col] == 1 && !visited[row][col]) \\n                        areas.Add(GetArea(++areaId, (row, col), isInfected, visited)); // add infected area\\n            \\n            if (areas.Count == 0)  \\n                return wallsCount;\\n            \\n            // isolate most dangerous area\\n            var maxInfectedCellsCount = areas.Max(a => a.CanInfectCells.Count);\\n            var mostDangerousArea = areas.First(a => a.CanInfectCells.Count == maxInfectedCellsCount);\\n            foreach (var cell in mostDangerousArea.InfectedCells) {\\n                isInfected[cell.row][cell.col] = 2; // isolated\\n            }\\n            wallsCount += mostDangerousArea.RequiredWallsToIsolate;\\n\\n            // spread virus\\n            foreach (var area in areas.Where(a => a.Id != mostDangerousArea.Id)) {\\n                foreach (var cell in area.CanInfectCells) {\\n                    isInfected[cell.row][cell.col] = 1;    \\n                }\\n            }\\n        }\\n    }\\n    \\n     private InfectedArea GetArea(int areaId, (int row, int col) start, int[][] isInfected, bool[][] visited) {\\n        var wallsCount = 0;\\n        var canInfectCells = new HashSet<(int row, int col)>();\\n        var infectedCells = new HashSet<(int row, int col)>();\\n        var queue = new Queue<(int row, int col)>();\\n        queue.Enqueue(start);\\n        visited[start.row][start.col] = true;\\n        infectedCells.Add(start);\\n        while (queue.Count > 0) {\\n            var count = queue.Count;\\n            for (int k=0; k<count; k++) {\\n                (int row, int col) pos = queue.Dequeue();\\n                if (isInfected[pos.row][pos.col] == 2) // isolated\\n                    continue;\\n                if (isInfected[pos.row][pos.col] == 0) { // nonInfected \\n                    canInfectCells.Add(pos);\\n                    wallsCount++;\\n                    continue;\\n                }\\n                foreach (var move in Moves) {\\n                    (int row, int col) newPos = (pos.row+move.row, pos.col+move.col);\\n                    if (!IsOutOfGrid(isInfected, newPos.row, newPos.col) && !visited[newPos.row][newPos.col]) {\\n                        if (isInfected[newPos.row][newPos.col] == 1) {\\n                            visited[newPos.row][newPos.col] = true;\\n                            infectedCells.Add(newPos);\\n                        }\\n                        queue.Enqueue(newPos);\\n                    }\\n                }\\n            }    \\n        }\\n        return new InfectedArea(areaId, infectedCells, canInfectCells, wallsCount);\\n    }\\n    \\n    private bool IsOutOfGrid(int[][] grid, int row, int col) \\n        => row < 0 || row >= grid.Length || col < 0 || col >= grid[0].Length;\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1651299,
                "title": "dfs-simulation",
                "content": "Idea is straightforward - but there is a good bit of code.\\na. Find all connected affected regions.\\nb. Check which one affects the most \"unaffected\" cells.\\nc. Wall the region from \"b.\" above, while all other regions expand their borders in 4 directions,\\nd. Repeat \"a.\" until there are no new affected regions to consider.\\n```\\n//O((m*n)^2) Time and O(m*n) Space\\npublic int ContainVirus(int[][] isInfected) {\\n\\tint m = isInfected.Length, n = isInfected[0].Length, result = 0;\\n\\tvar dirs = new (int rInc, int cInc)[]{(1,0), (-1,0), (0,1),(0,-1)};\\n\\twhile(true){\\n\\t\\tvar seen = new bool[m,n]; //Prevent revisiting cells\\n\\t\\tvar currInfected = new List<List<int[]>>(); //Tracks infected regions\\n\\t\\tbool keepGoing = false;\\n\\n\\t\\tfor(int r=0;r<m;r++){\\n\\t\\t\\tfor(int c = 0;c<n;c++){\\n\\t\\t\\t\\tif(isInfected[r][c]==1 && !seen[r,c]){\\n\\t\\t\\t\\t\\tseen[r,c] = true;\\n\\t\\t\\t\\t\\tkeepGoing = true;\\n\\t\\t\\t\\t\\tvar curr = new List<int[]>();\\n\\t\\t\\t\\t\\tDFS(r,c,curr,m,n,seen,isInfected,dirs);\\n\\t\\t\\t\\t\\tcurrInfected.Add(curr);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(!keepGoing) break;\\n\\n\\t\\tvar nextGen = new List<List<int[]>>(); //Next generation of infected cells\\n\\t\\tvar borderCt = new List<int>();\\n\\t\\tint maxNbr = 0, maxNbrIndex = -1; //Track how many new cells will be affected.\\n\\t\\tfor(int i=0;i<currInfected.Count;i++){\\n\\t\\t\\tvar currGen = currInfected[i];\\n\\t\\t\\tvar j = 0; //Tracks number of boundaries needed\\n\\t\\t\\tvar next = new List<int[]>();\\n\\t\\t\\tif(currGen.Count>0){\\n\\t\\t\\t\\tseen = new bool[m,n];\\n\\t\\t\\t\\tGetNeighbors(currGen, m, n, isInfected, seen, next, ref j, dirs);\\n\\t\\t\\t}\\n\\t\\t\\tnextGen.Add(next);\\n\\t\\t\\tborderCt.Add(j);\\n\\t\\t\\tif(next.Count>maxNbr){maxNbr = next.Count; maxNbrIndex = i;} //We want to wall the region that will affect most \"new\" cells\\n\\t\\t}\\n\\t\\tif(maxNbrIndex == -1) break; //No new cells will be affected, so we can exit\\n\\t\\tresult+=borderCt[maxNbrIndex]; //This set of cells will be contained, so add the border count.\\n\\t\\tforeach(var point in nextGen[maxNbrIndex]) isInfected[point[0]][point[1]] = 0; //Contained by walls\\n\\t\\tfor(int k=0;k<nextGen.Count;k++){\\n\\t\\t\\tif(k==maxNbrIndex) continue;\\n\\t\\t\\tforeach(var point in nextGen[k]) isInfected[point[0]][point[1]] = 1; //Next gen infection\\n\\t\\t}\\n\\t\\tforeach(var point in currInfected[maxNbrIndex]) isInfected[point[0]][point[1]] = -1; //Contained so set to -1 so that they are not picked up again.\\n\\t}\\n\\treturn result;\\n}\\n\\nvoid GetNeighbors(List<int[]> currGen, int m, int n, int[][] isInfected, bool[,] seen, List<int[]> next, ref int i , (int rInc, int cInc)[] dirs){\\n\\tforeach(var point in currGen){\\n\\t\\tint r = point[0], c = point[1];\\n\\t\\tforeach(var dir in dirs){\\n\\t\\t\\tint newR = r + dir.rInc, newC = c + dir.cInc;\\n\\t\\t\\tif(IsValid(newR, newC, m, n) && isInfected[newR][newC]==0){\\n\\t\\t\\t\\ti++; //This is # of borders needed, this != # of next gen cells that will be affected.\\n\\t\\t\\t\\tif(!seen[newR,newC]){\\n\\t\\t\\t\\t\\tseen[newR,newC] = true;\\n\\t\\t\\t\\t\\tnext.Add(new int[]{newR,newC});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nvoid DFS(int r, int c, List<int[]> curr, int m, int n, bool[,] seen, int[][] isInfected, (int rInc, int cInc)[] dirs){\\n\\tcurr.Add(new int[]{r,c});\\n\\tforeach(var dir in dirs){\\n\\t\\tint newR = r + dir.rInc, newC = c + dir.cInc;\\n\\t\\tif(IsValid(newR, newC, m, n) && !seen[newR,newC] && isInfected[newR][newC]==1){\\n\\t\\t\\tseen[newR,newC] = true;\\n\\t\\t\\tDFS(newR, newC, curr, m, n, seen, isInfected, dirs);\\n\\t\\t}\\n\\t}\\n}\\n\\nbool IsValid(int r, int c, int m, int n) => r>=0 && r<m && c>=0 && c<n; \\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\n//O((m*n)^2) Time and O(m*n) Space\\npublic int ContainVirus(int[][] isInfected) {\\n\\tint m = isInfected.Length, n = isInfected[0].Length, result = 0;\\n\\tvar dirs = new (int rInc, int cInc)[]{(1,0), (-1,0), (0,1),(0,-1)};\\n\\twhile(true){\\n\\t\\tvar seen = new bool[m,n]; //Prevent revisiting cells\\n\\t\\tvar currInfected = new List<List<int[]>>(); //Tracks infected regions\\n\\t\\tbool keepGoing = false;\\n\\n\\t\\tfor(int r=0;r<m;r++){\\n\\t\\t\\tfor(int c = 0;c<n;c++){\\n\\t\\t\\t\\tif(isInfected[r][c]==1 && !seen[r,c]){\\n\\t\\t\\t\\t\\tseen[r,c] = true;\\n\\t\\t\\t\\t\\tkeepGoing = true;\\n\\t\\t\\t\\t\\tvar curr = new List<int[]>();\\n\\t\\t\\t\\t\\tDFS(r,c,curr,m,n,seen,isInfected,dirs);\\n\\t\\t\\t\\t\\tcurrInfected.Add(curr);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(!keepGoing) break;\\n\\n\\t\\tvar nextGen = new List<List<int[]>>(); //Next generation of infected cells\\n\\t\\tvar borderCt = new List<int>();\\n\\t\\tint maxNbr = 0, maxNbrIndex = -1; //Track how many new cells will be affected.\\n\\t\\tfor(int i=0;i<currInfected.Count;i++){\\n\\t\\t\\tvar currGen = currInfected[i];\\n\\t\\t\\tvar j = 0; //Tracks number of boundaries needed\\n\\t\\t\\tvar next = new List<int[]>();\\n\\t\\t\\tif(currGen.Count>0){\\n\\t\\t\\t\\tseen = new bool[m,n];\\n\\t\\t\\t\\tGetNeighbors(currGen, m, n, isInfected, seen, next, ref j, dirs);\\n\\t\\t\\t}\\n\\t\\t\\tnextGen.Add(next);\\n\\t\\t\\tborderCt.Add(j);\\n\\t\\t\\tif(next.Count>maxNbr){maxNbr = next.Count; maxNbrIndex = i;} //We want to wall the region that will affect most \"new\" cells\\n\\t\\t}\\n\\t\\tif(maxNbrIndex == -1) break; //No new cells will be affected, so we can exit\\n\\t\\tresult+=borderCt[maxNbrIndex]; //This set of cells will be contained, so add the border count.\\n\\t\\tforeach(var point in nextGen[maxNbrIndex]) isInfected[point[0]][point[1]] = 0; //Contained by walls\\n\\t\\tfor(int k=0;k<nextGen.Count;k++){\\n\\t\\t\\tif(k==maxNbrIndex) continue;\\n\\t\\t\\tforeach(var point in nextGen[k]) isInfected[point[0]][point[1]] = 1; //Next gen infection\\n\\t\\t}\\n\\t\\tforeach(var point in currInfected[maxNbrIndex]) isInfected[point[0]][point[1]] = -1; //Contained so set to -1 so that they are not picked up again.\\n\\t}\\n\\treturn result;\\n}\\n\\nvoid GetNeighbors(List<int[]> currGen, int m, int n, int[][] isInfected, bool[,] seen, List<int[]> next, ref int i , (int rInc, int cInc)[] dirs){\\n\\tforeach(var point in currGen){\\n\\t\\tint r = point[0], c = point[1];\\n\\t\\tforeach(var dir in dirs){\\n\\t\\t\\tint newR = r + dir.rInc, newC = c + dir.cInc;\\n\\t\\t\\tif(IsValid(newR, newC, m, n) && isInfected[newR][newC]==0){\\n\\t\\t\\t\\ti++; //This is # of borders needed, this != # of next gen cells that will be affected.\\n\\t\\t\\t\\tif(!seen[newR,newC]){\\n\\t\\t\\t\\t\\tseen[newR,newC] = true;\\n\\t\\t\\t\\t\\tnext.Add(new int[]{newR,newC});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nvoid DFS(int r, int c, List<int[]> curr, int m, int n, bool[,] seen, int[][] isInfected, (int rInc, int cInc)[] dirs){\\n\\tcurr.Add(new int[]{r,c});\\n\\tforeach(var dir in dirs){\\n\\t\\tint newR = r + dir.rInc, newC = c + dir.cInc;\\n\\t\\tif(IsValid(newR, newC, m, n) && !seen[newR,newC] && isInfected[newR][newC]==1){\\n\\t\\t\\tseen[newR,newC] = true;\\n\\t\\t\\tDFS(newR, newC, curr, m, n, seen, isInfected, dirs);\\n\\t\\t}\\n\\t}\\n}\\n\\nbool IsValid(int r, int c, int m, int n) => r>=0 && r<m && c>=0 && c<n; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1548026,
                "title": "python-3-dfs-faster-than-98",
                "content": "```\\nclass Solution:\\n    def containVirus(self, isInfected: List[List[int]]) -> int:\\n        \\'\\'\\'      \\n        step 1: count infected area for each cluster, and wall needed. cluster: {(x0, y0): [(x, y), # of walls]}\\n        step 2: pick the largest infected area (x0, y0) set all(x,y) to -1, accumulate # of walls, removed (x0, yo) from dict\\n        step 3: increase the other infected area, DFS to set their neibors to 1\\n        step 4: repeat step 1 to 3\\n        \\'\\'\\'\\n\\n        # traverse to calculate the cells that will be infected, and number of walls required\\n        def dfs(parent, x, y):\\n            if 0<=x<m and 0<=y<n and (x, y) not in seen: \\n                if isInfected[x][y] == 1:\\n                    cluster[parent][0].append((x, y))\\n                    seen.add((x, y))\\n                    dfs(parent, x - 1, y)\\n                    dfs(parent, x + 1, y)\\n                    dfs(parent, x, y - 1)\\n                    dfs(parent, x, y + 1)\\n                elif isInfected[x][y] == 0:\\n                    cluster[parent][1] += 1\\n                    if (x, y) not in willbeinfected:\\n                        willbeinfected.add((x, y))\\n        \\n        # set infected cell to 1\\n        def dfs_infection(x, y):\\n            if 0<=x<m and 0<=y<n and isInfected[x][y] == 0: \\n                isInfected[x][y] = 1\\n                \\n        m, n = len(isInfected), len(isInfected[0])\\n        totalwall = 0\\n\\n        # loop untill no walls required or all cells are infected\\n        while True:\\n            cluster = dict()\\n            seen = set()\\n\\n            maxinfected = 0\\n            maxwall_parent = tuple()\\n            wall = 0\\n\\n            # scan the whole map to get the largest area that will be infected, get the number of walls required\\n            for i in range(m):\\n                for j in range(n):\\n                    if isInfected[i][j] == 1 and (i, j) not in seen:\\n                        willbeinfected = set()\\n                        parent = (i, j)\\n                        cluster[parent] = [[], 0]\\n                        dfs(parent, i, j)\\n                        if len(willbeinfected) > maxinfected:\\n                            maxinfected = len(willbeinfected)\\n                            maxwall_parent = parent\\n                            wall = cluster[parent][1]\\n\\n            # add wall\\n            totalwall += wall\\n\\n            # set cells inside wall to -1\\n            if maxwall_parent:\\n                for row, col in cluster[maxwall_parent][0]:\\n                    isInfected[row][col] = -1\\n                cluster.pop(maxwall_parent)\\n            \\n            # if no wall required, or no cells that will be infected\\n            if not cluster or wall == 0:\\n                break\\n\\n            # increase infection\\n            for parent in cluster:\\n                for i, j in cluster[parent][0]:\\n                    dfs_infection(i - 1, j)\\n                    dfs_infection(i + 1, j)\\n                    dfs_infection(i, j - 1)\\n                    dfs_infection(i, j + 1)\\n\\n        return totalwall\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def containVirus(self, isInfected: List[List[int]]) -> int:\\n        \\'\\'\\'      \\n        step 1: count infected area for each cluster, and wall needed. cluster: {(x0, y0): [(x, y), # of walls]}\\n        step 2: pick the largest infected area (x0, y0) set all(x,y) to -1, accumulate # of walls, removed (x0, yo) from dict\\n        step 3: increase the other infected area, DFS to set their neibors to 1\\n        step 4: repeat step 1 to 3\\n        \\'\\'\\'\\n\\n        # traverse to calculate the cells that will be infected, and number of walls required\\n        def dfs(parent, x, y):\\n            if 0<=x<m and 0<=y<n and (x, y) not in seen: \\n                if isInfected[x][y] == 1:\\n                    cluster[parent][0].append((x, y))\\n                    seen.add((x, y))\\n                    dfs(parent, x - 1, y)\\n                    dfs(parent, x + 1, y)\\n                    dfs(parent, x, y - 1)\\n                    dfs(parent, x, y + 1)\\n                elif isInfected[x][y] == 0:\\n                    cluster[parent][1] += 1\\n                    if (x, y) not in willbeinfected:\\n                        willbeinfected.add((x, y))\\n        \\n        # set infected cell to 1\\n        def dfs_infection(x, y):\\n            if 0<=x<m and 0<=y<n and isInfected[x][y] == 0: \\n                isInfected[x][y] = 1\\n                \\n        m, n = len(isInfected), len(isInfected[0])\\n        totalwall = 0\\n\\n        # loop untill no walls required or all cells are infected\\n        while True:\\n            cluster = dict()\\n            seen = set()\\n\\n            maxinfected = 0\\n            maxwall_parent = tuple()\\n            wall = 0\\n\\n            # scan the whole map to get the largest area that will be infected, get the number of walls required\\n            for i in range(m):\\n                for j in range(n):\\n                    if isInfected[i][j] == 1 and (i, j) not in seen:\\n                        willbeinfected = set()\\n                        parent = (i, j)\\n                        cluster[parent] = [[], 0]\\n                        dfs(parent, i, j)\\n                        if len(willbeinfected) > maxinfected:\\n                            maxinfected = len(willbeinfected)\\n                            maxwall_parent = parent\\n                            wall = cluster[parent][1]\\n\\n            # add wall\\n            totalwall += wall\\n\\n            # set cells inside wall to -1\\n            if maxwall_parent:\\n                for row, col in cluster[maxwall_parent][0]:\\n                    isInfected[row][col] = -1\\n                cluster.pop(maxwall_parent)\\n            \\n            # if no wall required, or no cells that will be infected\\n            if not cluster or wall == 0:\\n                break\\n\\n            # increase infection\\n            for parent in cluster:\\n                for i, j in cluster[parent][0]:\\n                    dfs_infection(i - 1, j)\\n                    dfs_infection(i + 1, j)\\n                    dfs_infection(i, j - 1)\\n                    dfs_infection(i, j + 1)\\n\\n        return totalwall\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1423499,
                "title": "javascript-dfs-solution-beats-100-with-detail-comments",
                "content": "```js\\n/**\\n * @param {number[][]} isInfected\\n * @return {number}\\n */\\nvar containVirus = function(isInfected) {\\n    var result = 0;\\n    \\n    var m = isInfected.length;\\n    var n = isInfected[0].length;\\n    \\n    //  use flat idx to make problem easier\\n    var getKey = function(x, y) {\\n        return x * n + y;\\n    }\\n    var getIdxFromKey = function(key) {\\n        return [Math.floor(key / n), key % n];\\n    }\\n        \\n    // for each virus area, we need to cache their {cellIKey, threatCount, wallCount}\\n    var cells = [];\\n    var threatAreas = [];\\n    var wallCounts = [];\\n    var visited = [];\\n    \\n    // four direction\\n    var dx = [0, 0, 1, -1];\\n    var dy = [1, -1, 0, 0];\\n    \\n    // for every virus area\\n    // mark controlled virus cell as 2\\n    // return the wall\\'s count to control this area\\n    var dfs = function(i, j, cellArr, threatSet, wallCount) {\\n        var key = getKey(i, j);\\n        if (i < 0 || i >= m || j < 0 || j >= n || visited[key] || isInfected[i][j] === 2) {\\n            return wallCount;\\n        }\\n        \\n        // if this cell is virus infected cell, cache its key to the cellArr, and calculate everything for 4 direction\\n        if (isInfected[i][j] === 1) {\\n            visited[key] = true;\\n            cellArr.push(key);\\n            for (var k = 0; k < dx.length; k++) {\\n                wallCount = dfs(i + dx[k], j + dy[k], cellArr, threatSet, wallCount);\\n            }\\n        } else {\\n            // if current cell is not infected cell\\n            // means this cell is the cell may be threat tonight\\n            // we need a new wall to control it\\n            // a threat cell may be calculate several time, so we use set here\\n            wallCount++;\\n            threatSet.add(key);\\n        }\\n        \\n        return wallCount;\\n    }\\n    \\n    while (true) {\\n        // for every night\\n        cells = []; // [virus area cells idx array 0, virus area cells idx array 1, ...]\\n        threatAreas = [];\\n        wallCounts = [];\\n        visited = [];\\n        \\n        var maxThreadArea = 0;\\n        var maxThreadAreaIdx = 0;\\n        \\n        for (var i = 0; i < m; i++) {\\n            for (var j = 0; j < n; j++) {\\n                // for a virus cell\\n                if (isInfected[i][j] === 1) {\\n                    var cellArr = [];\\n                    var threatSet = new Set();\\n                    var wallCount = dfs(i, j, cellArr, threatSet, 0);\\n                    // if this area do not need wall to control, ignore this area\\n                    if (!wallCount) {\\n                        continue;\\n                    }\\n                    // cache the area that threatens the most uninfected cells the following night\\n                    if (threatSet.size > maxThreadArea) {\\n                        maxThreadArea = threatSet.size;\\n                        maxThreadAreaIdx = threatAreas.length;\\n                    }\\n                    cells.push(cellArr);\\n                    threatAreas.push(Array.from(threatSet));\\n                    wallCounts.push(wallCount);\\n                }\\n            }\\n        }\\n        \\n        if (!wallCounts.length) {\\n            break;\\n        }\\n        \\n        // install walls to the area that threatens the most uninfected cells the tonight\\n        result += wallCounts[maxThreadAreaIdx];\\n        for (var k = 0; k < wallCounts.length; k++) {\\n            if (k === maxThreadAreaIdx) {\\n                cells[k].forEach(cellKey => {\\n                    var [x, y] = getIdxFromKey(cellKey);\\n                    isInfected[x][y] = 2;\\n                });\\n            } else {\\n                // threat the areas which not install walls\\n                threatAreas[k].forEach(cellKey => {\\n                    var [x, y] = getIdxFromKey(cellKey);\\n                    isInfected[x][y] = 1;\\n                });\\n            }\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```js\\n/**\\n * @param {number[][]} isInfected\\n * @return {number}\\n */\\nvar containVirus = function(isInfected) {\\n    var result = 0;\\n    \\n    var m = isInfected.length;\\n    var n = isInfected[0].length;\\n    \\n    //  use flat idx to make problem easier\\n    var getKey = function(x, y) {\\n        return x * n + y;\\n    }\\n    var getIdxFromKey = function(key) {\\n        return [Math.floor(key / n), key % n];\\n    }\\n        \\n    // for each virus area, we need to cache their {cellIKey, threatCount, wallCount}\\n    var cells = [];\\n    var threatAreas = [];\\n    var wallCounts = [];\\n    var visited = [];\\n    \\n    // four direction\\n    var dx = [0, 0, 1, -1];\\n    var dy = [1, -1, 0, 0];\\n    \\n    // for every virus area\\n    // mark controlled virus cell as 2\\n    // return the wall\\'s count to control this area\\n    var dfs = function(i, j, cellArr, threatSet, wallCount) {\\n        var key = getKey(i, j);\\n        if (i < 0 || i >= m || j < 0 || j >= n || visited[key] || isInfected[i][j] === 2) {\\n            return wallCount;\\n        }\\n        \\n        // if this cell is virus infected cell, cache its key to the cellArr, and calculate everything for 4 direction\\n        if (isInfected[i][j] === 1) {\\n            visited[key] = true;\\n            cellArr.push(key);\\n            for (var k = 0; k < dx.length; k++) {\\n                wallCount = dfs(i + dx[k], j + dy[k], cellArr, threatSet, wallCount);\\n            }\\n        } else {\\n            // if current cell is not infected cell\\n            // means this cell is the cell may be threat tonight\\n            // we need a new wall to control it\\n            // a threat cell may be calculate several time, so we use set here\\n            wallCount++;\\n            threatSet.add(key);\\n        }\\n        \\n        return wallCount;\\n    }\\n    \\n    while (true) {\\n        // for every night\\n        cells = []; // [virus area cells idx array 0, virus area cells idx array 1, ...]\\n        threatAreas = [];\\n        wallCounts = [];\\n        visited = [];\\n        \\n        var maxThreadArea = 0;\\n        var maxThreadAreaIdx = 0;\\n        \\n        for (var i = 0; i < m; i++) {\\n            for (var j = 0; j < n; j++) {\\n                // for a virus cell\\n                if (isInfected[i][j] === 1) {\\n                    var cellArr = [];\\n                    var threatSet = new Set();\\n                    var wallCount = dfs(i, j, cellArr, threatSet, 0);\\n                    // if this area do not need wall to control, ignore this area\\n                    if (!wallCount) {\\n                        continue;\\n                    }\\n                    // cache the area that threatens the most uninfected cells the following night\\n                    if (threatSet.size > maxThreadArea) {\\n                        maxThreadArea = threatSet.size;\\n                        maxThreadAreaIdx = threatAreas.length;\\n                    }\\n                    cells.push(cellArr);\\n                    threatAreas.push(Array.from(threatSet));\\n                    wallCounts.push(wallCount);\\n                }\\n            }\\n        }\\n        \\n        if (!wallCounts.length) {\\n            break;\\n        }\\n        \\n        // install walls to the area that threatens the most uninfected cells the tonight\\n        result += wallCounts[maxThreadAreaIdx];\\n        for (var k = 0; k < wallCounts.length; k++) {\\n            if (k === maxThreadAreaIdx) {\\n                cells[k].forEach(cellKey => {\\n                    var [x, y] = getIdxFromKey(cellKey);\\n                    isInfected[x][y] = 2;\\n                });\\n            } else {\\n                // threat the areas which not install walls\\n                threatAreas[k].forEach(cellKey => {\\n                    var [x, y] = getIdxFromKey(cellKey);\\n                    isInfected[x][y] = 1;\\n                });\\n            }\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1366743,
                "title": "don-t-know-why-mycode-is-giving-tle-although-32-32-cases-are-passed",
                "content": "Can someone please check mycode and help to tell why it is giving TLE?\\nI have used DFS approach.\\n\\nstruct NeighboursAndPerimeters{\\n\\tset<int> infected; // store index of infected cell which is part of infected region\\n\\tset<int> notinfected; // store index of non-infected cell which is connected to infected cell \\n\\tint perimeter=0; //wall count\\n};\\n\\nvoid dfs(vector<vector<int>> arr, int row, int col, bool **visited, NeighboursAndPerimeters &neighboursAndPerimeters){\\n\\tint rows = arr.size();\\n\\tint cols = arr[0].size();\\n\\t\\n\\tif(row <0 || row>=rows || col<0 || col>=cols || arr[row][col]==2)return;\\n\\t\\n\\tif(arr[row][col]==1){\\n\\t\\tneighboursAndPerimeters.infected.insert(row*cols+col);\\n\\t\\tif(visited[row][col])return;\\n\\t}\\n\\tvisited[row][col]=true;\\n\\t\\n\\tif(arr[row][col]==0){\\n\\t\\tneighboursAndPerimeters.perimeter++;\\n\\t\\tneighboursAndPerimeters.notinfected.insert(row*cols+col); //store as row major (2d matrix--> 1D matrix)\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\tdfs(arr,row+1,col,visited,neighboursAndPerimeters);\\n\\tdfs(arr,row-1,col,visited,neighboursAndPerimeters);\\n\\tdfs(arr,row,col+1,visited,neighboursAndPerimeters);\\n\\tdfs(arr,row,col-1,visited,neighboursAndPerimeters);\\n\\t\\n}\\n\\nbool myway(NeighboursAndPerimeters a, NeighboursAndPerimeters b){\\n\\treturn a.notinfected.size() > b.notinfected.size();\\n}\\n\\nclass Solution {\\npublic:\\n    int containVirus(vector<vector<int>>& arr) {\\n\\t\\tif(arr.size()==0)return 0;\\n\\t\\tint rows = arr.size();\\n\\t\\tint cols = arr[0].size();\\n\\t\\tcout<<rows<<\" \"<<cols<<endl;\\n\\t\\tint result=0;\\n\\t\\twhile(1){\\n\\t\\t\\tlist<NeighboursAndPerimeters> regionNeighbours;\\n\\t\\t\\tbool **visited = new bool*[rows];\\n\\t\\t\\tfor(int i=0;i<rows;i++){\\n\\t\\t\\t\\tvisited[i] = new bool[cols];\\n\\t\\t\\t}\\n            \\n            for(int i=0;i<rows;i++){\\n                for(int j=0;j<cols;j++){\\n                    visited[i][j]=false;\\n                }\\n            }\\n\\t\\t\\t\\n\\t\\t\\tfor(int row=0;row<rows;row++){\\n\\t\\t\\t\\tfor(int col=0;col<cols;col++){\\n\\t\\t\\t\\t\\tif(arr[row][col]==1 && !visited[row][col]){\\n                        //cout<<\"inside\";\\n\\t\\t\\t\\t\\t\\tNeighboursAndPerimeters neighboursAndPerimeters;\\n\\t\\t\\t\\t\\t\\tdfs(arr,row,col,visited,neighboursAndPerimeters);\\n\\t\\t\\t\\t\\t\\tcout<<neighboursAndPerimeters.perimeter<<endl;\\n\\t\\t\\t\\t\\t\\tif(neighboursAndPerimeters.notinfected.size()>0){\\n\\t\\t\\t\\t\\t\\t\\tregionNeighbours.push_back(neighboursAndPerimeters);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//cout<<\"here\";\\n\\t\\t\\tif(regionNeighbours.size()==0)break;\\n\\t\\t\\t\\n\\t\\t\\t//sort(regionNeighbours.begin(),regionNeighbours.end(),myway);\\n\\t\\t\\tregionNeighbours.sort(myway);\\n\\t\\t\\t\\n\\t\\t\\t//int last = regionNeighbours.size();\\n\\t\\t\\tauto it = regionNeighbours.begin();\\n\\t\\t\\t//NeighboursAndPerimeters neighboursAndPerimeters = regionNeighbours[last-1];\\n\\t\\t\\tNeighboursAndPerimeters neighboursAndPerimeters = *it;\\n\\t\\t\\tresult += neighboursAndPerimeters.perimeter;\\n\\t\\t\\t\\n\\t\\t\\tfor(int neighbour:neighboursAndPerimeters.infected){\\n\\t\\t\\t\\tint row = neighbour/cols;\\n\\t\\t\\t\\tint col = neighbour%cols;\\n\\t\\t\\t\\tarr[row][col] = 2;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tregionNeighbours.pop_front();\\n\\t\\t\\t\\n\\t\\t\\tfor(NeighboursAndPerimeters remaining : regionNeighbours){\\n\\t\\t\\t\\tfor(int neighbour:remaining.notinfected){\\n\\t\\t\\t\\t\\tint row = neighbour/cols;\\n\\t\\t\\t\\t\\tint col = neighbour%cols;\\n\\t\\t\\t\\t\\tarr[row][col]=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t}\\n\\t\\treturn result;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int containVirus(vector<vector<int>>& arr) {\\n\\t\\tif(arr.size()==0)return 0;\\n\\t\\tint rows = arr.size();\\n\\t\\tint cols = arr[0].size();\\n\\t\\tcout<<rows<<\" \"<<cols<<endl;\\n\\t\\tint result=0;\\n\\t\\twhile(1){\\n\\t\\t\\tlist<NeighboursAndPerimeters> regionNeighbours;\\n\\t\\t\\tbool **visited = new bool*[rows];\\n\\t\\t\\tfor(int i=0;i<rows;i++){\\n\\t\\t\\t\\tvisited[i] = new bool[cols];\\n\\t\\t\\t}",
                "codeTag": "C++"
            },
            {
                "id": 1319048,
                "title": "c-dfs-solution",
                "content": "```\\nclass Solution {\\n    int numWalls = 0;\\n    unordered_set<int> adjZeroCells;\\n    int currIt = 1;\\n    vector<int> dx = {0,1,0,-1};\\n    vector<int> dy = {1,0,-1,0};\\npublic:\\n    void getInfo(vector<vector<int>>& mat, int i, int j) {\\n        mat[i][j] = currIt+1;\\n        for(int d = 0; d < 4; d++) {\\n            int x = dx[d] + i;\\n            int y = dy[d] + j;\\n            if(x < 0 || y < 0 || x >= mat.size() || y >= mat[0].size()) continue;\\n            if(mat[x][y] == 0) {\\n                adjZeroCells.insert(x*mat[0].size()+y);\\n                numWalls++;\\n            } else if(mat[x][y] == currIt) getInfo(mat, x, y);\\n        }\\n    }\\n    void wallOff(vector<vector<int>>& mat, int i, int j) {\\n        mat[i][j] = -1;\\n        for(int d = 0; d < 4; d++) {\\n            int x = dx[d] + i;\\n            int y = dy[d] + j;\\n            if(x < 0 || y < 0 || x >= mat.size() || y >= mat[0].size()) continue;\\n            if(mat[x][y] == currIt) wallOff(mat, x, y);\\n        }\\n    }\\n    void spreadVirus(vector<vector<int>>& mat, int i, int j) {\\n        mat[i][j] = currIt+1;\\n        for(int d = 0; d < 4; d++) {\\n            int x = dx[d] + i;\\n            int y = dy[d] + j;\\n            if(x < 0 || y < 0 || x >= mat.size() || y >= mat[0].size()) continue;\\n            if(mat[x][y] == 0) mat[x][y] = currIt+1;\\n            else if(mat[x][y] == currIt) spreadVirus(mat, x, y);\\n        }\\n    }\\n    \\n    int containVirus(vector<vector<int>>& mat) {\\n        int ans = 0;\\n        while(true) {\\n            int bi,bj;\\n            int maxNewlyInf = INT_MIN;\\n            int bestNumWalls;\\n            for(int i = 0; i < mat.size(); i++) {\\n                for(int j = 0; j < mat[0].size(); j++) {\\n                    if(mat[i][j] != currIt) continue;\\n                    numWalls = 0;\\n                    adjZeroCells.clear();\\n                    getInfo(mat, i, j);\\n                    int newlyInf = adjZeroCells.size();\\n                    if(newlyInf > maxNewlyInf) {\\n                        maxNewlyInf = newlyInf;\\n                        bi = i;\\n                        bj = j;\\n                        bestNumWalls = numWalls; \\n                    }\\n                }\\n            }\\n            currIt++;\\n            if(maxNewlyInf == INT_MIN) return ans;\\n            wallOff(mat,bi,bj);\\n            ans += bestNumWalls; \\n        \\n            for(int i = 0; i < mat.size(); i++) {\\n                for(int j = 0; j < mat[0].size(); j++) {\\n                    if(mat[i][j] != currIt) continue;\\n                    spreadVirus(mat, i, j);\\n                }\\n            }\\n            currIt++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int numWalls = 0;\\n    unordered_set<int> adjZeroCells;\\n    int currIt = 1;\\n    vector<int> dx = {0,1,0,-1};\\n    vector<int> dy = {1,0,-1,0};\\npublic:\\n    void getInfo(vector<vector<int>>& mat, int i, int j) {\\n        mat[i][j] = currIt+1;\\n        for(int d = 0; d < 4; d++) {\\n            int x = dx[d] + i;\\n            int y = dy[d] + j;\\n            if(x < 0 || y < 0 || x >= mat.size() || y >= mat[0].size()) continue;\\n            if(mat[x][y] == 0) {\\n                adjZeroCells.insert(x*mat[0].size()+y);\\n                numWalls++;\\n            } else if(mat[x][y] == currIt) getInfo(mat, x, y);\\n        }\\n    }\\n    void wallOff(vector<vector<int>>& mat, int i, int j) {\\n        mat[i][j] = -1;\\n        for(int d = 0; d < 4; d++) {\\n            int x = dx[d] + i;\\n            int y = dy[d] + j;\\n            if(x < 0 || y < 0 || x >= mat.size() || y >= mat[0].size()) continue;\\n            if(mat[x][y] == currIt) wallOff(mat, x, y);\\n        }\\n    }\\n    void spreadVirus(vector<vector<int>>& mat, int i, int j) {\\n        mat[i][j] = currIt+1;\\n        for(int d = 0; d < 4; d++) {\\n            int x = dx[d] + i;\\n            int y = dy[d] + j;\\n            if(x < 0 || y < 0 || x >= mat.size() || y >= mat[0].size()) continue;\\n            if(mat[x][y] == 0) mat[x][y] = currIt+1;\\n            else if(mat[x][y] == currIt) spreadVirus(mat, x, y);\\n        }\\n    }\\n    \\n    int containVirus(vector<vector<int>>& mat) {\\n        int ans = 0;\\n        while(true) {\\n            int bi,bj;\\n            int maxNewlyInf = INT_MIN;\\n            int bestNumWalls;\\n            for(int i = 0; i < mat.size(); i++) {\\n                for(int j = 0; j < mat[0].size(); j++) {\\n                    if(mat[i][j] != currIt) continue;\\n                    numWalls = 0;\\n                    adjZeroCells.clear();\\n                    getInfo(mat, i, j);\\n                    int newlyInf = adjZeroCells.size();\\n                    if(newlyInf > maxNewlyInf) {\\n                        maxNewlyInf = newlyInf;\\n                        bi = i;\\n                        bj = j;\\n                        bestNumWalls = numWalls; \\n                    }\\n                }\\n            }\\n            currIt++;\\n            if(maxNewlyInf == INT_MIN) return ans;\\n            wallOff(mat,bi,bj);\\n            ans += bestNumWalls; \\n        \\n            for(int i = 0; i < mat.size(); i++) {\\n                for(int j = 0; j < mat[0].size(); j++) {\\n                    if(mat[i][j] != currIt) continue;\\n                    spreadVirus(mat, i, j);\\n                }\\n            }\\n            currIt++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1044682,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void infect(int i, int j, int numRows, int numCols,\\n                vector<vector<int>>& grid) {\\n        vector<int> x_cor = {0, 0,1,-1};\\n        vector<int> y_cor = {1,-1,0, 0};\\n\\n        for (int pos = 0; pos<x_cor.size(); pos++) {\\n            int x = i+x_cor[pos];\\n            int y = j+y_cor[pos];\\n            if ((x>=0) && (x<numRows) &&\\n                (y>=0) && (y<numCols) && (grid[x][y] == 0)) {\\n                grid[x][y] = 1;\\n            }\\n        }\\n    }\\n    int findNumWalls(vector<pair<int,int>>& items,\\n                     int numRows, int numCols,\\n                     vector<vector<int>>& grid) {\\n        int numWalls = 0;\\n        for (int m=0; m<items.size(); m++) {\\n            int i = items[m].first, j = items[m].second;\\n            vector<int> x_cor = {0, 0,1,-1};\\n            vector<int> y_cor = {1,-1,0, 0};\\n\\n            for (int pos = 0; pos<x_cor.size(); pos++) {\\n                int x = i+x_cor[pos];\\n                int y = j+y_cor[pos];\\n                if ((x>=0) && (x<numRows) &&\\n                    (y>=0) && (y<numCols) && (grid[x][y] == 0)){\\n                    numWalls++;\\n                }\\n            }\\n            grid[i][j] = 2;\\n        }\\n        return numWalls;\\n    }\\n    void dfs(int i, int j, set<pair<int,int>>& visited,\\n             int& numCanInfect,\\n             vector<pair<int,int>>& items,\\n             int numRows, int numCols,\\n             vector<vector<int>>& grid,\\n             set<pair<int,int>>& visited1) {\\n        visited.insert({i,j});\\n        items.push_back({i,j});\\n        vector<int> x_cor = {0, 0,1,-1};\\n        vector<int> y_cor = {1,-1,0, 0};\\n        \\n        for (int pos = 0; pos<x_cor.size(); pos++) {\\n            int x = i+x_cor[pos];\\n            int y = j+y_cor[pos];\\n            if ((x>=0) && (x<numRows) &&\\n                (y>=0) && (y<numCols) &&\\n                (visited.find({x,y}) == visited.end()) &&\\n                (visited1.find({x,y}) == visited1.end())) {\\n                 if (grid[x][y] == 1) {\\n                     dfs(x,y,visited, numCanInfect, items, numRows, numCols, grid, visited1);\\n                 } else if (grid[x][y] == 0) {\\n                     visited1.insert({x,y});\\n                     numCanInfect++;\\n                 }\\n            }\\n        }\\n    }\\n    int containVirus(vector<vector<int>>& grid) {\\n        int numWalls = 0;\\n        int numRows = grid.size();\\n        int numCols = grid[0].size();\\n        \\n        while(true) {\\n            vector<pair<int, vector<pair<int,int>>>> v;\\n            set<pair<int,int>> visited;\\n            for (int i=0; i<numRows; i++) {\\n                for (int j=0; j<numCols; j++) {\\n                    if ((grid[i][j] == 1) &&\\n                        (visited.find({i,j}) == visited.end())) {\\n                        int numCanInfect = 0;\\n                        vector<pair<int, int>> items;\\n                        set<pair<int,int>> visited1;\\n                        dfs(i,j,visited, numCanInfect, items, numRows, numCols, grid, visited1);\\n                        v.push_back({numCanInfect, items});\\n                    }\\n                }\\n            }\\n            if (v.size() == 0) {\\n                break;\\n            }\\n            sort(v.begin(), v.end());\\n            int nW = findNumWalls(v[v.size()-1].second, numRows, numCols, grid);\\n            numWalls += nW;\\n            for (int i=0; i<v.size()-1; i++) {\\n                for (auto item : v[i].second) {\\n                    infect(item.first, item.second, numRows, numCols, grid);\\n                }\\n            }\\n        }\\n        return numWalls;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void infect(int i, int j, int numRows, int numCols,\\n                vector<vector<int>>& grid) {\\n        vector<int> x_cor = {0, 0,1,-1};\\n        vector<int> y_cor = {1,-1,0, 0};\\n\\n        for (int pos = 0; pos<x_cor.size(); pos++) {\\n            int x = i+x_cor[pos];\\n            int y = j+y_cor[pos];\\n            if ((x>=0) && (x<numRows) &&\\n                (y>=0) && (y<numCols) && (grid[x][y] == 0)) {\\n                grid[x][y] = 1;\\n            }\\n        }\\n    }\\n    int findNumWalls(vector<pair<int,int>>& items,\\n                     int numRows, int numCols,\\n                     vector<vector<int>>& grid) {\\n        int numWalls = 0;\\n        for (int m=0; m<items.size(); m++) {\\n            int i = items[m].first, j = items[m].second;\\n            vector<int> x_cor = {0, 0,1,-1};\\n            vector<int> y_cor = {1,-1,0, 0};\\n\\n            for (int pos = 0; pos<x_cor.size(); pos++) {\\n                int x = i+x_cor[pos];\\n                int y = j+y_cor[pos];\\n                if ((x>=0) && (x<numRows) &&\\n                    (y>=0) && (y<numCols) && (grid[x][y] == 0)){\\n                    numWalls++;\\n                }\\n            }\\n            grid[i][j] = 2;\\n        }\\n        return numWalls;\\n    }\\n    void dfs(int i, int j, set<pair<int,int>>& visited,\\n             int& numCanInfect,\\n             vector<pair<int,int>>& items,\\n             int numRows, int numCols,\\n             vector<vector<int>>& grid,\\n             set<pair<int,int>>& visited1) {\\n        visited.insert({i,j});\\n        items.push_back({i,j});\\n        vector<int> x_cor = {0, 0,1,-1};\\n        vector<int> y_cor = {1,-1,0, 0};\\n        \\n        for (int pos = 0; pos<x_cor.size(); pos++) {\\n            int x = i+x_cor[pos];\\n            int y = j+y_cor[pos];\\n            if ((x>=0) && (x<numRows) &&\\n                (y>=0) && (y<numCols) &&\\n                (visited.find({x,y}) == visited.end()) &&\\n                (visited1.find({x,y}) == visited1.end())) {\\n                 if (grid[x][y] == 1) {\\n                     dfs(x,y,visited, numCanInfect, items, numRows, numCols, grid, visited1);\\n                 } else if (grid[x][y] == 0) {\\n                     visited1.insert({x,y});\\n                     numCanInfect++;\\n                 }\\n            }\\n        }\\n    }\\n    int containVirus(vector<vector<int>>& grid) {\\n        int numWalls = 0;\\n        int numRows = grid.size();\\n        int numCols = grid[0].size();\\n        \\n        while(true) {\\n            vector<pair<int, vector<pair<int,int>>>> v;\\n            set<pair<int,int>> visited;\\n            for (int i=0; i<numRows; i++) {\\n                for (int j=0; j<numCols; j++) {\\n                    if ((grid[i][j] == 1) &&\\n                        (visited.find({i,j}) == visited.end())) {\\n                        int numCanInfect = 0;\\n                        vector<pair<int, int>> items;\\n                        set<pair<int,int>> visited1;\\n                        dfs(i,j,visited, numCanInfect, items, numRows, numCols, grid, visited1);\\n                        v.push_back({numCanInfect, items});\\n                    }\\n                }\\n            }\\n            if (v.size() == 0) {\\n                break;\\n            }\\n            sort(v.begin(), v.end());\\n            int nW = findNumWalls(v[v.size()-1].second, numRows, numCols, grid);\\n            numWalls += nW;\\n            for (int i=0; i<v.size()-1; i++) {\\n                for (auto item : v[i].second) {\\n                    infect(item.first, item.second, numRows, numCols, grid);\\n                }\\n            }\\n        }\\n        return numWalls;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010427,
                "title": "easy-c-solution-step-by-step-infection",
                "content": "```\\npublic class Solution {\\n    private int[][] grid;\\n    private HashSet<(int, int)> seen;\\n    private List<HashSet<(int, int)>> regions;\\n    private List<HashSet<(int, int)>> frontiers;\\n    private List<int> perimeters;\\n    public int ContainVirus(int[][] grid) {\\n        this.grid = grid;\\n        if (grid.Length == 0 || grid[0].Length == 0)\\n            return 0;\\n        int rows = grid.Length;\\n        int cols = grid[0].Length;\\n        int ans = 0;\\n        while (true) {\\n            seen = new HashSet<(int, int)>();\\n            regions = new List<HashSet<(int, int)>>();\\n            frontiers = new List<HashSet<(int, int)>>();\\n            perimeters = new List<int>();\\n            for (int i = 0; i < rows; i++) {\\n                for (int j = 0; j < cols; j++) {\\n                    if (grid[i][j] == 1 && !seen.Contains((i, j))) {\\n                        regions.Add(new HashSet<(int, int)>());\\n                        frontiers.Add(new HashSet<(int, int)>());\\n                        perimeters.Add(0);\\n                        dfs(i, j);\\n                    }\\n                }\\n            }\\n            \\n            if (regions.Count == 0)\\n                break;\\n            \\n            int triageIndex = 0;\\n            for (int i = 0; i < frontiers.Count; i++) {\\n                if (frontiers[triageIndex].Count < frontiers[i].Count)\\n                    triageIndex = i;\\n            }\\n            \\n            ans += perimeters[triageIndex];\\n            for (int i = 0; i < regions.Count; i++) {\\n                if (i == triageIndex) {\\n                    foreach (var(ro, co) in regions[i])\\n                        grid[ro][co] = -1;\\n                }\\n                else {\\n                    foreach (var(ro, co) in regions[i]) {\\n                        InfectCell(ro - 1, co);\\n                        InfectCell(ro + 1, co);\\n                        InfectCell(ro, co - 1);\\n                        InfectCell(ro, co + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void InfectCell(int i, int j) {\\n        if (outside(i, j) || grid[i][j] != 0)\\n            return;\\n        grid[i][j] = 1;\\n    }\\n    \\n    bool outside(int i, int j) {\\n        return i < 0 || i >= grid.Length || j < 0 || j >= grid[i].Length;\\n    }\\n    \\n    void proceed(int N, int i, int j) {\\n        if (outside(i, j))\\n            return;\\n        \\n        if (grid[i][j] == 1)\\n            dfs(i, j);\\n        else if (grid[i][j] == 0) {\\n            frontiers[N - 1].Add((i, j));\\n            perimeters[N - 1]++;            \\n        }\\n    }\\n    \\n    void dfs(int i, int j) {\\n        if (seen.Contains((i, j)))\\n            return;\\n        seen.Add((i, j));\\n        int N = regions.Count;\\n        regions[N - 1].Add((i, j));\\n        \\n        proceed(N, i - 1, j);\\n        proceed(N, i + 1, j);\\n        proceed(N, i, j - 1);\\n        proceed(N, i, j + 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private int[][] grid;\\n    private HashSet<(int, int)> seen;\\n    private List<HashSet<(int, int)>> regions;\\n    private List<HashSet<(int, int)>> frontiers;\\n    private List<int> perimeters;\\n    public int ContainVirus(int[][] grid) {\\n        this.grid = grid;\\n        if (grid.Length == 0 || grid[0].Length == 0)\\n            return 0;\\n        int rows = grid.Length;\\n        int cols = grid[0].Length;\\n        int ans = 0;\\n        while (true) {\\n            seen = new HashSet<(int, int)>();\\n            regions = new List<HashSet<(int, int)>>();\\n            frontiers = new List<HashSet<(int, int)>>();\\n            perimeters = new List<int>();\\n            for (int i = 0; i < rows; i++) {\\n                for (int j = 0; j < cols; j++) {\\n                    if (grid[i][j] == 1 && !seen.Contains((i, j))) {\\n                        regions.Add(new HashSet<(int, int)>());\\n                        frontiers.Add(new HashSet<(int, int)>());\\n                        perimeters.Add(0);\\n                        dfs(i, j);\\n                    }\\n                }\\n            }\\n            \\n            if (regions.Count == 0)\\n                break;\\n            \\n            int triageIndex = 0;\\n            for (int i = 0; i < frontiers.Count; i++) {\\n                if (frontiers[triageIndex].Count < frontiers[i].Count)\\n                    triageIndex = i;\\n            }\\n            \\n            ans += perimeters[triageIndex];\\n            for (int i = 0; i < regions.Count; i++) {\\n                if (i == triageIndex) {\\n                    foreach (var(ro, co) in regions[i])\\n                        grid[ro][co] = -1;\\n                }\\n                else {\\n                    foreach (var(ro, co) in regions[i]) {\\n                        InfectCell(ro - 1, co);\\n                        InfectCell(ro + 1, co);\\n                        InfectCell(ro, co - 1);\\n                        InfectCell(ro, co + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void InfectCell(int i, int j) {\\n        if (outside(i, j) || grid[i][j] != 0)\\n            return;\\n        grid[i][j] = 1;\\n    }\\n    \\n    bool outside(int i, int j) {\\n        return i < 0 || i >= grid.Length || j < 0 || j >= grid[i].Length;\\n    }\\n    \\n    void proceed(int N, int i, int j) {\\n        if (outside(i, j))\\n            return;\\n        \\n        if (grid[i][j] == 1)\\n            dfs(i, j);\\n        else if (grid[i][j] == 0) {\\n            frontiers[N - 1].Add((i, j));\\n            perimeters[N - 1]++;            \\n        }\\n    }\\n    \\n    void dfs(int i, int j) {\\n        if (seen.Contains((i, j)))\\n            return;\\n        seen.Add((i, j));\\n        int N = regions.Count;\\n        regions[N - 1].Add((i, j));\\n        \\n        proceed(N, i - 1, j);\\n        proceed(N, i + 1, j);\\n        proceed(N, i, j - 1);\\n        proceed(N, i, j + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1001391,
                "title": "javascript-100-91-group-and-count",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar containVirus = function (grid) {\\n  if (!grid.length || !grid[0].length) return 0\\n  let BLOCKED = -1, HEALTHY = 0, UNGROUPED = 1//, GROUPED >=2\\n  let g = grid, walls = 0\\n  while (true) {\\n    // console.table(g)\\n    let [grouped, groupIds] = group(g)\\n    let [max, id, wallt] = findDangerGroup(groupIds)\\n    if (max == 0) return walls\\n    walls += wallt\\n    g = nextDay(grouped, id, groupIds)\\n  }\\n\\n  function nextDay(grouped = grid, id = 0, groupIds) {\\n    for (let i = 0; i < grouped.length; i++) {\\n      for (let j = 0; j < grouped[i].length; j++) {\\n        grouped[i][j] = grouped[i][j] == id\\n          ? -1\\n          : grouped[i][j] > 0 ? 1 : grouped[i][j]\\n      }\\n    }\\n    for (let [groupId, [cells]] of groupIds.entries()) {\\n      if (id == groupId) continue\\n      loopCells(cells, (i, j) => grouped[i][j] = 1)\\n    }\\n    return grouped\\n\\n    function loopCells(cells = new Map, cb = () => { }) {\\n      cells.forEach((jSet = new Set, i) => jSet.forEach(j => cb(i, j)))\\n    }\\n  }\\n\\n  function findDangerGroup(groupIds = new Map) {\\n    let max = 0, id = 0, wallt = 0\\n    for (let [groupId, [cells, countWalls, countCells]] of groupIds.entries()) {\\n      if (countCells > max) {\\n        max = countCells, id = groupId, wallt = countWalls\\n      }\\n    }\\n    return [max, id, wallt]\\n  }\\n\\n  //  [[0,1,0,0,0,0,0,1],   [[0,2,0,0,0,0,0,3],\\n  //  [0,1,0,0,0,0,0,1],    [0,2,0,0,0,0,0,3],\\n  //  [0,0,0,0,0,0,0,1], => [0,0,0,0,0,0,0,3],\\n  //  [0,0,0,0,0,0,0,0]]    [0,0,0,0,0,0,0,0]]\\n  function group(grid) {\\n    let idIterator = getGroupId(), groupIds = new Map\\n    for (let i = 0; i < grid.length; i++) {\\n      for (let j = 0; j < grid[i].length; j++) {\\n        if (grid[i][j] == UNGROUPED) {\\n          let groupId = idIterator.next()\\n          setGroup(i, j, groupId.value, grid)\\n        }\\n      }\\n    }\\n    return [grid, groupIds]\\n\\n    function setGroup(i, j, groupId, grid) {\\n      if (i < 0 || j < 0 || i >= grid.length || j >= grid[i].length) return\\n      if (grid[i][j] == BLOCKED) return\\n      if (grid[i][j] == HEALTHY) {\\n        if (!groupIds.has(groupId)) groupIds.set(groupId, [new Map, 0, 0])\\n        let groupArr = groupIds.get(groupId), groupCells = groupArr[0]\\n        if (!groupCells.has(i)) groupCells.set(i, new Set)\\n        let rowCells = groupCells.get(i)\\n        groupArr[1]++\\n        if (!rowCells.has(j)) groupArr[2]++\\n        return rowCells.add(j)\\n      }\\n      if (grid[i][j] > UNGROUPED) return\\n      grid[i][j] = groupId\\n      setGroup(i + 1, j, groupId, grid)\\n      setGroup(i - 1, j, groupId, grid)\\n      setGroup(i, j + 1, groupId, grid)\\n      setGroup(i, j - 1, groupId, grid)\\n    }\\n    function* getGroupId() {\\n      let i = 2\\n      while (true) {\\n        yield i\\n        i++\\n      }\\n    }\\n  }\\n};\\n\\n// console.log(containVirus([[0, 1, 0, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 1, 0], [0, 0, 0, 1, 1, 0, 0, 1, 1, 0], [0, 1, 0, 0, 1, 0, 1, 1, 0, 1], [0, 0, 0, 1, 0, 1, 0, 1, 1, 1], [0, 1, 0, 0, 1, 0, 0, 1, 1, 0], [0, 1, 0, 1, 0, 0, 0, 1, 1, 0], [0, 1, 1, 0, 0, 1, 1, 0, 0, 1], [1, 0, 1, 1, 0, 1, 0, 1, 0, 1]]\\n// ))\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar containVirus = function (grid) {\\n  if (!grid.length || !grid[0].length) return 0\\n  let BLOCKED = -1, HEALTHY = 0, UNGROUPED = 1//, GROUPED >=2\\n  let g = grid, walls = 0\\n  while (true) {\\n    // console.table(g)\\n    let [grouped, groupIds] = group(g)\\n    let [max, id, wallt] = findDangerGroup(groupIds)\\n    if (max == 0) return walls\\n    walls += wallt\\n    g = nextDay(grouped, id, groupIds)\\n  }\\n\\n  function nextDay(grouped = grid, id = 0, groupIds) {\\n    for (let i = 0; i < grouped.length; i++) {\\n      for (let j = 0; j < grouped[i].length; j++) {\\n        grouped[i][j] = grouped[i][j] == id\\n          ? -1\\n          : grouped[i][j] > 0 ? 1 : grouped[i][j]\\n      }\\n    }\\n    for (let [groupId, [cells]] of groupIds.entries()) {\\n      if (id == groupId) continue\\n      loopCells(cells, (i, j) => grouped[i][j] = 1)\\n    }\\n    return grouped\\n\\n    function loopCells(cells = new Map, cb = () => { }) {\\n      cells.forEach((jSet = new Set, i) => jSet.forEach(j => cb(i, j)))\\n    }\\n  }\\n\\n  function findDangerGroup(groupIds = new Map) {\\n    let max = 0, id = 0, wallt = 0\\n    for (let [groupId, [cells, countWalls, countCells]] of groupIds.entries()) {\\n      if (countCells > max) {\\n        max = countCells, id = groupId, wallt = countWalls\\n      }\\n    }\\n    return [max, id, wallt]\\n  }\\n\\n  //  [[0,1,0,0,0,0,0,1],   [[0,2,0,0,0,0,0,3],\\n  //  [0,1,0,0,0,0,0,1],    [0,2,0,0,0,0,0,3],\\n  //  [0,0,0,0,0,0,0,1], => [0,0,0,0,0,0,0,3],\\n  //  [0,0,0,0,0,0,0,0]]    [0,0,0,0,0,0,0,0]]\\n  function group(grid) {\\n    let idIterator = getGroupId(), groupIds = new Map\\n    for (let i = 0; i < grid.length; i++) {\\n      for (let j = 0; j < grid[i].length; j++) {\\n        if (grid[i][j] == UNGROUPED) {\\n          let groupId = idIterator.next()\\n          setGroup(i, j, groupId.value, grid)\\n        }\\n      }\\n    }\\n    return [grid, groupIds]\\n\\n    function setGroup(i, j, groupId, grid) {\\n      if (i < 0 || j < 0 || i >= grid.length || j >= grid[i].length) return\\n      if (grid[i][j] == BLOCKED) return\\n      if (grid[i][j] == HEALTHY) {\\n        if (!groupIds.has(groupId)) groupIds.set(groupId, [new Map, 0, 0])\\n        let groupArr = groupIds.get(groupId), groupCells = groupArr[0]\\n        if (!groupCells.has(i)) groupCells.set(i, new Set)\\n        let rowCells = groupCells.get(i)\\n        groupArr[1]++\\n        if (!rowCells.has(j)) groupArr[2]++\\n        return rowCells.add(j)\\n      }\\n      if (grid[i][j] > UNGROUPED) return\\n      grid[i][j] = groupId\\n      setGroup(i + 1, j, groupId, grid)\\n      setGroup(i - 1, j, groupId, grid)\\n      setGroup(i, j + 1, groupId, grid)\\n      setGroup(i, j - 1, groupId, grid)\\n    }\\n    function* getGroupId() {\\n      let i = 2\\n      while (true) {\\n        yield i\\n        i++\\n      }\\n    }\\n  }\\n};\\n\\n// console.log(containVirus([[0, 1, 0, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 1, 0], [0, 0, 0, 1, 1, 0, 0, 1, 1, 0], [0, 1, 0, 0, 1, 0, 1, 1, 0, 1], [0, 0, 0, 1, 0, 1, 0, 1, 1, 1], [0, 1, 0, 0, 1, 0, 0, 1, 1, 0], [0, 1, 0, 1, 0, 0, 0, 1, 1, 0], [0, 1, 1, 0, 0, 1, 1, 0, 0, 1], [1, 0, 1, 1, 0, 1, 0, 1, 0, 1]]\\n// ))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 916129,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\n    struct cluster {\\n        set<pair<int, int>> c;\\n        set<pair<int, int>> nc;\\n        int w = 0;\\n    };\\n    struct cmp {\\n        bool operator ()(cluster &a , cluster &b){\\n            return a.nc.size() < b.nc.size();\\n        }\\n    };\\npublic:\\n    int m, n;\\n    vector<vector<int>>g;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    void dfs(int i, int j, vector<vector<bool>>&vis, cluster &cl){\\n        if(i < 0 || i >= m || j < 0 || j >= n || vis[i][j] || g[i][j] == -1){\\n            return;\\n        }\\n        if(g[i][j] == 0){\\n            cl.nc.insert({i, j});\\n            cl.w++;\\n            return;\\n        }\\n        cl.c.insert({i, j});\\n        vis[i][j] = true;\\n        for(int k = 0; k < 4; k++){\\n            dfs(i + dx[k], j + dy[k], vis, cl);\\n        }\\n    }\\n    int containVirus(vector<vector<int>>& grid) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        g = grid;\\n        int ans = 0;\\n        while(true){\\n            vector<vector<bool>>vis(m, vector<bool>(n, false));\\n            priority_queue<cluster, vector<cluster>, cmp>pq;\\n            for(int i = 0; i < m; i++){\\n                for(int j = 0; j < n; j++){\\n                    if(!vis[i][j] && g[i][j] == 1){\\n                        cluster c;\\n                        dfs(i, j, vis, c);\\n                        pq.push(c);\\n                    }\\n                }\\n            }\\n            if(pq.size() == 0) break;\\n            cluster k = pq.top();\\n            pq.pop();\\n            ans += k.w;\\n            for(auto x : k.c){\\n                g[x.first][x.second] = -1;\\n            }\\n            while(!pq.empty()){\\n                cluster k1 = pq.top();\\n                pq.pop();\\n                for(auto x : k1.nc){\\n                    g[x.first][x.second] = 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    struct cluster {\\n        set<pair<int, int>> c;\\n        set<pair<int, int>> nc;\\n        int w = 0;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 894290,
                "title": "c-long-but-understandable-using-dfs-and-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs1(int i, int j, vector<vector<int>> &v, int n, int m){\\n        if(i<0 || j<0 || i>=n || j>=m || v[i][j]!=1)\\n            return;\\n        v[i][j]=-1;\\n        dfs1(i+1,j,v,n,m);\\n        dfs1(i,j+1,v,n,m);\\n        dfs1(i-1,j,v,n,m);\\n        dfs1(i,j-1,v,n,m);\\n    }\\n    void dfs(int i, int j, vector<vector<int>> &v, vector<vector<bool>> &visit, int n, int m, int &cnt, int &rt, vector<vector<bool>> &anvis){\\n        if(i<0 || j<0 || i>=n || j>=m || visit[i][j]==true || v[i][j]!=1)\\n            return;\\n        int flag=0;\\n        if(i+1<n && v[i+1][j]==0){\\n            flag++;\\n            if(anvis[i+1][j]==false){\\n                anvis[i+1][j]=true;\\n                rt++;\\n            }\\n        }\\n        if(i-1>=0 && v[i-1][j]==0){\\n            flag++;\\n            if(anvis[i-1][j]==false){\\n                anvis[i-1][j]=true;\\n                rt++;\\n            }\\n        }\\n        if(j+1<m && v[i][j+1]==0){\\n            flag++;\\n            if(anvis[i][j+1]==false){\\n                anvis[i][j+1]=true;\\n                rt++;\\n            }\\n        }\\n        if(j-1>=0 && v[i][j-1]==0){\\n            flag++;\\n            if(anvis[i][j-1]==false){\\n                anvis[i][j-1]=true;\\n                rt++;\\n            }\\n        }\\n        cnt+=flag;\\n        visit[i][j]=true;\\n        dfs(i+1,j,v,visit,n,m,cnt,rt,anvis);\\n        dfs(i,j+1,v,visit,n,m,cnt,rt,anvis);\\n        dfs(i-1,j,v,visit,n,m,cnt,rt,anvis);\\n        dfs(i,j-1,v,visit,n,m,cnt,rt,anvis);\\n    }\\n    int containVirus(vector<vector<int>>& v) {\\n        int n = v.size();\\n        if(n==0)\\n            return 0;\\n        int m = v[0].size();\\n        static int x[]={1,0,-1,0};\\n        static int y[]={0,1,0,-1};\\n        int ans = 0;\\n        while(true){\\n            vector<vector<bool>> visit(n+1,vector<bool>(m+1,false));\\n            int st=-1,en=-1;\\n            int maxi = 0;\\n            int peri = 0;\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<m;j++){\\n                    if(v[i][j]==1 && visit[i][j]==false){\\n                        vector<vector<bool>> anvis(n+1,vector<bool>(m+1,false));\\n                        int cnt = 0;\\n                        int rt = 0;\\n                        dfs(i,j,v,visit,n,m,cnt,rt,anvis);\\n                        if(rt>maxi){\\n                            maxi=rt;\\n                            peri=cnt;\\n                            st=i;\\n                            en=j;\\n                        }\\n                    }\\n                }\\n            }\\n            if(maxi==0)\\n                return ans;\\n            ans+=peri;\\n            dfs1(st,en,v,n,m);\\n            queue<pair<int,int>> q;\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<m;j++){\\n                    if(v[i][j]==1){\\n                        q.push({i,j});\\n                    }\\n                }\\n            }\\n            while(!q.empty()){\\n                int a = q.front().first;\\n                int b = q.front().second;\\n                q.pop();\\n                for(int k=0;k<4;k++){\\n                    int r = a+x[k];\\n                    int s = b+y[k];\\n                    if(r>=0 && r<n && s>=0 && s<m && v[r][s]==0){\\n                        v[r][s]=1;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs1(int i, int j, vector<vector<int>> &v, int n, int m){\\n        if(i<0 || j<0 || i>=n || j>=m || v[i][j]!=1)\\n            return;\\n        v[i][j]=-1;\\n        dfs1(i+1,j,v,n,m);\\n        dfs1(i,j+1,v,n,m);\\n        dfs1(i-1,j,v,n,m);\\n        dfs1(i,j-1,v,n,m);\\n    }\\n    void dfs(int i, int j, vector<vector<int>> &v, vector<vector<bool>> &visit, int n, int m, int &cnt, int &rt, vector<vector<bool>> &anvis){\\n        if(i<0 || j<0 || i>=n || j>=m || visit[i][j]==true || v[i][j]!=1)\\n            return;\\n        int flag=0;\\n        if(i+1<n && v[i+1][j]==0){\\n            flag++;\\n            if(anvis[i+1][j]==false){\\n                anvis[i+1][j]=true;\\n                rt++;\\n            }\\n        }\\n        if(i-1>=0 && v[i-1][j]==0){\\n            flag++;\\n            if(anvis[i-1][j]==false){\\n                anvis[i-1][j]=true;\\n                rt++;\\n            }\\n        }\\n        if(j+1<m && v[i][j+1]==0){\\n            flag++;\\n            if(anvis[i][j+1]==false){\\n                anvis[i][j+1]=true;\\n                rt++;\\n            }\\n        }\\n        if(j-1>=0 && v[i][j-1]==0){\\n            flag++;\\n            if(anvis[i][j-1]==false){\\n                anvis[i][j-1]=true;\\n                rt++;\\n            }\\n        }\\n        cnt+=flag;\\n        visit[i][j]=true;\\n        dfs(i+1,j,v,visit,n,m,cnt,rt,anvis);\\n        dfs(i,j+1,v,visit,n,m,cnt,rt,anvis);\\n        dfs(i-1,j,v,visit,n,m,cnt,rt,anvis);\\n        dfs(i,j-1,v,visit,n,m,cnt,rt,anvis);\\n    }\\n    int containVirus(vector<vector<int>>& v) {\\n        int n = v.size();\\n        if(n==0)\\n            return 0;\\n        int m = v[0].size();\\n        static int x[]={1,0,-1,0};\\n        static int y[]={0,1,0,-1};\\n        int ans = 0;\\n        while(true){\\n            vector<vector<bool>> visit(n+1,vector<bool>(m+1,false));\\n            int st=-1,en=-1;\\n            int maxi = 0;\\n            int peri = 0;\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<m;j++){\\n                    if(v[i][j]==1 && visit[i][j]==false){\\n                        vector<vector<bool>> anvis(n+1,vector<bool>(m+1,false));\\n                        int cnt = 0;\\n                        int rt = 0;\\n                        dfs(i,j,v,visit,n,m,cnt,rt,anvis);\\n                        if(rt>maxi){\\n                            maxi=rt;\\n                            peri=cnt;\\n                            st=i;\\n                            en=j;\\n                        }\\n                    }\\n                }\\n            }\\n            if(maxi==0)\\n                return ans;\\n            ans+=peri;\\n            dfs1(st,en,v,n,m);\\n            queue<pair<int,int>> q;\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<m;j++){\\n                    if(v[i][j]==1){\\n                        q.push({i,j});\\n                    }\\n                }\\n            }\\n            while(!q.empty()){\\n                int a = q.front().first;\\n                int b = q.front().second;\\n                q.pop();\\n                for(int k=0;k<4;k++){\\n                    int r = a+x[k];\\n                    int s = b+y[k];\\n                    if(r>=0 && r<n && s>=0 && s<m && v[r][s]==0){\\n                        v[r][s]=1;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 894186,
                "title": "c-dfs",
                "content": "```\\n    struct CompareVal{\\n        bool operator()(const pair<int, pair<int, int>> & p1, const pair<int, pair<int, int>> & p2){\\n            return p1.first < p2.first;\\n        }\\n    };\\n    \\n    bool valid(int x, int y, int m, int n){\\n        return (x>=0 && x<m && y>=0 && y<n);\\n    }\\n    \\n    \\n    void contaminate(vector<vector<int>> & grid, int x0, int y0, int m, int n, int dx[], int dy[] ,vector<vector<bool>> & visited){\\n        visited[x0][y0] = true;\\n        for(int i=0;i<4;i++){\\n            int x1 = x0 + dx[i];\\n            int y1 = y0 + dy[i];\\n            if(valid(x1, y1, m, n) && !visited[x1][y1] && grid[x1][y1] == 1)\\n                contaminate(grid, x1, y1, m, n, dx, dy, visited);\\n            else if(valid(x1, y1, m, n) && grid[x1][y1] == 0){\\n                grid[x1][y1] = 1;\\n                visited[x1][y1] = true;\\n            }\\n        }\\n    }\\n    \\n    void buildWall(vector<vector<int>> & grid, int x0, int y0, int m, int n, int dx[], int dy[] ,vector<vector<bool>> & visited){\\n        visited[x0][y0] = true;\\n        grid[x0][y0] = -1;\\n        for(int i=0;i<4;i++){\\n            int x1 = x0 + dx[i];\\n            int y1 = y0 + dy[i];\\n            if(valid(x1, y1, m, n) && !visited[x1][y1] && grid[x1][y1] == 1)\\n                buildWall(grid, x1, y1, m, n, dx, dy, visited);\\n        }\\n    }\\n    \\n    \\n    \\n    void dfs(vector<vector<int>> & grid, int x0, int y0, int m, int n, int dx[], int dy[] ,vector<vector<bool>> & visited, set<pair<int, int>> & st, \\n             int & count){\\n        visited[x0][y0] = true;\\n        for(int i=0;i<4;i++){\\n            int x1 = x0 + dx[i];\\n            int y1 = y0 + dy[i];\\n            if(valid(x1, y1, m, n) && !visited[x1][y1] && grid[x1][y1] == 1)\\n                dfs(grid, x1, y1, m, n, dx, dy, visited, st, count);\\n            if(valid(x1, y1, m, n) && grid[x1][y1] == 0 )\\n                count++;\\n            if(valid(x1, y1, m, n) && grid[x1][y1] == 0 && st.find({x1, y1}) == st.end())\\n                st.insert({x1, y1});\\n        }\\n    }\\n    \\n    \\n    \\n    \\n    int containVirus(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        if(!m)\\n            return 0;\\n        int n = grid[0].size();\\n        if(!n)\\n            return 0;\\n        int dx[4] = {0, 1, 0, -1};\\n        int dy[4] = {1, 0, -1, 0};\\n        int ans = 0;\\n        \\n        priority_queue< pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, CompareVal > pq;\\n        while(1){\\n            vector<vector<bool>>  visited(m, vector<bool>(n, false));\\n            map<pair<int, int>, int> m1;\\n            for(int i=0;i<m;i++){\\n                for(int j=0;j<n;j++){\\n                    if(grid[i][j] == 1 && !visited[i][j]){\\n                        set<pair<int, int>> st;\\n                        int count = 0;\\n                        dfs(grid, i, j, m, n, dx, dy, visited, st,  count);\\n                        pq.push({st.size(), {i, j}});\\n                        m1[{i, j}] = count;\\n                    }\\n                }\\n            }\\n            \\n            if(pq.size() == 0)\\n                break;\\n            \\n            pair<int, pair<int, int>> p = pq.top();\\n            pq.pop();\\n            ans+=m1[{p.second.first, p.second.second}];\\n            vector<vector<bool>>  visitedBuildWall(m, vector<bool>(n, false));\\n            buildWall(grid, p.second.first, p.second.second, m, n, dx, dy, visitedBuildWall);\\n            vector<vector<bool>>  visitedContamination(m, vector<bool>(n, false));\\n            while(!pq.empty()){\\n                contaminate(grid, pq.top().second.first, pq.top().second.second, m, n, dx, dy, visitedContamination);\\n                pq.pop();\\n            }\\n            \\n            \\n        }\\n        return ans;\\n\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    struct CompareVal{\\n        bool operator()(const pair<int, pair<int, int>> & p1, const pair<int, pair<int, int>> & p2){\\n            return p1.first < p2.first;\\n        }\\n    };\\n    \\n    bool valid(int x, int y, int m, int n){\\n        return (x>=0 && x<m && y>=0 && y<n);\\n    }\\n    \\n    \\n    void contaminate(vector<vector<int>> & grid, int x0, int y0, int m, int n, int dx[], int dy[] ,vector<vector<bool>> & visited){\\n        visited[x0][y0] = true;\\n        for(int i=0;i<4;i++){\\n            int x1 = x0 + dx[i];\\n            int y1 = y0 + dy[i];\\n            if(valid(x1, y1, m, n) && !visited[x1][y1] && grid[x1][y1] == 1)\\n                contaminate(grid, x1, y1, m, n, dx, dy, visited);\\n            else if(valid(x1, y1, m, n) && grid[x1][y1] == 0){\\n                grid[x1][y1] = 1;\\n                visited[x1][y1] = true;\\n            }\\n        }\\n    }\\n    \\n    void buildWall(vector<vector<int>> & grid, int x0, int y0, int m, int n, int dx[], int dy[] ,vector<vector<bool>> & visited){\\n        visited[x0][y0] = true;\\n        grid[x0][y0] = -1;\\n        for(int i=0;i<4;i++){\\n            int x1 = x0 + dx[i];\\n            int y1 = y0 + dy[i];\\n            if(valid(x1, y1, m, n) && !visited[x1][y1] && grid[x1][y1] == 1)\\n                buildWall(grid, x1, y1, m, n, dx, dy, visited);\\n        }\\n    }\\n    \\n    \\n    \\n    void dfs(vector<vector<int>> & grid, int x0, int y0, int m, int n, int dx[], int dy[] ,vector<vector<bool>> & visited, set<pair<int, int>> & st, \\n             int & count){\\n        visited[x0][y0] = true;\\n        for(int i=0;i<4;i++){\\n            int x1 = x0 + dx[i];\\n            int y1 = y0 + dy[i];\\n            if(valid(x1, y1, m, n) && !visited[x1][y1] && grid[x1][y1] == 1)\\n                dfs(grid, x1, y1, m, n, dx, dy, visited, st, count);\\n            if(valid(x1, y1, m, n) && grid[x1][y1] == 0 )\\n                count++;\\n            if(valid(x1, y1, m, n) && grid[x1][y1] == 0 && st.find({x1, y1}) == st.end())\\n                st.insert({x1, y1});\\n        }\\n    }\\n    \\n    \\n    \\n    \\n    int containVirus(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        if(!m)\\n            return 0;\\n        int n = grid[0].size();\\n        if(!n)\\n            return 0;\\n        int dx[4] = {0, 1, 0, -1};\\n        int dy[4] = {1, 0, -1, 0};\\n        int ans = 0;\\n        \\n        priority_queue< pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, CompareVal > pq;\\n        while(1){\\n            vector<vector<bool>>  visited(m, vector<bool>(n, false));\\n            map<pair<int, int>, int> m1;\\n            for(int i=0;i<m;i++){\\n                for(int j=0;j<n;j++){\\n                    if(grid[i][j] == 1 && !visited[i][j]){\\n                        set<pair<int, int>> st;\\n                        int count = 0;\\n                        dfs(grid, i, j, m, n, dx, dy, visited, st,  count);\\n                        pq.push({st.size(), {i, j}});\\n                        m1[{i, j}] = count;\\n                    }\\n                }\\n            }\\n            \\n            if(pq.size() == 0)\\n                break;\\n            \\n            pair<int, pair<int, int>> p = pq.top();\\n            pq.pop();\\n            ans+=m1[{p.second.first, p.second.second}];\\n            vector<vector<bool>>  visitedBuildWall(m, vector<bool>(n, false));\\n            buildWall(grid, p.second.first, p.second.second, m, n, dx, dy, visitedBuildWall);\\n            vector<vector<bool>>  visitedContamination(m, vector<bool>(n, false));\\n            while(!pq.empty()){\\n                contaminate(grid, pq.top().second.first, pq.top().second.second, m, n, dx, dy, visitedContamination);\\n                pq.pop();\\n            }\\n            \\n            \\n        }\\n        return ans;\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 892024,
                "title": "rust-translated-8ms-100",
                "content": "```rust\\nimpl Solution {\\n    pub fn contain_virus(mut grid: Vec<Vec<i32>>) -> i32 {\\n        use std::collections::HashSet;\\n\\n        const DIRS: [i32; 5] = [0, -1, 0, 1, 0];\\n\\n        fn dfs(\\n            grid: &mut Vec<Vec<i32>>,\\n            regions: &mut Vec<HashSet<i32>>,\\n            frontiers: &mut Vec<HashSet<i32>>,\\n            perimeters: &mut Vec<i32>,\\n            visited: &mut HashSet<i32>,\\n            r: i32,\\n            c: i32,\\n        ) {\\n            let m = grid.len();\\n            let n = grid[0].len();\\n            if !visited.contains(&(r * n as i32 + c as i32)) {\\n                visited.insert(r * n as i32 + c as i32);\\n            }\\n            let n2 = regions.len();\\n            regions[n2 - 1].insert(r * n as i32 + c as i32);\\n            for k in 0..4 {\\n                let nr = r + DIRS[k];\\n                let nc = c + DIRS[k + 1];\\n                if nr >= 0 && nr < m as i32 && nc >= 0 && nc < n as i32 {\\n                    if grid[nr as usize][nc as usize] == 1\\n                        && !visited.contains(&(nr * n as i32 + nc as i32))\\n                    {\\n                        dfs(grid, regions, frontiers, perimeters, visited, nr, nc);\\n                    } else if grid[nr as usize][nc as usize] == 0 {\\n                        frontiers[n2 - 1].insert(nr * n as i32 + nc);\\n                        perimeters[n2 - 1] += 1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        let mut visited = HashSet::<i32>::new();\\n        let mut regions = Vec::<HashSet<i32>>::new();\\n        let mut frontiers = Vec::<HashSet<i32>>::new();\\n        let mut perimeters = Vec::<i32>::new();\\n        let m = grid.len();\\n        let n = grid[0].len();\\n        let mut ans = 0;\\n        loop {\\n            visited.clear();\\n            regions.clear();\\n            frontiers.clear();\\n            perimeters.clear();\\n            for r in 0..m {\\n                for c in 0..n {\\n                    if grid[r][c] == 1 && !visited.contains(&((r * n + c) as i32)) {\\n                        regions.push(HashSet::new());\\n                        frontiers.push(HashSet::new());\\n                        perimeters.push(0);\\n                        dfs(\\n                            &mut grid,\\n                            &mut regions,\\n                            &mut frontiers,\\n                            &mut perimeters,\\n                            &mut visited,\\n                            r as i32,\\n                            c as i32,\\n                        );\\n                    }\\n                }\\n            }\\n            if regions.is_empty() {\\n                break;\\n            }\\n\\n            let mut triage_index = 0;\\n            for i in 0..frontiers.len() {\\n                if frontiers[triage_index].len() < frontiers[i].len() {\\n                    triage_index = i;\\n                }\\n            }\\n\\n            ans += perimeters.get(triage_index).unwrap_or_else(|| &0);\\n\\n            for i in 0..regions.len() {\\n                if i == triage_index {\\n                    for &code in &regions[i] {\\n                        grid[code as usize / n][code as usize % n] = -1;\\n                    }\\n                } else {\\n                    for &code in &regions[i] {\\n                        let r = code / n as i32;\\n                        let c = code % n as i32;\\n                        for k in 0..4 {\\n                            let nr = r + DIRS[k];\\n                            let nc = c + DIRS[k + 1];\\n                            if nr >= 0\\n                                && nr < m as i32\\n                                && nc >= 0\\n                                && nc < n as i32\\n                                && grid[nr as usize][nc as usize] == 0\\n                            {\\n                                grid[nr as usize][nc as usize] = 1;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        ans\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_contain_virus() {\\n        assert_eq!(\\n            Solution::contain_virus(vec![\\n                vec![0, 1, 0, 0, 0, 0, 0, 1],\\n                vec![0, 1, 0, 0, 0, 0, 0, 1],\\n                vec![0, 0, 0, 0, 0, 0, 0, 1],\\n                vec![0, 0, 0, 0, 0, 0, 0, 0]\\n            ]),\\n            10\\n        );\\n    }\\n\\n    #[test]\\n    fn test_contain_virus_02() {\\n        assert_eq!(\\n            Solution::contain_virus(vec![vec![1, 1, 1], vec![1, 0, 1], vec![1, 1, 1]]),\\n            4\\n        );\\n    }\\n\\n    #[test]\\n    fn test_contain_virus_03() {\\n        assert_eq!(\\n            Solution::contain_virus(vec![\\n                vec![1, 1, 1, 0, 0, 0, 0, 0, 0],\\n                vec![1, 0, 1, 0, 1, 1, 1, 1, 1],\\n                vec![1, 1, 1, 0, 0, 0, 0, 0, 0]\\n            ]),\\n            13\\n        );\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn contain_virus(mut grid: Vec<Vec<i32>>) -> i32 {\\n        use std::collections::HashSet;\\n\\n        const DIRS: [i32; 5] = [0, -1, 0, 1, 0];\\n\\n        fn dfs(\\n            grid: &mut Vec<Vec<i32>>,\\n            regions: &mut Vec<HashSet<i32>>,\\n            frontiers: &mut Vec<HashSet<i32>>,\\n            perimeters: &mut Vec<i32>,\\n            visited: &mut HashSet<i32>,\\n            r: i32,\\n            c: i32,\\n        ) {\\n            let m = grid.len();\\n            let n = grid[0].len();\\n            if !visited.contains(&(r * n as i32 + c as i32)) {\\n                visited.insert(r * n as i32 + c as i32);\\n            }\\n            let n2 = regions.len();\\n            regions[n2 - 1].insert(r * n as i32 + c as i32);\\n            for k in 0..4 {\\n                let nr = r + DIRS[k];\\n                let nc = c + DIRS[k + 1];\\n                if nr >= 0 && nr < m as i32 && nc >= 0 && nc < n as i32 {\\n                    if grid[nr as usize][nc as usize] == 1\\n                        && !visited.contains(&(nr * n as i32 + nc as i32))\\n                    {\\n                        dfs(grid, regions, frontiers, perimeters, visited, nr, nc);\\n                    } else if grid[nr as usize][nc as usize] == 0 {\\n                        frontiers[n2 - 1].insert(nr * n as i32 + nc);\\n                        perimeters[n2 - 1] += 1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        let mut visited = HashSet::<i32>::new();\\n        let mut regions = Vec::<HashSet<i32>>::new();\\n        let mut frontiers = Vec::<HashSet<i32>>::new();\\n        let mut perimeters = Vec::<i32>::new();\\n        let m = grid.len();\\n        let n = grid[0].len();\\n        let mut ans = 0;\\n        loop {\\n            visited.clear();\\n            regions.clear();\\n            frontiers.clear();\\n            perimeters.clear();\\n            for r in 0..m {\\n                for c in 0..n {\\n                    if grid[r][c] == 1 && !visited.contains(&((r * n + c) as i32)) {\\n                        regions.push(HashSet::new());\\n                        frontiers.push(HashSet::new());\\n                        perimeters.push(0);\\n                        dfs(\\n                            &mut grid,\\n                            &mut regions,\\n                            &mut frontiers,\\n                            &mut perimeters,\\n                            &mut visited,\\n                            r as i32,\\n                            c as i32,\\n                        );\\n                    }\\n                }\\n            }\\n            if regions.is_empty() {\\n                break;\\n            }\\n\\n            let mut triage_index = 0;\\n            for i in 0..frontiers.len() {\\n                if frontiers[triage_index].len() < frontiers[i].len() {\\n                    triage_index = i;\\n                }\\n            }\\n\\n            ans += perimeters.get(triage_index).unwrap_or_else(|| &0);\\n\\n            for i in 0..regions.len() {\\n                if i == triage_index {\\n                    for &code in &regions[i] {\\n                        grid[code as usize / n][code as usize % n] = -1;\\n                    }\\n                } else {\\n                    for &code in &regions[i] {\\n                        let r = code / n as i32;\\n                        let c = code % n as i32;\\n                        for k in 0..4 {\\n                            let nr = r + DIRS[k];\\n                            let nc = c + DIRS[k + 1];\\n                            if nr >= 0\\n                                && nr < m as i32\\n                                && nc >= 0\\n                                && nc < n as i32\\n                                && grid[nr as usize][nc as usize] == 0\\n                            {\\n                                grid[nr as usize][nc as usize] = 1;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        ans\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_contain_virus() {\\n        assert_eq!(\\n            Solution::contain_virus(vec![\\n                vec![0, 1, 0, 0, 0, 0, 0, 1],\\n                vec![0, 1, 0, 0, 0, 0, 0, 1],\\n                vec![0, 0, 0, 0, 0, 0, 0, 1],\\n                vec![0, 0, 0, 0, 0, 0, 0, 0]\\n            ]),\\n            10\\n        );\\n    }\\n\\n    #[test]\\n    fn test_contain_virus_02() {\\n        assert_eq!(\\n            Solution::contain_virus(vec![vec![1, 1, 1], vec![1, 0, 1], vec![1, 1, 1]]),\\n            4\\n        );\\n    }\\n\\n    #[test]\\n    fn test_contain_virus_03() {\\n        assert_eq!(\\n            Solution::contain_virus(vec![\\n                vec![1, 1, 1, 0, 0, 0, 0, 0, 0],\\n                vec![1, 0, 1, 0, 1, 1, 1, 1, 1],\\n                vec![1, 1, 1, 0, 0, 0, 0, 0, 0]\\n            ]),\\n            13\\n        );\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 849429,
                "title": "is-this-normal",
                "content": "\\n```\\n[[0,0,0,0,0,0,1,1], \\n [0,0,0,0,0,0,0,1],\\n [0,0,0,0,0,0,1,1],\\n [0,0,0,0,0,0,1,1]]\\n```\\nExpected output is 6, but the checker says Wrong Answer for 4. You only need 4 walls to contain this, not 6.",
                "solutionTags": [],
                "code": "```\\n[[0,0,0,0,0,0,1,1], \\n [0,0,0,0,0,0,0,1],\\n [0,0,0,0,0,0,1,1],\\n [0,0,0,0,0,0,1,1]]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 791101,
                "title": "java-bfs-solution",
                "content": "```\\nclass Solution {\\n    HashSet<Integer> seen;\\n    List<HashSet<Integer>> regions;\\n    List<HashSet<Integer>> neighbours;\\n    List<Integer> perimiters;\\n    int [][] grid;\\n    int [][] dirs;\\n    int ROW;\\n    int COL;\\n    public int containVirus(int[][] grids) {\\n        this.grid = grids;\\n        this.ROW = grid.length;\\n        this.COL = grid[0].length;\\n        this.dirs = new int [][]{{-1,0},{1,0},{0,1},{0,-1}};\\n        int result = 0;\\n        while(true){\\n            this.seen = new HashSet();\\n            this.regions = new ArrayList();\\n            this.neighbours = new ArrayList();\\n            this.perimiters = new ArrayList();\\n            for(int r =0;r<grid.length;r++){\\n                for(int c =0;c<grid[r].length;c++){\\n                    int getIndex = COL*r+c;\\n                    if(grid[r][c] == 1 && !this.seen.contains(getIndex)){\\n                        this.regions.add(new HashSet());\\n                        this.neighbours.add(new HashSet());\\n                        this.perimiters.add(0);\\n                        bfs(r,c);\\n                    }\\n                }\\n            }\\n            if(regions.size() == 0)\\n                break;\\n            int boundaryRegionIndex = 0;\\n            for(int i =0;i<neighbours.size();i++){\\n                HashSet<Integer> neighbour = neighbours.get(i);\\n                boundaryRegionIndex = neighbour.size() > neighbours.get(boundaryRegionIndex).size()?i:boundaryRegionIndex;\\n                }\\n            for(int i =0;i<regions.size();i++){\\n                if(i == boundaryRegionIndex){\\n                    HashSet<Integer> region = regions.get(i);\\n                    Iterator<Integer> itr = region.iterator();\\n                    while(itr.hasNext()){\\n                        int index = itr.next();\\n                        int r = index/COL;\\n                        int c = index%COL;\\n                        this.grid[r][c] = -1;\\n                    }\\n                    result += perimiters.get(i);\\n                }\\n                else{\\n                     HashSet<Integer> neighbour = neighbours.get(i);\\n                        Iterator<Integer> itr = neighbour.iterator();\\n                         while(itr.hasNext()){\\n                             int index = itr.next();\\n                             int r = index/COL;\\n                             int c = index%COL;\\n                             this.grid[r][c] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private void bfs(int row, int col){\\n        Queue<Integer> queue = new LinkedList();\\n        queue.add(COL*row+col);\\n        seen.add(COL*row+col);\\n        while(queue.size() > 0){\\n            int index = queue.poll();\\n            regions.get(regions.size()-1).add(index);\\n            int r = index/COL;\\n            int c = index%COL;\\n            for(int [] dir : dirs){\\n                int nextRow = r + dir[0];\\n                int nextCol = c + dir[1];\\n                int nextIndex = COL*nextRow+nextCol;\\n                if(nextRow >=0 && nextRow < ROW && nextCol >=0 && nextCol < COL){\\n                    if(grid[nextRow][nextCol] == 0){\\n                        neighbours.get(neighbours.size()-1).add(nextIndex);\\n                        perimiters.set(perimiters.size()-1, perimiters.get(perimiters.size()-1)+1);\\n                    }\\n                    else if(grid[nextRow][nextCol] == 1 && !seen.contains(nextIndex)){\\n                        seen.add(nextIndex);\\n                        queue.add(nextIndex);\\n                    }\\n                }\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    HashSet<Integer> seen;\\n    List<HashSet<Integer>> regions;\\n    List<HashSet<Integer>> neighbours;\\n    List<Integer> perimiters;\\n    int [][] grid;\\n    int [][] dirs;\\n    int ROW;\\n    int COL;\\n    public int containVirus(int[][] grids) {\\n        this.grid = grids;\\n        this.ROW = grid.length;\\n        this.COL = grid[0].length;\\n        this.dirs = new int [][]{{-1,0},{1,0},{0,1},{0,-1}};\\n        int result = 0;\\n        while(true){\\n            this.seen = new HashSet();\\n            this.regions = new ArrayList();\\n            this.neighbours = new ArrayList();\\n            this.perimiters = new ArrayList();\\n            for(int r =0;r<grid.length;r++){\\n                for(int c =0;c<grid[r].length;c++){\\n                    int getIndex = COL*r+c;\\n                    if(grid[r][c] == 1 && !this.seen.contains(getIndex)){\\n                        this.regions.add(new HashSet());\\n                        this.neighbours.add(new HashSet());\\n                        this.perimiters.add(0);\\n                        bfs(r,c);\\n                    }\\n                }\\n            }\\n            if(regions.size() == 0)\\n                break;\\n            int boundaryRegionIndex = 0;\\n            for(int i =0;i<neighbours.size();i++){\\n                HashSet<Integer> neighbour = neighbours.get(i);\\n                boundaryRegionIndex = neighbour.size() > neighbours.get(boundaryRegionIndex).size()?i:boundaryRegionIndex;\\n                }\\n            for(int i =0;i<regions.size();i++){\\n                if(i == boundaryRegionIndex){\\n                    HashSet<Integer> region = regions.get(i);\\n                    Iterator<Integer> itr = region.iterator();\\n                    while(itr.hasNext()){\\n                        int index = itr.next();\\n                        int r = index/COL;\\n                        int c = index%COL;\\n                        this.grid[r][c] = -1;\\n                    }\\n                    result += perimiters.get(i);\\n                }\\n                else{\\n                     HashSet<Integer> neighbour = neighbours.get(i);\\n                        Iterator<Integer> itr = neighbour.iterator();\\n                         while(itr.hasNext()){\\n                             int index = itr.next();\\n                             int r = index/COL;\\n                             int c = index%COL;\\n                             this.grid[r][c] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private void bfs(int row, int col){\\n        Queue<Integer> queue = new LinkedList();\\n        queue.add(COL*row+col);\\n        seen.add(COL*row+col);\\n        while(queue.size() > 0){\\n            int index = queue.poll();\\n            regions.get(regions.size()-1).add(index);\\n            int r = index/COL;\\n            int c = index%COL;\\n            for(int [] dir : dirs){\\n                int nextRow = r + dir[0];\\n                int nextCol = c + dir[1];\\n                int nextIndex = COL*nextRow+nextCol;\\n                if(nextRow >=0 && nextRow < ROW && nextCol >=0 && nextCol < COL){\\n                    if(grid[nextRow][nextCol] == 0){\\n                        neighbours.get(neighbours.size()-1).add(nextIndex);\\n                        perimiters.set(perimiters.size()-1, perimiters.get(perimiters.size()-1)+1);\\n                    }\\n                    else if(grid[nextRow][nextCol] == 1 && !seen.contains(nextIndex)){\\n                        seen.add(nextIndex);\\n                        queue.add(nextIndex);\\n                    }\\n                }\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 684701,
                "title": "java-union-find-solution",
                "content": "```\\n    int[] p;\\n    Map<Integer, Set<Integer>> affected;\\n    Map<Integer, Set<Integer>> toAffect;\\n\\n    public int containVirus(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        p = new int[m * n];\\n        int[][] dirs = new int[][]{{-1,0}, {1,0}, {0,-1}, {0,1}};\\n        int walls = 0;\\n        do{\\n            for(int i = 0; i < p.length; i++) p[i] = i;\\n            affected = new HashMap<>();\\n            toAffect = new HashMap<>();\\n            for(int i = 0; i < m; i++) {\\n                for(int j = 0; j < n; j++) {\\n                    if(grid[i][j] == 1) {\\n                        int index = i * n + j;\\n                        if(!affected.containsKey(index)) affected.put(index, new HashSet<>());\\n                        if(!toAffect.containsKey(index)) toAffect.put(index, new HashSet<>());\\n                        affected.get(index).add(index);\\n                        for(int[] dir : dirs) {\\n                            int row = i + dir[0], col = j + dir[1];\\n                            if(row >= 0 && row < m && col >= 0 && col < n && grid[row][col] == 0) toAffect.get(index).add(row * n + col);\\n                        }\\n                        if(i > 0 && grid[i-1][j] == 1) union(index, index - n);\\n                        if(j > 0 && grid[i][j-1] == 1) union(index, index - 1);\\n                    }\\n                }\\n            }\\n            if(toAffect.size() == 0 || affected.size() == 0) return walls;\\n            int maxIndex = toAffect.keySet().iterator().next();\\n            for(int index : toAffect.keySet()) if(toAffect.get(index).size() > toAffect.get(maxIndex).size()) maxIndex = index;\\n            for(int index : affected.get(maxIndex)) {\\n                int i = index / n;\\n                int j = index % n;\\n                for(int[] dir : dirs) {\\n                    int row = i + dir[0], col = j + dir[1];\\n                    if(row >= 0 && row < m && col >= 0 && col < n && grid[row][col] == 0) walls++;\\n                }\\n                grid[i][j] = -1;\\n            }\\n            for(int index : toAffect.keySet()) {\\n                if(index != maxIndex) {\\n                    for(int to : toAffect.get(index)) {\\n                        grid[to / n][to % n] = 1;\\n                    }\\n                }\\n            }\\n        }while (affected.size() > 1);\\n        return walls;\\n    }\\n\\n    private int find(int pos) {\\n        if(p[pos] == pos) return pos;\\n        return find(p[pos]);\\n    }\\n\\n    private void union(int c1, int c2) {\\n        int p1 = find(c1);\\n        int p2 = find(c2);\\n        if(p1 != p2) {\\n            p[p2] = p1;\\n            if(!affected.containsKey(p1)) affected.put(p1, new HashSet<>());\\n            toAffect.get(p1).addAll(toAffect.get(p2));\\n            toAffect.remove(p2);\\n            affected.get(p1).addAll(affected.get(p2));\\n            affected.remove(p2);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int[] p;\\n    Map<Integer, Set<Integer>> affected;\\n    Map<Integer, Set<Integer>> toAffect;\\n\\n    public int containVirus(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        p = new int[m * n];\\n        int[][] dirs = new int[][]{{-1,0}, {1,0}, {0,-1}, {0,1}};\\n        int walls = 0;\\n        do{\\n            for(int i = 0; i < p.length; i++) p[i] = i;\\n            affected = new HashMap<>();\\n            toAffect = new HashMap<>();\\n            for(int i = 0; i < m; i++) {\\n                for(int j = 0; j < n; j++) {\\n                    if(grid[i][j] == 1) {\\n                        int index = i * n + j;\\n                        if(!affected.containsKey(index)) affected.put(index, new HashSet<>());\\n                        if(!toAffect.containsKey(index)) toAffect.put(index, new HashSet<>());\\n                        affected.get(index).add(index);\\n                        for(int[] dir : dirs) {\\n                            int row = i + dir[0], col = j + dir[1];\\n                            if(row >= 0 && row < m && col >= 0 && col < n && grid[row][col] == 0) toAffect.get(index).add(row * n + col);\\n                        }\\n                        if(i > 0 && grid[i-1][j] == 1) union(index, index - n);\\n                        if(j > 0 && grid[i][j-1] == 1) union(index, index - 1);\\n                    }\\n                }\\n            }\\n            if(toAffect.size() == 0 || affected.size() == 0) return walls;\\n            int maxIndex = toAffect.keySet().iterator().next();\\n            for(int index : toAffect.keySet()) if(toAffect.get(index).size() > toAffect.get(maxIndex).size()) maxIndex = index;\\n            for(int index : affected.get(maxIndex)) {\\n                int i = index / n;\\n                int j = index % n;\\n                for(int[] dir : dirs) {\\n                    int row = i + dir[0], col = j + dir[1];\\n                    if(row >= 0 && row < m && col >= 0 && col < n && grid[row][col] == 0) walls++;\\n                }\\n                grid[i][j] = -1;\\n            }\\n            for(int index : toAffect.keySet()) {\\n                if(index != maxIndex) {\\n                    for(int to : toAffect.get(index)) {\\n                        grid[to / n][to % n] = 1;\\n                    }\\n                }\\n            }\\n        }while (affected.size() > 1);\\n        return walls;\\n    }\\n\\n    private int find(int pos) {\\n        if(p[pos] == pos) return pos;\\n        return find(p[pos]);\\n    }\\n\\n    private void union(int c1, int c2) {\\n        int p1 = find(c1);\\n        int p2 = find(c2);\\n        if(p1 != p2) {\\n            p[p2] = p1;\\n            if(!affected.containsKey(p1)) affected.put(p1, new HashSet<>());\\n            toAffect.get(p1).addAll(toAffect.get(p2));\\n            toAffect.remove(p2);\\n            affected.get(p1).addAll(affected.get(p2));\\n            affected.remove(p2);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 638353,
                "title": "simple-c-dfs-solution",
                "content": "```\\nclass Solution {\\n    int dir[4][2] = {\\n        {-1, 0}, {1, 0}, {0, -1}, {0, 1}  \\n    };\\n    int m, n;\\npublic:\\n    int containVirus(vector<vector<int>>& grid) {\\n        m = grid.size(), n = grid[0].size();\\n        int ans = 0;\\n        unordered_set<int> zeroes;\\n        int nextStart;\\n        while((nextStart = markAndGetNextStart(grid, zeroes)) != -1){\\n            ans += cleanAndWall(grid, nextStart / n, nextStart % n);\\n            spread(grid);\\n        }\\n        return ans;\\n    }\\n    \\n    int markAndGetNextStart(vector<vector<int>>& grid, unordered_set<int>& zeroes){\\n        int nextStart = -1;\\n        int nextSaved = 0;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] != 1) continue;\\n                zeroes.clear();\\n                markAndCountZeroes(grid, i, j, zeroes);\\n                if(zeroes.size() > nextSaved){\\n                    nextStart = i * n + j;\\n                    nextSaved = zeroes.size();\\n                }\\n            }\\n        }\\n        return nextStart;\\n    }\\n    \\n    void markAndCountZeroes(vector<vector<int>>& grid, int i, int j, unordered_set<int>& zeroes){\\n        grid[i][j] = 2;\\n        for(int d = 0; d < 4; d++){\\n            int ni = i + dir[d][0];\\n            int nj = j + dir[d][1];\\n            if(ni >= 0 && ni < m && nj >= 0 && nj < n){\\n                if(grid[ni][nj] <= 0){\\n                    zeroes.insert(ni * n + nj);\\n                    grid[ni][nj]--;\\n                }else if(grid[ni][nj] == 1){\\n                    markAndCountZeroes(grid, ni, nj, zeroes);\\n                }\\n            }\\n        }\\n    }\\n    \\n    int cleanAndWall(vector<vector<int>>& grid, int i, int j){\\n        int walls = 0;\\n        // 3: walled 1\\'s\\n        grid[i][j] = 3;\\n        for(int d = 0; d < 4; d++){\\n            int ni = i + dir[d][0];\\n            int nj = j + dir[d][1];\\n            if(ni >= 0 && ni < m && nj >= 0 && nj < n){\\n                if(grid[ni][nj] <= 0){\\n                    walls++;\\n                    grid[ni][nj]++;\\n                }else if(grid[ni][nj] == 2){\\n                    walls += cleanAndWall(grid, ni, nj);\\n                }\\n            }\\n        }\\n        \\n        return walls;\\n    }\\n    \\n    void spread(vector<vector<int>>& grid){\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] < 0 || grid[i][j] == 2) grid[i][j] = 1;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int dir[4][2] = {\\n        {-1, 0}, {1, 0}, {0, -1}, {0, 1}  \\n    };\\n    int m, n;\\npublic:\\n    int containVirus(vector<vector<int>>& grid) {\\n        m = grid.size(), n = grid[0].size();\\n        int ans = 0;\\n        unordered_set<int> zeroes;\\n        int nextStart;\\n        while((nextStart = markAndGetNextStart(grid, zeroes)) != -1){\\n            ans += cleanAndWall(grid, nextStart / n, nextStart % n);\\n            spread(grid);\\n        }\\n        return ans;\\n    }\\n    \\n    int markAndGetNextStart(vector<vector<int>>& grid, unordered_set<int>& zeroes){\\n        int nextStart = -1;\\n        int nextSaved = 0;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] != 1) continue;\\n                zeroes.clear();\\n                markAndCountZeroes(grid, i, j, zeroes);\\n                if(zeroes.size() > nextSaved){\\n                    nextStart = i * n + j;\\n                    nextSaved = zeroes.size();\\n                }\\n            }\\n        }\\n        return nextStart;\\n    }\\n    \\n    void markAndCountZeroes(vector<vector<int>>& grid, int i, int j, unordered_set<int>& zeroes){\\n        grid[i][j] = 2;\\n        for(int d = 0; d < 4; d++){\\n            int ni = i + dir[d][0];\\n            int nj = j + dir[d][1];\\n            if(ni >= 0 && ni < m && nj >= 0 && nj < n){\\n                if(grid[ni][nj] <= 0){\\n                    zeroes.insert(ni * n + nj);\\n                    grid[ni][nj]--;\\n                }else if(grid[ni][nj] == 1){\\n                    markAndCountZeroes(grid, ni, nj, zeroes);\\n                }\\n            }\\n        }\\n    }\\n    \\n    int cleanAndWall(vector<vector<int>>& grid, int i, int j){\\n        int walls = 0;\\n        // 3: walled 1\\'s\\n        grid[i][j] = 3;\\n        for(int d = 0; d < 4; d++){\\n            int ni = i + dir[d][0];\\n            int nj = j + dir[d][1];\\n            if(ni >= 0 && ni < m && nj >= 0 && nj < n){\\n                if(grid[ni][nj] <= 0){\\n                    walls++;\\n                    grid[ni][nj]++;\\n                }else if(grid[ni][nj] == 2){\\n                    walls += cleanAndWall(grid, ni, nj);\\n                }\\n            }\\n        }\\n        \\n        return walls;\\n    }\\n    \\n    void spread(vector<vector<int>>& grid){\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] < 0 || grid[i][j] == 2) grid[i][j] = 1;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 625757,
                "title": "why-is-the-solution-to-this-case-59-instead-of-68",
                "content": "**Original  **\\n  0     0     1     1     1     0     1     0     0     0   \\n  1     1     1     0     0     0     1     1     0     1   \\n  0     0     0     0     0     0     1     0     0     0   \\n  0     0     0     0     1     0     1     0     0     0   \\n  1     0     0     0     1     1     1     0     0     0   \\n  0     0     0     1     0     1     1     0     0     0   \\n  1     0     0     0     0     1     0     0     0     1   \\n  1     0     0     0     0     0     0     0     0     1   \\n  0     1     0     0     0     0     0     0     1     0   \\n  1     1     0     0     0     1     0     1     0     0   \\n\\nAbove is the grid. I print out the walls inserted in the form of x,y,dir. \\nDir=0 when the wall is put on the left of x,y\\nDir=1 when the wall is put above of x,y\\nDir=2 when the wall is put on the right of x,y\\nDir=3 when the wall is put below x,y\\n\\ninsert wall 1 :0 6 0\\ninsert wall 2 :0 6 2\\ninsert wall 3 :1 6 0\\ninsert wall 4 :2 6 0\\ninsert wall 5 :2 6 2\\ninsert wall 6 :3 6 0\\ninsert wall 7 :3 6 2\\ninsert wall 8 :4 6 2\\ninsert wall 9 :4 5 1\\ninsert wall 10 :5 5 0\\ninsert wall 11 :6 5 0\\ninsert wall 12 :6 5 2\\ninsert wall 13 :6 5 3\\ninsert wall 14 :5 6 2\\ninsert wall 15 :5 6 3\\ninsert wall 16 :4 4 0\\ninsert wall 17 :4 4 3\\ninsert wall 18 :3 4 0\\ninsert wall 19 :3 4 1\\ninsert wall 20 :3 4 2\\ninsert wall 21 :1 7 1\\ninsert wall 22 :1 7 2\\ninsert wall 23 :1 7 3\\n\\nI indicated the left and right walls with \\'|\\' and a wall above with \\'^\\' and a wall below with \\'v\\'.\\n\\n**After walled up**\\n  0     0     1     1     1     0   | 1 |   0     0     0   \\n  1     1     1     0     0     0   | 1    ^1v|   0     1   \\n  0     0     0     0     0     0   | 1 |   0     0     0   \\n  0     0     0     0   |^1 |   0   | 1 |   0     0     0   \\n  1     0     0     0   | 1v   ^1     1 |   0     0     0   \\n  0     0     0     1     0   | 1     1v|   0     0     0   \\n  1     0     0     0     0   | 1v|   0     0     0     1   \\n  1     0     0     0     0     0     0     0     0     1   \\n  0     1     0     0     0     0     0     0     1     0   \\n  1     1     0     0     0     1     0     1     0     0   \\n\\n**After simulation**\\n  1     1     1     1     1     1   | 1 |   0     0     1   \\n  1     1     1     1     1     0   | 1    ^1v|   1     1   \\n  1     1     1     0     0     0   | 1 |   0     0     1   \\n  1     0     0     0   |^1 |   0   | 1 |   0     0     0   \\n  1     1     0     1   | 1v   ^1     1 |   0     0     0   \\n  1     0     1     1     1   | 1     1v|   0     0     1   \\n  1     1     0     1     0   | 1v|   0     0     1     1   \\n  1     1     0     0     0     0     0     0     1     1   \\n  1     1     1     0     0     1     0     1     1     1   \\n  1     1     1     0     1     1     1     1     1     0   \\n\\ninsert wall 1 :1 4 2\\ninsert wall 2 :1 4 3\\ninsert wall 3 :1 3 3\\ninsert wall 4 :3 0 2\\ninsert wall 5 :5 0 2\\ninsert wall 6 :6 1 1\\ninsert wall 7 :6 1 2\\ninsert wall 8 :7 1 2\\ninsert wall 9 :8 2 1\\ninsert wall 10 :8 2 2\\ninsert wall 11 :9 2 2\\ninsert wall 12 :4 1 1\\ninsert wall 13 :4 1 2\\ninsert wall 14 :4 1 3\\ninsert wall 15 :2 1 3\\ninsert wall 16 :2 2 2\\ninsert wall 17 :2 2 3\\ninsert wall 18 :0 5 3\\ninsert wall 19 :4 3 0\\ninsert wall 20 :4 3 1\\ninsert wall 21 :6 3 0\\ninsert wall 22 :6 3 2\\ninsert wall 23 :6 3 3\\ninsert wall 24 :5 4 3\\ninsert wall 25 :5 2 0\\ninsert wall 26 :5 2 1\\ninsert wall 27 :5 2 3\\ninsert wall 28 :1 8 1\\ninsert wall 29 :1 8 3\\ninsert wall 30 :2 9 0\\ninsert wall 31 :2 9 3\\ninsert wall 32 :0 9 0\\n\\n**After walled up**\\n  1     1     1     1     1     1v  | 1 |   0     0   | 1   \\n  1     1     1     1v    1v|   0   | 1    ^1v|  ^1v    1   \\n  1     1v    1v|   0     0     0   | 1 |   0     0   | 1v  \\n  1 |   0     0     0   |^1 |   0   | 1 |   0     0     0   \\n  1    ^1v|   0   |^1   | 1v   ^1     1 |   0     0     0   \\n  1 |   0   |^1v    1     1v  | 1     1v|   0     0     1   \\n  1    ^1 |   0   | 1v|   0   | 1v|   0     0     1     1   \\n  1     1 |   0     0     0     0     0     0     1     1   \\n  1     1    ^1 |   0     0     1     0     1     1     1   \\n  1     1     1 |   0     1     1     1     1     1     0   \\n\\n**After simulation**\\n  1     1     1     1     1     1v  | 1 |   0     0   | 1   \\n  1     1     1     1v    1v|   0   | 1    ^1v|  ^1v    1   \\n  1     1v    1v|   0     0     0   | 1 |   0     0   | 1v  \\n  1 |   0     0     0   |^1 |   0   | 1 |   0     0     0   \\n  1    ^1v|   0   |^1   | 1v   ^1     1 |   0     0     1   \\n  1 |   0   |^1v    1     1v  | 1     1v|   0     1     1   \\n  1    ^1 |   0   | 1v|   0   | 1v|   0     1     1     1   \\n  1     1 |   0     0     0     1     0     1     1     1   \\n  1     1    ^1 |   0     1     1     1     1     1     1   \\n  1     1     1 |   1     1     1     1     1     1     1   \\n\\ninsert wall 1 :7 5 0\\ninsert wall 2 :7 5 2\\ninsert wall 3 :8 4 0\\ninsert wall 4 :8 4 1\\ninsert wall 5 :8 6 1\\ninsert wall 6 :7 7 0\\ninsert wall 7 :6 7 0\\ninsert wall 8 :6 7 1\\ninsert wall 9 :5 8 0\\ninsert wall 10 :5 8 1\\ninsert wall 11 :4 9 0\\ninsert wall 12 :4 9 1\\ninsert wall 13 :9 3 1\\n\\n**After walled up**\\n  1     1     1     1     1     1v  | 1 |   0     0   | 1   \\n  1     1     1     1v    1v|   0   | 1    ^1v|  ^1v    1   \\n  1     1v    1v|   0     0     0   | 1 |   0     0   | 1v  \\n  1 |   0     0     0   |^1 |   0   | 1 |   0     0     0   \\n  1    ^1v|   0   |^1   | 1v   ^1     1 |   0     0   |^1   \\n  1 |   0   |^1v    1     1v  | 1     1v|   0   |^1     1   \\n  1    ^1 |   0   | 1v|   0   | 1v|   0   |^1     1     1   \\n  1     1 |   0     0     0   | 1 |   0   | 1     1     1   \\n  1     1    ^1 |   0   |^1     1    ^1     1     1     1   \\n  1     1     1 |  ^1     1     1     1     1     1     1   \\n\\n**After simulation**\\n  1     1     1     1     1     1v  | 1 |   0     0   | 1   \\n  1     1     1     1v    1v|   0   | 1    ^1v|  ^1v    1   \\n  1     1v    1v|   0     0     0   | 1 |   0     0   | 1v  \\n  1 |   0     0     0   |^1 |   0   | 1 |   0     0     0   \\n  1    ^1v|   0   |^1   | 1v   ^1     1 |   0     0   |^1   \\n  1 |   0   |^1v    1     1v  | 1     1v|   0   |^1     1   \\n  1    ^1 |   0   | 1v|   0   | 1v|   0   |^1     1     1   \\n  1     1 |   0     0     0   | 1 |   0   | 1     1     1   \\n  1     1    ^1 |   0   |^1     1    ^1     1     1     1   \\n  1     1     1 |  ^1     1     1     1     1     1     1   \\n\\n\\n\\nCan anyone see why only 59 walls are inserted instead of 68?\\n",
                "solutionTags": [],
                "code": "**Original  **\\n  0     0     1     1     1     0     1     0     0     0   \\n  1     1     1     0     0     0     1     1     0     1   \\n  0     0     0     0     0     0     1     0     0     0   \\n  0     0     0     0     1     0     1     0     0     0   \\n  1     0     0     0     1     1     1     0     0     0   \\n  0     0     0     1     0     1     1     0     0     0   \\n  1     0     0     0     0     1     0     0     0     1   \\n  1     0     0     0     0     0     0     0     0     1   \\n  0     1     0     0     0     0     0     0     1     0   \\n  1     1     0     0     0     1     0     1     0     0   \\n\\nAbove is the grid. I print out the walls inserted in the form of x,y,dir. \\nDir=0 when the wall is put on the left of x,y\\nDir=1 when the wall is put above of x,y\\nDir=2 when the wall is put on the right of x,y\\nDir=3 when the wall is put below x,y\\n\\ninsert wall 1 :0 6 0\\ninsert wall 2 :0 6 2\\ninsert wall 3 :1 6 0\\ninsert wall 4 :2 6 0\\ninsert wall 5 :2 6 2\\ninsert wall 6 :3 6 0\\ninsert wall 7 :3 6 2\\ninsert wall 8 :4 6 2\\ninsert wall 9 :4 5 1\\ninsert wall 10 :5 5 0\\ninsert wall 11 :6 5 0\\ninsert wall 12 :6 5 2\\ninsert wall 13 :6 5 3\\ninsert wall 14 :5 6 2\\ninsert wall 15 :5 6 3\\ninsert wall 16 :4 4 0\\ninsert wall 17 :4 4 3\\ninsert wall 18 :3 4 0\\ninsert wall 19 :3 4 1\\ninsert wall 20 :3 4 2\\ninsert wall 21 :1 7 1\\ninsert wall 22 :1 7 2\\ninsert wall 23 :1 7 3\\n\\nI indicated the left and right walls with \\'|\\' and a wall above with \\'^\\' and a wall below with \\'v\\'.\\n\\n**After walled up**\\n  0     0     1     1     1     0   | 1 |   0     0     0   \\n  1     1     1     0     0     0   | 1    ^1v|   0     1   \\n  0     0     0     0     0     0   | 1 |   0     0     0   \\n  0     0     0     0   |^1 |   0   | 1 |   0     0     0   \\n  1     0     0     0   | 1v   ^1     1 |   0     0     0   \\n  0     0     0     1     0   | 1     1v|   0     0     0   \\n  1     0     0     0     0   | 1v|   0     0     0     1   \\n  1     0     0     0     0     0     0     0     0     1   \\n  0     1     0     0     0     0     0     0     1     0   \\n  1     1     0     0     0     1     0     1     0     0   \\n\\n**After simulation**\\n  1     1     1     1     1     1   | 1 |   0     0     1   \\n  1     1     1     1     1     0   | 1    ^1v|   1     1   \\n  1     1     1     0     0     0   | 1 |   0     0     1   \\n  1     0     0     0   |^1 |   0   | 1 |   0     0     0   \\n  1     1     0     1   | 1v   ^1     1 |   0     0     0   \\n  1     0     1     1     1   | 1     1v|   0     0     1   \\n  1     1     0     1     0   | 1v|   0     0     1     1   \\n  1     1     0     0     0     0     0     0     1     1   \\n  1     1     1     0     0     1     0     1     1     1   \\n  1     1     1     0     1     1     1     1     1     0   \\n\\ninsert wall 1 :1 4 2\\ninsert wall 2 :1 4 3\\ninsert wall 3 :1 3 3\\ninsert wall 4 :3 0 2\\ninsert wall 5 :5 0 2\\ninsert wall 6 :6 1 1\\ninsert wall 7 :6 1 2\\ninsert wall 8 :7 1 2\\ninsert wall 9 :8 2 1\\ninsert wall 10 :8 2 2\\ninsert wall 11 :9 2 2\\ninsert wall 12 :4 1 1\\ninsert wall 13 :4 1 2\\ninsert wall 14 :4 1 3\\ninsert wall 15 :2 1 3\\ninsert wall 16 :2 2 2\\ninsert wall 17 :2 2 3\\ninsert wall 18 :0 5 3\\ninsert wall 19 :4 3 0\\ninsert wall 20 :4 3 1\\ninsert wall 21 :6 3 0\\ninsert wall 22 :6 3 2\\ninsert wall 23 :6 3 3\\ninsert wall 24 :5 4 3\\ninsert wall 25 :5 2 0\\ninsert wall 26 :5 2 1\\ninsert wall 27 :5 2 3\\ninsert wall 28 :1 8 1\\ninsert wall 29 :1 8 3\\ninsert wall 30 :2 9 0\\ninsert wall 31 :2 9 3\\ninsert wall 32 :0 9 0\\n\\n**After walled up**\\n  1     1     1     1     1     1v  | 1 |   0     0   | 1   \\n  1     1     1     1v    1v|   0   | 1    ^1v|  ^1v    1   \\n  1     1v    1v|   0     0     0   | 1 |   0     0   | 1v  \\n  1 |   0     0     0   |^1 |   0   | 1 |   0     0     0   \\n  1    ^1v|   0   |^1   | 1v   ^1     1 |   0     0     0   \\n  1 |   0   |^1v    1     1v  | 1     1v|   0     0     1   \\n  1    ^1 |   0   | 1v|   0   | 1v|   0     0     1     1   \\n  1     1 |   0     0     0     0     0     0     1     1   \\n  1     1    ^1 |   0     0     1     0     1     1     1   \\n  1     1     1 |   0     1     1     1     1     1     0   \\n\\n**After simulation**\\n  1     1     1     1     1     1v  | 1 |   0     0   | 1   \\n  1     1     1     1v    1v|   0   | 1    ^1v|  ^1v    1   \\n  1     1v    1v|   0     0     0   | 1 |   0     0   | 1v  \\n  1 |   0     0     0   |^1 |   0   | 1 |   0     0     0   \\n  1    ^1v|   0   |^1   | 1v   ^1     1 |   0     0     1   \\n  1 |   0   |^1v    1     1v  | 1     1v|   0     1     1   \\n  1    ^1 |   0   | 1v|   0   | 1v|   0     1     1     1   \\n  1     1 |   0     0     0     1     0     1     1     1   \\n  1     1    ^1 |   0     1     1     1     1     1     1   \\n  1     1     1 |   1     1     1     1     1     1     1   \\n\\ninsert wall 1 :7 5 0\\ninsert wall 2 :7 5 2\\ninsert wall 3 :8 4 0\\ninsert wall 4 :8 4 1\\ninsert wall 5 :8 6 1\\ninsert wall 6 :7 7 0\\ninsert wall 7 :6 7 0\\ninsert wall 8 :6 7 1\\ninsert wall 9 :5 8 0\\ninsert wall 10 :5 8 1\\ninsert wall 11 :4 9 0\\ninsert wall 12 :4 9 1\\ninsert wall 13 :9 3 1\\n\\n**After walled up**\\n  1     1     1     1     1     1v  | 1 |   0     0   | 1   \\n  1     1     1     1v    1v|   0   | 1    ^1v|  ^1v    1   \\n  1     1v    1v|   0     0     0   | 1 |   0     0   | 1v  \\n  1 |   0     0     0   |^1 |   0   | 1 |   0     0     0   \\n  1    ^1v|   0   |^1   | 1v   ^1     1 |   0     0   |^1   \\n  1 |   0   |^1v    1     1v  | 1     1v|   0   |^1     1   \\n  1    ^1 |   0   | 1v|   0   | 1v|   0   |^1     1     1   \\n  1     1 |   0     0     0   | 1 |   0   | 1     1     1   \\n  1     1    ^1 |   0   |^1     1    ^1     1     1     1   \\n  1     1     1 |  ^1     1     1     1     1     1     1   \\n\\n**After simulation**\\n  1     1     1     1     1     1v  | 1 |   0     0   | 1   \\n  1     1     1     1v    1v|   0   | 1    ^1v|  ^1v    1   \\n  1     1v    1v|   0     0     0   | 1 |   0     0   | 1v  \\n  1 |   0     0     0   |^1 |   0   | 1 |   0     0     0   \\n  1    ^1v|   0   |^1   | 1v   ^1     1 |   0     0   |^1   \\n  1 |   0   |^1v    1     1v  | 1     1v|   0   |^1     1   \\n  1    ^1 |   0   | 1v|   0   | 1v|   0   |^1     1     1   \\n  1     1 |   0     0     0   | 1 |   0   | 1     1     1   \\n  1     1    ^1 |   0   |^1     1    ^1     1     1     1   \\n  1     1     1 |  ^1     1     1     1     1     1     1   \\n\\n\\n\\nCan anyone see why only 59 walls are inserted instead of 68?\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 578511,
                "title": "clear-rust-solution-with-simple-explains",
                "content": "```\\nuse std::cmp::Ordering;\\nuse std::collections::{BinaryHeap, HashSet};\\n\\ntype Point = (usize, usize);\\n\\n#[derive(Eq, Debug)]\\nstruct InfluencedRecord {\\n    pub need_walls: i32,\\n    pub influenced_area: HashSet<Point>,\\n    pub virus_area: HashSet<Point>,\\n}\\n\\nimpl Ord for InfluencedRecord {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        self.influenced_area.len().cmp(&other.influenced_area.len())\\n    }\\n}\\n\\nimpl PartialOrd for InfluencedRecord {\\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\\n        Some(self.cmp(other))\\n    }\\n}\\n\\nimpl PartialEq for InfluencedRecord {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.influenced_area.len() == other.influenced_area.len()\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn contain_virus(mut grid: Vec<Vec<i32>>) -> i32 {\\n        let mut safe_areas = HashSet::new();\\n        //record the  need walls\\n        let mut result = 0;\\n        let row_num = grid.len();\\n        let col_num = grid[0].len();\\n        fn dfs(\\n            grid: &mut Vec<Vec<i32>>,\\n            safe_areas: &mut HashSet<Point>,\\n            result: &mut i32,\\n            row_num: usize,\\n            col_num: usize,\\n        ) {\\n            //record all virus grid,virus area and influenced area;\\n            let mut virus = HashSet::new();\\n            let mut influenced_records = BinaryHeap::new();\\n            fn find_virus_and_influenced_area(\\n                virus_area: &mut HashSet<Point>,\\n                influenced_area: &mut HashSet<Point>,\\n                virus: &mut HashSet<Point>,\\n                safe_areas: &mut HashSet<Point>,\\n                need_walls: &mut i32,\\n                grid: &Vec<Vec<i32>>,\\n                point: Point,\\n                row_num: usize,\\n                col_num: usize,\\n            ) {\\n                // top right down left\\n                let dirs = vec![(-1, 0), (0, 1), (1, 0), (0, -1)];\\n                virus_area.insert(point);\\n                virus.insert(point);\\n                // top right down left\\n                dirs.iter().for_each(|&(x, y)| {\\n                    let new_x = point.0 as i32 + x;\\n                    let new_y = point.1 as i32 + y;\\n                    if new_x >= 0\\n                        && new_x < (row_num as i32)\\n                        && new_y >= 0\\n                        && new_y < (col_num as i32)\\n                    {\\n                        let new_point = (new_x as usize, new_y as usize);\\n                        let grid_val = &grid[new_x as usize][new_y as usize];\\n                        if grid_val == &0 {\\n                            influenced_area.insert(new_point);\\n                            *need_walls += 1;\\n                            return;\\n                        }\\n                        if !virus.contains(&new_point) && !safe_areas.contains(&new_point) {\\n                            find_virus_and_influenced_area(\\n                                virus_area,\\n                                influenced_area,\\n                                virus,\\n                                safe_areas,\\n                                need_walls,\\n                                &grid,\\n                                new_point,\\n                                row_num,\\n                                col_num,\\n                            );\\n                        }\\n                    }\\n                });\\n            }\\n            for i in 0..row_num {\\n                for j in 0..col_num {\\n                    let grid_val = grid[i][j];\\n                    if grid_val == 0 {\\n                        continue;\\n                    }\\n                    let point = (i, j);\\n                    if !virus.contains(&point) && !safe_areas.contains(&point) {\\n                        let mut virus_area = HashSet::new();\\n                        let mut influenced_area = HashSet::new();\\n                        let mut need_walls = 0;\\n                        //find contiguous virus and influenced_area;\\n                        find_virus_and_influenced_area(\\n                            &mut virus_area,\\n                            &mut influenced_area,\\n                            &mut virus,\\n                            safe_areas,\\n                            &mut need_walls,\\n                            grid.as_ref(),\\n                            point,\\n                            row_num,\\n                            col_num,\\n                        );\\n                        influenced_records.push(InfluencedRecord {\\n                            virus_area,\\n                            influenced_area,\\n                            need_walls,\\n                        });\\n                    }\\n                }\\n            }\\n            let influenced_record = influenced_records.pop();\\n            if influenced_record.is_none() {\\n                return;\\n            }\\n            let InfluencedRecord {\\n                mut virus_area,\\n                influenced_area: _,\\n                need_walls,\\n            } = influenced_record.unwrap();\\n            //build walls;\\n            *result += need_walls;\\n            //add safe areas;\\n            safe_areas.extend(virus_area.drain());\\n            influenced_records.iter().for_each(\\n                |InfluencedRecord {\\n                     influenced_area,\\n                     virus_area: _,\\n                     need_walls: _,\\n                 }| {\\n                    //infect areas;\\n                    influenced_area.iter().for_each(|&(x, y)| {\\n                        grid[x][y] = 1;\\n                    });\\n                },\\n            );\\n            //continue;\\n            dfs(grid, safe_areas, result, row_num, col_num);\\n        }\\n        dfs(&mut grid, &mut safe_areas, &mut result, row_num, col_num);\\n        result\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::cmp::Ordering;\\nuse std::collections::{BinaryHeap, HashSet};\\n\\ntype Point = (usize, usize);\\n\\n#[derive(Eq, Debug)]\\nstruct InfluencedRecord {\\n    pub need_walls: i32,\\n    pub influenced_area: HashSet<Point>,\\n    pub virus_area: HashSet<Point>,\\n}\\n\\nimpl Ord for InfluencedRecord {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        self.influenced_area.len().cmp(&other.influenced_area.len())\\n    }\\n}\\n\\nimpl PartialOrd for InfluencedRecord {\\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\\n        Some(self.cmp(other))\\n    }\\n}\\n\\nimpl PartialEq for InfluencedRecord {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.influenced_area.len() == other.influenced_area.len()\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn contain_virus(mut grid: Vec<Vec<i32>>) -> i32 {\\n        let mut safe_areas = HashSet::new();\\n        //record the  need walls\\n        let mut result = 0;\\n        let row_num = grid.len();\\n        let col_num = grid[0].len();\\n        fn dfs(\\n            grid: &mut Vec<Vec<i32>>,\\n            safe_areas: &mut HashSet<Point>,\\n            result: &mut i32,\\n            row_num: usize,\\n            col_num: usize,\\n        ) {\\n            //record all virus grid,virus area and influenced area;\\n            let mut virus = HashSet::new();\\n            let mut influenced_records = BinaryHeap::new();\\n            fn find_virus_and_influenced_area(\\n                virus_area: &mut HashSet<Point>,\\n                influenced_area: &mut HashSet<Point>,\\n                virus: &mut HashSet<Point>,\\n                safe_areas: &mut HashSet<Point>,\\n                need_walls: &mut i32,\\n                grid: &Vec<Vec<i32>>,\\n                point: Point,\\n                row_num: usize,\\n                col_num: usize,\\n            ) {\\n                // top right down left\\n                let dirs = vec![(-1, 0), (0, 1), (1, 0), (0, -1)];\\n                virus_area.insert(point);\\n                virus.insert(point);\\n                // top right down left\\n                dirs.iter().for_each(|&(x, y)| {\\n                    let new_x = point.0 as i32 + x;\\n                    let new_y = point.1 as i32 + y;\\n                    if new_x >= 0\\n                        && new_x < (row_num as i32)\\n                        && new_y >= 0\\n                        && new_y < (col_num as i32)\\n                    {\\n                        let new_point = (new_x as usize, new_y as usize);\\n                        let grid_val = &grid[new_x as usize][new_y as usize];\\n                        if grid_val == &0 {\\n                            influenced_area.insert(new_point);\\n                            *need_walls += 1;\\n                            return;\\n                        }\\n                        if !virus.contains(&new_point) && !safe_areas.contains(&new_point) {\\n                            find_virus_and_influenced_area(\\n                                virus_area,\\n                                influenced_area,\\n                                virus,\\n                                safe_areas,\\n                                need_walls,\\n                                &grid,\\n                                new_point,\\n                                row_num,\\n                                col_num,\\n                            );\\n                        }\\n                    }\\n                });\\n            }\\n            for i in 0..row_num {\\n                for j in 0..col_num {\\n                    let grid_val = grid[i][j];\\n                    if grid_val == 0 {\\n                        continue;\\n                    }\\n                    let point = (i, j);\\n                    if !virus.contains(&point) && !safe_areas.contains(&point) {\\n                        let mut virus_area = HashSet::new();\\n                        let mut influenced_area = HashSet::new();\\n                        let mut need_walls = 0;\\n                        //find contiguous virus and influenced_area;\\n                        find_virus_and_influenced_area(\\n                            &mut virus_area,\\n                            &mut influenced_area,\\n                            &mut virus,\\n                            safe_areas,\\n                            &mut need_walls,\\n                            grid.as_ref(),\\n                            point,\\n                            row_num,\\n                            col_num,\\n                        );\\n                        influenced_records.push(InfluencedRecord {\\n                            virus_area,\\n                            influenced_area,\\n                            need_walls,\\n                        });\\n                    }\\n                }\\n            }\\n            let influenced_record = influenced_records.pop();\\n            if influenced_record.is_none() {\\n                return;\\n            }\\n            let InfluencedRecord {\\n                mut virus_area,\\n                influenced_area: _,\\n                need_walls,\\n            } = influenced_record.unwrap();\\n            //build walls;\\n            *result += need_walls;\\n            //add safe areas;\\n            safe_areas.extend(virus_area.drain());\\n            influenced_records.iter().for_each(\\n                |InfluencedRecord {\\n                     influenced_area,\\n                     virus_area: _,\\n                     need_walls: _,\\n                 }| {\\n                    //infect areas;\\n                    influenced_area.iter().for_each(|&(x, y)| {\\n                        grid[x][y] = 1;\\n                    });\\n                },\\n            );\\n            //continue;\\n            dfs(grid, safe_areas, result, row_num, col_num);\\n        }\\n        dfs(&mut grid, &mut safe_areas, &mut result, row_num, col_num);\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 575971,
                "title": "java-solution-improved-on-another-fast-submission",
                "content": "Here is a Java solution I improved on another fast submission:\\n```\\nclass Solution {\\n    int[][] grid;\\n    int[][] moves = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    int regionId = 1;\\n    int li, lj;\\n    \\n    public int containVirus(int[][] grid) {\\n        this.grid = grid;\\n        this.li = grid.length;\\n        this.lj = grid[0].length;\\n        int ans = 0;\\n        \\n        while (true) {\\n            int regionIdThreshold = regionId;\\n            int maxNumThreats = 0;\\n            int numWallsNeeded = 0;\\n            int toBeContainedRegionId = 0;\\n            int toBeContainedOriginI = -1;\\n            int toBeContainedOriginJ = -1;\\n\\n            for (int i = 0; i < li; i++) {\\n                for (int j = 0; j < lj; j++) {\\n                    int g = grid[i][j];\\n                    if (g > 0 && g <= regionIdThreshold) {\\n                        int[] threatsAndWalls = dfs(++regionId, i, j);\\n                        if (threatsAndWalls[0] > maxNumThreats) {\\n                            maxNumThreats = threatsAndWalls[0]; \\n                            numWallsNeeded = threatsAndWalls[1];\\n                            toBeContainedRegionId = regionId; \\n                            toBeContainedOriginI = i;\\n                            toBeContainedOriginJ = j;\\n                        } \\n                    }\\n                }\\n            }\\n\\n            if (toBeContainedRegionId > 0) {\\n                ans += numWallsNeeded;\\n                contain(toBeContainedRegionId,\\n                        toBeContainedOriginI, toBeContainedOriginJ);\\n            } else {\\n                break; \\n            } \\n            \\n            regionIdThreshold = regionId;\\n            \\n            for (int i = 0; i < li; i++) {\\n                for (int j = 0; j < lj; j++) {\\n                    int g = grid[i][j];\\n                    if (g > 0 && g <= regionIdThreshold) {\\n                        infect(++regionId, i, j, regionIdThreshold);\\n                    }\\n                }\\n            }\\n        }\\n       \\n        return ans;\\n    }\\n\\n    private int[] dfs(int regionId, int i, int j) {\\n        int numThreats = 0;\\n        int numWalls = 0;\\n        grid[i][j] = regionId;\\n        for (int[] m : moves) {\\n            int ni = i + m[0];\\n            int nj = j + m[1];\\n            if (ni >= 0 && ni < li && nj >= 0 && nj <lj) {\\n                int gn = grid[ni][nj];\\n                if (gn <= 0 && gn != -1) {\\n                    numWalls++;\\n                    if (gn != -regionId) {\\n                        grid[ni][nj] = -regionId;\\n                        numThreats++;\\n                    }\\n                } else if (gn > 0 && gn != regionId) {\\n                    int[] a = dfs(regionId, ni, nj);\\n                    numThreats += a[0];\\n                    numWalls += a[1];\\n                }\\n            }\\n        }\\n        return new int[]{numThreats, numWalls};\\n    }\\n    \\n    private void infect(int regionId, int i, int j, int regionIdThreshold) {\\n        grid[i][j] = regionId;\\n        for (int[] m : moves) {\\n            int ni = i + m[0];\\n            int nj = j + m[1];\\n            if (ni >= 0 && ni < li && nj >= 0 && nj < lj) {\\n                int gn = grid[ni][nj];\\n                if (gn <= 0 && gn != -1) {\\n                    grid[ni][nj] = regionId;\\n                } else if (gn > 0 && gn <= regionIdThreshold) {\\n                    infect(regionId, ni, nj, regionIdThreshold);\\n                }\\n            }\\n        }\\n    }\\n    \\n    private void contain(int regionId, int i, int j) {\\n        grid[i][j] = -1;\\n        for (int[] m : moves) {\\n            int ni = i + m[0];\\n            int nj = j + m[1];\\n            if (ni >= 0 && ni < li && nj >= 0 && nj < lj) {\\n                if (grid[ni][nj] == regionId) {\\n                    contain(regionId, ni, nj);\\n                }\\n            }\\n        }\\n    }\\n\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] grid;\\n    int[][] moves = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    int regionId = 1;\\n    int li, lj;\\n    \\n    public int containVirus(int[][] grid) {\\n        this.grid = grid;\\n        this.li = grid.length;\\n        this.lj = grid[0].length;\\n        int ans = 0;\\n        \\n        while (true) {\\n            int regionIdThreshold = regionId;\\n            int maxNumThreats = 0;\\n            int numWallsNeeded = 0;\\n            int toBeContainedRegionId = 0;\\n            int toBeContainedOriginI = -1;\\n            int toBeContainedOriginJ = -1;\\n\\n            for (int i = 0; i < li; i++) {\\n                for (int j = 0; j < lj; j++) {\\n                    int g = grid[i][j];\\n                    if (g > 0 && g <= regionIdThreshold) {\\n                        int[] threatsAndWalls = dfs(++regionId, i, j);\\n                        if (threatsAndWalls[0] > maxNumThreats) {\\n                            maxNumThreats = threatsAndWalls[0]; \\n                            numWallsNeeded = threatsAndWalls[1];\\n                            toBeContainedRegionId = regionId; \\n                            toBeContainedOriginI = i;\\n                            toBeContainedOriginJ = j;\\n                        } \\n                    }\\n                }\\n            }\\n\\n            if (toBeContainedRegionId > 0) {\\n                ans += numWallsNeeded;\\n                contain(toBeContainedRegionId,\\n                        toBeContainedOriginI, toBeContainedOriginJ);\\n            } else {\\n                break; \\n            } \\n            \\n            regionIdThreshold = regionId;\\n            \\n            for (int i = 0; i < li; i++) {\\n                for (int j = 0; j < lj; j++) {\\n                    int g = grid[i][j];\\n                    if (g > 0 && g <= regionIdThreshold) {\\n                        infect(++regionId, i, j, regionIdThreshold);\\n                    }\\n                }\\n            }\\n        }\\n       \\n        return ans;\\n    }\\n\\n    private int[] dfs(int regionId, int i, int j) {\\n        int numThreats = 0;\\n        int numWalls = 0;\\n        grid[i][j] = regionId;\\n        for (int[] m : moves) {\\n            int ni = i + m[0];\\n            int nj = j + m[1];\\n            if (ni >= 0 && ni < li && nj >= 0 && nj <lj) {\\n                int gn = grid[ni][nj];\\n                if (gn <= 0 && gn != -1) {\\n                    numWalls++;\\n                    if (gn != -regionId) {\\n                        grid[ni][nj] = -regionId;\\n                        numThreats++;\\n                    }\\n                } else if (gn > 0 && gn != regionId) {\\n                    int[] a = dfs(regionId, ni, nj);\\n                    numThreats += a[0];\\n                    numWalls += a[1];\\n                }\\n            }\\n        }\\n        return new int[]{numThreats, numWalls};\\n    }\\n    \\n    private void infect(int regionId, int i, int j, int regionIdThreshold) {\\n        grid[i][j] = regionId;\\n        for (int[] m : moves) {\\n            int ni = i + m[0];\\n            int nj = j + m[1];\\n            if (ni >= 0 && ni < li && nj >= 0 && nj < lj) {\\n                int gn = grid[ni][nj];\\n                if (gn <= 0 && gn != -1) {\\n                    grid[ni][nj] = regionId;\\n                } else if (gn > 0 && gn <= regionIdThreshold) {\\n                    infect(regionId, ni, nj, regionIdThreshold);\\n                }\\n            }\\n        }\\n    }\\n    \\n    private void contain(int regionId, int i, int j) {\\n        grid[i][j] = -1;\\n        for (int[] m : moves) {\\n            int ni = i + m[0];\\n            int nj = j + m[1];\\n            if (ni >= 0 && ni < li && nj >= 0 && nj < lj) {\\n                if (grid[ni][nj] == regionId) {\\n                    contain(regionId, ni, nj);\\n                }\\n            }\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 574049,
                "title": "c-3-pass-dfs-4-somewhat-clean-functions",
                "content": "NOTE: If you\\'re not familiar with how to use DFS to traverse through a virus body (\"island\"), please do [200. Number of Islands](https://leetcode.com/problems/number-of-islands/) first.\\n\\nUsing this example for explanation:\\n```\\n[[ 0, 1, 0, 0, 0, 0, 0, 1],\\n [ 0, 1, 0, 0, 0, 1, 0, 1],\\n [ 0, 0, 0, 0, 0, 1, 0, 1],\\n [ 0, 0, 0, 0, 0, 0, 0, 0]]\\n ```\\n1. Find the most threatening virus body by counting the nearby zeroes with DFS. A virus body is defined as an isolated \"island\" of 1\\'s. In this example, there are 3 virus bodies at the start. If there isn\\'t any body that can infect any uninfected cells, we have reached the terminal state.\\n2. When we\\'re counting zeroes, we subtract the value by 1 to mark the number of virus grids around it. We mark traversed 1\\'s as 2 to avoid looping in the island during DFS.\\n```\\n[[-1, 2,-1, 0, 0,-1,-1, 2],\\n [-1, 2,-1, 0,-1, 2,-2, 2],\\n [ 0,-1, 0, 0,-1, 2,-2, 2],\\n [ 0, 0, 0, 0, 0,-1, 0,-1]]\\n ```\\n3. We then do another DFS to the most threatening virus body we\\'ve found to mark them as \"quarantined\" and clean up their marks on the surrounding 0\\'s. While doing so, we also count the walls needed to quarantine the body. The quarantined grids are marked as 3 so the virus can\\'t grow across them in the future. In this example, the middle island is the most threatening body with 6 potential casualties. \\n```\\n[[-1, 2,-1, 0, 0, 0,-1, 2],\\n [-1, 2,-1, 0, 0, 3,-1, 2],\\n [ 0,-1, 0, 0, 0, 3,-1, 2],\\n [ 0, 0, 0, 0, 0, 0, 0,-1]]\\n ```\\n 4. Finally, we simulate the spread. If the value of a grid is 2, it is an existing virus grid; if it is below 0, it is a newly infected cell with 1 or more infected cells around it. In either case, we mark the grid as 1.\\n ```\\n[[ 1, 1, 1, 0, 0, 0, 1, 1],\\n  [ 1, 1, 1, 0, 0, 3, 1, 1],\\n  [ 0, 1, 0, 0, 0, 3, 1, 1],\\n  [ 0, 0, 0, 0, 0, 0, 0, 1]]\\n ```\\n 5. Go back to step 1 and test again.\\n\\nFull code:\\n\\n```\\nclass Solution {\\n    int dir[4][2] = {\\n        {-1, 0}, {1, 0}, {0, -1}, {0, 1}  \\n    };\\n    int m, n;\\npublic:\\n    int containVirus(vector<vector<int>>& grid) {\\n        m = grid.size(), n = grid[0].size();\\n        int ans = 0;\\n        unordered_set<int> zeroes;\\n        int nextStart;\\n        while((nextStart = markAndGetNextStart(grid, zeroes)) != -1){\\n            ans += cleanAndWall(grid, nextStart / n, nextStart % n);\\n            spread(grid);\\n        }\\n        return ans;\\n    }\\n    \\n    int markAndGetNextStart(vector<vector<int>>& grid, unordered_set<int>& zeroes){\\n        int nextStart = -1;\\n        int nextSaved = 0;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] != 1) continue;\\n                zeroes.clear();\\n                markAndCountZeroes(grid, i, j, zeroes);\\n                if(zeroes.size() > nextSaved){\\n                    nextStart = i * n + j;\\n                    nextSaved = zeroes.size();\\n                }\\n            }\\n        }\\n        return nextStart;\\n    }\\n    \\n    void markAndCountZeroes(vector<vector<int>>& grid, int i, int j, unordered_set<int>& zeroes){\\n        // DFS to get affected 0\\'s after this round\\n        // Mark affected 0\\'s by subtracting 1\\n        // Mark traversed 1 as 2\\n        grid[i][j] = 2;\\n        for(int d = 0; d < 4; d++){\\n            int ni = i + dir[d][0];\\n            int nj = j + dir[d][1];\\n            if(ni >= 0 && ni < m && nj >= 0 && nj < n){\\n                if(grid[ni][nj] <= 0){\\n                    zeroes.insert(ni * n + nj);\\n                    grid[ni][nj]--;\\n                }else if(grid[ni][nj] == 1){\\n                    markAndCountZeroes(grid, ni, nj, zeroes);\\n                }\\n            }\\n        }\\n    }\\n    \\n    int cleanAndWall(vector<vector<int>>& grid, int i, int j){\\n        // DFS to count walls to build\\n        // Clean up marks\\n        int walls = 0;\\n        // 3: walled 1\\'s\\n        grid[i][j] = 3;\\n        for(int d = 0; d < 4; d++){\\n            int ni = i + dir[d][0];\\n            int nj = j + dir[d][1];\\n            if(ni >= 0 && ni < m && nj >= 0 && nj < n){\\n                if(grid[ni][nj] <= 0){\\n                    walls++;\\n                    grid[ni][nj]++;\\n                }else if(grid[ni][nj] == 2){\\n                    walls += cleanAndWall(grid, ni, nj);\\n                }\\n            }\\n        }\\n        \\n        return walls;\\n    }\\n    \\n    void spread(vector<vector<int>>& grid){\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] < 0 || grid[i][j] == 2) grid[i][j] = 1;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n[[ 0, 1, 0, 0, 0, 0, 0, 1],\\n [ 0, 1, 0, 0, 0, 1, 0, 1],\\n [ 0, 0, 0, 0, 0, 1, 0, 1],\\n [ 0, 0, 0, 0, 0, 0, 0, 0]]\\n ```\n```\\n[[-1, 2,-1, 0, 0,-1,-1, 2],\\n [-1, 2,-1, 0,-1, 2,-2, 2],\\n [ 0,-1, 0, 0,-1, 2,-2, 2],\\n [ 0, 0, 0, 0, 0,-1, 0,-1]]\\n ```\n```\\n[[-1, 2,-1, 0, 0, 0,-1, 2],\\n [-1, 2,-1, 0, 0, 3,-1, 2],\\n [ 0,-1, 0, 0, 0, 3,-1, 2],\\n [ 0, 0, 0, 0, 0, 0, 0,-1]]\\n ```\n```\\n[[ 1, 1, 1, 0, 0, 0, 1, 1],\\n  [ 1, 1, 1, 0, 0, 3, 1, 1],\\n  [ 0, 1, 0, 0, 0, 3, 1, 1],\\n  [ 0, 0, 0, 0, 0, 0, 0, 1]]\\n ```\n```\\nclass Solution {\\n    int dir[4][2] = {\\n        {-1, 0}, {1, 0}, {0, -1}, {0, 1}  \\n    };\\n    int m, n;\\npublic:\\n    int containVirus(vector<vector<int>>& grid) {\\n        m = grid.size(), n = grid[0].size();\\n        int ans = 0;\\n        unordered_set<int> zeroes;\\n        int nextStart;\\n        while((nextStart = markAndGetNextStart(grid, zeroes)) != -1){\\n            ans += cleanAndWall(grid, nextStart / n, nextStart % n);\\n            spread(grid);\\n        }\\n        return ans;\\n    }\\n    \\n    int markAndGetNextStart(vector<vector<int>>& grid, unordered_set<int>& zeroes){\\n        int nextStart = -1;\\n        int nextSaved = 0;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] != 1) continue;\\n                zeroes.clear();\\n                markAndCountZeroes(grid, i, j, zeroes);\\n                if(zeroes.size() > nextSaved){\\n                    nextStart = i * n + j;\\n                    nextSaved = zeroes.size();\\n                }\\n            }\\n        }\\n        return nextStart;\\n    }\\n    \\n    void markAndCountZeroes(vector<vector<int>>& grid, int i, int j, unordered_set<int>& zeroes){\\n        // DFS to get affected 0\\'s after this round\\n        // Mark affected 0\\'s by subtracting 1\\n        // Mark traversed 1 as 2\\n        grid[i][j] = 2;\\n        for(int d = 0; d < 4; d++){\\n            int ni = i + dir[d][0];\\n            int nj = j + dir[d][1];\\n            if(ni >= 0 && ni < m && nj >= 0 && nj < n){\\n                if(grid[ni][nj] <= 0){\\n                    zeroes.insert(ni * n + nj);\\n                    grid[ni][nj]--;\\n                }else if(grid[ni][nj] == 1){\\n                    markAndCountZeroes(grid, ni, nj, zeroes);\\n                }\\n            }\\n        }\\n    }\\n    \\n    int cleanAndWall(vector<vector<int>>& grid, int i, int j){\\n        // DFS to count walls to build\\n        // Clean up marks\\n        int walls = 0;\\n        // 3: walled 1\\'s\\n        grid[i][j] = 3;\\n        for(int d = 0; d < 4; d++){\\n            int ni = i + dir[d][0];\\n            int nj = j + dir[d][1];\\n            if(ni >= 0 && ni < m && nj >= 0 && nj < n){\\n                if(grid[ni][nj] <= 0){\\n                    walls++;\\n                    grid[ni][nj]++;\\n                }else if(grid[ni][nj] == 2){\\n                    walls += cleanAndWall(grid, ni, nj);\\n                }\\n            }\\n        }\\n        \\n        return walls;\\n    }\\n    \\n    void spread(vector<vector<int>>& grid){\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] < 0 || grid[i][j] == 2) grid[i][j] = 1;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538686,
                "title": "javascript-solution",
                "content": "This would\\'ve been super hard if it weren\\'t for this note\\n**\"...you can install walls around only one region -- the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night.\"**\\n\\n```javascript\\nvar containVirus = function(grid) {\\n  const infected = 1;\\n  const healthy = 0;\\n  const quarantined = 2;\\n  const directions = [[1,0],[-1,0],[0,1],[0,-1]];\\n  const mod = 100;\\n  const encode = (row, col) => row + (col * mod);\\n  const decode = (num) => [num % mod, Math.floor(num / mod)];\\n\\n  const disjointSet = {};\\n  for (let row = 0; row < grid.length; row++) {\\n    for (let col = 0; col < grid[row].length; col++) {\\n      const coord = encode(row, col);\\n      disjointSet[coord] = coord;\\n      if (grid[row][col] === 0) continue;\\n      if (grid[row][col - 1] === 1) union(coord, encode(row, col - 1));\\n      if (row > 0 && grid[row - 1][col] === 1) union(coord, encode(row - 1, col));\\n    }\\n  }\\n\\n  let numWalls = 0;\\n  while (true) {\\n    const impact = quarantineAndContaminate()\\n    if (impact === 0) return numWalls;\\n    numWalls += impact;\\n    spreadVirus();\\n  }\\n\\n  function find(coord) {\\n      return disjointSet[coord] = disjointSet[coord] === coord ? coord : find(disjointSet[coord]);\\n  }\\n\\n  function union(coord, toCoord) {\\n      return disjointSet[find(coord)] = find(toCoord)\\n  }\\n\\n  function quarantineAndContaminate() {\\n    const impact = new Map();\\n    for (let row = 0; row < grid.length; row++) {\\n      for (let col = 0; col < grid[row].length; col++) {\\n        if (grid[row][col] !== infected) continue;\\n        const root = find(encode(row, col));\\n        if (!impact.has(root)) impact.set(root, new Set());\\n        for (let [down, right] of directions) {\\n          if (grid[row + down] && grid[row + down][col + right] === healthy) {\\n            impact.get(root).add(encode(row + down, col + right));\\n          }\\n        }\\n      }\\n    }\\n    let impactedCoords = new Set();\\n    let root = null;\\n    for (let [node, coords] of impact) {\\n      if (impactedCoords.size < coords.size) {\\n        impactedCoords = coords;\\n        root = node\\n      }\\n    }\\n    if (impactedCoords.size === 0) return 0;\\n    return quarantine(...decode(root));\\n  }\\n\\n  function quarantine(row, col) {\\n    if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length) return 0;\\n    if (grid[row][col] === 2) return 0;\\n    if (grid[row][col] === 0) return 1;\\n    let totalWalls = 0;\\n    grid[row][col] = 2;\\n    for (let [down, right] of directions) {\\n      totalWalls += quarantine(row + down, col + right);\\n    }\\n    return totalWalls;\\n  }\\n\\n  function spreadVirus() {\\n    const infectedCoords = new Set();\\n    for (let row = 0; row < grid.length; row++) {\\n      for (let col = 0; col < grid[row].length; col++) {\\n        if (grid[row][col] !== healthy) continue\\n        for (let [down, right] of directions) {\\n          if (grid[row + down] && grid[row + down][col + right] === infected) {\\n            infectedCoords.add(encode(row, col))\\n          }\\n        }\\n      }\\n    }\\n    for (let coord of infectedCoords) {\\n      const [row, col] = decode(coord);\\n      grid[row][col] = 1;\\n      for (let [down, right] of directions) {\\n        if (grid[row + down] && grid[row + down][col + right] === 1) {\\n          union(coord, encode(row + down, col + right));\\n        }\\n      }\\n    }\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar containVirus = function(grid) {\\n  const infected = 1;\\n  const healthy = 0;\\n  const quarantined = 2;\\n  const directions = [[1,0],[-1,0],[0,1],[0,-1]];\\n  const mod = 100;\\n  const encode = (row, col) => row + (col * mod);\\n  const decode = (num) => [num % mod, Math.floor(num / mod)];\\n\\n  const disjointSet = {};\\n  for (let row = 0; row < grid.length; row++) {\\n    for (let col = 0; col < grid[row].length; col++) {\\n      const coord = encode(row, col);\\n      disjointSet[coord] = coord;\\n      if (grid[row][col] === 0) continue;\\n      if (grid[row][col - 1] === 1) union(coord, encode(row, col - 1));\\n      if (row > 0 && grid[row - 1][col] === 1) union(coord, encode(row - 1, col));\\n    }\\n  }\\n\\n  let numWalls = 0;\\n  while (true) {\\n    const impact = quarantineAndContaminate()\\n    if (impact === 0) return numWalls;\\n    numWalls += impact;\\n    spreadVirus();\\n  }\\n\\n  function find(coord) {\\n      return disjointSet[coord] = disjointSet[coord] === coord ? coord : find(disjointSet[coord]);\\n  }\\n\\n  function union(coord, toCoord) {\\n      return disjointSet[find(coord)] = find(toCoord)\\n  }\\n\\n  function quarantineAndContaminate() {\\n    const impact = new Map();\\n    for (let row = 0; row < grid.length; row++) {\\n      for (let col = 0; col < grid[row].length; col++) {\\n        if (grid[row][col] !== infected) continue;\\n        const root = find(encode(row, col));\\n        if (!impact.has(root)) impact.set(root, new Set());\\n        for (let [down, right] of directions) {\\n          if (grid[row + down] && grid[row + down][col + right] === healthy) {\\n            impact.get(root).add(encode(row + down, col + right));\\n          }\\n        }\\n      }\\n    }\\n    let impactedCoords = new Set();\\n    let root = null;\\n    for (let [node, coords] of impact) {\\n      if (impactedCoords.size < coords.size) {\\n        impactedCoords = coords;\\n        root = node\\n      }\\n    }\\n    if (impactedCoords.size === 0) return 0;\\n    return quarantine(...decode(root));\\n  }\\n\\n  function quarantine(row, col) {\\n    if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length) return 0;\\n    if (grid[row][col] === 2) return 0;\\n    if (grid[row][col] === 0) return 1;\\n    let totalWalls = 0;\\n    grid[row][col] = 2;\\n    for (let [down, right] of directions) {\\n      totalWalls += quarantine(row + down, col + right);\\n    }\\n    return totalWalls;\\n  }\\n\\n  function spreadVirus() {\\n    const infectedCoords = new Set();\\n    for (let row = 0; row < grid.length; row++) {\\n      for (let col = 0; col < grid[row].length; col++) {\\n        if (grid[row][col] !== healthy) continue\\n        for (let [down, right] of directions) {\\n          if (grid[row + down] && grid[row + down][col + right] === infected) {\\n            infectedCoords.add(encode(row, col))\\n          }\\n        }\\n      }\\n    }\\n    for (let coord of infectedCoords) {\\n      const [row, col] = decode(coord);\\n      grid[row][col] = 1;\\n      for (let [down, right] of directions) {\\n        if (grid[row + down] && grid[row + down][col + right] === 1) {\\n          union(coord, encode(row + down, col + right));\\n        }\\n      }\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 412816,
                "title": "python-dfs-70-loc",
                "content": "Code is pretty much self-explanatory, we use DFS to find groups each turn, then find the maximum group by affected cells using key=affected_cells. After that we count the number of walls needs to be build and change the value of the current group to group_index.\\n```\\nclass Solution:\\n    def containVirus(self, grid: List[List[int]]) -> int:\\n        d = ((0, 1), (0, -1), (1, 0), (-1, 0))\\n        def in_grid(i, j):\\n            return not(i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]))\\n        def dfs(i, j, res, visited):\\n            for di, dj in d:\\n                ci, cj = i + di, j + dj\\n                if  not in_grid(ci, cj) or grid[ci][cj] != 1 or (ci, cj) in visited:\\n                    continue\\n                res.add((ci, cj))\\n                visited.add((ci, cj))\\n                dfs(ci, cj, res, visited)\\n        def get_groups():\\n            groups = []\\n            visited = set()\\n            for i in range(len(grid)):\\n                for j in range(len(grid[0])):\\n                    if grid[i][j] == 1 and (i, j) not in visited:\\n                        group = set()\\n                        group.add((i, j))\\n                        dfs(i, j, group, visited)\\n                        groups.append(group)\\n            return groups\\n        def affected_cells(group):\\n            res = set()\\n            for i, j in group:\\n                for di, dj in d:\\n                    ci, cj = i + di, j + dj\\n                    if not in_grid(ci, cj) or grid[ci][cj] > 0:\\n                        continue\\n                    res.add((ci, cj))\\n            return len(res)\\n        \\n        def build_walls(group, new_v):\\n            res = 0\\n            for i, j in group:\\n                for di, dj in d:\\n                    ci, cj = i + di, j + dj\\n                    if not in_grid(ci, cj) or grid[ci][cj] > 0:\\n                        continue\\n                    res += 1\\n                grid[i][j] = new_v\\n            return res\\n        group_index = 2\\n        walls_count = 0\\n        def expand_groups(groups):\\n            cur = []\\n            for g in groups:\\n                for i, j in g:\\n                    cur.append((i, j))\\n            for i, j in cur:\\n                for di, dj in d:\\n                    ci, cj = i + di, j + dj\\n                    if not in_grid(ci, cj) or grid[ci][cj] > 0:\\n                        continue\\n                    grid[ci][cj] = 1\\n        while True:\\n            cur_groups = get_groups()\\n            if not cur_groups:\\n                break\\n            max_group = max(cur_groups, key=affected_cells)\\n            \\n            walls_count += build_walls(max_group, group_index)\\n            cur_groups.remove(max_group)\\n            if not cur_groups:\\n                break\\n            expand_groups(cur_groups)\\n            \\n            group_index += 1\\n            \\n        return walls_count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def containVirus(self, grid: List[List[int]]) -> int:\\n        d = ((0, 1), (0, -1), (1, 0), (-1, 0))\\n        def in_grid(i, j):\\n            return not(i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]))\\n        def dfs(i, j, res, visited):\\n            for di, dj in d:\\n                ci, cj = i + di, j + dj\\n                if  not in_grid(ci, cj) or grid[ci][cj] != 1 or (ci, cj) in visited:\\n                    continue\\n                res.add((ci, cj))\\n                visited.add((ci, cj))\\n                dfs(ci, cj, res, visited)\\n        def get_groups():\\n            groups = []\\n            visited = set()\\n            for i in range(len(grid)):\\n                for j in range(len(grid[0])):\\n                    if grid[i][j] == 1 and (i, j) not in visited:\\n                        group = set()\\n                        group.add((i, j))\\n                        dfs(i, j, group, visited)\\n                        groups.append(group)\\n            return groups\\n        def affected_cells(group):\\n            res = set()\\n            for i, j in group:\\n                for di, dj in d:\\n                    ci, cj = i + di, j + dj\\n                    if not in_grid(ci, cj) or grid[ci][cj] > 0:\\n                        continue\\n                    res.add((ci, cj))\\n            return len(res)\\n        \\n        def build_walls(group, new_v):\\n            res = 0\\n            for i, j in group:\\n                for di, dj in d:\\n                    ci, cj = i + di, j + dj\\n                    if not in_grid(ci, cj) or grid[ci][cj] > 0:\\n                        continue\\n                    res += 1\\n                grid[i][j] = new_v\\n            return res\\n        group_index = 2\\n        walls_count = 0\\n        def expand_groups(groups):\\n            cur = []\\n            for g in groups:\\n                for i, j in g:\\n                    cur.append((i, j))\\n            for i, j in cur:\\n                for di, dj in d:\\n                    ci, cj = i + di, j + dj\\n                    if not in_grid(ci, cj) or grid[ci][cj] > 0:\\n                        continue\\n                    grid[ci][cj] = 1\\n        while True:\\n            cur_groups = get_groups()\\n            if not cur_groups:\\n                break\\n            max_group = max(cur_groups, key=affected_cells)\\n            \\n            walls_count += build_walls(max_group, group_index)\\n            cur_groups.remove(max_group)\\n            if not cur_groups:\\n                break\\n            expand_groups(cur_groups)\\n            \\n            group_index += 1\\n            \\n        return walls_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 341176,
                "title": "straight-forward-python-solution-using-bfs-and-dfs",
                "content": "Honestly, I don\\'t want to go back and take a look at this dump even for a second.\\nDFS and BFS has no difference in this question, I just want to make my code more diversidied.\\nI used BFS to tranverse all the virus groups so far, and record the uninfected cells around them by minus their value by 1;\\nThen I use DFS to tranverse the virus group that will infect the most number of health cells, and disrecord these health cells by plus their value by 1 (since by building walls they won\\'t be infected by this virus group).\\nLastly, I change all the uninfected cells with a negative value to infected cells.\\n```\\nclass Solution:\\n    def containVirus(self, grid: List[List[int]]) -> int:\\n        rl, cl, ans = len(grid), len(grid[0]), 0\\n        self.blocked = set()\\n        while True:\\n            de = ((1,0),(0,1),(-1,0),(0,-1))\\n            self.seen, memo = set(), {}\\n            \\n            def bfs(x,y):\\n                counted = set()\\n                self.seen.add((x,y))\\n                q = collections.deque([(x,y)])\\n                while q:\\n                    cur = q.popleft()\\n                    for d in de:\\n                        nx = cur[0] + d[0]\\n                        ny = cur[1] + d[1]\\n                        if 0 <= nx < rl and 0 <= ny < cl:\\n                            if grid[nx][ny] == 1:\\n                                if (nx,ny) not in self.seen and (nx,ny) not in self.blocked:\\n                                    self.seen.add((nx,ny))\\n                                    q += (nx,ny),\\n                            else:\\n                                counted.add((nx,ny))\\n                                grid[nx][ny] -= 1\\n                return len(counted)\\n            \\n            def dfs(x,y):\\n                walls = 0\\n                self.blocked.add((x,y))\\n                for d in de:\\n                    nx = x + d[0]\\n                    ny = y + d[1]\\n                    if 0 <= nx < rl and 0 <= ny < cl:\\n                        if grid[nx][ny] < 0:\\n                            grid[nx][ny] += 1\\n                            walls += 1\\n                        elif grid[nx][ny] == 1 and (nx,ny) not in self.blocked:\\n                            walls += dfs(nx,ny)\\n                return walls\\n            \\n            for i in range(rl):\\n                for j in range(cl):\\n                    if grid[i][j] == 1 and (i,j) not in self.seen and (i,j) not in self.blocked:\\n                        memo[(i,j)] = bfs(i,j)\\n            if all(not i for i in memo.values()):\\n                return ans\\n            ans += dfs(*max(memo, key = memo.get))\\n            for i in range(rl):\\n                for j in range(cl):\\n                    if grid[i][j] < 0:\\n                        grid[i][j] = 1\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def containVirus(self, grid: List[List[int]]) -> int:\\n        rl, cl, ans = len(grid), len(grid[0]), 0\\n        self.blocked = set()\\n        while True:\\n            de = ((1,0),(0,1),(-1,0),(0,-1))\\n            self.seen, memo = set(), {}\\n            \\n            def bfs(x,y):\\n                counted = set()\\n                self.seen.add((x,y))\\n                q = collections.deque([(x,y)])\\n                while q:\\n                    cur = q.popleft()\\n                    for d in de:\\n                        nx = cur[0] + d[0]\\n                        ny = cur[1] + d[1]\\n                        if 0 <= nx < rl and 0 <= ny < cl:\\n                            if grid[nx][ny] == 1:\\n                                if (nx,ny) not in self.seen and (nx,ny) not in self.blocked:\\n                                    self.seen.add((nx,ny))\\n                                    q += (nx,ny),\\n                            else:\\n                                counted.add((nx,ny))\\n                                grid[nx][ny] -= 1\\n                return len(counted)\\n            \\n            def dfs(x,y):\\n                walls = 0\\n                self.blocked.add((x,y))\\n                for d in de:\\n                    nx = x + d[0]\\n                    ny = y + d[1]\\n                    if 0 <= nx < rl and 0 <= ny < cl:\\n                        if grid[nx][ny] < 0:\\n                            grid[nx][ny] += 1\\n                            walls += 1\\n                        elif grid[nx][ny] == 1 and (nx,ny) not in self.blocked:\\n                            walls += dfs(nx,ny)\\n                return walls\\n            \\n            for i in range(rl):\\n                for j in range(cl):\\n                    if grid[i][j] == 1 and (i,j) not in self.seen and (i,j) not in self.blocked:\\n                        memo[(i,j)] = bfs(i,j)\\n            if all(not i for i in memo.values()):\\n                return ans\\n            ans += dfs(*max(memo, key = memo.get))\\n            for i in range(rl):\\n                for j in range(cl):\\n                    if grid[i][j] < 0:\\n                        grid[i][j] = 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 331550,
                "title": "union-find-of-frontier-solution",
                "content": "The idea is as follows:\\n\\n1. Use union find to find all connected components.\\n2. Find the frontiers of each connected components. Frontiers are the healthy neighbors of the contaminated regions. The frontiers will be contaminated if not quarantined around them. \\n3. We calcualate the number of frontiers of each contaminated region, and quarantine the contaminated region with the largest frontier value with -1.\\n4. For all other contaminated regions, we mark all their frontiers as contaminated and union them, avoiding  searching the whole grid.\\n5. For all these contaminated frontiers, we find their frontiers, arranged by contaminated regions, these are the ones to be affected in the next round.\\n6. Repeat the whole process.\\n\\nThe algorithm runs not as fast, but avoids searching the whole grid. I think it can be optimized, but I need rest for now.\\n\\n\\n\\n```\\nclass Solution(object):\\n    def __init__(self):\\n        self.m = -1\\n        self.n = -1\\n        self.grid = None\\n        self.sets = None\\n        self.neighbors = None\\n        self.allzeros = True\\n        self.walls = 0\\n                    \\n    def containVirus(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        self.m = len(grid)\\n        self.n = len(grid[0])\\n        self.grid = grid\\n        self.sets = range(self.m*self.n)\\n        self.neighbors = collections.defaultdict(set)\\n        self.allzeros = True\\n        for i in range(self.m):\\n            for j in range(self.n):\\n                if grid[i][j] > 0:\\n                    self.allzeros = False\\n                    cleans, sicks = self.getNeighbors(i,j)\\n                    for p, q in sicks:\\n                        self.union(i, j, p, q)\\n                    self.addCleanNeighbors(i, j, cleans)\\n\\n        if self.allzeros:\\n            return 0     \\n        \\n        for i,v in enumerate(self.sets):\\n            v = self.__find(i)\\n            \\n        \\n        keys = self.neighbors.keys()\\n        for k in keys:\\n            k1 = self.__find(k)\\n            if k!= k1 and k in self.neighbors:\\n                self.neighbors[k1] |= self.neighbors[k]\\n                del self.neighbors[k]\\n        \\n        while self.neighbors:\\n            key, neighbors = self.whichToQuarantine()\\n            self.quarantine(key, neighbors)\\n        return self.walls\\n                        \\n   \\n        \\n    \\n    \\n    def getNeighbors(self, i, j):\\n        cleans = []\\n        sicks = []\\n        for p, q in [(-1, 0), (1,0), (0,-1), (0,1)]:\\n            if i + p >= 0 and i + p < self.m and j + q >= 0 and j + q < self.n:\\n                if self.grid[i+p][j+q] > 0:\\n                    sicks.append((i+p, j+q))\\n                elif self.grid[i+p][j+q] == 0:\\n                    cleans.append((i+p, j+q))\\n        return cleans, sicks\\n    \\n        \\n    def getIndex(self, i, j):\\n        return i*self.n + j\\n    \\n    \\n    def addCleanNeighbors(self, i, j, cleans):\\n        k = self.getIndex(i,j)\\n        for p, q in cleans:\\n            self.neighbors[k].add((p,q))\\n    \\n    def find(self, i, j):\\n        k = self.getIndex(i,j)\\n        return self.__find(k)\\n    \\n    def __find(self, k):\\n        while self.sets[k] != k:\\n            k = self.sets[k]\\n        return k\\n    \\n    def __union(self, k1, k2):\\n        k1 = self.__find(k1)\\n        k2 = self.__find(k2)\\n        self.sets[k1] = k2\\n        \\n                \\n    def union(self, i, j, p, q):\\n        k1 = self.getIndex(i,j)\\n        k2 = self.getIndex(p,q)\\n        \\n        self.__union(k1, k2)\\n        \\n        \\n    def whichToQuarantine(self):\\n        # The contaminated regions which contaminate uniquely the most cells in next step\\n        # These to-be contaminated cells must not be another contaminated regions\\' neighbors,\\n        # and must be the neighbors of the region we are investigating now\\n        keys = self.neighbors.keys()\\n        \\n        key = keys[0]\\n        \\n        for k in keys:            \\n            if len(self.neighbors[k]) > len(self.neighbors[key]):\\n                key = k\\n        \\n        return key, self.neighbors[key]\\n        \\n    def quarantine(self, key, neighbors):\\n        #self.__printGrid()\\n        for i, j in neighbors:\\n            _, sicks = self.getNeighbors(i,j)\\n            for i, j in sicks:\\n                if self.find(i,j) == key:\\n                    self.walls += 1\\n        #print \"after quarantine (%d, %d), the walls is %d\" % (key/self.n, key%self.n, self.walls)\\n        del self.neighbors[key]\\n        # Mark as not infectible\\n        for i in range(len(self.sets)):\\n            if self.__find(i) == key:\\n                self.grid[i/self.n][i%self.n] = -1\\n                \\n       \\n        # Other contaminate regions start propogating\\n        keys = self.neighbors.keys()\\n        # Mark frontiers as contaminated\\n        for k in keys:\\n            neighbors = self.neighbors[k]\\n            for i, j in neighbors:\\n                self.grid[i][j] = 1\\n                cleans, sicks = self.getNeighbors(i,j)\\n                for p, q in sicks:\\n                    self.union(i,j,p,q)\\n                    \\n        # Get the new frontiers\\n        for k in keys: \\n            neighbors = self.neighbors[k]\\n            del self.neighbors[k]\\n            for i, j in neighbors:\\n                    cleans, sicks = self.getNeighbors(i,j)\\n                    self.addCleanNeighbors(i,j,cleans)\\n        keys = self.neighbors.keys()\\n        #self.__printNeighbors()\\n        # Condense the frontiers\\n        for k in keys:\\n            k1 = self.__find(k)\\n\\n            if k1 != k:\\n                #print \"union neighbors of (%d, %d) and (%d, %d)\" % (k/self.n, k%self.n, k1/self.n, k1%self.n)\\n                self.neighbors[k1] |= self.neighbors[k]\\n                #print self.neighbors[k1]\\n                del self.neighbors[k]\\n                #print self.neighbors[k1]\\n        \\n        #print \"updated neighbors and sets\"\\n        #self.__printSets()\\n        #self.__printNeighbors()\\n        return self.walls\\n                \\n    def __printSets(self):\\n        sets = set()\\n        for i in range(len(self.sets)):\\n            v = self.__find(i)\\n            if v not in sets and self.grid[v/self.n][v%self.n] >=0:\\n                sets.add(v)\\n        string = \"remaining cc\\'s:\"    \\n        for i in sets:\\n            if self.grid[i/self.n][i%self.n] > 0:\\n                string += \"(%d, %d), \" % (i/self.n, i%self.n)\\n        print string[:-2]\\n        print \"done printing sets\"\\n\\n    def __printGrid(self):\\n        print \"printing grid\"\\n        \\n        for i, l in enumerate(self.grid):\\n            print \"%d %s\" % (i, str(l))\\n        print \"   %s\" % (str(range(len(self.grid[0]))))\\n        print \"done printing grid\"\\n        \\n    def __printNeighbors(self):\\n        for k in self.neighbors:\\n            string = \"Neighbors of (%d, %d): ( \" % (k/self.n, k%self.n)\\n            for i,j in self.neighbors[k]:\\n                string += \"(%d, %d), \" % (i,j)\\n        \\n            print \"%s )\" % string[:-2]\\n        \\n        \\n                    \\n                    \\n",
                "solutionTags": [],
                "code": "The idea is as follows:\\n\\n1. Use union find to find all connected components.\\n2. Find the frontiers of each connected components. Frontiers are the healthy neighbors of the contaminated regions. The frontiers will be contaminated if not quarantined around them. \\n3. We calcualate the number of frontiers of each contaminated region, and quarantine the contaminated region with the largest frontier value with -1.\\n4. For all other contaminated regions, we mark all their frontiers as contaminated and union them, avoiding  searching the whole grid.\\n5. For all these contaminated frontiers, we find their frontiers, arranged by contaminated regions, these are the ones to be affected in the next round.\\n6. Repeat the whole process.\\n\\nThe algorithm runs not as fast, but avoids searching the whole grid. I think it can be optimized, but I need rest for now.\\n\\n\\n\\n```\\nclass Solution(object):\\n    def __init__(self):\\n        self.m = -1\\n        self.n = -1\\n        self.grid = None\\n        self.sets = None\\n        self.neighbors = None\\n        self.allzeros = True\\n        self.walls = 0\\n                    \\n    def containVirus(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        self.m = len(grid)\\n        self.n = len(grid[0])\\n        self.grid = grid\\n        self.sets = range(self.m*self.n)\\n        self.neighbors = collections.defaultdict(set)\\n        self.allzeros = True\\n        for i in range(self.m):\\n            for j in range(self.n):\\n                if grid[i][j] > 0:\\n                    self.allzeros = False\\n                    cleans, sicks = self.getNeighbors(i,j)\\n                    for p, q in sicks:\\n                        self.union(i, j, p, q)\\n                    self.addCleanNeighbors(i, j, cleans)\\n\\n        if self.allzeros:\\n            return 0     \\n        \\n        for i,v in enumerate(self.sets):\\n            v = self.__find(i)\\n            \\n        \\n        keys = self.neighbors.keys()\\n        for k in keys:\\n            k1 = self.__find(k)\\n            if k!= k1 and k in self.neighbors:\\n                self.neighbors[k1] |= self.neighbors[k]\\n                del self.neighbors[k]\\n        \\n        while self.neighbors:\\n            key, neighbors = self.whichToQuarantine()\\n            self.quarantine(key, neighbors)\\n        return self.walls\\n                        \\n   \\n        \\n    \\n    \\n    def getNeighbors(self, i, j):\\n        cleans = []\\n        sicks = []\\n        for p, q in [(-1, 0), (1,0), (0,-1), (0,1)]:\\n            if i + p >= 0 and i + p < self.m and j + q >= 0 and j + q < self.n:\\n                if self.grid[i+p][j+q] > 0:\\n                    sicks.append((i+p, j+q))\\n                elif self.grid[i+p][j+q] == 0:\\n                    cleans.append((i+p, j+q))\\n        return cleans, sicks\\n    \\n        \\n    def getIndex(self, i, j):\\n        return i*self.n + j\\n    \\n    \\n    def addCleanNeighbors(self, i, j, cleans):\\n        k = self.getIndex(i,j)\\n        for p, q in cleans:\\n            self.neighbors[k].add((p,q))\\n    \\n    def find(self, i, j):\\n        k = self.getIndex(i,j)\\n        return self.__find(k)\\n    \\n    def __find(self, k):\\n        while self.sets[k] != k:\\n            k = self.sets[k]\\n        return k\\n    \\n    def __union(self, k1, k2):\\n        k1 = self.__find(k1)\\n        k2 = self.__find(k2)\\n        self.sets[k1] = k2\\n        \\n                \\n    def union(self, i, j, p, q):\\n        k1 = self.getIndex(i,j)\\n        k2 = self.getIndex(p,q)\\n        \\n        self.__union(k1, k2)\\n        \\n        \\n    def whichToQuarantine(self):\\n        # The contaminated regions which contaminate uniquely the most cells in next step\\n        # These to-be contaminated cells must not be another contaminated regions\\' neighbors,\\n        # and must be the neighbors of the region we are investigating now\\n        keys = self.neighbors.keys()\\n        \\n        key = keys[0]\\n        \\n        for k in keys:            \\n            if len(self.neighbors[k]) > len(self.neighbors[key]):\\n                key = k\\n        \\n        return key, self.neighbors[key]\\n        \\n    def quarantine(self, key, neighbors):\\n        #self.__printGrid()\\n        for i, j in neighbors:\\n            _, sicks = self.getNeighbors(i,j)\\n            for i, j in sicks:\\n                if self.find(i,j) == key:\\n                    self.walls += 1\\n        #print \"after quarantine (%d, %d), the walls is %d\" % (key/self.n, key%self.n, self.walls)\\n        del self.neighbors[key]\\n        # Mark as not infectible\\n        for i in range(len(self.sets)):\\n            if self.__find(i) == key:\\n                self.grid[i/self.n][i%self.n] = -1\\n                \\n       \\n        # Other contaminate regions start propogating\\n        keys = self.neighbors.keys()\\n        # Mark frontiers as contaminated\\n        for k in keys:\\n            neighbors = self.neighbors[k]\\n            for i, j in neighbors:\\n                self.grid[i][j] = 1\\n                cleans, sicks = self.getNeighbors(i,j)\\n                for p, q in sicks:\\n                    self.union(i,j,p,q)\\n                    \\n        # Get the new frontiers\\n        for k in keys: \\n            neighbors = self.neighbors[k]\\n            del self.neighbors[k]\\n            for i, j in neighbors:\\n                    cleans, sicks = self.getNeighbors(i,j)\\n                    self.addCleanNeighbors(i,j,cleans)\\n        keys = self.neighbors.keys()\\n        #self.__printNeighbors()\\n        # Condense the frontiers\\n        for k in keys:\\n            k1 = self.__find(k)\\n\\n            if k1 != k:\\n                #print \"union neighbors of (%d, %d) and (%d, %d)\" % (k/self.n, k%self.n, k1/self.n, k1%self.n)\\n                self.neighbors[k1] |= self.neighbors[k]\\n                #print self.neighbors[k1]\\n                del self.neighbors[k]\\n                #print self.neighbors[k1]\\n        \\n        #print \"updated neighbors and sets\"\\n        #self.__printSets()\\n        #self.__printNeighbors()\\n        return self.walls\\n                \\n    def __printSets(self):\\n        sets = set()\\n        for i in range(len(self.sets)):\\n            v = self.__find(i)\\n            if v not in sets and self.grid[v/self.n][v%self.n] >=0:\\n                sets.add(v)\\n        string = \"remaining cc\\'s:\"    \\n        for i in sets:\\n            if self.grid[i/self.n][i%self.n] > 0:\\n                string += \"(%d, %d), \" % (i/self.n, i%self.n)\\n        print string[:-2]\\n        print \"done printing sets\"\\n\\n    def __printGrid(self):\\n        print \"printing grid\"\\n        \\n        for i, l in enumerate(self.grid):\\n            print \"%d %s\" % (i, str(l))\\n        print \"   %s\" % (str(range(len(self.grid[0]))))\\n        print \"done printing grid\"\\n        \\n    def __printNeighbors(self):\\n        for k in self.neighbors:\\n            string = \"Neighbors of (%d, %d): ( \" % (k/self.n, k%self.n)\\n            for i,j in self.neighbors[k]:\\n                string += \"(%d, %d), \" % (i,j)\\n        \\n            print \"%s )\" % string[:-2]\\n        \\n        \\n                    \\n                    \\n",
                "codeTag": "Java"
            },
            {
                "id": 298857,
                "title": "python3-ugly-code",
                "content": "```\\nclass Solution(object):\\n    def containVirus(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m, n = len(grid), len(grid[0])\\n\\t\\t\\n\\t\\t# helper function: return the neighbors for (i, j) within the grid\\n        def nbr(i, j):\\n            return [(i+di, j+dj) for (di, dj) in [(0, 1), (0, -1), (1, 0), (-1, 0)] if i+di>=0 and i + di < m and j + dj >= 0 and j+dj < n]\\n            \\n         # identify the clusters of 1\\'s\\n        def find_region(i, j, visited):\\n            if grid[i][j] <= 0 or (i, j) in visited: return False\\n            visited.add((i, j))\\n            stack = [(i, j)]\\n            while stack:\\n                i, j = stack.pop()\\n                for ni, nj in nbr(i, j):\\n                    if (ni, nj) not in visited and grid[ni][nj] > 0:\\n                        visited.add((ni, nj))\\n                        stack.append((ni, nj))\\n            return True\\n        \\n\\t\\t# preprocessing at the beginning of each rounc of simulation\\n        def process():\\n            regions = dict()\\n            r = 1\\n            visited = set()\\n            for i in range(m):\\n                for j in range(n):\\n                    if find_region(i, j, visited):\\n                        regions[r] = (i, j)\\n                        r += 1\\n            return regions\\n\\n\\t\\t# infect from (i, j)\\n        def infects(i, j):\\n            # return (infect_sources, infected_cells)\\n            infect_sources = 0\\n            infected_cells = []\\n            visited = set([(i, j)])\\n            stack = [(i, j)]\\n            while stack:\\n                i, j = stack.pop()\\n                for ni, nj in nbr(i, j):\\n                    if grid[ni][nj] == 0: \\n                        infect_sources += 1\\n                    if (ni, nj) in visited or grid[ni][nj] < 0: continue\\n                    visited.add((ni, nj))\\n                    if grid[ni][nj] == 0: \\n                        infected_cells.append((ni, nj))\\n                    elif grid[ni][nj] > 0:\\n                        stack.append((ni, nj))\\n            return (infect_sources, infected_cells)\\n         \\n        def cure(i, j):\\n            stack = [(i, j)]\\n            while stack:\\n                i, j = stack.pop()\\n                grid[i][j] = -1\\n                for ni, nj in nbr(i, j):\\n                    if grid[ni][nj] != 1: continue\\n                    stack.append((ni, nj))\\n        \\n        ans = 0\\n        while 1:\\n            regions = process()\\n            worst_region = walls = -1\\n            infected = None\\n            affected = dict()\\n            for r, (i, j) in regions.items():\\n                infect_sources, infected_cells = infects(i, j)\\n                affected[r] = infected_cells\\n                if infected is None or len(infected_cells) > len(infected):\\n                    infected = infected_cells\\n                    worst_region = r\\n                    walls = infect_sources\\n            if infected is None: return ans\\n            ans += walls\\n            i, j = regions[worst_region]\\n            cure(i, j)\\n            affected.pop(worst_region)\\n            for r in affected.values():\\n                for i, j in r:\\n                    grid[i][j] = 1\\n            \\n                    \\n            \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def containVirus(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m, n = len(grid), len(grid[0])\\n\\t\\t\\n\\t\\t# helper function: return the neighbors for (i, j) within the grid\\n        def nbr(i, j):\\n            return [(i+di, j+dj) for (di, dj) in [(0, 1), (0, -1), (1, 0), (-1, 0)] if i+di>=0 and i + di < m and j + dj >= 0 and j+dj < n]\\n            \\n         # identify the clusters of 1\\'s\\n        def find_region(i, j, visited):\\n            if grid[i][j] <= 0 or (i, j) in visited: return False\\n            visited.add((i, j))\\n            stack = [(i, j)]\\n            while stack:\\n                i, j = stack.pop()\\n                for ni, nj in nbr(i, j):\\n                    if (ni, nj) not in visited and grid[ni][nj] > 0:\\n                        visited.add((ni, nj))\\n                        stack.append((ni, nj))\\n            return True\\n        \\n\\t\\t# preprocessing at the beginning of each rounc of simulation\\n        def process():\\n            regions = dict()\\n            r = 1\\n            visited = set()\\n            for i in range(m):\\n                for j in range(n):\\n                    if find_region(i, j, visited):\\n                        regions[r] = (i, j)\\n                        r += 1\\n            return regions\\n\\n\\t\\t# infect from (i, j)\\n        def infects(i, j):\\n            # return (infect_sources, infected_cells)\\n            infect_sources = 0\\n            infected_cells = []\\n            visited = set([(i, j)])\\n            stack = [(i, j)]\\n            while stack:\\n                i, j = stack.pop()\\n                for ni, nj in nbr(i, j):\\n                    if grid[ni][nj] == 0: \\n                        infect_sources += 1\\n                    if (ni, nj) in visited or grid[ni][nj] < 0: continue\\n                    visited.add((ni, nj))\\n                    if grid[ni][nj] == 0: \\n                        infected_cells.append((ni, nj))\\n                    elif grid[ni][nj] > 0:\\n                        stack.append((ni, nj))\\n            return (infect_sources, infected_cells)\\n         \\n        def cure(i, j):\\n            stack = [(i, j)]\\n            while stack:\\n                i, j = stack.pop()\\n                grid[i][j] = -1\\n                for ni, nj in nbr(i, j):\\n                    if grid[ni][nj] != 1: continue\\n                    stack.append((ni, nj))\\n        \\n        ans = 0\\n        while 1:\\n            regions = process()\\n            worst_region = walls = -1\\n            infected = None\\n            affected = dict()\\n            for r, (i, j) in regions.items():\\n                infect_sources, infected_cells = infects(i, j)\\n                affected[r] = infected_cells\\n                if infected is None or len(infected_cells) > len(infected):\\n                    infected = infected_cells\\n                    worst_region = r\\n                    walls = infect_sources\\n            if infected is None: return ans\\n            ans += walls\\n            i, j = regions[worst_region]\\n            cure(i, j)\\n            affected.pop(worst_region)\\n            for r in affected.values():\\n                for i, j in r:\\n                    grid[i][j] = 1\\n            \\n                    \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 292572,
                "title": "python-try-to-be-clear-solution",
                "content": "```\\nclass Solution(object):\\n    \\n    def bfs(self,i,j,cnt):\\n        if (i,j) in self.visit:\\n            return\\n        self.grid[i][j] = cnt\\n        self.visit[(i,j)] = True\\n        \\n        for d0,d1 in self.dirx:\\n            x = i+d0\\n            y = j+d1\\n            if 0<=x<self.m and 0<=y<self.n:\\n                if self.grid[x][y] == 1:\\n                    self.bfs(x,y,cnt)\\n                elif  self.grid[x][y] > 1 and self.grid[x][y] !=self.grid[i][j] and self.grid[x][y] not in self.blacklist:\\n                    if self.grid[x][y] in self.path:\\n                        del self.path[self.grid[x][y]]\\n                        del self.wall[self.grid[x][y]]\\n                    self.bfs(x,y,cnt)\\n                elif self.grid[x][y] == 0:\\n                    if cnt not in self.wall:\\n                        self.wall[cnt] = 0\\n                    self.wall[cnt] +=1\\n                    if cnt not in self.path:\\n                        self.path[cnt] = set()\\n                    self.path[cnt].add((x,y))\\n                    \\n    def spread(self):\\n        Spreadflag = False\\n        for cnt,pathset in self.path.items():\\n            if len(pathset)!=0:\\n                Spreadflag = True\\n            for x,y in pathset:\\n                self.grid[x][y] = cnt\\n        self.oldpath = self.path\\n        self.wall,self.path,self.visit= {},{},{}\\n        for cnt,pathset in self.oldpath.items():\\n            for x,y in pathset:\\n                self.bfs(x,y,cnt)\\n        return Spreadflag\\n    \\n        \\n                        \\n        \\n    def containVirus(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        self.m,self.n,self.grid = len(grid),len(grid[0]),grid\\n        self.dirx = [(1,0),(0,1),(0,-1),(-1,0)]\\n        self.wall,self.path,self.visit,self.blacklist = {},{},{},[]\\n        \\n        # initialize, set every continent to be a number bigger than 1\\n        cnt = 1\\n        for i in range(self.m):\\n            for j in range(self.n):\\n                if self.grid[i][j] == 1:\\n                    cnt+=1\\n                    self.bfs(i,j,cnt)\\n        \\n        # if no 1 in grid, then return 0\\n        if cnt == 1:\\n            return 0\\n        \\n        # every loop:\\n        #    1. add the most infected continent number into blacklist\\n        #    2. res add this continent\\'s wall count\\n        #    3. remove this wall\\'s next-to-be infected cells set\\n        # if all continent is walled, then the next-to-be infected cells set is empty, return res\\n        # if no space cell to spread, return res\\n        res = 0\\n        while True:\\n            maxm = -1\\n            if len(self.path.keys()) == 0:\\n                return res\\n            for k,v in self.path.items():\\n                if len(v)>maxm:\\n                    maxm = len(v)\\n                    curcnt = k\\n            res += self.wall[curcnt]\\n            self.blacklist.append(curcnt)\\n            del  self.path[curcnt]\\n            if len(self.path.keys()) == 0:\\n                return res\\n            if not self.spread():\\n                return res\\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    \\n    def bfs(self,i,j,cnt):\\n        if (i,j) in self.visit:\\n            return\\n        self.grid[i][j] = cnt\\n        self.visit[(i,j)] = True\\n        \\n        for d0,d1 in self.dirx:\\n            x = i+d0\\n            y = j+d1\\n            if 0<=x<self.m and 0<=y<self.n:\\n                if self.grid[x][y] == 1:\\n                    self.bfs(x,y,cnt)\\n                elif  self.grid[x][y] > 1 and self.grid[x][y] !=self.grid[i][j] and self.grid[x][y] not in self.blacklist:\\n                    if self.grid[x][y] in self.path:\\n                        del self.path[self.grid[x][y]]\\n                        del self.wall[self.grid[x][y]]\\n                    self.bfs(x,y,cnt)\\n                elif self.grid[x][y] == 0:\\n                    if cnt not in self.wall:\\n                        self.wall[cnt] = 0\\n                    self.wall[cnt] +=1\\n                    if cnt not in self.path:\\n                        self.path[cnt] = set()\\n                    self.path[cnt].add((x,y))\\n                    \\n    def spread(self):\\n        Spreadflag = False\\n        for cnt,pathset in self.path.items():\\n            if len(pathset)!=0:\\n                Spreadflag = True\\n            for x,y in pathset:\\n                self.grid[x][y] = cnt\\n        self.oldpath = self.path\\n        self.wall,self.path,self.visit= {},{},{}\\n        for cnt,pathset in self.oldpath.items():\\n            for x,y in pathset:\\n                self.bfs(x,y,cnt)\\n        return Spreadflag\\n    \\n        \\n                        \\n        \\n    def containVirus(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        self.m,self.n,self.grid = len(grid),len(grid[0]),grid\\n        self.dirx = [(1,0),(0,1),(0,-1),(-1,0)]\\n        self.wall,self.path,self.visit,self.blacklist = {},{},{},[]\\n        \\n        # initialize, set every continent to be a number bigger than 1\\n        cnt = 1\\n        for i in range(self.m):\\n            for j in range(self.n):\\n                if self.grid[i][j] == 1:\\n                    cnt+=1\\n                    self.bfs(i,j,cnt)\\n        \\n        # if no 1 in grid, then return 0\\n        if cnt == 1:\\n            return 0\\n        \\n        # every loop:\\n        #    1. add the most infected continent number into blacklist\\n        #    2. res add this continent\\'s wall count\\n        #    3. remove this wall\\'s next-to-be infected cells set\\n        # if all continent is walled, then the next-to-be infected cells set is empty, return res\\n        # if no space cell to spread, return res\\n        res = 0\\n        while True:\\n            maxm = -1\\n            if len(self.path.keys()) == 0:\\n                return res\\n            for k,v in self.path.items():\\n                if len(v)>maxm:\\n                    maxm = len(v)\\n                    curcnt = k\\n            res += self.wall[curcnt]\\n            self.blacklist.append(curcnt)\\n            del  self.path[curcnt]\\n            if len(self.path.keys()) == 0:\\n                return res\\n            if not self.spread():\\n                return res\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 278631,
                "title": "python-bfs-with-return-value-as-dead-cells-walls-virus",
                "content": "```\\nclass Solution(object):\\n    def containVirus(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        row, col = len(grid), len(grid[0])\\n        \\n        def bfs(node):\\n            q = collections.deque()\\n            xcells = set()\\n            walls = []\\n            virus = set()  #seen\\n            virus.add(node)\\n            q.append(node)\\n            while q:\\n                x, y = q.popleft()\\n                for nx, ny in ((x,y+1), (x,y-1), (x+1,y), (x-1,y)):\\n                    if 0<=nx<row and 0<=ny<col:\\n                        if grid[nx][ny]==0:\\n                            walls.append((nx,ny))\\n                            xcells.add((nx,ny))\\n                        elif grid[nx][ny]==1 and (nx,ny) not in virus:\\n                            virus.add((nx,ny))\\n                            q.append((nx,ny))\\n            return [xcells, walls, virus]\\n        \\n        res = 0\\n        while True:\\n            total = []\\n            seen = set()\\n            for i in xrange(row):\\n                for j in xrange(col):\\n                    if (i,j) not in seen and grid[i][j]==1:\\n                        tmp = bfs((i,j))\\n                        total.append(tmp)\\n                        seen |= tmp[2]\\n            if not total or not any([n[1] for n in total]):\\n                break\\n            total.sort(key=lambda x:-len(x[0]))\\n            for x,y in total[0][2]:\\n                grid[x][y] = -1\\n            for dead in total[1:]:\\n                for x,y in dead[0]:\\n                    grid[x][y] = 1     \\n            res += len(total[0][1])\\n        return res\\n                            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def containVirus(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        row, col = len(grid), len(grid[0])\\n        \\n        def bfs(node):\\n            q = collections.deque()\\n            xcells = set()\\n            walls = []\\n            virus = set()  #seen\\n            virus.add(node)\\n            q.append(node)\\n            while q:\\n                x, y = q.popleft()\\n                for nx, ny in ((x,y+1), (x,y-1), (x+1,y), (x-1,y)):\\n                    if 0<=nx<row and 0<=ny<col:\\n                        if grid[nx][ny]==0:\\n                            walls.append((nx,ny))\\n                            xcells.add((nx,ny))\\n                        elif grid[nx][ny]==1 and (nx,ny) not in virus:\\n                            virus.add((nx,ny))\\n                            q.append((nx,ny))\\n            return [xcells, walls, virus]\\n        \\n        res = 0\\n        while True:\\n            total = []\\n            seen = set()\\n            for i in xrange(row):\\n                for j in xrange(col):\\n                    if (i,j) not in seen and grid[i][j]==1:\\n                        tmp = bfs((i,j))\\n                        total.append(tmp)\\n                        seen |= tmp[2]\\n            if not total or not any([n[1] for n in total]):\\n                break\\n            total.sort(key=lambda x:-len(x[0]))\\n            for x,y in total[0][2]:\\n                grid[x][y] = -1\\n            for dead in total[1:]:\\n                for x,y in dead[0]:\\n                    grid[x][y] = 1     \\n            res += len(total[0][1])\\n        return res\\n                            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 212789,
                "title": "java-dfs-24-ms",
                "content": "\\n Key observations\\n 1.Use key = y * row + col, the advantage is that we can use the key to put location of cell (x, y) into list and set.\\n  2.For each day check calls, from DFS, get the set of cells that will be infected and number walls should be built, maintain the max number of walls and the list of virus cells\\u3002\\n  3.Update grid :\\n       set the virus area that has the most infected cells to 2\\n       set the cells that will be infected by other areas to 1\\n\\t   \\n     Example:\\n              [\\n               [0,1,0,0,0,0,0,1],\\n               [0,1,0,0,0,0,0,1],\\n               [0,0,0,0,0,0,0,1],\\n               [0,0,0,0,0,0,0,0]\\n              ]\\n    \\n     \\n      After 1st day update\\n              [\\n               [0,2,0,0,0,0,1,1],\\n               [0,2,0,0,0,0,1,1],\\n               [0,0,0,0,0,0,1,1],\\n               [0,0,0,0,0,0,0,1]\\n              ]\\n     \\n      After 2nd day update\\n              [\\n               [0,2,0,0,0,0,2,2],\\n               [0,2,0,0,0,0,2,2],\\n               [0,0,0,0,0,0,2,2],\\n               [0,0,0,0,0,0,0,2]\\n              ]\\n\\t\\t\\t  \\n\\t\\t\\t  \\n\\tclass Solution {\\n        int walls = 0;\\n        List<Integer> curr;\\n\\n        public int containVirus(int[][] grid) {\\n            if (null == grid || grid.length == 0) return 0;\\n\\n            int m = grid.length;\\n            int n = grid[0].length;\\n\\n            int total_walls = 0;\\n            curr = new ArrayList<>();\\n\\n            while (true) {\\n                int[] visited = new int[m * n];\\n                List<Integer> virus_area = new ArrayList<>();\\n\\n                /**\\n                 * list of sets that contains keys for cells that WILL be infected for each area\\n                 */\\n                List<Set<Integer>> nexts = new ArrayList<>();\\n\\n                int block_index = -1;\\n                int block_walls = -1;\\n\\n                for (int i = 0; i < m; i++) {\\n                    for (int j = 0; j < n; j++) {\\n                        int key = i * n + j;\\n                        if (grid[i][j] != 1 || visited[key] == 1) {\\n                            continue;\\n                        }\\n\\n                        Set<Integer> next = new HashSet<>();//set that contains the cells that will be infected around the current area\\n\\n                        curr.clear();\\n                        walls = 0;\\n\\n                        helper(j, i, m, n, grid, visited, next);\\n\\n                        if (next.isEmpty()) {\\n                            continue;\\n                        }\\n\\n                        if (nexts.isEmpty() || next.size() > nexts.get(block_index).size()) {\\n                            virus_area.clear();\\n                            virus_area.addAll(curr);\\n\\n                            block_index = nexts.size();\\n                            block_walls = walls;\\n                        }\\n\\n                        nexts.add(next);\\n                    }\\n                }\\n\\n                if (nexts.isEmpty()) {\\n                    break;\\n                }\\n\\n                total_walls += block_walls;\\n\\n                //update\\n                for (int i = 0; i < nexts.size(); i++) {\\n                    if (i == block_index) {\\n                        for (int key : virus_area) {\\n                            int y = key / n;\\n                            int x = key % n;\\n                            grid[y][x] = 2; \\n                        }\\n                    } else {\\n                        for (int key : nexts.get(i)) {\\n                            int y = key / n;\\n                            int x = key % n;\\n                            grid[y][x] = 1; \\n                        }\\n                    }\\n                }\\n            }\\n\\n            return total_walls;\\n        }\\n\\n        private void helper(int x, int y, int m, int n,\\n                            int[][] grid,\\n                            int[] visited,\\n                            Set<Integer> next) {\\n            int dirs[][] = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n\\n            if (x < 0 || x >= n || y < 0 || y >= m || grid[y][x] == 2) {\\n                return;\\n            }\\n\\n            int key = y * n + x;\\n\\n            // need one wall\\n            if (grid[y][x] == 0) {\\n                walls++;\\n                next.add(key);\\n                return;\\n            }\\n\\n            if (visited[key] == 1) {\\n                return;\\n            }\\n\\n            visited[key] = 1;\\n            curr.add(key);\\n\\t\\t\\t\\n            for (int i = 0; i < 4; ++i) {\\n                helper(x + dirs[i][0], y + dirs[i][1], m, n, grid, visited, next);\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        int walls = 0;\\n        List<Integer> curr;\\n\\n        public int containVirus(int[][] grid) {\\n            if (null == grid || grid.length == 0) return 0;\\n\\n            int m = grid.length;\\n            int n = grid[0].length;\\n\\n            int total_walls = 0;\\n            curr = new ArrayList<>();\\n\\n            while (true) {\\n                int[] visited = new int[m * n];\\n                List<Integer> virus_area = new ArrayList<>();\\n\\n                /**\\n                 * list of sets that contains keys for cells that WILL be infected for each area\\n                 */\\n                List<Set<Integer>> nexts = new ArrayList<>();\\n\\n                int block_index = -1;\\n                int block_walls = -1;\\n\\n                for (int i = 0; i < m; i++) {\\n                    for (int j = 0; j < n; j++) {\\n                        int key = i * n + j;\\n                        if (grid[i][j] != 1 || visited[key] == 1) {\\n                            continue;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 197813,
                "title": "python-108ms-simulation-solution",
                "content": "```\\nclass Solution(object):\\n    def containVirus(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        idxg=[2]\\n        def grow(): # return NnewWall and modify grid inplace\\n            groups=collections.defaultdict(set)\\n            def dfs(pos,idx):\\n                grid[pos[0]][pos[1]]=idx\\n                for i,j in [[0,1],[0,-1],[1,0],[-1,0]]:\\n                    if 0<=pos[0]+i<len(grid) and 0<=pos[1]+j<len(grid[0]):\\n                        if grid[pos[0]+i][pos[1]+j]==0:\\n                            groups[idx].add((pos[0]+i,pos[1]+j))\\n                        elif grid[pos[0]+i][pos[1]+j]==1:\\n                            dfs((pos[0]+i,pos[1]+j),idx)\\n            for i in xrange(len(grid)):\\n                for j in xrange(len(grid[0])):\\n                    if grid[i][j]==1:\\n                        dfs((i,j),idxg[0])\\n                        idxg[0]+=1\\n            wall=0\\n            if groups:\\n                blockId=max(groups,key=lambda x: len(groups[x]))\\n                for idx in groups:\\n                    if idx==blockId:\\n                        for x,y in groups[idx]:\\n                            for i,j in [[0,1],[0,-1],[1,0],[-1,0]]:\\n                                if 0<=x+i<len(grid) and 0<=y+j<len(grid[0]) and grid[x+i][y+j]==idx:\\n                                    wall+=1\\n                    else:\\n                        for x,y in groups[idx]:\\n                            grid[x][y]=1\\n                for i in xrange(len(grid)):\\n                    for j in xrange(len(grid[0])):\\n                        if grid[i][j] in groups and grid[i][j]!=blockId:\\n                            grid[i][j]=1\\n            return wall\\n        ret=0\\n        while True:\\n            tmp=grow()\\n            if tmp>0:\\n                ret+=tmp\\n            else:\\n                return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def containVirus(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        idxg=[2]\\n        def grow(): # return NnewWall and modify grid inplace\\n            groups=collections.defaultdict(set)\\n            def dfs(pos,idx):\\n                grid[pos[0]][pos[1]]=idx\\n                for i,j in [[0,1],[0,-1],[1,0],[-1,0]]:\\n                    if 0<=pos[0]+i<len(grid) and 0<=pos[1]+j<len(grid[0]):\\n                        if grid[pos[0]+i][pos[1]+j]==0:\\n                            groups[idx].add((pos[0]+i,pos[1]+j))\\n                        elif grid[pos[0]+i][pos[1]+j]==1:\\n                            dfs((pos[0]+i,pos[1]+j),idx)\\n            for i in xrange(len(grid)):\\n                for j in xrange(len(grid[0])):\\n                    if grid[i][j]==1:\\n                        dfs((i,j),idxg[0])\\n                        idxg[0]+=1\\n            wall=0\\n            if groups:\\n                blockId=max(groups,key=lambda x: len(groups[x]))\\n                for idx in groups:\\n                    if idx==blockId:\\n                        for x,y in groups[idx]:\\n                            for i,j in [[0,1],[0,-1],[1,0],[-1,0]]:\\n                                if 0<=x+i<len(grid) and 0<=y+j<len(grid[0]) and grid[x+i][y+j]==idx:\\n                                    wall+=1\\n                    else:\\n                        for x,y in groups[idx]:\\n                            grid[x][y]=1\\n                for i in xrange(len(grid)):\\n                    for j in xrange(len(grid[0])):\\n                        if grid[i][j] in groups and grid[i][j]!=blockId:\\n                            grid[i][j]=1\\n            return wall\\n        ret=0\\n        while True:\\n            tmp=grow()\\n            if tmp>0:\\n                ret+=tmp\\n            else:\\n                return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 170012,
                "title": "java-bfs",
                "content": "Java\\uFF0C\\u4E3B\\u8981\\u5206\\u4E3A4\\u6B65\\uFF0C\\n1. BFS\\uFF0C\\u627E\\u5230\\u6240\\u6709\\u75C5\\u533A\\u53CA\\u5176\\u53EF\\u611F\\u67D3\\u7684\\u5065\\u5EB7\\u533A\\u57DF\\u6570\\uFF0C\\u5B58\\u50A8\\u5728virusInfo[][]\\u4E2D\\uFF1B\\n2. \\u9009\\u62E9\\u53EF\\u611F\\u67D3\\u533A\\u57DF\\u6570\\u6700\\u5927\\u7684\\u75C5\\u533A\\uFF0CBFS\\u5EFA\\u5899\\uFF0C\\u5C06\\u5BF9\\u5E94\\u201C1\\u201D\\u7F6E\\u4E3A\\u201C2\\u201D\\uFF1B\\n3. \\u5BF9\\u5269\\u4F59\\u75C5\\u533A\\u8FDB\\u884C\\u611F\\u67D3\\u64CD\\u4F5C\\uFF0C\\u6B64\\u5904\\u6CE8\\u610F\\u8981\\u5BF9\\u65B0\\u611F\\u67D3\\u533A\\u57DF\\u8FDB\\u884C\\u8BB0\\u5F55\\uFF08newInfected[][]\\uFF09\\uFF0C\\u9632\\u6B62\\u540E\\u9762\\u7684\\u75C5\\u533A\\u4E0E\\u524D\\u9762\\u7684\\u75C5\\u533A\\u8FDE\\u63A5\\uFF0C\\u5BFC\\u81F4\\u540E\\u9762\\u7684\\u75C5\\u533A\\u591A\\u611F\\u67D3\\uFF1B\\n4. \\u7ED3\\u675F\\u6761\\u4EF6\\uFF0C\\u65E0\\u201C1\\u201D\\u6216\\u65E0\\u201C0\\u201D\\n```\\nclass Solution {\\n    private static int[][] DIR = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};\\n\\t\\n    public int containVirus(int[][] grid) {\\n        int height = grid.length;\\n        int width = grid[0].length;\\n        \\n        int sumVirus = 0;\\n        for (int i = 0; i < height; i++) {\\n            for (int j= 0; j < width; j++) {\\n                if (grid[i][j] == 1) {\\n                    sumVirus += 1;\\n                }\\n            }\\n        }\\n        \\n        if (sumVirus == 0 || sumVirus == height * width) {\\n            return 0;\\n        } else {\\n            int result = Solution.bfs(grid, sumVirus);\\n\\n            return result;\\n        }\\n    }\\n    \\n    private static int bfs(int[][] map, int sumVirus) {\\n\\t\\tint wallsNum = 0;\\n\\t\\t\\n\\t\\tboolean falgOne = true;\\n\\t\\twhile (falgOne) {\\n\\t\\t\\tint[][] newInfected = new int[map.length][map[0].length]; // !!!\\n            \\n\\t\\t\\t// \\u7B2C\\u4E00\\u6B65\\uFF0C\\u627E\\u5404\\u75C5\\u6BD2\\u533A\\u57DF\\u53CA\\u5176\\u53EF\\u611F\\u67D3\\u7684\\u5065\\u5EB7\\u533A\\u57DF\\u6570\\n\\t\\t\\tint[][] visitedVirus = new int[map.length][map[0].length];\\n\\t\\t\\tint[][] visitedHealth = new int[map.length][map[0].length];\\n\\t\\t\\t\\n\\t\\t\\tint[][] virusInfo = new int[map.length * map[0].length][3];\\n\\t\\t\\tint count = 0;\\n\\t\\t\\t\\n\\t\\t\\tint[] queueYVirus = new int[map.length * map[0].length];\\n\\t\\t\\tint[] queueXVirus = new int[map.length * map[0].length];\\n\\t\\t\\tint front = 0;\\n\\t\\t\\tint tail = 0;\\n\\t\\t\\t\\n\\t\\t\\tboolean falgTwo = true;\\n\\t\\t\\twhile (falgTwo) {\\n\\t\\t\\t\\tvisitedHealth = new int[map.length][map[0].length]; // reset\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tint startY = 0;\\n\\t\\t\\t\\tint startX = 0;\\n\\t\\t\\t\\tint temFlag = 0;\\n\\t\\t\\t\\tfor (int i = 0; i < map.length; i++) {\\n\\t\\t\\t\\t\\tif (temFlag == 1) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tfor (int j = 0; j < map[0].length; j++) {\\n\\t\\t\\t\\t\\t\\tif (map[i][j] == 1 && visitedVirus[i][j] == 0) {\\n\\t\\t\\t\\t\\t\\t\\tstartY = i;\\n\\t\\t\\t\\t\\t\\t\\tstartX = j;\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\ttemFlag = 1;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif (temFlag == 1) {\\n\\t\\t\\t\\t\\tvirusInfo[count][0] = startY;\\n\\t\\t\\t\\t\\tvirusInfo[count][1] = startX;\\n\\t\\t\\t\\t\\tvirusInfo[count][2] = 0;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tqueueYVirus[tail] = startY;\\n\\t\\t\\t\\t\\tqueueXVirus[tail] = startX;\\n\\t\\t\\t\\t\\ttail++;\\n\\t\\t\\t\\t\\tvisitedVirus[startY][startX] = 1;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// System.out.println(startY + \" \" + startX);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\twhile (front != tail) {\\n\\t\\t\\t\\t\\t\\tint temY = queueYVirus[front];\\n\\t\\t\\t\\t\\t\\tint temX = queueXVirus[front];\\n\\t\\t\\t\\t\\t\\tfront++;\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tfor (int dir = 0; dir < Solution.DIR.length; dir++) {\\n\\t\\t\\t\\t\\t\\t\\tint nextY = temY + Solution.DIR[dir][0];\\n\\t\\t\\t\\t\\t\\t\\tint nextX = temX + Solution.DIR[dir][1];\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tif (Solution.isValid(map, visitedVirus, nextY, nextX)) {\\n\\t\\t\\t\\t\\t\\t\\t\\tif (map[nextY][nextX] == 1) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tqueueYVirus[tail] = nextY;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tqueueXVirus[tail] = nextX;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\ttail++;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tvisitedVirus[nextY][nextX] = 1;\\n\\t\\t\\t\\t\\t\\t\\t\\t} else if (map[nextY][nextX] == 0 && visitedHealth[nextY][nextX] == 0) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tvirusInfo[count][2] += 1; // \\u53EF\\u611F\\u67D3\\u533A\\u57DF\\u52A01\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tvisitedHealth[nextY][nextX] = 1;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif (tail == sumVirus) { // sumVirus\\u540E\\u9762\\u4F1A\\u53D8\\u66F4\\uFF01\\uFF01\\uFF01\\n\\t\\t\\t\\t\\t\\tfalgTwo = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tcount += 1;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tfalgTwo = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif (count == 0) {\\n\\t\\t\\t\\treturn wallsNum;\\n\\t\\t\\t}\\n\\t\\t\\t// System.out.println(\"\\u627E\\u5230\\u4E86\" + count + \"\\u4E2A\\u75C5\\u533A\");\\n\\t\\t\\t\\n\\t\\t\\t// \\u7B2C\\u4E8C\\u6B65\\uFF0C\\u5EFA\\u5899\\n\\t\\t\\tint index = Solution.findMax(virusInfo, count);\\n\\t\\t\\tint toBuildY = virusInfo[index][0];\\n\\t\\t\\tint toBuildX = virusInfo[index][1];\\n\\t\\t\\t\\n\\t\\t\\tint[] buildWallResult = Solution.countWallsNum(map, toBuildY, toBuildX);\\n\\t\\t\\twallsNum += buildWallResult[0];\\n\\t\\t\\tsumVirus -= buildWallResult[1]; // sumVirus \\u53D8\\u66F4\\n\\t\\t\\t\\n\\t\\t\\t/*System.out.println(\"\\u5EFA\\u4E86\" + buildWallResult[0] + \"\\u5835\\u5899\\uFF0C\\u6D88\\u706D\\u4E86\" + buildWallResult[1] + \"\\u4E2A\\u75C5\\u6BD2\");\\n\\t\\t\\tfor (int i = 0; i < map.length; i++) {\\n\\t\\t\\t\\tfor (int j = 0; j < map[0].length; j++) {\\n\\t\\t\\t\\t\\tSystem.out.print(map[i][j] + \" \");\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tSystem.out.println();\\n\\t\\t\\t}*/\\n\\t\\t\\t\\n\\t\\t\\t// \\u7B2C\\u4E09\\u6B65\\uFF0C\\u611F\\u67D3\\n\\t\\t\\tfor (int i = 0; i < count; i++) {\\n\\t\\t\\t\\tint infectY = virusInfo[i][0];\\n\\t\\t\\t\\tint infectX = virusInfo[i][1];\\n\\t\\t\\t\\tif (!(infectY == toBuildY && infectX == toBuildX)) {\\n\\t\\t\\t\\t\\tint infectedNum = Solution.infect(map, newInfected, infectY, infectX);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tsumVirus += infectedNum; // sumVirus \\u53D8\\u66F4\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// System.out.println(\"\\u611F\\u67D3\\u4E86\" + infectedNum + \"\\u4E2A\\u533A\\u57DF\");\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// \\u7B2C\\u56DB\\u6B65\\uFF0C\\u662F\\u5426\\u7ED3\\u675F\\uFF1A\\u65E0\\u201C1\\u201D \\u6216\\u8005 \\u65E0\\u201C0\\u201D\\n\\t\\t\\tif (Solution.isFinish(map)) {\\n\\t\\t\\t\\tfalgOne = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\t/*System.out.println(\"\\u6700\\u7EC8\\u7ED3\\u679C\");\\n\\t\\tfor (int i = 0; i < map.length; i++) {\\n\\t\\t\\tfor (int j = 0; j < map[0].length; j++) {\\n\\t\\t\\t\\tSystem.out.print(map[i][j] + \" \");\\n\\t\\t\\t}\\n\\t\\t\\tSystem.out.println();\\n\\t\\t}*/\\n\\t\\t\\n\\t\\treturn wallsNum;\\n\\t}\\n    \\n    private static int infect(int[][] map, int[][] newInfected, int startY, int startX) {\\n\\t\\tint infectedNum = 0; // \\u611F\\u67D3\\u7684\\u533A\\u57DF\\u6570\\n\\t\\t\\n\\t\\tint[][] visitedVirus = new int[map.length][map[0].length];\\n\\t\\tint[] queueYVirus = new int[map.length * map[0].length];\\n\\t\\tint[] queueXVirus = new int[map.length * map[0].length];\\n\\t\\tint front = 0;\\n\\t\\tint tail = 0;\\n\\t\\t\\n\\t\\tqueueYVirus[tail] = startY;\\n\\t\\tqueueXVirus[tail] = startX;\\n\\t\\ttail++;\\n\\t\\tvisitedVirus[startY][startX] = 1;\\n\\t\\t\\n\\t\\twhile (front != tail) {\\n\\t\\t\\tint temY = queueYVirus[front];\\n\\t\\t\\tint temX = queueXVirus[front];\\n\\t\\t\\tfront++;\\n\\t\\t\\t\\n\\t\\t\\tfor (int dir = 0; dir < Solution.DIR.length; dir++) {\\n\\t\\t\\t\\tint nextY = temY + Solution.DIR[dir][0];\\n\\t\\t\\t\\tint nextX = temX + Solution.DIR[dir][1];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif (Solution.isValid(map, visitedVirus, nextY, nextX)) {\\n\\t\\t\\t\\t\\tif (map[nextY][nextX] == 1 && newInfected[nextY][nextX] == 0) {\\n\\t\\t\\t\\t\\t\\tqueueYVirus[tail] = nextY;\\n\\t\\t\\t\\t\\t\\tqueueXVirus[tail] = nextX;\\n\\t\\t\\t\\t\\t\\ttail++;\\n\\t\\t\\t\\t\\t} else if (map[nextY][nextX] == 0) {\\n                        newInfected[nextY][nextX] = 1;\\n                        \\n\\t\\t\\t\\t\\t\\tmap[nextY][nextX] = 1;\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tinfectedNum += 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tvisitedVirus[nextY][nextX] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn infectedNum;\\n\\t}\\n    \\n    private static int[] countWallsNum(int[][] map, int startY, int startX) {\\n\\t\\tint[] result = new int[2];\\n\\t\\t\\n\\t\\tint wall = 0;\\n\\t\\t\\n\\t\\tint[][] visitedVirus = new int[map.length][map[0].length];\\n\\t\\tint[] queueYVirus = new int[map.length * map[0].length];\\n\\t\\tint[] queueXVirus = new int[map.length * map[0].length];\\n\\t\\tint front = 0;\\n\\t\\tint tail = 0;\\n\\t\\t\\n\\t\\tqueueYVirus[tail] = startY;\\n\\t\\tqueueXVirus[tail] = startX;\\n\\t\\ttail++;\\n\\t\\tvisitedVirus[startY][startX] = 1;\\n\\t\\tmap[startY][startX] = 2;\\n\\t\\t\\n\\t\\twhile (front != tail) {\\n\\t\\t\\tint temY = queueYVirus[front];\\n\\t\\t\\tint temX = queueXVirus[front];\\n\\t\\t\\tfront++;\\n\\t\\t\\t\\n\\t\\t\\tfor (int dir = 0; dir < Solution.DIR.length; dir++) {\\n\\t\\t\\t\\tint nextY = temY + Solution.DIR[dir][0];\\n\\t\\t\\t\\tint nextX = temX + Solution.DIR[dir][1];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif (Solution.isValid(map, visitedVirus, nextY, nextX)) {\\n\\t\\t\\t\\t\\tif (map[nextY][nextX] == 1) {\\n\\t\\t\\t\\t\\t\\tmap[nextY][nextX] = 2;\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tqueueYVirus[tail] = nextY;\\n\\t\\t\\t\\t\\t\\tqueueXVirus[tail] = nextX;\\n\\t\\t\\t\\t\\t\\ttail++;\\n\\t\\t\\t\\t\\t\\tvisitedVirus[nextY][nextX] = 1; // \\u6CA1\\u7528\\n\\t\\t\\t\\t\\t} else if (map[nextY][nextX] == 0) {\\n\\t\\t\\t\\t\\t\\twall += 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tresult[0] = wall;\\n\\t\\tresult[1] = tail; // \\u88AB\\u6D88\\u9664\\u7684 virus \\u6570\\u91CF\\n\\t\\t\\n\\t\\treturn result;\\n\\t}\\n\\t\\n\\tprivate static int findMax(int[][] virusInfo, int count) {\\n\\t\\tint index = 0;\\n\\t\\tint max = 0;\\n\\t\\tfor (int i = 0; i < count; i++) {\\n\\t\\t\\tif (virusInfo[i][2] > max) {\\n\\t\\t\\t\\tindex = i;\\n\\t\\t\\t\\tmax = virusInfo[i][2];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn index;\\n\\t}\\n\\t\\n\\tprivate static boolean isFinish(int[][] map) {\\n\\t\\tboolean resultOne = true;\\n\\t\\tboolean resultTwo = true;\\n\\t\\tfor (int i = 0; i < map.length; i++) {\\n\\t\\t\\tfor (int j = 0; j < map[0].length; j++) {\\n\\t\\t\\t\\tif (map[i][j] == 1) {\\n\\t\\t\\t\\t\\tresultOne = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (map[i][j] == 0) {\\n\\t\\t\\t\\t\\tresultTwo = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn (resultOne || resultTwo);\\n\\t}\\n\\t\\n\\tprivate static boolean isValid(int[][] map, int[][] visitedVirus, int y, int x) {\\n\\t\\tif (y < 0 || y >= map.length || x < 0 || x >= map[0].length) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t\\n\\t\\tif (map[y][x] == 1 && visitedVirus[y][x] == 1) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn true;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static int[][] DIR = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};\\n\\t\\n    public int containVirus(int[][] grid) {\\n        int height = grid.length;\\n        int width = grid[0].length;\\n        \\n        int sumVirus = 0;\\n        for (int i = 0; i < height; i++) {\\n            for (int j= 0; j < width; j++) {\\n                if (grid[i][j] == 1) {\\n                    sumVirus += 1;\\n                }\\n            }\\n        }\\n        \\n        if (sumVirus == 0 || sumVirus == height * width) {\\n            return 0;\\n        } else {\\n            int result = Solution.bfs(grid, sumVirus);\\n\\n            return result;\\n        }\\n    }\\n    \\n    private static int bfs(int[][] map, int sumVirus) {\\n\\t\\tint wallsNum = 0;\\n\\t\\t\\n\\t\\tboolean falgOne = true;\\n\\t\\twhile (falgOne) {\\n\\t\\t\\tint[][] newInfected = new int[map.length][map[0].length]; // !!!\\n            \\n\\t\\t\\t// \\u7B2C\\u4E00\\u6B65\\uFF0C\\u627E\\u5404\\u75C5\\u6BD2\\u533A\\u57DF\\u53CA\\u5176\\u53EF\\u611F\\u67D3\\u7684\\u5065\\u5EB7\\u533A\\u57DF\\u6570\\n\\t\\t\\tint[][] visitedVirus = new int[map.length][map[0].length];\\n\\t\\t\\tint[][] visitedHealth = new int[map.length][map[0].length];\\n\\t\\t\\t\\n\\t\\t\\tint[][] virusInfo = new int[map.length * map[0].length][3];\\n\\t\\t\\tint count = 0;\\n\\t\\t\\t\\n\\t\\t\\tint[] queueYVirus = new int[map.length * map[0].length];\\n\\t\\t\\tint[] queueXVirus = new int[map.length * map[0].length];\\n\\t\\t\\tint front = 0;\\n\\t\\t\\tint tail = 0;\\n\\t\\t\\t\\n\\t\\t\\tboolean falgTwo = true;\\n\\t\\t\\twhile (falgTwo) {\\n\\t\\t\\t\\tvisitedHealth = new int[map.length][map[0].length]; // reset\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tint startY = 0;\\n\\t\\t\\t\\tint startX = 0;\\n\\t\\t\\t\\tint temFlag = 0;\\n\\t\\t\\t\\tfor (int i = 0; i < map.length; i++) {\\n\\t\\t\\t\\t\\tif (temFlag == 1) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tfor (int j = 0; j < map[0].length; j++) {\\n\\t\\t\\t\\t\\t\\tif (map[i][j] == 1 && visitedVirus[i][j] == 0) {\\n\\t\\t\\t\\t\\t\\t\\tstartY = i;\\n\\t\\t\\t\\t\\t\\t\\tstartX = j;\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\ttemFlag = 1;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif (temFlag == 1) {\\n\\t\\t\\t\\t\\tvirusInfo[count][0] = startY;\\n\\t\\t\\t\\t\\tvirusInfo[count][1] = startX;\\n\\t\\t\\t\\t\\tvirusInfo[count][2] = 0;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tqueueYVirus[tail] = startY;\\n\\t\\t\\t\\t\\tqueueXVirus[tail] = startX;\\n\\t\\t\\t\\t\\ttail++;\\n\\t\\t\\t\\t\\tvisitedVirus[startY][startX] = 1;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// System.out.println(startY + \" \" + startX);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\twhile (front != tail) {\\n\\t\\t\\t\\t\\t\\tint temY = queueYVirus[front];\\n\\t\\t\\t\\t\\t\\tint temX = queueXVirus[front];\\n\\t\\t\\t\\t\\t\\tfront++;\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tfor (int dir = 0; dir < Solution.DIR.length; dir++) {\\n\\t\\t\\t\\t\\t\\t\\tint nextY = temY + Solution.DIR[dir][0];\\n\\t\\t\\t\\t\\t\\t\\tint nextX = temX + Solution.DIR[dir][1];\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tif (Solution.isValid(map, visitedVirus, nextY, nextX)) {\\n\\t\\t\\t\\t\\t\\t\\t\\tif (map[nextY][nextX] == 1) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tqueueYVirus[tail] = nextY;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tqueueXVirus[tail] = nextX;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\ttail++;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tvisitedVirus[nextY][nextX] = 1;\\n\\t\\t\\t\\t\\t\\t\\t\\t} else if (map[nextY][nextX] == 0 && visitedHealth[nextY][nextX] == 0) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tvirusInfo[count][2] += 1; // \\u53EF\\u611F\\u67D3\\u533A\\u57DF\\u52A01\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tvisitedHealth[nextY][nextX] = 1;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif (tail == sumVirus) { // sumVirus\\u540E\\u9762\\u4F1A\\u53D8\\u66F4\\uFF01\\uFF01\\uFF01\\n\\t\\t\\t\\t\\t\\tfalgTwo = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tcount += 1;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tfalgTwo = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif (count == 0) {\\n\\t\\t\\t\\treturn wallsNum;\\n\\t\\t\\t}\\n\\t\\t\\t// System.out.println(\"\\u627E\\u5230\\u4E86\" + count + \"\\u4E2A\\u75C5\\u533A\");\\n\\t\\t\\t\\n\\t\\t\\t// \\u7B2C\\u4E8C\\u6B65\\uFF0C\\u5EFA\\u5899\\n\\t\\t\\tint index = Solution.findMax(virusInfo, count);\\n\\t\\t\\tint toBuildY = virusInfo[index][0];\\n\\t\\t\\tint toBuildX = virusInfo[index][1];\\n\\t\\t\\t\\n\\t\\t\\tint[] buildWallResult = Solution.countWallsNum(map, toBuildY, toBuildX);\\n\\t\\t\\twallsNum += buildWallResult[0];\\n\\t\\t\\tsumVirus -= buildWallResult[1]; // sumVirus \\u53D8\\u66F4\\n\\t\\t\\t\\n\\t\\t\\t/*System.out.println(\"\\u5EFA\\u4E86\" + buildWallResult[0] + \"\\u5835\\u5899\\uFF0C\\u6D88\\u706D\\u4E86\" + buildWallResult[1] + \"\\u4E2A\\u75C5\\u6BD2\");\\n\\t\\t\\tfor (int i = 0; i < map.length; i++) {\\n\\t\\t\\t\\tfor (int j = 0; j < map[0].length; j++) {\\n\\t\\t\\t\\t\\tSystem.out.print(map[i][j] + \" \");\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tSystem.out.println();\\n\\t\\t\\t}*/\\n\\t\\t\\t\\n\\t\\t\\t// \\u7B2C\\u4E09\\u6B65\\uFF0C\\u611F\\u67D3\\n\\t\\t\\tfor (int i = 0; i < count; i++) {\\n\\t\\t\\t\\tint infectY = virusInfo[i][0];\\n\\t\\t\\t\\tint infectX = virusInfo[i][1];\\n\\t\\t\\t\\tif (!(infectY == toBuildY && infectX == toBuildX)) {\\n\\t\\t\\t\\t\\tint infectedNum = Solution.infect(map, newInfected, infectY, infectX);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tsumVirus += infectedNum; // sumVirus \\u53D8\\u66F4\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// System.out.println(\"\\u611F\\u67D3\\u4E86\" + infectedNum + \"\\u4E2A\\u533A\\u57DF\");\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// \\u7B2C\\u56DB\\u6B65\\uFF0C\\u662F\\u5426\\u7ED3\\u675F\\uFF1A\\u65E0\\u201C1\\u201D \\u6216\\u8005 \\u65E0\\u201C0\\u201D\\n\\t\\t\\tif (Solution.isFinish(map)) {\\n\\t\\t\\t\\tfalgOne = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\t/*System.out.println(\"\\u6700\\u7EC8\\u7ED3\\u679C\");\\n\\t\\tfor (int i = 0; i < map.length; i++) {\\n\\t\\t\\tfor (int j = 0; j < map[0].length; j++) {\\n\\t\\t\\t\\tSystem.out.print(map[i][j] + \" \");\\n\\t\\t\\t}\\n\\t\\t\\tSystem.out.println();\\n\\t\\t}*/\\n\\t\\t\\n\\t\\treturn wallsNum;\\n\\t}\\n    \\n    private static int infect(int[][] map, int[][] newInfected, int startY, int startX) {\\n\\t\\tint infectedNum = 0; // \\u611F\\u67D3\\u7684\\u533A\\u57DF\\u6570\\n\\t\\t\\n\\t\\tint[][] visitedVirus = new int[map.length][map[0].length];\\n\\t\\tint[] queueYVirus = new int[map.length * map[0].length];\\n\\t\\tint[] queueXVirus = new int[map.length * map[0].length];\\n\\t\\tint front = 0;\\n\\t\\tint tail = 0;\\n\\t\\t\\n\\t\\tqueueYVirus[tail] = startY;\\n\\t\\tqueueXVirus[tail] = startX;\\n\\t\\ttail++;\\n\\t\\tvisitedVirus[startY][startX] = 1;\\n\\t\\t\\n\\t\\twhile (front != tail) {\\n\\t\\t\\tint temY = queueYVirus[front];\\n\\t\\t\\tint temX = queueXVirus[front];\\n\\t\\t\\tfront++;\\n\\t\\t\\t\\n\\t\\t\\tfor (int dir = 0; dir < Solution.DIR.length; dir++) {\\n\\t\\t\\t\\tint nextY = temY + Solution.DIR[dir][0];\\n\\t\\t\\t\\tint nextX = temX + Solution.DIR[dir][1];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif (Solution.isValid(map, visitedVirus, nextY, nextX)) {\\n\\t\\t\\t\\t\\tif (map[nextY][nextX] == 1 && newInfected[nextY][nextX] == 0) {\\n\\t\\t\\t\\t\\t\\tqueueYVirus[tail] = nextY;\\n\\t\\t\\t\\t\\t\\tqueueXVirus[tail] = nextX;\\n\\t\\t\\t\\t\\t\\ttail++;\\n\\t\\t\\t\\t\\t} else if (map[nextY][nextX] == 0) {\\n                        newInfected[nextY][nextX] = 1;\\n                        \\n\\t\\t\\t\\t\\t\\tmap[nextY][nextX] = 1;\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tinfectedNum += 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tvisitedVirus[nextY][nextX] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn infectedNum;\\n\\t}\\n    \\n    private static int[] countWallsNum(int[][] map, int startY, int startX) {\\n\\t\\tint[] result = new int[2];\\n\\t\\t\\n\\t\\tint wall = 0;\\n\\t\\t\\n\\t\\tint[][] visitedVirus = new int[map.length][map[0].length];\\n\\t\\tint[] queueYVirus = new int[map.length * map[0].length];\\n\\t\\tint[] queueXVirus = new int[map.length * map[0].length];\\n\\t\\tint front = 0;\\n\\t\\tint tail = 0;\\n\\t\\t\\n\\t\\tqueueYVirus[tail] = startY;\\n\\t\\tqueueXVirus[tail] = startX;\\n\\t\\ttail++;\\n\\t\\tvisitedVirus[startY][startX] = 1;\\n\\t\\tmap[startY][startX] = 2;\\n\\t\\t\\n\\t\\twhile (front != tail) {\\n\\t\\t\\tint temY = queueYVirus[front];\\n\\t\\t\\tint temX = queueXVirus[front];\\n\\t\\t\\tfront++;\\n\\t\\t\\t\\n\\t\\t\\tfor (int dir = 0; dir < Solution.DIR.length; dir++) {\\n\\t\\t\\t\\tint nextY = temY + Solution.DIR[dir][0];\\n\\t\\t\\t\\tint nextX = temX + Solution.DIR[dir][1];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif (Solution.isValid(map, visitedVirus, nextY, nextX)) {\\n\\t\\t\\t\\t\\tif (map[nextY][nextX] == 1) {\\n\\t\\t\\t\\t\\t\\tmap[nextY][nextX] = 2;\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tqueueYVirus[tail] = nextY;\\n\\t\\t\\t\\t\\t\\tqueueXVirus[tail] = nextX;\\n\\t\\t\\t\\t\\t\\ttail++;\\n\\t\\t\\t\\t\\t\\tvisitedVirus[nextY][nextX] = 1; // \\u6CA1\\u7528\\n\\t\\t\\t\\t\\t} else if (map[nextY][nextX] == 0) {\\n\\t\\t\\t\\t\\t\\twall += 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tresult[0] = wall;\\n\\t\\tresult[1] = tail; // \\u88AB\\u6D88\\u9664\\u7684 virus \\u6570\\u91CF\\n\\t\\t\\n\\t\\treturn result;\\n\\t}\\n\\t\\n\\tprivate static int findMax(int[][] virusInfo, int count) {\\n\\t\\tint index = 0;\\n\\t\\tint max = 0;\\n\\t\\tfor (int i = 0; i < count; i++) {\\n\\t\\t\\tif (virusInfo[i][2] > max) {\\n\\t\\t\\t\\tindex = i;\\n\\t\\t\\t\\tmax = virusInfo[i][2];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn index;\\n\\t}\\n\\t\\n\\tprivate static boolean isFinish(int[][] map) {\\n\\t\\tboolean resultOne = true;\\n\\t\\tboolean resultTwo = true;\\n\\t\\tfor (int i = 0; i < map.length; i++) {\\n\\t\\t\\tfor (int j = 0; j < map[0].length; j++) {\\n\\t\\t\\t\\tif (map[i][j] == 1) {\\n\\t\\t\\t\\t\\tresultOne = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (map[i][j] == 0) {\\n\\t\\t\\t\\t\\tresultTwo = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn (resultOne || resultTwo);\\n\\t}\\n\\t\\n\\tprivate static boolean isValid(int[][] map, int[][] visitedVirus, int y, int x) {\\n\\t\\tif (y < 0 || y >= map.length || x < 0 || x >= map[0].length) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t\\n\\t\\tif (map[y][x] == 1 && visitedVirus[y][x] == 1) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn true;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 160991,
                "title": "share-my-intuition-java-bfs-solution",
                "content": "```\\nclass Solution {\\n    class Group {\\n        ArrayList<int[]> viruses;\\n        ArrayList<int[]> spread;\\n        int size;\\n        public Group() {\\n            viruses = new ArrayList<>();\\n            spread = new ArrayList<>();\\n            size = 0;\\n        }\\n    }\\n    \\n    int[] dx = {0, 0, 1, -1};\\n    int[] dy = {1, -1, 0, 0};\\n    \\n    public int containVirus(int[][] grid) {\\n        int ans = 0;\\n        \\n        while (true) {\\n            ArrayList<Group> groups = new ArrayList<>();\\n            getAffectedGroups(grid, groups);\\n            //System.out.println(groups.size());\\n            if (groups.size() == 0) {\\n                break;\\n            }\\n            int max = -1;\\n            int idx = -1;\\n            for (int i = 0; i < groups.size(); i++) {\\n                //System.out.println(groups.get(i).spread.size() + \"\\\\t\" + groups.get(i).viruses.size());\\n                int size = groups.get(i).spread.size();\\n                if (size > max) {\\n                    max = size;\\n                    idx = i;\\n                }\\n            }\\n            ans += groups.get(idx).size;\\n            for (int[] p : groups.get(idx).viruses) {\\n                grid[p[0]][p[1]] = 3;\\n            }\\n            groups.remove(idx);\\n            if (groups.size() == 0) {\\n                break;\\n            }\\n            for (Group g : groups) {\\n                for (int[] p : g.spread) {\\n                    grid[p[0]][p[1]] = 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    void getAffectedGroups(int[][] grid, ArrayList<Group> groups) {\\n        int M = grid.length, N = grid[0].length;\\n        int[][] visited = new int[grid.length][grid[0].length]; \\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1 && visited[i][j] == 0) {\\n                    visited[i][j] = 1;\\n                    Queue<int[]> q = new LinkedList<>();\\n                    q.offer(new int[] {i, j});\\n                    Group g = new Group();\\n                    while (!q.isEmpty()) {\\n                        int[] p = q.poll();\\n                        g.viruses.add(p);\\n                        for (int k = 0; k < 4; k++) {\\n                            int nx = p[0] + dx[k];\\n                            int ny = p[1] + dy[k];\\n                            if (nx >= 0 && nx < M && ny >= 0 && ny < N) {\\n                                if (visited[nx][ny] == 1) {\\n                                    continue;\\n                                }\\n                                if (grid[nx][ny] == 1) {\\n                                    q.offer(new int[] {nx, ny});\\n                                    visited[nx][ny] = 1;\\n                                }\\n                                else if (grid[nx][ny] == 0) {\\n                                    if (visited[nx][ny] == 0)\\n                                        g.spread.add(new int[] {nx, ny});\\n                                    g.size++;\\n                                    visited[nx][ny] = 2;\\n                                }\\n                                \\n                            }\\n                        }\\n                    }\\n                    for (int[] p : g.spread) {\\n                        visited[p[0]][p[1]] = 0;\\n                    }\\n                    groups.add(g);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class Group {\\n        ArrayList<int[]> viruses;\\n        ArrayList<int[]> spread;\\n        int size;\\n        public Group() {\\n            viruses = new ArrayList<>();\\n            spread = new ArrayList<>();\\n            size = 0;\\n        }\\n    }\\n    \\n    int[] dx = {0, 0, 1, -1};\\n    int[] dy = {1, -1, 0, 0};\\n    \\n    public int containVirus(int[][] grid) {\\n        int ans = 0;\\n        \\n        while (true) {\\n            ArrayList<Group> groups = new ArrayList<>();\\n            getAffectedGroups(grid, groups);\\n            //System.out.println(groups.size());\\n            if (groups.size() == 0) {\\n                break;\\n            }\\n            int max = -1;\\n            int idx = -1;\\n            for (int i = 0; i < groups.size(); i++) {\\n                //System.out.println(groups.get(i).spread.size() + \"\\\\t\" + groups.get(i).viruses.size());\\n                int size = groups.get(i).spread.size();\\n                if (size > max) {\\n                    max = size;\\n                    idx = i;\\n                }\\n            }\\n            ans += groups.get(idx).size;\\n            for (int[] p : groups.get(idx).viruses) {\\n                grid[p[0]][p[1]] = 3;\\n            }\\n            groups.remove(idx);\\n            if (groups.size() == 0) {\\n                break;\\n            }\\n            for (Group g : groups) {\\n                for (int[] p : g.spread) {\\n                    grid[p[0]][p[1]] = 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    void getAffectedGroups(int[][] grid, ArrayList<Group> groups) {\\n        int M = grid.length, N = grid[0].length;\\n        int[][] visited = new int[grid.length][grid[0].length]; \\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1 && visited[i][j] == 0) {\\n                    visited[i][j] = 1;\\n                    Queue<int[]> q = new LinkedList<>();\\n                    q.offer(new int[] {i, j});\\n                    Group g = new Group();\\n                    while (!q.isEmpty()) {\\n                        int[] p = q.poll();\\n                        g.viruses.add(p);\\n                        for (int k = 0; k < 4; k++) {\\n                            int nx = p[0] + dx[k];\\n                            int ny = p[1] + dy[k];\\n                            if (nx >= 0 && nx < M && ny >= 0 && ny < N) {\\n                                if (visited[nx][ny] == 1) {\\n                                    continue;\\n                                }\\n                                if (grid[nx][ny] == 1) {\\n                                    q.offer(new int[] {nx, ny});\\n                                    visited[nx][ny] = 1;\\n                                }\\n                                else if (grid[nx][ny] == 0) {\\n                                    if (visited[nx][ny] == 0)\\n                                        g.spread.add(new int[] {nx, ny});\\n                                    g.size++;\\n                                    visited[nx][ny] = 2;\\n                                }\\n                                \\n                            }\\n                        }\\n                    }\\n                    for (int[] p : g.spread) {\\n                        visited[p[0]][p[1]] = 0;\\n                    }\\n                    groups.add(g);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566634,
                "content": [
                    {
                        "username": "IWantToPass",
                        "content": "I feel like because of the sheer volume of code to write as well as determining how to implement in a simple way this is a little hard to do within one interview, jmo tho. Did anyone get this in a real interview?"
                    },
                    {
                        "username": "misteltoe",
                        "content": "I\\'ve got in OA of Goldman Sachs"
                    },
                    {
                        "username": "bo29",
                        "content": "The problem is hard, but our lives are even harder.\\n\\n`If the world will become fully infected, return the number of walls used.` Well, I guess no matter how many walls built, the world\\'s been fully infected anyway..."
                    },
                    {
                        "username": "ryx",
                        "content": "Given the input\\n0 0 1\\n0 1 0\\n1 0 0\\n\\nThe center region will be quarantined, and the other two virus spread. It becomes\\n0 1 1\\n1 1 1\\n1 1 0\\n\\nNow, how many regions there? one or two?\\n\\nThanks"
                    },
                    {
                        "username": "Finesse",
                        "content": "3. Walls split the regions."
                    },
                    {
                        "username": "cshshshzx",
                        "content": "This is what I saw during the contest, spent lots of time figuring out the logic (guess it's 11 because we can't overlap the walls)\\n![0_1513484232399_c05b43a5-4a61-4df3-9975-f1b482747be5-image.png](/assets/uploads/files/1513484236548-c05b43a5-4a61-4df3-9975-f1b482747be5-image.png) \\nBut by the time I submitted my answer, it was wrong!\\n![0_1513484327878_p1.PNG](/assets/uploads/files/1513484332132-p1-resized.png) \\nWhen I refreshed the page, this was the example answer now.\\n![0_1513484395895_7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image.png](/assets/uploads/files/1513484400071-7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image-resized.png)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "And Corona Virus took it seriously"
                    },
                    {
                        "username": "kaishen2",
                        "content": "![image](https://assets.leetcode.com/users/images/104545f1-7f7d-4bf6-af6a-2635ab0ab4ca_1600144394.7455535.png)\\n![image](https://assets.leetcode.com/users/images/68b94f38-7de5-4ac1-ab3a-d047c659d10c_1600144404.1627324.png)\\n"
                    },
                    {
                        "username": "JackyD",
                        "content": "If at the end one cell survived, can I call it the day is saved? Or the target is to save the most cells? Save ten or save one, there will be different costs. The requirement is so vague."
                    },
                    {
                        "username": "schwarzkatze",
                        "content": "[[0,1,0,1,1,1,1,1,1,0],\\n[0,0,0,1,0,0,0,0,0,0],\\n[0,0,1,1,1,0,0,0,1,0],\\n[0,0,0,1,1,0,0,1,1,0],\\n[0,1,0,0,1,0,1,1,0,1],\\n[0,0,0,1,0,1,0,1,1,1],\\n[0,1,0,0,1,0,0,1,1,0],\\n[0,1,0,1,0,0,0,1,1,0],\\n[0,1,1,0,0,1,1,0,0,1],\\n[1,0,1,1,0,1,0,1,0,1]]"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "[@guddukumar0709](/guddukumar0709) Same problem "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Here logic is to check maximum zero related to infected area\\nand then use wall to cover that area"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "can someone explain this example \\nI am getting answer 40 but expected answer is 38\\n\\nAm I missing something in this test case??"
                    },
                    {
                        "username": "alfredzj",
                        "content": "Just cuirous why we need stick to the steps provided by the solution? Is it a greedy algorithm? If so, how we make sure the result we get is the optimal one?"
                    },
                    {
                        "username": "jordandong",
                        "content": "I am very confused about this question.\\nInput: grid = \\n[[1,1,1,0,0,0,0,0,0],\\n [1,0,1,0,1,1,1,1,1],\\n [1,1,1,0,0,0,0,0,0]]\\nOutput: 13\\nExplanation: The region on the left only builds two new walls.\\n\\nit should be 12, the 0 at (1, 3) will be always infected. \\n\\nwe build 10 walls(up and down, left is not needed) for the region on the right, after one night it becomes:\\n111100000\\n111111111\\n111100000\\nthe second day, build 2 walls is enough.\\n\\nTotal is 10  + 2 = 12"
                    },
                    {
                        "username": "lak1973",
                        "content": "Actually it should be 11 the region on the left  will build 4 walls for the inner zero and three walls to its right  total 7 and on day 2 only 4 walls will be needed to stop the virus "
                    }
                ]
            },
            {
                "id": 1567659,
                "content": [
                    {
                        "username": "IWantToPass",
                        "content": "I feel like because of the sheer volume of code to write as well as determining how to implement in a simple way this is a little hard to do within one interview, jmo tho. Did anyone get this in a real interview?"
                    },
                    {
                        "username": "misteltoe",
                        "content": "I\\'ve got in OA of Goldman Sachs"
                    },
                    {
                        "username": "bo29",
                        "content": "The problem is hard, but our lives are even harder.\\n\\n`If the world will become fully infected, return the number of walls used.` Well, I guess no matter how many walls built, the world\\'s been fully infected anyway..."
                    },
                    {
                        "username": "ryx",
                        "content": "Given the input\\n0 0 1\\n0 1 0\\n1 0 0\\n\\nThe center region will be quarantined, and the other two virus spread. It becomes\\n0 1 1\\n1 1 1\\n1 1 0\\n\\nNow, how many regions there? one or two?\\n\\nThanks"
                    },
                    {
                        "username": "Finesse",
                        "content": "3. Walls split the regions."
                    },
                    {
                        "username": "cshshshzx",
                        "content": "This is what I saw during the contest, spent lots of time figuring out the logic (guess it's 11 because we can't overlap the walls)\\n![0_1513484232399_c05b43a5-4a61-4df3-9975-f1b482747be5-image.png](/assets/uploads/files/1513484236548-c05b43a5-4a61-4df3-9975-f1b482747be5-image.png) \\nBut by the time I submitted my answer, it was wrong!\\n![0_1513484327878_p1.PNG](/assets/uploads/files/1513484332132-p1-resized.png) \\nWhen I refreshed the page, this was the example answer now.\\n![0_1513484395895_7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image.png](/assets/uploads/files/1513484400071-7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image-resized.png)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "And Corona Virus took it seriously"
                    },
                    {
                        "username": "kaishen2",
                        "content": "![image](https://assets.leetcode.com/users/images/104545f1-7f7d-4bf6-af6a-2635ab0ab4ca_1600144394.7455535.png)\\n![image](https://assets.leetcode.com/users/images/68b94f38-7de5-4ac1-ab3a-d047c659d10c_1600144404.1627324.png)\\n"
                    },
                    {
                        "username": "JackyD",
                        "content": "If at the end one cell survived, can I call it the day is saved? Or the target is to save the most cells? Save ten or save one, there will be different costs. The requirement is so vague."
                    },
                    {
                        "username": "schwarzkatze",
                        "content": "[[0,1,0,1,1,1,1,1,1,0],\\n[0,0,0,1,0,0,0,0,0,0],\\n[0,0,1,1,1,0,0,0,1,0],\\n[0,0,0,1,1,0,0,1,1,0],\\n[0,1,0,0,1,0,1,1,0,1],\\n[0,0,0,1,0,1,0,1,1,1],\\n[0,1,0,0,1,0,0,1,1,0],\\n[0,1,0,1,0,0,0,1,1,0],\\n[0,1,1,0,0,1,1,0,0,1],\\n[1,0,1,1,0,1,0,1,0,1]]"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "[@guddukumar0709](/guddukumar0709) Same problem "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Here logic is to check maximum zero related to infected area\\nand then use wall to cover that area"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "can someone explain this example \\nI am getting answer 40 but expected answer is 38\\n\\nAm I missing something in this test case??"
                    },
                    {
                        "username": "alfredzj",
                        "content": "Just cuirous why we need stick to the steps provided by the solution? Is it a greedy algorithm? If so, how we make sure the result we get is the optimal one?"
                    },
                    {
                        "username": "jordandong",
                        "content": "I am very confused about this question.\\nInput: grid = \\n[[1,1,1,0,0,0,0,0,0],\\n [1,0,1,0,1,1,1,1,1],\\n [1,1,1,0,0,0,0,0,0]]\\nOutput: 13\\nExplanation: The region on the left only builds two new walls.\\n\\nit should be 12, the 0 at (1, 3) will be always infected. \\n\\nwe build 10 walls(up and down, left is not needed) for the region on the right, after one night it becomes:\\n111100000\\n111111111\\n111100000\\nthe second day, build 2 walls is enough.\\n\\nTotal is 10  + 2 = 12"
                    },
                    {
                        "username": "lak1973",
                        "content": "Actually it should be 11 the region on the left  will build 4 walls for the inner zero and three walls to its right  total 7 and on day 2 only 4 walls will be needed to stop the virus "
                    }
                ]
            },
            {
                "id": 1567285,
                "content": [
                    {
                        "username": "IWantToPass",
                        "content": "I feel like because of the sheer volume of code to write as well as determining how to implement in a simple way this is a little hard to do within one interview, jmo tho. Did anyone get this in a real interview?"
                    },
                    {
                        "username": "misteltoe",
                        "content": "I\\'ve got in OA of Goldman Sachs"
                    },
                    {
                        "username": "bo29",
                        "content": "The problem is hard, but our lives are even harder.\\n\\n`If the world will become fully infected, return the number of walls used.` Well, I guess no matter how many walls built, the world\\'s been fully infected anyway..."
                    },
                    {
                        "username": "ryx",
                        "content": "Given the input\\n0 0 1\\n0 1 0\\n1 0 0\\n\\nThe center region will be quarantined, and the other two virus spread. It becomes\\n0 1 1\\n1 1 1\\n1 1 0\\n\\nNow, how many regions there? one or two?\\n\\nThanks"
                    },
                    {
                        "username": "Finesse",
                        "content": "3. Walls split the regions."
                    },
                    {
                        "username": "cshshshzx",
                        "content": "This is what I saw during the contest, spent lots of time figuring out the logic (guess it's 11 because we can't overlap the walls)\\n![0_1513484232399_c05b43a5-4a61-4df3-9975-f1b482747be5-image.png](/assets/uploads/files/1513484236548-c05b43a5-4a61-4df3-9975-f1b482747be5-image.png) \\nBut by the time I submitted my answer, it was wrong!\\n![0_1513484327878_p1.PNG](/assets/uploads/files/1513484332132-p1-resized.png) \\nWhen I refreshed the page, this was the example answer now.\\n![0_1513484395895_7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image.png](/assets/uploads/files/1513484400071-7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image-resized.png)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "And Corona Virus took it seriously"
                    },
                    {
                        "username": "kaishen2",
                        "content": "![image](https://assets.leetcode.com/users/images/104545f1-7f7d-4bf6-af6a-2635ab0ab4ca_1600144394.7455535.png)\\n![image](https://assets.leetcode.com/users/images/68b94f38-7de5-4ac1-ab3a-d047c659d10c_1600144404.1627324.png)\\n"
                    },
                    {
                        "username": "JackyD",
                        "content": "If at the end one cell survived, can I call it the day is saved? Or the target is to save the most cells? Save ten or save one, there will be different costs. The requirement is so vague."
                    },
                    {
                        "username": "schwarzkatze",
                        "content": "[[0,1,0,1,1,1,1,1,1,0],\\n[0,0,0,1,0,0,0,0,0,0],\\n[0,0,1,1,1,0,0,0,1,0],\\n[0,0,0,1,1,0,0,1,1,0],\\n[0,1,0,0,1,0,1,1,0,1],\\n[0,0,0,1,0,1,0,1,1,1],\\n[0,1,0,0,1,0,0,1,1,0],\\n[0,1,0,1,0,0,0,1,1,0],\\n[0,1,1,0,0,1,1,0,0,1],\\n[1,0,1,1,0,1,0,1,0,1]]"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "[@guddukumar0709](/guddukumar0709) Same problem "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Here logic is to check maximum zero related to infected area\\nand then use wall to cover that area"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "can someone explain this example \\nI am getting answer 40 but expected answer is 38\\n\\nAm I missing something in this test case??"
                    },
                    {
                        "username": "alfredzj",
                        "content": "Just cuirous why we need stick to the steps provided by the solution? Is it a greedy algorithm? If so, how we make sure the result we get is the optimal one?"
                    },
                    {
                        "username": "jordandong",
                        "content": "I am very confused about this question.\\nInput: grid = \\n[[1,1,1,0,0,0,0,0,0],\\n [1,0,1,0,1,1,1,1,1],\\n [1,1,1,0,0,0,0,0,0]]\\nOutput: 13\\nExplanation: The region on the left only builds two new walls.\\n\\nit should be 12, the 0 at (1, 3) will be always infected. \\n\\nwe build 10 walls(up and down, left is not needed) for the region on the right, after one night it becomes:\\n111100000\\n111111111\\n111100000\\nthe second day, build 2 walls is enough.\\n\\nTotal is 10  + 2 = 12"
                    },
                    {
                        "username": "lak1973",
                        "content": "Actually it should be 11 the region on the left  will build 4 walls for the inner zero and three walls to its right  total 7 and on day 2 only 4 walls will be needed to stop the virus "
                    }
                ]
            },
            {
                "id": 1567284,
                "content": [
                    {
                        "username": "IWantToPass",
                        "content": "I feel like because of the sheer volume of code to write as well as determining how to implement in a simple way this is a little hard to do within one interview, jmo tho. Did anyone get this in a real interview?"
                    },
                    {
                        "username": "misteltoe",
                        "content": "I\\'ve got in OA of Goldman Sachs"
                    },
                    {
                        "username": "bo29",
                        "content": "The problem is hard, but our lives are even harder.\\n\\n`If the world will become fully infected, return the number of walls used.` Well, I guess no matter how many walls built, the world\\'s been fully infected anyway..."
                    },
                    {
                        "username": "ryx",
                        "content": "Given the input\\n0 0 1\\n0 1 0\\n1 0 0\\n\\nThe center region will be quarantined, and the other two virus spread. It becomes\\n0 1 1\\n1 1 1\\n1 1 0\\n\\nNow, how many regions there? one or two?\\n\\nThanks"
                    },
                    {
                        "username": "Finesse",
                        "content": "3. Walls split the regions."
                    },
                    {
                        "username": "cshshshzx",
                        "content": "This is what I saw during the contest, spent lots of time figuring out the logic (guess it's 11 because we can't overlap the walls)\\n![0_1513484232399_c05b43a5-4a61-4df3-9975-f1b482747be5-image.png](/assets/uploads/files/1513484236548-c05b43a5-4a61-4df3-9975-f1b482747be5-image.png) \\nBut by the time I submitted my answer, it was wrong!\\n![0_1513484327878_p1.PNG](/assets/uploads/files/1513484332132-p1-resized.png) \\nWhen I refreshed the page, this was the example answer now.\\n![0_1513484395895_7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image.png](/assets/uploads/files/1513484400071-7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image-resized.png)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "And Corona Virus took it seriously"
                    },
                    {
                        "username": "kaishen2",
                        "content": "![image](https://assets.leetcode.com/users/images/104545f1-7f7d-4bf6-af6a-2635ab0ab4ca_1600144394.7455535.png)\\n![image](https://assets.leetcode.com/users/images/68b94f38-7de5-4ac1-ab3a-d047c659d10c_1600144404.1627324.png)\\n"
                    },
                    {
                        "username": "JackyD",
                        "content": "If at the end one cell survived, can I call it the day is saved? Or the target is to save the most cells? Save ten or save one, there will be different costs. The requirement is so vague."
                    },
                    {
                        "username": "schwarzkatze",
                        "content": "[[0,1,0,1,1,1,1,1,1,0],\\n[0,0,0,1,0,0,0,0,0,0],\\n[0,0,1,1,1,0,0,0,1,0],\\n[0,0,0,1,1,0,0,1,1,0],\\n[0,1,0,0,1,0,1,1,0,1],\\n[0,0,0,1,0,1,0,1,1,1],\\n[0,1,0,0,1,0,0,1,1,0],\\n[0,1,0,1,0,0,0,1,1,0],\\n[0,1,1,0,0,1,1,0,0,1],\\n[1,0,1,1,0,1,0,1,0,1]]"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "[@guddukumar0709](/guddukumar0709) Same problem "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Here logic is to check maximum zero related to infected area\\nand then use wall to cover that area"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "can someone explain this example \\nI am getting answer 40 but expected answer is 38\\n\\nAm I missing something in this test case??"
                    },
                    {
                        "username": "alfredzj",
                        "content": "Just cuirous why we need stick to the steps provided by the solution? Is it a greedy algorithm? If so, how we make sure the result we get is the optimal one?"
                    },
                    {
                        "username": "jordandong",
                        "content": "I am very confused about this question.\\nInput: grid = \\n[[1,1,1,0,0,0,0,0,0],\\n [1,0,1,0,1,1,1,1,1],\\n [1,1,1,0,0,0,0,0,0]]\\nOutput: 13\\nExplanation: The region on the left only builds two new walls.\\n\\nit should be 12, the 0 at (1, 3) will be always infected. \\n\\nwe build 10 walls(up and down, left is not needed) for the region on the right, after one night it becomes:\\n111100000\\n111111111\\n111100000\\nthe second day, build 2 walls is enough.\\n\\nTotal is 10  + 2 = 12"
                    },
                    {
                        "username": "lak1973",
                        "content": "Actually it should be 11 the region on the left  will build 4 walls for the inner zero and three walls to its right  total 7 and on day 2 only 4 walls will be needed to stop the virus "
                    }
                ]
            },
            {
                "id": 1815372,
                "content": [
                    {
                        "username": "IWantToPass",
                        "content": "I feel like because of the sheer volume of code to write as well as determining how to implement in a simple way this is a little hard to do within one interview, jmo tho. Did anyone get this in a real interview?"
                    },
                    {
                        "username": "misteltoe",
                        "content": "I\\'ve got in OA of Goldman Sachs"
                    },
                    {
                        "username": "bo29",
                        "content": "The problem is hard, but our lives are even harder.\\n\\n`If the world will become fully infected, return the number of walls used.` Well, I guess no matter how many walls built, the world\\'s been fully infected anyway..."
                    },
                    {
                        "username": "ryx",
                        "content": "Given the input\\n0 0 1\\n0 1 0\\n1 0 0\\n\\nThe center region will be quarantined, and the other two virus spread. It becomes\\n0 1 1\\n1 1 1\\n1 1 0\\n\\nNow, how many regions there? one or two?\\n\\nThanks"
                    },
                    {
                        "username": "Finesse",
                        "content": "3. Walls split the regions."
                    },
                    {
                        "username": "cshshshzx",
                        "content": "This is what I saw during the contest, spent lots of time figuring out the logic (guess it's 11 because we can't overlap the walls)\\n![0_1513484232399_c05b43a5-4a61-4df3-9975-f1b482747be5-image.png](/assets/uploads/files/1513484236548-c05b43a5-4a61-4df3-9975-f1b482747be5-image.png) \\nBut by the time I submitted my answer, it was wrong!\\n![0_1513484327878_p1.PNG](/assets/uploads/files/1513484332132-p1-resized.png) \\nWhen I refreshed the page, this was the example answer now.\\n![0_1513484395895_7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image.png](/assets/uploads/files/1513484400071-7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image-resized.png)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "And Corona Virus took it seriously"
                    },
                    {
                        "username": "kaishen2",
                        "content": "![image](https://assets.leetcode.com/users/images/104545f1-7f7d-4bf6-af6a-2635ab0ab4ca_1600144394.7455535.png)\\n![image](https://assets.leetcode.com/users/images/68b94f38-7de5-4ac1-ab3a-d047c659d10c_1600144404.1627324.png)\\n"
                    },
                    {
                        "username": "JackyD",
                        "content": "If at the end one cell survived, can I call it the day is saved? Or the target is to save the most cells? Save ten or save one, there will be different costs. The requirement is so vague."
                    },
                    {
                        "username": "schwarzkatze",
                        "content": "[[0,1,0,1,1,1,1,1,1,0],\\n[0,0,0,1,0,0,0,0,0,0],\\n[0,0,1,1,1,0,0,0,1,0],\\n[0,0,0,1,1,0,0,1,1,0],\\n[0,1,0,0,1,0,1,1,0,1],\\n[0,0,0,1,0,1,0,1,1,1],\\n[0,1,0,0,1,0,0,1,1,0],\\n[0,1,0,1,0,0,0,1,1,0],\\n[0,1,1,0,0,1,1,0,0,1],\\n[1,0,1,1,0,1,0,1,0,1]]"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "[@guddukumar0709](/guddukumar0709) Same problem "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Here logic is to check maximum zero related to infected area\\nand then use wall to cover that area"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "can someone explain this example \\nI am getting answer 40 but expected answer is 38\\n\\nAm I missing something in this test case??"
                    },
                    {
                        "username": "alfredzj",
                        "content": "Just cuirous why we need stick to the steps provided by the solution? Is it a greedy algorithm? If so, how we make sure the result we get is the optimal one?"
                    },
                    {
                        "username": "jordandong",
                        "content": "I am very confused about this question.\\nInput: grid = \\n[[1,1,1,0,0,0,0,0,0],\\n [1,0,1,0,1,1,1,1,1],\\n [1,1,1,0,0,0,0,0,0]]\\nOutput: 13\\nExplanation: The region on the left only builds two new walls.\\n\\nit should be 12, the 0 at (1, 3) will be always infected. \\n\\nwe build 10 walls(up and down, left is not needed) for the region on the right, after one night it becomes:\\n111100000\\n111111111\\n111100000\\nthe second day, build 2 walls is enough.\\n\\nTotal is 10  + 2 = 12"
                    },
                    {
                        "username": "lak1973",
                        "content": "Actually it should be 11 the region on the left  will build 4 walls for the inner zero and three walls to its right  total 7 and on day 2 only 4 walls will be needed to stop the virus "
                    }
                ]
            },
            {
                "id": 1568446,
                "content": [
                    {
                        "username": "IWantToPass",
                        "content": "I feel like because of the sheer volume of code to write as well as determining how to implement in a simple way this is a little hard to do within one interview, jmo tho. Did anyone get this in a real interview?"
                    },
                    {
                        "username": "misteltoe",
                        "content": "I\\'ve got in OA of Goldman Sachs"
                    },
                    {
                        "username": "bo29",
                        "content": "The problem is hard, but our lives are even harder.\\n\\n`If the world will become fully infected, return the number of walls used.` Well, I guess no matter how many walls built, the world\\'s been fully infected anyway..."
                    },
                    {
                        "username": "ryx",
                        "content": "Given the input\\n0 0 1\\n0 1 0\\n1 0 0\\n\\nThe center region will be quarantined, and the other two virus spread. It becomes\\n0 1 1\\n1 1 1\\n1 1 0\\n\\nNow, how many regions there? one or two?\\n\\nThanks"
                    },
                    {
                        "username": "Finesse",
                        "content": "3. Walls split the regions."
                    },
                    {
                        "username": "cshshshzx",
                        "content": "This is what I saw during the contest, spent lots of time figuring out the logic (guess it's 11 because we can't overlap the walls)\\n![0_1513484232399_c05b43a5-4a61-4df3-9975-f1b482747be5-image.png](/assets/uploads/files/1513484236548-c05b43a5-4a61-4df3-9975-f1b482747be5-image.png) \\nBut by the time I submitted my answer, it was wrong!\\n![0_1513484327878_p1.PNG](/assets/uploads/files/1513484332132-p1-resized.png) \\nWhen I refreshed the page, this was the example answer now.\\n![0_1513484395895_7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image.png](/assets/uploads/files/1513484400071-7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image-resized.png)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "And Corona Virus took it seriously"
                    },
                    {
                        "username": "kaishen2",
                        "content": "![image](https://assets.leetcode.com/users/images/104545f1-7f7d-4bf6-af6a-2635ab0ab4ca_1600144394.7455535.png)\\n![image](https://assets.leetcode.com/users/images/68b94f38-7de5-4ac1-ab3a-d047c659d10c_1600144404.1627324.png)\\n"
                    },
                    {
                        "username": "JackyD",
                        "content": "If at the end one cell survived, can I call it the day is saved? Or the target is to save the most cells? Save ten or save one, there will be different costs. The requirement is so vague."
                    },
                    {
                        "username": "schwarzkatze",
                        "content": "[[0,1,0,1,1,1,1,1,1,0],\\n[0,0,0,1,0,0,0,0,0,0],\\n[0,0,1,1,1,0,0,0,1,0],\\n[0,0,0,1,1,0,0,1,1,0],\\n[0,1,0,0,1,0,1,1,0,1],\\n[0,0,0,1,0,1,0,1,1,1],\\n[0,1,0,0,1,0,0,1,1,0],\\n[0,1,0,1,0,0,0,1,1,0],\\n[0,1,1,0,0,1,1,0,0,1],\\n[1,0,1,1,0,1,0,1,0,1]]"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "[@guddukumar0709](/guddukumar0709) Same problem "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Here logic is to check maximum zero related to infected area\\nand then use wall to cover that area"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "can someone explain this example \\nI am getting answer 40 but expected answer is 38\\n\\nAm I missing something in this test case??"
                    },
                    {
                        "username": "alfredzj",
                        "content": "Just cuirous why we need stick to the steps provided by the solution? Is it a greedy algorithm? If so, how we make sure the result we get is the optimal one?"
                    },
                    {
                        "username": "jordandong",
                        "content": "I am very confused about this question.\\nInput: grid = \\n[[1,1,1,0,0,0,0,0,0],\\n [1,0,1,0,1,1,1,1,1],\\n [1,1,1,0,0,0,0,0,0]]\\nOutput: 13\\nExplanation: The region on the left only builds two new walls.\\n\\nit should be 12, the 0 at (1, 3) will be always infected. \\n\\nwe build 10 walls(up and down, left is not needed) for the region on the right, after one night it becomes:\\n111100000\\n111111111\\n111100000\\nthe second day, build 2 walls is enough.\\n\\nTotal is 10  + 2 = 12"
                    },
                    {
                        "username": "lak1973",
                        "content": "Actually it should be 11 the region on the left  will build 4 walls for the inner zero and three walls to its right  total 7 and on day 2 only 4 walls will be needed to stop the virus "
                    }
                ]
            },
            {
                "id": 1573462,
                "content": [
                    {
                        "username": "IWantToPass",
                        "content": "I feel like because of the sheer volume of code to write as well as determining how to implement in a simple way this is a little hard to do within one interview, jmo tho. Did anyone get this in a real interview?"
                    },
                    {
                        "username": "misteltoe",
                        "content": "I\\'ve got in OA of Goldman Sachs"
                    },
                    {
                        "username": "bo29",
                        "content": "The problem is hard, but our lives are even harder.\\n\\n`If the world will become fully infected, return the number of walls used.` Well, I guess no matter how many walls built, the world\\'s been fully infected anyway..."
                    },
                    {
                        "username": "ryx",
                        "content": "Given the input\\n0 0 1\\n0 1 0\\n1 0 0\\n\\nThe center region will be quarantined, and the other two virus spread. It becomes\\n0 1 1\\n1 1 1\\n1 1 0\\n\\nNow, how many regions there? one or two?\\n\\nThanks"
                    },
                    {
                        "username": "Finesse",
                        "content": "3. Walls split the regions."
                    },
                    {
                        "username": "cshshshzx",
                        "content": "This is what I saw during the contest, spent lots of time figuring out the logic (guess it's 11 because we can't overlap the walls)\\n![0_1513484232399_c05b43a5-4a61-4df3-9975-f1b482747be5-image.png](/assets/uploads/files/1513484236548-c05b43a5-4a61-4df3-9975-f1b482747be5-image.png) \\nBut by the time I submitted my answer, it was wrong!\\n![0_1513484327878_p1.PNG](/assets/uploads/files/1513484332132-p1-resized.png) \\nWhen I refreshed the page, this was the example answer now.\\n![0_1513484395895_7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image.png](/assets/uploads/files/1513484400071-7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image-resized.png)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "And Corona Virus took it seriously"
                    },
                    {
                        "username": "kaishen2",
                        "content": "![image](https://assets.leetcode.com/users/images/104545f1-7f7d-4bf6-af6a-2635ab0ab4ca_1600144394.7455535.png)\\n![image](https://assets.leetcode.com/users/images/68b94f38-7de5-4ac1-ab3a-d047c659d10c_1600144404.1627324.png)\\n"
                    },
                    {
                        "username": "JackyD",
                        "content": "If at the end one cell survived, can I call it the day is saved? Or the target is to save the most cells? Save ten or save one, there will be different costs. The requirement is so vague."
                    },
                    {
                        "username": "schwarzkatze",
                        "content": "[[0,1,0,1,1,1,1,1,1,0],\\n[0,0,0,1,0,0,0,0,0,0],\\n[0,0,1,1,1,0,0,0,1,0],\\n[0,0,0,1,1,0,0,1,1,0],\\n[0,1,0,0,1,0,1,1,0,1],\\n[0,0,0,1,0,1,0,1,1,1],\\n[0,1,0,0,1,0,0,1,1,0],\\n[0,1,0,1,0,0,0,1,1,0],\\n[0,1,1,0,0,1,1,0,0,1],\\n[1,0,1,1,0,1,0,1,0,1]]"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "[@guddukumar0709](/guddukumar0709) Same problem "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Here logic is to check maximum zero related to infected area\\nand then use wall to cover that area"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "can someone explain this example \\nI am getting answer 40 but expected answer is 38\\n\\nAm I missing something in this test case??"
                    },
                    {
                        "username": "alfredzj",
                        "content": "Just cuirous why we need stick to the steps provided by the solution? Is it a greedy algorithm? If so, how we make sure the result we get is the optimal one?"
                    },
                    {
                        "username": "jordandong",
                        "content": "I am very confused about this question.\\nInput: grid = \\n[[1,1,1,0,0,0,0,0,0],\\n [1,0,1,0,1,1,1,1,1],\\n [1,1,1,0,0,0,0,0,0]]\\nOutput: 13\\nExplanation: The region on the left only builds two new walls.\\n\\nit should be 12, the 0 at (1, 3) will be always infected. \\n\\nwe build 10 walls(up and down, left is not needed) for the region on the right, after one night it becomes:\\n111100000\\n111111111\\n111100000\\nthe second day, build 2 walls is enough.\\n\\nTotal is 10  + 2 = 12"
                    },
                    {
                        "username": "lak1973",
                        "content": "Actually it should be 11 the region on the left  will build 4 walls for the inner zero and three walls to its right  total 7 and on day 2 only 4 walls will be needed to stop the virus "
                    }
                ]
            },
            {
                "id": 1569160,
                "content": [
                    {
                        "username": "IWantToPass",
                        "content": "I feel like because of the sheer volume of code to write as well as determining how to implement in a simple way this is a little hard to do within one interview, jmo tho. Did anyone get this in a real interview?"
                    },
                    {
                        "username": "misteltoe",
                        "content": "I\\'ve got in OA of Goldman Sachs"
                    },
                    {
                        "username": "bo29",
                        "content": "The problem is hard, but our lives are even harder.\\n\\n`If the world will become fully infected, return the number of walls used.` Well, I guess no matter how many walls built, the world\\'s been fully infected anyway..."
                    },
                    {
                        "username": "ryx",
                        "content": "Given the input\\n0 0 1\\n0 1 0\\n1 0 0\\n\\nThe center region will be quarantined, and the other two virus spread. It becomes\\n0 1 1\\n1 1 1\\n1 1 0\\n\\nNow, how many regions there? one or two?\\n\\nThanks"
                    },
                    {
                        "username": "Finesse",
                        "content": "3. Walls split the regions."
                    },
                    {
                        "username": "cshshshzx",
                        "content": "This is what I saw during the contest, spent lots of time figuring out the logic (guess it's 11 because we can't overlap the walls)\\n![0_1513484232399_c05b43a5-4a61-4df3-9975-f1b482747be5-image.png](/assets/uploads/files/1513484236548-c05b43a5-4a61-4df3-9975-f1b482747be5-image.png) \\nBut by the time I submitted my answer, it was wrong!\\n![0_1513484327878_p1.PNG](/assets/uploads/files/1513484332132-p1-resized.png) \\nWhen I refreshed the page, this was the example answer now.\\n![0_1513484395895_7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image.png](/assets/uploads/files/1513484400071-7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image-resized.png)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "And Corona Virus took it seriously"
                    },
                    {
                        "username": "kaishen2",
                        "content": "![image](https://assets.leetcode.com/users/images/104545f1-7f7d-4bf6-af6a-2635ab0ab4ca_1600144394.7455535.png)\\n![image](https://assets.leetcode.com/users/images/68b94f38-7de5-4ac1-ab3a-d047c659d10c_1600144404.1627324.png)\\n"
                    },
                    {
                        "username": "JackyD",
                        "content": "If at the end one cell survived, can I call it the day is saved? Or the target is to save the most cells? Save ten or save one, there will be different costs. The requirement is so vague."
                    },
                    {
                        "username": "schwarzkatze",
                        "content": "[[0,1,0,1,1,1,1,1,1,0],\\n[0,0,0,1,0,0,0,0,0,0],\\n[0,0,1,1,1,0,0,0,1,0],\\n[0,0,0,1,1,0,0,1,1,0],\\n[0,1,0,0,1,0,1,1,0,1],\\n[0,0,0,1,0,1,0,1,1,1],\\n[0,1,0,0,1,0,0,1,1,0],\\n[0,1,0,1,0,0,0,1,1,0],\\n[0,1,1,0,0,1,1,0,0,1],\\n[1,0,1,1,0,1,0,1,0,1]]"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "[@guddukumar0709](/guddukumar0709) Same problem "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Here logic is to check maximum zero related to infected area\\nand then use wall to cover that area"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "can someone explain this example \\nI am getting answer 40 but expected answer is 38\\n\\nAm I missing something in this test case??"
                    },
                    {
                        "username": "alfredzj",
                        "content": "Just cuirous why we need stick to the steps provided by the solution? Is it a greedy algorithm? If so, how we make sure the result we get is the optimal one?"
                    },
                    {
                        "username": "jordandong",
                        "content": "I am very confused about this question.\\nInput: grid = \\n[[1,1,1,0,0,0,0,0,0],\\n [1,0,1,0,1,1,1,1,1],\\n [1,1,1,0,0,0,0,0,0]]\\nOutput: 13\\nExplanation: The region on the left only builds two new walls.\\n\\nit should be 12, the 0 at (1, 3) will be always infected. \\n\\nwe build 10 walls(up and down, left is not needed) for the region on the right, after one night it becomes:\\n111100000\\n111111111\\n111100000\\nthe second day, build 2 walls is enough.\\n\\nTotal is 10  + 2 = 12"
                    },
                    {
                        "username": "lak1973",
                        "content": "Actually it should be 11 the region on the left  will build 4 walls for the inner zero and three walls to its right  total 7 and on day 2 only 4 walls will be needed to stop the virus "
                    }
                ]
            },
            {
                "id": 1574676,
                "content": [
                    {
                        "username": "IWantToPass",
                        "content": "I feel like because of the sheer volume of code to write as well as determining how to implement in a simple way this is a little hard to do within one interview, jmo tho. Did anyone get this in a real interview?"
                    },
                    {
                        "username": "misteltoe",
                        "content": "I\\'ve got in OA of Goldman Sachs"
                    },
                    {
                        "username": "bo29",
                        "content": "The problem is hard, but our lives are even harder.\\n\\n`If the world will become fully infected, return the number of walls used.` Well, I guess no matter how many walls built, the world\\'s been fully infected anyway..."
                    },
                    {
                        "username": "ryx",
                        "content": "Given the input\\n0 0 1\\n0 1 0\\n1 0 0\\n\\nThe center region will be quarantined, and the other two virus spread. It becomes\\n0 1 1\\n1 1 1\\n1 1 0\\n\\nNow, how many regions there? one or two?\\n\\nThanks"
                    },
                    {
                        "username": "Finesse",
                        "content": "3. Walls split the regions."
                    },
                    {
                        "username": "cshshshzx",
                        "content": "This is what I saw during the contest, spent lots of time figuring out the logic (guess it's 11 because we can't overlap the walls)\\n![0_1513484232399_c05b43a5-4a61-4df3-9975-f1b482747be5-image.png](/assets/uploads/files/1513484236548-c05b43a5-4a61-4df3-9975-f1b482747be5-image.png) \\nBut by the time I submitted my answer, it was wrong!\\n![0_1513484327878_p1.PNG](/assets/uploads/files/1513484332132-p1-resized.png) \\nWhen I refreshed the page, this was the example answer now.\\n![0_1513484395895_7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image.png](/assets/uploads/files/1513484400071-7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image-resized.png)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "And Corona Virus took it seriously"
                    },
                    {
                        "username": "kaishen2",
                        "content": "![image](https://assets.leetcode.com/users/images/104545f1-7f7d-4bf6-af6a-2635ab0ab4ca_1600144394.7455535.png)\\n![image](https://assets.leetcode.com/users/images/68b94f38-7de5-4ac1-ab3a-d047c659d10c_1600144404.1627324.png)\\n"
                    },
                    {
                        "username": "JackyD",
                        "content": "If at the end one cell survived, can I call it the day is saved? Or the target is to save the most cells? Save ten or save one, there will be different costs. The requirement is so vague."
                    },
                    {
                        "username": "schwarzkatze",
                        "content": "[[0,1,0,1,1,1,1,1,1,0],\\n[0,0,0,1,0,0,0,0,0,0],\\n[0,0,1,1,1,0,0,0,1,0],\\n[0,0,0,1,1,0,0,1,1,0],\\n[0,1,0,0,1,0,1,1,0,1],\\n[0,0,0,1,0,1,0,1,1,1],\\n[0,1,0,0,1,0,0,1,1,0],\\n[0,1,0,1,0,0,0,1,1,0],\\n[0,1,1,0,0,1,1,0,0,1],\\n[1,0,1,1,0,1,0,1,0,1]]"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "[@guddukumar0709](/guddukumar0709) Same problem "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Here logic is to check maximum zero related to infected area\\nand then use wall to cover that area"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "can someone explain this example \\nI am getting answer 40 but expected answer is 38\\n\\nAm I missing something in this test case??"
                    },
                    {
                        "username": "alfredzj",
                        "content": "Just cuirous why we need stick to the steps provided by the solution? Is it a greedy algorithm? If so, how we make sure the result we get is the optimal one?"
                    },
                    {
                        "username": "jordandong",
                        "content": "I am very confused about this question.\\nInput: grid = \\n[[1,1,1,0,0,0,0,0,0],\\n [1,0,1,0,1,1,1,1,1],\\n [1,1,1,0,0,0,0,0,0]]\\nOutput: 13\\nExplanation: The region on the left only builds two new walls.\\n\\nit should be 12, the 0 at (1, 3) will be always infected. \\n\\nwe build 10 walls(up and down, left is not needed) for the region on the right, after one night it becomes:\\n111100000\\n111111111\\n111100000\\nthe second day, build 2 walls is enough.\\n\\nTotal is 10  + 2 = 12"
                    },
                    {
                        "username": "lak1973",
                        "content": "Actually it should be 11 the region on the left  will build 4 walls for the inner zero and three walls to its right  total 7 and on day 2 only 4 walls will be needed to stop the virus "
                    }
                ]
            },
            {
                "id": 1571820,
                "content": [
                    {
                        "username": "IWantToPass",
                        "content": "I feel like because of the sheer volume of code to write as well as determining how to implement in a simple way this is a little hard to do within one interview, jmo tho. Did anyone get this in a real interview?"
                    },
                    {
                        "username": "misteltoe",
                        "content": "I\\'ve got in OA of Goldman Sachs"
                    },
                    {
                        "username": "bo29",
                        "content": "The problem is hard, but our lives are even harder.\\n\\n`If the world will become fully infected, return the number of walls used.` Well, I guess no matter how many walls built, the world\\'s been fully infected anyway..."
                    },
                    {
                        "username": "ryx",
                        "content": "Given the input\\n0 0 1\\n0 1 0\\n1 0 0\\n\\nThe center region will be quarantined, and the other two virus spread. It becomes\\n0 1 1\\n1 1 1\\n1 1 0\\n\\nNow, how many regions there? one or two?\\n\\nThanks"
                    },
                    {
                        "username": "Finesse",
                        "content": "3. Walls split the regions."
                    },
                    {
                        "username": "cshshshzx",
                        "content": "This is what I saw during the contest, spent lots of time figuring out the logic (guess it's 11 because we can't overlap the walls)\\n![0_1513484232399_c05b43a5-4a61-4df3-9975-f1b482747be5-image.png](/assets/uploads/files/1513484236548-c05b43a5-4a61-4df3-9975-f1b482747be5-image.png) \\nBut by the time I submitted my answer, it was wrong!\\n![0_1513484327878_p1.PNG](/assets/uploads/files/1513484332132-p1-resized.png) \\nWhen I refreshed the page, this was the example answer now.\\n![0_1513484395895_7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image.png](/assets/uploads/files/1513484400071-7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image-resized.png)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "And Corona Virus took it seriously"
                    },
                    {
                        "username": "kaishen2",
                        "content": "![image](https://assets.leetcode.com/users/images/104545f1-7f7d-4bf6-af6a-2635ab0ab4ca_1600144394.7455535.png)\\n![image](https://assets.leetcode.com/users/images/68b94f38-7de5-4ac1-ab3a-d047c659d10c_1600144404.1627324.png)\\n"
                    },
                    {
                        "username": "JackyD",
                        "content": "If at the end one cell survived, can I call it the day is saved? Or the target is to save the most cells? Save ten or save one, there will be different costs. The requirement is so vague."
                    },
                    {
                        "username": "schwarzkatze",
                        "content": "[[0,1,0,1,1,1,1,1,1,0],\\n[0,0,0,1,0,0,0,0,0,0],\\n[0,0,1,1,1,0,0,0,1,0],\\n[0,0,0,1,1,0,0,1,1,0],\\n[0,1,0,0,1,0,1,1,0,1],\\n[0,0,0,1,0,1,0,1,1,1],\\n[0,1,0,0,1,0,0,1,1,0],\\n[0,1,0,1,0,0,0,1,1,0],\\n[0,1,1,0,0,1,1,0,0,1],\\n[1,0,1,1,0,1,0,1,0,1]]"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "[@guddukumar0709](/guddukumar0709) Same problem "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Here logic is to check maximum zero related to infected area\\nand then use wall to cover that area"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "can someone explain this example \\nI am getting answer 40 but expected answer is 38\\n\\nAm I missing something in this test case??"
                    },
                    {
                        "username": "alfredzj",
                        "content": "Just cuirous why we need stick to the steps provided by the solution? Is it a greedy algorithm? If so, how we make sure the result we get is the optimal one?"
                    },
                    {
                        "username": "jordandong",
                        "content": "I am very confused about this question.\\nInput: grid = \\n[[1,1,1,0,0,0,0,0,0],\\n [1,0,1,0,1,1,1,1,1],\\n [1,1,1,0,0,0,0,0,0]]\\nOutput: 13\\nExplanation: The region on the left only builds two new walls.\\n\\nit should be 12, the 0 at (1, 3) will be always infected. \\n\\nwe build 10 walls(up and down, left is not needed) for the region on the right, after one night it becomes:\\n111100000\\n111111111\\n111100000\\nthe second day, build 2 walls is enough.\\n\\nTotal is 10  + 2 = 12"
                    },
                    {
                        "username": "lak1973",
                        "content": "Actually it should be 11 the region on the left  will build 4 walls for the inner zero and three walls to its right  total 7 and on day 2 only 4 walls will be needed to stop the virus "
                    }
                ]
            },
            {
                "id": 1566634,
                "content": [
                    {
                        "username": "IWantToPass",
                        "content": "I feel like because of the sheer volume of code to write as well as determining how to implement in a simple way this is a little hard to do within one interview, jmo tho. Did anyone get this in a real interview?"
                    },
                    {
                        "username": "misteltoe",
                        "content": "I\\'ve got in OA of Goldman Sachs"
                    },
                    {
                        "username": "bo29",
                        "content": "The problem is hard, but our lives are even harder.\\n\\n`If the world will become fully infected, return the number of walls used.` Well, I guess no matter how many walls built, the world\\'s been fully infected anyway..."
                    },
                    {
                        "username": "ryx",
                        "content": "Given the input\\n0 0 1\\n0 1 0\\n1 0 0\\n\\nThe center region will be quarantined, and the other two virus spread. It becomes\\n0 1 1\\n1 1 1\\n1 1 0\\n\\nNow, how many regions there? one or two?\\n\\nThanks"
                    },
                    {
                        "username": "Finesse",
                        "content": "3. Walls split the regions."
                    },
                    {
                        "username": "cshshshzx",
                        "content": "This is what I saw during the contest, spent lots of time figuring out the logic (guess it's 11 because we can't overlap the walls)\\n![0_1513484232399_c05b43a5-4a61-4df3-9975-f1b482747be5-image.png](/assets/uploads/files/1513484236548-c05b43a5-4a61-4df3-9975-f1b482747be5-image.png) \\nBut by the time I submitted my answer, it was wrong!\\n![0_1513484327878_p1.PNG](/assets/uploads/files/1513484332132-p1-resized.png) \\nWhen I refreshed the page, this was the example answer now.\\n![0_1513484395895_7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image.png](/assets/uploads/files/1513484400071-7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image-resized.png)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "And Corona Virus took it seriously"
                    },
                    {
                        "username": "kaishen2",
                        "content": "![image](https://assets.leetcode.com/users/images/104545f1-7f7d-4bf6-af6a-2635ab0ab4ca_1600144394.7455535.png)\\n![image](https://assets.leetcode.com/users/images/68b94f38-7de5-4ac1-ab3a-d047c659d10c_1600144404.1627324.png)\\n"
                    },
                    {
                        "username": "JackyD",
                        "content": "If at the end one cell survived, can I call it the day is saved? Or the target is to save the most cells? Save ten or save one, there will be different costs. The requirement is so vague."
                    },
                    {
                        "username": "schwarzkatze",
                        "content": "[[0,1,0,1,1,1,1,1,1,0],\\n[0,0,0,1,0,0,0,0,0,0],\\n[0,0,1,1,1,0,0,0,1,0],\\n[0,0,0,1,1,0,0,1,1,0],\\n[0,1,0,0,1,0,1,1,0,1],\\n[0,0,0,1,0,1,0,1,1,1],\\n[0,1,0,0,1,0,0,1,1,0],\\n[0,1,0,1,0,0,0,1,1,0],\\n[0,1,1,0,0,1,1,0,0,1],\\n[1,0,1,1,0,1,0,1,0,1]]"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "[@guddukumar0709](/guddukumar0709) Same problem "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Here logic is to check maximum zero related to infected area\\nand then use wall to cover that area"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "can someone explain this example \\nI am getting answer 40 but expected answer is 38\\n\\nAm I missing something in this test case??"
                    },
                    {
                        "username": "alfredzj",
                        "content": "Just cuirous why we need stick to the steps provided by the solution? Is it a greedy algorithm? If so, how we make sure the result we get is the optimal one?"
                    },
                    {
                        "username": "jordandong",
                        "content": "I am very confused about this question.\\nInput: grid = \\n[[1,1,1,0,0,0,0,0,0],\\n [1,0,1,0,1,1,1,1,1],\\n [1,1,1,0,0,0,0,0,0]]\\nOutput: 13\\nExplanation: The region on the left only builds two new walls.\\n\\nit should be 12, the 0 at (1, 3) will be always infected. \\n\\nwe build 10 walls(up and down, left is not needed) for the region on the right, after one night it becomes:\\n111100000\\n111111111\\n111100000\\nthe second day, build 2 walls is enough.\\n\\nTotal is 10  + 2 = 12"
                    },
                    {
                        "username": "lak1973",
                        "content": "Actually it should be 11 the region on the left  will build 4 walls for the inner zero and three walls to its right  total 7 and on day 2 only 4 walls will be needed to stop the virus "
                    }
                ]
            },
            {
                "id": 1567659,
                "content": [
                    {
                        "username": "IWantToPass",
                        "content": "I feel like because of the sheer volume of code to write as well as determining how to implement in a simple way this is a little hard to do within one interview, jmo tho. Did anyone get this in a real interview?"
                    },
                    {
                        "username": "misteltoe",
                        "content": "I\\'ve got in OA of Goldman Sachs"
                    },
                    {
                        "username": "bo29",
                        "content": "The problem is hard, but our lives are even harder.\\n\\n`If the world will become fully infected, return the number of walls used.` Well, I guess no matter how many walls built, the world\\'s been fully infected anyway..."
                    },
                    {
                        "username": "ryx",
                        "content": "Given the input\\n0 0 1\\n0 1 0\\n1 0 0\\n\\nThe center region will be quarantined, and the other two virus spread. It becomes\\n0 1 1\\n1 1 1\\n1 1 0\\n\\nNow, how many regions there? one or two?\\n\\nThanks"
                    },
                    {
                        "username": "Finesse",
                        "content": "3. Walls split the regions."
                    },
                    {
                        "username": "cshshshzx",
                        "content": "This is what I saw during the contest, spent lots of time figuring out the logic (guess it's 11 because we can't overlap the walls)\\n![0_1513484232399_c05b43a5-4a61-4df3-9975-f1b482747be5-image.png](/assets/uploads/files/1513484236548-c05b43a5-4a61-4df3-9975-f1b482747be5-image.png) \\nBut by the time I submitted my answer, it was wrong!\\n![0_1513484327878_p1.PNG](/assets/uploads/files/1513484332132-p1-resized.png) \\nWhen I refreshed the page, this was the example answer now.\\n![0_1513484395895_7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image.png](/assets/uploads/files/1513484400071-7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image-resized.png)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "And Corona Virus took it seriously"
                    },
                    {
                        "username": "kaishen2",
                        "content": "![image](https://assets.leetcode.com/users/images/104545f1-7f7d-4bf6-af6a-2635ab0ab4ca_1600144394.7455535.png)\\n![image](https://assets.leetcode.com/users/images/68b94f38-7de5-4ac1-ab3a-d047c659d10c_1600144404.1627324.png)\\n"
                    },
                    {
                        "username": "JackyD",
                        "content": "If at the end one cell survived, can I call it the day is saved? Or the target is to save the most cells? Save ten or save one, there will be different costs. The requirement is so vague."
                    },
                    {
                        "username": "schwarzkatze",
                        "content": "[[0,1,0,1,1,1,1,1,1,0],\\n[0,0,0,1,0,0,0,0,0,0],\\n[0,0,1,1,1,0,0,0,1,0],\\n[0,0,0,1,1,0,0,1,1,0],\\n[0,1,0,0,1,0,1,1,0,1],\\n[0,0,0,1,0,1,0,1,1,1],\\n[0,1,0,0,1,0,0,1,1,0],\\n[0,1,0,1,0,0,0,1,1,0],\\n[0,1,1,0,0,1,1,0,0,1],\\n[1,0,1,1,0,1,0,1,0,1]]"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "[@guddukumar0709](/guddukumar0709) Same problem "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Here logic is to check maximum zero related to infected area\\nand then use wall to cover that area"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "can someone explain this example \\nI am getting answer 40 but expected answer is 38\\n\\nAm I missing something in this test case??"
                    },
                    {
                        "username": "alfredzj",
                        "content": "Just cuirous why we need stick to the steps provided by the solution? Is it a greedy algorithm? If so, how we make sure the result we get is the optimal one?"
                    },
                    {
                        "username": "jordandong",
                        "content": "I am very confused about this question.\\nInput: grid = \\n[[1,1,1,0,0,0,0,0,0],\\n [1,0,1,0,1,1,1,1,1],\\n [1,1,1,0,0,0,0,0,0]]\\nOutput: 13\\nExplanation: The region on the left only builds two new walls.\\n\\nit should be 12, the 0 at (1, 3) will be always infected. \\n\\nwe build 10 walls(up and down, left is not needed) for the region on the right, after one night it becomes:\\n111100000\\n111111111\\n111100000\\nthe second day, build 2 walls is enough.\\n\\nTotal is 10  + 2 = 12"
                    },
                    {
                        "username": "lak1973",
                        "content": "Actually it should be 11 the region on the left  will build 4 walls for the inner zero and three walls to its right  total 7 and on day 2 only 4 walls will be needed to stop the virus "
                    }
                ]
            },
            {
                "id": 1567285,
                "content": [
                    {
                        "username": "IWantToPass",
                        "content": "I feel like because of the sheer volume of code to write as well as determining how to implement in a simple way this is a little hard to do within one interview, jmo tho. Did anyone get this in a real interview?"
                    },
                    {
                        "username": "misteltoe",
                        "content": "I\\'ve got in OA of Goldman Sachs"
                    },
                    {
                        "username": "bo29",
                        "content": "The problem is hard, but our lives are even harder.\\n\\n`If the world will become fully infected, return the number of walls used.` Well, I guess no matter how many walls built, the world\\'s been fully infected anyway..."
                    },
                    {
                        "username": "ryx",
                        "content": "Given the input\\n0 0 1\\n0 1 0\\n1 0 0\\n\\nThe center region will be quarantined, and the other two virus spread. It becomes\\n0 1 1\\n1 1 1\\n1 1 0\\n\\nNow, how many regions there? one or two?\\n\\nThanks"
                    },
                    {
                        "username": "Finesse",
                        "content": "3. Walls split the regions."
                    },
                    {
                        "username": "cshshshzx",
                        "content": "This is what I saw during the contest, spent lots of time figuring out the logic (guess it's 11 because we can't overlap the walls)\\n![0_1513484232399_c05b43a5-4a61-4df3-9975-f1b482747be5-image.png](/assets/uploads/files/1513484236548-c05b43a5-4a61-4df3-9975-f1b482747be5-image.png) \\nBut by the time I submitted my answer, it was wrong!\\n![0_1513484327878_p1.PNG](/assets/uploads/files/1513484332132-p1-resized.png) \\nWhen I refreshed the page, this was the example answer now.\\n![0_1513484395895_7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image.png](/assets/uploads/files/1513484400071-7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image-resized.png)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "And Corona Virus took it seriously"
                    },
                    {
                        "username": "kaishen2",
                        "content": "![image](https://assets.leetcode.com/users/images/104545f1-7f7d-4bf6-af6a-2635ab0ab4ca_1600144394.7455535.png)\\n![image](https://assets.leetcode.com/users/images/68b94f38-7de5-4ac1-ab3a-d047c659d10c_1600144404.1627324.png)\\n"
                    },
                    {
                        "username": "JackyD",
                        "content": "If at the end one cell survived, can I call it the day is saved? Or the target is to save the most cells? Save ten or save one, there will be different costs. The requirement is so vague."
                    },
                    {
                        "username": "schwarzkatze",
                        "content": "[[0,1,0,1,1,1,1,1,1,0],\\n[0,0,0,1,0,0,0,0,0,0],\\n[0,0,1,1,1,0,0,0,1,0],\\n[0,0,0,1,1,0,0,1,1,0],\\n[0,1,0,0,1,0,1,1,0,1],\\n[0,0,0,1,0,1,0,1,1,1],\\n[0,1,0,0,1,0,0,1,1,0],\\n[0,1,0,1,0,0,0,1,1,0],\\n[0,1,1,0,0,1,1,0,0,1],\\n[1,0,1,1,0,1,0,1,0,1]]"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "[@guddukumar0709](/guddukumar0709) Same problem "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Here logic is to check maximum zero related to infected area\\nand then use wall to cover that area"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "can someone explain this example \\nI am getting answer 40 but expected answer is 38\\n\\nAm I missing something in this test case??"
                    },
                    {
                        "username": "alfredzj",
                        "content": "Just cuirous why we need stick to the steps provided by the solution? Is it a greedy algorithm? If so, how we make sure the result we get is the optimal one?"
                    },
                    {
                        "username": "jordandong",
                        "content": "I am very confused about this question.\\nInput: grid = \\n[[1,1,1,0,0,0,0,0,0],\\n [1,0,1,0,1,1,1,1,1],\\n [1,1,1,0,0,0,0,0,0]]\\nOutput: 13\\nExplanation: The region on the left only builds two new walls.\\n\\nit should be 12, the 0 at (1, 3) will be always infected. \\n\\nwe build 10 walls(up and down, left is not needed) for the region on the right, after one night it becomes:\\n111100000\\n111111111\\n111100000\\nthe second day, build 2 walls is enough.\\n\\nTotal is 10  + 2 = 12"
                    },
                    {
                        "username": "lak1973",
                        "content": "Actually it should be 11 the region on the left  will build 4 walls for the inner zero and three walls to its right  total 7 and on day 2 only 4 walls will be needed to stop the virus "
                    }
                ]
            },
            {
                "id": 1567284,
                "content": [
                    {
                        "username": "IWantToPass",
                        "content": "I feel like because of the sheer volume of code to write as well as determining how to implement in a simple way this is a little hard to do within one interview, jmo tho. Did anyone get this in a real interview?"
                    },
                    {
                        "username": "misteltoe",
                        "content": "I\\'ve got in OA of Goldman Sachs"
                    },
                    {
                        "username": "bo29",
                        "content": "The problem is hard, but our lives are even harder.\\n\\n`If the world will become fully infected, return the number of walls used.` Well, I guess no matter how many walls built, the world\\'s been fully infected anyway..."
                    },
                    {
                        "username": "ryx",
                        "content": "Given the input\\n0 0 1\\n0 1 0\\n1 0 0\\n\\nThe center region will be quarantined, and the other two virus spread. It becomes\\n0 1 1\\n1 1 1\\n1 1 0\\n\\nNow, how many regions there? one or two?\\n\\nThanks"
                    },
                    {
                        "username": "Finesse",
                        "content": "3. Walls split the regions."
                    },
                    {
                        "username": "cshshshzx",
                        "content": "This is what I saw during the contest, spent lots of time figuring out the logic (guess it's 11 because we can't overlap the walls)\\n![0_1513484232399_c05b43a5-4a61-4df3-9975-f1b482747be5-image.png](/assets/uploads/files/1513484236548-c05b43a5-4a61-4df3-9975-f1b482747be5-image.png) \\nBut by the time I submitted my answer, it was wrong!\\n![0_1513484327878_p1.PNG](/assets/uploads/files/1513484332132-p1-resized.png) \\nWhen I refreshed the page, this was the example answer now.\\n![0_1513484395895_7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image.png](/assets/uploads/files/1513484400071-7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image-resized.png)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "And Corona Virus took it seriously"
                    },
                    {
                        "username": "kaishen2",
                        "content": "![image](https://assets.leetcode.com/users/images/104545f1-7f7d-4bf6-af6a-2635ab0ab4ca_1600144394.7455535.png)\\n![image](https://assets.leetcode.com/users/images/68b94f38-7de5-4ac1-ab3a-d047c659d10c_1600144404.1627324.png)\\n"
                    },
                    {
                        "username": "JackyD",
                        "content": "If at the end one cell survived, can I call it the day is saved? Or the target is to save the most cells? Save ten or save one, there will be different costs. The requirement is so vague."
                    },
                    {
                        "username": "schwarzkatze",
                        "content": "[[0,1,0,1,1,1,1,1,1,0],\\n[0,0,0,1,0,0,0,0,0,0],\\n[0,0,1,1,1,0,0,0,1,0],\\n[0,0,0,1,1,0,0,1,1,0],\\n[0,1,0,0,1,0,1,1,0,1],\\n[0,0,0,1,0,1,0,1,1,1],\\n[0,1,0,0,1,0,0,1,1,0],\\n[0,1,0,1,0,0,0,1,1,0],\\n[0,1,1,0,0,1,1,0,0,1],\\n[1,0,1,1,0,1,0,1,0,1]]"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "[@guddukumar0709](/guddukumar0709) Same problem "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Here logic is to check maximum zero related to infected area\\nand then use wall to cover that area"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "can someone explain this example \\nI am getting answer 40 but expected answer is 38\\n\\nAm I missing something in this test case??"
                    },
                    {
                        "username": "alfredzj",
                        "content": "Just cuirous why we need stick to the steps provided by the solution? Is it a greedy algorithm? If so, how we make sure the result we get is the optimal one?"
                    },
                    {
                        "username": "jordandong",
                        "content": "I am very confused about this question.\\nInput: grid = \\n[[1,1,1,0,0,0,0,0,0],\\n [1,0,1,0,1,1,1,1,1],\\n [1,1,1,0,0,0,0,0,0]]\\nOutput: 13\\nExplanation: The region on the left only builds two new walls.\\n\\nit should be 12, the 0 at (1, 3) will be always infected. \\n\\nwe build 10 walls(up and down, left is not needed) for the region on the right, after one night it becomes:\\n111100000\\n111111111\\n111100000\\nthe second day, build 2 walls is enough.\\n\\nTotal is 10  + 2 = 12"
                    },
                    {
                        "username": "lak1973",
                        "content": "Actually it should be 11 the region on the left  will build 4 walls for the inner zero and three walls to its right  total 7 and on day 2 only 4 walls will be needed to stop the virus "
                    }
                ]
            },
            {
                "id": 1815372,
                "content": [
                    {
                        "username": "IWantToPass",
                        "content": "I feel like because of the sheer volume of code to write as well as determining how to implement in a simple way this is a little hard to do within one interview, jmo tho. Did anyone get this in a real interview?"
                    },
                    {
                        "username": "misteltoe",
                        "content": "I\\'ve got in OA of Goldman Sachs"
                    },
                    {
                        "username": "bo29",
                        "content": "The problem is hard, but our lives are even harder.\\n\\n`If the world will become fully infected, return the number of walls used.` Well, I guess no matter how many walls built, the world\\'s been fully infected anyway..."
                    },
                    {
                        "username": "ryx",
                        "content": "Given the input\\n0 0 1\\n0 1 0\\n1 0 0\\n\\nThe center region will be quarantined, and the other two virus spread. It becomes\\n0 1 1\\n1 1 1\\n1 1 0\\n\\nNow, how many regions there? one or two?\\n\\nThanks"
                    },
                    {
                        "username": "Finesse",
                        "content": "3. Walls split the regions."
                    },
                    {
                        "username": "cshshshzx",
                        "content": "This is what I saw during the contest, spent lots of time figuring out the logic (guess it's 11 because we can't overlap the walls)\\n![0_1513484232399_c05b43a5-4a61-4df3-9975-f1b482747be5-image.png](/assets/uploads/files/1513484236548-c05b43a5-4a61-4df3-9975-f1b482747be5-image.png) \\nBut by the time I submitted my answer, it was wrong!\\n![0_1513484327878_p1.PNG](/assets/uploads/files/1513484332132-p1-resized.png) \\nWhen I refreshed the page, this was the example answer now.\\n![0_1513484395895_7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image.png](/assets/uploads/files/1513484400071-7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image-resized.png)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "And Corona Virus took it seriously"
                    },
                    {
                        "username": "kaishen2",
                        "content": "![image](https://assets.leetcode.com/users/images/104545f1-7f7d-4bf6-af6a-2635ab0ab4ca_1600144394.7455535.png)\\n![image](https://assets.leetcode.com/users/images/68b94f38-7de5-4ac1-ab3a-d047c659d10c_1600144404.1627324.png)\\n"
                    },
                    {
                        "username": "JackyD",
                        "content": "If at the end one cell survived, can I call it the day is saved? Or the target is to save the most cells? Save ten or save one, there will be different costs. The requirement is so vague."
                    },
                    {
                        "username": "schwarzkatze",
                        "content": "[[0,1,0,1,1,1,1,1,1,0],\\n[0,0,0,1,0,0,0,0,0,0],\\n[0,0,1,1,1,0,0,0,1,0],\\n[0,0,0,1,1,0,0,1,1,0],\\n[0,1,0,0,1,0,1,1,0,1],\\n[0,0,0,1,0,1,0,1,1,1],\\n[0,1,0,0,1,0,0,1,1,0],\\n[0,1,0,1,0,0,0,1,1,0],\\n[0,1,1,0,0,1,1,0,0,1],\\n[1,0,1,1,0,1,0,1,0,1]]"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "[@guddukumar0709](/guddukumar0709) Same problem "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Here logic is to check maximum zero related to infected area\\nand then use wall to cover that area"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "can someone explain this example \\nI am getting answer 40 but expected answer is 38\\n\\nAm I missing something in this test case??"
                    },
                    {
                        "username": "alfredzj",
                        "content": "Just cuirous why we need stick to the steps provided by the solution? Is it a greedy algorithm? If so, how we make sure the result we get is the optimal one?"
                    },
                    {
                        "username": "jordandong",
                        "content": "I am very confused about this question.\\nInput: grid = \\n[[1,1,1,0,0,0,0,0,0],\\n [1,0,1,0,1,1,1,1,1],\\n [1,1,1,0,0,0,0,0,0]]\\nOutput: 13\\nExplanation: The region on the left only builds two new walls.\\n\\nit should be 12, the 0 at (1, 3) will be always infected. \\n\\nwe build 10 walls(up and down, left is not needed) for the region on the right, after one night it becomes:\\n111100000\\n111111111\\n111100000\\nthe second day, build 2 walls is enough.\\n\\nTotal is 10  + 2 = 12"
                    },
                    {
                        "username": "lak1973",
                        "content": "Actually it should be 11 the region on the left  will build 4 walls for the inner zero and three walls to its right  total 7 and on day 2 only 4 walls will be needed to stop the virus "
                    }
                ]
            },
            {
                "id": 1568446,
                "content": [
                    {
                        "username": "IWantToPass",
                        "content": "I feel like because of the sheer volume of code to write as well as determining how to implement in a simple way this is a little hard to do within one interview, jmo tho. Did anyone get this in a real interview?"
                    },
                    {
                        "username": "misteltoe",
                        "content": "I\\'ve got in OA of Goldman Sachs"
                    },
                    {
                        "username": "bo29",
                        "content": "The problem is hard, but our lives are even harder.\\n\\n`If the world will become fully infected, return the number of walls used.` Well, I guess no matter how many walls built, the world\\'s been fully infected anyway..."
                    },
                    {
                        "username": "ryx",
                        "content": "Given the input\\n0 0 1\\n0 1 0\\n1 0 0\\n\\nThe center region will be quarantined, and the other two virus spread. It becomes\\n0 1 1\\n1 1 1\\n1 1 0\\n\\nNow, how many regions there? one or two?\\n\\nThanks"
                    },
                    {
                        "username": "Finesse",
                        "content": "3. Walls split the regions."
                    },
                    {
                        "username": "cshshshzx",
                        "content": "This is what I saw during the contest, spent lots of time figuring out the logic (guess it's 11 because we can't overlap the walls)\\n![0_1513484232399_c05b43a5-4a61-4df3-9975-f1b482747be5-image.png](/assets/uploads/files/1513484236548-c05b43a5-4a61-4df3-9975-f1b482747be5-image.png) \\nBut by the time I submitted my answer, it was wrong!\\n![0_1513484327878_p1.PNG](/assets/uploads/files/1513484332132-p1-resized.png) \\nWhen I refreshed the page, this was the example answer now.\\n![0_1513484395895_7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image.png](/assets/uploads/files/1513484400071-7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image-resized.png)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "And Corona Virus took it seriously"
                    },
                    {
                        "username": "kaishen2",
                        "content": "![image](https://assets.leetcode.com/users/images/104545f1-7f7d-4bf6-af6a-2635ab0ab4ca_1600144394.7455535.png)\\n![image](https://assets.leetcode.com/users/images/68b94f38-7de5-4ac1-ab3a-d047c659d10c_1600144404.1627324.png)\\n"
                    },
                    {
                        "username": "JackyD",
                        "content": "If at the end one cell survived, can I call it the day is saved? Or the target is to save the most cells? Save ten or save one, there will be different costs. The requirement is so vague."
                    },
                    {
                        "username": "schwarzkatze",
                        "content": "[[0,1,0,1,1,1,1,1,1,0],\\n[0,0,0,1,0,0,0,0,0,0],\\n[0,0,1,1,1,0,0,0,1,0],\\n[0,0,0,1,1,0,0,1,1,0],\\n[0,1,0,0,1,0,1,1,0,1],\\n[0,0,0,1,0,1,0,1,1,1],\\n[0,1,0,0,1,0,0,1,1,0],\\n[0,1,0,1,0,0,0,1,1,0],\\n[0,1,1,0,0,1,1,0,0,1],\\n[1,0,1,1,0,1,0,1,0,1]]"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "[@guddukumar0709](/guddukumar0709) Same problem "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Here logic is to check maximum zero related to infected area\\nand then use wall to cover that area"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "can someone explain this example \\nI am getting answer 40 but expected answer is 38\\n\\nAm I missing something in this test case??"
                    },
                    {
                        "username": "alfredzj",
                        "content": "Just cuirous why we need stick to the steps provided by the solution? Is it a greedy algorithm? If so, how we make sure the result we get is the optimal one?"
                    },
                    {
                        "username": "jordandong",
                        "content": "I am very confused about this question.\\nInput: grid = \\n[[1,1,1,0,0,0,0,0,0],\\n [1,0,1,0,1,1,1,1,1],\\n [1,1,1,0,0,0,0,0,0]]\\nOutput: 13\\nExplanation: The region on the left only builds two new walls.\\n\\nit should be 12, the 0 at (1, 3) will be always infected. \\n\\nwe build 10 walls(up and down, left is not needed) for the region on the right, after one night it becomes:\\n111100000\\n111111111\\n111100000\\nthe second day, build 2 walls is enough.\\n\\nTotal is 10  + 2 = 12"
                    },
                    {
                        "username": "lak1973",
                        "content": "Actually it should be 11 the region on the left  will build 4 walls for the inner zero and three walls to its right  total 7 and on day 2 only 4 walls will be needed to stop the virus "
                    }
                ]
            },
            {
                "id": 1573462,
                "content": [
                    {
                        "username": "IWantToPass",
                        "content": "I feel like because of the sheer volume of code to write as well as determining how to implement in a simple way this is a little hard to do within one interview, jmo tho. Did anyone get this in a real interview?"
                    },
                    {
                        "username": "misteltoe",
                        "content": "I\\'ve got in OA of Goldman Sachs"
                    },
                    {
                        "username": "bo29",
                        "content": "The problem is hard, but our lives are even harder.\\n\\n`If the world will become fully infected, return the number of walls used.` Well, I guess no matter how many walls built, the world\\'s been fully infected anyway..."
                    },
                    {
                        "username": "ryx",
                        "content": "Given the input\\n0 0 1\\n0 1 0\\n1 0 0\\n\\nThe center region will be quarantined, and the other two virus spread. It becomes\\n0 1 1\\n1 1 1\\n1 1 0\\n\\nNow, how many regions there? one or two?\\n\\nThanks"
                    },
                    {
                        "username": "Finesse",
                        "content": "3. Walls split the regions."
                    },
                    {
                        "username": "cshshshzx",
                        "content": "This is what I saw during the contest, spent lots of time figuring out the logic (guess it's 11 because we can't overlap the walls)\\n![0_1513484232399_c05b43a5-4a61-4df3-9975-f1b482747be5-image.png](/assets/uploads/files/1513484236548-c05b43a5-4a61-4df3-9975-f1b482747be5-image.png) \\nBut by the time I submitted my answer, it was wrong!\\n![0_1513484327878_p1.PNG](/assets/uploads/files/1513484332132-p1-resized.png) \\nWhen I refreshed the page, this was the example answer now.\\n![0_1513484395895_7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image.png](/assets/uploads/files/1513484400071-7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image-resized.png)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "And Corona Virus took it seriously"
                    },
                    {
                        "username": "kaishen2",
                        "content": "![image](https://assets.leetcode.com/users/images/104545f1-7f7d-4bf6-af6a-2635ab0ab4ca_1600144394.7455535.png)\\n![image](https://assets.leetcode.com/users/images/68b94f38-7de5-4ac1-ab3a-d047c659d10c_1600144404.1627324.png)\\n"
                    },
                    {
                        "username": "JackyD",
                        "content": "If at the end one cell survived, can I call it the day is saved? Or the target is to save the most cells? Save ten or save one, there will be different costs. The requirement is so vague."
                    },
                    {
                        "username": "schwarzkatze",
                        "content": "[[0,1,0,1,1,1,1,1,1,0],\\n[0,0,0,1,0,0,0,0,0,0],\\n[0,0,1,1,1,0,0,0,1,0],\\n[0,0,0,1,1,0,0,1,1,0],\\n[0,1,0,0,1,0,1,1,0,1],\\n[0,0,0,1,0,1,0,1,1,1],\\n[0,1,0,0,1,0,0,1,1,0],\\n[0,1,0,1,0,0,0,1,1,0],\\n[0,1,1,0,0,1,1,0,0,1],\\n[1,0,1,1,0,1,0,1,0,1]]"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "[@guddukumar0709](/guddukumar0709) Same problem "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Here logic is to check maximum zero related to infected area\\nand then use wall to cover that area"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "can someone explain this example \\nI am getting answer 40 but expected answer is 38\\n\\nAm I missing something in this test case??"
                    },
                    {
                        "username": "alfredzj",
                        "content": "Just cuirous why we need stick to the steps provided by the solution? Is it a greedy algorithm? If so, how we make sure the result we get is the optimal one?"
                    },
                    {
                        "username": "jordandong",
                        "content": "I am very confused about this question.\\nInput: grid = \\n[[1,1,1,0,0,0,0,0,0],\\n [1,0,1,0,1,1,1,1,1],\\n [1,1,1,0,0,0,0,0,0]]\\nOutput: 13\\nExplanation: The region on the left only builds two new walls.\\n\\nit should be 12, the 0 at (1, 3) will be always infected. \\n\\nwe build 10 walls(up and down, left is not needed) for the region on the right, after one night it becomes:\\n111100000\\n111111111\\n111100000\\nthe second day, build 2 walls is enough.\\n\\nTotal is 10  + 2 = 12"
                    },
                    {
                        "username": "lak1973",
                        "content": "Actually it should be 11 the region on the left  will build 4 walls for the inner zero and three walls to its right  total 7 and on day 2 only 4 walls will be needed to stop the virus "
                    }
                ]
            },
            {
                "id": 1569160,
                "content": [
                    {
                        "username": "IWantToPass",
                        "content": "I feel like because of the sheer volume of code to write as well as determining how to implement in a simple way this is a little hard to do within one interview, jmo tho. Did anyone get this in a real interview?"
                    },
                    {
                        "username": "misteltoe",
                        "content": "I\\'ve got in OA of Goldman Sachs"
                    },
                    {
                        "username": "bo29",
                        "content": "The problem is hard, but our lives are even harder.\\n\\n`If the world will become fully infected, return the number of walls used.` Well, I guess no matter how many walls built, the world\\'s been fully infected anyway..."
                    },
                    {
                        "username": "ryx",
                        "content": "Given the input\\n0 0 1\\n0 1 0\\n1 0 0\\n\\nThe center region will be quarantined, and the other two virus spread. It becomes\\n0 1 1\\n1 1 1\\n1 1 0\\n\\nNow, how many regions there? one or two?\\n\\nThanks"
                    },
                    {
                        "username": "Finesse",
                        "content": "3. Walls split the regions."
                    },
                    {
                        "username": "cshshshzx",
                        "content": "This is what I saw during the contest, spent lots of time figuring out the logic (guess it's 11 because we can't overlap the walls)\\n![0_1513484232399_c05b43a5-4a61-4df3-9975-f1b482747be5-image.png](/assets/uploads/files/1513484236548-c05b43a5-4a61-4df3-9975-f1b482747be5-image.png) \\nBut by the time I submitted my answer, it was wrong!\\n![0_1513484327878_p1.PNG](/assets/uploads/files/1513484332132-p1-resized.png) \\nWhen I refreshed the page, this was the example answer now.\\n![0_1513484395895_7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image.png](/assets/uploads/files/1513484400071-7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image-resized.png)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "And Corona Virus took it seriously"
                    },
                    {
                        "username": "kaishen2",
                        "content": "![image](https://assets.leetcode.com/users/images/104545f1-7f7d-4bf6-af6a-2635ab0ab4ca_1600144394.7455535.png)\\n![image](https://assets.leetcode.com/users/images/68b94f38-7de5-4ac1-ab3a-d047c659d10c_1600144404.1627324.png)\\n"
                    },
                    {
                        "username": "JackyD",
                        "content": "If at the end one cell survived, can I call it the day is saved? Or the target is to save the most cells? Save ten or save one, there will be different costs. The requirement is so vague."
                    },
                    {
                        "username": "schwarzkatze",
                        "content": "[[0,1,0,1,1,1,1,1,1,0],\\n[0,0,0,1,0,0,0,0,0,0],\\n[0,0,1,1,1,0,0,0,1,0],\\n[0,0,0,1,1,0,0,1,1,0],\\n[0,1,0,0,1,0,1,1,0,1],\\n[0,0,0,1,0,1,0,1,1,1],\\n[0,1,0,0,1,0,0,1,1,0],\\n[0,1,0,1,0,0,0,1,1,0],\\n[0,1,1,0,0,1,1,0,0,1],\\n[1,0,1,1,0,1,0,1,0,1]]"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "[@guddukumar0709](/guddukumar0709) Same problem "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Here logic is to check maximum zero related to infected area\\nand then use wall to cover that area"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "can someone explain this example \\nI am getting answer 40 but expected answer is 38\\n\\nAm I missing something in this test case??"
                    },
                    {
                        "username": "alfredzj",
                        "content": "Just cuirous why we need stick to the steps provided by the solution? Is it a greedy algorithm? If so, how we make sure the result we get is the optimal one?"
                    },
                    {
                        "username": "jordandong",
                        "content": "I am very confused about this question.\\nInput: grid = \\n[[1,1,1,0,0,0,0,0,0],\\n [1,0,1,0,1,1,1,1,1],\\n [1,1,1,0,0,0,0,0,0]]\\nOutput: 13\\nExplanation: The region on the left only builds two new walls.\\n\\nit should be 12, the 0 at (1, 3) will be always infected. \\n\\nwe build 10 walls(up and down, left is not needed) for the region on the right, after one night it becomes:\\n111100000\\n111111111\\n111100000\\nthe second day, build 2 walls is enough.\\n\\nTotal is 10  + 2 = 12"
                    },
                    {
                        "username": "lak1973",
                        "content": "Actually it should be 11 the region on the left  will build 4 walls for the inner zero and three walls to its right  total 7 and on day 2 only 4 walls will be needed to stop the virus "
                    }
                ]
            },
            {
                "id": 1574676,
                "content": [
                    {
                        "username": "IWantToPass",
                        "content": "I feel like because of the sheer volume of code to write as well as determining how to implement in a simple way this is a little hard to do within one interview, jmo tho. Did anyone get this in a real interview?"
                    },
                    {
                        "username": "misteltoe",
                        "content": "I\\'ve got in OA of Goldman Sachs"
                    },
                    {
                        "username": "bo29",
                        "content": "The problem is hard, but our lives are even harder.\\n\\n`If the world will become fully infected, return the number of walls used.` Well, I guess no matter how many walls built, the world\\'s been fully infected anyway..."
                    },
                    {
                        "username": "ryx",
                        "content": "Given the input\\n0 0 1\\n0 1 0\\n1 0 0\\n\\nThe center region will be quarantined, and the other two virus spread. It becomes\\n0 1 1\\n1 1 1\\n1 1 0\\n\\nNow, how many regions there? one or two?\\n\\nThanks"
                    },
                    {
                        "username": "Finesse",
                        "content": "3. Walls split the regions."
                    },
                    {
                        "username": "cshshshzx",
                        "content": "This is what I saw during the contest, spent lots of time figuring out the logic (guess it's 11 because we can't overlap the walls)\\n![0_1513484232399_c05b43a5-4a61-4df3-9975-f1b482747be5-image.png](/assets/uploads/files/1513484236548-c05b43a5-4a61-4df3-9975-f1b482747be5-image.png) \\nBut by the time I submitted my answer, it was wrong!\\n![0_1513484327878_p1.PNG](/assets/uploads/files/1513484332132-p1-resized.png) \\nWhen I refreshed the page, this was the example answer now.\\n![0_1513484395895_7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image.png](/assets/uploads/files/1513484400071-7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image-resized.png)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "And Corona Virus took it seriously"
                    },
                    {
                        "username": "kaishen2",
                        "content": "![image](https://assets.leetcode.com/users/images/104545f1-7f7d-4bf6-af6a-2635ab0ab4ca_1600144394.7455535.png)\\n![image](https://assets.leetcode.com/users/images/68b94f38-7de5-4ac1-ab3a-d047c659d10c_1600144404.1627324.png)\\n"
                    },
                    {
                        "username": "JackyD",
                        "content": "If at the end one cell survived, can I call it the day is saved? Or the target is to save the most cells? Save ten or save one, there will be different costs. The requirement is so vague."
                    },
                    {
                        "username": "schwarzkatze",
                        "content": "[[0,1,0,1,1,1,1,1,1,0],\\n[0,0,0,1,0,0,0,0,0,0],\\n[0,0,1,1,1,0,0,0,1,0],\\n[0,0,0,1,1,0,0,1,1,0],\\n[0,1,0,0,1,0,1,1,0,1],\\n[0,0,0,1,0,1,0,1,1,1],\\n[0,1,0,0,1,0,0,1,1,0],\\n[0,1,0,1,0,0,0,1,1,0],\\n[0,1,1,0,0,1,1,0,0,1],\\n[1,0,1,1,0,1,0,1,0,1]]"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "[@guddukumar0709](/guddukumar0709) Same problem "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Here logic is to check maximum zero related to infected area\\nand then use wall to cover that area"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "can someone explain this example \\nI am getting answer 40 but expected answer is 38\\n\\nAm I missing something in this test case??"
                    },
                    {
                        "username": "alfredzj",
                        "content": "Just cuirous why we need stick to the steps provided by the solution? Is it a greedy algorithm? If so, how we make sure the result we get is the optimal one?"
                    },
                    {
                        "username": "jordandong",
                        "content": "I am very confused about this question.\\nInput: grid = \\n[[1,1,1,0,0,0,0,0,0],\\n [1,0,1,0,1,1,1,1,1],\\n [1,1,1,0,0,0,0,0,0]]\\nOutput: 13\\nExplanation: The region on the left only builds two new walls.\\n\\nit should be 12, the 0 at (1, 3) will be always infected. \\n\\nwe build 10 walls(up and down, left is not needed) for the region on the right, after one night it becomes:\\n111100000\\n111111111\\n111100000\\nthe second day, build 2 walls is enough.\\n\\nTotal is 10  + 2 = 12"
                    },
                    {
                        "username": "lak1973",
                        "content": "Actually it should be 11 the region on the left  will build 4 walls for the inner zero and three walls to its right  total 7 and on day 2 only 4 walls will be needed to stop the virus "
                    }
                ]
            },
            {
                "id": 1571820,
                "content": [
                    {
                        "username": "IWantToPass",
                        "content": "I feel like because of the sheer volume of code to write as well as determining how to implement in a simple way this is a little hard to do within one interview, jmo tho. Did anyone get this in a real interview?"
                    },
                    {
                        "username": "misteltoe",
                        "content": "I\\'ve got in OA of Goldman Sachs"
                    },
                    {
                        "username": "bo29",
                        "content": "The problem is hard, but our lives are even harder.\\n\\n`If the world will become fully infected, return the number of walls used.` Well, I guess no matter how many walls built, the world\\'s been fully infected anyway..."
                    },
                    {
                        "username": "ryx",
                        "content": "Given the input\\n0 0 1\\n0 1 0\\n1 0 0\\n\\nThe center region will be quarantined, and the other two virus spread. It becomes\\n0 1 1\\n1 1 1\\n1 1 0\\n\\nNow, how many regions there? one or two?\\n\\nThanks"
                    },
                    {
                        "username": "Finesse",
                        "content": "3. Walls split the regions."
                    },
                    {
                        "username": "cshshshzx",
                        "content": "This is what I saw during the contest, spent lots of time figuring out the logic (guess it's 11 because we can't overlap the walls)\\n![0_1513484232399_c05b43a5-4a61-4df3-9975-f1b482747be5-image.png](/assets/uploads/files/1513484236548-c05b43a5-4a61-4df3-9975-f1b482747be5-image.png) \\nBut by the time I submitted my answer, it was wrong!\\n![0_1513484327878_p1.PNG](/assets/uploads/files/1513484332132-p1-resized.png) \\nWhen I refreshed the page, this was the example answer now.\\n![0_1513484395895_7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image.png](/assets/uploads/files/1513484400071-7dba4180-d27e-48e8-a0c8-0b3ad89bebc6-image-resized.png)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "And Corona Virus took it seriously"
                    },
                    {
                        "username": "kaishen2",
                        "content": "![image](https://assets.leetcode.com/users/images/104545f1-7f7d-4bf6-af6a-2635ab0ab4ca_1600144394.7455535.png)\\n![image](https://assets.leetcode.com/users/images/68b94f38-7de5-4ac1-ab3a-d047c659d10c_1600144404.1627324.png)\\n"
                    },
                    {
                        "username": "JackyD",
                        "content": "If at the end one cell survived, can I call it the day is saved? Or the target is to save the most cells? Save ten or save one, there will be different costs. The requirement is so vague."
                    },
                    {
                        "username": "schwarzkatze",
                        "content": "[[0,1,0,1,1,1,1,1,1,0],\\n[0,0,0,1,0,0,0,0,0,0],\\n[0,0,1,1,1,0,0,0,1,0],\\n[0,0,0,1,1,0,0,1,1,0],\\n[0,1,0,0,1,0,1,1,0,1],\\n[0,0,0,1,0,1,0,1,1,1],\\n[0,1,0,0,1,0,0,1,1,0],\\n[0,1,0,1,0,0,0,1,1,0],\\n[0,1,1,0,0,1,1,0,0,1],\\n[1,0,1,1,0,1,0,1,0,1]]"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "[@guddukumar0709](/guddukumar0709) Same problem "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Here logic is to check maximum zero related to infected area\\nand then use wall to cover that area"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "can someone explain this example \\nI am getting answer 40 but expected answer is 38\\n\\nAm I missing something in this test case??"
                    },
                    {
                        "username": "alfredzj",
                        "content": "Just cuirous why we need stick to the steps provided by the solution? Is it a greedy algorithm? If so, how we make sure the result we get is the optimal one?"
                    },
                    {
                        "username": "jordandong",
                        "content": "I am very confused about this question.\\nInput: grid = \\n[[1,1,1,0,0,0,0,0,0],\\n [1,0,1,0,1,1,1,1,1],\\n [1,1,1,0,0,0,0,0,0]]\\nOutput: 13\\nExplanation: The region on the left only builds two new walls.\\n\\nit should be 12, the 0 at (1, 3) will be always infected. \\n\\nwe build 10 walls(up and down, left is not needed) for the region on the right, after one night it becomes:\\n111100000\\n111111111\\n111100000\\nthe second day, build 2 walls is enough.\\n\\nTotal is 10  + 2 = 12"
                    },
                    {
                        "username": "lak1973",
                        "content": "Actually it should be 11 the region on the left  will build 4 walls for the inner zero and three walls to its right  total 7 and on day 2 only 4 walls will be needed to stop the virus "
                    }
                ]
            }
        ]
    }
]