[
    {
        "title": "Path In Zigzag Labelled Binary Tree",
        "question_content": "In an infinite binary tree where every node has two children, the nodes are labelled in row order.\nIn the odd numbered rows (ie., the first, third, fifth,...), the labelling is left to right, while in the even numbered rows (second, fourth, sixth,...), the labelling is right to left.\n\nGiven the label of a node in this tree, return the labels in the path from the root of the tree to the&nbsp;node with that label.\n&nbsp;\nExample 1:\n\nInput: label = 14\nOutput: [1,3,4,14]\n\nExample 2:\n\nInput: label = 26\nOutput: [1,2,6,10,26]\n\n&nbsp;\nConstraints:\n\n\t1 <= label <= 10^6",
        "solutions": [
            {
                "id": 324011,
                "title": "python-o-logn-time-and-space-with-readable-code-and-step-by-step-explanation",
                "content": "Step by Step Explanation\\nWith the thought in mind that in an ordered binary tree that goes from 1 to n:\\n```\\nNormally Ordered Binary Tree:\\n             1\\n           /   \\\\\\n         2       3\\n       /  \\\\     /  \\\\\\n     4     5   6     7\\n   / |    /|   |\\\\    | \\\\\\n 8   9  10 11 12 13  14  15\\n```\\nThought 1) You can easily determine the parent by dividing by 2 with a normally ordered (non-zigzag) binary tree\\nFor example the parent of 9 can be calculated via int(9/2) which is 4\\n\\nThought 2) So we now how how to trace from the input `label` to the root node. So lets start with `label` In our example, we will use 14. To determine the parent of 14, notice that in the same spot in a normally ordered binary tree that it is 9. So you just need to calculate how to get from 14 to 9.\\n```\\nZig Zag Binary Tree:\\n             1\\n           /   \\\\\\n         3       2  <- 3+2-3 = 2/2 = 1\\n       /  \\\\     /  \\\\\\n     4     5   6     7   <- 7+4-4 = 7/2 = 3\\n   / |    /|   |\\\\    | \\\\\\n 15 14  13 12 11 10  9  8   <- 15+8-14 = 9/2 = 4\\n```\\ninversion formula: (max number of current level + min number of current level) - current number\\nFor example to find the inversion of 14: 15 + 8 - 14 = 9\\nFrom here you just divide 9 by 2 to find the parent 4\\n\\nThought 3) You have to run the inversion formula at every level because at every level the row is inverted relative to the previous row\\n\\nTime Complexity:\\nO(3 log n). 3 are needed as commented in the code.\\n\\nSpace Complexity:\\nIf including the space required for the return `res` object counts as space then we need\\nO(log n) because we need to store the path from the root to the `label`.\\n\\n```\\nclass Solution:\\n    def pathInZigZagTree(self, label):\\n        res = [] # O(log n) space\\n        node_count = 1\\n        level = 1\\n        # Determine level of the label\\n        while label >= node_count*2: # O(log n) time\\n            node_count *= 2\\n            level += 1\\n        # Iterate from the target label to the root\\n        while label != 0: # O(log n) time\\n            res.append(label)\\n            level_max = 2**(level) - 1\\n            level_min = 2**(level-1)\\n            label = int((level_max + level_min - label)/2)\\n            level -= 1\\n        return res[::-1] # O(n) time\\n```",
                "solutionTags": [],
                "code": "```\\nNormally Ordered Binary Tree:\\n             1\\n           /   \\\\\\n         2       3\\n       /  \\\\     /  \\\\\\n     4     5   6     7\\n   / |    /|   |\\\\    | \\\\\\n 8   9  10 11 12 13  14  15\\n```\n```\\nZig Zag Binary Tree:\\n             1\\n           /   \\\\\\n         3       2  <- 3+2-3 = 2/2 = 1\\n       /  \\\\     /  \\\\\\n     4     5   6     7   <- 7+4-4 = 7/2 = 3\\n   / |    /|   |\\\\    | \\\\\\n 15 14  13 12 11 10  9  8   <- 15+8-14 = 9/2 = 4\\n```\n```\\nclass Solution:\\n    def pathInZigZagTree(self, label):\\n        res = [] # O(log n) space\\n        node_count = 1\\n        level = 1\\n        # Determine level of the label\\n        while label >= node_count*2: # O(log n) time\\n            node_count *= 2\\n            level += 1\\n        # Iterate from the target label to the root\\n        while label != 0: # O(log n) time\\n            res.append(label)\\n            level_max = 2**(level) - 1\\n            level_min = 2**(level-1)\\n            label = int((level_max + level_min - label)/2)\\n            level -= 1\\n        return res[::-1] # O(n) time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323293,
                "title": "invert-labels",
                "content": "#### Intuition\\nIf the tree is numbered left-to-right (not zigzag), the parent\\'s label can be always determined as ```label / 2```. For zigzag, we need to \"invert\" the parent label.\\n\\n#### Simplified Solution\\nThe idea is the same as for the original solution below, but I hope this one is a bit easier to understand. We first build the path from label to the root (by dividing the label by two).\\n\\nThen, we go thougth the path, and invert odd labels.\\n\\n**C++**\\n```cpp\\nvector<int> pathInZigZagTree(int label) {\\n    vector<int> res;\\n    for (; label > 0; label /= 2)\\n        res.push_back(label);\\n    for (int i = res.size() - 1; i >= 0; --i)\\n        if (i % 2 == 1)\\n            res[i] = (1 << (res.size() - i - 1)) * 3 - res[i] - 1;\\n    return vector<int>(rbegin(res), rend(res));\\n}\\n```\\n\\n#### Original Solution\\nDetermine the tree ```level``` where our value is located. The maximum label in the level is ```1 << level - 1```, and minimum is ```1 << (level - 1)```. We will use this fact to \"invert\" the parent label.\\n\\n**C++**\\n```cpp\\nvector<int> pathInZigZagTree(int label, int level = 0) {\\n  while (1 << level <= label) ++level;\\n  vector<int> res(level);\\n  for(; label >= 1; label /= 2, --level) {\\n    res[level - 1] = label;\\n    label = (1 << level) - 1 - label + (1 << (level - 1));\\n  }\\n  return res;\\n}\\n```\\n#### Complexity Analysis\\nRuntime: *O(log n)*\\nMemory: *O(1)* or *O(log n)* if we consider the memory required for the result.",
                "solutionTags": [
                    "C"
                ],
                "code": "```label / 2```\n```cpp\\nvector<int> pathInZigZagTree(int label) {\\n    vector<int> res;\\n    for (; label > 0; label /= 2)\\n        res.push_back(label);\\n    for (int i = res.size() - 1; i >= 0; --i)\\n        if (i % 2 == 1)\\n            res[i] = (1 << (res.size() - i - 1)) * 3 - res[i] - 1;\\n    return vector<int>(rbegin(res), rend(res));\\n}\\n```\n```level```\n```1 << level - 1```\n```1 << (level - 1)```\n```cpp\\nvector<int> pathInZigZagTree(int label, int level = 0) {\\n  while (1 << level <= label) ++level;\\n  vector<int> res(level);\\n  for(; label >= 1; label /= 2, --level) {\\n    res[level - 1] = label;\\n    label = (1 << level) - 1 - label + (1 << (level - 1));\\n  }\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 323312,
                "title": "simple-solution-in-java-using-properties-of-complete-binary-tree-o-log-n",
                "content": "1) Calculate current depth of the label\\n2) Calculate offset (for each depth, values lie from 2^d -> 2^(d+1) -1\\n3) Find the real parent based on offset\\n4) Repeat until we reach 1\\n\\ne.g. parent of 14 is 4\\n1) depth = 3, values in this depth lie from 8 to 15 (since it is a complete binary tree)\\n2) offset = 15 - 14 = 1\\n3) real parent of 14 = parent of ( 8 + offset ) = parent (9) = 9/2 = 4\\n\\n```\\npublic List<Integer> pathInZigZagTree(int label) {\\n        LinkedList<Integer> result = new LinkedList<>();\\n        int parent = label;\\n        result.addFirst(parent);\\n\\n        while(parent != 1) {\\n            int d = (int)(Math.log(parent)/Math.log(2));\\n            int offset = (int)Math.pow(2, d+1) - 1 - parent;\\n            parent = ((int)Math.pow(2, d) + offset) / 2;\\n            result.addFirst(parent);   \\n        }\\n        \\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> pathInZigZagTree(int label) {\\n        LinkedList<Integer> result = new LinkedList<>();\\n        int parent = label;\\n        result.addFirst(parent);\\n\\n        while(parent != 1) {\\n            int d = (int)(Math.log(parent)/Math.log(2));\\n            int offset = (int)Math.pow(2, d+1) - 1 - parent;\\n            parent = ((int)Math.pow(2, d) + offset) / 2;\\n            result.addFirst(parent);   \\n        }\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 323462,
                "title": "c-o-log-n-solution-with-comments",
                "content": "C++ O(log n) Solution with comments\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> result;\\n        result.push_back(label); //taking bottom up approach, so the label itself must be included \\n        int height=log2(label); //height of label from root\\n        \\n        while(height!=0){\\n            int left=pow(2,height-1); // rank of left limit of the previous level \\n            int right=pow(2,height)-1;// rank of right limit of the previous level\\n            label=left+(right-label/2);// The previous level is sorted in different order than current one.\\n                                       //So the new label is adjusted accordingly\\n            result.push_back(label);  //newly found label is appened to result\\n            height--;\\n        }\\n        \\n        reverse(result.begin(),result.end()); //required top to down, so the array is reversed. \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> result;\\n        result.push_back(label); //taking bottom up approach, so the label itself must be included \\n        int height=log2(label); //height of label from root\\n        \\n        while(height!=0){\\n            int left=pow(2,height-1); // rank of left limit of the previous level \\n            int right=pow(2,height)-1;// rank of right limit of the previous level\\n            label=left+(right-label/2);// The previous level is sorted in different order than current one.\\n                                       //So the new label is adjusted accordingly\\n            result.push_back(label);  //newly found label is appened to result\\n            height--;\\n        }\\n        \\n        reverse(result.begin(),result.end()); //required top to down, so the array is reversed. \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323286,
                "title": "if-this-question-is-easy-than-why-2-3-of-participants-cannot-solve-it",
                "content": "If this question is `Easy` than why 2/3 of participants (including me) cannot solve it?",
                "solutionTags": [],
                "code": "If this question is `Easy` than why 2/3 of participants (including me) cannot solve it?",
                "codeTag": "Unknown"
            },
            {
                "id": 323310,
                "title": "python-1-line-solution",
                "content": "In the same line, the biggest = smallest * 2  - 1, which leads to the factor 3.\\nAnd also, each parent is the half of their children, which leads to the pow of 2.\\n\\n**Python:**\\n```\\n    def pathInZigZagTree(self, x):\\n        return self.pathInZigZagTree(3 * 2 ** (len(bin(x)) - 4) - 1 - x / 2) + [x] if x > 1 else [1]\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def pathInZigZagTree(self, x):\\n        return self.pathInZigZagTree(3 * 2 ** (len(bin(x)) - 4) - 1 - x / 2) + [x] if x > 1 else [1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 327870,
                "title": "java-solution-with-detailed-explanation",
                "content": "\\nHere in my solution, the depth and position are both 0 indexed.\\nFor the first number on level n, there are total 2 ^ n before it.\\n\\n\\tdepth = 0   |                            1\\n\\tdepth = 1   |                 3                     2\\n\\t...\\n\\tdepth = n   |    2^ n-1, ....                     2^n-k/2-1....\\n\\t\\t\\t\\t\\t  /\\t    \\\\\\t\\t\\t\\t\\t\\t   /   \\\\\\n\\tdepth = n+1 | 2^n,     2^n+1, ....           2^n+k, 2^n+(k+1)....\\nWe first get the current depth and position of the given number, then deduct (pos + 1)  from the label which will get last number on the upper level. For example from the image, the current position of 14 is depth=3 and pos=6. We deduct 7 get 7. The next thing is to find the postion of its parent, which is pos / 2. For example, 14 position is 6, the position of its parent (4) is 3.\\nIn this way, we get all the numbers. The time complexity is O(lgn)\\n![image](https://assets.leetcode.com/users/shield_david/image_1562351879.png)\\n\\n```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> result = new LinkedList<>();\\n        if(label <= 0)\\n            return result;\\n        int level = 0;\\n        while(Math.pow(2, level) - 1 < label)   level++;        \\n        level--; // calculate the depth, 0 indexed, 0 is odd\\n        while(level != 0) {\\n            result.add(0, label);\\n            int pos = label - (int) Math.pow(2, level); // calculate the position, 0 indexed  \\n            label = label - (pos + 1) - pos / 2;\\n            level--;\\n        }\\n        result.add(0, 1);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> result = new LinkedList<>();\\n        if(label <= 0)\\n            return result;\\n        int level = 0;\\n        while(Math.pow(2, level) - 1 < label)   level++;        \\n        level--; // calculate the depth, 0 indexed, 0 is odd\\n        while(level != 0) {\\n            result.add(0, label);\\n            int pos = label - (int) Math.pow(2, level); // calculate the position, 0 indexed  \\n            label = label - (pos + 1) - pos / 2;\\n            level--;\\n        }\\n        result.add(0, 1);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 860872,
                "title": "c-o-logn-solution-bottom-up",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Path In Zigzag Labelled Binary Tree.\\nMemory Usage: 6.5 MB, less than 29.20% of C++ online submissions for Path In Zigzag Labelled Binary Tree..\\n.\\n.\\n![image](https://assets.leetcode.com/users/images/88917ec1-bdf8-4d78-b360-8d7a3a897fcf_1600876038.6600647.png)\\n\\n\\n```\\nWe find the labels starting from given label in bottom to top order\\nFirst we find the depth of the current label as : depth = log2(label)\\nThe parent label (next label) of  the current label will be label/2 in non zigzag binary tree\\nAs the given tree is zigzag labeled no labels will have their original parent label which is label/2 except depth 1 labels, root has depth 0.\\n    \\nSo, we find the parent label (next label) of the current label in zigzag tree as:\\n\\nparent label = previous depth first element + (previous depth last element - next label in non zigzag tree)\\nprevious depth first element : 2^ (depth-1)\\nprevious depth last element : 2^ (depth) -1\\nnext label in non zigzag tree : label/2\\n\\nExample:\\nFor label 14, depth = log2(14) = 3\\ndepth = 3, label = 14, parent label = 2^(3-1) + 2^3 -1 - 14/2 = 4 + 7 - 7 = 4\\ndepth = 2, label =  4, parent label = 2^(2-1) + 2^2 -1 -  4/2 = 2 + 3 - 2 = 3\\ndepth = 1, label =  3, parent label = 2^(1-1) + 2^1 -1 -  3/2 = 1 + 1 - 1 = 1\\nSo, path = [1, 3, 4, 14]\\n```\\n.\\n.\\n.\\n.\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n\\n        vector<int>result;\\n        \\n        // depth of the given label\\n        int depth = log10(label)/log10(2);\\n        \\n        // Insert labels in the front of the vector from bottom to top\\n        while(depth>=0)\\n        {\\n            // insert current label in the front of vector \\n            result.insert(result.begin(),label);\\n            \\n            // next label (parent label of current label) in non zizag tree: label/2\\n            // in zigzag tree we get label as: \\n            // previous depth first element + (previous depth last element - next label in non zigzag tree)\\n            // previous depth first element : 2^ (depth-1)\\n            // previous depth last element : 2^ (depth) -1\\n            // next label in non zigzag tree : label/2\\n            label = (int)pow(2,depth-1) + (int)pow(2,depth) - 1 - label/2;\\n            depth--;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nWe find the labels starting from given label in bottom to top order\\nFirst we find the depth of the current label as : depth = log2(label)\\nThe parent label (next label) of  the current label will be label/2 in non zigzag binary tree\\nAs the given tree is zigzag labeled no labels will have their original parent label which is label/2 except depth 1 labels, root has depth 0.\\n    \\nSo, we find the parent label (next label) of the current label in zigzag tree as:\\n\\nparent label = previous depth first element + (previous depth last element - next label in non zigzag tree)\\nprevious depth first element : 2^ (depth-1)\\nprevious depth last element : 2^ (depth) -1\\nnext label in non zigzag tree : label/2\\n\\nExample:\\nFor label 14, depth = log2(14) = 3\\ndepth = 3, label = 14, parent label = 2^(3-1) + 2^3 -1 - 14/2 = 4 + 7 - 7 = 4\\ndepth = 2, label =  4, parent label = 2^(2-1) + 2^2 -1 -  4/2 = 2 + 3 - 2 = 3\\ndepth = 1, label =  3, parent label = 2^(1-1) + 2^1 -1 -  3/2 = 1 + 1 - 1 = 1\\nSo, path = [1, 3, 4, 14]\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n\\n        vector<int>result;\\n        \\n        // depth of the given label\\n        int depth = log10(label)/log10(2);\\n        \\n        // Insert labels in the front of the vector from bottom to top\\n        while(depth>=0)\\n        {\\n            // insert current label in the front of vector \\n            result.insert(result.begin(),label);\\n            \\n            // next label (parent label of current label) in non zizag tree: label/2\\n            // in zigzag tree we get label as: \\n            // previous depth first element + (previous depth last element - next label in non zigzag tree)\\n            // previous depth first element : 2^ (depth-1)\\n            // previous depth last element : 2^ (depth) -1\\n            // next label in non zigzag tree : label/2\\n            label = (int)pow(2,depth-1) + (int)pow(2,depth) - 1 - label/2;\\n            depth--;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1453554,
                "title": "easy-to-understand-o-log-n-c-solution-with-intuition-and-explanation-with-example",
                "content": "**Steps** to approach this problem:-\\n1. Determining the level of label node.\\n2. Determining its parent(path) with the help of non-zigzag tree.\\n\\nLets see the below two trees:-\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   1                                                         -> level 1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t2                                                        3                          -> level 2\\n\\t\\t\\t\\t\\t\\t\\t                4                                5                           6                          7             -> level 3\\n\\t                            8                    9               10            11\\t\\t\\t  12           13         14             15       -> level 4\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tNon-Zigzag\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   1                                                         -> level 1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t3                                                        2                           -> level 2\\n\\t\\t\\t\\t\\t\\t\\t                4                                5                           6                          7                -> level 3\\n\\t                            15                    14               13              12\\t\\t\\t  11           10         9             8           -> level 4\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tZigzag\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n1. We can clearly observe that whether the tree may be zigzag or non-zigzag the level in which a label node will lie remains same as each level contain same nodes in both trees.\\nThis level is simply **(int)log2(label) +1** .\\n\\n2. Now if we observe for a non-zigzag tree, the parent of any label node will always be **label/2**.\\nAlso, for each level the nodes lying in the level will be in the following range:-\\n**[2^(level-1),(2^level)-1]** where ^ denotes power.\\nOne important observation is that, the ***label node in zigzag tree is in its mirror position in non-zigzag tree***\\nSo if we can determine the corresponding mirror node of label node in a level then we can easily say its parent is label/2.\\nSo to determine this:-\\n**(Mirror node - lowest node in that level) = (Highest node in that level - label node)**\\nLets say mirror node=x\\nx - 2^(level-1) = (2^level)-1 - label\\n=>** x = ((2^level)-1 - label) + 2^(level-1)**\\nSo parent of x will be x/2.\\n\\nSo we will simply push back the value of x in our result vector and in the end return the reversed result.\\n\\nEg. Let label =13\\n\\nlevel=(int)log2(label)+1 = (int)log2(13)+1 = 4.\\nNow see the 4th level in above 2 trees.\\nThe position of 13 is exaclty the mirror position in both trees.\\nMirror of 13 = ?\\nx=mirror\\nusing this:-\\nx = ((2^level)-1 - label) + 2^(level-1) = ((2^4)-1 - 13) + 2^(4-1) = 10\\nand we know the parent of 10 in non-zigzag tree is 10/2 =5.\\nSo parent of 13 in zigzag tree is also 5.\\nSimilarly we can repeat by setting the label to its parent.\\n```\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> ans;\\n        int level=(int)log2(label)+1; // determine the level in which the label node will lie\\n        int x=label;\\n        ans.push_back(x); \\n        while(level>1)\\n        {\\n            x=(((int)pow(2,level)-1-x)+(int)pow(2,level-1))/2;    // use the non-zigzag tree form to determine the parent\\n            ans.push_back(x);\\n            level--;            \\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;  \\n    }\\n```\\n\\nPlease upvote if you find it helpful as it really motivates me to help the community.\\nAny suggestions are welcomed!\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> ans;\\n        int level=(int)log2(label)+1; // determine the level in which the label node will lie\\n        int x=label;\\n        ans.push_back(x); \\n        while(level>1)\\n        {\\n            x=(((int)pow(2,level)-1-x)+(int)pow(2,level-1))/2;    // use the non-zigzag tree form to determine the parent\\n            ans.push_back(x);\\n            level--;            \\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;  \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1447819,
                "title": "c-easy-solution-for-beginners-with-math-explanation-100-faster",
                "content": "### Approach: \\n\\nAll we have to do is, we have to find parent for each label everytime, until we reach 1. \\nAs it is an infinite binary tree and constraints are upto 10^6, we cannot store it in array or in form of normal node pointers.\\n\\nThe challenge here is to **FIND THE PARENT OF A GIVEN LABEL USING MATHS**\\n\\nFew observations, which come in sight are:\\n- If label is a power of 2, then its parent is label - 1. (Due to zig zag nature of tree).\\n- Difference between label and its level start = 2 * (Difference between its parent and parent level end).\\n- Parent Level End = Label Level Start - 1\\n\\nSo for any label, its parent comes out to be = Parent Level End - (Difference between label and its level start)/2\\n\\nFor example, label = 14.\\n![image](https://assets.leetcode.com/users/images/35accf05-0e72-4384-9429-ce767f235088_1630915985.5353606.png)\\n\\nMy submission:\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPowerTwo(long long n){\\n        return ((n - 1)&n) == 0;\\n    }\\n    int getLevelStart(long long n){\\n        while(!isPowerTwo(n)){\\n            n++;\\n        }\\n        return n/2;\\n    }\\n    int getParent(int n){\\n        if(isPowerTwo(n)){\\n            return n - 1;\\n        } else {\\n            int level_start = getLevelStart(n);\\n            int difference = (n - level_start)/2;\\n            return level_start - 1 - difference;\\n        }\\n    }\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> result;\\n        result.push_back(label);\\n        while(label != 1){\\n            int parent = getParent(label);\\n            result.push_back(parent);\\n            label = parent;\\n        }\\n        reverse(result.begin() , result.end());\\n        return result;\\n    }\\n};\\n```\\n**PLEASE UPVOTE IT IF YOU LIKED IT, IT REALLY MOTIVATES :)**\\n\\n",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPowerTwo(long long n){\\n        return ((n - 1)&n) == 0;\\n    }\\n    int getLevelStart(long long n){\\n        while(!isPowerTwo(n)){\\n            n++;\\n        }\\n        return n/2;\\n    }\\n    int getParent(int n){\\n        if(isPowerTwo(n)){\\n            return n - 1;\\n        } else {\\n            int level_start = getLevelStart(n);\\n            int difference = (n - level_start)/2;\\n            return level_start - 1 - difference;\\n        }\\n    }\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> result;\\n        result.push_back(label);\\n        while(label != 1){\\n            int parent = getParent(label);\\n            result.push_back(parent);\\n            label = parent;\\n        }\\n        reverse(result.begin() , result.end());\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323848,
                "title": "golang-o-log-n-with-detail-explanation",
                "content": "\\n\\nWe first consider the normal case.\\n\\nObviously for a specific number, we can easily find the path from root to the node labeled with the number. \\n\\nFor example, **111 -> 11 -> 1**, **101 -> 10 -> 1**, **110 -> 11 -> 1**. Just shift the number one bit to the right and we can get the parent node of the number until we meet the root node labeled with 1.\\n![image](https://assets.leetcode.com/users/kerojin/image_1561907141.png)\\n\\nNow we consider the zigzag case.\\n![image](https://assets.leetcode.com/users/kerojin/image_1561907407.png)\\nCompared to the normal case, **it needs to convert the node to the symmetric node on the same level and get the parent node**\\n\\nFor example, **100 (--symmetric-> 111) -> 11 (--symmetric-> 10) -> 1, 101 (--symmetric-> 110) -> 11 (--symmetric->10) -> 1**\\n\\nHow to get the symmetric of the number on the same level? **The highest bit remains unchanged, the other bits are reversed**\\n> 1**110** -> 1**001**, we can find 1110+1001=**10111**=10000+1000-1, so **1001 = 10000+1000-1-1110**. That is what `1<<tb + 1<<(tb-1) - 1 - n` means.\\n\\n14(1**110**) --> 9(1**001**) -> 4(100)\\n4(1**00**) --> 7(1**11**) -> 3(11)\\n3(1**1**) --> 2(1**0**) -> 1\\n\\nso the path is 1->3->4->14\\n\\n26(1**1010**) --> 21(1**0101**) -> 10(1010)\\n10(1**010**) --> 13(1**101**) -> 6(110)\\n6(1**10**) --> 5(1**01**) -> 2(10)\\n2(1**0**) --> 3(1**1**) -> 1\\n\\nso the path is 1->2->6->10->26\\n\\n```go\\nfunc pathInZigZagTree(label int) []int {\\n\\tans := []int{label}\\n\\tfor label > 1 {\\n\\t\\tlabel = convert(label)\\n\\t\\tans = append(ans, label)\\n\\t}\\n\\tfor i, j := 0, len(ans)-1; i < j; i, j = i+1, j-1 {\\n\\t\\tans[i], ans[j] = ans[j], ans[i]\\n\\t}\\n\\treturn ans\\n}\\n\\nfunc convert(n int) int {\\n\\ttb := uint(bits(n))\\n\\treturn symmetric(n, tb) >> 1\\n}\\n\\nfunc symmetric(n int, tb uint) int {\\n\\treturn 1<<tb + 1<<(tb-1) - 1 - n\\n}\\n\\nfunc bits(n int) int {\\n\\tr := 0\\n\\tfor n > 0 {\\n\\t\\tr++\\n\\t\\tn >>= 1\\n\\t}\\n\\treturn r\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc pathInZigZagTree(label int) []int {\\n\\tans := []int{label}\\n\\tfor label > 1 {\\n\\t\\tlabel = convert(label)\\n\\t\\tans = append(ans, label)\\n\\t}\\n\\tfor i, j := 0, len(ans)-1; i < j; i, j = i+1, j-1 {\\n\\t\\tans[i], ans[j] = ans[j], ans[i]\\n\\t}\\n\\treturn ans\\n}\\n\\nfunc convert(n int) int {\\n\\ttb := uint(bits(n))\\n\\treturn symmetric(n, tb) >> 1\\n}\\n\\nfunc symmetric(n int, tb uint) int {\\n\\treturn 1<<tb + 1<<(tb-1) - 1 - n\\n}\\n\\nfunc bits(n int) int {\\n\\tr := 0\\n\\tfor n > 0 {\\n\\t\\tr++\\n\\t\\tn >>= 1\\n\\t}\\n\\treturn r\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 323302,
                "title": "c-log-n-intuitive-solution-with-algo-comments",
                "content": "1. First find level of label and index of given label in its respective level.\\n2. Go up the tree each level , index of parent will be half of children\\'s index in its respective level . Find label value considering zig zag in odd/even levels.\\n3. Reverse the array and return result\\n\\n```\\n\\t\\tint index=0;\\n        vector<int> res;\\n        res.push_back(label); // pushing given label in res\\n         int curr_level=0;  // this will serve as current level\\n        while(label>0)  // finding label\\'s level\\n        {\\n            int x = pow(2,curr_level);\\n            if(x<label)\\n\\t\\t\\t\\tlabel-=x;\\n            else\\n                break;\\n            curr_level++;\\n        }\\n        if(curr_level%2==0) // index of label in its level\\n            index= label-1;  \\n        else\\n            index = pow(2,curr_level)-label;\\n        \\n        while(curr_level>0)  // finding label\\'s parents indices\\n        {\\n            curr_level--;\\n            index=index/2; // index in its level\\n            if(curr_level%2==0)\\n                res.push_back(pow(2,curr_level)+index); // to find label value \\n            else\\n                res.push_back(pow(2,curr_level+1)-index-1);\\n        }\\n        reverse(res.begin(),res.end());\\n        return res;\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n\\t\\tint index=0;\\n        vector<int> res;\\n        res.push_back(label); // pushing given label in res\\n         int curr_level=0;  // this will serve as current level\\n        while(label>0)  // finding label\\'s level\\n        {\\n            int x = pow(2,curr_level);\\n            if(x<label)\\n\\t\\t\\t\\tlabel-=x;\\n            else\\n                break;\\n            curr_level++;\\n        }\\n        if(curr_level%2==0) // index of label in its level\\n            index= label-1;  \\n        else\\n            index = pow(2,curr_level)-label;\\n        \\n        while(curr_level>0)  // finding label\\'s parents indices\\n        {\\n            curr_level--;\\n            index=index/2; // index in its level\\n            if(curr_level%2==0)\\n                res.push_back(pow(2,curr_level)+index); // to find label value \\n            else\\n                res.push_back(pow(2,curr_level+1)-index-1);\\n        }\\n        reverse(res.begin(),res.end());\\n        return res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 691083,
                "title": "java-solution-with-explanation",
                "content": "```\\n    // in a normally indexed tree, we can find the parent of a node by node.index/2\\n    // but in this case, some levels node indexes are reversed\\n    // original: 8 9 10 11 12 13 14 15 \\n    // current:  15 14 12 12 11 10 9 8\\n    // we want to find current 14\\'s parent which is original 9\\'s parent  9/2 = 4\\n    // how do we know 14\\'s corresponding reverse node is 9?\\n    // we can see that every original index + current index are the same\\n    // so we can get min and max of every level  -> min + max - 14 is the corresponding reversed index\\n    // step1: find target label\\'s level \\n    // step2: all the way up to root, every level, we get min, max, find reversed index -> parent add to result;\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int level = 0;\\n        int count = 0;\\n        while (label > count) {\\n            count += Math.pow(2, level); // 1  3 7 15\\n            level++;   // 1 2 3 4\\n        }\\n        level = level - 1;\\n        List<Integer> result = new ArrayList<>();\\n\\n        while (level >= 0) {\\n            result.add(0, label);\\n            int min = (int)Math.pow(2, level);\\n            int max = (int)Math.pow(2, level+1)-1;\\n            int reversedLabel = min + max - label;\\n            label = reversedLabel/2;\\n            level = level - 1;\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "```\\n    // in a normally indexed tree, we can find the parent of a node by node.index/2\\n    // but in this case, some levels node indexes are reversed\\n    // original: 8 9 10 11 12 13 14 15 \\n    // current:  15 14 12 12 11 10 9 8\\n    // we want to find current 14\\'s parent which is original 9\\'s parent  9/2 = 4\\n    // how do we know 14\\'s corresponding reverse node is 9?\\n    // we can see that every original index + current index are the same\\n    // so we can get min and max of every level  -> min + max - 14 is the corresponding reversed index\\n    // step1: find target label\\'s level \\n    // step2: all the way up to root, every level, we get min, max, find reversed index -> parent add to result;\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int level = 0;\\n        int count = 0;\\n        while (label > count) {\\n            count += Math.pow(2, level); // 1  3 7 15\\n            level++;   // 1 2 3 4\\n        }\\n        level = level - 1;\\n        List<Integer> result = new ArrayList<>();\\n\\n        while (level >= 0) {\\n            result.add(0, label);\\n            int min = (int)Math.pow(2, level);\\n            int max = (int)Math.pow(2, level+1)-1;\\n            int reversedLabel = min + max - label;\\n            label = reversedLabel/2;\\n            level = level - 1;\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 323300,
                "title": "python-level-based-approach",
                "content": "```\\ndef pathInZigZagTree(self, label: int) -> List[int]:\\n        level, tot = -1, 0\\n        while label > tot:\\n            level += 1\\n            tot += (2 ** level)\\n        \\n        level -= 1\\n        cur = label // 2\\n        res = [label]\\n        while level > -1:\\n            st, end = 2 ** level, (2 **(level+1)) - 1\\n            cur = st + end - cur\\n            res.append(cur)\\n            level -= 1\\n            cur = cur // 2\\n        return res[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\ndef pathInZigZagTree(self, label: int) -> List[int]:\\n        level, tot = -1, 0\\n        while label > tot:\\n            level += 1\\n            tot += (2 ** level)\\n        \\n        level -= 1\\n        cur = label // 2\\n        res = [label]\\n        while level > -1:\\n            st, end = 2 ** level, (2 **(level+1)) - 1\\n            cur = st + end - cur\\n            res.append(cur)\\n            level -= 1\\n            cur = cur // 2\\n        return res[::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 888006,
                "title": "java-100-o-log-n",
                "content": "plz do Upvote if you like the solution.\\n\\nclass Solution {\\n\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> result=new ArrayList<>();\\n        int parent=label;\\n        result.add(parent);\\n        while(parent !=1){\\n            int depth= (int) (Math.log(parent)/Math.log(2));\\n            int offset= (int) Math.pow(2,depth+1)-1-parent;\\n            parent= ((int) Math.pow(2,depth)+ offset)/2;\\n            result.add(parent);\\n        }\\n        Collections.reverse(result);\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> result=new ArrayList<>();\\n        int parent=label;\\n        result.add(parent);\\n        while(parent !=1){\\n            int depth= (int) (Math.log(parent)/Math.log(2));\\n            int offset= (int) Math.pow(2,depth+1)-1-parent;\\n            parent= ((int) Math.pow(2,depth)+ offset)/2;\\n            result.add(parent);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3263448,
                "title": "c-solution-with-explanation-beats-100",
                "content": "# Approach\\n1. Simply find the parent of a label as we find the parent of a node in complete binary tree (label/2).\\n2. Since upper level is in reverse order relative to the current level, therefore correct parent will be different. For example - if parent is 7 in complete binary tree, correct binary tree will be 4 in this case. If parent is 5 then correct parent will be 6.\\n3. For finding the correct parent of a node we need to subtract incorrect parent from the sum of minimum and maximum value of the previous level (4+7-(14/2)=4).\\n4. Minimum value in the previous level = 2^(current_height - 1).\\n5. Maximum value in the previous level = 2^(current_height)-1.\\n6. Therefore correct parent will be 2^(current_height - 1) + 2^(current_height)-1 + (label/2)\\n7. Repeat these steps untill we reach the root node.\\n\\n# Complexity\\n- Time complexity:\\n  O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n  O(log n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int height =log2(label);\\n        vector<int> ans;\\n        ans.push_back(label);\\n        while(height){\\n            int left=pow(2,height-1);\\n            int right=pow(2,height)-1;\\n            label=left+right-(label/2);\\n            ans.push_back(label);\\n            height--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int height =log2(label);\\n        vector<int> ans;\\n        ans.push_back(label);\\n        while(height){\\n            int left=pow(2,height-1);\\n            int right=pow(2,height)-1;\\n            label=left+right-(label/2);\\n            ans.push_back(label);\\n            height--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 608949,
                "title": "python-o-log-n-level-wise-parent-calculation",
                "content": "# Intuition\\nA starting point to solve this problem is to think of the much simpler case. when the labelling is always done from left-to-right. \\nIn that case, you may get the solution by simply dividing the current label by 2 until you reach the top (`1`). \\nHowever, we must make sure we divide the correct number by finding its symmetry in the level, hence, avoiding the fact that the labelling direction keeps switiching up.\\n\\n### Procedure\\n- We first determine the level of the label.\\n- We init the solutions list as a `deque` to prepend elements in `O(1)`\\n- We iterate starting from the label\\'s level up to the first level (`0`).\\n- We append the current label to the `deque`.\\n- We get the label of the previous level in one operation, it uses:\\n\\t- `last_element`: the last element in the current level: `2**l - 1`\\n\\t- `first_element`: the first element in the current level: `2**(l-1)`\\n\\t- The update operation is: `(last_element + first_element - label) // 2`\\n- Time: `O(log n)`, Space: `O(1)`\\n\\n```Python\\nfrom math import log\\nfrom collections import deque\\n\\nclass Solution:\\n    def pathInZigZagTree(self, label):\\n        level = int(log(label, 2))\\n        solution = deque()\\n        for l in range(level, -1, -1):\\n            solution.appendleft(label)\\n            label = (3*(2**l) - 1 - label) // 2\\n        return solution\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python\\nfrom math import log\\nfrom collections import deque\\n\\nclass Solution:\\n    def pathInZigZagTree(self, label):\\n        level = int(log(label, 2))\\n        solution = deque()\\n        for l in range(level, -1, -1):\\n            solution.appendleft(label)\\n            label = (3*(2**l) - 1 - label) // 2\\n        return solution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 572570,
                "title": "0ms-java-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int level = 0;\\n        int tmp = label;\\n        \\n        while (tmp != 0){\\n            tmp /= 2;\\n            level ++;\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        while (level > 0){\\n            res.add(label);\\n\\t\\t\\t/*At level n, the smallest label is 2^(n-1), the greatest label is 2^n - 1. \\n\\t\\t\\tThus a label plus its complementary label is equal to 2^(n-1) + 2^n - 1.\\n\\t\\t\\tThe predecessor of a node with label n has label n/2 if the labels are not reversed. \\n\\t\\t\\tNow that the labels are reversed every two levels, either the node itself or its predecessor is at a reversed level. \\n\\t\\t\\tSo to calculate the label of its predecessor, we use its complementary label / 2.*/\\n            label = (3 * (int)Math.pow(2, level - 1) - 1 -label);\\n            label /= 2;\\n            level --;\\n        }\\n        Collections.reverse(res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int level = 0;\\n        int tmp = label;\\n        \\n        while (tmp != 0){\\n            tmp /= 2;\\n            level ++;\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        while (level > 0){\\n            res.add(label);\\n\\t\\t\\t/*At level n, the smallest label is 2^(n-1), the greatest label is 2^n - 1. \\n\\t\\t\\tThus a label plus its complementary label is equal to 2^(n-1) + 2^n - 1.\\n\\t\\t\\tThe predecessor of a node with label n has label n/2 if the labels are not reversed. \\n\\t\\t\\tNow that the labels are reversed every two levels, either the node itself or its predecessor is at a reversed level. \\n\\t\\t\\tSo to calculate the label of its predecessor, we use its complementary label / 2.*/\\n            label = (3 * (int)Math.pow(2, level - 1) - 1 -label);\\n            label /= 2;\\n            level --;\\n        }\\n        Collections.reverse(res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 396484,
                "title": "simple-solution-in-java",
                "content": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        // int parent = label;\\n        LinkedList<Integer> res = new LinkedList<>();\\n        res.addFirst(label);\\n        \\n        while(label != 1){\\n            int level = (int)(Math.log(label)/Math.log(2))+1;\\n            int max = (int)Math.pow(2,level) - 1;\\n            int min = (int)Math.pow(2,level - 1);\\n            label = (int)(max + min - label)/2;\\n            \\n            res.addFirst(label);\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        // int parent = label;\\n        LinkedList<Integer> res = new LinkedList<>();\\n        res.addFirst(label);\\n        \\n        while(label != 1){\\n            int level = (int)(Math.log(label)/Math.log(2))+1;\\n            int max = (int)Math.pow(2,level) - 1;\\n            int min = (int)Math.pow(2,level - 1);\\n            label = (int)(max + min - label)/2;\\n            \\n            res.addFirst(label);\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1939470,
                "title": "c-simple-solution-beats-100",
                "content": "The approach is quite simple first of all we generate a path without the zigzag. i.e. we will just divide the number with two, to get its\\'s parent. then we will keep on storing it\\'s value into the ans vector.\\n\\nThe second step is mapping. There will always be elements in power of 2 on every level.\\n\\n```\\nsuppose we are dealing with level 3 i.e. 8 elements now if we invert the level each element will be mapped to it\\'s counter part;\\n\\n 1   2  3     4  5  6    7  8\\n |   |   |    |__|   |   |  |\\n |   |   |___________|   |  |\\n |   |___________________|  |\\n |__________________________|\\n \\n so we just have to find the corresponding element and scale it up i.e add the first element occuring in the corresponding level.\\n \\n```\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> ans;\\n        for(int i = label; i > 0; i/=2) {\\n            ans.push_back(i);  //pushing the parents without zigzag pattern\\n        }\\n        int aux = 4;\\n        reverse(ans.begin(), ans.end());\\n        for(int i = ans.size()-2; i > 0; i -=2 ){\\n            int l = log2(ans[i+1]);\\n            l = pow(2, l); //contains the number fo elements in that level\\n            int aux = log2(ans[i]);\\n            aux = pow(2, aux); //aux contain the value of the first element of that level\\n            ans[i] = aux + (l - ans[i])-1; //finding the corresponding element\\n        } \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nsuppose we are dealing with level 3 i.e. 8 elements now if we invert the level each element will be mapped to it\\'s counter part;\\n\\n 1   2  3     4  5  6    7  8\\n |   |   |    |__|   |   |  |\\n |   |   |___________|   |  |\\n |   |___________________|  |\\n |__________________________|\\n \\n so we just have to find the corresponding element and scale it up i.e add the first element occuring in the corresponding level.\\n \\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> ans;\\n        for(int i = label; i > 0; i/=2) {\\n            ans.push_back(i);  //pushing the parents without zigzag pattern\\n        }\\n        int aux = 4;\\n        reverse(ans.begin(), ans.end());\\n        for(int i = ans.size()-2; i > 0; i -=2 ){\\n            int l = log2(ans[i+1]);\\n            l = pow(2, l); //contains the number fo elements in that level\\n            int aux = log2(ans[i]);\\n            aux = pow(2, aux); //aux contain the value of the first element of that level\\n            ans[i] = aux + (l - ans[i])-1; //finding the corresponding element\\n        } \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1455280,
                "title": "c-easy-to-understand-100-faster-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int>v;\\n        while(label>0) {\\n            v.push_back(label);\\n            label/=2;\\n        }\\n        for(int i=0;i<v.size();i++) {\\n            if(i%2==1) {\\n                int base=log2(v[i]);\\n                int add=pow(2,base+1)-1-v[i];\\n                v[i]=pow(2,base)+add;\\n            }\\n        }\\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int>v;\\n        while(label>0) {\\n            v.push_back(label);\\n            label/=2;\\n        }\\n        for(int i=0;i<v.size();i++) {\\n            if(i%2==1) {\\n                int base=log2(v[i]);\\n                int add=pow(2,base+1)-1-v[i];\\n                v[i]=pow(2,base)+add;\\n            }\\n        }\\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 556569,
                "title": "easy-to-understand-faser-than-100-11-lines",
                "content": "```\\n vector<int> pathInZigZagTree(int label) {\\n    int level = log(label) / log(2) + 1;  \\n    vector<int> path(level);\\n    while (label) {\\n        path[level - 1] = label;\\n        label = pow(2, level) - 1 - label + pow(2, level - 1);\\n        label >>= 1;\\n        level--;\\n    }\\n    return path;\\n }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n vector<int> pathInZigZagTree(int label) {\\n    int level = log(label) / log(2) + 1;  \\n    vector<int> path(level);\\n    while (label) {\\n        path[level - 1] = label;\\n        label = pow(2, level) - 1 - label + pow(2, level - 1);\\n        label >>= 1;\\n        level--;\\n    }\\n    return path;\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2459714,
                "title": "c-easy-to-understand-0-ms",
                "content": "///\\n\\nclass Solution {\\npublic:\\n\\n    vector<int> pathInZigZagTree(int n) {\\n        int lastValue = 1; // start and end of root node will be 1\\n        int currVal = 0 ; // To traverse to the given root/level\\n        \\n        while(currVal < n)\\n        {\\n            currVal += lastValue; // to reach the correct level\\n            lastValue *=2;\\n        }\\n        \\n        lastValue /=2; // to come back to the original level \\n        \\n        vector<int> ans;\\n        while( n != 1)\\n        {\\n            ans.emplace_back(n);\\n            int complement = 3*lastValue - n - 1; // start = lastValue , end = 2*lastValue-1 , compl = start + end - n;\\n            int parent = complement/2;   // parent = complement of n/2;\\n            n = parent;  // update number\\n            lastValue /=2; // decrease level\\n        }\\n        ans.emplace_back(1);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> pathInZigZagTree(int n) {\\n        int lastValue = 1; // start and end of root node will be 1\\n        int currVal = 0 ; // To traverse to the given root/level\\n        \\n        while(currVal < n)\\n        {\\n            currVal += lastValue; // to reach the correct level\\n            lastValue *=2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1110443,
                "title": "c-o-logn-fundamental-approach",
                "content": "For a given label we can first find it\\'s distance from minimum/starting value in the given level. This can be given by:\\n**dist = label - pow(2, level)**\\n\\nwhere pow(2, level) gives the minimum value in the level.\\n\\nWe further divide it by 2 to get equivalent distance that gets reflected in previous level. (Property of binary tree - Number of nodes in previous level is half of current level.)\\n**dist = dist / 2**\\n\\nNow finally to get parent in previous level we just need to remove this **dist**  from greatest value in previous level.\\n**parent =  (pow(2, level) - 1) - dist**\\n\\nFinally return reverse of vector, since the calculation has been done in bottom up manner.\\n\\n```\\nvector<int> pathInZigZagTree(int label) {\\n        vector<int> res;\\n        int p = log2(label);\\n        \\n        res.push_back(label);\\n        \\n        while(p > 0) {\\n            int dist = (label - pow(2, p)) / 2;\\n            label =  pow(2, p) - 1 - dist;\\n\\n            res.push_back(label);         \\n            p--;\\n        }\\n        \\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> pathInZigZagTree(int label) {\\n        vector<int> res;\\n        int p = log2(label);\\n        \\n        res.push_back(label);\\n        \\n        while(p > 0) {\\n            int dist = (label - pow(2, p)) / 2;\\n            label =  pow(2, p) - 1 - dist;\\n\\n            res.push_back(label);         \\n            p--;\\n        }\\n        \\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 497583,
                "title": "java-o-log-n-solution-using-the-path-and-symmetric-path",
                "content": "1. If the tree is not zigzag, what is the path to a number?\\n```\\n Stack<Integer> path = new Stack<>();\\n int tmp = label;\\n while(tmp > 1) {\\n\\t path.push(tmp % 2);\\n     tmp /= 2;\\n }\\n```\\n\\n2. Find the nodes on the path and the symmetric path: values[0] and values[1], for example: if the number is 26:\\n```\\nvalues[0] = [1, 2, 5, 10, 21]      <- symmetric path\\nvalues[1] = [1, 3, 6, 13, 26]      <- path to 26 in the non-zigzag tree.\\n```\\n3. So the path to the node in the zigzag tree: choose one from symmetric path and path alternatively.\\n```\\n[1, 2, 6, 10, 26]     <- path to 26 in the zigzag tree\\n```\\n\\n```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        Stack<Integer> path = new Stack<>();\\n        int tmp = label;\\n        while(tmp > 1) {\\n            path.push(tmp % 2);\\n            tmp /= 2;\\n        }\\n        int[][] values = new int[2][path.size() + 1];\\n        values[0][0] = 1;\\n        values[1][0] = 1;\\n        int step = 1;\\n        while(!path.isEmpty()) {\\n            int dir = path.pop();\\n            values[0][step] = values[0][step - 1] * 2 + (dir == 0 ? 1 : 0);\\n            values[1][step] = values[1][step - 1] * 2 + dir;\\n            ++step;\\n        }\\n\\n        List<Integer> res = new ArrayList<>();\\n        int index = step % 2;\\n        for(int i = 0; i < step; ++i) {\\n            res.add(values[(index + i) % 2][i]);\\n        }\\n\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\n Stack<Integer> path = new Stack<>();\\n int tmp = label;\\n while(tmp > 1) {\\n\\t path.push(tmp % 2);\\n     tmp /= 2;\\n }\\n```\n```\\nvalues[0] = [1, 2, 5, 10, 21]      <- symmetric path\\nvalues[1] = [1, 3, 6, 13, 26]      <- path to 26 in the non-zigzag tree.\\n```\n```\\n[1, 2, 6, 10, 26]     <- path to 26 in the zigzag tree\\n```\n```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        Stack<Integer> path = new Stack<>();\\n        int tmp = label;\\n        while(tmp > 1) {\\n            path.push(tmp % 2);\\n            tmp /= 2;\\n        }\\n        int[][] values = new int[2][path.size() + 1];\\n        values[0][0] = 1;\\n        values[1][0] = 1;\\n        int step = 1;\\n        while(!path.isEmpty()) {\\n            int dir = path.pop();\\n            values[0][step] = values[0][step - 1] * 2 + (dir == 0 ? 1 : 0);\\n            values[1][step] = values[1][step - 1] * 2 + dir;\\n            ++step;\\n        }\\n\\n        List<Integer> res = new ArrayList<>();\\n        int index = step % 2;\\n        for(int i = 0; i < step; ++i) {\\n            res.add(values[(index + i) % 2][i]);\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323837,
                "title": "java-java-solution-with-explanation",
                "content": "idea borrowed from @votrubac, and translate to Java\\nhttps://leetcode.com/problems/path-in-zigzag-labelled-binary-tree/discuss/323293/C%2B%2B-O(log-n)\\n\\nThe basic idea is to get the height of the node in the tree and then traverse back to root which is the tricky part (since it is zigzaged).\\n\\nWe know that the target node\\'s actual parent should be the parent of its symmetric node at current height. So we first get the current height which is the first for loop. Then, to get the symmetric node, we first need to realize the fact: **(label of current node + label of symmetric node) == (label of minimum node at current height) + (label of maximum node at current height)** The minimum label can be calculated by 2^(level - 1) and maximum label can be calculated by 2^(level) - 1, where level is the current height. \\n\\n```\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int size = 1;\\n        int level = 1;\\n        LinkedList<Integer> res = new LinkedList<>();\\n        while ((size << 1) <= label) {\\n            size <<= 1;\\n            level++;\\n        }\\n        while (label != 0) {\\n            res.addFirst(label);\\n            label = ((1 << level) - 1 + (1 << (level - 1)) - label) / 2; \\n            level--;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int size = 1;\\n        int level = 1;\\n        LinkedList<Integer> res = new LinkedList<>();\\n        while ((size << 1) <= label) {\\n            size <<= 1;\\n            level++;\\n        }\\n        while (label != 0) {\\n            res.addFirst(label);\\n            label = ((1 << level) - 1 + (1 << (level - 1)) - label) / 2; \\n            level--;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 323676,
                "title": "python-simple-solution-with-explanation",
                "content": "First of all, ignore the fact that the binary tree is a zegzag labelled binary Tree. Simply assuming it\\'s a sequentially labelled binary tree. Then the path could be easily calculated.\\n\\nThe only difference between our assumption and the fact is that there are several different items. The ```key abservation``` is that we could easily find the complement of those different items, given the height of our item:\\n```complement = 2**(height+1) + 2**height - item``` \\n\\n```\\n    def pathInZigZagTree(self, label):\\n        \"\"\"\\n        :type label: int\\n        :rtype: List[int]\\n        \"\"\"\\n        res = []\\n        while label:\\n            res.append(label)\\n            label /= 2\\n        res = res[::-1]\\n        for i in range(len(res)-2, 0, -2):\\n            res[i] = 2**(i+1) -1 + 2**i - res[i]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```key abservation```\n```complement = 2**(height+1) + 2**height - item```\n```\\n    def pathInZigZagTree(self, label):\\n        \"\"\"\\n        :type label: int\\n        :rtype: List[int]\\n        \"\"\"\\n        res = []\\n        while label:\\n            res.append(label)\\n            label /= 2\\n        res = res[::-1]\\n        for i in range(len(res)-2, 0, -2):\\n            res[i] = 2**(i+1) -1 + 2**i - res[i]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 323382,
                "title": "python-3-easy-explained",
                "content": "In normaly row-ordered binary tree we can find parent node by **label//2**, but in this problem we need to adjust calculation depending if current or previous row is inverted.\\n\\nE.g. label 14 is in negatively ordered row, so to find parent we adjust position - that is see 14 occupies place of 9, then divide 9 by 2, thus parent is 9//2 = 4.\\n\\nLabel 4 is in normally ordered row - we divide by 2, 4//2 = 2, but place of 2 in previous  row is occupied by 3, thus parent of 4 is 3.\\n\\nI created helper array to store order of every row to simplify thought process.\\n\\nSee how to find parents in rows, where row represented by tuple **(min_element_in_row, is_neg_order)**:\\n\\n(1, 0)\\n(2, 1) - inverted order, to find parent adjust current row position and divide by 2\\n(4, 0) - normal order, divide by 2 and adjust parent row position\\n(8, 1) - inverted order, to find parent adjust current row position and divide by 2\\n(16, 0) - normal order, divide by 2 and adjust parent row position\\nand so on...\\n    \\n```\\nclass Solution:\\n    \\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        rows = [(1, 0)] #row represented by tuple (min_element_in_row, is_neg_order)\\n        while rows[-1][0]*2 <= label:\\n            rows.append((rows[-1][0]*2, 1 - rows[-1][1]))\\n            \\n        power, negOrder = rows.pop()\\n        \\n        res = []\\n        while label > 1:\\n            res.append(label)\\n                \\n            if negOrder:\\n                # adjust label position and find parent with division by 2\\n                # a, b - range of current row \\n                a, b = power, power*2 -1\\n                label = (a + (b - label))//2\\n            else:\\n                # divide label by 2 and adjust parent position\\n                # a, b - range of previous row\\n                a, b = power//2, power - 1\\n                label = b - (label//2 - a)\\n                \\n            power, negOrder = rows.pop()\\n            \\n                          \\n        res.append(1)\\n                          \\n        return res[::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        rows = [(1, 0)] #row represented by tuple (min_element_in_row, is_neg_order)\\n        while rows[-1][0]*2 <= label:\\n            rows.append((rows[-1][0]*2, 1 - rows[-1][1]))\\n            \\n        power, negOrder = rows.pop()\\n        \\n        res = []\\n        while label > 1:\\n            res.append(label)\\n                \\n            if negOrder:\\n                # adjust label position and find parent with division by 2\\n                # a, b - range of current row \\n                a, b = power, power*2 -1\\n                label = (a + (b - label))//2\\n            else:\\n                # divide label by 2 and adjust parent position\\n                # a, b - range of previous row\\n                a, b = power//2, power - 1\\n                label = b - (label//2 - a)\\n                \\n            power, negOrder = rows.pop()\\n            \\n                          \\n        res.append(1)\\n                          \\n        return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018989,
                "title": "simplest-solution-ever",
                "content": "# Code\\n```\\n#include<cmath>\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int level=0,a=label;\\n        vector<int> res;\\n        while(a>0){a=a/2;level++;}\\n        for(int i=level-1;i>0;i--){\\n            res.push_back(label);\\n            int x=(pow(2,i)+pow(2,i-1)-1);\\n            int y=label/2;\\n            label=x-y;\\n        }\\n        res.push_back(1);\\n        reverse(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n#include<cmath>\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int level=0,a=label;\\n        vector<int> res;\\n        while(a>0){a=a/2;level++;}\\n        for(int i=level-1;i>0;i--){\\n            res.push_back(label);\\n            int x=(pow(2,i)+pow(2,i-1)-1);\\n            int y=label/2;\\n            label=x-y;\\n        }\\n        res.push_back(1);\\n        reverse(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3221022,
                "title": "100-faster-time-o-n-space-o-ans-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int x) {\\n        vector<int> ans;\\n        int k = 0, y = x;\\n        while(y){\\n            k++;\\n            y >>= 1;\\n        }\\n        // cout<<k--<<\" \";\\n        --k;\\n        while(x>1){\\n            if(k&1){\\n                ans.push_back(x);\\n                x = (1<<(k+1))-x+(1<<k)-1;\\n                x >>= 1;\\n            }else{\\n                ans.push_back(x);\\n                x >>= 1;\\n                x = (1<<(k))-x+(1<<(k-1))-1;\\n            }\\n            k--;\\n        }\\n        ans.push_back(1);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int x) {\\n        vector<int> ans;\\n        int k = 0, y = x;\\n        while(y){\\n            k++;\\n            y >>= 1;\\n        }\\n        // cout<<k--<<\" \";\\n        --k;\\n        while(x>1){\\n            if(k&1){\\n                ans.push_back(x);\\n                x = (1<<(k+1))-x+(1<<k)-1;\\n                x >>= 1;\\n            }else{\\n                ans.push_back(x);\\n                x >>= 1;\\n                x = (1<<(k))-x+(1<<(k-1))-1;\\n            }\\n            k--;\\n        }\\n        ans.push_back(1);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3121699,
                "title": "binary-tree-not-required-o-n-javascript-memory-94-72-meaningful-vars",
                "content": "# Intuition\\nBinary Tree Not Required\\n\\n# Approach\\n1. Create an array having all elements of every level till the level where our label element exists. Remeber to reverse the array for even number of levels. \\n=> arr.reverse();\\n2. Find the index of element where label exist from the last level of above array. \\n=> let indexOfLabelElement = array[array.length - 1].indexOf(label);\\n3. Find Parent of this level till we hit level 0. \\n=> Math.floor(indexOfLabelElement / 2);\\n\\n# Complexity\\n- Time complexity:\\n=> O(n)\\n\\n- Space complexity:\\n=> O(n)\\n\\n# Code\\n```\\nvar pathInZigZagTree = function(label) {\\n\\tlet array = [];\\n\\tlet currentLevel = 0;\\n\\tlet currentElement = 1;\\n\\tlet totalElementsBuild = 0;\\n\\twhile (totalElementsBuild < label) {\\n\\t\\tlet elementInCurrentLevel = Math.pow(2, currentLevel);\\n\\t\\ttotalElementsBuild += elementInCurrentLevel;\\n\\t\\tconst arr = [];\\n\\t\\twhile (elementInCurrentLevel--) {\\n\\t\\t\\tarr.push(currentElement++);\\n\\t\\t}\\n\\t\\tif (currentLevel % 2 !== 0) {\\n\\t\\t\\tarr.reverse();\\n\\t\\t}\\n\\t\\tarray.push(arr);\\n\\t\\tcurrentLevel++;\\n\\t}\\n\\tlet indexOfLabelElement = array[array.length - 1].indexOf(label);\\n\\tconst output = [ label ];\\n\\tfor (let index = array.length - 2; index >= 0; index--) {\\n\\t\\tindexOfLabelElement = Math.floor(indexOfLabelElement / 2);\\n\\t\\toutput.push(array[index][indexOfLabelElement]);\\n\\t}\\n\\treturn output.reverse();\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar pathInZigZagTree = function(label) {\\n\\tlet array = [];\\n\\tlet currentLevel = 0;\\n\\tlet currentElement = 1;\\n\\tlet totalElementsBuild = 0;\\n\\twhile (totalElementsBuild < label) {\\n\\t\\tlet elementInCurrentLevel = Math.pow(2, currentLevel);\\n\\t\\ttotalElementsBuild += elementInCurrentLevel;\\n\\t\\tconst arr = [];\\n\\t\\twhile (elementInCurrentLevel--) {\\n\\t\\t\\tarr.push(currentElement++);\\n\\t\\t}\\n\\t\\tif (currentLevel % 2 !== 0) {\\n\\t\\t\\tarr.reverse();\\n\\t\\t}\\n\\t\\tarray.push(arr);\\n\\t\\tcurrentLevel++;\\n\\t}\\n\\tlet indexOfLabelElement = array[array.length - 1].indexOf(label);\\n\\tconst output = [ label ];\\n\\tfor (let index = array.length - 2; index >= 0; index--) {\\n\\t\\tindexOfLabelElement = Math.floor(indexOfLabelElement / 2);\\n\\t\\toutput.push(array[index][indexOfLabelElement]);\\n\\t}\\n\\treturn output.reverse();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2683563,
                "title": "python3-xor-solution",
                "content": "Recently I learned about an interesting way to label complete binary trees. Where the nodes are labelled with bits where going left you append a \\'0\\' and if you go right, you append a \\'1\\'. Normally you can get the path (from leaf to root) by just bitshifting to the right each step. But since the even rows are flipped, you need to get the \"mirror image\" of some nodes in the path. To do that you can notice that to get the \"mirror image\" of a number on a certain level, you flip every bit except the leading 1.  To \"flip the bits\", you can use XOR\\n\\n![image](https://assets.leetcode.com/users/images/cc32b129-6888-440e-a69e-f507dfbcb750_1665613178.5220823.png)\\n\\n\\n```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        \\n        x = label\\n        mask = 0 \\n        while x > 1:\\n            x >>= 1\\n            mask <<= 1\\n            mask |= 1\\n            \\n        x = label\\n        res = deque()\\n        while x:\\n            res.appendleft(x)\\n            x >>= 1\\n            mask >>= 1\\n            x ^= mask\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        \\n        x = label\\n        mask = 0 \\n        while x > 1:\\n            x >>= 1\\n            mask <<= 1\\n            mask |= 1\\n            \\n        x = label\\n        res = deque()\\n        while x:\\n            res.appendleft(x)\\n            x >>= 1\\n            mask >>= 1\\n            x ^= mask\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2471876,
                "title": "python-solution-know-your-tree-well",
                "content": "```\\nclass Solution:\\n    # Remember rule of binary tree parenthood:\\n    # ith node\\'s children are 2*i and 2*i+1 (i = 1, 2, ...)\\n    # First of all, given label, we know which level it is at: label.bit_length()-1\\n    # Now we have a zigzag situation\\n    # On ith row (with 2^i nodes 2^i, 2^i+1,... 2^(i+1) - 1)\\n    # if i is odd, it becomes reversed 2^(i+1)-1, 2^(i+1)-2,... 2^(i+1) - 2^i\\n    # Therefore we separate into two cases:\\n    # 1. if the node given is on an even level i\\n    # if label is odd / even, we know its parent is j = (label - 1)//2 / label//2\\n    # But we should output 2^i - (j - 2^(i-1) + 1)\\n    # If the node 2*j+1 / 2*j given is on an odd level i\\n    # We find its parent on the even level \\n    # which is 2^i - (j - 2^(i-1) + 1)\\n    \\n    def zigzagpath(self, label, path, level):\\n        while level > 0:\\n            path += [label]\\n            label //= 2\\n            parent_new = pow(2, level) - (label + 1 - pow(2,level-1))\\n            path += [parent_new]\\n            label //= 2\\n            level -= 2\\n        path.append(1)\\n        return path\\n    \\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        level, result = label.bit_length() - 1, []\\n        if level % 2 == 1:\\n            result.append(label)\\n            if label % 2 == 1:\\n                label -= 1\\n            label //= 2\\n            label = pow(2, level) - (label + 1 - pow(2,level-1))\\n            level -= 1\\n        return reversed(self.zigzagpath(label, result, level))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # Remember rule of binary tree parenthood:\\n    # ith node\\'s children are 2*i and 2*i+1 (i = 1, 2, ...)\\n    # First of all, given label, we know which level it is at: label.bit_length()-1\\n    # Now we have a zigzag situation\\n    # On ith row (with 2^i nodes 2^i, 2^i+1,... 2^(i+1) - 1)\\n    # if i is odd, it becomes reversed 2^(i+1)-1, 2^(i+1)-2,... 2^(i+1) - 2^i\\n    # Therefore we separate into two cases:\\n    # 1. if the node given is on an even level i\\n    # if label is odd / even, we know its parent is j = (label - 1)//2 / label//2\\n    # But we should output 2^i - (j - 2^(i-1) + 1)\\n    # If the node 2*j+1 / 2*j given is on an odd level i\\n    # We find its parent on the even level \\n    # which is 2^i - (j - 2^(i-1) + 1)\\n    \\n    def zigzagpath(self, label, path, level):\\n        while level > 0:\\n            path += [label]\\n            label //= 2\\n            parent_new = pow(2, level) - (label + 1 - pow(2,level-1))\\n            path += [parent_new]\\n            label //= 2\\n            level -= 2\\n        path.append(1)\\n        return path\\n    \\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        level, result = label.bit_length() - 1, []\\n        if level % 2 == 1:\\n            result.append(label)\\n            if label % 2 == 1:\\n                label -= 1\\n            label //= 2\\n            label = pow(2, level) - (label + 1 - pow(2,level-1))\\n            level -= 1\\n        return reversed(self.zigzagpath(label, result, level))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327791,
                "title": "java-array-solution",
                "content": "```\\nclass Solution {\\n    // storing tree in array\\n    public List<Integer> pathInZigZagTree(int n) {\\n        \\n        int arr[] = new int[1000000];   //space for storing tree \\n         \\n        // here don\\'t see the code think that you have to construct array as \\n        //     1 3 2 4 5 6 7 15 14 13 12 11 10 9 8 .........\\n        //     so jump to next comment\\n        \\n        int p = 1;\\n        for(int i = 0 ; i < n ; i++,p++){\\n            int x = (int)Math.pow(2, p-1);\\n            int start = 1,diff = 1;\\n            \\n            if(p%2 != 0){\\n              start = (int)Math.pow(2, p-1);\\n                diff = 1;\\n            } \\n            else{\\n              start = (int)Math.pow(2, p)-1;\\n                diff = -1;                \\n            }\\n            while(x > 0){\\n                if(i == arr.length) break;\\n                x--;\\n                arr[i++] = start;\\n                start += diff;\\n            }\\n            \\n                if(i == arr.length) break;\\n            i--;\\n       }\\n        // find the  n and start finding its parents\\n        //     since \\n        //     child = 2*parent + 1 || 2*parent + 2\\n        //     so in general we ge parent as \\n        //     parent = (child-1)/2 \\n        //      here parent and child are represented through index\\n            \\n        List<Integer> ans = new ArrayList<>();\\n        int i = 0;\\n        while(arr[i] != n){\\n            i++;\\n        }\\n        while(i>0){\\n            ans.add(arr[i]);\\n            i = (i-1)/2;\\n        }\\n        ans.add(arr[0]);\\n        // reverseing the arraylist\\n        Collections.reverse(ans);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    // storing tree in array\\n    public List<Integer> pathInZigZagTree(int n) {\\n        \\n        int arr[] = new int[1000000];   //space for storing tree \\n         \\n        // here don\\'t see the code think that you have to construct array as \\n        //     1 3 2 4 5 6 7 15 14 13 12 11 10 9 8 .........\\n        //     so jump to next comment\\n        \\n        int p = 1;\\n        for(int i = 0 ; i < n ; i++,p++){\\n            int x = (int)Math.pow(2, p-1);\\n            int start = 1,diff = 1;\\n            \\n            if(p%2 != 0){\\n              start = (int)Math.pow(2, p-1);\\n                diff = 1;\\n            } \\n            else{\\n              start = (int)Math.pow(2, p)-1;\\n                diff = -1;                \\n            }\\n            while(x > 0){\\n                if(i == arr.length) break;\\n                x--;\\n                arr[i++] = start;\\n                start += diff;\\n            }\\n            \\n                if(i == arr.length) break;\\n            i--;\\n       }\\n        // find the  n and start finding its parents\\n        //     since \\n        //     child = 2*parent + 1 || 2*parent + 2\\n        //     so in general we ge parent as \\n        //     parent = (child-1)/2 \\n        //      here parent and child are represented through index\\n            \\n        List<Integer> ans = new ArrayList<>();\\n        int i = 0;\\n        while(arr[i] != n){\\n            i++;\\n        }\\n        while(i>0){\\n            ans.add(arr[i]);\\n            i = (i-1)/2;\\n        }\\n        ans.add(arr[0]);\\n        // reverseing the arraylist\\n        Collections.reverse(ans);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2187059,
                "title": "c-o-logn-solution",
                "content": "```\\n//if you draw the tree given in the problem statement you will notice that \\n//depending on the number of #bits of the current label the maximum value is pow(#ofbits)-1 and the size is pow(#bits-1)\\n//for example label = 14, so #bits = 4, so maxvalue = 15, sz = 8, so we will have\\n//15 14 13 12 11 10 9 8,\\n//now if you notice the above elements can be written as,\\n//4+11, 4+10,5+8,5+7,6+5,6+4,7+2,7+1,\\n//where left operand is nothing but the parent of that respective label childs an\\n//another thing is to notice is that the second operand starts from 1 and after every two element skips the next element.\\n//and now if you number the indices you will see a way to find the second operand too,\\n//15 14 13 12 11 10 9 8,\\n//4+11, 4+10,5+8,5+7,6+5,6+4,7+2,7+1,\\n//7,6,5,4,3,2,1,0,\\n//so for label 14 we have to subtract 10 to get the parent 4 , which are being done by,\\n//int ind = abs(sz-abs(maxValue-label)-1); //abs(8-abs(15-14)-1) = 6\\n//int minus = ind + floor(ind/2)+1; 6 + floor(6/2) +1 = 10 , so 14-10 = 4 which is the parent.\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n    \\n        vector<int>ans;\\n        int sz=0,maxValue=0,bits=0;\\n        \\n        while(label>=1){\\n            \\n            bits = log2(label)+1;\\n\\t\\t\\t\\n            maxValue = pow(2,bits)-1; //maxvalue of the level in which the current label is\\n\\t\\t\\tsz = pow(2,bits-1); //number of element in that level\\n            \\n            ans.push_back(label);\\n            int ind = abs(sz-abs(maxValue-label)-1); //index of the current label \\n            int minus = ind + floor(ind/2)+1; // the number upon substracting will give the current labels parent\\n            label = label-minus;\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//if you draw the tree given in the problem statement you will notice that \\n//depending on the number of #bits of the current label the maximum value is pow(#ofbits)-1 and the size is pow(#bits-1)\\n//for example label = 14, so #bits = 4, so maxvalue = 15, sz = 8, so we will have\\n//15 14 13 12 11 10 9 8,\\n//now if you notice the above elements can be written as,\\n//4+11, 4+10,5+8,5+7,6+5,6+4,7+2,7+1,\\n//where left operand is nothing but the parent of that respective label childs an\\n//another thing is to notice is that the second operand starts from 1 and after every two element skips the next element.\\n//and now if you number the indices you will see a way to find the second operand too,\\n//15 14 13 12 11 10 9 8,\\n//4+11, 4+10,5+8,5+7,6+5,6+4,7+2,7+1,\\n//7,6,5,4,3,2,1,0,\\n//so for label 14 we have to subtract 10 to get the parent 4 , which are being done by,\\n//int ind = abs(sz-abs(maxValue-label)-1); //abs(8-abs(15-14)-1) = 6\\n//int minus = ind + floor(ind/2)+1; 6 + floor(6/2) +1 = 10 , so 14-10 = 4 which is the parent.\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n    \\n        vector<int>ans;\\n        int sz=0,maxValue=0,bits=0;\\n        \\n        while(label>=1){\\n            \\n            bits = log2(label)+1;\\n\\t\\t\\t\\n            maxValue = pow(2,bits)-1; //maxvalue of the level in which the current label is\\n\\t\\t\\tsz = pow(2,bits-1); //number of element in that level\\n            \\n            ans.push_back(label);\\n            int ind = abs(sz-abs(maxValue-label)-1); //index of the current label \\n            int minus = ind + floor(ind/2)+1; // the number upon substracting will give the current labels parent\\n            label = label-minus;\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915645,
                "title": "c-beat-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int l=label;\\n        vector<int> ans;\\n        \\n        while(label!=0){\\n            if(label%2!=0){\\n                ans.push_back(label);\\n                --label;\\n                label/=2;\\n            }else{\\n                ans.push_back(label);\\n                label/=2;\\n            }\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        \\n        if(ans.size()%2==0){\\n            for(int i=3; i<=ans.size(); i+=2){\\n                int lower = (1<<(i-1));\\n                int upper = (1<<i)-1;\\n                ans[i-1]=upper-ans[i-1]+lower;\\n            }\\n        }else{\\n            for(int i=2; i<=ans.size(); i+=2){\\n                int lower = (1<<(i-1));\\n                int upper = (1<<i)-1;\\n                ans[i-1]=upper-ans[i-1]+lower;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int l=label;\\n        vector<int> ans;\\n        \\n        while(label!=0){\\n            if(label%2!=0){\\n                ans.push_back(label);\\n                --label;\\n                label/=2;\\n            }else{\\n                ans.push_back(label);\\n                label/=2;\\n            }\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        \\n        if(ans.size()%2==0){\\n            for(int i=3; i<=ans.size(); i+=2){\\n                int lower = (1<<(i-1));\\n                int upper = (1<<i)-1;\\n                ans[i-1]=upper-ans[i-1]+lower;\\n            }\\n        }else{\\n            for(int i=2; i<=ans.size(); i+=2){\\n                int lower = (1<<(i-1));\\n                int upper = (1<<i)-1;\\n                ans[i-1]=upper-ans[i-1]+lower;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668693,
                "title": "c-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/f101aca7-a3ab-4244-b142-fc8760722811_1641391858.5747855.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/0ee8c6aa-e426-4092-9248-d3d4d73a8355_1641391878.2286615.jpeg)\\n\\n\\n```\\n#define rep(i,a,b) for(int i=a ; i<(b) ; ++i )\\n#define endl \"\\\\n\"\\n#define pb push_back\\n#define ff first\\n#define ss second\\n#define endl \"\\\\n\"\\n#define debug(x) cout<<#x<<\" : \"<<x<<\"\\\\n\";\\n#define all(x) x.begin(), x.end()\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> res;\\n        \\n        // flips all the bits of x except the most significant bit //\\n        auto flip = [](int x){\\n        \\n            int lim = 31 - __builtin_clz(x);\\n\\n            int ans = 0;\\n\\n            rep(i,0,lim){\\n                if(!(x&(1<<i)))\\n                ans |= (1<<i);\\n            }\\n\\n            ans |= (x&(1<<lim));\\n\\n            return ans;\\n        };\\n        \\n        while(label!=1){\\n            \\n            res.pb(label);\\n\\n            label = flip(label);\\n\\n            label>>=1; // label/=2;\\n        }\\n        \\n        res.pb(1);\\n        reverse(all(res));\\n        return res; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define rep(i,a,b) for(int i=a ; i<(b) ; ++i )\\n#define endl \"\\\\n\"\\n#define pb push_back\\n#define ff first\\n#define ss second\\n#define endl \"\\\\n\"\\n#define debug(x) cout<<#x<<\" : \"<<x<<\"\\\\n\";\\n#define all(x) x.begin(), x.end()\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> res;\\n        \\n        // flips all the bits of x except the most significant bit //\\n        auto flip = [](int x){\\n        \\n            int lim = 31 - __builtin_clz(x);\\n\\n            int ans = 0;\\n\\n            rep(i,0,lim){\\n                if(!(x&(1<<i)))\\n                ans |= (1<<i);\\n            }\\n\\n            ans |= (x&(1<<lim));\\n\\n            return ans;\\n        };\\n        \\n        while(label!=1){\\n            \\n            res.pb(label);\\n\\n            label = flip(label);\\n\\n            label>>=1; // label/=2;\\n        }\\n        \\n        res.pb(1);\\n        reverse(all(res));\\n        return res; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1586393,
                "title": "c-solution-concise-includes-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int t=1;\\n        while(t<=label){\\n            t=t*2;\\n        }\\n        t/=2;   //Extrating the starting node value which belongs to the same level as label\\n        vector<int> ans;\\n        while(t>0){\\n            ans.push_back(label);\\n            label=(3*t-label-1)/2; //Using the value of label\\'s complement to get the parent value of label\\n            t/=2;\\n            \\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int t=1;\\n        while(t<=label){\\n            t=t*2;\\n        }\\n        t/=2;   //Extrating the starting node value which belongs to the same level as label\\n        vector<int> ans;\\n        while(t>0){\\n            ans.push_back(label);\\n            label=(3*t-label-1)/2; //Using the value of label\\'s complement to get the parent value of label\\n            t/=2;\\n            \\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1364324,
                "title": "java-o-log-n",
                "content": "**Runtime: 0 ms, faster than 100.00% of Java online submissions for Path In Zigzag Labelled Binary Tree.\\nMemory Usage: 36.7 MB, less than 61.44% of Java online submissions for Path In Zigzag Labelled Binary Tree.**\\n```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int level = 1,labels = 1;\\n        List<Integer> res = new ArrayList();\\n        \\n        while(labels < label){\\n            labels += (int)Math.pow(2,level);\\n            level++;\\n        }\\n        \\n        while(label > 0){\\n            res.add(label);\\n            int max = (int)(Math.pow(2,level) - 1);\\n            int min = (int)Math.pow(2,level-1);\\n            label = (int)((max + min - label)/2);\\n            level--;\\n        }\\n        \\n        Collections.reverse(res);\\n        return res;\\n    }\\n}a\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int level = 1,labels = 1;\\n        List<Integer> res = new ArrayList();\\n        \\n        while(labels < label){\\n            labels += (int)Math.pow(2,level);\\n            level++;\\n        }\\n        \\n        while(label > 0){\\n            res.add(label);\\n            int max = (int)(Math.pow(2,level) - 1);\\n            int min = (int)Math.pow(2,level-1);\\n            label = (int)((max + min - label)/2);\\n            level--;\\n        }\\n        \\n        Collections.reverse(res);\\n        return res;\\n    }\\n}a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1328711,
                "title": "easy-and-simple-math-solution-100-faster-o-height-complexity-height-not-found",
                "content": "Every level starts with a power of 2 so by finding the log base of any number we can find its height, through which we can calculate the first element. Then what I\\'ve done is I halved the number and in the upper row we want the mirror of that number. By obesrvation, the difference of the number which we got after dividing by 2 which on subtracting with first element of the level, we can find its distance from the first element of that row. And its mirror which we require also has the same difference but from the last node of that level which is firstNum*2 - 1; And with putting it in loop, we\\'re done.\\n\\n\\n```\\n    public List<Integer> pathInZigZagTree(int num) {\\n        \\n        ArrayList<Integer> answer = new ArrayList<>();\\n        int baseExponent = (int)(Math.log(num)/Math.log(2));\\n        int basePow = 1 << baseExponent;\\n        \\n        int upperPow = basePow*2;\\n        \\n        while(num >= 1){\\n            \\n            answer.add(num);\\n            num = num/2;\\n            \\n            upperPow = basePow;\\n            basePow = basePow/2;\\n            \\n            int diff = num - basePow;\\n            \\n            num = upperPow - 1 - diff;\\n            \\n        }\\n        \\n        Collections.reverse(answer);\\n        \\n        return answer;\\n        \\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<Integer> pathInZigZagTree(int num) {\\n        \\n        ArrayList<Integer> answer = new ArrayList<>();\\n        int baseExponent = (int)(Math.log(num)/Math.log(2));\\n        int basePow = 1 << baseExponent;\\n        \\n        int upperPow = basePow*2;\\n        \\n        while(num >= 1){\\n            \\n            answer.add(num);\\n            num = num/2;\\n            \\n            upperPow = basePow;\\n            basePow = basePow/2;\\n            \\n            int diff = num - basePow;\\n            \\n            num = upperPow - 1 - diff;\\n            \\n        }\\n        \\n        Collections.reverse(answer);\\n        \\n        return answer;\\n        \\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1290114,
                "title": "c-dequeue-bfs",
                "content": "**The idea is to first create a parent array using bfs for our elements\\nand then perform normal traversal using this parent array.\\nWe notice that on even levels we need to seek our last element of queue and push children in the front\\nand the opposite for odd levels. So the best possible data structure to use is deque.**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label)\\n    {\\n        deque<int> q;//Our queue\\n        vector<int> par(1000002,-1);//Parent array\\n        q.push_front(1);\\n        int fl=1,br=0,curr=2;//Flag is fl, br is to break out when our children curr increases to >label\\n        while(!br)\\n        {\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++)\\n            {\\n                int x;\\n                if(fl)\\n                {\\n                    x=q.back();\\n                    q.pop_back();\\n                    q.push_front(curr),q.push_front(curr+1);\\n                }\\n                else\\n                {\\n                    x=q.front();\\n                    q.pop_front();\\n                    q.push_back(curr),q.push_back(curr+1); \\n                }\\n                curr+=2;\\n                //cout<<x<<endl;\\n                par[curr-2]=par[curr-1]=x;\\n                if(curr>label)\\n                {\\n                    br++;\\n                    break;\\n                }\\n            }\\n            fl=1-fl;//This flag determines whether we will (pop and push) or (push and pop) \\n        }\\n        vector<int> ans;\\n        int th=label;\\n        while(th!=-1)//Simple traversal using parent array and 1\\'s parent is -1\\n            ans.push_back(th),th=par[th];\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label)\\n    {\\n        deque<int> q;//Our queue\\n        vector<int> par(1000002,-1);//Parent array\\n        q.push_front(1);\\n        int fl=1,br=0,curr=2;//Flag is fl, br is to break out when our children curr increases to >label\\n        while(!br)\\n        {\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++)\\n            {\\n                int x;\\n                if(fl)\\n                {\\n                    x=q.back();\\n                    q.pop_back();\\n                    q.push_front(curr),q.push_front(curr+1);\\n                }\\n                else\\n                {\\n                    x=q.front();\\n                    q.pop_front();\\n                    q.push_back(curr),q.push_back(curr+1); \\n                }\\n                curr+=2;\\n                //cout<<x<<endl;\\n                par[curr-2]=par[curr-1]=x;\\n                if(curr>label)\\n                {\\n                    br++;\\n                    break;\\n                }\\n            }\\n            fl=1-fl;//This flag determines whether we will (pop and push) or (push and pop) \\n        }\\n        vector<int> ans;\\n        int th=label;\\n        while(th!=-1)//Simple traversal using parent array and 1\\'s parent is -1\\n            ans.push_back(th),th=par[th];\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1188725,
                "title": "c-bit-manipulation",
                "content": "HINT is find the parent of that label in non-zig-zag binary tree\\n\\nconsider , elements at odd level have been reversed in zig-zag binary treee\\n\\nThe parent of the current node is the , reverse element of the respective class of 2 power n - class here refers to elements having same MSB\\n\\nHere , MSB represents the depth of the binary tree element and its reversed element is obtained by , flipping all the bits from MSB+1 to zero \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> ans;\\n        \\n        ans.push_back(label);\\n        while(label != 1){\\n            int msb = 0;\\n            for(int i=32;i>=0;--i){\\n                if(label&(1LL << i)){\\n                    msb = i;   //Depth of that element in the zig-zag binary tree is found\\n                    break;\\n                }\\n            }\\n            int num = 0;\\n            \\n            int i=0;\\n            while(i < msb){\\n                if(!(label & (1LL << i)))num += pow(2,i);\\n                ++i;\\n            }\\n            num += pow(2,msb); //original  element in the non-zig-zag binary tree\\n            ans.push_back(num/2);\\n            label = num/2;     //Its parent\\n            \\n            \\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n***For Recursion Lovers***\\n```\\nclass Solution {\\npublic:\\n\\nvector<int> ans;\\n\\nvoid dfs(int label){\\n    if(label == 1)return ;\\n    \\n        int msb = 0;\\n        for(int i=32;i>=0;--i){\\n            if(label&(1LL << i)){\\n                msb = i; //depth\\n                break;\\n            }\\n        }\\n        int num = 0;\\n\\n        int i=0;\\n        while(i < msb){\\n            if(!(label & (1LL << i)))num += pow(2,i);\\n            ++i;\\n        }\\n        num += pow(2,msb);\\n        label = num/2;   //parent \\n        \\n        dfs(label);\\n        ans.push_back(label);\\n            \\n}\\n    vector<int> pathInZigZagTree(int label) {\\n        \\n        ans.clear();\\n        dfs(label);\\n        ans.push_back(label);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> ans;\\n        \\n        ans.push_back(label);\\n        while(label != 1){\\n            int msb = 0;\\n            for(int i=32;i>=0;--i){\\n                if(label&(1LL << i)){\\n                    msb = i;   //Depth of that element in the zig-zag binary tree is found\\n                    break;\\n                }\\n            }\\n            int num = 0;\\n            \\n            int i=0;\\n            while(i < msb){\\n                if(!(label & (1LL << i)))num += pow(2,i);\\n                ++i;\\n            }\\n            num += pow(2,msb); //original  element in the non-zig-zag binary tree\\n            ans.push_back(num/2);\\n            label = num/2;     //Its parent\\n            \\n            \\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\nvector<int> ans;\\n\\nvoid dfs(int label){\\n    if(label == 1)return ;\\n    \\n        int msb = 0;\\n        for(int i=32;i>=0;--i){\\n            if(label&(1LL << i)){\\n                msb = i; //depth\\n                break;\\n            }\\n        }\\n        int num = 0;\\n\\n        int i=0;\\n        while(i < msb){\\n            if(!(label & (1LL << i)))num += pow(2,i);\\n            ++i;\\n        }\\n        num += pow(2,msb);\\n        label = num/2;   //parent \\n        \\n        dfs(label);\\n        ans.push_back(label);\\n            \\n}\\n    vector<int> pathInZigZagTree(int label) {\\n        \\n        ans.clear();\\n        dfs(label);\\n        ans.push_back(label);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1182182,
                "title": "c-log-n-intuitive-approach-time-better-than-100-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int height=0;\\n        while(pow(2,height)<=label)\\n        {\\n            height=height+1;\\n        }\\n        cout<<height;\\n        vector<int> ans;\\n        ans.push_back(label);\\n        // label=pow(2,height-1)-label/2+pow(2,height-2);\\n         while(height>1)\\n         {\\n             int father=pow(2,height-1)-1-label/2+pow(2,height-2);\\n             label=father;\\n             height=height-1;\\n             ans.push_back(father);\\n         }\\n        // ans.push_back(1);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int height=0;\\n        while(pow(2,height)<=label)\\n        {\\n            height=height+1;\\n        }\\n        cout<<height;\\n        vector<int> ans;\\n        ans.push_back(label);\\n        // label=pow(2,height-1)-label/2+pow(2,height-2);\\n         while(height>1)\\n         {\\n             int father=pow(2,height-1)-1-label/2+pow(2,height-2);\\n             label=father;\\n             height=height-1;\\n             ans.push_back(father);\\n         }\\n        // ans.push_back(1);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1104927,
                "title": "c-faster-than-100-solution",
                "content": "ALGORITHM: \\n\\n1. Find the false parent. ( false parent is half of child 2 i.e. 7 for 14 and 15).\\n2. Find mirror of false parent.\\n3. Push the mirror into stack.\\n4. Reverse the stack into a vector.\\n        \\n---------------------------\\n        \\n-> False parent is half of the child.\\n-> mirror is reflection of node in other half of tree.\\n\\nHere goes the code ,\\n\\n```\\nclass Solution {\\npublic:\\n    int findMirror(int label){\\n        \\n        int x = label;\\n        int level =-1;\\n        \\n        while(x!=0){\\n            x = x>>1;\\n            level++;\\n        }\\n        \\n        int lowerB = 1<<level;\\n        int upperB = (1<<(level+1)) -1;\\n        \\n        int gap = label-lowerB;\\n        \\n        \\n        return abs(upperB-gap);\\n    }\\n    \\n    \\n    vector<int> pathInZigZagTree(int label) {\\n        \\n        stack<int>st;\\n        vector<int>ans;\\n        st.push(label);\\n        \\n        while(label !=1){\\n            \\n            int falseParent = label/2;\\n            int mirror = findMirror(falseParent);\\n            st.push(mirror);\\n            label = mirror;\\n        }\\n        \\n        while(st.size()!=0){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findMirror(int label){\\n        \\n        int x = label;\\n        int level =-1;\\n        \\n        while(x!=0){\\n            x = x>>1;\\n            level++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1020294,
                "title": "intuitive-java-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int level = 0, n = label;\\n        while(n != 0)\\n        {\\n            level ++;\\n            n = n / 2;\\n        }\\n        int[] res = new int[level];\\n        res[level - 1] = label;\\n        for(int l = level - 2; l >= 0; l --)\\n        {\\n            label = label / 2;\\n            if((level - l) % 2 == 1)\\n                res[l] = label;\\n            else\\n                res[l] = (int)Math.pow(2, l + 1) - 1 - label + (int)Math.pow(2, l);\\n        }\\n        List<Integer> l = new ArrayList<>();\\n        for(int e : res)\\n            l.add(e);\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int level = 0, n = label;\\n        while(n != 0)\\n        {\\n            level ++;\\n            n = n / 2;\\n        }\\n        int[] res = new int[level];\\n        res[level - 1] = label;\\n        for(int l = level - 2; l >= 0; l --)\\n        {\\n            label = label / 2;\\n            if((level - l) % 2 == 1)\\n                res[l] = label;\\n            else\\n                res[l] = (int)Math.pow(2, l + 1) - 1 - label + (int)Math.pow(2, l);\\n        }\\n        List<Integer> l = new ArrayList<>();\\n        for(int e : res)\\n            l.add(e);\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1017882,
                "title": "c-solution-faster-than-100-solution-0-ms",
                "content": "I tried to give as obvious variable names as possible.\\nobs_parent is the observed parent\\n```\\nclass Solution {\\npublic:\\n    int getParent(int n){\\n        int level = 0;\\n        int sum = 0;\\n        while(sum < n){\\n            sum += pow(2, level);\\n            level++;\\n        }\\n        level -= 1;\\n        int end = sum - pow(2, level);\\n        int start = (end - pow(2, level - 1)) + 1;\\n        int range = end - start + 1;\\n        int realParent = n / 2;\\n        int obs_parent;\\n        if(realParent < start + (range / 2)){\\n            obs_parent = end - (realParent - start);\\n        }\\n        else{\\n            obs_parent = start + (end - realParent);\\n        }\\n        return obs_parent;\\n    }\\n    \\n    vector<int> pathInZigZagTree(int label) {\\n        if(label == 1)  return {1};\\n        vector<int> result;\\n        result.insert(result.begin(), label);\\n        int parent = 0;\\n        while(parent != 1){\\n            parent = getParent(label);\\n            result.insert(result.begin(), parent);\\n            label = parent;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getParent(int n){\\n        int level = 0;\\n        int sum = 0;\\n        while(sum < n){\\n            sum += pow(2, level);\\n            level++;\\n        }\\n        level -= 1;\\n        int end = sum - pow(2, level);\\n        int start = (end - pow(2, level - 1)) + 1;\\n        int range = end - start + 1;\\n        int realParent = n / 2;\\n        int obs_parent;\\n        if(realParent < start + (range / 2)){\\n            obs_parent = end - (realParent - start);\\n        }\\n        else{\\n            obs_parent = start + (end - realParent);\\n        }\\n        return obs_parent;\\n    }\\n    \\n    vector<int> pathInZigZagTree(int label) {\\n        if(label == 1)  return {1};\\n        vector<int> result;\\n        result.insert(result.begin(), label);\\n        int parent = 0;\\n        while(parent != 1){\\n            parent = getParent(label);\\n            result.insert(result.begin(), parent);\\n            label = parent;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 791993,
                "title": "explained-python-easy-to-understand-1-line-concept",
                "content": "We start from the label and stop till we get 1. \\n\\nLogic: \\nIf num = \\'1001\\' (binary format), then it\\'s parent will be \\'1\\' + inverted(num[1:-1])\\n\\n```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        \\n        res = []\\n        \\n        while label != 1:\\n            res.append(label)\\n            label = int(\\'1\\' + \"\".join(map(lambda x: \\'1\\' if x == \\'0\\' else \\'0\\', format(label, \\'b\\')[1:-1])), 2)\\n        res.append(1)\\n        \\n        return reversed(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        \\n        res = []\\n        \\n        while label != 1:\\n            res.append(label)\\n            label = int(\\'1\\' + \"\".join(map(lambda x: \\'1\\' if x == \\'0\\' else \\'0\\', format(label, \\'b\\')[1:-1])), 2)\\n        res.append(1)\\n        \\n        return reversed(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 657156,
                "title": "java-very-clean-solution-runs-in-0ms",
                "content": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        LinkedList<Integer> list = new LinkedList<>();\\n        while (label != 0) {\\n            list.addFirst(label);\\n            label = getParent(label);\\n        }\\n        \\n        return list;\\n    }\\n    \\n    private int getParent(int label) {\\n        int highestBit = 1 << (int) (Math.log(label) / Math.log(2));\\n        int position = label ^ highestBit;\\n        \\n        int parent = highestBit - position / 2 - 1;\\n        return parent;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        LinkedList<Integer> list = new LinkedList<>();\\n        while (label != 0) {\\n            list.addFirst(label);\\n            label = getParent(label);\\n        }\\n        \\n        return list;\\n    }\\n    \\n    private int getParent(int label) {\\n        int highestBit = 1 << (int) (Math.log(label) / Math.log(2));\\n        int position = label ^ highestBit;\\n        \\n        int parent = highestBit - position / 2 - 1;\\n        return parent;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 634695,
                "title": "python-easy-to-understand-faster-than-91-93-memory-usage-less-than-100",
                "content": "```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n\\t\\n        #Base case\\n        if label == 1:\\n            return [1]\\n        \\n\\t\\t# Calculate the level that the label is present in \\n        level = 1\\n        while True:\\n            if (2**level - 1 >= label):\\n\\t\\t\\t\\tbreak\\n            level += 1\\n            \\t\\n        pathArray = [label]\\n\\t\\t# reduce level by 1 since we have already added label to the path array\\n        level -= 1\\n        \\n\\t\\t# Base case\\n        while level != 0:\\n            \\n\\t\\t\\t# calculating parent \\n            label = 2**(level-1) + ((2**(level+1) - 1 - label)//2)\\n\\t\\t    # insert parent to the top\\n            pathArray.insert(0, label)\\n            level -= 1\\n            \\n        return pathArray\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n\\t\\n        #Base case\\n        if label == 1:\\n            return [1]\\n        \\n\\t\\t# Calculate the level that the label is present in \\n        level = 1\\n        while True:\\n            if (2**level - 1 >= label):\\n\\t\\t\\t\\tbreak\\n            level += 1\\n            \\t\\n        pathArray = [label]\\n\\t\\t# reduce level by 1 since we have already added label to the path array\\n        level -= 1\\n        \\n\\t\\t# Base case\\n        while level != 0:\\n            \\n\\t\\t\\t# calculating parent \\n            label = 2**(level-1) + ((2**(level+1) - 1 - label)//2)\\n\\t\\t    # insert parent to the top\\n            pathArray.insert(0, label)\\n            level -= 1\\n            \\n        return pathArray\\n```",
                "codeTag": "Java"
            },
            {
                "id": 593865,
                "title": "100-time-space-solution-c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        \\n        vector<int>ans;\\n        int level=0;\\n        int x = pow(2,0);\\n        while (label>=x)\\n        {\\n            level++;\\n            x=pow(2,level);\\n        }\\n        ans.push_back(label);\\n        level--;\\n        label/=2;\\n        while(label>=1)\\n        {\\n            label = pow(2,level)-1+pow(2,level-1)-label;\\n            ans.push_back(label);\\n            label/=2;\\n            level--;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    };\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        \\n        vector<int>ans;\\n        int level=0;\\n        int x = pow(2,0);\\n        while (label>=x)\\n        {\\n            level++;\\n            x=pow(2,level);\\n        }\\n        ans.push_back(label);\\n        level--;\\n        label/=2;\\n        while(label>=1)\\n        {\\n            label = pow(2,level)-1+pow(2,level-1)-label;\\n            ans.push_back(label);\\n            label/=2;\\n            level--;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538505,
                "title": "go-golang-0ms-solution",
                "content": "```\\nfunc findLevel(label int) (int, int, int) {\\n    s := 1\\n    n := 0\\n    for {\\n        if label >= s && label < s * 2 {\\n            return n, s, s * 2 - 1\\n        }\\n        n ++\\n        s = s * 2\\n    }\\n}\\n\\nfunc pathInZigZagTree(label int) []int {\\n    level, min, max := findLevel(label)   \\n    res := make([]int, level + 1)\\n    res[level] = label\\n    for label != 1 {\\n        label = label / 2\\n        level --\\n        min = min / 2\\n        max = max / 2\\n        label = max - label + min\\n        res[level] =  label\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc findLevel(label int) (int, int, int) {\\n    s := 1\\n    n := 0\\n    for {\\n        if label >= s && label < s * 2 {\\n            return n, s, s * 2 - 1\\n        }\\n        n ++\\n        s = s * 2\\n    }\\n}\\n\\nfunc pathInZigZagTree(label int) []int {\\n    level, min, max := findLevel(label)   \\n    res := make([]int, level + 1)\\n    res[level] = label\\n    for label != 1 {\\n        label = label / 2\\n        level --\\n        min = min / 2\\n        max = max / 2\\n        label = max - label + min\\n        res[level] =  label\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 486736,
                "title": "ease-javascript-solution",
                "content": "```\\n/**\\n * @param {number} label\\n * @return {number[]}\\n */\\nvar pathInZigZagTree = function(label) {\\n    let level = 0, res = [label];\\n    // get label\\'s level\\n    while(label = parseInt(label / 2)) {\\n        level++;\\n    }\\n    \\n    // 1. every level\\'s number is in [Math.pow(2, level), Math.pow(2, level + 1) - 1]\\n    // 2. node[level - 1] = parseInt(res[level] / 2)\\n    // 3. res[level - 1] = (Math.pow(2, level) + Math.pow(2, level + 1) - 1) - node[level - 1] is the parent node we need;\\n    for(let i = level - 1; i >= 0; i--) {\\n        let sum = (2 ** i) + (2 ** (i + 1)) - 1;\\n        let val = parseInt(res[0] / 2);\\n        res.unshift(sum - val);\\n    }\\n    return res;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} label\\n * @return {number[]}\\n */\\nvar pathInZigZagTree = function(label) {\\n    let level = 0, res = [label];\\n    // get label\\'s level\\n    while(label = parseInt(label / 2)) {\\n        level++;\\n    }\\n    \\n    // 1. every level\\'s number is in [Math.pow(2, level), Math.pow(2, level + 1) - 1]\\n    // 2. node[level - 1] = parseInt(res[level] / 2)\\n    // 3. res[level - 1] = (Math.pow(2, level) + Math.pow(2, level + 1) - 1) - node[level - 1] is the parent node we need;\\n    for(let i = level - 1; i >= 0; i--) {\\n        let sum = (2 ** i) + (2 ** (i + 1)) - 1;\\n        let val = parseInt(res[0] / 2);\\n        res.unshift(sum - val);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 473751,
                "title": "easy-to-understand-python3-solution-with-explanation",
                "content": "The logic consists of three components:\\n* Any number will always be in level : floor(log2(number)). Therefore given the label we can get the level it will be in.\\n* In a normal tree, the leftmost node in a level will have value : 2^(level - 1)\\n* In a normal tree, the rightmost node in a level will have value: 2^(level) - 1\\n* In the zigzag tree, the leftmost and rightmost node limits are interchanged alternatively. However since we are going to add these values, it does not matter.\\n* From the tree and the limits for a level above, we can see that for any node, its parent is : (leftmost limit + rightmost limit - label) // 2\\n* This implies parent(label) = (2^(level - 1) + 2^(level) - 1 - label) // 2.\\n* We can do this operation repeatedly to trace the path to the parent.\\n```\\nimport math\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        res = [label]\\n        level = math.floor(math.log(label, 2)) + 1\\n        currentNode = label\\n        while level > 1:\\n            parent = (2**(level-1) + 2**(level) - 1 - currentNode) // 2\\n            res.insert(0, parent)\\n            currentNode = parent\\n            level -= 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        res = [label]\\n        level = math.floor(math.log(label, 2)) + 1\\n        currentNode = label\\n        while level > 1:\\n            parent = (2**(level-1) + 2**(level) - 1 - currentNode) // 2\\n            res.insert(0, parent)\\n            currentNode = parent\\n            level -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 443958,
                "title": "c-100-runtime-100-mem",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n       int low = log2 (label);\\n        vector<int> ans (low+1);\\n        int cur = 0;\\n        ans[0] = 1;\\n        ans[low] = label;\\n        for (int i = low - 1; i > 0; i--) {\\n            cur = (pow(2, low+1) - ans[i+1] + pow(2, low) - 1)/2;\\n            ans[i] = cur;\\n            low--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n       int low = log2 (label);\\n        vector<int> ans (low+1);\\n        int cur = 0;\\n        ans[0] = 1;\\n        ans[low] = label;\\n        for (int i = low - 1; i > 0; i--) {\\n            cur = (pow(2, low+1) - ans[i+1] + pow(2, low) - 1)/2;\\n            ans[i] = cur;\\n            low--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 427306,
                "title": "golang-bottom-to-top-solution-cost-logn",
                "content": "```\\nfunc pathInZigZagTree(label int) []int {\\n\\tvar res []int\\n\\tres = append(res, label)\\n\\tvar layer_num int = math.Ilogb(float64(label))\\n    if layer_num == 0{\\n        return res\\n    }\\n\\tfor layer_num > 1{\\n\\t\\tvar parent int = label/2\\n\\t\\tlayer_min := int(math.Pow(2,float64(layer_num - 1)))\\n\\t\\tlayer_max := int(math.Pow(2,float64(layer_num)) - 1)\\n\\t\\tparent = layer_max - (parent - layer_min)\\n\\t\\tlabel = parent\\n\\t\\tlayer_num--\\n\\t\\tres = append(res, parent)\\n\\t}\\n\\tres = append(res, 1)\\n\\tfor i, j := 0, len(res)-1; i < j; i, j = i+1, j-1 {\\n\\t\\tres[i], res[j] = res[j], res[i]\\n\\t} \\n\\treturn res\\n}",
                "solutionTags": [],
                "code": "```\\nfunc pathInZigZagTree(label int) []int {\\n\\tvar res []int\\n\\tres = append(res, label)\\n\\tvar layer_num int = math.Ilogb(float64(label))\\n    if layer_num == 0{\\n        return res\\n    }\\n\\tfor layer_num > 1{\\n\\t\\tvar parent int = label/2\\n\\t\\tlayer_min := int(math.Pow(2,float64(layer_num - 1)))\\n\\t\\tlayer_max := int(math.Pow(2,float64(layer_num)) - 1)\\n\\t\\tparent = layer_max - (parent - layer_min)\\n\\t\\tlabel = parent\\n\\t\\tlayer_num--\\n\\t\\tres = append(res, parent)\\n\\t}\\n\\tres = append(res, 1)\\n\\tfor i, j := 0, len(res)-1; i < j; i, j = i+1, j-1 {\\n\\t\\tres[i], res[j] = res[j], res[i]\\n\\t} \\n\\treturn res\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 359041,
                "title": "python-3-short-solution",
                "content": "```\\nfrom math import log\\n\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        line, result = int(log(label, 2)), [label]\\n        \\n        while line:            \\n\\t\\t    # calculate offset to the left or right side\\n            offset = result[-1] - 2 ** line\\n\\t\\t\\t# subtract current offset and parent offset\\n            result.append(result[-1] - offset - (offset // 2 + 1))\\n            line -= 1\\n            \\n        return result[::-1]\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom math import log\\n\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        line, result = int(log(label, 2)), [label]\\n        \\n        while line:            \\n\\t\\t    # calculate offset to the left or right side\\n            offset = result[-1] - 2 ** line\\n\\t\\t\\t# subtract current offset and parent offset\\n            result.append(result[-1] - offset - (offset // 2 + 1))\\n            line -= 1\\n            \\n        return result[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325180,
                "title": "o-logn-java-solution-with-explanation",
                "content": "![image](https://assets.leetcode.com/users/arif32/image_1562050357.png)\\n\\n```\\n    public List<Integer> pathInZigZagTree(int label) {\\n\\t\\tList<Integer> result = new LinkedList<Integer>();\\n\\t\\tresult.add(label);\\n        int height = findHeight(label);\\n\\t\\twhile (label != 1) {\\n\\t\\t\\tint parent = label / 2;\\n\\t\\t\\t--height;\\n\\t\\t\\tint start = (int) (Math.pow(2, height));\\n\\t\\t\\tint end = start + (int) (Math.pow(2, height)) - 1;\\n\\t\\t\\tlabel = start + (end - parent); // reverse index\\n\\t\\t\\tresult.add(0, label);\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n\\n\\tint findHeight(int n) {\\n\\t\\tint height = 0;\\n\\t\\twhile (n != 1) {\\n\\t\\t\\tn = n / 2;\\n\\t\\t\\theight++;\\n\\t\\t}\\n\\t\\treturn height;\\n\\t}\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public List<Integer> pathInZigZagTree(int label) {\\n\\t\\tList<Integer> result = new LinkedList<Integer>();\\n\\t\\tresult.add(label);\\n        int height = findHeight(label);\\n\\t\\twhile (label != 1) {\\n\\t\\t\\tint parent = label / 2;\\n\\t\\t\\t--height;\\n\\t\\t\\tint start = (int) (Math.pow(2, height));\\n\\t\\t\\tint end = start + (int) (Math.pow(2, height)) - 1;\\n\\t\\t\\tlabel = start + (end - parent); // reverse index\\n\\t\\t\\tresult.add(0, label);\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n\\n\\tint findHeight(int n) {\\n\\t\\tint height = 0;\\n\\t\\twhile (n != 1) {\\n\\t\\t\\tn = n / 2;\\n\\t\\t\\theight++;\\n\\t\\t}\\n\\t\\treturn height;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 324913,
                "title": "dew-it-simple-logic-o-log-n-100-100",
                "content": "## The Approach\\nThings we need to note are as follows:\\n* MAX value at each level is:\\ndepth 1: **1** = 2^1 - 1\\ndepth 2: **3** = 2^2 - 1\\ndepth 3: **7** = 2^3 - 1\\n.\\n.\\ndepth n: **x** = ***(2^n) - 1***\\n* Similarly, the MIN value at each level is ***2^(n-1)***\\n* In a **normal tree** (without zig zag), the parent of any node n will have the value [n/2]\\n=>Example: parent of 3 is [3/2] = 1\\n* The parent of a node n in a **normal tree** would be at index (n/2 - MIN value of previous level)\\n=>Example, parent of 10 is 5. MIN value of the level is 4. Hence index of 5 in previous row is 1\\n* In a **zig zag tree**, the index of the parent will be inverted. If there are r elements in the array, index i inverted will be [r-1-i] (first element becomes last and so on)\\n=> If we take the same example of 10, the index in the normal tree is 1\\n=> Number of elements in the parent row = 4 (values from 4 to 7)\\n=> Index in the inverted row is 4 - 1 - 1 = 2\\n=> This simply means that the actual parent of 10 in a zig zag tree is the second element starting from 4 (which happens to be 6 as shown in the example image in the description of the problem)\\n\\nWe use this basic idea to compute parents for labels and further recursively find their parents.\\n\\nNote:\\n* We first construct the path starting with required label and then go upwards in the tree. Because of this, we need to invert the answer arraylist before returning\\n* A variable named \"seed\" is frequently seen in my code. It is simply the smallest element in the row that we are currently looking at\\n\\n## The Code\\n\\n```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> ans = new ArrayList<>();\\n\\t\\t\\n        int seed = 1;\\n        while(seed <= label) seed *= 2;\\n        seed /= 2;\\n        get(label, ans, seed);\\n\\t\\t\\n        int n = ans.size();\\n        for(int i=0; i<n/2; ++i) {\\n            int temp = ans.get(i);\\n            ans.set(i, ans.get(n-1-i));\\n            ans.set(n-1-i, temp);\\n        }\\n\\t\\t\\n        return ans;\\n    }\\n    \\n    private void get(int label, List<Integer> ans, int seed) {\\n        if(label > 0) {\\n            ans.add(label);\\n            int newLabel = label/2 - seed/2;\\n            newLabel = seed - 1 - newLabel;\\n            get(newLabel, ans, seed/2);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> ans = new ArrayList<>();\\n\\t\\t\\n        int seed = 1;\\n        while(seed <= label) seed *= 2;\\n        seed /= 2;\\n        get(label, ans, seed);\\n\\t\\t\\n        int n = ans.size();\\n        for(int i=0; i<n/2; ++i) {\\n            int temp = ans.get(i);\\n            ans.set(i, ans.get(n-1-i));\\n            ans.set(n-1-i, temp);\\n        }\\n\\t\\t\\n        return ans;\\n    }\\n    \\n    private void get(int label, List<Integer> ans, int seed) {\\n        if(label > 0) {\\n            ans.add(label);\\n            int newLabel = label/2 - seed/2;\\n            newLabel = seed - 1 - newLabel;\\n            get(newLabel, ans, seed/2);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063088,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n     // taken help\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(label);\\n        int xx = (int)(Math.log(label)/Math.log(2));\\n        for(int i=0;i<xx;i++)\\n        {\\n            int x = (int)Math.pow(2,(int)(Math.log((int)label/2)/Math.log(2))+1)-1;\\n            label = x - (int)label/2 + (x+1)/2 ;\\n            ans.add(0,label);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n     // taken help\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(label);\\n        int xx = (int)(Math.log(label)/Math.log(2));\\n        for(int i=0;i<xx;i++)\\n        {\\n            int x = (int)Math.pow(2,(int)(Math.log((int)label/2)/Math.log(2))+1)-1;\\n            label = x - (int)label/2 + (x+1)/2 ;\\n            ans.add(0,label);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591629,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int l = label;\\n        int n{};\\n        //getting the depth of required node\\n        while(l){\\n            n++;\\n            l >>= 1; // dividing by 2\\n        }\\n\\n        vector<int> ans(n);\\n        ans[n-1] = label;\\n        for(int i = n-2; i>=0;i--){\\n            ans[i] = (3*(1<<(i+1)) - ans[i+1] - 1)/2; \\n            // (1 << i) = 2 raise to power i\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int l = label;\\n        int n{};\\n        //getting the depth of required node\\n        while(l){\\n            n++;\\n            l >>= 1; // dividing by 2\\n        }\\n\\n        vector<int> ans(n);\\n        ans[n-1] = label;\\n        for(int i = n-2; i>=0;i--){\\n            ans[i] = (3*(1<<(i+1)) - ans[i+1] - 1)/2; \\n            // (1 << i) = 2 raise to power i\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340653,
                "title": "michael-scott-says-he-beat-this-100-on-java",
                "content": "# Intuition\\nMichael is busy at the moment(sleeping), just look at the code it is self explanatory \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(label);\\n        int xx = (int)(Math.log(label)/Math.log(2));\\n        for(int i=0;i<xx;i++)\\n        {\\n            int x = (int)Math.pow(2,(int)(Math.log((int)label/2)/Math.log(2))+1)-1;\\n            label = x - (int)label/2 + (x+1)/2 ;\\n            ans.add(0,label);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(label);\\n        int xx = (int)(Math.log(label)/Math.log(2));\\n        for(int i=0;i<xx;i++)\\n        {\\n            int x = (int)Math.pow(2,(int)(Math.log((int)label/2)/Math.log(2))+1)-1;\\n            label = x - (int)label/2 + (x+1)/2 ;\\n            ans.add(0,label);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224831,
                "title": "c-solution-beats-100-ii-simple-and-clean-code",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> r;\\n        r.push_back(label);\\n        int d=log2(label),m;\\n        while(d)\\n        {\\n            m=pow(2,d)+pow(2,d+1)-1-label;  //mirror w.r.to non zig zag version \\n            // OR you can do pow(2,d-1)+pow(2,d)-1-label/2;\\n            //4+7-(14/2) == 4+7-7 == 4 \\n            r.push_back(m/2);\\n            label=m/2;\\n            d--;\\n        }\\n        reverse(r.begin(),r.end());\\n        return r;\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> r;\\n        r.push_back(label);\\n        int d=log2(label),m;\\n        while(d)\\n        {\\n            m=pow(2,d)+pow(2,d+1)-1-label;  //mirror w.r.to non zig zag version \\n            // OR you can do pow(2,d-1)+pow(2,d)-1-label/2;\\n            //4+7-(14/2) == 4+7-7 == 4 \\n            r.push_back(m/2);\\n            label=m/2;\\n            d--;\\n        }\\n        reverse(r.begin(),r.end());\\n        return r;\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137820,
                "title": "python-bitwise-solution-with-explanation",
                "content": "Let us take an example of 4th level as  `[8, 9, 10, 11, 12, 13, 14, 15]`\\n```\\n[8, 9, 10, 11, 12, 13, 14, 15]   |   [\\'1000\\', \\'1001\\', \\'1010\\', \\'1011\\', \\'1100\\', \\'1101\\', \\'1110\\', \\'1111\\']\\n[15, 14, 13, 12, 11, 10, 9, 8]   |   [\\'1111\\', \\'1110\\', \\'1101\\', \\'1100\\', \\'1011\\', \\'1010\\', \\'1001\\', \\'1000\\']\\n```\\nWe can see that the zigzag fashion leads `ALL bits fliped EXCEPT the 1st \\'1\\'`\\n```\\n\\'1000\\' -> \\'1111\\', \\'1001\\' -> \\'1110\\', \\'1010\\'->\\'1101\\', \\'1011\\' -> \\'1100\\'\\n```\\nSo we can do bits flipping to get the parent node\\n```\\ndef pathInZigZagTree(self, x: int) -> List[int]:\\n\\tres = [x]\\n\\twhile(x>1):\\n\\t\\tx >>= 1                          # move to the parent level \\n\\t\\tx = x^(1<<(x.bit_length()-1))-1  # flipping all bits EXCEPT the 1st \\'1\\'\\n\\t\\tres.append(x)\\n\\treturn res[::-1]\\n```\\n\\nIf you are not comfortable with bitwise computation, the following line also works for `flipping bits `\\n```\\nx = int(\\'1\\'+\\'\\'.join(\\'1\\' if i==\\'0\\' else \\'0\\' for i in bin(x)[3:]), 2)\\n```",
                "solutionTags": [],
                "code": "```\\n[8, 9, 10, 11, 12, 13, 14, 15]   |   [\\'1000\\', \\'1001\\', \\'1010\\', \\'1011\\', \\'1100\\', \\'1101\\', \\'1110\\', \\'1111\\']\\n[15, 14, 13, 12, 11, 10, 9, 8]   |   [\\'1111\\', \\'1110\\', \\'1101\\', \\'1100\\', \\'1011\\', \\'1010\\', \\'1001\\', \\'1000\\']\\n```\n```\\n\\'1000\\' -> \\'1111\\', \\'1001\\' -> \\'1110\\', \\'1010\\'->\\'1101\\', \\'1011\\' -> \\'1100\\'\\n```\n```\\ndef pathInZigZagTree(self, x: int) -> List[int]:\\n\\tres = [x]\\n\\twhile(x>1):\\n\\t\\tx >>= 1                          # move to the parent level \\n\\t\\tx = x^(1<<(x.bit_length()-1))-1  # flipping all bits EXCEPT the 1st \\'1\\'\\n\\t\\tres.append(x)\\n\\treturn res[::-1]\\n```\n```\\nx = int(\\'1\\'+\\'\\'.join(\\'1\\' if i==\\'0\\' else \\'0\\' for i in bin(x)[3:]), 2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3136729,
                "title": "python-solution-with-explanation-easy-to-understand",
                "content": "* How many levels will be there if n=14? The ans is 3 (level 0,level 1, level 2 and level3)\\n* How many levels will be there if n=16? The ans is 4.\\n* The number of levels in this binary tree will be [log2(n)] where [x] represents floor value. [3.99] = 3\\n* The levels in this tree are odd levels and even levels all odd,even levels follows same patterns respectively.\\n* for all odd level the parent can be calculated as `label = 2**(level-1)+(2**(level-1)-pos-1)`. i.e. decreasing respective positions.\\n* for all even level parent can be calculated as `2**(level) - 1 - pos`. Increasing respective positions\\n* for odd level example suppose we have` label = 13 and level = 3` its parent label will be `2**(3-1)+(2**(3-1)-((13-(2**3))//2-1)` that is `4+4-2-1` that is 5.\\n* for even level example suppose we have `label = 5 and level = 2` its parent label will be `2**(2) - 1 - (5-2**2)//2` that is 3.\\n\\n```\\nfrom math import log2,floor\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        level = floor(log2(label))\\n        ans = [label]\\n        while label!=1:\\n            c = label - 2**level\\n            pos = c//2\\n            if level&1:\\n                label = 2**(level-1)+(2**(level-1)-pos-1)\\n            else:\\n                label = 2**(level) - 1 - pos\\n            level -= 1\\n            ans.append(label)\\n        return ans[::-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\nfrom math import log2,floor\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        level = floor(log2(label))\\n        ans = [label]\\n        while label!=1:\\n            c = label - 2**level\\n            pos = c//2\\n            if level&1:\\n                label = 2**(level-1)+(2**(level-1)-pos-1)\\n            else:\\n                label = 2**(level) - 1 - pos\\n            level -= 1\\n            ans.append(label)\\n        return ans[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026396,
                "title": "beats-100",
                "content": "# Code\\n```\\nint parent(int n){\\n    int org=n/2;\\n    if(n==1) return -1;\\n    int x=log2(n)-1;\\n    return pow(2,x+1)-1-(org-pow(2,x));\\n}\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int>res;\\n        while(label!=-1){\\n            res.push_back(label);\\n            label=parent(label);\\n        }\\n        reverse (res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint parent(int n){\\n    int org=n/2;\\n    if(n==1) return -1;\\n    int x=log2(n)-1;\\n    return pow(2,x+1)-1-(org-pow(2,x));\\n}\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int>res;\\n        while(label!=-1){\\n            res.push_back(label);\\n            label=parent(label);\\n        }\\n        reverse (res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990123,
                "title": "simple-python-solution",
                "content": "# Intuition\\nFirst Calculate at which level the target value will appear and then \\ncalculate the path backword. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        def check_level(label, p):\\n            while True:\\n                if label <= 2 **(p+1) -1:\\n                    return p\\n                else:\\n                    p += 1\\n        level = check_level(label,0)\\n        \\n        def find_path(level, label):\\n            ans = [label]\\n            while level > 0:\\n                parent = (2**(level+1) - 1) + (2**(level)) - label\\n                ans.append(parent//2)\\n                label = parent//2\\n                level -= 1\\n            return ans[::-1]\\n        return  find_path(level,label)   \\n\\n\\n                 \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        def check_level(label, p):\\n            while True:\\n                if label <= 2 **(p+1) -1:\\n                    return p\\n                else:\\n                    p += 1\\n        level = check_level(label,0)\\n        \\n        def find_path(level, label):\\n            ans = [label]\\n            while level > 0:\\n                parent = (2**(level+1) - 1) + (2**(level)) - label\\n                ans.append(parent//2)\\n                label = parent//2\\n                level -= 1\\n            return ans[::-1]\\n        return  find_path(level,label)   \\n\\n\\n                 \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742318,
                "title": "flip-bits",
                "content": "```\\nint change(int &n)\\n{\\n    n=n>>1;\\n    int bits=log2(n)+1;\\n    \\n    for(int i=0;i<bits-1;i++)//No need to flip MSB\\n    {\\n        n=n^(1<<i);\\n    }\\n    return n;\\n}\\nclass Solution \\n{\\npublic:\\n    vector<int> pathInZigZagTree(int label) \\n    {\\n        vector<int>ans;\\n        ans.push_back(label);\\n        while(label>1)\\n        {\\n            int x=change(label);\\n            ans.push_back(x);\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Bit Manipulation",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "class Solution \\n{\\npublic:\\n    vector<int> pathInZigZagTree(int label) \\n    {\\n        vector<int>ans;\\n        ans.push_back(label);\\n        while(label>1)\\n        {\\n            int x=change(label);\\n            ans.push_back(x);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2725585,
                "title": "c-o-logn-simple-observation",
                "content": "Based on the parent at previous layer and corresponding number if level is reversed.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int d = log2(label)+1;\\n        \\n        vector<int> ans;\\n        \\n        vector<int> temp;\\n        int n = label;\\n        while(n>0){\\n            temp.push_back(n);\\n            n /= 2;\\n        }\\n            \\n        for(int i=0; i<temp.size(); i++){\\n            int curr = temp[i];\\n                \\n            if(i%2 == 0){\\n                ans.push_back(curr);\\n            }\\n            else{\\n                int start = pow(2, d-1);\\n                int end = pow(2, d) - 1;\\n                    \\n                int fromstart = curr - start;\\n                int fromend = end - fromstart;\\n                    \\n                ans.push_back(fromend);\\n            }    \\n            \\n            d--;\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int d = log2(label)+1;\\n        \\n        vector<int> ans;\\n        \\n        vector<int> temp;\\n        int n = label;\\n        while(n>0){\\n            temp.push_back(n);\\n            n /= 2;\\n        }\\n            \\n        for(int i=0; i<temp.size(); i++){\\n            int curr = temp[i];\\n                \\n            if(i%2 == 0){\\n                ans.push_back(curr);\\n            }\\n            else{\\n                int start = pow(2, d-1);\\n                int end = pow(2, d) - 1;\\n                    \\n                int fromstart = curr - start;\\n                int fromend = end - fromstart;\\n                    \\n                ans.push_back(fromend);\\n            }    \\n            \\n            d--;\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465385,
                "title": "c-easy-to-understand-faster-than-100-of-c-online-submissions",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    vector<int> pathInZigZagTree(int label) \\n    {\\n        int num=0;\\n        int level=0;\\n        while(label>num)\\n            num+=pow(2,level++);\\n        vector<int> ans(level);\\n        int i;\\n        for(i=level;i>1;i--)\\n        {\\n            cout<<i<<\"-\";\\n            ans[i-1]=label;\\n            int low=pow(2,i-2);\\n            int high=pow(2,i-1)-1;\\n            if(i%2!=0)\\n            {\\n                label=high-(int)(label-pow(2,i-1))/2;\\n                cout<<label<<\" \";\\n            }\\n            else\\n            {\\n                label=low+(pow(2,i)-1-label)/2;\\n                cout<<label<<\" \";\\n            }\\n        }\\n        ans[i-1]=label;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    vector<int> pathInZigZagTree(int label) \\n    {\\n        int num=0;\\n        int level=0;\\n        while(label>num)\\n            num+=pow(2,level++);\\n        vector<int> ans(level);\\n        int i;\\n        for(i=level;i>1;i--)\\n        {\\n            cout<<i<<\"-\";\\n            ans[i-1]=label;\\n            int low=pow(2,i-2);\\n            int high=pow(2,i-1)-1;\\n            if(i%2!=0)\\n            {\\n                label=high-(int)(label-pow(2,i-1))/2;\\n                cout<<label<<\" \";\\n            }\\n            else\\n            {\\n                label=low+(pow(2,i)-1-label)/2;\\n                cout<<label<<\" \";\\n            }\\n        }\\n        ans[i-1]=label;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2440245,
                "title": "cpp-easy-0-ms-100-faster",
                "content": "The approach is to find the level of node i.e for 14 it is 3(0 based leveling ) and for 26 it is 4.Then find parent of node if the tree was given in normal order like 1,2,3,4,.....\\nlevel is stored in var n and then res is used to store correct node is it was given in normal order.\\n for eg in case of 14 the normal order would be 9 and for 10 it would be 13...\\n so to get normal node value I added first and last value of level and subtracted the given node...\\n this is all about approach.\\n \\n Try dry running code if u didn\\'t get it\\n\\n```\\nvoid solve(int l,vector<int> &ans)\\n    {\\n        if(l==1)\\n        {\\n            ans.push_back(1);\\n            return ;\\n        }\\n            \\n        int n=log2(l);\\n        int res=(pow(2,n+1)-1+pow(2,n)-l)/2;\\n        solve(res,ans);\\n        ans.push_back(l);\\n    }\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int>  ans;\\n        solve(label,ans);\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvoid solve(int l,vector<int> &ans)\\n    {\\n        if(l==1)\\n        {\\n            ans.push_back(1);\\n            return ;\\n        }\\n            \\n        int n=log2(l);\\n        int res=(pow(2,n+1)-1+pow(2,n)-l)/2;\\n        solve(res,ans);\\n        ans.push_back(l);\\n    }\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int>  ans;\\n        solve(label,ans);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2314445,
                "title": "recursive-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(int label,vector<int>& ans)\\n    {\\n        ans.push_back(label);\\n         if(label<=1)\\n             return ;\\n        \\n        int rowNumber=0;\\n        long long n=1;\\n        while(label>=n)\\n        {\\n            rowNumber++;\\n            n=n*2;  \\n        }\\n        long long start=n/2;\\n        int index=(label-start)/2 +1;\\n        solve(start/2+(start/2-index),ans);\\n    }\\n    vector<int> pathInZigZagTree(int label) {\\n       vector<int> ans;\\n        solve(label,ans);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    void solve(int label,vector<int>& ans)\\n    {\\n        ans.push_back(label);\\n         if(label<=1)\\n             return ;\\n        \\n        int rowNumber=0;\\n        long long n=1;\\n        while(label>=n)\\n        {\\n            rowNumber++;\\n            n=n*2;  \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2302857,
                "title": "new-method-to-solve-this-queston-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> res;\\n        vector<int> tree;\\n        int l=1;\\n        int k=1;\\n        while(l+k<=label)\\n        {\\n            k=k*2;\\n             l+=k;\\n        }\\n        k=k*2;\\n         l+=k;\\n       // cout<<l<<endl;\\n        for(int i=1;i<=l;i++)\\n        {\\n            tree.push_back(i);\\n        }\\n        \\n        int st=1;\\n        int i=0;\\n        int turn=1;\\n        while(i+st-1<l)\\n        {\\n            //cout<<i<<\" \"<<st<<endl;\\n            if(turn==0)\\n            {\\n                reverse(tree.begin()+i,tree.begin()+i+st);\\n                turn =1;\\n            }\\n            else\\n                turn=0;\\n            i=i+st;\\n            st=st*2;\\n        }\\n        \\n        if(turn==0)\\n        {\\n            reverse(tree.begin()+i,tree.end());\\n        }\\n       \\n        int x=-1;\\n        for(int i=0;i<l;i++)\\n        {\\n           if(tree[i]==label)\\n           {\\n               x=i;\\n               break;\\n           }\\n        }\\n        \\n        while(x>0)\\n        {\\n           // cout<<x<<e\\n            res.push_back(tree[x]);\\n            x=(x-1)/2;\\n        }\\n        res.push_back(tree[0]);\\n        reverse(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> res;\\n        vector<int> tree;\\n        int l=1;\\n        int k=1;\\n        while(l+k<=label)\\n        {\\n            k=k*2;\\n             l+=k;\\n        }\\n        k=k*2;\\n         l+=k;\\n       // cout<<l<<endl;\\n        for(int i=1;i<=l;i++)\\n        {\\n            tree.push_back(i);\\n        }\\n        \\n        int st=1;\\n        int i=0;\\n        int turn=1;\\n        while(i+st-1<l)\\n        {\\n            //cout<<i<<\" \"<<st<<endl;\\n            if(turn==0)\\n            {\\n                reverse(tree.begin()+i,tree.begin()+i+st);\\n                turn =1;\\n            }\\n            else\\n                turn=0;\\n            i=i+st;\\n            st=st*2;\\n        }\\n        \\n        if(turn==0)\\n        {\\n            reverse(tree.begin()+i,tree.end());\\n        }\\n       \\n        int x=-1;\\n        for(int i=0;i<l;i++)\\n        {\\n           if(tree[i]==label)\\n           {\\n               x=i;\\n               break;\\n           }\\n        }\\n        \\n        while(x>0)\\n        {\\n           // cout<<x<<e\\n            res.push_back(tree[x]);\\n            x=(x-1)/2;\\n        }\\n        res.push_back(tree[0]);\\n        reverse(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2256129,
                "title": "68-tc-and-72-sc-easy-python-solution",
                "content": "```\\ndef pathInZigZagTree(self, label: int) -> List[int]:\\n\\tans = [label]\\n\\twhile(label != 1):\\n\\t\\tpar1 = label//2\\n\\t\\tx = int(log(par1, 2))\\n\\t\\tdiff = par1 - 2**x\\n\\t\\tlabel = 2**(x+1)-1 - diff\\n\\t\\tans.append(label)\\n\\treturn ans[::-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef pathInZigZagTree(self, label: int) -> List[int]:\\n\\tans = [label]\\n\\twhile(label != 1):\\n\\t\\tpar1 = label//2\\n\\t\\tx = int(log(par1, 2))\\n\\t\\tdiff = par1 - 2**x\\n\\t\\tlabel = 2**(x+1)-1 - diff\\n\\t\\tans.append(label)\\n\\treturn ans[::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2247937,
                "title": "o-logn-observation-on-calculating-the-parent-of-the-label",
                "content": "Looking at the complete binary tree we can deduce that the level of the given label is ```floor(log2(label))+1```.\\n\\nLet\\'s say the level of the current label is ```level```. For this ```level``` the node\\'s value will vary from ```2^level - 1``` to ```2^(level-1)```.\\n\\nLet\\'s say the current level is **even**. At this ```level``` there are ```2^(level-1)``` nodes among these nodes every 2 nodes from ```2^(level-1)``` nodes is assigned to a parent node.\\n\\nTo find the parent label for a node with label ```n``` at the current level we can subtract ```n``` from the node at the extreme left i.e. ```2^level - 1```(even level). Let\\'s say the different is ```diff```. \\nWe can safely say that ```diff/2``` is the position of the parent node with respect to the left most node at the parent level.\\nFor example:\\nfor label 14 (level = 4), the leftmost node\\'s label is 15, the difference is 1. Position ```pos``` of the parent is 1/2 = 0 with respect to the left most node at level 3 i.e ```2^(3-1)```(odd level), so the parent node\\'s label is ```2^(3-1)``` + ```pos```(relative position from leftmost node i.e 0), the parent node\\'s label turns out to be 4.\\n\\n\\nIf the ```level``` is **odd** then the left most node\\'s value becomes ```2^(level-1)``` so the difference ```diff``` becomes ```label - 2^(level-1)```, ```pos``` is ```diff/2```. Parent node\\'s label (even level) becomes ```2^parentLevel - 1 - pos``` since the parent level is even for the sequence is reversed.\\n\\nC++ solution:\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int lev = floor(log2(label))+1;\\n        vector<int> ans;\\n        while(lev>0) {\\n            // cout<<label<<\" \"<<lev<<endl;\\n            ans.push_back(label);\\n            if (lev%2==0) {\\n                int prev = pow(2,lev) - label - 1; // differece with the leftmost node and divided by 2 to get the position pos\\n                prev/=2;\\n                lev--; // level decreased to parent\\'s level\\n                label = pow(2,lev-1)+prev;\\n            } else {\\n                int prev = label - pow(2,lev-1);\\n                prev/=2;\\n                lev--;\\n                label = pow(2,lev)-prev-1;\\n            }\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```floor(log2(label))+1```\n```level```\n```level```\n```2^level - 1```\n```2^(level-1)```\n```level```\n```2^(level-1)```\n```2^(level-1)```\n```n```\n```n```\n```2^level - 1```\n```diff```\n```diff/2```\n```pos```\n```2^(3-1)```\n```2^(3-1)```\n```pos```\n```level```\n```2^(level-1)```\n```diff```\n```label - 2^(level-1)```\n```pos```\n```diff/2```\n```2^parentLevel - 1 - pos```\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int lev = floor(log2(label))+1;\\n        vector<int> ans;\\n        while(lev>0) {\\n            // cout<<label<<\" \"<<lev<<endl;\\n            ans.push_back(label);\\n            if (lev%2==0) {\\n                int prev = pow(2,lev) - label - 1; // differece with the leftmost node and divided by 2 to get the position pos\\n                prev/=2;\\n                lev--; // level decreased to parent\\'s level\\n                label = pow(2,lev-1)+prev;\\n            } else {\\n                int prev = label - pow(2,lev-1);\\n                prev/=2;\\n                lev--;\\n                label = pow(2,lev)-prev-1;\\n            }\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2238990,
                "title": "c-solution-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool rev_b(bool flag)\\n    {\\n        if(flag == true) return false;\\n        return true;\\n    }\\n    \\n    void vec_arrange(vector<int> &v, bool flag)\\n    {\\n        if(flag == true)\\n        {\\n           reverse(v.begin(), v.end());\\n        }\\n    }\\n    \\n    vector<int> pathInZigZagTree(int label) {\\n        \\n        vector<vector<int>> v;\\n        vector<int> temp;\\n        int count = 1, i=1, j=0;\\n        bool flag = true;\\n        \\n        while(true)\\n        {\\n            for(int tmp = 0; tmp<count; tmp++)\\n            {\\n                temp.push_back(i);\\n                i++;\\n                if(i == label+1)\\n                {\\n                    j = 1;\\n                }\\n            }\\n            flag = rev_b(flag);\\n            vec_arrange(temp, flag);\\n            v.push_back(temp);\\n            temp.clear();\\n            if(j == 1) break;\\n            count = 2*count;\\n        }\\n        \\n        i = v.size()-1;\\n        j = v[i].size()-1;\\n        \\n        for(int k=0; k<j+1; k++)\\n        {\\n            if(v[i][k] == label)\\n            {\\n                j = k;\\n                break;\\n            }\\n        }\\n        \\n        while(i>-1 && j>-1)\\n        {\\n            temp.push_back(v[i][j]);\\n            i--;\\n            j = ceil(j/2);\\n        }\\n        \\n        reverse(temp.begin(), temp.end());        \\n     \\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool rev_b(bool flag)\\n    {\\n        if(flag == true) return false;\\n        return true;\\n    }\\n    \\n    void vec_arrange(vector<int> &v, bool flag)\\n    {\\n        if(flag == true)\\n        {\\n           reverse(v.begin(), v.end());\\n        }\\n    }\\n    \\n    vector<int> pathInZigZagTree(int label) {\\n        \\n        vector<vector<int>> v;\\n        vector<int> temp;\\n        int count = 1, i=1, j=0;\\n        bool flag = true;\\n        \\n        while(true)\\n        {\\n            for(int tmp = 0; tmp<count; tmp++)\\n            {\\n                temp.push_back(i);\\n                i++;\\n                if(i == label+1)\\n                {\\n                    j = 1;\\n                }\\n            }\\n            flag = rev_b(flag);\\n            vec_arrange(temp, flag);\\n            v.push_back(temp);\\n            temp.clear();\\n            if(j == 1) break;\\n            count = 2*count;\\n        }\\n        \\n        i = v.size()-1;\\n        j = v[i].size()-1;\\n        \\n        for(int k=0; k<j+1; k++)\\n        {\\n            if(v[i][k] == label)\\n            {\\n                j = k;\\n                break;\\n            }\\n        }\\n        \\n        while(i>-1 && j>-1)\\n        {\\n            temp.push_back(v[i][j]);\\n            i--;\\n            j = ceil(j/2);\\n        }\\n        \\n        reverse(temp.begin(), temp.end());        \\n     \\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090667,
                "title": "c-o-log-n-solution-easy-to-understand",
                "content": "\\nclass Solution {\\npublic:\\n  \\n  vector<int> pathInZigZagTree(int label) \\n  {  \\n  \\n\\t   vector<int>result;        \\n        \\n\\t\\tint depth = log2(label);\\n        while(depth>=0)\\n        {\\n            result.insert(result.begin(),label);\\n           \\n\\t\\t   int left=pow(2,depth-1);\\n\\t\\t  int right=pow(2,depth)-1;\\n\\t\\t  label=left+(right-label/2);\\n          \\n\\t\\t  depth--;\\n        \\n\\t\\t}\\n\\t\\t\\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "Math",
                    "Tree"
                ],
                "code": "class Solution {\\npublic:\\n  \\n  vector<int> pathInZigZagTree(int label) \\n  {  \\n  \\n\\t   vector<int>result;        \\n        \\n\\t\\tint depth = log2(label);\\n        while(depth>=0)\\n        {\\n            result.insert(result.begin(),label);\\n           \\n\\t\\t   int left=pow(2,depth-1);\\n\\t\\t  int right=pow(2,depth)-1;\\n\\t\\t  label=left+(right-label/2);\\n          \\n\\t\\t  depth--;\\n        \\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2023504,
                "title": "c-faster-than-100",
                "content": "```\\n    vector<int> pathInZigZagTree(int label) {\\n         vector<int> result;\\n         int level = logBase2(label);\\n        result.push_back(label);\\n       \\n        while(label > 1){\\n            int l = pow(2,level-2);\\n            int h = pow(2,level-1) -1;\\n            label = label/2;\\n            label = l + (h-label);\\n            result.push_back(label);\\n            level--;\\n        }\\n        \\n        reverse(result.begin(), result.end());\\n        return result;\\n    }\\n    \\n    int logBase2(int num){\\n        int res = 0;\\n        while(num>0){\\n            num >>= 1;\\n            res++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<int> pathInZigZagTree(int label) {\\n         vector<int> result;\\n         int level = logBase2(label);\\n        result.push_back(label);\\n       \\n        while(label > 1){\\n            int l = pow(2,level-2);\\n            int h = pow(2,level-1) -1;\\n            label = label/2;\\n            label = l + (h-label);\\n            result.push_back(label);\\n            level--;\\n        }\\n        \\n        reverse(result.begin(), result.end());\\n        return result;\\n    }\\n    \\n    int logBase2(int num){\\n        int res = 0;\\n        while(num>0){\\n            num >>= 1;\\n            res++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1966346,
                "title": "java-fast-solution-0ms-100-beat",
                "content": "![image](https://assets.leetcode.com/users/images/93f53438-7db3-414f-b024-c6adcaa4ee6d_1650450661.2556148.png)\\n\\n```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> answer = new ArrayList<>();\\n        int parent = label;\\n        answer.add(parent);\\n        while (parent != 1) {\\n            int depth = (int) (Math.log(parent) / Math.log(2));\\n            int offset = (int) Math.pow(2, depth + 1) - 1 - parent;\\n            parent = ((int) Math.pow(2, depth) + offset) / 2;\\n            answer.add(parent);\\n        }\\n        Collections.reverse(answer);\\n        return answer; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> answer = new ArrayList<>();\\n        int parent = label;\\n        answer.add(parent);\\n        while (parent != 1) {\\n            int depth = (int) (Math.log(parent) / Math.log(2));\\n            int offset = (int) Math.pow(2, depth + 1) - 1 - parent;\\n            parent = ((int) Math.pow(2, depth) + offset) / 2;\\n            answer.add(parent);\\n        }\\n        Collections.reverse(answer);\\n        return answer; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954889,
                "title": "java-logarithmic-run-time-base2",
                "content": "Computer height of the Binary Tree - logN / log2 (rows)\\n\\nFor each row in Binary Tree - \\n1. Find start and end node indices\\n2. Find correct node index of the label in the row if the nodes were indexed in the right order -\\n\\ta. Compute offset [How far the label is from the end]\\n\\tb. Actual Index = start + offset\\n```\\n\\tpublic List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> nodes = new LinkedList<>();\\n\\n        int depth = (int) (Math.log(label) / Math.log(2));\\n        while (depth >= 0) {\\n            nodes.add(0, label);\\n\\n            int start = (int) (Math.pow(2, depth));\\n            int end = start * 2 - 1;\\n\\n            int offset = end - label;\\n            int actualIndex = start + offset;\\n\\n            label = actualIndex / 2;\\n            depth--;\\n        }\\n\\n        return nodes;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> nodes = new LinkedList<>();\\n\\n        int depth = (int) (Math.log(label) / Math.log(2));\\n        while (depth >= 0) {\\n            nodes.add(0, label);\\n\\n            int start = (int) (Math.pow(2, depth));\\n            int end = start * 2 - 1;\\n\\n            int offset = end - label;\\n            int actualIndex = start + offset;\\n\\n            label = actualIndex / 2;\\n            depth--;\\n        }\\n\\n        return nodes;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1862396,
                "title": "simple-and-easy-solution-in-c",
                "content": "```\\nvector<int> pathInZigZagTree(int label) {\\n//last level value\\n        int last_l_val = 1;\\n\\t\\t//curr level value\\n        int curr_l_max = 0;\\n        while(curr_l_max<label){\\n            curr_l_max+=last_l_val;   // 1 3 7 15 .....\\n            last_l_val*=2; // 1 2 4 8 16\\n        }\\n        last_l_val/=2;          // 8\\n        vector<int> v;\\n        while(label!=1){\\n            v.push_back(label);                      // 13 5 3 \\n            int compliment = (3*last_l_val-label-1);    // first find the compliment of label means original children of label\\'s parent \\n            label = compliment/2;\\n            last_l_val/=2;\\n        }\\n\\t\\t// push 1 to vector\\n        v.push_back(1);\\n\\t\\t//reverse the vector \\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\nvector<int> pathInZigZagTree(int label) {\\n//last level value\\n        int last_l_val = 1;\\n\\t\\t//curr level value\\n        int curr_l_max = 0;\\n        while(curr_l_max<label){\\n            curr_l_max+=last_l_val;   // 1 3 7 15 .....\\n            last_l_val*=2; // 1 2 4 8 16\\n        }\\n        last_l_val/=2;          // 8\\n        vector<int> v;\\n        while(label!=1){\\n            v.push_back(label);                      // 13 5 3 \\n            int compliment = (3*last_l_val-label-1);    // first find the compliment of label means original children of label\\'s parent \\n            label = compliment/2;\\n            last_l_val/=2;\\n        }\\n\\t\\t// push 1 to vector\\n        v.push_back(1);\\n\\t\\t//reverse the vector \\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1666985,
                "title": "c-using-basic-mathematics-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int x) \\n    {\\n        vector<int> path;\\n        while(x)\\n        {\\n            path.push_back(x);\\n            x /= 2;\\n        }\\n        \\n        reverse(path.begin(),path.end());\\n        \\n        if(path.size() & 1)\\n        {\\n            for(int  i = 0; i < path.size(); i++)\\n            {\\n                if(!(i & 1)) continue;\\n                //reverse value\\n                int beg = pow(2,i);\\n                int end = pow(2, i + 1) - 1;\\n                \\n                path[i] = end + beg - path[i];\\n            }\\n        }\\n        else\\n        {\\n            for(int i = 0; i < path.size(); i++)\\n            {\\n                if(i & 1) continue;\\n                //reverse value\\n                int beg = pow(2,i);\\n                int end = pow(2, i + 1) - 1;\\n                \\n                path[i] = end + beg - path[i];\\n            }\\n        }\\n        \\n        return path;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int x) \\n    {\\n        vector<int> path;\\n        while(x)\\n        {\\n            path.push_back(x);\\n            x /= 2;\\n        }\\n        \\n        reverse(path.begin(),path.end());\\n        \\n        if(path.size() & 1)\\n        {\\n            for(int  i = 0; i < path.size(); i++)\\n            {\\n                if(!(i & 1)) continue;\\n                //reverse value\\n                int beg = pow(2,i);\\n                int end = pow(2, i + 1) - 1;\\n                \\n                path[i] = end + beg - path[i];\\n            }\\n        }\\n        else\\n        {\\n            for(int i = 0; i < path.size(); i++)\\n            {\\n                if(i & 1) continue;\\n                //reverse value\\n                int beg = pow(2,i);\\n                int end = pow(2, i + 1) - 1;\\n                \\n                path[i] = end + beg - path[i];\\n            }\\n        }\\n        \\n        return path;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1641795,
                "title": "python3-o-logn-commented",
                "content": "```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        mn=mx=total=1\\n        while not (mn<=label<=mx): #go to the depth level of the label in our tree\\n            total*=2               #total=number of nodes in each level\\n            mn=total               #mx = maximum value in each level (rightmost element)\\n            mx=total*2-1           #mn = minimum value in each level (leftmost element)\\n        res=collections.deque()\\n        while label>0:    \\n            res.appendleft(label)\\n            mx//=2                 #go up one level in the tree and update mx,mn and label\\n            mn//=2                 #the new label is it\\'s parent (label//2), but mirrored from the center of the level\\n            label//=2\\n            diff=abs(mx-label)\\n            label=mn+diff\\n        return res            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        mn=mx=total=1\\n        while not (mn<=label<=mx): #go to the depth level of the label in our tree\\n            total*=2               #total=number of nodes in each level\\n            mn=total               #mx = maximum value in each level (rightmost element)\\n            mx=total*2-1           #mn = minimum value in each level (leftmost element)\\n        res=collections.deque()\\n        while label>0:    \\n            res.appendleft(label)\\n            mx//=2                 #go up one level in the tree and update mx,mn and label\\n            mn//=2                 #the new label is it\\'s parent (label//2), but mirrored from the center of the level\\n            label//=2\\n            diff=abs(mx-label)\\n            label=mn+diff\\n        return res            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1497450,
                "title": "c-o-log-n-beats-100-with-explanation",
                "content": "Instead of creating the whole tree we can only find the parents of the node.\\nAs the tree to be constructed would have been full binary tree i.e. each node has two children this property can be exploited.\\nFor array representation of a full binary tree each node at index i would hv its children at 2*i and 2*i +1 index or each node would have its parent at i/2 index.\\nBut in our case the tree defined in a zig zag manner so we need to find the distance from last node at its level and add it to the first node of the level giving us the parent node.\\nif it was a normal binary tree parent would have been i/2 so now we check the distance of i/2 from last node (2*h-1 where h is level) at the level and add it to the first node(pow(2,h-1));\\neg.\\nfor node 14:\\nfor normal tree parent would have been 7 but now it will be 2^3-1(number of nodes covered till this level) - 7 (i/2) + 2^2(first node)\\n\\n\\n```\\n vector<int> pathInZigZagTree(int label) {\\n        vector<int>a;\\n        int p=label;\\n        int h=log2(label); //find height till which we need to traverse\\n        while(p!=1)\\n        {\\n            a.push_back(p);\\n            p=p/2;\\n            if(p==1)\\n            {\\n                break;\\n            }\\n            p=pow(2,h)-1-p+pow(2,h-1);\\n            h--;\\n        }\\n        a.push_back(1);\\n        reverse(a.begin(),a.end());\\n        return a;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n vector<int> pathInZigZagTree(int label) {\\n        vector<int>a;\\n        int p=label;\\n        int h=log2(label); //find height till which we need to traverse\\n        while(p!=1)\\n        {\\n            a.push_back(p);\\n            p=p/2;\\n            if(p==1)\\n            {\\n                break;\\n            }\\n            p=pow(2,h)-1-p+pow(2,h-1);\\n            h--;\\n        }\\n        a.push_back(1);\\n        reverse(a.begin(),a.end());\\n        return a;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1488208,
                "title": "c-o-n-100-faster-space-o-1",
                "content": "\\t1. every time add the element into res and then invert the node.\\n\\t2. if it was from left to right then it would have been label/2 always but in this case have to invert.\\n\\t3. just take the sum of previous level first element from left and right then substract the label/2 and then \\n\\t4. recursion will do the rest of the work.\\n\\n\\tvector<int> res;\\n    void rec(int label){\\n        if(label==1)  {  res.push_back(1); return ;}\\n        res.push_back(label) ;\\n        int level = (int)log2(label) ;\\n        int element = label/2 ;\\n        level--;\\n        int sum = 0;\\n        int t = pow(2,level) ;sum+=t ;\\n        sum = sum + pow(2,(level+1))-1;\\n        rec(sum-element) ;\\n    }\\n    vector<int> pathInZigZagTree(int label) {\\n        rec(label) ;reverse(res.begin(),res.end()) ;return res;\\n    }",
                "solutionTags": [
                    "C",
                    "Math",
                    "Recursion"
                ],
                "code": "\\t1. every time add the element into res and then invert the node.\\n\\t2. if it was from left to right then it would have been label/2 always but in this case have to invert.\\n\\t3. just take the sum of previous level first element from left and right then substract the label/2 and then \\n\\t4. recursion will do the rest of the work.\\n\\n\\tvector<int> res;\\n    void rec(int label){\\n        if(label==1)  {  res.push_back(1); return ;}\\n        res.push_back(label) ;\\n        int level = (int)log2(label) ;\\n        int element = label/2 ;\\n        level--;\\n        int sum = 0;\\n        int t = pow(2,level) ;sum+=t ;\\n        sum = sum + pow(2,(level+1))-1;\\n        rec(sum-element) ;\\n    }\\n    vector<int> pathInZigZagTree(int label) {\\n        rec(label) ;reverse(res.begin(),res.end()) ;return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1437241,
                "title": "c-o-logn-solution-100-faster-runtime",
                "content": "```\\nvector<int> pathInZigZagTree(int label) {\\n        vector<int> result;\\n        while(label != 1){\\n            int row = floor(log2(label)) + 1;\\n            int parent = label / 2;\\n            int starting = (1 << (row - 2));\\n            int diff = parent - starting;\\n            int ending = (1 << (row - 1)) - 1;\\n            result.push_back(label);\\n            label = ending - diff;\\n        }\\n        result.push_back(1);\\n        reverse(result.begin(), result.end());\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> pathInZigZagTree(int label) {\\n        vector<int> result;\\n        while(label != 1){\\n            int row = floor(log2(label)) + 1;\\n            int parent = label / 2;\\n            int starting = (1 << (row - 2));\\n            int diff = parent - starting;\\n            int ending = (1 << (row - 1)) - 1;\\n            result.push_back(label);\\n            label = ending - diff;\\n        }\\n        result.push_back(1);\\n        reverse(result.begin(), result.end());\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1428745,
                "title": "java-o-n-simple-solution-with-explanation",
                "content": "**Idea / Approach**\\nSo I would start to approach the problem from the information we have. \\n1. We know the id of the node whose path is to be found. \\n2. We can find the height of the level in which it is there as h\\n3. The number of nodes until the previous height is **2^(h-1)-1**.\\n4. So the position of the current node in the level alone would be **label - (num nodes until prev level)**\\n5. So if the node is in xth position in its level, the parent would be in **(x-1)/2** th position from the end **in its level** . Or we can say (x-1)/2 parents will be there before the desired parent in that level.\\n6. The end in its level will have id of? Thats right from point 3 we get the max id in that level and we have to reduce the number of parents that come before the current node as **(2^(h-1)-1-(x-1)/2)**.\\n\\nHope you find it useful!! :) \\n**Recursive:**\\n```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int h = 1+(int)(Math.log(label)/Math.log(2)+1e-10);\\n        int[] pow = new int[h+1]; // (not too important) storing the required powers so that it doesn\\'t have to be recalculated for each level\\n        pow[0]=1;\\n        for(int i=1;i<=h;i++)\\n            pow[i]=pow[i-1]*2;\\n        ArrayList<Integer> res =new ArrayList<>();\\n        rec(h, label, res, pow);\\n        Collections.reverse(res);\\n        return res;\\n    }\\n    void rec(int h, int num, ArrayList<Integer> path, int[] pow){\\n        if(h==0) return;\\n        path.add(num);\\n        int count = num-(pow[h-1]-1);\\n        int next = pow[h-1]-1 - (count-1)/2;\\n        rec(h-1, next, path, pow);\\n    }\\n}\\n```\\nI later saw that it can be converted to an iterative solution which just keeps reducing height and runs the quickest !!\\n**Iterative:**\\n```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int h = 1+(int)(Math.log(label)/Math.log(2)+1e-10);\\n        int[] pow = new int[h+1]; \\n        pow[0]=1;\\n        for(int i=1;i<=h;i++)\\n            pow[i]=pow[i-1]*2;\\n        ArrayList<Integer> res =new ArrayList<>(h);\\n        int count, next;\\n        while(--h>=0){ // since we need only the previous  level height and not the current height we can reduce and use the same for finding the number of elements in the previous level and the parent label\\n            res.add(label);\\n            count = label-(pow[h]-1);\\n            label = pow[h]-1 - (count-1)/2;\\n        }\\n        Collections.reverse(res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int h = 1+(int)(Math.log(label)/Math.log(2)+1e-10);\\n        int[] pow = new int[h+1]; // (not too important) storing the required powers so that it doesn\\'t have to be recalculated for each level\\n        pow[0]=1;\\n        for(int i=1;i<=h;i++)\\n            pow[i]=pow[i-1]*2;\\n        ArrayList<Integer> res =new ArrayList<>();\\n        rec(h, label, res, pow);\\n        Collections.reverse(res);\\n        return res;\\n    }\\n    void rec(int h, int num, ArrayList<Integer> path, int[] pow){\\n        if(h==0) return;\\n        path.add(num);\\n        int count = num-(pow[h-1]-1);\\n        int next = pow[h-1]-1 - (count-1)/2;\\n        rec(h-1, next, path, pow);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int h = 1+(int)(Math.log(label)/Math.log(2)+1e-10);\\n        int[] pow = new int[h+1]; \\n        pow[0]=1;\\n        for(int i=1;i<=h;i++)\\n            pow[i]=pow[i-1]*2;\\n        ArrayList<Integer> res =new ArrayList<>(h);\\n        int count, next;\\n        while(--h>=0){ // since we need only the previous  level height and not the current height we can reduce and use the same for finding the number of elements in the previous level and the parent label\\n            res.add(label);\\n            count = label-(pow[h]-1);\\n            label = pow[h]-1 - (count-1)/2;\\n        }\\n        Collections.reverse(res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365821,
                "title": "log-n-well-documented-most-optimized",
                "content": "class Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        \\n        // Finding the initial level of node \"label\"\\n        int level = log2(label) + 1;\\n        \\n        // Here sum is equal to lower value and higher value of that particular level.\\n        int sum = pow(2,level-1) + pow(2,level)-1;\\n        \\n        // Take a \"ans\" vector to store the ans.\\n        vector<int>  ans;\\n        \\n        // Run a loop while the value of level is greater than 0.\\n        while(label > 0)\\n        {\\n            // Store the current \"label\" in \"ans\" vector\\n            ans.push_back(label);\\n            \\n            // Find the alternative to \"label\" as below because the parent of \"label\" is half the value of its alternative value (observation).\\n            int alt = sum - label;\\n            \\n            // Find parent\\n            label = alt/2;\\n            \\n            // Find the find for next iteration.\\n            sum = (sum - 1) / 2;\\n        }\\n        \\n        // Since we have stored the elements in reverse order, So we need to reverse our answer.\\n        reverse(ans.begin(), ans.end());\\n        \\n        // Return \"ans\"\\n        return ans;\\n    }\\n};\\n\\nTime : O(logN) \\nEvery time our next lebel decreases by half.\\n\\nSpace: O(logN)\\nWe are storing our answer.\\n\\nIf you still don\\'t understand, comment down, I will give an example.",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        \\n        // Finding the initial level of node \"label\"\\n        int level = log2(label) + 1;\\n        \\n        // Here sum is equal to lower value and higher value of that particular level.\\n        int sum = pow(2,level-1) + pow(2,level)-1;\\n        \\n        // Take a \"ans\" vector to store the ans.\\n        vector<int>  ans;\\n        \\n        // Run a loop while the value of level is greater than 0.\\n        while(label > 0)\\n        {\\n            // Store the current \"label\" in \"ans\" vector\\n            ans.push_back(label);\\n            \\n            // Find the alternative to \"label\" as below because the parent of \"label\" is half the value of its alternative value (observation).\\n            int alt = sum - label;\\n            \\n            // Find parent\\n            label = alt/2;\\n            \\n            // Find the find for next iteration.\\n            sum = (sum - 1) / 2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1351221,
                "title": "c-100-0ms-o-log-n-time-and-memory",
                "content": "Idea: Calculate the path for a normal complete binary tree and flip the nodes alternatively.\\n\\n1. The node with value `label` will be at a level with height `log2(label)  + 1`.\\n2. Path from node to root for a normal complete binary tree is computed as the floor of division by 2 continuously until we reach root. Eg:- `14 -> 7 -> 3 -> 1`.\\n3. In a Zig-Zag tree, the nodes at levels with same parity as the level of `label` remain unchanged while the others are flipped.\\n4. To flip a node, we need to observe that the offset of the node from the start of that level and the offset of the flipped node from the end of that level is equal. Eg: `10 flips to 13, 10 - 8 == 15 - 13`. \\n5. Thus, to flip a node at level `i`, we find the offset from the start, which is `val - 2^i` and subtract this from the last node, which is `2^(i+1) - 1`. So, the value of flipped node = `2^(i + 1) - (val - 2^i)  = 2^(i+1) + 2^i - val`\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n\\t\\t// Level of node with value = label\\n        int lg = log2(label)+1;\\n\\t\\t// Don\\'t flip the last node\\n        bool flip = false;\\n\\t\\t// Store powers of 2 for faster computation\\n        vector<int> path(lg, 0), powers(lg+1, 1);\\n        for(int i=1; i<lg+1; i++)\\n            powers[i] = 2*powers[i-1];\\n        for(int i=lg-1; i>-1; i--) {\\n\\t\\t\\t// Store the original path\\n            path[i] = label;\\n            label /= 2;\\n\\t\\t\\t// Check if current level\\'s parity is different from that of last node\\n            if(flip)\\n                path[i] = powers[i+1] + powers[i] - path[i] - 1;\\n\\t\\t\\t// Flip the nodes alternatively\\n            flip = !flip;\\n        }\\n        return path;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n\\t\\t// Level of node with value = label\\n        int lg = log2(label)+1;\\n\\t\\t// Don\\'t flip the last node\\n        bool flip = false;\\n\\t\\t// Store powers of 2 for faster computation\\n        vector<int> path(lg, 0), powers(lg+1, 1);\\n        for(int i=1; i<lg+1; i++)\\n            powers[i] = 2*powers[i-1];\\n        for(int i=lg-1; i>-1; i--) {\\n\\t\\t\\t// Store the original path\\n            path[i] = label;\\n            label /= 2;\\n\\t\\t\\t// Check if current level\\'s parity is different from that of last node\\n            if(flip)\\n                path[i] = powers[i+1] + powers[i] - path[i] - 1;\\n\\t\\t\\t// Flip the nodes alternatively\\n            flip = !flip;\\n        }\\n        return path;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317308,
                "title": "c-log-n-solution",
                "content": "Generate the path in a normally ordered binary tree, then reverse the nodes that are out of order. The tricky bit here is to realize that you need to reverse the nodes not on whether or not they were actually reversed, but whether the layers in between are in the wrong order.\\n```\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> res;\\n        int count=1;\\n        while (label){\\n            res.push_back(label);\\n            label/=2;\\n        }\\n        reverse(res.begin(), res.end());\\n        for (int i=1 + !(res.size()%2);i<res.size();i+=2){\\n            int r=(1<<(i+1))-1; //Max Number for this layer of the tree\\n            int l=(1<<i); //Min number\\n            int dist=res[i]-l; //Reflect the distance\\n            res[i]=r-dist;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> res;\\n        int count=1;\\n        while (label){\\n            res.push_back(label);\\n            label/=2;\\n        }\\n        reverse(res.begin(), res.end());\\n        for (int i=1 + !(res.size()%2);i<res.size();i+=2){\\n            int r=(1<<(i+1))-1; //Max Number for this layer of the tree\\n            int l=(1<<i); //Min number\\n            int dist=res[i]-l; //Reflect the distance\\n            res[i]=r-dist;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314575,
                "title": "java-solution-o-log-n-time-o-log-n-space-using-power-of-two-series-trick",
                "content": "[https://github.com/2018hsridhar/Leetcode_Solutions/blob/master/leetcode_1104.java](http://)\\n```\\n/*\\nTHOUGHT PROCESS : \\n\\n1104. Path In Zigzag Labelled Binary Tree\\nURL = https://leetcode.com/problems/path-in-zigzag-labelled-binary-tree/\\n\\nAlways ask if each node, in a binary tree, is uniquely labeled or not ( provided we know if the bTree is also labeled ) \\nFactorization ( into {2,3} ) can guarantee convergence to the value of 1 here\\n\\nEasiest way to think of problem : utilize 2-power sequence\\nlen = 6 [ 1,2,4,8,16,32 ]\\nlen = 7 [ 1,2,4,8,16,32,64]\\nlen = 8 [ 1,2,4,8,16,32,64,128]\\n=> Quick to built intuition from here!\\n\\n\\nEdge cases\\n1\\n2\\n3\\n127\\n128\\n17\\n14\\n1000000\\n\\nComputational Complexity : \\nTime = O(log(N)) + O(N) + O(N/2) = O(N) [ break down into three segments, per loop and for list reversal ( assume optimized here ) ]\\nSpace = O(N) [ due to array list ]\\n\\nBetter idea : use the reverse iterator?\\n\\n*/\\nclass Solution \\n{\\n    public List<Integer> pathInZigZagTree(int label) \\n    {\\n        // [1] Generate the binary sequence ( divide by 2 sequence ) until you hit 1 ( you are guaranteed to hit 1, as you hit {2,3} at some point )\\n        ArrayList<Integer> traversal = new ArrayList<Integer>();\\n        while(label != 1)\\n        {\\n            traversal.add(label);\\n            label /= 2;\\n        }\\n        // Add label ( equal to 1 now! ) \\n        traversal.add(label);\\n        \\n        // [2] Reverse iterate over this arrayList now : convert to array\\n        Collections.reverse(traversal);\\n        int n = traversal.size();\\n        \\n        // [3] Perform computation on array, based on parity of traversal size\\n        if(n % 2 == 0) // len = 6 [ 1,2,4,8,16,32 ]\\n        {\\n            for(int i = 2; i < n; i += 2)\\n            {\\n                int replVal = (((int)Math.pow(2,i) * 3 ) - 1 ) - traversal.get(i);\\n                traversal.set(i,replVal);\\n            }\\n        }\\n        else if ( n % 2 == 1)\\n        {\\n            for(int i = 1; i < n; i += 2)\\n            {\\n                int replVal = (((int)Math.pow(2,i) * 3 ) - 1 ) - traversal.get(i);\\n                traversal.set(i, replVal);\\n            }\\n        }\\n        \\n        return traversal;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Tree"
                ],
                "code": "```\\n/*\\nTHOUGHT PROCESS : \\n\\n1104. Path In Zigzag Labelled Binary Tree\\nURL = https://leetcode.com/problems/path-in-zigzag-labelled-binary-tree/\\n\\nAlways ask if each node, in a binary tree, is uniquely labeled or not ( provided we know if the bTree is also labeled ) \\nFactorization ( into {2,3} ) can guarantee convergence to the value of 1 here\\n\\nEasiest way to think of problem : utilize 2-power sequence\\nlen = 6 [ 1,2,4,8,16,32 ]\\nlen = 7 [ 1,2,4,8,16,32,64]\\nlen = 8 [ 1,2,4,8,16,32,64,128]\\n=> Quick to built intuition from here!\\n\\n\\nEdge cases\\n1\\n2\\n3\\n127\\n128\\n17\\n14\\n1000000\\n\\nComputational Complexity : \\nTime = O(log(N)) + O(N) + O(N/2) = O(N) [ break down into three segments, per loop and for list reversal ( assume optimized here ) ]\\nSpace = O(N) [ due to array list ]\\n\\nBetter idea : use the reverse iterator?\\n\\n*/\\nclass Solution \\n{\\n    public List<Integer> pathInZigZagTree(int label) \\n    {\\n        // [1] Generate the binary sequence ( divide by 2 sequence ) until you hit 1 ( you are guaranteed to hit 1, as you hit {2,3} at some point )\\n        ArrayList<Integer> traversal = new ArrayList<Integer>();\\n        while(label != 1)\\n        {\\n            traversal.add(label);\\n            label /= 2;\\n        }\\n        // Add label ( equal to 1 now! ) \\n        traversal.add(label);\\n        \\n        // [2] Reverse iterate over this arrayList now : convert to array\\n        Collections.reverse(traversal);\\n        int n = traversal.size();\\n        \\n        // [3] Perform computation on array, based on parity of traversal size\\n        if(n % 2 == 0) // len = 6 [ 1,2,4,8,16,32 ]\\n        {\\n            for(int i = 2; i < n; i += 2)\\n            {\\n                int replVal = (((int)Math.pow(2,i) * 3 ) - 1 ) - traversal.get(i);\\n                traversal.set(i,replVal);\\n            }\\n        }\\n        else if ( n % 2 == 1)\\n        {\\n            for(int i = 1; i < n; i += 2)\\n            {\\n                int replVal = (((int)Math.pow(2,i) * 3 ) - 1 ) - traversal.get(i);\\n                traversal.set(i, replVal);\\n            }\\n        }\\n        \\n        return traversal;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309157,
                "title": "c-math-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        \\n        \\n        int level;\\n        int parent;\\n        int sum;\\n        int temp;\\n        \\n        \\n        vector<int> ans;\\n        ans.push_back(label);\\n        while(label > 1){\\n            \\n            parent = label/2;\\n            level = (31 - __builtin_clz(parent));\\n            temp = pow(2, level);\\n            sum = temp + 2*temp - 1;\\n            label = sum - parent;\\n            ans.insert(ans.begin(), label);\\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        \\n        \\n        int level;\\n        int parent;\\n        int sum;\\n        int temp;\\n        \\n        \\n        vector<int> ans;\\n        ans.push_back(label);\\n        while(label > 1){\\n            \\n            parent = label/2;\\n            level = (31 - __builtin_clz(parent));\\n            temp = pow(2, level);\\n            sum = temp + 2*temp - 1;\\n            label = sum - parent;\\n            ans.insert(ans.begin(), label);\\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1302083,
                "title": "c-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int t) {\\n        if(t==1){\\n            return {1};\\n        }\\n        int i=0;\\n        while((1<<i) <= t){\\n            i++;\\n        }\\n        vector<int>ans;\\n        while(t){\\n            ans.push_back(t);\\n            \\n            if(i&1){\\n                int x = t - (1<<(i-1)); // counting no. of nodes behind cur node\\n                int par = x/2; // count no. of parents which come before the par of cur node.\\n                int st = (1<<(i-1))-1; // front element of par row, which is even\\n                t = st-par; // getting par of curr node\\n                i--;\\n            }\\n            else{\\n               int x = (1<<(i))-t-1; // counting no. of nodes before cur node\\n               int par = x/2; // count no. of parents which come before the par of cur node\\n                int st = (1<<(i-2));// front element of par row, which is odd\\n                t = st + par; //  getting par of curr node\\n                i--;\\n            }\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int t) {\\n        if(t==1){\\n            return {1};\\n        }\\n        int i=0;\\n        while((1<<i) <= t){\\n            i++;\\n        }\\n        vector<int>ans;\\n        while(t){\\n            ans.push_back(t);\\n            \\n            if(i&1){\\n                int x = t - (1<<(i-1)); // counting no. of nodes behind cur node\\n                int par = x/2; // count no. of parents which come before the par of cur node.\\n                int st = (1<<(i-1))-1; // front element of par row, which is even\\n                t = st-par; // getting par of curr node\\n                i--;\\n            }\\n            else{\\n               int x = (1<<(i))-t-1; // counting no. of nodes before cur node\\n               int par = x/2; // count no. of parents which come before the par of cur node\\n                int st = (1<<(i-2));// front element of par row, which is odd\\n                t = st + par; //  getting par of curr node\\n                i--;\\n            }\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1288152,
                "title": "pre-compute-powers-of-2-99-speed",
                "content": "Runtime: 20 ms, faster than 99.29% of Python3 online submissions for Path In Zigzag Labelled Binary Tree.\\nMemory Usage: 14.3 MB, less than 50.00% of Python3 online submissions for Path In Zigzag Labelled Binary Tree.\\n```\\nfrom math import log2\\nclass Solution:\\n\\n    power2 = {i: pow(2, i) for i in range(21)}\\n\\n    def pathInZigZagTree(self, label: int):\\n        if label == 1:\\n            return [1]\\n        row = int(log2(label))\\n        labels = [1] * (row + 1)\\n        labels[row] = label\\n        position = (Solution.power2[row + 1] - 1 - label if row % 2 else\\n                    label - Solution.power2[row])\\n        for r in range(row - 1, 0, -1):\\n            position //= 2\\n            if r % 2:\\n                labels[r] = Solution.power2[r + 1] - 1 - position\\n            else:\\n                labels[r] = Solution.power2[r] + position\\n        return labels\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom math import log2\\nclass Solution:\\n\\n    power2 = {i: pow(2, i) for i in range(21)}\\n\\n    def pathInZigZagTree(self, label: int):\\n        if label == 1:\\n            return [1]\\n        row = int(log2(label))\\n        labels = [1] * (row + 1)\\n        labels[row] = label\\n        position = (Solution.power2[row + 1] - 1 - label if row % 2 else\\n                    label - Solution.power2[row])\\n        for r in range(row - 1, 0, -1):\\n            position //= 2\\n            if r % 2:\\n                labels[r] = Solution.power2[r + 1] - 1 - position\\n            else:\\n                labels[r] = Solution.power2[r] + position\\n        return labels\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242695,
                "title": "c-100-faster",
                "content": "```\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> ans;\\n        ans.push_back(label);\\n        int i=1;\\n        while(pow(2,i)<=label)\\n        {\\n            i++;\\n        }\\n        i--;\\n        int val=label;\\n        while(i>0)\\n        {\\n            val=val/2;\\n            val=val-pow(2,i-1);\\n            val=pow(2,i)-val-1;\\n            ans.push_back(val);\\n            i--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> ans;\\n        ans.push_back(label);\\n        int i=1;\\n        while(pow(2,i)<=label)\\n        {\\n            i++;\\n        }\\n        i--;\\n        int val=label;\\n        while(i>0)\\n        {\\n            val=val/2;\\n            val=val-pow(2,i-1);\\n            val=pow(2,i)-val-1;\\n            ans.push_back(val);\\n            i--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241236,
                "title": "c-easy-solution-100-beat-concept-of-2-h-1",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int i=1;\\n        while(pow(2,i)-1 < label)\\n        {\\n            i++;\\n        }\\n        vector<int>ans;\\n        ans.push_back(label);\\n        while(i-1!=0)\\n        {\\n            int v=i-1;\\n            int total=pow(2,v);\\n            int j = label - total;\\n            j=j+j/2;\\n            label=label-j;\\n            label-=1;\\n            ans.push_back(label);\\n            i--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int i=1;\\n        while(pow(2,i)-1 < label)\\n        {\\n            i++;\\n        }\\n        vector<int>ans;\\n        ans.push_back(label);\\n        while(i-1!=0)\\n        {\\n            int v=i-1;\\n            int total=pow(2,v);\\n            int j = label - total;\\n            j=j+j/2;\\n            label=label-j;\\n            label-=1;\\n            ans.push_back(label);\\n            i--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1232562,
                "title": "o-log-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int levels = 1;\\n        int nodes = 1;\\n        levels = log2(label);\\n        vector<int>result;\\n        result.push_back(label);\\n        while(levels>0)\\n        {\\n            int dist = (label - pow(2,levels))/2;\\n            label = pow(2,levels)-1-dist;\\n            result.push_back(label);\\n            levels--;\\n        }\\n        reverse(result.begin(),result.end());\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int levels = 1;\\n        int nodes = 1;\\n        levels = log2(label);\\n        vector<int>result;\\n        result.push_back(label);\\n        while(levels>0)\\n        {\\n            int dist = (label - pow(2,levels))/2;\\n            label = pow(2,levels)-1-dist;\\n            result.push_back(label);\\n            levels--;\\n        }\\n        reverse(result.begin(),result.end());\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1219932,
                "title": "0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nvector<int> pathInZigZagTree(int label) {\\n        int level=log2(label)+1;\\n        vector<int> ans;\\n        while(label>0){\\n            ans.insert(ans.begin(),label);\\n            int level_max= (1<<level)-1;\\n            int level_min= 1<<(level-1);\\n            label=(level_max + level_min - label)/2;\\n            level--;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> pathInZigZagTree(int label) {\\n        int level=log2(label)+1;\\n        vector<int> ans;\\n        while(label>0){\\n            ans.insert(ans.begin(),label);\\n            int level_max= (1<<level)-1;\\n            int level_min= 1<<(level-1);\\n            label=(level_max + level_min - label)/2;\\n            level--;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1194882,
                "title": "easy-c-100-fastest",
                "content": "//The idea is we should change parent every time we move up i.e. 15 will be changed to 8, 4 will be changed to 7 as counting is done in zigzig pattern\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int ht=ceil(log2(label+1));\\n        cout<<ht;\\n        vector<int> ans;\\n        ans.push_back(label);\\n        label/=2;ht--;\\n        while (ht>=1){\\n            int orig=pow(2,ht-1)+(pow(2,ht)-1-label);   //orig will give the node number, the current node would come from if counting wasn\\'t done on zigziag\\n            label=orig;\\n            ans.push_back(label);\\n            ht--;\\n            label=label/2;\\n            \\n         }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int ht=ceil(log2(label+1));\\n        cout<<ht;\\n        vector<int> ans;\\n        ans.push_back(label);\\n        label/=2;ht--;\\n        while (ht>=1){\\n            int orig=pow(2,ht-1)+(pow(2,ht)-1-label);   //orig will give the node number, the current node would come from if counting wasn\\'t done on zigziag\\n            label=orig;\\n            ans.push_back(label);\\n            ht--;\\n            label=label/2;\\n            \\n         }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1176846,
                "title": "python3-move-along-the-tree",
                "content": "\\n```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        level = int(log2(label))\\n        compl = 3*2**level - 1 - label # complement \\n        \\n        ans = []\\n        while label: \\n            ans.append(label)\\n            label //= 2\\n            compl //= 2\\n            label, compl = compl, label\\n        return ans[::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        level = int(log2(label))\\n        compl = 3*2**level - 1 - label # complement \\n        \\n        ans = []\\n        while label: \\n            ans.append(label)\\n            label //= 2\\n            compl //= 2\\n            label, compl = compl, label\\n        return ans[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166840,
                "title": "c-0ms-100-math-iterative",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Path In Zigzag Labelled Binary Tree.\\nMemory Usage: 6.1 MB, less than 75.52% of C++ online submissions for Path In Zigzag Labelled Binary Tree.\\n**General idea**\\nnuxt number = level * 3 - label / 2 - 1; where level is the number of digits in the \"label\" + 1.\\n```\\nclass Solution {\\npublic:\\n  vector<int> pathInZigZagTree(int label) {\\n    vector <int> answer;\\n    int k = label, level = 1;\\n    while(k != 1) k = k>>1, level = level<<1;\\n    \\n    while(level){\\n      answer.push_back(label);\\n      label = (level>>1) + level - (label>>1) - 1;\\n      level = level>>1;\\n    }\\n    \\n    reverse(answer.begin(),answer.end());\\n    return answer;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<int> pathInZigZagTree(int label) {\\n    vector <int> answer;\\n    int k = label, level = 1;\\n    while(k != 1) k = k>>1, level = level<<1;\\n    \\n    while(level){\\n      answer.push_back(label);\\n      label = (level>>1) + level - (label>>1) - 1;\\n      level = level>>1;\\n    }\\n    \\n    reverse(answer.begin(),answer.end());\\n    return answer;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1147738,
                "title": "java-iterative-solution-100-0-ms",
                "content": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> l=new ArrayList<>();\\n        int temp=label;\\n\\t\\t/**\\n\\t\\tadding nodes from label to root node while considering\\n\\t\\tit as a normal binary tree without zig-zag\\n\\t\\t*/\\n        while(temp>0){\\n            l.add(temp);\\n            temp/=2;\\n        }\\n        Collections.reverse(l);\\n        \\n\\t\\t/**\\n\\t\\tafter reversing list \\n\\t\\tinside for loop \\n\\t\\t1. if list size is even --> the label node is at odd index hence i \\n\\t\\t                             check for even positions and flip the node value using formula \\n\\t\\t2. if list size is odd --> the label node is at even index hence i \\n\\t\\t                             check for odd positions and flip the node value using formula \\t\\t\\n\\t\\thi --> highest value node in that level\\n\\t\\tlo --> lowest value node in that level\\n\\t\\tformula --> if the labeling starts from right to left then I add (hi - currVal = d : distance from \\n\\t\\tcurrent node to last node ) to lo, thereby getting the corresponding node equi-distance(d) from lower node\\n\\t\\t*/\\n        for(int i=0;i<l.size();i++){\\n            boolean flipNode=false;\\n            if(l.size()%2 == 0 && i%2==0){\\n                flipNode=true;\\n            }else if(l.size()%2 != 0 && i%2!=0){\\n                flipNode=true;\\n            }\\n            \\n            if(flipNode){\\n                int lo=(int)Math.pow(2,i);\\n                int hi=(int)Math.pow(2,i+1)-1;\\n                temp=lo+hi-l.get(i);\\n                l.set(i,temp);\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> l=new ArrayList<>();\\n        int temp=label;\\n\\t\\t/**\\n\\t\\tadding nodes from label to root node while considering\\n\\t\\tit as a normal binary tree without zig-zag\\n\\t\\t*/\\n        while(temp>0){\\n            l.add(temp);\\n            temp/=2;\\n        }\\n        Collections.reverse(l);\\n        \\n\\t\\t/**\\n\\t\\tafter reversing list \\n\\t\\tinside for loop \\n\\t\\t1. if list size is even --> the label node is at odd index hence i \\n\\t\\t                             check for even positions and flip the node value using formula \\n\\t\\t2. if list size is odd --> the label node is at even index hence i \\n\\t\\t                             check for odd positions and flip the node value using formula \\t\\t\\n\\t\\thi --> highest value node in that level\\n\\t\\tlo --> lowest value node in that level\\n\\t\\tformula --> if the labeling starts from right to left then I add (hi - currVal = d : distance from \\n\\t\\tcurrent node to last node ) to lo, thereby getting the corresponding node equi-distance(d) from lower node\\n\\t\\t*/\\n        for(int i=0;i<l.size();i++){\\n            boolean flipNode=false;\\n            if(l.size()%2 == 0 && i%2==0){\\n                flipNode=true;\\n            }else if(l.size()%2 != 0 && i%2!=0){\\n                flipNode=true;\\n            }\\n            \\n            if(flipNode){\\n                int lo=(int)Math.pow(2,i);\\n                int hi=(int)Math.pow(2,i+1)-1;\\n                temp=lo+hi-l.get(i);\\n                l.set(i,temp);\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1060623,
                "title": "c-o-log-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int l=1,c=1;\\n        vector<int> ans;\\n        while(c*2<=label){\\n            c*=2;\\n            l++;\\n        }\\n        while(label!=0){\\n            ans.push_back(label);\\n            int maxi=((int)pow(2,l))-1;\\n            int mini=((int)pow(2,l-1));\\n            label=(int)(maxi+mini-label)/2;\\n            l--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int l=1,c=1;\\n        vector<int> ans;\\n        while(c*2<=label){\\n            c*=2;\\n            l++;\\n        }\\n        while(label!=0){\\n            ans.push_back(label);\\n            int maxi=((int)pow(2,l))-1;\\n            int mini=((int)pow(2,l-1));\\n            label=(int)(maxi+mini-label)/2;\\n            l--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038907,
                "title": "java-log-n-2",
                "content": "```\\nclass Solution\\n{\\n    private int[] pow2;\\n    private int flip(int x)\\n    {\\n        int k=0;\\n        for(k=0; k<25; k++)\\n        {\\n            if(x>=pow2[k] && x<pow2[k+1])\\n            {\\n                return pow2[k]+pow2[k+1]-1-x;\\n            }\\n        }\\n        return -1;\\n    }\\n    public List<Integer> pathInZigZagTree(int n)\\n    {\\n        int x=1;\\n        pow2 = new int[25];\\n        int i=0;\\n        while(i<25)\\n        {\\n            pow2[i++]=x;\\n            x=x*2;\\n        }\\n        List<Integer> ret = new LinkedList<>();\\n        while(n>0)\\n        {\\n            ret.add(0,n);\\n            n=flip(n/2);\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    private int[] pow2;\\n    private int flip(int x)\\n    {\\n        int k=0;\\n        for(k=0; k<25; k++)\\n        {\\n            if(x>=pow2[k] && x<pow2[k+1])\\n            {\\n                return pow2[k]+pow2[k+1]-1-x;\\n            }\\n        }\\n        return -1;\\n    }\\n    public List<Integer> pathInZigZagTree(int n)\\n    {\\n        int x=1;\\n        pow2 = new int[25];\\n        int i=0;\\n        while(i<25)\\n        {\\n            pow2[i++]=x;\\n            x=x*2;\\n        }\\n        List<Integer> ret = new LinkedList<>();\\n        while(n>0)\\n        {\\n            ret.add(0,n);\\n            n=flip(n/2);\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1025020,
                "title": "c-solution-o-logn-faster-than-100",
                "content": "I get the concept from here [click here](https://leetcode.com/problems/path-in-zigzag-labelled-binary-tree/discuss/324011/Python-O(logn)-time-and-space-with-readable-code-and-step-by-step-explanation)\\n```\\nvector<int> pathInZigZagTree(int label) \\n    {\\n        vector<int>v;\\n        int level=1;\\n        int level_starting_value=1;\\n        while(label>=level_starting_value*2)     \\n        {\\n            level++;\\n            level_starting_value*=2;\\n        }\\n        while(label)\\n        {\\n            v.push_back(label);\\n            int maxmOfLevel=pow(2,level)-1;\\n            int minmOfLevel=pow(2,level-1);\\n            label=(minmOfLevel+maxmOfLevel-label)/2;\\n            level--;\\n        }\\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> pathInZigZagTree(int label) \\n    {\\n        vector<int>v;\\n        int level=1;\\n        int level_starting_value=1;\\n        while(label>=level_starting_value*2)     \\n        {\\n            level++;\\n            level_starting_value*=2;\\n        }\\n        while(label)\\n        {\\n            v.push_back(label);\\n            int maxmOfLevel=pow(2,level)-1;\\n            int minmOfLevel=pow(2,level-1);\\n            label=(minmOfLevel+maxmOfLevel-label)/2;\\n            level--;\\n        }\\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 971132,
                "title": "3-different-java-solution-o-n-o-logn-time",
                "content": "\\t//time :O(N) , space O(N)\\n\\t/*\\n\\tapproach 1 : \\n\\t  -> create the zig zag tree upto given label using 2 stacks.\\n\\t  ->traverse and find all ancestors of given label\\n\\t*/\\n\\tclass TreeNode{\\n\\t\\tint data;\\n\\t\\tTreeNode left,right;\\n\\t\\tpublic TreeNode(int data){\\n\\t\\t\\tthis.data=data;\\n\\t\\t}\\n\\t}\\n\\tclass Solution {\\n\\t\\tpublic List<Integer> pathInZigZagTree(int label) {\\n\\t\\t\\tDeque<TreeNode> s1 = new ArrayDeque<>();\\n\\t\\t\\tDeque<TreeNode> s2 = new ArrayDeque<>();\\n\\t\\t\\tTreeNode root=new TreeNode(1);\\n\\t\\t\\ts1.push(root);\\n\\t\\t\\tint c = 2;\\n\\t\\t\\tboolean isLess = true;\\n\\t\\t\\twhile((!s1.isEmpty() || !s2.isEmpty()) && isLess) {\\n\\t\\t\\t\\t\\twhile(!s1.isEmpty()){\\n\\t\\t\\t\\t\\t\\tTreeNode x = s1.pop();\\n\\t\\t\\t\\t\\t\\tTreeNode l = new TreeNode(c++);\\n\\t\\t\\t\\t\\t\\tTreeNode r=  new TreeNode(c++);\\n\\t\\t\\t\\t\\t\\tx.right =l;x.left=r;\\n\\t\\t\\t\\t\\t\\ts2.push(l);s2.push(r);\\n\\t\\t\\t\\t\\t\\tif(c>label){\\n\\t\\t\\t\\t\\t\\t\\tisLess = false;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(!isLess)break;\\n\\t\\t\\t\\twhile(!s2.isEmpty()){\\n\\t\\t\\t\\t\\t\\tTreeNode x = s2.pop();\\n\\t\\t\\t\\t\\t\\tTreeNode l = new TreeNode(c++);\\n\\t\\t\\t\\t\\t\\tTreeNode r=  new TreeNode(c++);\\n\\t\\t\\t\\t\\t\\tx.left =l;x.right=r;\\n\\t\\t\\t\\t\\t\\ts1.push(l);s1.push(r);\\n\\t\\t\\t\\t\\t\\tif(c>label){\\n\\t\\t\\t\\t\\t\\t\\tisLess = false;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\tLinkedList<Integer> ans = new LinkedList<>();\\n\\t\\t\\tform(root,ans,label);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\tprivate boolean form( TreeNode root,LinkedList<Integer> ans,int label){\\n\\t\\t\\tif(root==null)return false;\\n\\t\\t\\tif(root.data==label){\\n\\t\\t\\t\\tans.addFirst(root.data);\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tboolean l = form(root.left,ans,label);\\n\\t\\t\\tif(l){\\n\\t\\t\\t\\tans.addFirst(root.data);\\n\\t\\t\\t\\treturn l;\\n\\t\\t\\t}\\n\\t\\t\\tboolean r = form(root.right,ans,label);\\n\\t\\t\\tif(r){\\n\\t\\t\\t\\tans.addFirst(root.data);\\n\\t\\t\\t\\treturn r;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\t// time : O(N)  , space O(N) \\n\\t/*approach 2 : \\n\\t  ->Instead to creating Tree , what we can do it to store level order of the zig zag tree in a list.\\n\\t  -> for any index i , (i-1)/2 th index is the index of its parent\\n\\t  */\\n\\tclass Solution {\\n\\t\\tpublic List<Integer> pathInZigZagTree(int label) {\\n\\t\\t\\tArrayList<Integer> list = new ArrayList<>();\\n\\t\\t\\tlist.add(1);\\n\\t\\t\\tboolean isSmall = true;\\n\\t\\t\\tfor(int i=2;i<=label;i++){\\n\\t\\t\\t\\tif(i%2==0){\\n\\t\\t\\t\\t\\tfor(int j=(int)Math.pow(2,i)-1;j>Math.pow(2,i-1)-1;j--){\\n\\t\\t\\t\\t\\t\\t list.add(j);\\n\\t\\t\\t\\t\\t\\t if(j==label){\\n\\t\\t\\t\\t\\t\\t\\tisSmall=false;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tfor(int j=(int)Math.pow(2,i-1);j<Math.pow(2,i);j++){\\n\\t\\t\\t\\t\\t\\tlist.add(j);\\n\\t\\t\\t\\t\\t\\tif(j==label){\\n\\t\\t\\t\\t\\t\\t\\tisSmall=false;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(!isSmall)break;\\n\\t\\t\\t}\\n\\t\\t\\tLinkedList<Integer> ans = new LinkedList<>();\\n\\t\\t\\tans.add(label);\\n\\t\\t\\t int zz=list.size()-1;\\n\\t\\t\\twhile(zz>0){\\n\\t\\t\\t\\tans.addFirst(list.get((zz-1)/2));\\n\\t\\t\\t\\tzz=(zz-1)/2;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}\\n\\t//time O(logn) , space O(logn)\\n\\t// approach 3 :\\n\\t/*\\n\\t  ->Now instead of storing the whole tree, we can initially store all the ancestors of label(like for a normal tree) without thinking zig zag tree.\\n\\t  ->Now we need to change those values in the list which need to be reversed due to zig zag tree.(every alternative ancestor)\\n\\t  -> upon observation we can see that the new value is the mirror image of the origional value.\\n\\t  -> like we can find the diff btw origional value and the nearest greater power of 2 ,  \\n\\t  -> so the new value will be the nearest smallest power of 2 + the calculated diff.\\n\\t  -> one thing to keep in mind that we need to change either even indexed ancestor or odd indexed ancestors\\n\\t  -> we can find this with the help of # of ancestors of label.\\n\\t  -> if the # of ancestors(same as list size) is odd then we change odd indexed ancestors else change even indexed ancestors.\\n\\t*/\\n\\tclass Solution {\\n\\t\\tpublic List<Integer> pathInZigZagTree(int label) {\\n\\t\\t\\tLinkedList<Integer> list =new LinkedList<>();\\n\\t\\t\\twhile(label>0){\\n\\t\\t\\t\\tlist.addFirst(label);\\n\\t\\t\\t\\tlabel/=2;\\n\\t\\t\\t}\\n\\t\\t\\tArrayList<Integer> ans = new ArrayList(list);\\n\\t\\t\\tint s = 0;\\n\\t\\t\\tif(ans.size()%2==1)s=1;\\n\\t\\t\\tfor(int i=s;i<ans.size()-1;i+=2){\\n\\t\\t\\t\\tint add = (int)Math.pow(2,i+1)-1-ans.get(i);\\n\\t\\t\\t\\tans.set(i,(int)Math.pow(2,i)+add);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic List<Integer> pathInZigZagTree(int label) {\\n\\t\\t\\tDeque<TreeNode> s1 = new ArrayDeque<>();\\n\\t\\t\\tDeque<TreeNode> s2 = new ArrayDeque<>();\\n\\t\\t\\tTreeNode root=new TreeNode(1);\\n\\t\\t\\ts1.push(root);\\n\\t\\t\\tint c = 2;\\n\\t\\t\\tboolean isLess = true;\\n\\t\\t\\twhile((!s1.isEmpty() || !s2.isEmpty()) && isLess) {\\n\\t\\t\\t\\t\\twhile(!s1.isEmpty()){\\n\\t\\t\\t\\t\\t\\tTreeNode x = s1.pop();\\n\\t\\t\\t\\t\\t\\tTreeNode l = new TreeNode(c++);\\n\\t\\t\\t\\t\\t\\tTreeNode r=  new TreeNode(c++);\\n\\t\\t\\t\\t\\t\\tx.right =l;x.left=r;\\n\\t\\t\\t\\t\\t\\ts2.push(l);s2.push(r);\\n\\t\\t\\t\\t\\t\\tif(c>label){\\n\\t\\t\\t\\t\\t\\t\\tisLess = false;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 947288,
                "title": "c-code-well-commented-and-explained-0ms-faster-than-100",
                "content": "**Runtime: 0 ms, faster than 100.00% of C++ online submissions for Path In Zigzag Labelled Binary Tree.**\\n**Memory Usage: 6.6 MB, less than 64.06% of C++ online submissions for Path In Zigzag Labelled Binary Tree.**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> res;\\n        if(label == 1)\\n            return {1};\\n        \\n        \\n        int level = log2(label); //Formula to get the depth or level where the element is located\\n        \\n        res.insert(res.begin(), label); //Insert it into result vector\\n        level--; //We store the elements from the previous level to the 0th level\\n        \\n        while(level != 0){\\n            label = 3 * pow(2, level) - 1 - label/2; //Formula to get the element for each level\\n            res.insert(res.begin(), label); //Insert it into the resultant vector\\n            level--;           //Decrease level by 1\\n        }\\n        res.insert(res.begin(), 1); //As 1 will always be the first element and we didnt included level 0 till now so push 1 to the beginning\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> res;\\n        if(label == 1)\\n            return {1};\\n        \\n        \\n        int level = log2(label); //Formula to get the depth or level where the element is located\\n        \\n        res.insert(res.begin(), label); //Insert it into result vector\\n        level--; //We store the elements from the previous level to the 0th level\\n        \\n        while(level != 0){\\n            label = 3 * pow(2, level) - 1 - label/2; //Formula to get the element for each level\\n            res.insert(res.begin(), label); //Insert it into the resultant vector\\n            level--;           //Decrease level by 1\\n        }\\n        res.insert(res.begin(), 1); //As 1 will always be the first element and we didnt included level 0 till now so push 1 to the beginning\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875417,
                "title": "convert-to-binary-log-n-2-complexity-worse-than-logn-but-interesting",
                "content": "```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        x=bin(label)[2:]\\n        n = len(x)\\n        #invert path\\n        y=\"1\"\\n        for i in range(1, n): y += \"0\" if x[i] == \"1\" else \"1\"\\n        #Follow path in odd even fashion\\n        out = []\\n        for i in range(n):\\n            if n%2 == 0:\\n                if i % 2 == 1: out.append(int(x[:i+1], 2))\\n                else: out.append(int(y[:i+1], 2))\\n            else:\\n                if i % 2 == 0: out.append(int(x[:i+1], 2))\\n                else: out.append(int(y[:i+1], 2))\\n        return out\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        x=bin(label)[2:]\\n        n = len(x)\\n        #invert path\\n        y=\"1\"\\n        for i in range(1, n): y += \"0\" if x[i] == \"1\" else \"1\"\\n        #Follow path in odd even fashion\\n        out = []\\n        for i in range(n):\\n            if n%2 == 0:\\n                if i % 2 == 1: out.append(int(x[:i+1], 2))\\n                else: out.append(int(y[:i+1], 2))\\n            else:\\n                if i % 2 == 0: out.append(int(x[:i+1], 2))\\n                else: out.append(int(y[:i+1], 2))\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 845575,
                "title": "typescript-simple-o-logn-beats-100-w-detailed-comments",
                "content": "```\\nfunction pathInZigZagTree(label: number): number[] {\\n    // find level this label is on\\n    let level: number = Math.floor(Math.log(label) / Math.log(2) + 1);\\n\\n    // create an empty path array of size level\\n    // (since we need to go that many levels to reach label)\\n    const path: number[] = Array(level);\\n\\n    // go until label is 0\\n    while (label > 0) {\\n        // at this level is simply the label (node we encountered in path)\\n        path[level - 1] = label;\\n\\n        // calculate symmetric node on other side (since we are zig zagging)\\n        label = 2 ** level - 1 - label + 2 ** (level - 1);\\n\\n        // right shift by 1 since we are going up a level\\n        label >>= 1;\\n\\n        // go up a level\\n        level--;\\n    }\\n\\n    return path;\\n}\\n```\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction pathInZigZagTree(label: number): number[] {\\n    // find level this label is on\\n    let level: number = Math.floor(Math.log(label) / Math.log(2) + 1);\\n\\n    // create an empty path array of size level\\n    // (since we need to go that many levels to reach label)\\n    const path: number[] = Array(level);\\n\\n    // go until label is 0\\n    while (label > 0) {\\n        // at this level is simply the label (node we encountered in path)\\n        path[level - 1] = label;\\n\\n        // calculate symmetric node on other side (since we are zig zagging)\\n        label = 2 ** level - 1 - label + 2 ** (level - 1);\\n\\n        // right shift by 1 since we are going up a level\\n        label >>= 1;\\n\\n        // go up a level\\n        level--;\\n    }\\n\\n    return path;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 840617,
                "title": "java-simple-solution",
                "content": "```\\n\\tpublic List<Integer> pathInZigZagTree(int label) {\\n        int n = (int)(Math.log(label)/Math.log(2))+1;\\n        LinkedList<Integer> list = new LinkedList<>();\\n        while (n > 0) {\\n            list.addFirst(label);\\n            int ref = (1<<n)+(1<<n-1)-label-1;\\n            label = ref/2;\\n            n--;\\n        }\\n        return list;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic List<Integer> pathInZigZagTree(int label) {\\n        int n = (int)(Math.log(label)/Math.log(2))+1;\\n        LinkedList<Integer> list = new LinkedList<>();\\n        while (n > 0) {\\n            list.addFirst(label);\\n            int ref = (1<<n)+(1<<n-1)-label-1;\\n            label = ref/2;\\n            n--;\\n        }\\n        return list;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 838927,
                "title": "java-0ms-100-faster-14-lines",
                "content": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int s = (int) (Math.log(label)/Math.log(2));\\n        List<Integer> result = new ArrayList<>(s+1);\\n        result.add(label);\\n        for(int i = s; i > 0; i--){\\n            int k = (int) (label - Math.pow(2,i))/2;\\n            label = (int)Math.pow(2,i) - 1 - k;\\n            result.add(label);\\n        }\\n        Collections.sort(result);\\n        return  result;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int s = (int) (Math.log(label)/Math.log(2));\\n        List<Integer> result = new ArrayList<>(s+1);\\n        result.add(label);\\n        for(int i = s; i > 0; i--){\\n            int k = (int) (label - Math.pow(2,i))/2;\\n            label = (int)Math.pow(2,i) - 1 - k;\\n            result.add(label);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 837634,
                "title": "c-readable-code-formula-based-to-compute-parent-explanation",
                "content": "Formula derivation here => https://imgur.com/FdKcoMf\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int current = label, parent;\\n        \\n        vector<int> ans;\\n        ans.push_back(label);\\n        \\n        while (current != 1) {\\n            parent = getParent(current);\\n            ans.push_back(parent);\\n            current = parent;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n    private:\\n    int getLevel(int num) {\\n        int i = 0;\\n        while(pow(2, i) <= num) {\\n            i++;\\n        }\\n        return i - 1;\\n    }\\n    int getParent(int child) {\\n        int levelOfChild = getLevel(child);\\n        int levelOfParent = levelOfChild - 1;\\n        return (1<<levelOfChild) + (1<<levelOfParent) - (1 + (child>>1));\\n        // return pow(2, levelOfChild) + pow(2, levelOfParent) - (1 + child/2) ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int current = label, parent;\\n        \\n        vector<int> ans;\\n        ans.push_back(label);\\n        \\n        while (current != 1) {\\n            parent = getParent(current);\\n            ans.push_back(parent);\\n            current = parent;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n    private:\\n    int getLevel(int num) {\\n        int i = 0;\\n        while(pow(2, i) <= num) {\\n            i++;\\n        }\\n        return i - 1;\\n    }\\n    int getParent(int child) {\\n        int levelOfChild = getLevel(child);\\n        int levelOfParent = levelOfChild - 1;\\n        return (1<<levelOfChild) + (1<<levelOfParent) - (1 + (child>>1));\\n        // return pow(2, levelOfChild) + pow(2, levelOfParent) - (1 + child/2) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822768,
                "title": "short-and-simple-solution-time-space-complexity-o-logn",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        \\n        int lvl = log2(label)+1;\\n        vector<int> ans(lvl,0);\\n        \\n        while(label>=1){\\n            \\n            ans[lvl-1] = label;\\n            label = pow(2,lvl-1)+pow(2,lvl-2)-1-label/2;\\n            lvl--;\\n        }\\n        \\n    return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        \\n        int lvl = log2(label)+1;\\n        vector<int> ans(lvl,0);\\n        \\n        while(label>=1){\\n            \\n            ans[lvl-1] = label;\\n            label = pow(2,lvl-1)+pow(2,lvl-2)-1-label/2;\\n            lvl--;\\n        }\\n        \\n    return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 813183,
                "title": "c-clean-code-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> ans;\\n        while (label) {\\n            ans.insert(ans.begin(), label);\\n            label /= 2;\\n        }\\n        for (int i = 2 - ans.size() % 2; i < ans.size() - 1; i += 2)\\n            ans[i] = 3 * pow(2, i) - 1 - ans[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> ans;\\n        while (label) {\\n            ans.insert(ans.begin(), label);\\n            label /= 2;\\n        }\\n        for (int i = 2 - ans.size() % 2; i < ans.size() - 1; i += 2)\\n            ans[i] = 3 * pow(2, i) - 1 - ans[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807272,
                "title": "super-short-c-code-beats-100-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int x = log2(label);    //getting number of levels required\\n        vector<int> ans(x+1,1); // Initializing vector with value 1\\n        while(x){                     \\n            ans[x--] = label;\\n            label /= 2;\\n            label = (1<<x+1) + (1<<x) - label - 1; // calculating required value for each level\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int x = log2(label);    //getting number of levels required\\n        vector<int> ans(x+1,1); // Initializing vector with value 1\\n        while(x){                     \\n            ans[x--] = label;\\n            label /= 2;\\n            label = (1<<x+1) + (1<<x) - label - 1; // calculating required value for each level\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 791261,
                "title": "c-fastest-and-easiest-code-using-the-properties-of-a-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> ans;\\n        while(label){\\n            ans.push_back(label);\\n            label/=2;\\n        }\\n        bool tmp=ans.size()%2;\\n        reverse(ans.begin(),ans.end());\\n        for(int i=tmp;i<ans.size();i+=2){\\n            ans[i]=pow(2,i+1)-ans[i]+pow(2,i)-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> ans;\\n        while(label){\\n            ans.push_back(label);\\n            label/=2;\\n        }\\n        bool tmp=ans.size()%2;\\n        reverse(ans.begin(),ans.end());\\n        for(int i=tmp;i<ans.size();i+=2){\\n            ans[i]=pow(2,i+1)-ans[i]+pow(2,i)-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781732,
                "title": "swift-solution",
                "content": "```\\nfinal class Solution {\\n    func pathInZigZagTree(_ label: Int) -> [Int] {\\n        var labelCopy = label\\n\\n        var level = 0\\n        while labelCopy > 0 {\\n            level += 1\\n            labelCopy = labelCopy/2\\n        }\\n\\n        var output = [Int]()\\n        var nextLevel = label\\n        while level > 0 {\\n            let min = Double(pow(Double(2.0), Double(level - 1)))\\n            let max = Double(pow(Double(2.0), Double(level)) - 1.0)\\n            output.append(nextLevel)\\n            nextLevel = (Int(max + min) - nextLevel) / 2\\n            level -= 1\\n        }\\n        return output.reversed()\\n    }\\n }\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfinal class Solution {\\n    func pathInZigZagTree(_ label: Int) -> [Int] {\\n        var labelCopy = label\\n\\n        var level = 0\\n        while labelCopy > 0 {\\n            level += 1\\n            labelCopy = labelCopy/2\\n        }\\n\\n        var output = [Int]()\\n        var nextLevel = label\\n        while level > 0 {\\n            let min = Double(pow(Double(2.0), Double(level - 1)))\\n            let max = Double(pow(Double(2.0), Double(level)) - 1.0)\\n            output.append(nextLevel)\\n            nextLevel = (Int(max + min) - nextLevel) / 2\\n            level -= 1\\n        }\\n        return output.reversed()\\n    }\\n }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 740010,
                "title": "java-0ms-so-easy-your-mom-will-understand",
                "content": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        // loga b = log10 b / log10 a\\n        int lvl = 1+ (int) (Math.log(label) / Math.log(2));\\n        while (label > 0) {\\n            ans.add(0, label);\\n            label = (int)((Math.pow(2,lvl)-1) + (Math.pow(2,lvl-1)) - label);\\n            label = label/2;\\n            lvl--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        // loga b = log10 b / log10 a\\n        int lvl = 1+ (int) (Math.log(label) / Math.log(2));\\n        while (label > 0) {\\n            ans.add(0, label);\\n            label = (int)((Math.pow(2,lvl)-1) + (Math.pow(2,lvl-1)) - label);\\n            label = label/2;\\n            lvl--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 705519,
                "title": "java-0ms-math",
                "content": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int n = 1;\\n        LinkedList<Integer> list = new LinkedList<>();\\n        list.add(label);\\n\\t\\t// the the level of the node\\n        while(Math.pow(2, n) - 1 < label){\\n            n++;\\n        }\\n\\t\\t// check the lcoation of each row by finding the symmetry\\n        while(n > 1){\\n            label /= 2;\\n\\t\\t\\t// base case, we are at the first row\\n            if(n == 2){\\n                list.addFirst(label);\\n                break;\\n            }\\n            n--; // go up\\n\\t\\t\\t// get the middle of current row\\n            int min = (int)Math.pow(2, n - 1); // min of current row\\n            int max = (int)Math.pow(2, n) - 1; // max of current row\\n            int middle = min + (max - min) / 2; // middle\\n            \\n            int location = middle - label + 1 + middle; // get the location\\n            list.addFirst(location); //add to the result\\n            label = location; // reset the label\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int n = 1;\\n        LinkedList<Integer> list = new LinkedList<>();\\n        list.add(label);\\n\\t\\t// the the level of the node\\n        while(Math.pow(2, n) - 1 < label){\\n            n++;\\n        }\\n\\t\\t// check the lcoation of each row by finding the symmetry\\n        while(n > 1){\\n            label /= 2;\\n\\t\\t\\t// base case, we are at the first row\\n            if(n == 2){\\n                list.addFirst(label);\\n                break;\\n            }\\n            n--; // go up\\n\\t\\t\\t// get the middle of current row\\n            int min = (int)Math.pow(2, n - 1); // min of current row\\n            int max = (int)Math.pow(2, n) - 1; // max of current row\\n            int middle = min + (max - min) / 2; // middle\\n            \\n            int location = middle - label + 1 + middle; // get the location\\n            list.addFirst(location); //add to the result\\n            label = location; // reset the label\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696831,
                "title": "c-100-faster-with-explaination-easy-to-understand-o-1-memory",
                "content": "We first find the level of the current label. Then we traverse the tree up from the node in a tree assuming it is an ordinary binary tree, by taking the mirror image of the current value in the present level. Each level start with (1<<level) numbered node and ends with (1<<(level+1)) -1 numbered node. So we can get the mirror imaged node by taking the difference from the upper value and incrementing the same difference to the lower value. Then we find its parent which is equal to the (node/2) in an ordinary binary tree.\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int cur=0;\\n        int level=0;\\n        while(cur<label)\\n        {\\n            cur=cur+(1<<level);\\n            level++;\\n        }\\n        level--;                    // this is the level of our label\\n        vector<int> ans;\\n        int temp=label;\\n        // cout<<level;\\n        while(level>0 and temp!=1)\\n        {\\n            ans.push_back(temp);    // push the current label\\n            int start=1<<level;\\n            int diff=(1<<(level+1))-1-temp;\\n            int rev=start+diff;     // flip it in a way that it would be present in an ordinary binary tree\\n            temp=rev/2;             // this is the parent in the ordinary binary tree\\n            level--;                // level of the parent node of temp\\n        }\\n        ans.push_back(1);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int cur=0;\\n        int level=0;\\n        while(cur<label)\\n        {\\n            cur=cur+(1<<level);\\n            level++;\\n        }\\n        level--;                    // this is the level of our label\\n        vector<int> ans;\\n        int temp=label;\\n        // cout<<level;\\n        while(level>0 and temp!=1)\\n        {\\n            ans.push_back(temp);    // push the current label\\n            int start=1<<level;\\n            int diff=(1<<(level+1))-1-temp;\\n            int rev=start+diff;     // flip it in a way that it would be present in an ordinary binary tree\\n            temp=rev/2;             // this is the parent in the ordinary binary tree\\n            level--;                // level of the parent node of temp\\n        }\\n        ans.push_back(1);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 676197,
                "title": "c-0ms-solution-w-backtracking",
                "content": "Run-time is `O(logn)`. \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        std::vector<int> res;\\n        int cur{label}, row{(int)std::log2(label)}, l{1<<row}, r{(1<<(row+1))-1};\\n        while(row != 0) {\\n            res.emplace_back(cur);\\n            int nextL{1<<(row-1)}, nextR{(1<<row)-1};\\n            if(row % 2) cur = nextL + ((r-cur)>>1);\\n            else cur = nextR - ((cur-l)>>1);\\n            l = nextL, r = nextR;\\n            --row;\\n        }\\n        res.emplace_back(1);\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        std::vector<int> res;\\n        int cur{label}, row{(int)std::log2(label)}, l{1<<row}, r{(1<<(row+1))-1};\\n        while(row != 0) {\\n            res.emplace_back(cur);\\n            int nextL{1<<(row-1)}, nextR{(1<<row)-1};\\n            if(row % 2) cur = nextL + ((r-cur)>>1);\\n            else cur = nextR - ((cur-l)>>1);\\n            l = nextL, r = nextR;\\n            --row;\\n        }\\n        res.emplace_back(1);\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 670769,
                "title": "c-arithmetic-explained-100-speed-100-memory",
                "content": "Starting with n, iteratively decrement with a transform expression to trace the path through the tree. At each step up in the tree, the value in the path will be the minimum value at that level plus some offset.\\n\\nThe offset is calculated as the difference between the maximum value at the new level and the current n value divided by 2. This quantity basically enables the \\'flipping\\' in the value between maximum and minimum of the new value and then adding to the extent that it\\'s needed such that the correct node \\'bucket\\' is identified.\\n\\nNote: unnecessary brackets are used to help others follow the math logic.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int n) {\\n        int l = getLevel(n);           //Get n\\'s level\\n        vector<int> ans(l+1, 0);       //Answer has level number of spaces (the path through each level) plus the root level\\n        int i = l;                     //for iterating from deepest level to the root\\n        while(n > 1){                  //Iterating from n to 1\\n            ans[i] = n;\\n            n = pow(2,l-1) + ((pow(2,l) - 1) - n/2); //At each step in the path, transform n = (first number of next level = pow(2,l-1)) + ((max at next level up = pow(2,l) - 1) - (n/2))\\n            l--;\\n            i--;\\n        }\\n        ans[0] = 1;     //Set the remaining value to the root value\\n        return ans;\\n    }\\n    \\n    //Get the zero-indexed level that the label n exists on\\n    int getLevel(int n) {\\n        return (n == 1)? 0 : getLevel(n/2)+1; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int n) {\\n        int l = getLevel(n);           //Get n\\'s level\\n        vector<int> ans(l+1, 0);       //Answer has level number of spaces (the path through each level) plus the root level\\n        int i = l;                     //for iterating from deepest level to the root\\n        while(n > 1){                  //Iterating from n to 1\\n            ans[i] = n;\\n            n = pow(2,l-1) + ((pow(2,l) - 1) - n/2); //At each step in the path, transform n = (first number of next level = pow(2,l-1)) + ((max at next level up = pow(2,l) - 1) - (n/2))\\n            l--;\\n            i--;\\n        }\\n        ans[0] = 1;     //Set the remaining value to the root value\\n        return ans;\\n    }\\n    \\n    //Get the zero-indexed level that the label n exists on\\n    int getLevel(int n) {\\n        return (n == 1)? 0 : getLevel(n/2)+1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 655845,
                "title": "python-faster-than-100-simple-explained-4-lines",
                "content": "```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        l,r = math.ceil(math.log2(label + 1)),[label]\\n        for l in range(l-1,0,-1):\\n            label = 2**(l-1) + (2**(l+1) - 1 - label)//2 if l%2==0 else  (2**l) - 1 - (label - 2**l)//2\\n            r.append(label)\\n        return r[::-1]\\n\\n```\\n\\nGeneral approach:\\n\\n1. First we find what level the label is on. `math.ceil(math.log2(label + 1))` . This looks complicated, but it\\'s not.\\n\\nIf you look at the tree:\\n\\n```\\n1 - range 2**0 - level 1\\n3 2 - range 2**1 ... 2**2-1 - level 2\\n4 5 6 7 - range 2**2 ... 2**3-1 - level 3\\n```\\n\\nit makes sense. `label + 1` will be in the range `2**(x-1) < label + 1 <= 2**x`, so `log2(label+1)` rounded up will give us the level.\\n\\nThe list `r` is our return array. We can pre-populate it with the initial `label`.\\n\\nNow we spin a loop and we go level by level from the bottom up:\\n\\n```\\n        for l in range(l-1,0,-1):\\n```\\n\\nand at each step we calculate the label above and add it to the return list.\\n\\nHow do we calculate the label above?\\n\\nThe code is:\\n\\n```\\n            label = 2**(l-1) + (2**(l+1) - 1 - label)//2 if l%2==0 else  (2**l) - 1 - (label - 2**l)//2\\n```\\nto make it more readable:\\n\\n```\\nif l%2==0:\\n\\tlabel = 2**(l-1) + (2**(l+1) - 1 - label)//2\\nelse:\\n\\tlabel = (2**l) - 1 - (label - 2**l)//2\\n```\\n\\nWhat is going on here? First, due to zigzag numbering, we treat odd and even levels different - this is what `if l%2==0` for.\\nNow, some simple logic. let\\'s say our current label is the 3rd element in the current level (from the left, index starts at 0). in order to tell the index of the parent element, we need to split the elements on the current level into pairs and the index of the pair will be the index of the parent element.  The we apply that offset to the left most element on the upper level.\\n\\nSo for even rows:\\n\\n```\\nlabel = 2**(l-1) + (2**(l+1) - 1 - label)//2\\n```\\nwhere `2**(l-1)` is the leftmost element of the level above and the `(2**(l+1) - 1 - label)//2` is the pair index and for the even:\\n`(2**l) - 1` is the leftmost and ` (label - 2**l)//2` is the pair index.\\n\\nNow we just need to return the elements in the reversed order and we are done:\\n```\\n        return r[::-1]\\n```\\n\\nNow we can save a line by combining the 2 lines inside loop into 1:\\n\\n```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        l,r = math.ceil(math.log2(label + 1)),[label]\\n        for l in range(l-1,0,-1):\\n            r.append(2**(l-1) + (2**(l+1) - 1 - r[-1])//2 if l%2==0 else  (2**l) - 1 - (r[-1] - 2**l)//2)\\n        return r[::-1]\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        l,r = math.ceil(math.log2(label + 1)),[label]\\n        for l in range(l-1,0,-1):\\n            label = 2**(l-1) + (2**(l+1) - 1 - label)//2 if l%2==0 else  (2**l) - 1 - (label - 2**l)//2\\n            r.append(label)\\n        return r[::-1]\\n\\n```\n```\\n1 - range 2**0 - level 1\\n3 2 - range 2**1 ... 2**2-1 - level 2\\n4 5 6 7 - range 2**2 ... 2**3-1 - level 3\\n```\n```\\n        for l in range(l-1,0,-1):\\n```\n```\\n            label = 2**(l-1) + (2**(l+1) - 1 - label)//2 if l%2==0 else  (2**l) - 1 - (label - 2**l)//2\\n```\n```\\nif l%2==0:\\n\\tlabel = 2**(l-1) + (2**(l+1) - 1 - label)//2\\nelse:\\n\\tlabel = (2**l) - 1 - (label - 2**l)//2\\n```\n```\\nlabel = 2**(l-1) + (2**(l+1) - 1 - label)//2\\n```\n```\\n        return r[::-1]\\n```\n```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        l,r = math.ceil(math.log2(label + 1)),[label]\\n        for l in range(l-1,0,-1):\\n            r.append(2**(l-1) + (2**(l+1) - 1 - r[-1])//2 if l%2==0 else  (2**l) - 1 - (r[-1] - 2**l)//2)\\n        return r[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 647518,
                "title": "c-5-lines-o-log-n-math-solution-explained",
                "content": "If we look at the non-zigzag tree as below\\n```\\n\\t\\t\\t\\t\\t1                    row 0\\n\\t\\t\\t2                3           row 1\\n\\t    4       5        6        7      row 2\\n\\t  8   9   10  11   12  13   14  15   row 3\\n```\\nLet\\'s take ```14``` as an example:\\nIf we want to go from the leaf node with value ```14``` to the root node with value ```1```, what we need to do is to keep deviding by 2 from ```14``` to ```1```, which gives ```14, 7, 3, 1```.\\n\\nLet\\'s say now we are standing at node with value ```14```. To consider the zigzag structure, we need to modify the values coming from the row above us, and every alternative rows (in this given example, it would be row 2 and row 0 shown in the figure above).\\n\\nSo how to do the modification? We notice that row ```i``` starts with value of ```2^i```. Let\\'s call this value as \"base\".\\nThen, If we substract \"base\" from all the values in this row, they will look like:\\n```\\n\\t\\t\\t\\t\\t0                    row 0 (base = 1)\\n\\t\\t\\t0                1           row 1 (base = 2)\\n\\t    0       1        2        3      row 2 (base = 4)\\n\\t  0   1   2   3    4   5    6   7    row 3 (base = 8)\\n\\t\\t  ~                     ~\\n```\\nSo the original ```14``` is corresponding to ```6``` now, and the position that we need it to be is ```1``` (both marked with ```~``` in the figure above). Clearly, we want to do things like: \\n\\n```new value = (base - 1) - current value```\\n\\nBut remeber, we substracted \"base\" from each element previously, so we need change the equation above into:\\n\\n```(new value - base) = (base - 1) - (current value - base)```\\n\\nand we therefore get:\\n\\n```new value = 3 * base - 1 - current value```\\n\\n\\nThis algorithm gives us O(log n) time compelexity in the step of dividing ```n``` by 2 until 0. The modification step and the reverse step takes the same order time complexity as well, since they process the same amount of values as the dividing step. Therefore, overall time complexity is still O(log n).\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> ret;\\n        for (; label; label >>= 1) ret.push_back(label);\\n        for (int i = 1; i < ret.size(); i += 2) ret[i] = 3 * (1 << (ret.size() - 1 - i)) - 1 - ret[i];\\n        reverse(ret.begin(), ret.end());\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\t\\t\\t\\t1                    row 0\\n\\t\\t\\t2                3           row 1\\n\\t    4       5        6        7      row 2\\n\\t  8   9   10  11   12  13   14  15   row 3\\n```\n```14```\n```14```\n```1```\n```14```\n```1```\n```14, 7, 3, 1```\n```14```\n```i```\n```2^i```\n```\\n\\t\\t\\t\\t\\t0                    row 0 (base = 1)\\n\\t\\t\\t0                1           row 1 (base = 2)\\n\\t    0       1        2        3      row 2 (base = 4)\\n\\t  0   1   2   3    4   5    6   7    row 3 (base = 8)\\n\\t\\t  ~                     ~\\n```\n```14```\n```6```\n```1```\n```~```\n```new value = (base - 1) - current value```\n```(new value - base) = (base - 1) - (current value - base)```\n```new value = 3 * base - 1 - current value```\n```n```\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> ret;\\n        for (; label; label >>= 1) ret.push_back(label);\\n        for (int i = 1; i < ret.size(); i += 2) ret[i] = 3 * (1 << (ret.size() - 1 - i)) - 1 - ret[i];\\n        reverse(ret.begin(), ret.end());\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 644205,
                "title": "java-simple-solution-using-linkedlist",
                "content": "![image](https://assets.leetcode.com/users/mart74/image_1590087859.png)\\n```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        LinkedList<Integer> list=new LinkedList<Integer>();\\n        //Go up from label to 1\\n        while(label>0){\\n            list.push(label);\\n            label/=2;\\n        }//~\\n        \\n        int n=list.size();\\n        for(int i=1;i<n;i++){            \\n            //Change in dependency from parity n \\n            if(n%2!=0&&i%2!=0||n%2==0&&i%2==0){   \\n               int val=list.get(i).intValue();\\n               int lower=(int)Math.pow(2,i); \\n               int upper=2*lower-1; \\n               list.set(i,lower+(upper-val));\\n            }\\n        }//~\\n        \\n        return list;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        LinkedList<Integer> list=new LinkedList<Integer>();\\n        //Go up from label to 1\\n        while(label>0){\\n            list.push(label);\\n            label/=2;\\n        }//~\\n        \\n        int n=list.size();\\n        for(int i=1;i<n;i++){            \\n            //Change in dependency from parity n \\n            if(n%2!=0&&i%2!=0||n%2==0&&i%2==0){   \\n               int val=list.get(i).intValue();\\n               int lower=(int)Math.pow(2,i); \\n               int upper=2*lower-1; \\n               list.set(i,lower+(upper-val));\\n            }\\n        }//~\\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 574477,
                "title": "c-o-logn-logn-readable-iterative-6-3-mb-less-memory-than-100",
                "content": "A more readable solution, \\nO(log<sup>2</sup>n): for each level, we call the method `getLevel` adding extra factor of `logn` \\n```\\nclass Solution {\\n    int getLevel(int number) {\\n        // returns the depth of node of \\'number\\'\\n        return log2(number);\\n    }\\n    \\n    long long int getNumberInLevel(int level) {\\n        // returns number of nodes in the given level\\n        return (1 << level);\\n    }\\n    \\n    long long int getParent(int number) {\\n        // get the expected parent of given number in normal Binary Tree\\n        int parent = number / 2, level = getLevel(parent);\\n        \\n        // find the lowest valued node in the level\\n        long long int first = (1LL << level), size = getNumberInLevel(level);\\n        \\n        // As it is a zig-zag tree, \\'i\\'th node from first in normal tree\\n        // will be located as \\'i\\'th node from the end in the same level\\n        long long int last = first + size -1, dist = parent - first;\\n        \\n        return last - dist;\\n    }\\n    \\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> order;\\n        \\n        // Climb up the tree while we don\\'t reach the root\\n        while(label != 1) {\\n            order.push_back(label);\\n            label = getParent(label);\\n        }   \\n        \\n        order.push_back(label);\\n        reverse(order.begin(), order.end());\\n        \\n        return order;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int getLevel(int number) {\\n        // returns the depth of node of \\'number\\'\\n        return log2(number);\\n    }\\n    \\n    long long int getNumberInLevel(int level) {\\n        // returns number of nodes in the given level\\n        return (1 << level);\\n    }\\n    \\n    long long int getParent(int number) {\\n        // get the expected parent of given number in normal Binary Tree\\n        int parent = number / 2, level = getLevel(parent);\\n        \\n        // find the lowest valued node in the level\\n        long long int first = (1LL << level), size = getNumberInLevel(level);\\n        \\n        // As it is a zig-zag tree, \\'i\\'th node from first in normal tree\\n        // will be located as \\'i\\'th node from the end in the same level\\n        long long int last = first + size -1, dist = parent - first;\\n        \\n        return last - dist;\\n    }\\n    \\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> order;\\n        \\n        // Climb up the tree while we don\\'t reach the root\\n        while(label != 1) {\\n            order.push_back(label);\\n            label = getParent(label);\\n        }   \\n        \\n        order.push_back(label);\\n        reverse(order.begin(), order.end());\\n        \\n        return order;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 566211,
                "title": "clean-c-100-space-time",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int>ans;\\n        while(label){\\n            ans.push_back(label);\\n            int l = floor(log2(label));\\n            int actual = pow(2,l+1)-1 + pow(2,l) - label;\\n            label = actual/2;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int>ans;\\n        while(label){\\n            ans.push_back(label);\\n            int l = floor(log2(label));\\n            int actual = pow(2,l+1)-1 + pow(2,l) - label;\\n            label = actual/2;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 546889,
                "title": "java-straightforward-recursive-solution-o-logn",
                "content": "The first idea comes into my head is recursion because there is a \"Tree\" keyword. Although the question is not directly related to tree, we can solve it by recursion in a straight forward manner.\\n\\nThe recursive function take the lower(inclusive) label  and the higher label (exclusive) of current row, a boolean to indicate whether current row is in reverse manner, and the target label we need to find, and it returns the position of the node in current row which is the label node or is the ancestor of the label node. The position returned can help us to find the label of its parent.\\n\\n```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> result = new ArrayList<>();\\n        findLabel(1, 2, false, label, result);\\n        Collections.reverse(result);\\n        return result;\\n    }\\n    \\n    private int findLabel(int lower, int upper, boolean reversed, int label, List<Integer> result) {\\n        if (label >= lower && label < upper) {\\n            int currPos = reversed ? (upper - label) : (label - lower + 1);\\n            result.add(label);\\n            return currPos;\\n        }\\n        int bottomPos = findLabel(upper, upper * 2, !reversed, label, result);\\n        int currPos = (bottomPos - 1) / 2 + 1;\\n        int currLabel = reversed ? (upper - currPos) : (lower + currPos - 1);\\n        result.add(currLabel);\\n        return currPos;\\n    }\\n}\\n\\n/*\\nfirst line: <= 2^0\\nsecond line: 2^1 <= x < 2^2\\nthird line: 2^2 <=\\n\\nrecursive function:\\n    input: lower, upper, reversed\\n    output: pos of node where label is itself or under its subtree\\n            pos is always from left to right, start from 1\\n\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> result = new ArrayList<>();\\n        findLabel(1, 2, false, label, result);\\n        Collections.reverse(result);\\n        return result;\\n    }\\n    \\n    private int findLabel(int lower, int upper, boolean reversed, int label, List<Integer> result) {\\n        if (label >= lower && label < upper) {\\n            int currPos = reversed ? (upper - label) : (label - lower + 1);\\n            result.add(label);\\n            return currPos;\\n        }\\n        int bottomPos = findLabel(upper, upper * 2, !reversed, label, result);\\n        int currPos = (bottomPos - 1) / 2 + 1;\\n        int currLabel = reversed ? (upper - currPos) : (lower + currPos - 1);\\n        result.add(currLabel);\\n        return currPos;\\n    }\\n}\\n\\n/*\\nfirst line: <= 2^0\\nsecond line: 2^1 <= x < 2^2\\nthird line: 2^2 <=\\n\\nrecursive function:\\n    input: lower, upper, reversed\\n    output: pos of node where label is itself or under its subtree\\n            pos is always from left to right, start from 1\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 518041,
                "title": "java-neat-log-n-soluton",
                "content": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int k = (int)(Math.log(label) / Math.log(2.0));\\n        int start = (int)Math.pow(2.0, k);\\n        int last = label - start;\\n        Stack<Integer> stk = new Stack<>();\\n        int ok = 0;\\n        while(k >= 0){\\n            if (ok == 1){\\n                stk.add(start + start - last - 1);\\n            }else{\\n                stk.add(start + last);\\n            }\\n            ok ^= 1;\\n            last /= 2;\\n            start /= 2;\\n            k--;\\n        }\\n        Collections.reverse(stk);\\n        return stk;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int k = (int)(Math.log(label) / Math.log(2.0));\\n        int start = (int)Math.pow(2.0, k);\\n        int last = label - start;\\n        Stack<Integer> stk = new Stack<>();\\n        int ok = 0;\\n        while(k >= 0){\\n            if (ok == 1){\\n                stk.add(start + start - last - 1);\\n            }else{\\n                stk.add(start + last);\\n            }\\n            ok ^= 1;\\n            last /= 2;\\n            start /= 2;\\n            k--;\\n        }\\n        Collections.reverse(stk);\\n        return stk;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 487047,
                "title": "python-easy-to-understand-o-lgn",
                "content": "The solution here is easy to understand.\\n1. First find the total level of this label. This is actually how many bits does the binary numer of label has.\\n2. second loop from bottem to root. \\n\\tfor odd row the index of the tree is same as the value.\\n\\tfor even row the index + value == 2 ** (level - 1) + (2 ** level) - 1\\n\\tthe next level index is half of previous level\\n\\tSo we can get every level\\'s value and index easily.\\n\\n```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        level = 0\\n        tem = label\\n\\t\\t# find level\\n        while tem > 0:\\n            level += 1\\n            tem = tem >> 1\\n        result = collections.deque()\\n        currentval = label\\n\\t\\t\\n\\t\\t#find value sequence\\n        while level > 0:\\n            result.appendleft(currentval)\\n            curidx = currentval if (level % 2) else 2 ** (level - 1) - 1 + (2 ** level) - currentval\\n            nxtidx = curidx//2\\n            level -= 1\\n            currentval = nxtidx if (level % 2) else 2 ** (level) - 1 + 2 ** (level - 1) - nxtidx\\n        return result\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        level = 0\\n        tem = label\\n\\t\\t# find level\\n        while tem > 0:\\n            level += 1\\n            tem = tem >> 1\\n        result = collections.deque()\\n        currentval = label\\n\\t\\t\\n\\t\\t#find value sequence\\n        while level > 0:\\n            result.appendleft(currentval)\\n            curidx = currentval if (level % 2) else 2 ** (level - 1) - 1 + (2 ** level) - currentval\\n            nxtidx = curidx//2\\n            level -= 1\\n            currentval = nxtidx if (level % 2) else 2 ** (level) - 1 + 2 ** (level - 1) - nxtidx\\n        return result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 481963,
                "title": "java-runtime-0-ms-100-00-speed-100-00-memory",
                "content": "\\n```class Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(label);\\n\\n        while (label > 1) {\\n            int heightOfTree = (int) (Math.log10(label) / Math.log10(2));\\n            int rowStartValue = (int) Math.pow(2, heightOfTree);\\n            label = (rowStartValue - 1) - ((label - rowStartValue) / 2);\\n            list.add(label);\\n        }\\n\\n        Collections.reverse(list);\\n        return list;\\n    }\\n}",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(label);\\n\\n        while (label > 1) {\\n            int heightOfTree = (int) (Math.log10(label) / Math.log10(2));\\n            int rowStartValue = (int) Math.pow(2, heightOfTree);\\n            label = (rowStartValue - 1) - ((label - rowStartValue) / 2);\\n            list.add(label);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 461146,
                "title": "fastest-solution-o-logn-time",
                "content": "```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        ret = [label]\\n        height = int(math.log(label,2))\\n        prev = 1<<height\\n        while height:\\n            right = prev-1         # 2^height-1\\n            left = prev = prev//2  # 2^(height-1)\\n            label = left+right-label//2\\n            ret.append(label)\\n            height -= 1\\n        return ret[::-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        ret = [label]\\n        height = int(math.log(label,2))\\n        prev = 1<<height\\n        while height:\\n            right = prev-1         # 2^height-1\\n            left = prev = prev//2  # 2^(height-1)\\n            label = left+right-label//2\\n            ret.append(label)\\n            height -= 1\\n        return ret[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 445874,
                "title": "easy-to-understand-faster-than-100-00-less-than-100-00",
                "content": "```\\nUnder normal circumstances, 14 will like this [14,7,3,1], but 14 is flipped\\n          1  \\n    2          3 \\n 4    5     6     7 \\n8 9 10 11 12 13 14 15\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> result;\\n        result.push_back(label);\\n        \\n        int tmp = label;\\n        while (tmp > 1) {\\n            tmp = tmp/2;\\n            result.push_back(tmp);\\n        }\\n\\n        \\n        // odd should be changed\\n        // last one will always be 1 \\n        for (int i = 1; i < result.size() - 1; i = i + 2) {\\n            int levelmin = pow(2, result.size() - i - 1);\\n            int levelmax = pow(2, result.size() - i) - 1;\\n            int newval = levelmax - result[i] + levelmin;\\n            result[i] = newval;\\n        }\\n        \\n        reverse(result.begin(), result.end());\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nUnder normal circumstances, 14 will like this [14,7,3,1], but 14 is flipped\\n          1  \\n    2          3 \\n 4    5     6     7 \\n8 9 10 11 12 13 14 15\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> result;\\n        result.push_back(label);\\n        \\n        int tmp = label;\\n        while (tmp > 1) {\\n            tmp = tmp/2;\\n            result.push_back(tmp);\\n        }\\n\\n        \\n        // odd should be changed\\n        // last one will always be 1 \\n        for (int i = 1; i < result.size() - 1; i = i + 2) {\\n            int levelmin = pow(2, result.size() - i - 1);\\n            int levelmax = pow(2, result.size() - i) - 1;\\n            int newval = levelmax - result[i] + levelmin;\\n            result[i] = newval;\\n        }\\n        \\n        reverse(result.begin(), result.end());\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 444828,
                "title": "swift-math-solution",
                "content": "```\\nimport Foundation\\n\\nclass Solution {\\n    func pathInZigZagTree(_ label: Int) -> [Int] {\\n        if label == 1 {\\n            return [1]\\n        }\\n\\n        let numberOfRows = Int(ceil(log2(Double(label + 1))))\\n        return pathInZigZagTree((Int(pow(2.0, Double(numberOfRows))) - label + Int(pow(2.0, Double(numberOfRows - 1))) - 1) / 2) + [label]\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport Foundation\\n\\nclass Solution {\\n    func pathInZigZagTree(_ label: Int) -> [Int] {\\n        if label == 1 {\\n            return [1]\\n        }\\n\\n        let numberOfRows = Int(ceil(log2(Double(label + 1))))\\n        return pathInZigZagTree((Int(pow(2.0, Double(numberOfRows))) - label + Int(pow(2.0, Double(numberOfRows - 1))) - 1) / 2) + [label]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 441075,
                "title": "simple-java-solution",
                "content": "Time Complextity: O(log N)\\nSpace Complexity: O(log N)\\n```\\n    public List<Integer> pathInZigZagTree(int label) {        \\n        int num = 1;\\n        int level = 1;\\n        int totalNodes = 1;\\n        \\n        LinkedList<Integer> path = new LinkedList<Integer>();\\n        path.addFirst(label);\\n        \\n        while(totalNodes < label){\\n            num *= 2;\\n            totalNodes += num;\\n            level++;\\n        }\\n        \\n        while(label > 1){\\n            int diff = totalNodes - label;\\n            int parentOffset = diff / 2;\\n            int parentLevelStart = ((totalNodes/2) /2) + 1;\\n            \\n            int parent = parentLevelStart + parentOffset;\\n            path.addFirst(parent);\\n            \\n            label = parent;\\n            totalNodes = totalNodes / 2;\\n        }\\n        return path;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<Integer> pathInZigZagTree(int label) {        \\n        int num = 1;\\n        int level = 1;\\n        int totalNodes = 1;\\n        \\n        LinkedList<Integer> path = new LinkedList<Integer>();\\n        path.addFirst(label);\\n        \\n        while(totalNodes < label){\\n            num *= 2;\\n            totalNodes += num;\\n            level++;\\n        }\\n        \\n        while(label > 1){\\n            int diff = totalNodes - label;\\n            int parentOffset = diff / 2;\\n            int parentLevelStart = ((totalNodes/2) /2) + 1;\\n            \\n            int parent = parentLevelStart + parentOffset;\\n            path.addFirst(parent);\\n            \\n            label = parent;\\n            totalNodes = totalNodes / 2;\\n        }\\n        return path;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 433663,
                "title": "java-100-time-mem-compact-recursion-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> list = new LinkedList<Integer>();\\n        list.add(label);\\n        addNumber(list, label, Integer.highestOneBit(label));\\n        return list;\\n    }\\n    \\n    private void addNumber(List<Integer> numbers, int number, int startPoint) {\\n        if (number == 1) {\\n            return;\\n        }\\n        int index = (number - startPoint + 2) / 2;\\n        int nextNumber = startPoint - index;\\n        numbers.add(0, nextNumber);\\n        addNumber(numbers, nextNumber, Integer.highestOneBit(nextNumber));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> list = new LinkedList<Integer>();\\n        list.add(label);\\n        addNumber(list, label, Integer.highestOneBit(label));\\n        return list;\\n    }\\n    \\n    private void addNumber(List<Integer> numbers, int number, int startPoint) {\\n        if (number == 1) {\\n            return;\\n        }\\n        int index = (number - startPoint + 2) / 2;\\n        int nextNumber = startPoint - index;\\n        numbers.add(0, nextNumber);\\n        addNumber(numbers, nextNumber, Integer.highestOneBit(nextNumber));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425747,
                "title": "easy-to-understand",
                "content": "```\\nvar pathInZigZagTree = function(label) {\\n  let level = 1;\\n  let num = 1;\\n  /* record how many nodes of each level */\\n  let levelCount = 1;\\n  /* find last level */\\n  while (num < label) {\\n    levelCount *= 2;\\n    num += levelCount;\\n    level += 1;\\n  }\\n  /* insert ans in reverse order */\\n  const ans = [label];\\n  while (--level) {\\n    /* because of zigzag, each pair for each level */\\n    /* we find the \\'other\\' number */\\n    let levelEnd = 2 ** (level) - 1;\\n    let levelStart = 2 ** (level - 1);\\n    let target = Math.floor(label / 2);\\n    target = levelEnd + levelStart - target;\\n    label = target;\\n    ans.push(target);\\n  }\\n  \\n  return ans.reverse();\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar pathInZigZagTree = function(label) {\\n  let level = 1;\\n  let num = 1;\\n  /* record how many nodes of each level */\\n  let levelCount = 1;\\n  /* find last level */\\n  while (num < label) {\\n    levelCount *= 2;\\n    num += levelCount;\\n    level += 1;\\n  }\\n  /* insert ans in reverse order */\\n  const ans = [label];\\n  while (--level) {\\n    /* because of zigzag, each pair for each level */\\n    /* we find the \\'other\\' number */\\n    let levelEnd = 2 ** (level) - 1;\\n    let levelStart = 2 ** (level - 1);\\n    let target = Math.floor(label / 2);\\n    target = levelEnd + levelStart - target;\\n    label = target;\\n    ans.push(target);\\n  }\\n  \\n  return ans.reverse();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 382188,
                "title": "java-o-logn",
                "content": "```\\nclass Solution \\n{\\n    public List<Integer> pathInZigZagTree(int label) \\n    {\\n        List<Integer> q = new ArrayList();\\n        while (label != 0)\\n        {\\n            q.add(label);\\n            label /= 2;\\n        }\\n        \\n        Collections.reverse(q);\\n        int base = q.size() % 2 == 0 ? 4 : 2;\\n        for (int i = base / 2; i < q.size(); i += 2)\\n        {\\n            int sum = base * 3 - 1;\\n            base = base << 2;\\n            q.set(i, sum - q.get(i));\\n        }\\n        \\n        \\n        return q;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public List<Integer> pathInZigZagTree(int label) \\n    {\\n        List<Integer> q = new ArrayList();\\n        while (label != 0)\\n        {\\n            q.add(label);\\n            label /= 2;\\n        }\\n        \\n        Collections.reverse(q);\\n        int base = q.size() % 2 == 0 ? 4 : 2;\\n        for (int i = base / 2; i < q.size(); i += 2)\\n        {\\n            int sum = base * 3 - 1;\\n            base = base << 2;\\n            q.set(i, sum - q.get(i));\\n        }\\n        \\n        \\n        return q;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 378478,
                "title": "java-math-beat-100",
                "content": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int row = (int) (Math.log(label)/ Math.log(2));\\n        List<Integer> list = new ArrayList<>(row + 1);\\n        while (label > 1) {\\n            list.add(label);\\n            label = label >> 1;\\n            label = (1 << row--) + (1 << row) - 1 - label; \\n        }\\n        list.add(1);\\n        Collections.reverse(list);\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int row = (int) (Math.log(label)/ Math.log(2));\\n        List<Integer> list = new ArrayList<>(row + 1);\\n        while (label > 1) {\\n            list.add(label);\\n            label = label >> 1;\\n            label = (1 << row--) + (1 << row) - 1 - label; \\n        }\\n        list.add(1);\\n        Collections.reverse(list);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 367549,
                "title": "11-8-mb-less-than-100-00-of-python-online-submissions-python",
                "content": "```class Solution(object):\\n    def pathInZigZagTree(self, label):\\n        \"\"\"\\n        :type label: int\\n        :rtype: List[int]\\n        \"\"\"\\n        liste=set()\\n        n=1\\n        while label > pow(2,n)-1:\\n            n+=1\\n        liste.add(label)\\n        while label>1:\\n            n-=1\\n            label=pow(2,n-1)+(pow(2,n)-1-int(label/2))\\n            liste.add(label)\\n        return sorted(liste)`\\n```",
                "solutionTags": [],
                "code": "```class Solution(object):\\n    def pathInZigZagTree(self, label):\\n        \"\"\"\\n        :type label: int\\n        :rtype: List[int]\\n        \"\"\"\\n        liste=set()\\n        n=1\\n        while label > pow(2,n)-1:\\n            n+=1\\n        liste.add(label)\\n        while label>1:\\n            n-=1\\n            label=pow(2,n-1)+(pow(2,n)-1-int(label/2))\\n            liste.add(label)\\n        return sorted(liste)`\\n```",
                "codeTag": "Java"
            },
            {
                "id": 362791,
                "title": "recursive-java-solution-i-think-it-is-easier-than-other-to-understand",
                "content": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> res = new ArrayList<>();\\n        if(label == 1) {\\n            res.add(1);\\n            return res;\\n        }\\n        // Each level is 2^l ~ 2^(l+1)-1.\\n        int l = log(label);\\n        int prev = label / 2;\\n        prev = (int)Math.pow(2, l-1) + ((int)Math.pow(2, l) - 1 - prev);\\n        res.addAll(pathInZigZagTree(prev));\\n        res.add(label);\\n        return res;\\n    }\\n    \\n    // Return log-2 (x). Round up to smaller value.\\n    public static int log(int x) {\\n        return (int) (Math.log(x) / Math.log(2));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> res = new ArrayList<>();\\n        if(label == 1) {\\n            res.add(1);\\n            return res;\\n        }\\n        // Each level is 2^l ~ 2^(l+1)-1.\\n        int l = log(label);\\n        int prev = label / 2;\\n        prev = (int)Math.pow(2, l-1) + ((int)Math.pow(2, l) - 1 - prev);\\n        res.addAll(pathInZigZagTree(prev));\\n        res.add(label);\\n        return res;\\n    }\\n    \\n    // Return log-2 (x). Round up to smaller value.\\n    public static int log(int x) {\\n        return (int) (Math.log(x) / Math.log(2));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361295,
                "title": "c-solution-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> paths;\\n        int i=0,up=0,res=0,n=label;\\n        bool flag=1;\\n        while(i<32 && n) {i++; n=n>>1;}\\n        //cout<<i;\\n        while(i){\\n            res = (i%2==1) ?(1<<(i-1)) :(1<<i)-1;\\n            //cout<<res<<\" \";\\n            int lab = (flag==0) ?((i%2) ?(res+up) :(res-up)) :label;\\n            flag=0;\\n            up = (i%2==1) ?(lab-res)/2 :(res-lab)/2;\\n            i--;\\n            paths.push_back(lab);\\n        }\\n        reverse(paths.begin(), paths.end());\\n        return paths;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> paths;\\n        int i=0,up=0,res=0,n=label;\\n        bool flag=1;\\n        while(i<32 && n) {i++; n=n>>1;}\\n        //cout<<i;\\n        while(i){\\n            res = (i%2==1) ?(1<<(i-1)) :(1<<i)-1;\\n            //cout<<res<<\" \";\\n            int lab = (flag==0) ?((i%2) ?(res+up) :(res-up)) :label;\\n            flag=0;\\n            up = (i%2==1) ?(lab-res)/2 :(res-lab)/2;\\n            i--;\\n            paths.push_back(lab);\\n        }\\n        reverse(paths.begin(), paths.end());\\n        return paths;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 357749,
                "title": "java-full-explanation-100-beat-in-both",
                "content": "Approach:\\n\\nBrute Force: \\nAs you understand the simplest approach would be just generate the binary tree like above, and do the traversal and find the nodes in between. \\n\\nOptimal Approach: \\nLet\\u2019s understand the question first, \\n1.\\tOdd Level : When level is odd, numbering start from right \\n2.\\tEven Level : When level is Even, numbering start from left \\n\\nNow for a moment forget about the zig-zag tree, and have a normal tree  where numbering is based on node insert in level order traversal\\n\\n![image](https://assets.leetcode.com/users/nits2010/image_1565699666.png)\\n\\nIn Full binary tree, if you are at a node (say 6) we can find its parent by 6/2 = 3 [ because each node have 2 child\\u2019s, then they must be separated by 2 child\\u2019s only at each level].\\nFor 7 -> 7/2 = 3\\nFor 5/2= 2\\n\\nBack to original question.\\nThe only difference with the normal tree vs zig-zag tree has the numbering getting altered based on level (even/odd).\\n\\nOur task is boils down to first find the level, at which our target is placed in zig-zag tree. \\nIf you observe, then you\\u2019ll see its regardless that tree is normal or zig-zag the placement of any label will always be based on Hight of tree [ level of tree ].\\n\\nSo in our original example:\\n![image](https://assets.leetcode.com/users/nits2010/image_1565699708.png)\\n\\nThe level of 14 can be easily evaluated by 2^n >= 14. The least value of n is your level. \\nHere in our case, n = 4 as 2^4 = 16 > 14 [ whereas 2^3 < 14 ].\\n\\nOk, now we know what is the level of our current label = 4. \\nNext we need to know, what is the level at which its parent would be, and that is trivial it will always be 1 less than its level until you hit root. \\n\\nBut since the tree is zig-zag, just doing 14/2 = 7 wont\\u2019 give you the parent. \\nBut it will tell you the where could be the parent. \\nSee at level 3 [ parent level] we have 4 , 5, 6, 7 which tells 7 is symmetry of 4 and 6 is for 5 and vice-versa.\\n\\ni.e. 14/2 = 7 then our parent would be 4 [ 4 is symmetry for 7 ].\\n\\nThere could be multiple way to find this \\n1.\\tUsing Level with odd-even rule\\n2.\\tBy applying maths in it. \\n\\nI\\u2019m covering first 2nd approach. \\nOk, now we know this level have 4,5,6,7 as nodes \\nAnd if you do (7 + 4 \\u2013 4)/2 = (7)/2 = 7/2=3 [your required parent of 4].\\nMeans, (level last node value + level first node value \\u2013 lastLable)/2\\n\\n\\nOk, we know at each level how many nodes are there which is defined by \\n2^(level-1) ; for level = 3 => 2^2 = 4.[ which is the start of this level in normal tree]\\nFor end of the level we can simply do 2^(level) -1 = 8-1 = 7\\n\\nOk, so we have a formula to calculate the last node label and first node label using current level. \\n \\n( ( 2^level -1 ) + ( 2^(level-1)  )  - lable ) /2\\n\\nHence;\\nLabel=14 with level 4 => (2^4 \\u2013 1 + 2^3 \\u2013 14)/2 = (15 + 8 \\u2013 14 )= 9/2 = 4\\nLabel = 4 with level 3 => (7 + 4 \\u2013 4 ) / 2 = 3\\nLabel = 3 with level 2 => (4 + 2 -3 )/2 = 3/2 = 1 [your main root] \\n Hence [1,3,4,14]\\n\\n\\n```\\n\\n    public List<Integer> pathInZigZagTree(int label) {\\n\\n        if (label <= 0)\\n            return Collections.EMPTY_LIST;\\n\\n        if (label == 1)\\n            return Arrays.asList(1);\\n\\n\\n        /**\\n         * Find the level of this label is;\\n         * You can compute like 2^n > label; find the least value of \\'n\\'\\n         */\\n        int level = (int) (Math.log(label) / Math.log(2)) + 1;;\\n\\n        List<Integer> path = new ArrayList<>(level + 1);\\n        path.add(label);\\n\\n        /**\\n         * Backtrack from this level to the root\\n         *\\n         * O(log(level))\\n         */\\n        while (level > 1) {\\n\\n//            int totalNodes = (int) (Math.pow(2, level) - 1 + Math.pow(2, level - 1));\\n\\n            /**\\n             * Find the parent of this label;\\n             * ................................\\n             * In normal tree, the parent of any node is calculated by v/2.\\n             * Since the tree is zig-zag; which parents of every node has push to other side but they have symmetry\\n             *\\n             * For example: Node=14\\n             * For normal tree: 14/2 = 7\\n             * For zig-zag tree: Nodes just above this node are\\n             * 4 , 5 , 6 , 7\\n             * So if it were normal tree, the parent is on 7 while if its zig-zag then its on 4. Which is symmetrical.\\n             *\\n             * Hence,\\n             *\\n             * Find how many nodes are there at this level.\\n             * This level labeling would start from Math.pow(2, level - 1))\\n             * and end at (Math.pow(2, level) - 1\\n             *\\n             * Which is equivalent to ((1 << level) - 1) + (1 << (level - 1))\\n             */\\n            int totalNodes = ((1 << level) - 1) + (1 << (level - 1));\\n\\n\\n            //Parent of this label is same as normal tree parent.\\n            int parentLabel = (totalNodes - label) / 2;\\n\\n            label = parentLabel;\\n            path.add(label);\\n            level--;\\n\\n        }\\n        Collections.reverse(path);\\n        return path;\\n    }\\n```\\n\\nCheck this for way 1: https://leetcode.com/problems/path-in-zigzag-labelled-binary-tree/discuss/323848/Golang-O(log-n)-with-detail-explanation\\n",
                "solutionTags": [],
                "code": "```\\n\\n    public List<Integer> pathInZigZagTree(int label) {\\n\\n        if (label <= 0)\\n            return Collections.EMPTY_LIST;\\n\\n        if (label == 1)\\n            return Arrays.asList(1);\\n\\n\\n        /**\\n         * Find the level of this label is;\\n         * You can compute like 2^n > label; find the least value of \\'n\\'\\n         */\\n        int level = (int) (Math.log(label) / Math.log(2)) + 1;;\\n\\n        List<Integer> path = new ArrayList<>(level + 1);\\n        path.add(label);\\n\\n        /**\\n         * Backtrack from this level to the root\\n         *\\n         * O(log(level))\\n         */\\n        while (level > 1) {\\n\\n//            int totalNodes = (int) (Math.pow(2, level) - 1 + Math.pow(2, level - 1));\\n\\n            /**\\n             * Find the parent of this label;\\n             * ................................\\n             * In normal tree, the parent of any node is calculated by v/2.\\n             * Since the tree is zig-zag; which parents of every node has push to other side but they have symmetry\\n             *\\n             * For example: Node=14\\n             * For normal tree: 14/2 = 7\\n             * For zig-zag tree: Nodes just above this node are\\n             * 4 , 5 , 6 , 7\\n             * So if it were normal tree, the parent is on 7 while if its zig-zag then its on 4. Which is symmetrical.\\n             *\\n             * Hence,\\n             *\\n             * Find how many nodes are there at this level.\\n             * This level labeling would start from Math.pow(2, level - 1))\\n             * and end at (Math.pow(2, level) - 1\\n             *\\n             * Which is equivalent to ((1 << level) - 1) + (1 << (level - 1))\\n             */\\n            int totalNodes = ((1 << level) - 1) + (1 << (level - 1));\\n\\n\\n            //Parent of this label is same as normal tree parent.\\n            int parentLabel = (totalNodes - label) / 2;\\n\\n            label = parentLabel;\\n            path.add(label);\\n            level--;\\n\\n        }\\n        Collections.reverse(path);\\n        return path;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 346434,
                "title": "java-easy-to-understand-solution",
                "content": "1. find out the last row of the node;\\n2. get then normal node index \\n3. add the path from bottom to root. if the row number is even, find the correct label using the formula:  startOfCurrentRow + (num of nodes in this row - (label - startOfCurrentRow)) - 1.    Because num of nodes in current row  is the same as Start label Of current row, then the formula is simplified as: 3 * startOfCurrentRow - normalLabel - 1; \\n       \\n\\t   \\n       public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> path = new LinkedList();\\n        int row = 1; \\n        int startOfNextRow = 2; \\n        while (label >= startOfNextRow) {\\n            startOfNextRow *= 2;\\n            row++;\\n        }\\n        \\n        int startOfCurrentRow = startOfNextRow / 2;\\n        int normalLabel = (row % 2 == 1) ? label : 3 * startOfCurrentRow - label -1;\\n        while (row > 0) {\\n            if (row % 2 == 0) {\\n                path.add(0, 3 * startOfCurrentRow - normalLabel - 1);\\n            }\\n            else {\\n                path.add(0, normalLabel);\\n            }\\n            \\n            startOfCurrentRow /= 2;\\n            normalLabel /= 2;\\n            row--;\\n        }\\n        \\n        return path;\\n\\t\\t}",
                "solutionTags": [],
                "code": "1. find out the last row of the node;\\n2. get then normal node index \\n3. add the path from bottom to root. if the row number is even, find the correct label using the formula:  startOfCurrentRow + (num of nodes in this row - (label - startOfCurrentRow)) - 1.    Because num of nodes in current row  is the same as Start label Of current row, then the formula is simplified as: 3 * startOfCurrentRow - normalLabel - 1; \\n       \\n\\t   \\n       public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> path = new LinkedList();\\n        int row = 1; \\n        int startOfNextRow = 2; \\n        while (label >= startOfNextRow) {\\n            startOfNextRow *= 2;\\n            row++;\\n        }\\n        \\n        int startOfCurrentRow = startOfNextRow / 2;\\n        int normalLabel = (row % 2 == 1) ? label : 3 * startOfCurrentRow - label -1;\\n        while (row > 0) {\\n            if (row % 2 == 0) {\\n                path.add(0, 3 * startOfCurrentRow - normalLabel - 1);\\n            }\\n            else {\\n                path.add(0, normalLabel);\\n            }\\n            \\n            startOfCurrentRow /= 2;\\n            normalLabel /= 2;\\n            row--;\\n        }\\n        \\n        return path;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 333262,
                "title": "c-math-trick-with-xor",
                "content": "Code:- \\n\\nLets consider the level of root is 1.\\n\\nIf the tree is filled normally , left to right for all levels , and assigning a bit 0 for left direction and 1 for right direction , starting with bit 1 for root since label constraint starts from 1 , we can exactly know the number at any level with the directions.\\n\\nIn the zig zag ordering the original position of a number at any level is just the XOR with (total number of nodes-1) in that level.\\nNumber of Nodes at any level can be derived as : power( 2, L-1) ,\\nL is  level \\nSo in level 4 where the zig zag ordering is  15 14 13 12 11 10 9 8, and xoring each with 7 (number of nodes in this level -1) we have 8 9 10 11 12 13 14 15 \\n\\nso dividing the given number by 2 we get its original position in previous level and on XORing operation we get the zig zag element .\\ndo it until the element reaches root:\\n\\n\\n```\\n#include <math.h> \\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int l) {\\n        vector<int> r;\\n        int n = log2(l); // find required bits to hold the number \\n        r.insert(r.begin(), l);\\n        int p = pow(2,n-1)-1;\\n      \\n        while(l !=1)\\n        {\\n            l=l/2;\\n            int t = l^p;   \\n            r.insert(r.begin(),l^p);\\n            l=t;\\n            p = p>>1;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <math.h> \\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int l) {\\n        vector<int> r;\\n        int n = log2(l); // find required bits to hold the number \\n        r.insert(r.begin(), l);\\n        int p = pow(2,n-1)-1;\\n      \\n        while(l !=1)\\n        {\\n            l=l/2;\\n            int t = l^p;   \\n            r.insert(r.begin(),l^p);\\n            l=t;\\n            p = p>>1;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 332115,
                "title": "simple-python",
                "content": "```\\nimport math\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        parent = label\\n        res = [parent]  \\n        row = int(math.log(parent, 2))\\n        rowStart = 2 ** row\\n\\t\\t\\n        while row != 0:\\n            dist_to_start = (parent - rowStart) // 2\\n            parent = rowStart - dist_to_start - 1\\n            res.insert(0, parent)\\n            row -= 1\\n            rowStart //= 2\\n        return res     \\n```\\t\\t",
                "solutionTags": [],
                "code": "```\\nimport math\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        parent = label\\n        res = [parent]  \\n        row = int(math.log(parent, 2))\\n        rowStart = 2 ** row\\n\\t\\t\\n        while row != 0:\\n            dist_to_start = (parent - rowStart) // 2\\n            parent = rowStart - dist_to_start - 1\\n            res.insert(0, parent)\\n            row -= 1\\n            rowStart //= 2\\n        return res     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 329884,
                "title": "python3-it-s-all-about-mathematics",
                "content": "\\tclass Solution:\\n\\t\\tdef pathInZigZagTree(self, label: int) -> List[int]:\\n\\t\\t\\tres=[label]\\n\\t\\t\\tnum=1\\n\\t\\t\\tlevel=1\\n\\t\\t\\twhile num<label:\\n\\t\\t\\t\\tnum=num+2**level\\n\\t\\t\\t\\tlevel+=1  \\n\\t\\t\\twhile label!=0:\\n\\t\\t\\t\\tMAX=2**(level)-1\\n\\t\\t\\t\\tMIN=2**(level-1)                        \\n\\t\\t\\t\\ttem=(MAX+MIN-label)//2            \\n\\t\\t\\t\\tif tem!=0:\\n\\t\\t\\t\\t\\tres.append(tem)\\n\\t\\t\\t\\tlevel-=1\\n\\t\\t\\t\\tlabel=tem\\n\\t\\t\\treturn res[::-1]",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef pathInZigZagTree(self, label: int) -> List[int]:\\n\\t\\t\\tres=[label]\\n\\t\\t\\tnum=1\\n\\t\\t\\tlevel=1\\n\\t\\t\\twhile num<label:\\n\\t\\t\\t\\tnum=num+2**level\\n\\t\\t\\t\\tlevel+=1  \\n\\t\\t\\twhile label!=0:\\n\\t\\t\\t\\tMAX=2**(level)-1\\n\\t\\t\\t\\tMIN=2**(level-1)                        \\n\\t\\t\\t\\ttem=(MAX+MIN-label)//2            \\n\\t\\t\\t\\tif tem!=0:\\n\\t\\t\\t\\t\\tres.append(tem)\\n\\t\\t\\t\\tlevel-=1\\n\\t\\t\\t\\tlabel=tem\\n\\t\\t\\treturn res[::-1]",
                "codeTag": "Java"
            },
            {
                "id": 326834,
                "title": "python-explain-this-math-problem-in-detail-clear-solution-beats-83-72",
                "content": "In a full binary tree (FBT), the number of nodes at level 1 is 1, 2 at level 2, 4 at level 3,..., and `2**(i-1)` at level `i`. So, From level 1 to level `i`, there are `1 + 2 + 4 + ... + 2**(i-1) = 2**i - 1` nodes totally. Suppose the node of `label` is at level `j`, `j` must fullfill `2**(j-1) - 1 < label <= 2**j - 1`. Therefore, we can firstly find out the level of `label` with bit operations.\\n```python\\ntmp = label\\nlevel = 0\\nwhile tmp:\\n    tmp >>= 1\\n    level += 1\\n```\\nThen, we will figure out the location of `label` on its `level`, which we call it `p`. If `level` is odd, nodes would be labelled from left to right. Since there are `2**(level-1)-1` nodes from level 1 to level `level-1`, `label` would be the `label - (2**(level-1) - 1)`-th node at level `level`. On the other hand, if `level` is even, `label` would be the `2**level - label`-th node at level `level`. So,\\n```python\\np = 2**level - label if level % 2 == 0 else label - (2**(level-1) - 1)\\n```\\nImagine a FBT, which is labelled from left to right at every level (you may have seen it if you have been in a data structure class). In this tree, the children of the node labelled `n`, are labelled `2*n` and `2*n+1`. For the node which is at level `level`, and is the `p` th node counted from left to right, its parent is labelled `label / 2`, and its grandparent is labelled `label / 2 / 2`, and so on. We can clearly find the path from the root to `label` by dividing `label` with 2 repeatly until it is equal to 1. After getting such a path, just map it to the FBT of this problem. The mapping rule is:\\n\\n```python\\nif level is odd:\\n    label_on_zigzag_FBT = label_on_normal_FBT\\nif level is even:\\n    label_on_zigzag_FBT = 2**level + 2**(level-1) - 1 - label_on_normal_FBT\\n    label_on_normal_FBT = 2**level + 2**(level-1) - 1 - label_on_zigzag_FBT\\n```\\nThis is acquired from the former equation:\\n```python\\np = 2**level - label if level % 2 == 0 else label - (2**(level-1) - 1)\\n```\\nTree nodes of the same `level` and same `p` map to each others.\\n\\nFinally, we combine all code blocks:\\n```python\\nclass Solution:\\n    def pathInZigZagTree(self, label: int):\\n        tmp = label\\n        level = 0\\n        while tmp:\\n            tmp >>= 1\\n            level += 1\\n\\n        label_on_zigzag_FBT = label\\n        label_on_normal_FBT = label_on_zigzag_FBT\\n        if level % 2 == 0:\\n            label_on_normal_FBT = 2 ** level + 2 ** (level - 1) - 1 - label_on_zigzag_FBT\\n        \\n        ans = []\\n        # path on normal FBT\\n        while label_on_normal_FBT >= 1:\\n            ans.append(label_on_normal_FBT)\\n            label_on_normal_FBT = int(label_on_normal_FBT / 2)\\n\\n        ans.reverse()\\n        # map to zigzag FBT\\n        for i in range(2, len(ans)+1, 2):\\n            ans[i-1] = 2 ** i + 2 ** (i - 1) - 1 - ans[i-1]\\n\\n        return ans\\n```\\n",
                "solutionTags": [],
                "code": "```python\\ntmp = label\\nlevel = 0\\nwhile tmp:\\n    tmp >>= 1\\n    level += 1\\n```\n```python\\np = 2**level - label if level % 2 == 0 else label - (2**(level-1) - 1)\\n```\n```python\\nif level is odd:\\n    label_on_zigzag_FBT = label_on_normal_FBT\\nif level is even:\\n    label_on_zigzag_FBT = 2**level + 2**(level-1) - 1 - label_on_normal_FBT\\n    label_on_normal_FBT = 2**level + 2**(level-1) - 1 - label_on_zigzag_FBT\\n```\n```python\\np = 2**level - label if level % 2 == 0 else label - (2**(level-1) - 1)\\n```\n```python\\nclass Solution:\\n    def pathInZigZagTree(self, label: int):\\n        tmp = label\\n        level = 0\\n        while tmp:\\n            tmp >>= 1\\n            level += 1\\n\\n        label_on_zigzag_FBT = label\\n        label_on_normal_FBT = label_on_zigzag_FBT\\n        if level % 2 == 0:\\n            label_on_normal_FBT = 2 ** level + 2 ** (level - 1) - 1 - label_on_zigzag_FBT\\n        \\n        ans = []\\n        # path on normal FBT\\n        while label_on_normal_FBT >= 1:\\n            ans.append(label_on_normal_FBT)\\n            label_on_normal_FBT = int(label_on_normal_FBT / 2)\\n\\n        ans.reverse()\\n        # map to zigzag FBT\\n        for i in range(2, len(ans)+1, 2):\\n            ans[i-1] = 2 ** i + 2 ** (i - 1) - 1 - ans[i-1]\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 326609,
                "title": "go-o-log-n",
                "content": "```go\\nfunc pathInZigZagTree(label int) []int {\\n    level, s := 1, 1\\n    for ; s < label; level++ { s += 1<<uint(level) }\\n    res := make([]int, level)\\n    res[0], res[level-1] = 1, label\\n    for level -= 2; level > 0; level-- {\\n        s >>= 1\\n        label = s-(label-s+1)/2+1\\n        res[level] = label\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc pathInZigZagTree(label int) []int {\\n    level, s := 1, 1\\n    for ; s < label; level++ { s += 1<<uint(level) }\\n    res := make([]int, level)\\n    res[0], res[level-1] = 1, label\\n    for level -= 2; level > 0; level-- {\\n        s >>= 1\\n        label = s-(label-s+1)/2+1\\n        res[level] = label\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 325656,
                "title": "c-o-log-n-clean-and-a-straight-forward-intuitive-approach",
                "content": "Intuition: \\n1. Every alternate level is reversed. So, every grand-parent of any node is node/4 (Parent of any node => node/2, it\\'s parent => parent/2 or node/4).\\n2. Last level will always be the given parameter label.\\n3. So, all we need is to find the value of parent of label (in case level > 1)\\n\\nFinding parent of label:\\n1. Let there be `level` levels.\\n2. Number of nodes at `level-1 => (2^(level-1)-1)` => let\\'s call this x\\n3. If not reversed, parent will be label/2. This parent is `x-label/2+1 => y` nodes before last node at level-1.\\n4. Since, nodes are reversed at level. New node is y nodes ahead of level-2 => `y + (2^(level-2) - 1)`\\n\\nCode for this intuition:\\n\\n\\t\\tvector<int> pathInZigZagTree(int label) {\\n\\t\\t\\n\\t\\t\\tint level = ceil(log2(label+1));\\n\\n\\t\\t\\tvector<int> labels(level, 0);\\n\\t\\t\\tif (level > 0)\\n\\t\\t\\t\\tlabels[level-1] = label;\\n\\t\\t\\tif (level > 1)\\n\\t\\t\\t\\tlabels[level-2] = ((pow(2,level-1) - 1) - label/2 + 1) + (pow(2, level-2) - 1);\\n\\n\\t\\t\\tfor (int i=level-3; i>=0; i--)\\n\\t\\t\\t\\tlabels[i] = labels[i+2] / 4;\\n\\n\\t\\t\\treturn labels;\\n\\t\\t}\\n\\t\\t\\nComplexity: `O(log n)`",
                "solutionTags": [
                    "C"
                ],
                "code": "Intuition: \\n1. Every alternate level is reversed. So, every grand-parent of any node is node/4 (Parent of any node => node/2, it\\'s parent => parent/2 or node/4).\\n2. Last level will always be the given parameter label.\\n3. So, all we need is to find the value of parent of label (in case level > 1)\\n\\nFinding parent of label:\\n1. Let there be `level` levels.\\n2. Number of nodes at `level-1 => (2^(level-1)-1)` => let\\'s call this x\\n3. If not reversed, parent will be label/2. This parent is `x-label/2+1 => y` nodes before last node at level-1.\\n4. Since, nodes are reversed at level. New node is y nodes ahead of level-2 => `y + (2^(level-2) - 1)`\\n\\nCode for this intuition:\\n\\n\\t\\tvector<int> pathInZigZagTree(int label) {\\n\\t\\t\\n\\t\\t\\tint level = ceil(log2(label+1));\\n\\n\\t\\t\\tvector<int> labels(level, 0);\\n\\t\\t\\tif (level > 0)\\n\\t\\t\\t\\tlabels[level-1] = label;\\n\\t\\t\\tif (level > 1)\\n\\t\\t\\t\\tlabels[level-2] = ((pow(2,level-1) - 1) - label/2 + 1) + (pow(2, level-2) - 1);\\n\\n\\t\\t\\tfor (int i=level-3; i>=0; i--)\\n\\t\\t\\t\\tlabels[i] = labels[i+2] / 4;\\n\\n\\t\\t\\treturn labels;\\n\\t\\t}\\n\\t\\t\\nComplexity: `O(log n)`",
                "codeTag": "Unknown"
            },
            {
                "id": 325408,
                "title": "share-my-code-c",
                "content": "vector<int> pathInZigZagTree(int label) {\\n        int num = log2(label) + 1;\\n        vector<int> res(num, 0);\\n        while (num > 0)\\n        {\\n            res[num - 1] = label;\\n            label = (pow(2, num - 1) + (pow(2, num) - 1 - label)) / 2;\\n            num--;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "vector<int> pathInZigZagTree(int label) {\\n        int num = log2(label) + 1;\\n        vector<int> res(num, 0);\\n        while (num > 0)\\n        {\\n            res[num - 1] = label;\\n            label = (pow(2, num - 1) + (pow(2, num) - 1 - label)) / 2;\\n            num--;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1931980,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "how many of you thinks that question description in not clear."
                    },
                    {
                        "username": "psonlinux",
                        "content": "Given the `label` we can always find how many nodes are there in between `label` and it\\'s parent .\\nLet it be `x` .\\nTo get parent of `label` subtract `label - x - 1 = p` .\\nHow to find `x` ?\\nx = y + z\\ny = no of nodes before `label` and starting node of that row . \\nz = no of nodes after parent p and before starting node of next row .\\n\\nHow to find label of starting node of any row ?\\n`int startRow = 2 ^ log2(nodeLabel)` \\n\\ny = label - startRow\\nOnce you have find y , finding x is simple .\\nz = y / 2, because for each pair of in y there is one parent in level above !\\n\\nPerform above steps until you reach node 1 . Save all parents along the way .\\nTry to digest the idea .\\n\\nT : O(log label)\\nS : O(log label)\\n\\nI am not pasting code deliberately ."
                    },
                    {
                        "username": "nt34542",
                        "content": "Fog chal raha hai in my brain after reading the problem statement\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "what is this problem even asking.... how do we know what the root of the tree even is?"
                    },
                    {
                        "username": "aditya_gupta17",
                        "content": "the constraints of the problem give us a hint that we would not be requiring to create a tree and traverse a tree. Thus we should get a hint of finding a relationship between a node and its parent. By making a tree upto 3-4 levels one can observe that there indeed exists a relationship. let A be the power of two smaller or equal to label. The parent would then be (A-(distance between label and A)/2 +1). Thus we can make a while loop by updating the label\\n\\nint nearestPowerofTwo(int a){\\n    int i=1;\\n    while(i<=a){\\n        i=i*2;\\n    }\\n    i=i/2;\\n    return i;\\n}\\nvector<int> pathInZigZagTree(int label) {\\n    vector<int>ans;\\n    while(label!=1){\\n        ans.push_back(label);\\n        int nearest=nearestPowerofTwo(label);\\n        label=nearest-(((label-nearest)/2)+1);\\n    }\\n    ans.push_back(1);\\n    reverse(ans.begin(),ans.end());\\n    return ans;\\n}"
                    },
                    {
                        "username": "saikrishna_vemaraju",
                        "content": "class Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(label);\\n        //replace every parent with its complement\\n        //complement-start=end-label;\\n        //complement=start+end-label;\\n        //Ex:-c=8+15-14=9\\n        //parent=complement/2;\\n        while(label!=1)\\n        {\\n            int level = (int)(Math.log(label)/Math.log(2));\\n            int start= (int)Math.pow(2,level);\\n            int end =(int)Math.pow(2,level+1)-1;\\n            int complement = start+end-label;\\n            label = complement/2;\\n            list.add(0,label);\\n\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "coderr_divy",
                        "content": "class Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        long count=1;\\n        long n=label;\\n        long p=1;\\n        long k1=0;\\n        while(p<=n){\\n       p=pow(2,k1);\\n       k1++;\\n        }\\n        vector<int>ans;\\n        vector<long>parent(1000000,-1);\\n        \\n       \\n        long turn =1;\\n        long i=2;\\n        deque<long>dq;\\n        dq.push_back(1);\\n       while(i<=n){\\n            stack<long>st;\\n           long nodes=pow(2,count);\\n           long target=(i+nodes-1);\\n           i=nodes;\\n           if(turn==1){\\n               turn=1-turn;\\n               \\n               while(i<=target){\\n                   st.push(i);\\n                   i++;\\n\\n             \\n         }\\n         while(!st.empty()){\\n          \\n             long k=st.top();\\n             if(st.empty())\\n             break;\\n             st.pop();\\n             if(st.empty())\\n             break;\\n             long kk=st.top();\\n               if(st.empty())\\n               break;\\n             st.pop();\\n             if(dq.empty())\\n             break;\\nlong x=dq.front();\\ndq.pop_front();\\nparent[k]=x;\\nparent[kk]=x;\\ndq.push_back(k);\\ndq.push_back(kk);\\n         }\\n\\n               \\n               \\n           }\\n           else{\\n               turn=1-turn;\\n               while(i<=target){\\n                long kx=i;\\n                long kxx=i+1;\\n                i++;\\n                i++;\\n                if(dq.empty())\\n                break;\\n                parent[kx]=dq.front();\\n                parent[kxx]=dq.front();\\n                dq.pop_front();\\n                \\n                dq.push_back(kx);\\n                dq.push_back(kxx);\\n               }\\n           }\\n           count++;\\n       }\\n\\n    long kkk=n;\\n    while(parent[kkk]!=-1){\\n        ans.push_back(parent[kkk]);\\n        kkk=parent[kkk];\\n    }\\n \\n    reverse(ans.begin(),ans.end());\\n       ans.push_back(n);\\n        return ans;\\n    }\\n};\\n\\nI got Runtime error here... please help\\n\\n runtime error: reference binding to misaligned address 0xbebebebebebec0ba for type \\'int\\', which requires 4 byte alignment (stl_deque.h)\\n0xbebebebebebec0ba: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_deque.h:180:16"
                    }
                ]
            },
            {
                "id": 1574940,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "how many of you thinks that question description in not clear."
                    },
                    {
                        "username": "psonlinux",
                        "content": "Given the `label` we can always find how many nodes are there in between `label` and it\\'s parent .\\nLet it be `x` .\\nTo get parent of `label` subtract `label - x - 1 = p` .\\nHow to find `x` ?\\nx = y + z\\ny = no of nodes before `label` and starting node of that row . \\nz = no of nodes after parent p and before starting node of next row .\\n\\nHow to find label of starting node of any row ?\\n`int startRow = 2 ^ log2(nodeLabel)` \\n\\ny = label - startRow\\nOnce you have find y , finding x is simple .\\nz = y / 2, because for each pair of in y there is one parent in level above !\\n\\nPerform above steps until you reach node 1 . Save all parents along the way .\\nTry to digest the idea .\\n\\nT : O(log label)\\nS : O(log label)\\n\\nI am not pasting code deliberately ."
                    },
                    {
                        "username": "nt34542",
                        "content": "Fog chal raha hai in my brain after reading the problem statement\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "what is this problem even asking.... how do we know what the root of the tree even is?"
                    },
                    {
                        "username": "aditya_gupta17",
                        "content": "the constraints of the problem give us a hint that we would not be requiring to create a tree and traverse a tree. Thus we should get a hint of finding a relationship between a node and its parent. By making a tree upto 3-4 levels one can observe that there indeed exists a relationship. let A be the power of two smaller or equal to label. The parent would then be (A-(distance between label and A)/2 +1). Thus we can make a while loop by updating the label\\n\\nint nearestPowerofTwo(int a){\\n    int i=1;\\n    while(i<=a){\\n        i=i*2;\\n    }\\n    i=i/2;\\n    return i;\\n}\\nvector<int> pathInZigZagTree(int label) {\\n    vector<int>ans;\\n    while(label!=1){\\n        ans.push_back(label);\\n        int nearest=nearestPowerofTwo(label);\\n        label=nearest-(((label-nearest)/2)+1);\\n    }\\n    ans.push_back(1);\\n    reverse(ans.begin(),ans.end());\\n    return ans;\\n}"
                    },
                    {
                        "username": "saikrishna_vemaraju",
                        "content": "class Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(label);\\n        //replace every parent with its complement\\n        //complement-start=end-label;\\n        //complement=start+end-label;\\n        //Ex:-c=8+15-14=9\\n        //parent=complement/2;\\n        while(label!=1)\\n        {\\n            int level = (int)(Math.log(label)/Math.log(2));\\n            int start= (int)Math.pow(2,level);\\n            int end =(int)Math.pow(2,level+1)-1;\\n            int complement = start+end-label;\\n            label = complement/2;\\n            list.add(0,label);\\n\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "coderr_divy",
                        "content": "class Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        long count=1;\\n        long n=label;\\n        long p=1;\\n        long k1=0;\\n        while(p<=n){\\n       p=pow(2,k1);\\n       k1++;\\n        }\\n        vector<int>ans;\\n        vector<long>parent(1000000,-1);\\n        \\n       \\n        long turn =1;\\n        long i=2;\\n        deque<long>dq;\\n        dq.push_back(1);\\n       while(i<=n){\\n            stack<long>st;\\n           long nodes=pow(2,count);\\n           long target=(i+nodes-1);\\n           i=nodes;\\n           if(turn==1){\\n               turn=1-turn;\\n               \\n               while(i<=target){\\n                   st.push(i);\\n                   i++;\\n\\n             \\n         }\\n         while(!st.empty()){\\n          \\n             long k=st.top();\\n             if(st.empty())\\n             break;\\n             st.pop();\\n             if(st.empty())\\n             break;\\n             long kk=st.top();\\n               if(st.empty())\\n               break;\\n             st.pop();\\n             if(dq.empty())\\n             break;\\nlong x=dq.front();\\ndq.pop_front();\\nparent[k]=x;\\nparent[kk]=x;\\ndq.push_back(k);\\ndq.push_back(kk);\\n         }\\n\\n               \\n               \\n           }\\n           else{\\n               turn=1-turn;\\n               while(i<=target){\\n                long kx=i;\\n                long kxx=i+1;\\n                i++;\\n                i++;\\n                if(dq.empty())\\n                break;\\n                parent[kx]=dq.front();\\n                parent[kxx]=dq.front();\\n                dq.pop_front();\\n                \\n                dq.push_back(kx);\\n                dq.push_back(kxx);\\n               }\\n           }\\n           count++;\\n       }\\n\\n    long kkk=n;\\n    while(parent[kkk]!=-1){\\n        ans.push_back(parent[kkk]);\\n        kkk=parent[kkk];\\n    }\\n \\n    reverse(ans.begin(),ans.end());\\n       ans.push_back(n);\\n        return ans;\\n    }\\n};\\n\\nI got Runtime error here... please help\\n\\n runtime error: reference binding to misaligned address 0xbebebebebebec0ba for type \\'int\\', which requires 4 byte alignment (stl_deque.h)\\n0xbebebebebebec0ba: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_deque.h:180:16"
                    }
                ]
            },
            {
                "id": 2028000,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "how many of you thinks that question description in not clear."
                    },
                    {
                        "username": "psonlinux",
                        "content": "Given the `label` we can always find how many nodes are there in between `label` and it\\'s parent .\\nLet it be `x` .\\nTo get parent of `label` subtract `label - x - 1 = p` .\\nHow to find `x` ?\\nx = y + z\\ny = no of nodes before `label` and starting node of that row . \\nz = no of nodes after parent p and before starting node of next row .\\n\\nHow to find label of starting node of any row ?\\n`int startRow = 2 ^ log2(nodeLabel)` \\n\\ny = label - startRow\\nOnce you have find y , finding x is simple .\\nz = y / 2, because for each pair of in y there is one parent in level above !\\n\\nPerform above steps until you reach node 1 . Save all parents along the way .\\nTry to digest the idea .\\n\\nT : O(log label)\\nS : O(log label)\\n\\nI am not pasting code deliberately ."
                    },
                    {
                        "username": "nt34542",
                        "content": "Fog chal raha hai in my brain after reading the problem statement\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "what is this problem even asking.... how do we know what the root of the tree even is?"
                    },
                    {
                        "username": "aditya_gupta17",
                        "content": "the constraints of the problem give us a hint that we would not be requiring to create a tree and traverse a tree. Thus we should get a hint of finding a relationship between a node and its parent. By making a tree upto 3-4 levels one can observe that there indeed exists a relationship. let A be the power of two smaller or equal to label. The parent would then be (A-(distance between label and A)/2 +1). Thus we can make a while loop by updating the label\\n\\nint nearestPowerofTwo(int a){\\n    int i=1;\\n    while(i<=a){\\n        i=i*2;\\n    }\\n    i=i/2;\\n    return i;\\n}\\nvector<int> pathInZigZagTree(int label) {\\n    vector<int>ans;\\n    while(label!=1){\\n        ans.push_back(label);\\n        int nearest=nearestPowerofTwo(label);\\n        label=nearest-(((label-nearest)/2)+1);\\n    }\\n    ans.push_back(1);\\n    reverse(ans.begin(),ans.end());\\n    return ans;\\n}"
                    },
                    {
                        "username": "saikrishna_vemaraju",
                        "content": "class Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(label);\\n        //replace every parent with its complement\\n        //complement-start=end-label;\\n        //complement=start+end-label;\\n        //Ex:-c=8+15-14=9\\n        //parent=complement/2;\\n        while(label!=1)\\n        {\\n            int level = (int)(Math.log(label)/Math.log(2));\\n            int start= (int)Math.pow(2,level);\\n            int end =(int)Math.pow(2,level+1)-1;\\n            int complement = start+end-label;\\n            label = complement/2;\\n            list.add(0,label);\\n\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "coderr_divy",
                        "content": "class Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        long count=1;\\n        long n=label;\\n        long p=1;\\n        long k1=0;\\n        while(p<=n){\\n       p=pow(2,k1);\\n       k1++;\\n        }\\n        vector<int>ans;\\n        vector<long>parent(1000000,-1);\\n        \\n       \\n        long turn =1;\\n        long i=2;\\n        deque<long>dq;\\n        dq.push_back(1);\\n       while(i<=n){\\n            stack<long>st;\\n           long nodes=pow(2,count);\\n           long target=(i+nodes-1);\\n           i=nodes;\\n           if(turn==1){\\n               turn=1-turn;\\n               \\n               while(i<=target){\\n                   st.push(i);\\n                   i++;\\n\\n             \\n         }\\n         while(!st.empty()){\\n          \\n             long k=st.top();\\n             if(st.empty())\\n             break;\\n             st.pop();\\n             if(st.empty())\\n             break;\\n             long kk=st.top();\\n               if(st.empty())\\n               break;\\n             st.pop();\\n             if(dq.empty())\\n             break;\\nlong x=dq.front();\\ndq.pop_front();\\nparent[k]=x;\\nparent[kk]=x;\\ndq.push_back(k);\\ndq.push_back(kk);\\n         }\\n\\n               \\n               \\n           }\\n           else{\\n               turn=1-turn;\\n               while(i<=target){\\n                long kx=i;\\n                long kxx=i+1;\\n                i++;\\n                i++;\\n                if(dq.empty())\\n                break;\\n                parent[kx]=dq.front();\\n                parent[kxx]=dq.front();\\n                dq.pop_front();\\n                \\n                dq.push_back(kx);\\n                dq.push_back(kxx);\\n               }\\n           }\\n           count++;\\n       }\\n\\n    long kkk=n;\\n    while(parent[kkk]!=-1){\\n        ans.push_back(parent[kkk]);\\n        kkk=parent[kkk];\\n    }\\n \\n    reverse(ans.begin(),ans.end());\\n       ans.push_back(n);\\n        return ans;\\n    }\\n};\\n\\nI got Runtime error here... please help\\n\\n runtime error: reference binding to misaligned address 0xbebebebebebec0ba for type \\'int\\', which requires 4 byte alignment (stl_deque.h)\\n0xbebebebebebec0ba: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_deque.h:180:16"
                    }
                ]
            },
            {
                "id": 1978228,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "how many of you thinks that question description in not clear."
                    },
                    {
                        "username": "psonlinux",
                        "content": "Given the `label` we can always find how many nodes are there in between `label` and it\\'s parent .\\nLet it be `x` .\\nTo get parent of `label` subtract `label - x - 1 = p` .\\nHow to find `x` ?\\nx = y + z\\ny = no of nodes before `label` and starting node of that row . \\nz = no of nodes after parent p and before starting node of next row .\\n\\nHow to find label of starting node of any row ?\\n`int startRow = 2 ^ log2(nodeLabel)` \\n\\ny = label - startRow\\nOnce you have find y , finding x is simple .\\nz = y / 2, because for each pair of in y there is one parent in level above !\\n\\nPerform above steps until you reach node 1 . Save all parents along the way .\\nTry to digest the idea .\\n\\nT : O(log label)\\nS : O(log label)\\n\\nI am not pasting code deliberately ."
                    },
                    {
                        "username": "nt34542",
                        "content": "Fog chal raha hai in my brain after reading the problem statement\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "what is this problem even asking.... how do we know what the root of the tree even is?"
                    },
                    {
                        "username": "aditya_gupta17",
                        "content": "the constraints of the problem give us a hint that we would not be requiring to create a tree and traverse a tree. Thus we should get a hint of finding a relationship between a node and its parent. By making a tree upto 3-4 levels one can observe that there indeed exists a relationship. let A be the power of two smaller or equal to label. The parent would then be (A-(distance between label and A)/2 +1). Thus we can make a while loop by updating the label\\n\\nint nearestPowerofTwo(int a){\\n    int i=1;\\n    while(i<=a){\\n        i=i*2;\\n    }\\n    i=i/2;\\n    return i;\\n}\\nvector<int> pathInZigZagTree(int label) {\\n    vector<int>ans;\\n    while(label!=1){\\n        ans.push_back(label);\\n        int nearest=nearestPowerofTwo(label);\\n        label=nearest-(((label-nearest)/2)+1);\\n    }\\n    ans.push_back(1);\\n    reverse(ans.begin(),ans.end());\\n    return ans;\\n}"
                    },
                    {
                        "username": "saikrishna_vemaraju",
                        "content": "class Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(label);\\n        //replace every parent with its complement\\n        //complement-start=end-label;\\n        //complement=start+end-label;\\n        //Ex:-c=8+15-14=9\\n        //parent=complement/2;\\n        while(label!=1)\\n        {\\n            int level = (int)(Math.log(label)/Math.log(2));\\n            int start= (int)Math.pow(2,level);\\n            int end =(int)Math.pow(2,level+1)-1;\\n            int complement = start+end-label;\\n            label = complement/2;\\n            list.add(0,label);\\n\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "coderr_divy",
                        "content": "class Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        long count=1;\\n        long n=label;\\n        long p=1;\\n        long k1=0;\\n        while(p<=n){\\n       p=pow(2,k1);\\n       k1++;\\n        }\\n        vector<int>ans;\\n        vector<long>parent(1000000,-1);\\n        \\n       \\n        long turn =1;\\n        long i=2;\\n        deque<long>dq;\\n        dq.push_back(1);\\n       while(i<=n){\\n            stack<long>st;\\n           long nodes=pow(2,count);\\n           long target=(i+nodes-1);\\n           i=nodes;\\n           if(turn==1){\\n               turn=1-turn;\\n               \\n               while(i<=target){\\n                   st.push(i);\\n                   i++;\\n\\n             \\n         }\\n         while(!st.empty()){\\n          \\n             long k=st.top();\\n             if(st.empty())\\n             break;\\n             st.pop();\\n             if(st.empty())\\n             break;\\n             long kk=st.top();\\n               if(st.empty())\\n               break;\\n             st.pop();\\n             if(dq.empty())\\n             break;\\nlong x=dq.front();\\ndq.pop_front();\\nparent[k]=x;\\nparent[kk]=x;\\ndq.push_back(k);\\ndq.push_back(kk);\\n         }\\n\\n               \\n               \\n           }\\n           else{\\n               turn=1-turn;\\n               while(i<=target){\\n                long kx=i;\\n                long kxx=i+1;\\n                i++;\\n                i++;\\n                if(dq.empty())\\n                break;\\n                parent[kx]=dq.front();\\n                parent[kxx]=dq.front();\\n                dq.pop_front();\\n                \\n                dq.push_back(kx);\\n                dq.push_back(kxx);\\n               }\\n           }\\n           count++;\\n       }\\n\\n    long kkk=n;\\n    while(parent[kkk]!=-1){\\n        ans.push_back(parent[kkk]);\\n        kkk=parent[kkk];\\n    }\\n \\n    reverse(ans.begin(),ans.end());\\n       ans.push_back(n);\\n        return ans;\\n    }\\n};\\n\\nI got Runtime error here... please help\\n\\n runtime error: reference binding to misaligned address 0xbebebebebebec0ba for type \\'int\\', which requires 4 byte alignment (stl_deque.h)\\n0xbebebebebebec0ba: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_deque.h:180:16"
                    }
                ]
            },
            {
                "id": 1805408,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "how many of you thinks that question description in not clear."
                    },
                    {
                        "username": "psonlinux",
                        "content": "Given the `label` we can always find how many nodes are there in between `label` and it\\'s parent .\\nLet it be `x` .\\nTo get parent of `label` subtract `label - x - 1 = p` .\\nHow to find `x` ?\\nx = y + z\\ny = no of nodes before `label` and starting node of that row . \\nz = no of nodes after parent p and before starting node of next row .\\n\\nHow to find label of starting node of any row ?\\n`int startRow = 2 ^ log2(nodeLabel)` \\n\\ny = label - startRow\\nOnce you have find y , finding x is simple .\\nz = y / 2, because for each pair of in y there is one parent in level above !\\n\\nPerform above steps until you reach node 1 . Save all parents along the way .\\nTry to digest the idea .\\n\\nT : O(log label)\\nS : O(log label)\\n\\nI am not pasting code deliberately ."
                    },
                    {
                        "username": "nt34542",
                        "content": "Fog chal raha hai in my brain after reading the problem statement\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "what is this problem even asking.... how do we know what the root of the tree even is?"
                    },
                    {
                        "username": "aditya_gupta17",
                        "content": "the constraints of the problem give us a hint that we would not be requiring to create a tree and traverse a tree. Thus we should get a hint of finding a relationship between a node and its parent. By making a tree upto 3-4 levels one can observe that there indeed exists a relationship. let A be the power of two smaller or equal to label. The parent would then be (A-(distance between label and A)/2 +1). Thus we can make a while loop by updating the label\\n\\nint nearestPowerofTwo(int a){\\n    int i=1;\\n    while(i<=a){\\n        i=i*2;\\n    }\\n    i=i/2;\\n    return i;\\n}\\nvector<int> pathInZigZagTree(int label) {\\n    vector<int>ans;\\n    while(label!=1){\\n        ans.push_back(label);\\n        int nearest=nearestPowerofTwo(label);\\n        label=nearest-(((label-nearest)/2)+1);\\n    }\\n    ans.push_back(1);\\n    reverse(ans.begin(),ans.end());\\n    return ans;\\n}"
                    },
                    {
                        "username": "saikrishna_vemaraju",
                        "content": "class Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(label);\\n        //replace every parent with its complement\\n        //complement-start=end-label;\\n        //complement=start+end-label;\\n        //Ex:-c=8+15-14=9\\n        //parent=complement/2;\\n        while(label!=1)\\n        {\\n            int level = (int)(Math.log(label)/Math.log(2));\\n            int start= (int)Math.pow(2,level);\\n            int end =(int)Math.pow(2,level+1)-1;\\n            int complement = start+end-label;\\n            label = complement/2;\\n            list.add(0,label);\\n\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "coderr_divy",
                        "content": "class Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        long count=1;\\n        long n=label;\\n        long p=1;\\n        long k1=0;\\n        while(p<=n){\\n       p=pow(2,k1);\\n       k1++;\\n        }\\n        vector<int>ans;\\n        vector<long>parent(1000000,-1);\\n        \\n       \\n        long turn =1;\\n        long i=2;\\n        deque<long>dq;\\n        dq.push_back(1);\\n       while(i<=n){\\n            stack<long>st;\\n           long nodes=pow(2,count);\\n           long target=(i+nodes-1);\\n           i=nodes;\\n           if(turn==1){\\n               turn=1-turn;\\n               \\n               while(i<=target){\\n                   st.push(i);\\n                   i++;\\n\\n             \\n         }\\n         while(!st.empty()){\\n          \\n             long k=st.top();\\n             if(st.empty())\\n             break;\\n             st.pop();\\n             if(st.empty())\\n             break;\\n             long kk=st.top();\\n               if(st.empty())\\n               break;\\n             st.pop();\\n             if(dq.empty())\\n             break;\\nlong x=dq.front();\\ndq.pop_front();\\nparent[k]=x;\\nparent[kk]=x;\\ndq.push_back(k);\\ndq.push_back(kk);\\n         }\\n\\n               \\n               \\n           }\\n           else{\\n               turn=1-turn;\\n               while(i<=target){\\n                long kx=i;\\n                long kxx=i+1;\\n                i++;\\n                i++;\\n                if(dq.empty())\\n                break;\\n                parent[kx]=dq.front();\\n                parent[kxx]=dq.front();\\n                dq.pop_front();\\n                \\n                dq.push_back(kx);\\n                dq.push_back(kxx);\\n               }\\n           }\\n           count++;\\n       }\\n\\n    long kkk=n;\\n    while(parent[kkk]!=-1){\\n        ans.push_back(parent[kkk]);\\n        kkk=parent[kkk];\\n    }\\n \\n    reverse(ans.begin(),ans.end());\\n       ans.push_back(n);\\n        return ans;\\n    }\\n};\\n\\nI got Runtime error here... please help\\n\\n runtime error: reference binding to misaligned address 0xbebebebebebec0ba for type \\'int\\', which requires 4 byte alignment (stl_deque.h)\\n0xbebebebebebec0ba: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_deque.h:180:16"
                    }
                ]
            },
            {
                "id": 1748069,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "how many of you thinks that question description in not clear."
                    },
                    {
                        "username": "psonlinux",
                        "content": "Given the `label` we can always find how many nodes are there in between `label` and it\\'s parent .\\nLet it be `x` .\\nTo get parent of `label` subtract `label - x - 1 = p` .\\nHow to find `x` ?\\nx = y + z\\ny = no of nodes before `label` and starting node of that row . \\nz = no of nodes after parent p and before starting node of next row .\\n\\nHow to find label of starting node of any row ?\\n`int startRow = 2 ^ log2(nodeLabel)` \\n\\ny = label - startRow\\nOnce you have find y , finding x is simple .\\nz = y / 2, because for each pair of in y there is one parent in level above !\\n\\nPerform above steps until you reach node 1 . Save all parents along the way .\\nTry to digest the idea .\\n\\nT : O(log label)\\nS : O(log label)\\n\\nI am not pasting code deliberately ."
                    },
                    {
                        "username": "nt34542",
                        "content": "Fog chal raha hai in my brain after reading the problem statement\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "what is this problem even asking.... how do we know what the root of the tree even is?"
                    },
                    {
                        "username": "aditya_gupta17",
                        "content": "the constraints of the problem give us a hint that we would not be requiring to create a tree and traverse a tree. Thus we should get a hint of finding a relationship between a node and its parent. By making a tree upto 3-4 levels one can observe that there indeed exists a relationship. let A be the power of two smaller or equal to label. The parent would then be (A-(distance between label and A)/2 +1). Thus we can make a while loop by updating the label\\n\\nint nearestPowerofTwo(int a){\\n    int i=1;\\n    while(i<=a){\\n        i=i*2;\\n    }\\n    i=i/2;\\n    return i;\\n}\\nvector<int> pathInZigZagTree(int label) {\\n    vector<int>ans;\\n    while(label!=1){\\n        ans.push_back(label);\\n        int nearest=nearestPowerofTwo(label);\\n        label=nearest-(((label-nearest)/2)+1);\\n    }\\n    ans.push_back(1);\\n    reverse(ans.begin(),ans.end());\\n    return ans;\\n}"
                    },
                    {
                        "username": "saikrishna_vemaraju",
                        "content": "class Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(label);\\n        //replace every parent with its complement\\n        //complement-start=end-label;\\n        //complement=start+end-label;\\n        //Ex:-c=8+15-14=9\\n        //parent=complement/2;\\n        while(label!=1)\\n        {\\n            int level = (int)(Math.log(label)/Math.log(2));\\n            int start= (int)Math.pow(2,level);\\n            int end =(int)Math.pow(2,level+1)-1;\\n            int complement = start+end-label;\\n            label = complement/2;\\n            list.add(0,label);\\n\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "coderr_divy",
                        "content": "class Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        long count=1;\\n        long n=label;\\n        long p=1;\\n        long k1=0;\\n        while(p<=n){\\n       p=pow(2,k1);\\n       k1++;\\n        }\\n        vector<int>ans;\\n        vector<long>parent(1000000,-1);\\n        \\n       \\n        long turn =1;\\n        long i=2;\\n        deque<long>dq;\\n        dq.push_back(1);\\n       while(i<=n){\\n            stack<long>st;\\n           long nodes=pow(2,count);\\n           long target=(i+nodes-1);\\n           i=nodes;\\n           if(turn==1){\\n               turn=1-turn;\\n               \\n               while(i<=target){\\n                   st.push(i);\\n                   i++;\\n\\n             \\n         }\\n         while(!st.empty()){\\n          \\n             long k=st.top();\\n             if(st.empty())\\n             break;\\n             st.pop();\\n             if(st.empty())\\n             break;\\n             long kk=st.top();\\n               if(st.empty())\\n               break;\\n             st.pop();\\n             if(dq.empty())\\n             break;\\nlong x=dq.front();\\ndq.pop_front();\\nparent[k]=x;\\nparent[kk]=x;\\ndq.push_back(k);\\ndq.push_back(kk);\\n         }\\n\\n               \\n               \\n           }\\n           else{\\n               turn=1-turn;\\n               while(i<=target){\\n                long kx=i;\\n                long kxx=i+1;\\n                i++;\\n                i++;\\n                if(dq.empty())\\n                break;\\n                parent[kx]=dq.front();\\n                parent[kxx]=dq.front();\\n                dq.pop_front();\\n                \\n                dq.push_back(kx);\\n                dq.push_back(kxx);\\n               }\\n           }\\n           count++;\\n       }\\n\\n    long kkk=n;\\n    while(parent[kkk]!=-1){\\n        ans.push_back(parent[kkk]);\\n        kkk=parent[kkk];\\n    }\\n \\n    reverse(ans.begin(),ans.end());\\n       ans.push_back(n);\\n        return ans;\\n    }\\n};\\n\\nI got Runtime error here... please help\\n\\n runtime error: reference binding to misaligned address 0xbebebebebebec0ba for type \\'int\\', which requires 4 byte alignment (stl_deque.h)\\n0xbebebebebebec0ba: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_deque.h:180:16"
                    }
                ]
            },
            {
                "id": 1711845,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "how many of you thinks that question description in not clear."
                    },
                    {
                        "username": "psonlinux",
                        "content": "Given the `label` we can always find how many nodes are there in between `label` and it\\'s parent .\\nLet it be `x` .\\nTo get parent of `label` subtract `label - x - 1 = p` .\\nHow to find `x` ?\\nx = y + z\\ny = no of nodes before `label` and starting node of that row . \\nz = no of nodes after parent p and before starting node of next row .\\n\\nHow to find label of starting node of any row ?\\n`int startRow = 2 ^ log2(nodeLabel)` \\n\\ny = label - startRow\\nOnce you have find y , finding x is simple .\\nz = y / 2, because for each pair of in y there is one parent in level above !\\n\\nPerform above steps until you reach node 1 . Save all parents along the way .\\nTry to digest the idea .\\n\\nT : O(log label)\\nS : O(log label)\\n\\nI am not pasting code deliberately ."
                    },
                    {
                        "username": "nt34542",
                        "content": "Fog chal raha hai in my brain after reading the problem statement\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "what is this problem even asking.... how do we know what the root of the tree even is?"
                    },
                    {
                        "username": "aditya_gupta17",
                        "content": "the constraints of the problem give us a hint that we would not be requiring to create a tree and traverse a tree. Thus we should get a hint of finding a relationship between a node and its parent. By making a tree upto 3-4 levels one can observe that there indeed exists a relationship. let A be the power of two smaller or equal to label. The parent would then be (A-(distance between label and A)/2 +1). Thus we can make a while loop by updating the label\\n\\nint nearestPowerofTwo(int a){\\n    int i=1;\\n    while(i<=a){\\n        i=i*2;\\n    }\\n    i=i/2;\\n    return i;\\n}\\nvector<int> pathInZigZagTree(int label) {\\n    vector<int>ans;\\n    while(label!=1){\\n        ans.push_back(label);\\n        int nearest=nearestPowerofTwo(label);\\n        label=nearest-(((label-nearest)/2)+1);\\n    }\\n    ans.push_back(1);\\n    reverse(ans.begin(),ans.end());\\n    return ans;\\n}"
                    },
                    {
                        "username": "saikrishna_vemaraju",
                        "content": "class Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(label);\\n        //replace every parent with its complement\\n        //complement-start=end-label;\\n        //complement=start+end-label;\\n        //Ex:-c=8+15-14=9\\n        //parent=complement/2;\\n        while(label!=1)\\n        {\\n            int level = (int)(Math.log(label)/Math.log(2));\\n            int start= (int)Math.pow(2,level);\\n            int end =(int)Math.pow(2,level+1)-1;\\n            int complement = start+end-label;\\n            label = complement/2;\\n            list.add(0,label);\\n\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "coderr_divy",
                        "content": "class Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        long count=1;\\n        long n=label;\\n        long p=1;\\n        long k1=0;\\n        while(p<=n){\\n       p=pow(2,k1);\\n       k1++;\\n        }\\n        vector<int>ans;\\n        vector<long>parent(1000000,-1);\\n        \\n       \\n        long turn =1;\\n        long i=2;\\n        deque<long>dq;\\n        dq.push_back(1);\\n       while(i<=n){\\n            stack<long>st;\\n           long nodes=pow(2,count);\\n           long target=(i+nodes-1);\\n           i=nodes;\\n           if(turn==1){\\n               turn=1-turn;\\n               \\n               while(i<=target){\\n                   st.push(i);\\n                   i++;\\n\\n             \\n         }\\n         while(!st.empty()){\\n          \\n             long k=st.top();\\n             if(st.empty())\\n             break;\\n             st.pop();\\n             if(st.empty())\\n             break;\\n             long kk=st.top();\\n               if(st.empty())\\n               break;\\n             st.pop();\\n             if(dq.empty())\\n             break;\\nlong x=dq.front();\\ndq.pop_front();\\nparent[k]=x;\\nparent[kk]=x;\\ndq.push_back(k);\\ndq.push_back(kk);\\n         }\\n\\n               \\n               \\n           }\\n           else{\\n               turn=1-turn;\\n               while(i<=target){\\n                long kx=i;\\n                long kxx=i+1;\\n                i++;\\n                i++;\\n                if(dq.empty())\\n                break;\\n                parent[kx]=dq.front();\\n                parent[kxx]=dq.front();\\n                dq.pop_front();\\n                \\n                dq.push_back(kx);\\n                dq.push_back(kxx);\\n               }\\n           }\\n           count++;\\n       }\\n\\n    long kkk=n;\\n    while(parent[kkk]!=-1){\\n        ans.push_back(parent[kkk]);\\n        kkk=parent[kkk];\\n    }\\n \\n    reverse(ans.begin(),ans.end());\\n       ans.push_back(n);\\n        return ans;\\n    }\\n};\\n\\nI got Runtime error here... please help\\n\\n runtime error: reference binding to misaligned address 0xbebebebebebec0ba for type \\'int\\', which requires 4 byte alignment (stl_deque.h)\\n0xbebebebebebec0ba: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_deque.h:180:16"
                    }
                ]
            }
        ]
    },
    {
        "title": "Bank Account Summary II",
        "question_content": "<p>Table: <code>Users</code></p>\n\n<pre>\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| account      | int     |\n| name         | varchar |\n+--------------+---------+\naccount is the primary key (column with unique values) for this table.\nEach row of this table contains the account number of each user in the bank.\nThere will be no two users having the same name in the table.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Transactions</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| trans_id      | int     |\n| account       | int     |\n| amount        | int     |\n| transacted_on | date    |\n+---------------+---------+\ntrans_id is the primary key (column with unique values) for this table.\nEach row of this table contains all changes made to all accounts.\namount is positive if the user received money and negative if they transferred money.\nAll accounts start with a balance of 0.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to report the name and balance of users with a balance higher than <code>10000</code>. The balance of an account is equal to the sum of the amounts of all transactions involving that account.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nUsers table:\n+------------+--------------+\n| account    | name         |\n+------------+--------------+\n| 900001     | Alice        |\n| 900002     | Bob          |\n| 900003     | Charlie      |\n+------------+--------------+\nTransactions table:\n+------------+------------+------------+---------------+\n| trans_id   | account    | amount     | transacted_on |\n+------------+------------+------------+---------------+\n| 1          | 900001     | 7000       |  2020-08-01   |\n| 2          | 900001     | 7000       |  2020-09-01   |\n| 3          | 900001     | -3000      |  2020-09-02   |\n| 4          | 900002     | 1000       |  2020-09-12   |\n| 5          | 900003     | 6000       |  2020-08-07   |\n| 6          | 900003     | 6000       |  2020-09-07   |\n| 7          | 900003     | -4000      |  2020-09-11   |\n+------------+------------+------------+---------------+\n<strong>Output:</strong> \n+------------+------------+\n| name       | balance    |\n+------------+------------+\n| Alice      | 11000      |\n+------------+------------+\n<strong>Explanation:</strong> \nAlice&#39;s balance is (7000 + 7000 - 3000) = 11000.\nBob&#39;s balance is 1000.\nCharlie&#39;s balance is (6000 + 6000 - 4000) = 8000.\n</pre>\n",
        "solutions": [
            {
                "id": 851440,
                "title": "straight-forward-mysql-solution",
                "content": "```\\nselect\\n    a.name,\\n    sum(b.amount) balance\\nfrom\\n    Users a\\njoin\\n    Transactions b\\non\\n    a.account = b.account\\ngroup by\\n    a.account\\nhaving\\n    balance > 10000;\\n```",
                "solutionTags": [],
                "code": "```\\nselect\\n    a.name,\\n    sum(b.amount) balance\\nfrom\\n    Users a\\njoin\\n    Transactions b\\non\\n    a.account = b.account\\ngroup by\\n    a.account\\nhaving\\n    balance > 10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 861510,
                "title": "mysql-with-cte-faster-91",
                "content": "```\\nwith tmp as(\\nselect t.account, u.name, sum(amount) as balance\\nfrom Transactions t\\nleft join Users u on t.account = u.account\\ngroup by account )\\n\\nselect name, balance\\nfrom tmp\\nwhere balance > 10000\\n```",
                "solutionTags": [],
                "code": "```\\nwith tmp as(\\nselect t.account, u.name, sum(amount) as balance\\nfrom Transactions t\\nleft join Users u on t.account = u.account\\ngroup by account )\\n\\nselect name, balance\\nfrom tmp\\nwhere balance > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1978360,
                "title": "mysql-easy-to-understand",
                "content": "```\\nSELECT u.name as name , SUM(t.amount) as balance \\nFROM \\nUSERS u JOIN TRANSACTIONS t on u.account=t.account\\nGROUP BY \\nt.ACCOUNT HAVING balance>10000;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT u.name as name , SUM(t.amount) as balance \\nFROM \\nUSERS u JOIN TRANSACTIONS t on u.account=t.account\\nGROUP BY \\nt.ACCOUNT HAVING balance>10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2520664,
                "title": "mysql-beginner-level-easy-to-understand-simple-short-solution",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome.***\\n*====================================================================*\\n\\u2705 **MySQL Code :**\\n```\\nSELECT a.NAME, b.BALANCE FROM Users a JOIN\\n(SELECT account, SUM(amount) AS balance FROM Transactions GROUP BY account HAVING SUM(amount) > 10000) b ON a.account = b.account;\\n```\\n**Runtime:** 1299 ms\\n**Memory Usage:**  0B\\n________________________________\\n__________________________________\\n\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT a.NAME, b.BALANCE FROM Users a JOIN\\n(SELECT account, SUM(amount) AS balance FROM Transactions GROUP BY account HAVING SUM(amount) > 10000) b ON a.account = b.account;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 851938,
                "title": "mysql-faster-than-100",
                "content": "```\\nselect name, sum(amount) balance\\nfrom users\\nleft join transactions\\nusing(account)\\ngroup by account\\nhaving balance > 10000\\n```",
                "solutionTags": [],
                "code": "```\\nselect name, sum(amount) balance\\nfrom users\\nleft join transactions\\nusing(account)\\ngroup by account\\nhaving balance > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1891472,
                "title": "mysql-faster-than-92-80-elegant-solution",
                "content": "```\\nSELECT u.name, SUM(t.amount) AS balance FROM Users AS u\\nINNER JOIN Transactions AS t ON u.account = t.account\\nGROUP BY u.account\\nHAVING balance > 10000;\\n```\\n\\n![image](https://assets.leetcode.com/users/images/3c86953d-208c-43eb-b379-c7e128ec3a8c_1648469997.1175315.png)\\n",
                "solutionTags": [],
                "code": "```\\nSELECT u.name, SUM(t.amount) AS balance FROM Users AS u\\nINNER JOIN Transactions AS t ON u.account = t.account\\nGROUP BY u.account\\nHAVING balance > 10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3274983,
                "title": "easy-to-understand-sql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT u.name, SUM(t.amount) AS balance \\nFROM Users u JOIN Transactions t\\nON u.account = t.account\\nGROUP BY t.account\\nHAVING (balance > 10000);\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT u.name, SUM(t.amount) AS balance \\nFROM Users u JOIN Transactions t\\nON u.account = t.account\\nGROUP BY t.account\\nHAVING (balance > 10000);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3010178,
                "title": "just-left-join",
                "content": "\\n# Code\\n```\\nselect u.name,sum(amount) as balance from users u left join transactions t on u.account=t.account group by u.account having (sum(amount)>10000);\\n```\\n\\n```don\\'t forget to upvote```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect u.name,sum(amount) as balance from users u left join transactions t on u.account=t.account group by u.account having (sum(amount)>10000);\\n```\n```don\\'t forget to upvote```",
                "codeTag": "Unknown"
            },
            {
                "id": 2546704,
                "title": "1587-bank-account-summary-ii",
                "content": "```\\nSELECT name, SUM(amount) AS balance\\nFROM Users\\nINNER JOIN Transactions\\nON Users.account = Transactions.account\\nGROUP BY Users.account HAVING balance > 10000;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT name, SUM(amount) AS balance\\nFROM Users\\nINNER JOIN Transactions\\nON Users.account = Transactions.account\\nGROUP BY Users.account HAVING balance > 10000;",
                "codeTag": "Unknown"
            },
            {
                "id": 2288157,
                "title": "mysql-runtime-557-ms-faster-than-91-79",
                "content": "```\\nSELECT a.name, SUM(b.amount) balance\\nFROM Users a\\nJOIN Transactions b\\nON a.account = b.account\\nGROUP BY a.account\\nHAVING balance > 10000;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT a.name, SUM(b.amount) balance\\nFROM Users a\\nJOIN Transactions b\\nON a.account = b.account\\nGROUP BY a.account\\nHAVING balance > 10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3271146,
                "title": "mysql-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT u.name, SUM(t.amount) AS balance \\nFROM Users u JOIN Transactions t\\nON u.account = t.account\\nGROUP BY t.account\\nHAVING (balance > 10000);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT u.name, SUM(t.amount) AS balance \\nFROM Users u JOIN Transactions t\\nON u.account = t.account\\nGROUP BY t.account\\nHAVING (balance > 10000);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3167047,
                "title": "easiest-solution-without-using-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSelect U.name,sum(T.amount) as balance from Users U , Transactions T \\nwhere U.account = T.account group by U.account having balance > 10000;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSelect U.name,sum(T.amount) as balance from Users U , Transactions T \\nwhere U.account = T.account group by U.account having balance > 10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2578691,
                "title": "bank-account-summary-ii-solution-sql",
                "content": "select name,sum(amount) balance\\nfrom Transactions t\\njoin Users u\\non t.account = u.account\\ngroup by name\\nhaving balance>10000",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select name,sum(amount) balance\\nfrom Transactions t\\njoin Users u\\non t.account = u.account\\ngroup by name\\nhaving balance>10000",
                "codeTag": "Unknown"
            },
            {
                "id": 1012313,
                "title": "mysql-left-join-solution",
                "content": "```\\nSELECT \\n    Users.name,\\n    sum(Transactions.amount) AS balance\\nFROM Transactions\\nLEFT JOIN Users \\nON Transactions.account = Users.account\\nGROUP BY Transactions.account \\nHAVING sum(Transactions.amount) > 10000\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT \\n    Users.name,\\n    sum(Transactions.amount) AS balance\\nFROM Transactions\\nLEFT JOIN Users \\nON Transactions.account = Users.account\\nGROUP BY Transactions.account \\nHAVING sum(Transactions.amount) > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3477566,
                "title": "my-bank-account-summary-ii",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect name, sum(amount) as balance\\nfrom Users as u\\njoin Transactions as t\\non u.account = t.account\\ngroup by name\\nhaving balance > 10000\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect name, sum(amount) as balance\\nfrom Users as u\\njoin Transactions as t\\non u.account = t.account\\ngroup by name\\nhaving balance > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2699708,
                "title": "mysql-group-by-left-join",
                "content": "# Write your MySQL query statement below\\n```\\nSELECT u.name AS name , SUM(t.amount) AS balance\\nFROM Users AS u LEFT JOIN Transactions AS t \\nON u.account=t.account\\nGROUP BY name HAVING balance>10000;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT u.name AS name , SUM(t.amount) AS balance\\nFROM Users AS u LEFT JOIN Transactions AS t \\nON u.account=t.account\\nGROUP BY name HAVING balance>10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2284052,
                "title": "oracle-best-and-simple-solution",
                "content": "```\\n/* Write your PL/SQL query statement below */\\n\\nSELECT * FROM\\n(\\n    SELECT \\n    u.name AS \"NAME\", \\n    SUM(t.amount) AS \"BALANCE\" FROM users u\\n    NATURAL JOIN\\n    transactions t\\n    GROUP BY account, u.name\\n) WHERE balance > 10000;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\n\\nSELECT * FROM\\n(\\n    SELECT \\n    u.name AS \"NAME\", \\n    SUM(t.amount) AS \"BALANCE\" FROM users u\\n    NATURAL JOIN\\n    transactions t\\n    GROUP BY account, u.name\\n) WHERE balance > 10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1149051,
                "title": "ms-sql-join-having",
                "content": "```\\nSELECT U.name, SUM(T.amount) AS \\'balance\\'\\nFROM Transactions T\\nINNER JOIN Users U\\nON T.account = U.account\\nGROUP BY U.name\\nHAVING SUM(T.amount) >= 10000;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT U.name, SUM(T.amount) AS \\'balance\\'\\nFROM Transactions T\\nINNER JOIN Users U\\nON T.account = U.account\\nGROUP BY U.name\\nHAVING SUM(T.amount) >= 10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 950169,
                "title": "mysql-oracle-sql-server-fast-solution",
                "content": "```\\nselect\\nname,sum(amount) balance\\nfrom\\nTransactions t\\njoin users u\\non t.account=u.account\\ngroup by name\\nhaving sum(amount)>10000",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\nselect\\nname,sum(amount) balance\\nfrom\\nTransactions t\\njoin users u\\non t.account=u.account\\ngroup by name\\nhaving sum(amount)>10000",
                "codeTag": "Unknown"
            },
            {
                "id": 3894600,
                "title": "pandas-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSurprisingly, I didn\\'t find a Pandas solution on leetcode, which is exactly one of the reasons I want to post it. I don\\'t think this is the best solution, really, but for a while is the best)))\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nVery simple, step by step:\\n1) Convert initial table to calculate\\n2) Preparing output empty table\\n3) Create rows and sum amount into balance for each name in cycle\\n4) Select balances more than 10000\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n450ms\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n62.06\\n# Code\\n```\\nimport pandas as pd\\n\\ndef account_summary(users: pd.DataFrame, transactions: pd.DataFrame) -> pd.DataFrame:\\n  temp = pd.merge(\\n        \\t\\t\\t\\tusers, transactions, how=\\'left\\', on=\\'account\\'\\n    \\t\\t\\t\\t)[[\\'name\\', \\'amount\\']]  \\n  output = pd.DataFrame ({\\'name\\': {},\\n                   \\'balance\\': {}})\\n  for n in range(temp.shape[0]):\\n    key = 0\\n    for i in range(output.shape[0]):\\n      if temp.loc[n,\\'name\\'] == output.loc[i,\\'name\\']:\\n        key = 1\\n        output.loc[i,\\'balance\\'] += temp.loc[n,\\'amount\\']\\n    if key == 0:\\n      output = output._append({\\'name\\':temp.loc[n,\\'name\\'], \\'balance\\': temp.loc[n,\\'amount\\']} , ignore_index=True)\\n  output = output[output.balance>10000]\\n  return output\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef account_summary(users: pd.DataFrame, transactions: pd.DataFrame) -> pd.DataFrame:\\n  temp = pd.merge(\\n        \\t\\t\\t\\tusers, transactions, how=\\'left\\', on=\\'account\\'\\n    \\t\\t\\t\\t)[[\\'name\\', \\'amount\\']]  \\n  output = pd.DataFrame ({\\'name\\': {},\\n                   \\'balance\\': {}})\\n  for n in range(temp.shape[0]):\\n    key = 0\\n    for i in range(output.shape[0]):\\n      if temp.loc[n,\\'name\\'] == output.loc[i,\\'name\\']:\\n        key = 1\\n        output.loc[i,\\'balance\\'] += temp.loc[n,\\'amount\\']\\n    if key == 0:\\n      output = output._append({\\'name\\':temp.loc[n,\\'name\\'], \\'balance\\': temp.loc[n,\\'amount\\']} , ignore_index=True)\\n  output = output[output.balance>10000]\\n  return output\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3724952,
                "title": "mysql-solution-for-bank-account-summary-ii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to join the Users and Transactions tables based on the account number and then calculate the sum of the amounts for each user. We can then filter the result to include only those users whose balance is higher than 10000.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe query uses an inner join between the Users and Transactions tables based on the account column. This allows us to link each user with their corresponding transactions.\\n\\nWe then use the GROUP BY clause on the name column to group the transactions by user. This allows us to calculate the sum of the amounts for each user.\\n\\nFinally, the HAVING clause filters the result set based on the condition balance > 10000, selecting only those users whose balance is higher than 10000.\\n\\nThe query returns the name and balance columns, representing the name of the user and their corresponding balance.\\n\\nThe result is a table with the name and balance of users whose balance is higher than 10000.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution depends on the size of the tables and the efficiency of the join operation. If the tables are indexed properly, the join operation can be performed in linear time complexity, resulting in an overall time complexity of O(n), where n is the total number of rows in the joined tables.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nThe space complexity of the solution is determined by the size of the result set, which depends on the number of qualified users. In the worst case scenario, if all users have a balance higher than 10000, the space complexity will be O(n), where n is the number of users. However, if only a few users satisfy the condition, the space complexity will be much lower.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT u.name, SUM(t.amount) AS balance\\nFROM Users u\\nJOIN Transactions t ON u.account = t.account\\nGROUP BY u.name\\nHAVING balance > 10000;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT u.name, SUM(t.amount) AS balance\\nFROM Users u\\nJOIN Transactions t ON u.account = t.account\\nGROUP BY u.name\\nHAVING balance > 10000;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3465965,
                "title": "super-easy-solution-using-group-by-and-having-sql-server",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe questionstates that we have to find or group the people who have a bank balance greater than 10000 (rich people lol). Now this sum is not given directly but is given in the form of transactions. So we have to use aggreegate function to to do the sum of all the transations for the final bank balance and group the people at the end with sum of there bank balance\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Selecting name from the users table (Used u as the Alias for Users table) and balance as the alias for the sum of the transactions\\n2. Used inner join as we need the common account details (even left join will work here because there exist a accout number for every transaction done)\\n3. GROUPED on the basis of User name\\n4. Now used the HAVING function to check the condition for the bank balance to be more than 10000. We cannot use WHERE clause here as we are conditioning the AGGREEEGATE functions and also we generally use HAVING with GROUP BY\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n SELECT u.name , SUM(t.amount) AS balance\\n FROM Users AS u\\n INNER JOIN Transactions t on u.account = t.account\\n GROUP BY u.name\\n HAVING SUM(t.amount) > 10000\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n SELECT u.name , SUM(t.amount) AS balance\\n FROM Users AS u\\n INNER JOIN Transactions t on u.account = t.account\\n GROUP BY u.name\\n HAVING SUM(t.amount) > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3447476,
                "title": "super-logic-with-having-and-group-by",
                "content": "```\\nselect name,sum(transactions.amount) as balance\\nfrom users left join transactions\\non users.account=transactions.account\\ngroup by transactions.account\\nhaving balance>10000\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect name,sum(transactions.amount) as balance\\nfrom users left join transactions\\non users.account=transactions.account\\ngroup by transactions.account\\nhaving balance>10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3276375,
                "title": "mysql-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect name, sum(amount) as balance from Users natural join Transactions\\ngroup by account having balance > 10000;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect name, sum(amount) as balance from Users natural join Transactions\\ngroup by account having balance > 10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3104702,
                "title": "mysql-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect\\n    a.name,\\n    sum(b.amount) balance\\nfrom\\n    Users a\\njoin\\n    Transactions b\\non\\n    a.account = b.account\\ngroup by\\n    a.account\\nhaving\\n    balance > 10000;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect\\n    a.name,\\n    sum(b.amount) balance\\nfrom\\n    Users a\\njoin\\n    Transactions b\\non\\n    a.account = b.account\\ngroup by\\n    a.account\\nhaving\\n    balance > 10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3100960,
                "title": "using-group-by-and-having-clause-bank-account-summary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect u.name as name , SUM(t.amount) as balance from Users u join Transactions t on u.account=t.account group by t.ACCOUNT having balance>10000;\\n```\\nPlease upvote!!",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect u.name as name , SUM(t.amount) as balance from Users u join Transactions t on u.account=t.account group by t.ACCOUNT having balance>10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2457865,
                "title": "mysql-easy-very-easy-solution",
                "content": "```\\nselect a.name, sum(b.amount) as balance\\nfrom Users a join Transactions b\\non a.account=b.account\\ngroup by a.account\\nhaving balance>10000;",
                "solutionTags": [],
                "code": "```\\nselect a.name, sum(b.amount) as balance\\nfrom Users a join Transactions b\\non a.account=b.account\\ngroup by a.account\\nhaving balance>10000;",
                "codeTag": "Unknown"
            },
            {
                "id": 2456302,
                "title": "mysql-easy-solution-having-group-by",
                "content": "```\\nSELECT name, SUM(amount) AS balance\\nFROM Users JOIN Transactions ON Users.account = Transactions.account\\nGROUP BY name\\nHAVING balance > 10000;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT name, SUM(amount) AS balance\\nFROM Users JOIN Transactions ON Users.account = Transactions.account\\nGROUP BY name\\nHAVING balance > 10000;",
                "codeTag": "Unknown"
            },
            {
                "id": 2315277,
                "title": "mssql",
                "content": "```\\nSELECT name, SUM(amount)balance\\nFROM Users U \\nJOIN Transactions T ON T.account = U.account\\nGROUP BY name\\nHAVING SUM(AMOUNT) > 10000\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT name, SUM(amount)balance\\nFROM Users U \\nJOIN Transactions T ON T.account = U.account\\nGROUP BY name\\nHAVING SUM(AMOUNT) > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2155155,
                "title": "easy-solution",
                "content": "select u.name , sum(t.amount) as Balance\\nfrom users as u join transactions t \\non u.account = t.account\\ngroup by  t.account\\nhaving sum(t.amount)>10000;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select u.name , sum(t.amount) as Balance\\nfrom users as u join transactions t \\non u.account = t.account\\ngroup by  t.account\\nhaving sum(t.amount)>10000;",
                "codeTag": "Unknown"
            },
            {
                "id": 2038049,
                "title": "easy-mysql-solution-do-upvote",
                "content": "```\\n# Write your MySQL query statement below\\nselect users.name, sum(transactions.amount) as balance from transactions \\nleft join users on users.account=transactions.account\\ngroup by transactions.account\\nhaving sum(transactions.amount)>10000\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect users.name, sum(transactions.amount) as balance from transactions \\nleft join users on users.account=transactions.account\\ngroup by transactions.account\\nhaving sum(transactions.amount)>10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1930536,
                "title": "short-quick-solution",
                "content": "if you like it please upvote\\n\\n```\\n# Write your MySQL query statement below\\nselect u.name ,sum(t.amount) as balance\\nfrom Users as u \\njoin Transactions as t\\non u.account = t.account\\ngroup by u.account\\nhaving balance > 10000;\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect u.name ,sum(t.amount) as balance\\nfrom Users as u \\njoin Transactions as t\\non u.account = t.account\\ngroup by u.account\\nhaving balance > 10000;\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1072189,
                "title": "clean-formatted-sql-having",
                "content": "# Use HAVING not WHERE \\n- \"Having\" clause introduces a condition on aggregations\\n-  Where clause introduces a condition on individual rows; \\n\\n```\\nSELECT\\n    u.name,\\n    SUM(t.amount) AS balance\\nFROM \\n    Users u\\nINNER JOIN\\n    Transactions t ON u.account = t.account\\nGROUP BY\\n    u.name\\nHAVING\\n    SUM(t.amount) > 10000\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n    u.name,\\n    SUM(t.amount) AS balance\\nFROM \\n    Users u\\nINNER JOIN\\n    Transactions t ON u.account = t.account\\nGROUP BY\\n    u.name\\nHAVING\\n    SUM(t.amount) > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 851461,
                "title": "simple-mysql-solution",
                "content": "select u.name,\\n       tb1.amount_sum AS balance\\nfrom Users u join\\n(select account,\\n       SUM(amount) AS amount_sum\\nfrom Transactions \\ngroup by account) tb1\\non u.account = tb1.account\\nwhere tb1.amount_sum > 10000",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select u.name,\\n       tb1.amount_sum AS balance\\nfrom Users u join\\n(select account,\\n       SUM(amount) AS amount_sum\\nfrom Transactions \\ngroup by account) tb1\\non u.account = tb1.account\\nwhere tb1.amount_sum > 10000",
                "codeTag": "Unknown"
            },
            {
                "id": 851435,
                "title": "my-simplest-solution",
                "content": "select u.name, sum(t.amount) as balance\\nFROM users as u\\njoin transactions as t\\non u.account = t.account\\ngroup by u.name\\nhaving balance > 10000;",
                "solutionTags": [],
                "code": "select u.name, sum(t.amount) as balance\\nFROM users as u\\njoin transactions as t\\non u.account = t.account\\ngroup by u.name\\nhaving balance > 10000;",
                "codeTag": "Unknown"
            },
            {
                "id": 4072569,
                "title": "pandas-sql-easy-bank-account-summary-ii",
                "content": "[see the Successfully Accepted Submission](https://leetcode.com/submissions/detail/1054391514/)\\n```\\nimport pandas as pd\\n\\ndef account_summary(users: pd.DataFrame, transactions: pd.DataFrame) -> pd.DataFrame:\\n    \\n    # Let\\'s combines the two DataFrames based on the \"account\" column. It creates a new DataFrame that includes all columns from both users and transactions where the \"account\" values match between the two DataFrames. \\n    merge_users = pd.merge(users, transactions, left_on=\\'account\\', right_on=\\'account\\')\\n    \\n    # Next,  we group the rows in the `merge_users` DataFrame based on the values in the \"name\" column.\\n    grouped_users = merge_users.groupby(\\'name\\')\\n    \\n    # Then, we calculate the sum of the \"amount\" column within each group. And also, we assign the result to a new column named \"balance\" in the resulting DataFrame. \\n    \\n    calculated_users = grouped_users.agg(balance=(\\'amount\\', \\'sum\\'))\\n    # Let\\'s move the current index back to regular row labels and adds a new default integer index to the DataFrame.\\n    structured_users = calculated_users.reset_index()\\n    \\n    # Finally, we filter rows( in `structured_users`) where the \"balance\" column has values greater than 10,000.\\n    filtered_users = structured_users.query(\\'balance > 10000\\')\\n    \\n    return filtered_users\\n```\\n\\n**SQL**\\n\\n[see the Successfully Accepted Submission](https://leetcode.com/submissions/detail/1061724398/)\\n\\n```\\nSELECT _user.name \\nAS NAME , SUM(_transactions.amount) \\nAS BALANCE\\n\\nfrom Transactions _transactions\\n\\nLEFT JOIN Users _user ON _user.account = _transactions.account\\n\\nGROUP BY _user.name\\nHAVING SUM(_transactions.amount)>10000;\\n```\\n\\n\\n```\\n-- Select the \\'name\\' column from the \\'_user\\' table and alias it as \\'NAME\\'\\nSELECT _user.name AS NAME,\\n\\n       -- Calculate the sum of \\'amount\\' from the \\'_transactions\\' table and alias it as \\'BALANCE\\'\\n       SUM(_transactions.amount) AS BALANCE\\n\\n-- Retrieve data from the \\'Transactions\\' table and alias it as \\'_transactions\\'\\nFROM Transactions _transactions\\n\\n-- Perform a LEFT JOIN between \\'_transactions\\' and \\'_user\\' tables using the \\'account\\' relationship\\n-- This join links transactions to users based on their account\\nLEFT JOIN Users _user ON _user.account = _transactions.account\\n\\n-- Group the results by the \\'name\\' column to aggregate transaction amounts for each user\\nGROUP BY _user.name\\n\\n-- Filter the grouped results to include only those with a sum of \\'amount\\' greater than 10,000\\nHAVING SUM(_transactions.amount) > 10000;\\n```\\n\\n![image](https://assets.leetcode.com/users/images/121ec905-cc1f-4a5a-b1bb-dadda1375c97_1695302329.08588.jpeg)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef account_summary(users: pd.DataFrame, transactions: pd.DataFrame) -> pd.DataFrame:\\n    \\n    # Let\\'s combines the two DataFrames based on the \"account\" column. It creates a new DataFrame that includes all columns from both users and transactions where the \"account\" values match between the two DataFrames. \\n    merge_users = pd.merge(users, transactions, left_on=\\'account\\', right_on=\\'account\\')\\n    \\n    # Next,  we group the rows in the `merge_users` DataFrame based on the values in the \"name\" column.\\n    grouped_users = merge_users.groupby(\\'name\\')\\n    \\n    # Then, we calculate the sum of the \"amount\" column within each group. And also, we assign the result to a new column named \"balance\" in the resulting DataFrame. \\n    \\n    calculated_users = grouped_users.agg(balance=(\\'amount\\', \\'sum\\'))\\n    # Let\\'s move the current index back to regular row labels and adds a new default integer index to the DataFrame.\\n    structured_users = calculated_users.reset_index()\\n    \\n    # Finally, we filter rows( in `structured_users`) where the \"balance\" column has values greater than 10,000.\\n    filtered_users = structured_users.query(\\'balance > 10000\\')\\n    \\n    return filtered_users\\n```\n```\\nSELECT _user.name \\nAS NAME , SUM(_transactions.amount) \\nAS BALANCE\\n\\nfrom Transactions _transactions\\n\\nLEFT JOIN Users _user ON _user.account = _transactions.account\\n\\nGROUP BY _user.name\\nHAVING SUM(_transactions.amount)>10000;\\n```\n```\\n-- Select the \\'name\\' column from the \\'_user\\' table and alias it as \\'NAME\\'\\nSELECT _user.name AS NAME,\\n\\n       -- Calculate the sum of \\'amount\\' from the \\'_transactions\\' table and alias it as \\'BALANCE\\'\\n       SUM(_transactions.amount) AS BALANCE\\n\\n-- Retrieve data from the \\'Transactions\\' table and alias it as \\'_transactions\\'\\nFROM Transactions _transactions\\n\\n-- Perform a LEFT JOIN between \\'_transactions\\' and \\'_user\\' tables using the \\'account\\' relationship\\n-- This join links transactions to users based on their account\\nLEFT JOIN Users _user ON _user.account = _transactions.account\\n\\n-- Group the results by the \\'name\\' column to aggregate transaction amounts for each user\\nGROUP BY _user.name\\n\\n-- Filter the grouped results to include only those with a sum of \\'amount\\' greater than 10,000\\nHAVING SUM(_transactions.amount) > 10000;\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3451458,
                "title": "oracle-easy-solution-beats-99-beginner-level",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1)Either group by name or transactions(account) number so that we can separate different records\\n2)Now compare two account numbers (user and transactions)\\nat the end sum of transaction amounts give balance of each person as having and group by clause is applied\\n3)Signs are already given in table which made our worl more easy\\n     If not case and if..else is used and also there will be a row containing information like \"credit\" and \"debit\"\\n\\nPLEASE UPVOTE IF YOU FIND THIS SOLUTION EASY.............\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nselect name,sum(t.amount) as balance\\nfrom Users u,Transactions t\\nwhere u.account=t.account\\nhaving sum(t.amount)>10000\\ngroup by u.name;\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect name,sum(t.amount) as balance\\nfrom Users u,Transactions t\\nwhere u.account=t.account\\nhaving sum(t.amount)>10000\\ngroup by u.name;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3343839,
                "title": "sql-code",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect u1.name,sum(t1.amount) as balance\\nfrom Users u1\\njoin \\nTransactions t1\\non u1.account=t1.account \\ngroup by name \\nhaving balance>10000\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect u1.name,sum(t1.amount) as balance\\nfrom Users u1\\njoin \\nTransactions t1\\non u1.account=t1.account \\ngroup by name \\nhaving balance>10000\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3306941,
                "title": "sql-server-clean-easy",
                "content": "```\\nSELECT name, balance\\nFROM (\\n  SELECT account, SUM(amount) as balance\\n  FROM Transactions\\n  GROUP BY account\\n) AS account_balances\\nJOIN Users ON account_balances.account = Users.account\\nWHERE balance > 10000;\\n\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT name, balance\\nFROM (\\n  SELECT account, SUM(amount) as balance\\n  FROM Transactions\\n  GROUP BY account\\n) AS account_balances\\nJOIN Users ON account_balances.account = Users.account\\nWHERE balance > 10000;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3260930,
                "title": "solution-with-window-function-sql-server",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\n\\r\\nWITH CTE AS (\\r\\n        SELECT DISTINCT\\r\\n            account,\\r\\n            SUM(amount) OVER(PARTITION BY account) balance\\r\\n        FROM\\r\\n            Transactions \\r\\n)\\r\\nSELECT\\r\\n    T.name,\\r\\n    C.balance\\r\\nFROM\\r\\n    CTE C\\r\\nINNER JOIN\\r\\n    Users T ON C.account = T.account\\r\\nWHERE\\r\\n    balance > 10000\\r\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\n\\r\\nWITH CTE AS (\\r\\n        SELECT DISTINCT\\r\\n            account,\\r\\n            SUM(amount) OVER(PARTITION BY account) balance\\r\\n        FROM\\r\\n            Transactions \\r\\n)\\r\\nSELECT\\r\\n    T.name,\\r\\n    C.balance\\r\\nFROM\\r\\n    CTE C\\r\\nINNER JOIN\\r\\n    Users T ON C.account = T.account\\r\\nWHERE\\r\\n    balance > 10000\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3089260,
                "title": "mysql-statement-using-group-by-clause",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT name , SUM(amount) as balance\\nFROM Users\\nJOIN Transactions on Users.account = Transactions.account\\nGroup By Users.account\\nhaving balance > 10000\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT name , SUM(amount) as balance\\nFROM Users\\nJOIN Transactions on Users.account = Transactions.account\\nGroup By Users.account\\nhaving balance > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3085873,
                "title": "simple-sql-solution",
                "content": "# Code\\n```\\nSELECT name, SUM(t.amount) AS balance FROM Users u \\n    JOIN Transactions t ON u.account = t.account \\n        GROUP BY name  HAVING SUM(t.amount) > 10000\\n```",
                "solutionTags": [
                    "Oracle",
                    "Database"
                ],
                "code": "```\\nSELECT name, SUM(t.amount) AS balance FROM Users u \\n    JOIN Transactions t ON u.account = t.account \\n        GROUP BY name  HAVING SUM(t.amount) > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2854777,
                "title": "easy-solution-subquery",
                "content": "```\\nSELECT * FROM (\\n    SELECT name, sum(amount) \"balance\" from Users u, Transactions t\\n    WHERE u.account = t.account\\n    GROUP by name) t\\nWHERE t.balance > 10000;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT * FROM (\\n    SELECT name, sum(amount) \"balance\" from Users u, Transactions t\\n    WHERE u.account = t.account\\n    GROUP by name) t\\nWHERE t.balance > 10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2703287,
                "title": "mysql-solution",
                "content": "```\\nselect u.name , sum(t.amount) balance\\nfrom users u\\njoin transactions t on u.account= t.account\\ngroup by u.account\\nhaving balance> 10000\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect u.name , sum(t.amount) balance\\nfrom users u\\njoin transactions t on u.account= t.account\\ngroup by u.account\\nhaving balance> 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2616534,
                "title": "using-left-join-having",
                "content": "SELECT u.name, SUM(t.amount) as balance FROM Users u \\nLEFT JOIN Transactions t\\nON u.account=t.account\\nGroup by u.name HAVING balance>10000;",
                "solutionTags": [],
                "code": "SELECT u.name, SUM(t.amount) as balance FROM Users u \\nLEFT JOIN Transactions t\\nON u.account=t.account\\nGroup by u.name HAVING balance>10000;",
                "codeTag": "Unknown"
            },
            {
                "id": 2588331,
                "title": "easy-solution-with-mysql-group-by",
                "content": "\"\"\"\\n\\nSELECT users.name, SUM(transactions.amount) AS balance FROM transactions\\nINNER JOIN users ON users.account=transactions.account\\nGROUP BY transactions.account HAVING balance > 10000\\n\"\"\"",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\"\"\"\\n\\nSELECT users.name, SUM(transactions.amount) AS balance FROM transactions\\nINNER JOIN users ON users.account=transactions.account\\nGROUP BY transactions.account HAVING balance > 10000\\n\"\"\"",
                "codeTag": "Unknown"
            },
            {
                "id": 2538298,
                "title": "mysql-simple-and-clean-solution",
                "content": "**Please Upvote if it helped you !!!**\\n```\\nselect users.name,sum(transactions.amount) as balance \\nfrom users \\nleft join transactions \\non users.account=transactions.account \\ngroup by users.account having balance >10000;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect users.name,sum(transactions.amount) as balance \\nfrom users \\nleft join transactions \\non users.account=transactions.account \\ngroup by users.account having balance >10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2504554,
                "title": "oh-mein-g-t-beats-100",
                "content": "```\\n# Write your MySQL query statement below\\nwith valid_transaction as (\\n  select \\n    *,\\n    sum(amount) as balance\\n  from Transactions group by account having sum(amount) > 10000\\n)\\nselect U.name, V.balance from Users U inner join valid_transaction V on U.account = V.account\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nwith valid_transaction as (\\n  select \\n    *,\\n    sum(amount) as balance\\n  from Transactions group by account having sum(amount) > 10000\\n)\\nselect U.name, V.balance from Users U inner join valid_transaction V on U.account = V.account\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2464982,
                "title": "simple-mysql-solution-using-join-groupby",
                "content": "```\\nselect name,sum(amount) as balance from users u \\ninner join transactions t \\non u.account=t.account\\ngroup by u.account\\nhaving balance > 10000;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect name,sum(amount) as balance from users u \\ninner join transactions t \\non u.account=t.account\\ngroup by u.account\\nhaving balance > 10000;",
                "codeTag": "Unknown"
            },
            {
                "id": 2406996,
                "title": "mysql-beats-98-30-easy-to-understand-with-explaination",
                "content": "The requirement is to report the name and balance of users with a balance higher than 10000.\\n\\nAccording to above requirement, we can divide the idea into 3 parts:\\n1. Report the name and balance:\\n    First of all, we write code here to show what we need.\\n\\tWe want the column names of output are NAME and BALANCE.\\n\\tTo calculate balance, we can use `SUM`.\\n\\t\\n   ```\\n   SELECT u.name AS NAME, SUM(t.amount) AS BALANCE\\n   FROM `transactions` AS t,`users` AS u\\n   ...\\n   GROUP BY u.name\\n   ```\\n\\n2. Then we can use ```JOIN``` to combine Table```transactions``` and Table ```users``` on the condition that their account are the same.\\n\\n   By code of step1, we add some change to combine two table:\\n   ```\\n   SELECT u.name AS NAME, SUM(t.amount) AS BALANCE\\n   FROM `transactions` AS t JOIN `users` AS u\\n   ON u.account=t.account\\n   GROUP BY u.name\\n   ```\\n3. Balance of users with a balance higher than 10000.\\n    To set a limited to balance, we use ```HAVING```:\\n\\t```\\n\\tHAVING BALANCE > 10000\\n\\t```\\n\\t\\n\\nCompleted code:\\nRuntime: **520 ms**\\n```\\nSELECT u.name AS NAME,SUM(t.amount) AS BALANCE\\nFROM `transactions` AS t JOIN `users` AS u\\nON u.account=t.account\\nGROUP BY u.name\\nHAVING BALANCE>10000\\n```\\n\\n\\nUpvote if you think this idea is helpful. Thanks:)",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n   SELECT u.name AS NAME, SUM(t.amount) AS BALANCE\\n   FROM `transactions` AS t,`users` AS u\\n   ...\\n   GROUP BY u.name\\n   ```\n```JOIN```\n```transactions```\n```users```\n```\\n   SELECT u.name AS NAME, SUM(t.amount) AS BALANCE\\n   FROM `transactions` AS t JOIN `users` AS u\\n   ON u.account=t.account\\n   GROUP BY u.name\\n   ```\n```HAVING```\n```\\n\\tHAVING BALANCE > 10000\\n\\t```\n```\\nSELECT u.name AS NAME,SUM(t.amount) AS BALANCE\\nFROM `transactions` AS t JOIN `users` AS u\\nON u.account=t.account\\nGROUP BY u.name\\nHAVING BALANCE>10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2398599,
                "title": "sql-having-group-by",
                "content": "select name , sum(amount) as balance from users u join transactions t\\non u.account=t.account\\ngroup by t.account\\nhaving balance >10000;",
                "solutionTags": [],
                "code": "select name , sum(amount) as balance from users u join transactions t\\non u.account=t.account\\ngroup by t.account\\nhaving balance >10000;",
                "codeTag": "Unknown"
            },
            {
                "id": 2374230,
                "title": "mysql-solution-using-with-clause",
                "content": "Creating a temporary table t1 that stores **account** and **sum of all transactions** (as balance) grouped by account. Join this t1 table with Users table using **account**. And final step filter out records where balance is < 10000. Pretty easy.\\n\\n```\\nWITH t1 as\\n    (SELECT account, SUM(amount) as balance\\n    FROM Transactions\\n    GROUP BY account)\\n\\nSELECT u.name, t1.balance\\nFROM Users u\\nJOIN t1 USING (account)\\nWHERE t1.balance > 10000\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nWITH t1 as\\n    (SELECT account, SUM(amount) as balance\\n    FROM Transactions\\n    GROUP BY account)\\n\\nSELECT u.name, t1.balance\\nFROM Users u\\nJOIN t1 USING (account)\\nWHERE t1.balance > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2356010,
                "title": "simple-mysql-joins-easy-to-understand",
                "content": "```\\nSELECT U.NAME, SUM(T.AMOUNT) AS BALANCE FROM USERS U\\nJOIN TRANSACTIONS T \\n\\tON T.ACCOUNT = U.ACCOUNT\\nGROUP BY T.ACCOUNT\\n\\tHAVING SUM(T.AMOUNT) > 10000\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT U.NAME, SUM(T.AMOUNT) AS BALANCE FROM USERS U\\nJOIN TRANSACTIONS T \\n\\tON T.ACCOUNT = U.ACCOUNT\\nGROUP BY T.ACCOUNT\\n\\tHAVING SUM(T.AMOUNT) > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2308080,
                "title": "mysql-solution-bank-account-summary-ii",
                "content": "Ouput : \\n1. The name and balance of users with a balance higher than 10000\\n2. Tha balance of an account = sum(transcations involving that account)\\n3. to find the balance we will use table \"Transcations \" where we will group by column account\\nto get all the trnacations which is done by that account \\n                 \\n                 from Transactions\\n                 group by account\\n4. Then in order to calculate the balance we will use sum( ) \\n      \\n\\t     select account , sum(amount) as balance\\n         from Transactions\\n         group by account\\n\\t\\t having balance > 10000;\\n       \\n      \\n       \\n5. Now we need the name of owner of the account , for that we will Users table\\n6. Now let consider the view table which we are getting from step 4 as temp . Now in order to retrive the name we need to join the temp and Users table, where we will consider the temp as primary table \\n       \\n\\t\\t select u.name as name , temp.balance as balance\\n       from Users u right join \\n       ( select account , sum(amount) as balance\\n       from Transactions\\n       group by account\\n       having balance > 10000) temp \\n       on u.account = temp.account;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "Ouput : \\n1. The name and balance of users with a balance higher than 10000\\n2. Tha balance of an account = sum(transcations involving that account)\\n3. to find the balance we will use table \"Transcations \" where we will group by column account\\nto get all the trnacations which is done by that account \\n                 \\n                 from Transactions\\n                 group by account\\n4. Then in order to calculate the balance we will use sum( ) \\n      \\n\\t     select account , sum(amount) as balance\\n         from Transactions\\n         group by account\\n\\t\\t having balance > 10000;\\n       \\n      \\n       \\n5. Now we need the name of owner of the account , for that we will Users table\\n6. Now let consider the view table which we are getting from step 4 as temp . Now in order to retrive the name we need to join the temp and Users table, where we will consider the temp as primary table \\n       \\n\\t\\t select u.name as name , temp.balance as balance\\n       from Users u right join \\n       ( select account , sum(amount) as balance\\n       from Transactions\\n       group by account\\n       having balance > 10000) temp \\n       on u.account = temp.account;",
                "codeTag": "Unknown"
            },
            {
                "id": 2179319,
                "title": "solution-using-join-and-with-clause-for-better-performace",
                "content": "```\\nwith bank as\\n    (select u.name as name, t.amount as balance, u.account as account\\n    from Users u\\n    join Transactions t\\n    on u.account=t.account)\\nselect name, sum(balance) as balance \\nfrom bank\\ngroup by account\\nhaving sum(balance)>10000;\\n```",
                "solutionTags": [],
                "code": "```\\nwith bank as\\n    (select u.name as name, t.amount as balance, u.account as account\\n    from Users u\\n    join Transactions t\\n    on u.account=t.account)\\nselect name, sum(balance) as balance \\nfrom bank\\ngroup by account\\nhaving sum(balance)>10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2141969,
                "title": "mysql-solution-easy-approach",
                "content": "**Approach:**\\n```\\nSELECT Users.name, SUM(amount) AS balance FROM Transactions\\nINNER JOIN Users ON Transactions.account =  Users.account\\nGROUP BY Transactions.account\\nHAVING balance > 10000 ;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT Users.name, SUM(amount) AS balance FROM Transactions\\nINNER JOIN Users ON Transactions.account =  Users.account\\nGROUP BY Transactions.account\\nHAVING balance > 10000 ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2113444,
                "title": "sql-too-easy-query-without-using-join",
                "content": "```\\nselect a.name,\\nsum(b.amount) as balance \\nfrom Users a,Transactions b\\nwhere a.account=b.account\\ngroup by a.name\\nhaving sum(b.amount)>10000;```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect a.name,\\nsum(b.amount) as balance \\nfrom Users a,Transactions b\\nwhere a.account=b.account\\ngroup by a.name\\nhaving sum(b.amount)>10000;```",
                "codeTag": "Unknown"
            },
            {
                "id": 2110158,
                "title": "easy-sql-query",
                "content": "```\\nselect\\n    a.name,\\n    sum(b.amount) balance\\nfrom\\n    Users a\\njoin\\n    Transactions b\\non\\n    a.account = b.account\\ngroup by\\n    a.account\\nhaving\\n    balance > 10000;```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect\\n    a.name,\\n    sum(b.amount) balance\\nfrom\\n    Users a\\njoin\\n    Transactions b\\non\\n    a.account = b.account\\ngroup by\\n    a.account\\nhaving\\n    balance > 10000;```",
                "codeTag": "Unknown"
            },
            {
                "id": 2105453,
                "title": "mysql-easiest-solution",
                "content": "**Pls Upvote if you like the Solution!**\\n```\\nSELECT name, SUM(amount) balance\\nFROM users\\nLEFT JOIN transactions\\nUSING(account)\\nGROUP BY account\\nHAVING balance > 10000",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "**Pls Upvote if you like the Solution!**\\n```\\nSELECT name, SUM(amount) balance\\nFROM users\\nLEFT JOIN transactions\\nUSING(account)\\nGROUP BY account\\nHAVING balance > 10000",
                "codeTag": "Unknown"
            },
            {
                "id": 2093922,
                "title": "approach-using-inner-join-in-mysql",
                "content": "```\\nSELECT a.name, b.sumAmount as balance\\nFROM (\\nSelect account, sum(amount) as sumAmount\\nfrom transactions\\ngroup by account\\nhaving sumAmount > 10000) as b\\nINNER JOIN \\n(Select account,name from users) as a\\non b.account = a.account;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT a.name, b.sumAmount as balance\\nFROM (\\nSelect account, sum(amount) as sumAmount\\nfrom transactions\\ngroup by account\\nhaving sumAmount > 10000) as b\\nINNER JOIN \\n(Select account,name from users) as a\\non b.account = a.account;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2092538,
                "title": "simple-solution-with-having-fastest-than-98",
                "content": "```\\nselect\\n    u.name,\\n    sum(t.amount) as balance\\nfrom users u\\nleft join transactions t on t.account = u.account\\ngroup by 1\\nhaving sum(t.amount) > 10000\\n```",
                "solutionTags": [],
                "code": "```\\nselect\\n    u.name,\\n    sum(t.amount) as balance\\nfrom users u\\nleft join transactions t on t.account = u.account\\ngroup by 1\\nhaving sum(t.amount) > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2019047,
                "title": "mysql-easy",
                "content": "```\\nselect name,sum(amount) as balance from Users \\njoin Transactions \\non Users.account = Transactions.account \\ngroup by Transactions.account having balance>=10000\\n```",
                "solutionTags": [],
                "code": "```\\nselect name,sum(amount) as balance from Users \\njoin Transactions \\non Users.account = Transactions.account \\ngroup by Transactions.account having balance>=10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1998545,
                "title": "easy-solution-with-inner-join-window-functions-and-distinct",
                "content": "```\\nWITH TOTAL_AMOUNTS AS (\\n    SELECT DISTINCT ACCOUNT,\\n           SUM(AMOUNT) OVER(PARTITION BY ACCOUNT) AS BALANCE\\n      FROM TRANSACTIONS\\n)\\n    SELECT U.NAME,\\n           TA.BALANCE\\n      FROM USERS U\\n      JOIN TOTAL_AMOUNTS AS TA ON TA.BALANCE > 10000 AND TA.ACCOUNT = U.ACCOUNT\\n  ```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nWITH TOTAL_AMOUNTS AS (\\n    SELECT DISTINCT ACCOUNT,\\n           SUM(AMOUNT) OVER(PARTITION BY ACCOUNT) AS BALANCE\\n      FROM TRANSACTIONS\\n)\\n    SELECT U.NAME,\\n           TA.BALANCE\\n      FROM USERS U\\n      JOIN TOTAL_AMOUNTS AS TA ON TA.BALANCE > 10000 AND TA.ACCOUNT = U.ACCOUNT\\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1971724,
                "title": "mysql-solution",
                "content": "# Solution\\n```\\nSELECT name, SUM(amount) as balance\\nFROM Users\\nINNER JOIN Transactions on Transactions.account = Users.account\\nGROUP BY name\\nHAVING SUM(amount) > 10000\\n```\\nThe **HAVING** clause was added to SQL because the **WHERE** keyword cannot be used with aggregate functions.\\nIf you find this **solution** and **explanation** helpful, please **upvote** it for others people.\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT name, SUM(amount) as balance\\nFROM Users\\nINNER JOIN Transactions on Transactions.account = Users.account\\nGROUP BY name\\nHAVING SUM(amount) > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1969164,
                "title": "mysql-easy-implementation",
                "content": "```\\nSELECT name, SUM(t.amount) as balance\\nFROM Transactions t LEFT JOIN Users u\\nON t.account = u.account\\nGROUP BY t.account\\nHAVING balance> 10000\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT name, SUM(t.amount) as balance\\nFROM Transactions t LEFT JOIN Users u\\nON t.account = u.account\\nGROUP BY t.account\\nHAVING balance> 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1758735,
                "title": "mysql-solution",
                "content": "```\\nselect \\n    u.name, sum(t.amount) balance\\nfrom users u\\njoin transactions t\\non u.account = t.account\\ngroup by u.name\\nhaving sum(t.amount) > 10000\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect \\n    u.name, sum(t.amount) balance\\nfrom users u\\njoin transactions t\\non u.account = t.account\\ngroup by u.name\\nhaving sum(t.amount) > 10000\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1351458,
                "title": "mysql-solution-easy-to-understand",
                "content": "```\\nselect name, balance from users join \\n(select account, sum(amount) as balance from transactions group by account) as account_balance\\non users.account = account_balance.account\\nwhere balance >10000\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect name, balance from users join \\n(select account, sum(amount) as balance from transactions group by account) as account_balance\\non users.account = account_balance.account\\nwhere balance >10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1347550,
                "title": "concise-mysql",
                "content": "```\\n\\n# Write your MySQL query statement below\\n\\nselect\\nname, \\nsum(amount) as balance\\nfrom\\nusers as u\\nleft join\\ntransactions as t\\non u.account = t.account\\ngroup by 1\\nhaving sum(amount) > 10000\\n;\\n```",
                "solutionTags": [],
                "code": "```\\n\\n# Write your MySQL query statement below\\n\\nselect\\nname, \\nsum(amount) as balance\\nfrom\\nusers as u\\nleft join\\ntransactions as t\\non u.account = t.account\\ngroup by 1\\nhaving sum(amount) > 10000\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1259707,
                "title": "ms-sql-server-easy-solution-using-inner-join-having-clause",
                "content": "select a.name , sum(b.amount) as balance\\nfrom Users a , Transactions b\\nwhere a.account = b.account \\ngroup by a.name\\nhaving sum(b.amount) > 10000",
                "solutionTags": [],
                "code": "select a.name , sum(b.amount) as balance\\nfrom Users a , Transactions b\\nwhere a.account = b.account \\ngroup by a.name\\nhaving sum(b.amount) > 10000",
                "codeTag": "Unknown"
            },
            {
                "id": 1050929,
                "title": "easy-mysql-solution-faster-than-91",
                "content": "```\\nSELECT name, SUM(amount) as balance\\nFROM Users \\nINNER JOIN Transactions\\nON Users.account = Transactions.account\\nGROUP BY Transactions.account\\nHAVING SUM(amount) > 10000\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT name, SUM(amount) as balance\\nFROM Users \\nINNER JOIN Transactions\\nON Users.account = Transactions.account\\nGROUP BY Transactions.account\\nHAVING SUM(amount) > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1018507,
                "title": "simple-mysql-solution-using-cte",
                "content": "with funds as (\\n    select \\n\\tu.account, \\n\\tu.name, \\n\\tsum(t.amount) as balance\\n    from users u\\n    join transactions t \\n    on u.account = t.account\\n    group by t.account\\n)\\n\\nselect \\nname, \\nbalance\\nfrom funds \\nwhere balance > 10000\\n;\\n",
                "solutionTags": [],
                "code": "with funds as (\\n    select \\n\\tu.account, \\n\\tu.name, \\n\\tsum(t.amount) as balance\\n    from users u\\n    join transactions t \\n    on u.account = t.account\\n    group by t.account\\n)\\n\\nselect \\nname, \\nbalance\\nfrom funds \\nwhere balance > 10000\\n;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 999926,
                "title": "easy-sql-solution",
                "content": "```\\n\\nSELECT NAME, SUM(AMOUNT) AS BALANCE\\nFROM TRANSACTIONS LEFT JOIN USERS ON TRANSACTIONS.ACCOUNT = USERS.ACCOUNT\\nGROUP BY TRANSACTIONS.ACCOUNT\\nHAVING BALANCE > 10000\\n```",
                "solutionTags": [],
                "code": "```\\n\\nSELECT NAME, SUM(AMOUNT) AS BALANCE\\nFROM TRANSACTIONS LEFT JOIN USERS ON TRANSACTIONS.ACCOUNT = USERS.ACCOUNT\\nGROUP BY TRANSACTIONS.ACCOUNT\\nHAVING BALANCE > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 989478,
                "title": "left-join-approach",
                "content": "```\\nSELECT \\n  us.name, \\n  balance\\nFROM users us\\nLEFT JOIN (\\n  SELECT account, sum(amount) AS balance\\n  FROM transactions \\n  GROUP BY account\\n) AS spent ON us.account = spent.account\\nWHERE balance > 10000\\n```\\n",
                "solutionTags": [],
                "code": "```\\nSELECT \\n  us.name, \\n  balance\\nFROM users us\\nLEFT JOIN (\\n  SELECT account, sum(amount) AS balance\\n  FROM transactions \\n  GROUP BY account\\n) AS spent ON us.account = spent.account\\nWHERE balance > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 913027,
                "title": "mysql-solution",
                "content": "SELECT u.name AS NAME, SUM(t.amount) AS BALANCE\\nFROM Users u JOIN Transactions t \\nON t.account = u.account\\nGROUP BY name HAVING balance > 10000;",
                "solutionTags": [],
                "code": "SELECT u.name AS NAME, SUM(t.amount) AS BALANCE\\nFROM Users u JOIN Transactions t \\nON t.account = u.account\\nGROUP BY name HAVING balance > 10000;",
                "codeTag": "Unknown"
            },
            {
                "id": 867794,
                "title": "1587-bank-account-summary-ii-easy-solution",
                "content": "```\\nselect accountData.name as name, balance from\\n(select U.name as name, sum(T.amount) as balance from Transactions as T\\njoin Users as U\\non U.account = T.account\\ngroup by U.account) as accountData\\nwhere accountData.balance > 10000\\n```",
                "solutionTags": [],
                "code": "```\\nselect accountData.name as name, balance from\\n(select U.name as name, sum(T.amount) as balance from Transactions as T\\njoin Users as U\\non U.account = T.account\\ngroup by U.account) as accountData\\nwhere accountData.balance > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 863592,
                "title": "mysql-query",
                "content": "```\\nselect u.name as NAME, sum(t.amount) as BALANCE from Users u \\ninner join Transactions t on u.account = t.account\\ngroup by t.account\\nhaving BALANCE > 10000\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect u.name as NAME, sum(t.amount) as BALANCE from Users u \\ninner join Transactions t on u.account = t.account\\ngroup by t.account\\nhaving BALANCE > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 860845,
                "title": "ms-sql-server",
                "content": "```\\n/* Write your T-SQL query statement below */\\nwith temp as \\n(select distinct name, sum(amount) over (partition by t.account) as balance\\nfrom Transactions t join Users u\\non t.account = u.account)\\n\\nselect * from temp where balance > 10000\\n\\n-----------------------------------------OR---------------------------\\n\\nselect u.name, sum(t.amount) balance\\nfrom users u join transactions t on t.account = u.account\\ngroup by u.name\\nhaving sum(t.amount) > 10000\\n```",
                "solutionTags": [],
                "code": "```\\n/* Write your T-SQL query statement below */\\nwith temp as \\n(select distinct name, sum(amount) over (partition by t.account) as balance\\nfrom Transactions t join Users u\\non t.account = u.account)\\n\\nselect * from temp where balance > 10000\\n\\n-----------------------------------------OR---------------------------\\n\\nselect u.name, sum(t.amount) balance\\nfrom users u join transactions t on t.account = u.account\\ngroup by u.name\\nhaving sum(t.amount) > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 852996,
                "title": "simple-mysql-solution-with-window-function",
                "content": "![image](https://assets.leetcode.com/users/images/3ee52a48-8818-47a2-88bb-1e5a37ce1d8a_1600462434.0843422.png)\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/3ee52a48-8818-47a2-88bb-1e5a37ce1d8a_1600462434.0843422.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 851446,
                "title": "easy-mysql",
                "content": "```\\nSELECT u.name, SUM(t.amount) AS balance\\nFROM Users u\\nJOIN Transactions t\\nON u.account = t.account\\nGROUP BY u.account\\nHAVING SUM(t.amount) > 10000\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT u.name, SUM(t.amount) AS balance\\nFROM Users u\\nJOIN Transactions t\\nON u.account = t.account\\nGROUP BY u.account\\nHAVING SUM(t.amount) > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4099468,
                "title": "most-easy-solution-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT NAME,SUM(AMOUNT) AS BALANCE FROM USERS NATURAL JOIN TRANSACTIONS  GROUP BY ACCOUNT  HAVING BALANCE>10000;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT NAME,SUM(AMOUNT) AS BALANCE FROM USERS NATURAL JOIN TRANSACTIONS  GROUP BY ACCOUNT  HAVING BALANCE>10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097185,
                "title": "bank-account-summary-ii-solution-mysql",
                "content": "# Intuition\\nUsing Joins and Aggregate functions\\n\\n# Approach\\nThe given SQL query is retrieving the names and balances of users who have a total transaction amount greater than 10,000.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\n# SELECT U.name AS NAME , SUM(T.amount) AS BALANCE\\n# from Users U\\n# LEFT JOIN Transactions T ON T.account = U.account\\n# GROUP BY U.name\\n# HAVING SUM(T.amount)>10000;\\n\\n\\nSELECT U.name AS NAME , SUM(T.amount) AS BALANCE\\nfrom Transactions T\\nLEFT JOIN Users U ON U.account = T.account\\nGROUP BY U.name\\nHAVING SUM(T.amount)>10000;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n# SELECT U.name AS NAME , SUM(T.amount) AS BALANCE\\n# from Users U\\n# LEFT JOIN Transactions T ON T.account = U.account\\n# GROUP BY U.name\\n# HAVING SUM(T.amount)>10000;\\n\\n\\nSELECT U.name AS NAME , SUM(T.amount) AS BALANCE\\nfrom Transactions T\\nLEFT JOIN Users U ON U.account = T.account\\nGROUP BY U.name\\nHAVING SUM(T.amount)>10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4092480,
                "title": "pandas-two-step-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef account_summary(users: pd.DataFrame, transactions: pd.DataFrame) -> pd.DataFrame:\\n    df = transactions.groupby(\\'account\\')[\\'amount\\'].sum().reset_index(name=\\'balance\\')\\n    return df.merge(users,how=\\'right\\',on=\\'account\\')[df[\\'balance\\']>10000][[\\'name\\',\\'balance\\']]\\n    \\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef account_summary(users: pd.DataFrame, transactions: pd.DataFrame) -> pd.DataFrame:\\n    df = transactions.groupby(\\'account\\')[\\'amount\\'].sum().reset_index(name=\\'balance\\')\\n    return df.merge(users,how=\\'right\\',on=\\'account\\')[df[\\'balance\\']>10000][[\\'name\\',\\'balance\\']]\\n    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4092258,
                "title": "mysql-join-groupby-having-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect u.name, sum(t.amount) as balance\\nfrom users u\\njoin transactions t on u.account = t.account\\ngroup by u.account\\nhaving balance > 10000\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect u.name, sum(t.amount) as balance\\nfrom users u\\njoin transactions t on u.account = t.account\\ngroup by u.account\\nhaving balance > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084779,
                "title": "pandas-oneliner-sum-query",
                "content": "# Intuition\\nMerge both tables and simply add amount, since its already assigned as < 0 when it\\'s outflow, its as simple as sum of \"account\". Use query to filter balance > 10_000.\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef account_summary(users: pd.DataFrame, transactions: pd.DataFrame) -> pd.DataFrame:\\n    return transactions.merge(users, on = \\'account\\').groupby(\\'name\\')[\\'amount\\'].sum().to_frame(\\'balance\\').reset_index().query(\"balance > 10_000\")\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef account_summary(users: pd.DataFrame, transactions: pd.DataFrame) -> pd.DataFrame:\\n    return transactions.merge(users, on = \\'account\\').groupby(\\'name\\')[\\'amount\\'].sum().to_frame(\\'balance\\').reset_index().query(\"balance > 10_000\")\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4082110,
                "title": "pandas-solution",
                "content": "Merge users and transactions tables and drop unneeded columns (account, trans_id, transacted_on). Then groupby \\'name\\' and get the sum of the account balances for each name. Reset_index to bring back name and rename columns as necessary for submission. Lastly filter by rows which have BALANCE higher than 10000.\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef account_summary(users: pd.DataFrame, transactions: pd.DataFrame) -> pd.DataFrame:\\n    df = pd.merge(users, transactions).drop(columns=[\\'account\\', \\'trans_id\\', \\'transacted_on\\']).groupby(\\'name\\').sum().reset_index().rename(columns={\\'name\\': \\'NAME\\', \\'amount\\': \\'BALANCE\\'})\\n    return df[df[\\'BALANCE\\'] > 10000]\\n    \\n    \\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef account_summary(users: pd.DataFrame, transactions: pd.DataFrame) -> pd.DataFrame:\\n    df = pd.merge(users, transactions).drop(columns=[\\'account\\', \\'trans_id\\', \\'transacted_on\\']).groupby(\\'name\\').sum().reset_index().rename(columns={\\'name\\': \\'NAME\\', \\'amount\\': \\'BALANCE\\'})\\n    return df[df[\\'BALANCE\\'] > 10000]\\n    \\n    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4070304,
                "title": "pandas-simple-solution-by-merge",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPlssss **UPVOTE** if you like to encourage me posting more solutions :) Appreciate your support!\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef account_summary(users: pd.DataFrame, transactions: pd.DataFrame) -> pd.DataFrame:\\n\\n  df = users.merge(transactions)\\n\\n  df = df.groupby([\\'name\\'], as_index=False).agg(balance=(\\'amount\\', \\'sum\\'))\\n\\n  df = df[df[\\'balance\\'] > 10000]\\n\\n  return df\\n    \\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/dcdda3f4-4bec-4c41-b1b3-6cf4311d772f_1695250412.9674263.png)\\n",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef account_summary(users: pd.DataFrame, transactions: pd.DataFrame) -> pd.DataFrame:\\n\\n  df = users.merge(transactions)\\n\\n  df = df.groupby([\\'name\\'], as_index=False).agg(balance=(\\'amount\\', \\'sum\\'))\\n\\n  df = df[df[\\'balance\\'] > 10000]\\n\\n  return df\\n    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4068198,
                "title": "oracle-solution",
                "content": "\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSelect u.name,sum(t.amount) as balance  from Users u join Transactions t on\\nu.account=t.account  group by u.name having sum(t.amount)>10000;\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSelect u.name,sum(t.amount) as balance  from Users u join Transactions t on\\nu.account=t.account  group by u.name having sum(t.amount)>10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4067682,
                "title": "mysql-solution",
                "content": "# Code\\n```\\nselect name, sum(amount) as balance\\nfrom Users u\\nleft join Transactions t\\non u.account = t.account\\ngroup by u.account\\nhaving sum(amount) > 10000\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect name, sum(amount) as balance\\nfrom Users u\\nleft join Transactions t\\non u.account = t.account\\ngroup by u.account\\nhaving sum(amount) > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4050787,
                "title": "easy-solution-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect u.name, sum(t.amount) as balance from users u join transactions t on u.account=t.account group by u.name having sum(t.amount)>10000;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect u.name, sum(t.amount) as balance from users u join transactions t on u.account=t.account group by u.name having sum(t.amount)>10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4048468,
                "title": "simple-easy-solution-beginner-friendly",
                "content": "# Code\\n```\\n/* Write your PL/SQL query statement below */\\nselect \\n    name, \\n    sum(amount) as balance     \\nfrom \\n    users u join transactions t on u.account = t.account\\ngroup by \\n    name \\n    having sum(amount) > 10000\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect \\n    name, \\n    sum(amount) as balance     \\nfrom \\n    users u join transactions t on u.account = t.account\\ngroup by \\n    name \\n    having sum(amount) > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4045893,
                "title": "beats-99-01-of-users-with-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect name ,balance as balance from Users u\\n join\\n(select account,sum(amount) as balance from Transactions  group by account having balance>10000) a\\non a.account=u.account ;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect name ,balance as balance from Users u\\n join\\n(select account,sum(amount) as balance from Transactions  group by account having balance>10000) a\\non a.account=u.account ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041308,
                "title": "using-joins",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect name, sum(amount) as balance\\nfrom Users as u\\njoin Transactions as t\\non u.account = t.account\\ngroup by name\\nhaving balance>10000\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect name, sum(amount) as balance\\nfrom Users as u\\njoin Transactions as t\\non u.account = t.account\\ngroup by name\\nhaving balance>10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034447,
                "title": "case-when-group-by-easy-solution",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect u.name as Name , \\n\\nsum(case when t.amount > 0  then t.amount else 0 end) \\n-\\n(- sum(case when t.amount < 0 then t.amount else 0 end)) \\n\\nas BALANCE\\nfrom users u left join transactions t\\non u.account = t.account \\n\\ngroup by u.name\\nhaving balance > 10000\\n\\n \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect u.name as Name , \\n\\nsum(case when t.amount > 0  then t.amount else 0 end) \\n-\\n(- sum(case when t.amount < 0 then t.amount else 0 end)) \\n\\nas BALANCE\\nfrom users u left join transactions t\\non u.account = t.account \\n\\ngroup by u.name\\nhaving balance > 10000\\n\\n \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4030405,
                "title": "simple-solution-with-subquerry",
                "content": "\\n# Code\\n```\\nWITH H AS (\\nSELECT\\n    u.name as NAME, \\n    sum(t.amount) as BALANCE\\nFROM \\n    Users u\\nLEFT JOIN\\n    Transactions t\\nON \\n    u.account=t.account\\nGROUP BY\\n    u.account)\\n\\nSELECT * FROM H\\nWHERE BALANCE>10000\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nWITH H AS (\\nSELECT\\n    u.name as NAME, \\n    sum(t.amount) as BALANCE\\nFROM \\n    Users u\\nLEFT JOIN\\n    Transactions t\\nON \\n    u.account=t.account\\nGROUP BY\\n    u.account)\\n\\nSELECT * FROM H\\nWHERE BALANCE>10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4027195,
                "title": "simle-solution-for-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA convenient and understandable solution for general understanding.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\n\\nSELECT ur.name, SUM(ts.amount) AS balance\\nFROM Users ur\\n    INNER JOIN Transactions ts ON ur.account = ts.account\\nGROUP BY name\\nHAVING balance > 10000\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n\\nSELECT ur.name, SUM(ts.amount) AS balance\\nFROM Users ur\\n    INNER JOIN Transactions ts ON ur.account = ts.account\\nGROUP BY name\\nHAVING balance > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4023989,
                "title": "solution",
                "content": "\\n# Code\\n```\\nselect name, sum(amount) as balance\\nfrom transactions t\\njoin Users u on t.account = u.account\\ngroup by 1\\nhaving sum(amount) > 10000\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect name, sum(amount) as balance\\nfrom transactions t\\njoin Users u on t.account = u.account\\ngroup by 1\\nhaving sum(amount) > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013184,
                "title": "easiest-logic",
                "content": "\\n\\n# Code\\n```\\nSELECT u.name, SUM(t.amount) AS BALANCE FROM Transactions as t\\nRIGHT JOIN Users as u\\nON t.account = u.account\\nGROUP BY u.account\\nHAVING SUM(t.amount) > 10000 ;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT u.name, SUM(t.amount) AS BALANCE FROM Transactions as t\\nRIGHT JOIN Users as u\\nON t.account = u.account\\nGROUP BY u.account\\nHAVING SUM(t.amount) > 10000 ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4008999,
                "title": "sql-simple-solution-for-beginner",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect u.name, sum(t.amount) balance from Users u left join Transactions t on u.account=t.account\\ngroup by t.account having balance > 10000\\norder by balance desc\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect u.name, sum(t.amount) balance from Users u left join Transactions t on u.account=t.account\\ngroup by t.account having balance > 10000\\norder by balance desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4006782,
                "title": "easy-mysql",
                "content": "```\\nSELECT\\n    SUM(t.amount) AS balance,\\n    u.name\\nFROM \\n    Transactions as t\\nJOIN \\n    Users as u \\n    ON t.account = u.account\\nGROUP BY\\n    t.account\\nHAVING  \\n    balance > 10000;\\n```\\n![image](https://assets.leetcode.com/users/images/abfe6fff-e502-4384-ba47-284beea484ad_1693937402.4112647.jpeg)\\n",
                "solutionTags": [],
                "code": "```\\nSELECT\\n    SUM(t.amount) AS balance,\\n    u.name\\nFROM \\n    Transactions as t\\nJOIN \\n    Users as u \\n    ON t.account = u.account\\nGROUP BY\\n    t.account\\nHAVING  \\n    balance > 10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3999694,
                "title": "mssql-use-having",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nselect\\n  a.name\\n ,sum(b.amount) as balance\\nfrom Users as a\\ninner join Transactions as b\\non a.account = b.account\\nwhere 1=1\\ngroup by a.name\\nhaving sum(b.amount) > 10000\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect\\n  a.name\\n ,sum(b.amount) as balance\\nfrom Users as a\\ninner join Transactions as b\\non a.account = b.account\\nwhere 1=1\\ngroup by a.name\\nhaving sum(b.amount) > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3999475,
                "title": "mysql-bank-account-using-left-join",
                "content": "# Intuition\\nTo calculate the balance of users with a balance higher than 10000, we need to sum the amounts of all transactions for each user and then filter the results to include only those with a balance greater than 10000.\\n\\n# Explanation\\nWe can use a SQL query to join the Users table with the Transactions table using a LEFT JOIN based on the account column, which connects users to their transactions.\\n\\nUsing the SUM function, we calculate the balance for each user by summing up the amount column from the joined Transactions table.\\n\\nThe GROUP BY clause ensures that we calculate the balance for each user.\\n\\nThe HAVING clause is used to filter the results, including only those users whose balance is greater than 10000.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT U.name, SUM(T.amount) AS balance\\nFROM Users U\\nLEFT JOIN Transactions T ON U.account = T.account\\nGROUP BY U.name\\nHAVING SUM(T.amount) > 10000;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT U.name, SUM(T.amount) AS balance\\nFROM Users U\\nLEFT JOIN Transactions T ON U.account = T.account\\nGROUP BY U.name\\nHAVING SUM(T.amount) > 10000;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3996917,
                "title": "very-easy-mysql-explained-in-depth",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n**SELECT name as NAME, SUM(amount) as BALANCE:** This part of the query selects two columns from the result set. It renames the \\'name\\' column as \\'NAME\\' and calculates the sum of \\'amount\\' for each user, renaming this calculated sum as \\'BALANCE.\\' Essentially, it\\'s creating a list of users and their total transaction balances.\\n\\n**FROM Users:** This specifies the source table as \\'Users.\\' Presumably, \\'Users\\' contains information about user accounts.\\n\\n**JOIN Transactions ON Users.account = Transactions.account:** This part of the query performs an inner join between the \\'Users\\' and \\'Transactions\\' tables based on the \\'account\\' column. It means it combines data from both tables where the \\'account\\' values match. This allows you to associate users with their transaction records.\\n\\n**GROUP BY Transactions.account:** After joining the \\'Users\\' and \\'Transactions\\' tables, the result set is grouped by the \\'account\\' column from the \\'Transactions\\' table. This means that all transactions associated with the same account are aggregated together.\\n\\n**HAVING BALANCE > 10000:** The \\'HAVING\\' clause is used to filter the grouped results. In this case, it filters the results to only include groups (accounts) where the sum of \\'amount\\' (which is aliased as \\'BALANCE\\') is greater than 10,000. This means that only accounts with a total transaction balance exceeding 10,000 will be included in the final result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT name as NAME, SUM(amount) as BALANCE\\n\\nFROM Users\\nJOIN Transactions\\nON Users.account = Transactions.account\\nGROUP BY Transactions.account\\nHAVING BALANCE > 10000\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT name as NAME, SUM(amount) as BALANCE\\n\\nFROM Users\\nJOIN Transactions\\nON Users.account = Transactions.account\\nGROUP BY Transactions.account\\nHAVING BALANCE > 10000\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3980212,
                "title": "solution-using-having",
                "content": "Run time varies every time I run it. CTE was faster then using having, but as I ran it more the run time changed. \\n\\n# Code\\n```\\nselect u.name, sum(t.amount) as balance\\nfrom Users u inner join Transactions t on u.account = t.account\\ngroup by u.name\\nhaving balance > 10000;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect u.name, sum(t.amount) as balance\\nfrom Users u inner join Transactions t on u.account = t.account\\ngroup by u.name\\nhaving balance > 10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3979497,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement be\\nSELECT u.name,sum(t.amount) as balance from Users as u  join Transactions as t on u.account=t.account group by u.name having balance>10000\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement be\\nSELECT u.name,sum(t.amount) as balance from Users as u  join Transactions as t on u.account=t.account group by u.name having balance>10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3979030,
                "title": "easy-python-solution",
                "content": "```\\nSELECT u.name AS NAME, SUM(amount) AS BALANCE\\nFROM Users AS u LEFT JOIN Transactions AS t USING(account)\\nGROUP BY name\\nHAVING SUM(amount)>10000\\n```\\n***Hope it helps...!!*** \\uD83D\\uDE07\\u270C\\uFE0F",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT u.name AS NAME, SUM(amount) AS BALANCE\\nFROM Users AS u LEFT JOIN Transactions AS t USING(account)\\nGROUP BY name\\nHAVING SUM(amount)>10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3970658,
                "title": "simple-and-self-explanatory-solution",
                "content": "# Intuition\\nQuery requires knowledge of grouping and joining the table data.\\nWe have to join both tables given to associate names with account numbers.\\nAnd apply grouping to get the balance for each individual account number.\\n\\n# Approach\\nLet me break down the solution:\\n**Step 1:**\\n> In this step we are selecting the account and sum of the amount from Transactions table, grouping the result based on account numbers.\\nAnd Finally applying a filter to get only those rows that have sum(amount) greater than 10000.\\n\\n```\\nselect account, sum(amount) as balance from transactions group by account having balance > 10000\\n```\\n**Step 2:**\\n> Select account number and name of holder from users table.\\n\\n```\\nselect account, name from users\\n```\\n\\n**Step 3:**\\n> Now we have to join the two queries using **left join** on the **account** columns\\n\\n```\\n(select account, sum(amount) as balance from transactions group by account having balance > 10000) a\\nleft join\\n(select account, name from users) b\\non\\na.account = b.account\\n```\\n\\n**Step 4:**\\n> Now just select the account and balance columns from the joined queries, and we get the final result.\\n\\n```\\nselect b.name, a.balance\\n(select account, sum(amount) as balance from transactions group by account having balance > 10000) a\\nleft join\\n(select account, name from users) b\\non\\na.account = b.account\\n```\\n# Complexity\\n- Time complexity:\\n\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect b.name, a.balance \\nfrom \\n(select account, sum(amount) as balance from transactions group by account having balance > 10000) a\\nleft join\\n(select account, name from users) b\\non\\na.account = b.account\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect account, sum(amount) as balance from transactions group by account having balance > 10000\\n```\n```\\nselect account, name from users\\n```\n```\\n(select account, sum(amount) as balance from transactions group by account having balance > 10000) a\\nleft join\\n(select account, name from users) b\\non\\na.account = b.account\\n```\n```\\nselect b.name, a.balance\\n(select account, sum(amount) as balance from transactions group by account having balance > 10000) a\\nleft join\\n(select account, name from users) b\\non\\na.account = b.account\\n```\n```\\n# Write your MySQL query statement below\\nselect b.name, a.balance \\nfrom \\n(select account, sum(amount) as balance from transactions group by account having balance > 10000) a\\nleft join\\n(select account, name from users) b\\non\\na.account = b.account\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3967223,
                "title": "balance-of-users-with-a-abalance-higher-than-10000-mysql",
                "content": "SELECT U.name,SUM(T.amount) AS balance FROM Users U INNER JOIN Transactions T ON U.account=T.account GROUP BY T.account HAVING SUM(T.amount)>10000;",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "SELECT U.name,SUM(T.amount) AS balance FROM Users U INNER JOIN Transactions T ON U.account=T.account GROUP BY T.account HAVING SUM(T.amount)>10000;",
                "codeTag": "Unknown"
            },
            {
                "id": 3964806,
                "title": "using-sub-query-60-better-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT t1.name, t1.balance from\\n(SELECT u.name, u.account, SUM(t.amount) as balance\\nFROM Users u\\nJoin Transactions t\\nOn u.account = t.account\\nGroup by u.account, u.name) t1\\nWHERE t1.balance > 10000\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT t1.name, t1.balance from\\n(SELECT u.name, u.account, SUM(t.amount) as balance\\nFROM Users u\\nJoin Transactions t\\nOn u.account = t.account\\nGroup by u.account, u.name) t1\\nWHERE t1.balance > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3952354,
                "title": "easy-sql-solution",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\n\\nSELECT name, SUM(amount) as balance\\nFROM Users\\nLEFT JOIN Transactions\\nUSING(account)\\nGROUP BY account\\nHAVING balance>10000\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n\\nSELECT name, SUM(amount) as balance\\nFROM Users\\nLEFT JOIN Transactions\\nUSING(account)\\nGROUP BY account\\nHAVING balance>10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3951379,
                "title": "1587-bank-account-summary-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect u.name, sum(t.amount) as balance from Users u join Transactions t on u.account = t.account group by u.account having balance > 10000;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect u.name, sum(t.amount) as balance from Users u join Transactions t on u.account = t.account group by u.account having balance > 10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3944734,
                "title": "solution-bank-account",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT \\n    u.name,\\n    SUM(amount) as balance\\n    FROM Transactions t\\n    JOIN Users u\\n    ON t.account = u.account\\n    GROUP BY u.name\\n    HAVING SUM(amount) > 10000\\n\\n       \\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT \\n    u.name,\\n    SUM(amount) as balance\\n    FROM Transactions t\\n    JOIN Users u\\n    ON t.account = u.account\\n    GROUP BY u.name\\n    HAVING SUM(amount) > 10000\\n\\n       \\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3944063,
                "title": "sql-simple-solution-sum-left-join-having",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT u.name, SUM(t.amount) as balance\\nFROM Users u\\nLEFT JOIN Transactions t ON u.account = t.account\\nGROUP BY u.name\\nHAVING SUM(t.amount) > 10000\\n```\\n",
                "solutionTags": [
                    "MS SQL Server",
                    "Database"
                ],
                "code": "```\\nSELECT u.name, SUM(t.amount) as balance\\nFROM Users u\\nLEFT JOIN Transactions t ON u.account = t.account\\nGROUP BY u.name\\nHAVING SUM(t.amount) > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3941595,
                "title": "1587-bank-account-summary-ii",
                "content": "```\\nselect u.name, sum(t.amount) as balance from \\nusers u left join transactions t on\\nu.account = t.account\\ngroup by u.name\\nhaving balance > 10000;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect u.name, sum(t.amount) as balance from \\nusers u left join transactions t on\\nu.account = t.account\\ngroup by u.name\\nhaving balance > 10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3925690,
                "title": "ms-sql",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity/ -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nSELECT \\n    -- t.account,\\n    u.name as name,\\n    sum(t.amount) as balance\\nFROM\\n    Transactions as t\\nLEFT JOIN \\n    Users as u \\n    ON u.account = t.account\\nGROUP BY \\n    t.account, u.name\\nHAVING\\n    sum(t.amount) > 10000 ;\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT \\n    -- t.account,\\n    u.name as name,\\n    sum(t.amount) as balance\\nFROM\\n    Transactions as t\\nLEFT JOIN \\n    Users as u \\n    ON u.account = t.account\\nGROUP BY \\n    t.account, u.name\\nHAVING\\n    sum(t.amount) > 10000 ;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3919755,
                "title": "pandas-olution",
                "content": "# Code\\n```\\nimport pandas as pd\\n\\ndef account_summary(users: pd.DataFrame, transactions: pd.DataFrame) -> pd.DataFrame:\\n  df = transactions.groupby(\\'account\\')[\\'amount\\'].sum().reset_index(name = \\'balance\\')\\n  return users.merge(df[df[\\'balance\\']>10000], how = \\'inner\\')[[\\'name\\',\\'balance\\']]\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef account_summary(users: pd.DataFrame, transactions: pd.DataFrame) -> pd.DataFrame:\\n  df = transactions.groupby(\\'account\\')[\\'amount\\'].sum().reset_index(name = \\'balance\\')\\n  return users.merge(df[df[\\'balance\\']>10000], how = \\'inner\\')[[\\'name\\',\\'balance\\']]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3904008,
                "title": "pandas-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef account_summary(users: pd.DataFrame, transactions: pd.DataFrame) -> pd.DataFrame:    \\n    grouped = transactions.groupby(\\'account\\')[\\'amount\\'].sum().reset_index()\\n    result = pd.merge(grouped[grouped[\\'amount\\'] > 10000], users, on=\\'account\\')\\n    result.columns = [\"account\", \"NAME\", \"BALANCE\"]\\n    return result[[\"NAME\", \"BALANCE\"]]\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef account_summary(users: pd.DataFrame, transactions: pd.DataFrame) -> pd.DataFrame:    \\n    grouped = transactions.groupby(\\'account\\')[\\'amount\\'].sum().reset_index()\\n    result = pd.merge(grouped[grouped[\\'amount\\'] > 10000], users, on=\\'account\\')\\n    result.columns = [\"account\", \"NAME\", \"BALANCE\"]\\n    return result[[\"NAME\", \"BALANCE\"]]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3895899,
                "title": "mysql-2023",
                "content": "# Write your MySQL query statement below\\n\\nwith amt as (select account, sum(amount) amt from Transactions group by account)\\n\\nselect Users.name, amt.amt as balance from Users LEFT JOIN amt on Users.account=amt.account\\nwhere amt.amt>10000;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "# Write your MySQL query statement below\\n\\nwith amt as (select account, sum(amount) amt from Transactions group by account)\\n\\nselect Users.name, amt.amt as balance from Users LEFT JOIN amt on Users.account=amt.account\\nwhere amt.amt>10000;",
                "codeTag": "Unknown"
            },
            {
                "id": 3887681,
                "title": "sql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT u.name, sum(amount) AS balance FROM Users u\\nRIGHT OUTER JOIN Transactions t\\nON u.account = t.account\\nGROUP BY u.account HAVING sum(amount) > 10000 \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT u.name, sum(amount) AS balance FROM Users u\\nRIGHT OUTER JOIN Transactions t\\nON u.account = t.account\\nGROUP BY u.account HAVING sum(amount) > 10000 \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3885077,
                "title": "simplest-and-easiest-way-to-do",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect name , sum(t.amount) as balance from Transactions t\\nleft join users u on t.account =  u.account\\ngroup by t.account having balance > 10000\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect name , sum(t.amount) as balance from Transactions t\\nleft join users u on t.account =  u.account\\ngroup by t.account having balance > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3883510,
                "title": "most-simple-solution-ever",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nselect u.name, sum(t.amount) balance\\nfrom users u inner join transactions t \\non u.account = t.account \\ngroup by u.account , u.name\\nhaving sum(t.amount)>10000\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect u.name, sum(t.amount) balance\\nfrom users u inner join transactions t \\non u.account = t.account \\ngroup by u.account , u.name\\nhaving sum(t.amount)>10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3871701,
                "title": "having",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect u.name, sum(t.amount) balance\\nfrom Users u\\njoin Transactions t\\non u.account = t.account\\ngroup by t.account\\nhaving sum(amount) > 10000;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect u.name, sum(t.amount) balance\\nfrom Users u\\njoin Transactions t\\non u.account = t.account\\ngroup by t.account\\nhaving sum(amount) > 10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3863897,
                "title": "group-by-ms-sql-server",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\nFor a fact table such as Transactions/Sales wherein multiple entries may get created for a single user & the problems states to find out the sum/average, GROUP BY is the most suitable clause\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\nAs a single account may have multiple Transactions leading to multiple entries getting created in the Transactions table, joining on the account column is the first step to get a cummulative result set. Once the join is made, we can group by the account number from the transactions table & take the sum for each of the group & display only those groups which have the sum of amount greater than 10000 by applying the HAVING clause.\\r\\n\\r\\n# Code\\r\\n```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\nSELECT\\r\\n    name=U.name, balance=sum(T.amount)\\r\\nFROM\\r\\n    Users U\\r\\nLEFT JOIN\\r\\n    Transactions T ON T.account = U.account\\r\\nGROUP BY\\r\\n    T.account, U.name\\r\\nHAVING\\r\\n    sum(T.amount) > 10000\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\nSELECT\\r\\n    name=U.name, balance=sum(T.amount)\\r\\nFROM\\r\\n    Users U\\r\\nLEFT JOIN\\r\\n    Transactions T ON T.account = U.account\\r\\nGROUP BY\\r\\n    T.account, U.name\\r\\nHAVING\\r\\n    sum(T.amount) > 10000\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3852759,
                "title": "easy-to-understand-solution",
                "content": "```\\nselect  name, sum(amount) as balance from Users\\njoin Transactions using(account)\\ngroup by 1\\nhaving sum(amount) > 10000;\\n```\\n\\n![image](https://assets.leetcode.com/users/images/d5b741cc-28f7-463b-afa1-ee5543bb4e3f_1690973995.984746.png)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect  name, sum(amount) as balance from Users\\njoin Transactions using(account)\\ngroup by 1\\nhaving sum(amount) > 10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3849111,
                "title": "cte-approach-for-bank-account-summary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe should get the accounts that is having balance greater than 10000 and each account can have multiple transactions.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse CTE first get sum of all the transaction for each account using group by and from CTE do INNER JOIN to Users Table, get the names and balance which is greater than 10000\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nWITH CTE AS(SELECT account, sum(amount) as balance FROM Transactions GROUP BY account) SELECT Users.name, CTE.balance FROM CTE INNER JOIN Users ON CTE.account = Users.account WHERE balance > 10000;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nWITH CTE AS(SELECT account, sum(amount) as balance FROM Transactions GROUP BY account) SELECT Users.name, CTE.balance FROM CTE INNER JOIN Users ON CTE.account = Users.account WHERE balance > 10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3848844,
                "title": "bank-account-summary-ii",
                "content": "\\n\\n# Code\\n```\\n# MYSQL Easy Solution\\n\\nSelect u.name,sum(t.amount) as balance\\nfrom Users u JOIN Transactions t\\nON u.account = t.account\\ngroup by t.account\\nhaving sum(t.amount) > 10000\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# MYSQL Easy Solution\\n\\nSelect u.name,sum(t.amount) as balance\\nfrom Users u JOIN Transactions t\\nON u.account = t.account\\ngroup by t.account\\nhaving sum(t.amount) > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3834763,
                "title": "easy-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect u.name as name, sum(t.amount) as balance \\nfrom Transactions as t join Users as u \\non t.account = u.account \\ngroup by t.account \\nhaving sum(t.amount) > \\'10000\\';\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect u.name as name, sum(t.amount) as balance \\nfrom Transactions as t join Users as u \\non t.account = u.account \\ngroup by t.account \\nhaving sum(t.amount) > \\'10000\\';\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3825391,
                "title": "mysql-left-join-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT Users.name AS NAME, SUM(Transactions.amount) AS BALANCE \\nFROM Users LEFT JOIN Transactions  \\nON Users.account = Transactions.account \\nGROUP BY Users.account \\nHAVING BALANCE > 10000;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT Users.name AS NAME, SUM(Transactions.amount) AS BALANCE \\nFROM Users LEFT JOIN Transactions  \\nON Users.account = Transactions.account \\nGROUP BY Users.account \\nHAVING BALANCE > 10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3817924,
                "title": "simple-solution-in-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we have to find the sum of amounts, we have to use group by clause and the grouping would be done based on the account name. Then we have to find the balance that**Bold** fall in the desired range using having clause\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe first left both the tables based on the account column in both the tables. Then group by account name and find the balance of each account by calculating the aggregate sum of amounts of each account. Finally we select those account names whose balance is more than 10000 using having clause.\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect u.name as \"NAME\", sum(t.amount) as \"BALANCE\" \\nfrom Usrs u \\nleft join Transactions t\\non u.account = t.account\\ngroup by name\\nhaving sum(t.amount) >10000;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect u.name as \"NAME\", sum(t.amount) as \"BALANCE\" \\nfrom Usrs u \\nleft join Transactions t\\non u.account = t.account\\ngroup by name\\nhaving sum(t.amount) >10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3815128,
                "title": "easiest-mysql-query-using-join-and-group-by",
                "content": "\\nSELECT Users.name,sum(Transactions.amount) AS balance\\nFROM Users\\nINNER JOIN Transactions\\nON Users.account = Transactions.account\\nGROUP BY Users.name\\nHAVING balance > 10000;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\nSELECT Users.name,sum(Transactions.amount) AS balance\\nFROM Users\\nINNER JOIN Transactions\\nON Users.account = Transactions.account\\nGROUP BY Users.name\\nHAVING balance > 10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3810221,
                "title": "easy-mysql-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect u.name , SUM(t.amount) as balance\\nfrom users u\\njoin transactions t\\non u.account = t.account\\ngroup by t.account\\nhaving balance > 10000;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect u.name , SUM(t.amount) as balance\\nfrom users u\\njoin transactions t\\non u.account = t.account\\ngroup by t.account\\nhaving balance > 10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3807593,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT name , SUM(t.amount) AS balance \\nFROM Users s , Transactions t\\nWHERE s.account = t.account\\nGROUP BY  s.name , t.account \\nHAVING  10000 < SUM(t.amount) \\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSELECT name , SUM(t.amount) AS balance \\nFROM Users s , Transactions t\\nWHERE s.account = t.account\\nGROUP BY  s.name , t.account \\nHAVING  10000 < SUM(t.amount) \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3805719,
                "title": "easy-soln-using-inner-join-group-by-and-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect u.name,sum(t.amount) as balance from users u join transactions t using(account) group by account\\nhaving balance > 10000;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect u.name,sum(t.amount) as balance from users u join transactions t using(account) group by account\\nhaving balance > 10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3805000,
                "title": "easy-code",
                "content": "\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nWITH CTEBALANCE AS\\n(\\nSELECT \\nU.name,\\nSUM(T.amount) AS balance    \\nFROM Users U\\nINNER JOIN Transactions T ON U.account = T.account \\nGROUP BY T.account   , U.name\\n)\\nSELECT * FROM CTEBALANCE\\nWHERE balance > 10000\\n\\n\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nWITH CTEBALANCE AS\\n(\\nSELECT \\nU.name,\\nSUM(T.amount) AS balance    \\nFROM Users U\\nINNER JOIN Transactions T ON U.account = T.account \\nGROUP BY T.account   , U.name\\n)\\nSELECT * FROM CTEBALANCE\\nWHERE balance > 10000\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3787877,
                "title": "easy-solution-by-query-in",
                "content": "# Appreciate for your upvote\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT\\n    name,\\n    balance\\nFROM    \\n    (SELECT\\n        name,\\n        SUM(amount) AS balance\\n    FROM\\n        Transactions\\n        LEFT JOIN\\n        Users USING(account)\\n    GROUP BY\\n        name) AS t1\\nWHERE balance > 10000\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT\\n    name,\\n    balance\\nFROM    \\n    (SELECT\\n        name,\\n        SUM(amount) AS balance\\n    FROM\\n        Transactions\\n        LEFT JOIN\\n        Users USING(account)\\n    GROUP BY\\n        name) AS t1\\nWHERE balance > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3784990,
                "title": "easy-solution-0718",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect A.name, sum(B.amount) balance\\nfrom Users A join Transactions B on A.account = B.account\\ngroup by A.account\\nhaving balance > 10000\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect A.name, sum(B.amount) balance\\nfrom Users A join Transactions B on A.account = B.account\\ngroup by A.account\\nhaving balance > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3781494,
                "title": "simple-easy-to-read",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT      a.name, SUM(b.amount) AS \\'balance\\'\\nFROM        Users a\\nLEFT JOIN   Transactions b\\nON          a.account = b.account\\nGROUP BY    a.name\\nHAVING      SUM(b.amount) > 10000\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT      a.name, SUM(b.amount) AS \\'balance\\'\\nFROM        Users a\\nLEFT JOIN   Transactions b\\nON          a.account = b.account\\nGROUP BY    a.name\\nHAVING      SUM(b.amount) > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3775984,
                "title": "ms-sql-server-solution-using-window-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nselect u.name, t.balance\\nfrom\\nusers u\\njoin\\n(select account, balance from\\n(select *, sum(amount) over (partition by account) as balance\\nfrom\\ntransactions) t\\ngroup by account, balance\\n) t\\non t.account=u.account\\nand balance>10000\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nselect u.name, t.balance\\nfrom\\nusers u\\njoin\\n(select account, balance from\\n(select *, sum(amount) over (partition by account) as balance\\nfrom\\ntransactions) t\\ngroup by account, balance\\n) t\\non t.account=u.account\\nand balance>10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3769703,
                "title": "mysql-solution",
                "content": "```\\nselect NAME, sum(amount) as BALANCE from (select u1.account, u1.name, t2.amount from users as u1 inner join transactions as t2 on u1.account = t2.account) a group by account having BALANCE > 10000;\\n```",
                "solutionTags": [],
                "code": "```\\nselect NAME, sum(amount) as BALANCE from (select u1.account, u1.name, t2.amount from users as u1 inner join transactions as t2 on u1.account = t2.account) a group by account having BALANCE > 10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3763311,
                "title": "easy-and-clean-solution-in-mysql",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect u.name, \\nsum(t.amount) as balance\\nfrom users u \\njoin \\ntransactions t \\non u.account = t.account\\ngroup by t.account having sum(t.amount)>10000\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect u.name, \\nsum(t.amount) as balance\\nfrom users u \\njoin \\ntransactions t \\non u.account = t.account\\ngroup by t.account having sum(t.amount)>10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3763040,
                "title": "beats-more-than-85-using-aggregate-sum-fun-and-group-by-clause",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect Users.name, sum(Transactions.amount) as balance from Users join Transactions on Users.account=Transactions.account \\ngroup by Transactions.account\\nhaving balance>10000;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect Users.name, sum(Transactions.amount) as balance from Users join Transactions on Users.account=Transactions.account \\ngroup by Transactions.account\\nhaving balance>10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3746975,
                "title": "get-most-balance-beats-92",
                "content": "\\n# Run time: 1412 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect name, sum(amount) as balance from Users join Transactions on Users.account = Transactions.account group by Transactions.account having sum(Transactions.amount) > 10000\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect name, sum(amount) as balance from Users join Transactions on Users.account = Transactions.account group by Transactions.account having sum(Transactions.amount) > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3745529,
                "title": "a-solution-with-explanation",
                "content": "# Intuition\\nFor this problem we need to do the following:\\n1. select the required column(s) and compute the necessary calculatons based on the information on the tables\\n2. Merge the reference columns by utilizing the common column (account in this case) \\n3. Group the data based on the account numbers because we want to learn the balance for each individual.\\n4. Only pick the ones having balance bigger than 10000.\\n\\nThe final code looks like this:\\n\\n# Code\\n```\\nselect u.name,sum(t.amount) as balance from users u\\ninner join transactions t on u.account = t.account\\ngroup by u.account\\nhaving balance > 10000;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nselect u.name,sum(t.amount) as balance from users u\\ninner join transactions t on u.account = t.account\\ngroup by u.account\\nhaving balance > 10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3745427,
                "title": "mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT u.name, SUM(t.amount) AS balance\\nFROM Users u\\nJOIN Transactions t ON u.account = t.account\\nGROUP BY u.name\\nHAVING balance > 10000;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT u.name, SUM(t.amount) AS balance\\nFROM Users u\\nJOIN Transactions t ON u.account = t.account\\nGROUP BY u.name\\nHAVING balance > 10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3741358,
                "title": "mysql-and-oracle-solution",
                "content": "# Intuition\\nAggregation of amount in transactions\\n\\n# Approach\\nAggregation of amount in transactions\\nand having clause to check higher 10 000 sum of amount\\n\\n# Complexity\\n- Time complexity:\\nOracle: 170+ ms\\nMySQL: 150+ ms\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect u.name, sum(t.amount) as balance from users u join transactions t on u.account = t.account group by u.name having sum(t.amount) > 10000\\n```",
                "solutionTags": [
                    "MySQL",
                    "Oracle"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect u.name, sum(t.amount) as balance from users u join transactions t on u.account = t.account group by u.name having sum(t.amount) > 10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3739354,
                "title": "sql-simple-solution-joins",
                "content": "# Code\\n```\\nSELECT U.name, SUM(T.amount) AS balance FROM Users U\\nJOIN Transactions T on\\nU.account = T.account\\nGROUP BY(U.name)\\nHAVING SUM(amount) > 10000;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nSELECT U.name, SUM(T.amount) AS balance FROM Users U\\nJOIN Transactions T on\\nU.account = T.account\\nGROUP BY(U.name)\\nHAVING SUM(amount) > 10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3729858,
                "title": "mysql-simple-solution",
                "content": "\\n# Code\\n```\\nselect u.name as NAME,sum(t.amount) as BALANCE\\nfrom Users as u, Transactions as t\\nwhere u.account = t.account\\ngroup by u.name\\nhaving sum(t.amount)>10000;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect u.name as NAME,sum(t.amount) as BALANCE\\nfrom Users as u, Transactions as t\\nwhere u.account = t.account\\ngroup by u.name\\nhaving sum(t.amount)>10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3681392,
                "title": "simple-solution-for-mssql-server",
                "content": "\\n**Simple solution Using Group By and Having clause** \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\n\\nselect name,sum(amount) as balance from Users as U\\njoin Transactions T\\non U.account = T.account\\ngroup by name\\nhaving sum(amount)>10000\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\n\\nselect name,sum(amount) as balance from Users as U\\njoin Transactions T\\non U.account = T.account\\ngroup by name\\nhaving sum(amount)>10000\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3675597,
                "title": "easy-sql-query",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect name,sum(amount) balance from Users a,Transactions b where \\na.account=b.account group by b.account having sum(amount)>10000;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect name,sum(amount) balance from Users a,Transactions b where \\na.account=b.account group by b.account having sum(amount)>10000;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3671207,
                "title": "simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nSELECT u.name,SUM(amount) as BALANCE FROM Users u join Transactions t on u.account = t.account\\nGROUP BY u.name\\nHaving SUM(amount)>10000 \\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT u.name,SUM(amount) as BALANCE FROM Users u join Transactions t on u.account = t.account\\nGROUP BY u.name\\nHaving SUM(amount)>10000 \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3665826,
                "title": "simple-easy-solution",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect u.name, sum(t.amount) as balance  from Users as u\\nright join Transactions as t\\non u.account = t.account\\ngroup by u.name\\nhaving balance > 10000;\\n\\n# any of left,inner or right join will work becuase accounts are same in both tables \\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect u.name, sum(t.amount) as balance  from Users as u\\nright join Transactions as t\\non u.account = t.account\\ngroup by u.name\\nhaving balance > 10000;\\n\\n# any of left,inner or right join will work becuase accounts are same in both tables \\n\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1576883,
                "content": [
                    {
                        "username": "clashkingjeet",
                        "content": "**<-----Upvote Here**\\n\\nSolution-\\n\\n\\tSELECT u.name, SUM(amount) as balance\\n\\tFROM Transactions t\\n\\tLEFT JOIN Users u ON u.account=t.account GROUP BY t.account\\n\\tHAVING SUM(amount)>10000\\n\\t\\n![image](https://assets.leetcode.com/users/images/0640b163-3097-4163-91d9-f9ab751efdc9_1654957305.362194.png)\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "how would i do it if i were to use window function with sum"
                    },
                    {
                        "username": "HimanshuBhoir",
                        "content": "\\t# Write your MySQL query statement below\\n\\tselect Users.name, sum(Transactions.amount) as balance \\n\\tfrom Transactions\\n\\tleft join Users\\n\\ton Transactions.account = users.account\\n\\tgroup by Transactions.account\\n\\tHaving sum(Transactions.amount) > 10000;"
                    },
                    {
                        "username": "sindhujaC77",
                        "content": "------- simple way ---------\\n\\nselect name, sum(amount) as balance\\nfrom users u, transactions t\\nwhere u.account=t.account\\ngroup by u.account\\nhaving sum(amount)>10000\\n"
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select Users.name as NAME,sum(amount) as BALANCE \\nfrom\\n Users\\n left join \\n Transactions on Users.account = Transactions.account\\n group by Transactions.account\\n having sum(amount)>10000;"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Coming from postgres, mysql uses HAVING MORE\\n\\nhttps://devdocs.io/postgresql~15/sql-select#SQL-HAVING\\n\\n> HAVING eliminates group rows that do not satisfy the condition. HAVING is different from WHERE: WHERE filters individual rows before the application of GROUP BY, while HAVING filters group rows created by GROUP BY. Each column referenced in condition must unambiguously reference a grouping column, unless the reference appears within an aggregate function or the ungrouped column is functionally dependent on the grouping columns."
                    },
                    {
                        "username": "Ravi_Tomar",
                        "content": "----\\nSELECT U.NAME, SUM(T.AMOUNT) AS BALANCE FROM USERS U INNER JOIN TRANSACTIONS T\\nON U.ACCOUNT=T.ACCOUNT \\nGROUP BY U.ACCOUNT\\nHAVING SUM(T.AMOUNT) > 10000"
                    },
                    {
                        "username": "Zain_ul_rab",
                        "content": "SELECT name,SUM(amount) as balance FROM Users u LEFT JOIN Transactions t ON u.account = t.account\\nGROUP BY t.account\\nHAVING SUM(amount) > 10000"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select u.name,a.balance\\nfrom users u,\\n(select account,sum(Amount) as \\'balance\\'\\nfrom Transactions\\ngroup by account) a\\nwhere u.account=a.account\\nand a.balance>10000;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select name , sum(t.amount) as balance\\nfrom users as u\\nleft JOIN Transactions as t\\non u.account = t.account\\ngroup by u.account having sum(t.amount) > 10000;"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "SOLUTION with EXPLANATION :\\n\\nFirst we have to find the total sum of every account, so for that SUM(transaction.amount) using join on condition that account should be same so, users.account = transaction.account after that we have to print only accounts with more than 10000\\nso grouping users.account having clause condition ( balance i.e SUM(transaction.amount) > 10000 ) .\\n\\nSelect u.name, SUM(t.amount) AS balance \\nFrom Users u LEFT JOIN Transactions t\\nON u.account = t.account\\nGroup by u.account having balance > 10000;\\n\\n"
                    }
                ]
            },
            {
                "id": 1576562,
                "content": [
                    {
                        "username": "clashkingjeet",
                        "content": "**<-----Upvote Here**\\n\\nSolution-\\n\\n\\tSELECT u.name, SUM(amount) as balance\\n\\tFROM Transactions t\\n\\tLEFT JOIN Users u ON u.account=t.account GROUP BY t.account\\n\\tHAVING SUM(amount)>10000\\n\\t\\n![image](https://assets.leetcode.com/users/images/0640b163-3097-4163-91d9-f9ab751efdc9_1654957305.362194.png)\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "how would i do it if i were to use window function with sum"
                    },
                    {
                        "username": "HimanshuBhoir",
                        "content": "\\t# Write your MySQL query statement below\\n\\tselect Users.name, sum(Transactions.amount) as balance \\n\\tfrom Transactions\\n\\tleft join Users\\n\\ton Transactions.account = users.account\\n\\tgroup by Transactions.account\\n\\tHaving sum(Transactions.amount) > 10000;"
                    },
                    {
                        "username": "sindhujaC77",
                        "content": "------- simple way ---------\\n\\nselect name, sum(amount) as balance\\nfrom users u, transactions t\\nwhere u.account=t.account\\ngroup by u.account\\nhaving sum(amount)>10000\\n"
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select Users.name as NAME,sum(amount) as BALANCE \\nfrom\\n Users\\n left join \\n Transactions on Users.account = Transactions.account\\n group by Transactions.account\\n having sum(amount)>10000;"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Coming from postgres, mysql uses HAVING MORE\\n\\nhttps://devdocs.io/postgresql~15/sql-select#SQL-HAVING\\n\\n> HAVING eliminates group rows that do not satisfy the condition. HAVING is different from WHERE: WHERE filters individual rows before the application of GROUP BY, while HAVING filters group rows created by GROUP BY. Each column referenced in condition must unambiguously reference a grouping column, unless the reference appears within an aggregate function or the ungrouped column is functionally dependent on the grouping columns."
                    },
                    {
                        "username": "Ravi_Tomar",
                        "content": "----\\nSELECT U.NAME, SUM(T.AMOUNT) AS BALANCE FROM USERS U INNER JOIN TRANSACTIONS T\\nON U.ACCOUNT=T.ACCOUNT \\nGROUP BY U.ACCOUNT\\nHAVING SUM(T.AMOUNT) > 10000"
                    },
                    {
                        "username": "Zain_ul_rab",
                        "content": "SELECT name,SUM(amount) as balance FROM Users u LEFT JOIN Transactions t ON u.account = t.account\\nGROUP BY t.account\\nHAVING SUM(amount) > 10000"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select u.name,a.balance\\nfrom users u,\\n(select account,sum(Amount) as \\'balance\\'\\nfrom Transactions\\ngroup by account) a\\nwhere u.account=a.account\\nand a.balance>10000;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select name , sum(t.amount) as balance\\nfrom users as u\\nleft JOIN Transactions as t\\non u.account = t.account\\ngroup by u.account having sum(t.amount) > 10000;"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "SOLUTION with EXPLANATION :\\n\\nFirst we have to find the total sum of every account, so for that SUM(transaction.amount) using join on condition that account should be same so, users.account = transaction.account after that we have to print only accounts with more than 10000\\nso grouping users.account having clause condition ( balance i.e SUM(transaction.amount) > 10000 ) .\\n\\nSelect u.name, SUM(t.amount) AS balance \\nFrom Users u LEFT JOIN Transactions t\\nON u.account = t.account\\nGroup by u.account having balance > 10000;\\n\\n"
                    }
                ]
            },
            {
                "id": 1930173,
                "content": [
                    {
                        "username": "clashkingjeet",
                        "content": "**<-----Upvote Here**\\n\\nSolution-\\n\\n\\tSELECT u.name, SUM(amount) as balance\\n\\tFROM Transactions t\\n\\tLEFT JOIN Users u ON u.account=t.account GROUP BY t.account\\n\\tHAVING SUM(amount)>10000\\n\\t\\n![image](https://assets.leetcode.com/users/images/0640b163-3097-4163-91d9-f9ab751efdc9_1654957305.362194.png)\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "how would i do it if i were to use window function with sum"
                    },
                    {
                        "username": "HimanshuBhoir",
                        "content": "\\t# Write your MySQL query statement below\\n\\tselect Users.name, sum(Transactions.amount) as balance \\n\\tfrom Transactions\\n\\tleft join Users\\n\\ton Transactions.account = users.account\\n\\tgroup by Transactions.account\\n\\tHaving sum(Transactions.amount) > 10000;"
                    },
                    {
                        "username": "sindhujaC77",
                        "content": "------- simple way ---------\\n\\nselect name, sum(amount) as balance\\nfrom users u, transactions t\\nwhere u.account=t.account\\ngroup by u.account\\nhaving sum(amount)>10000\\n"
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select Users.name as NAME,sum(amount) as BALANCE \\nfrom\\n Users\\n left join \\n Transactions on Users.account = Transactions.account\\n group by Transactions.account\\n having sum(amount)>10000;"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Coming from postgres, mysql uses HAVING MORE\\n\\nhttps://devdocs.io/postgresql~15/sql-select#SQL-HAVING\\n\\n> HAVING eliminates group rows that do not satisfy the condition. HAVING is different from WHERE: WHERE filters individual rows before the application of GROUP BY, while HAVING filters group rows created by GROUP BY. Each column referenced in condition must unambiguously reference a grouping column, unless the reference appears within an aggregate function or the ungrouped column is functionally dependent on the grouping columns."
                    },
                    {
                        "username": "Ravi_Tomar",
                        "content": "----\\nSELECT U.NAME, SUM(T.AMOUNT) AS BALANCE FROM USERS U INNER JOIN TRANSACTIONS T\\nON U.ACCOUNT=T.ACCOUNT \\nGROUP BY U.ACCOUNT\\nHAVING SUM(T.AMOUNT) > 10000"
                    },
                    {
                        "username": "Zain_ul_rab",
                        "content": "SELECT name,SUM(amount) as balance FROM Users u LEFT JOIN Transactions t ON u.account = t.account\\nGROUP BY t.account\\nHAVING SUM(amount) > 10000"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select u.name,a.balance\\nfrom users u,\\n(select account,sum(Amount) as \\'balance\\'\\nfrom Transactions\\ngroup by account) a\\nwhere u.account=a.account\\nand a.balance>10000;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select name , sum(t.amount) as balance\\nfrom users as u\\nleft JOIN Transactions as t\\non u.account = t.account\\ngroup by u.account having sum(t.amount) > 10000;"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "SOLUTION with EXPLANATION :\\n\\nFirst we have to find the total sum of every account, so for that SUM(transaction.amount) using join on condition that account should be same so, users.account = transaction.account after that we have to print only accounts with more than 10000\\nso grouping users.account having clause condition ( balance i.e SUM(transaction.amount) > 10000 ) .\\n\\nSelect u.name, SUM(t.amount) AS balance \\nFrom Users u LEFT JOIN Transactions t\\nON u.account = t.account\\nGroup by u.account having balance > 10000;\\n\\n"
                    }
                ]
            },
            {
                "id": 1851303,
                "content": [
                    {
                        "username": "clashkingjeet",
                        "content": "**<-----Upvote Here**\\n\\nSolution-\\n\\n\\tSELECT u.name, SUM(amount) as balance\\n\\tFROM Transactions t\\n\\tLEFT JOIN Users u ON u.account=t.account GROUP BY t.account\\n\\tHAVING SUM(amount)>10000\\n\\t\\n![image](https://assets.leetcode.com/users/images/0640b163-3097-4163-91d9-f9ab751efdc9_1654957305.362194.png)\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "how would i do it if i were to use window function with sum"
                    },
                    {
                        "username": "HimanshuBhoir",
                        "content": "\\t# Write your MySQL query statement below\\n\\tselect Users.name, sum(Transactions.amount) as balance \\n\\tfrom Transactions\\n\\tleft join Users\\n\\ton Transactions.account = users.account\\n\\tgroup by Transactions.account\\n\\tHaving sum(Transactions.amount) > 10000;"
                    },
                    {
                        "username": "sindhujaC77",
                        "content": "------- simple way ---------\\n\\nselect name, sum(amount) as balance\\nfrom users u, transactions t\\nwhere u.account=t.account\\ngroup by u.account\\nhaving sum(amount)>10000\\n"
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select Users.name as NAME,sum(amount) as BALANCE \\nfrom\\n Users\\n left join \\n Transactions on Users.account = Transactions.account\\n group by Transactions.account\\n having sum(amount)>10000;"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Coming from postgres, mysql uses HAVING MORE\\n\\nhttps://devdocs.io/postgresql~15/sql-select#SQL-HAVING\\n\\n> HAVING eliminates group rows that do not satisfy the condition. HAVING is different from WHERE: WHERE filters individual rows before the application of GROUP BY, while HAVING filters group rows created by GROUP BY. Each column referenced in condition must unambiguously reference a grouping column, unless the reference appears within an aggregate function or the ungrouped column is functionally dependent on the grouping columns."
                    },
                    {
                        "username": "Ravi_Tomar",
                        "content": "----\\nSELECT U.NAME, SUM(T.AMOUNT) AS BALANCE FROM USERS U INNER JOIN TRANSACTIONS T\\nON U.ACCOUNT=T.ACCOUNT \\nGROUP BY U.ACCOUNT\\nHAVING SUM(T.AMOUNT) > 10000"
                    },
                    {
                        "username": "Zain_ul_rab",
                        "content": "SELECT name,SUM(amount) as balance FROM Users u LEFT JOIN Transactions t ON u.account = t.account\\nGROUP BY t.account\\nHAVING SUM(amount) > 10000"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select u.name,a.balance\\nfrom users u,\\n(select account,sum(Amount) as \\'balance\\'\\nfrom Transactions\\ngroup by account) a\\nwhere u.account=a.account\\nand a.balance>10000;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select name , sum(t.amount) as balance\\nfrom users as u\\nleft JOIN Transactions as t\\non u.account = t.account\\ngroup by u.account having sum(t.amount) > 10000;"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "SOLUTION with EXPLANATION :\\n\\nFirst we have to find the total sum of every account, so for that SUM(transaction.amount) using join on condition that account should be same so, users.account = transaction.account after that we have to print only accounts with more than 10000\\nso grouping users.account having clause condition ( balance i.e SUM(transaction.amount) > 10000 ) .\\n\\nSelect u.name, SUM(t.amount) AS balance \\nFrom Users u LEFT JOIN Transactions t\\nON u.account = t.account\\nGroup by u.account having balance > 10000;\\n\\n"
                    }
                ]
            },
            {
                "id": 1832741,
                "content": [
                    {
                        "username": "clashkingjeet",
                        "content": "**<-----Upvote Here**\\n\\nSolution-\\n\\n\\tSELECT u.name, SUM(amount) as balance\\n\\tFROM Transactions t\\n\\tLEFT JOIN Users u ON u.account=t.account GROUP BY t.account\\n\\tHAVING SUM(amount)>10000\\n\\t\\n![image](https://assets.leetcode.com/users/images/0640b163-3097-4163-91d9-f9ab751efdc9_1654957305.362194.png)\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "how would i do it if i were to use window function with sum"
                    },
                    {
                        "username": "HimanshuBhoir",
                        "content": "\\t# Write your MySQL query statement below\\n\\tselect Users.name, sum(Transactions.amount) as balance \\n\\tfrom Transactions\\n\\tleft join Users\\n\\ton Transactions.account = users.account\\n\\tgroup by Transactions.account\\n\\tHaving sum(Transactions.amount) > 10000;"
                    },
                    {
                        "username": "sindhujaC77",
                        "content": "------- simple way ---------\\n\\nselect name, sum(amount) as balance\\nfrom users u, transactions t\\nwhere u.account=t.account\\ngroup by u.account\\nhaving sum(amount)>10000\\n"
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select Users.name as NAME,sum(amount) as BALANCE \\nfrom\\n Users\\n left join \\n Transactions on Users.account = Transactions.account\\n group by Transactions.account\\n having sum(amount)>10000;"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Coming from postgres, mysql uses HAVING MORE\\n\\nhttps://devdocs.io/postgresql~15/sql-select#SQL-HAVING\\n\\n> HAVING eliminates group rows that do not satisfy the condition. HAVING is different from WHERE: WHERE filters individual rows before the application of GROUP BY, while HAVING filters group rows created by GROUP BY. Each column referenced in condition must unambiguously reference a grouping column, unless the reference appears within an aggregate function or the ungrouped column is functionally dependent on the grouping columns."
                    },
                    {
                        "username": "Ravi_Tomar",
                        "content": "----\\nSELECT U.NAME, SUM(T.AMOUNT) AS BALANCE FROM USERS U INNER JOIN TRANSACTIONS T\\nON U.ACCOUNT=T.ACCOUNT \\nGROUP BY U.ACCOUNT\\nHAVING SUM(T.AMOUNT) > 10000"
                    },
                    {
                        "username": "Zain_ul_rab",
                        "content": "SELECT name,SUM(amount) as balance FROM Users u LEFT JOIN Transactions t ON u.account = t.account\\nGROUP BY t.account\\nHAVING SUM(amount) > 10000"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select u.name,a.balance\\nfrom users u,\\n(select account,sum(Amount) as \\'balance\\'\\nfrom Transactions\\ngroup by account) a\\nwhere u.account=a.account\\nand a.balance>10000;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select name , sum(t.amount) as balance\\nfrom users as u\\nleft JOIN Transactions as t\\non u.account = t.account\\ngroup by u.account having sum(t.amount) > 10000;"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "SOLUTION with EXPLANATION :\\n\\nFirst we have to find the total sum of every account, so for that SUM(transaction.amount) using join on condition that account should be same so, users.account = transaction.account after that we have to print only accounts with more than 10000\\nso grouping users.account having clause condition ( balance i.e SUM(transaction.amount) > 10000 ) .\\n\\nSelect u.name, SUM(t.amount) AS balance \\nFrom Users u LEFT JOIN Transactions t\\nON u.account = t.account\\nGroup by u.account having balance > 10000;\\n\\n"
                    }
                ]
            },
            {
                "id": 1811608,
                "content": [
                    {
                        "username": "clashkingjeet",
                        "content": "**<-----Upvote Here**\\n\\nSolution-\\n\\n\\tSELECT u.name, SUM(amount) as balance\\n\\tFROM Transactions t\\n\\tLEFT JOIN Users u ON u.account=t.account GROUP BY t.account\\n\\tHAVING SUM(amount)>10000\\n\\t\\n![image](https://assets.leetcode.com/users/images/0640b163-3097-4163-91d9-f9ab751efdc9_1654957305.362194.png)\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "how would i do it if i were to use window function with sum"
                    },
                    {
                        "username": "HimanshuBhoir",
                        "content": "\\t# Write your MySQL query statement below\\n\\tselect Users.name, sum(Transactions.amount) as balance \\n\\tfrom Transactions\\n\\tleft join Users\\n\\ton Transactions.account = users.account\\n\\tgroup by Transactions.account\\n\\tHaving sum(Transactions.amount) > 10000;"
                    },
                    {
                        "username": "sindhujaC77",
                        "content": "------- simple way ---------\\n\\nselect name, sum(amount) as balance\\nfrom users u, transactions t\\nwhere u.account=t.account\\ngroup by u.account\\nhaving sum(amount)>10000\\n"
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select Users.name as NAME,sum(amount) as BALANCE \\nfrom\\n Users\\n left join \\n Transactions on Users.account = Transactions.account\\n group by Transactions.account\\n having sum(amount)>10000;"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Coming from postgres, mysql uses HAVING MORE\\n\\nhttps://devdocs.io/postgresql~15/sql-select#SQL-HAVING\\n\\n> HAVING eliminates group rows that do not satisfy the condition. HAVING is different from WHERE: WHERE filters individual rows before the application of GROUP BY, while HAVING filters group rows created by GROUP BY. Each column referenced in condition must unambiguously reference a grouping column, unless the reference appears within an aggregate function or the ungrouped column is functionally dependent on the grouping columns."
                    },
                    {
                        "username": "Ravi_Tomar",
                        "content": "----\\nSELECT U.NAME, SUM(T.AMOUNT) AS BALANCE FROM USERS U INNER JOIN TRANSACTIONS T\\nON U.ACCOUNT=T.ACCOUNT \\nGROUP BY U.ACCOUNT\\nHAVING SUM(T.AMOUNT) > 10000"
                    },
                    {
                        "username": "Zain_ul_rab",
                        "content": "SELECT name,SUM(amount) as balance FROM Users u LEFT JOIN Transactions t ON u.account = t.account\\nGROUP BY t.account\\nHAVING SUM(amount) > 10000"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select u.name,a.balance\\nfrom users u,\\n(select account,sum(Amount) as \\'balance\\'\\nfrom Transactions\\ngroup by account) a\\nwhere u.account=a.account\\nand a.balance>10000;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select name , sum(t.amount) as balance\\nfrom users as u\\nleft JOIN Transactions as t\\non u.account = t.account\\ngroup by u.account having sum(t.amount) > 10000;"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "SOLUTION with EXPLANATION :\\n\\nFirst we have to find the total sum of every account, so for that SUM(transaction.amount) using join on condition that account should be same so, users.account = transaction.account after that we have to print only accounts with more than 10000\\nso grouping users.account having clause condition ( balance i.e SUM(transaction.amount) > 10000 ) .\\n\\nSelect u.name, SUM(t.amount) AS balance \\nFrom Users u LEFT JOIN Transactions t\\nON u.account = t.account\\nGroup by u.account having balance > 10000;\\n\\n"
                    }
                ]
            },
            {
                "id": 1800722,
                "content": [
                    {
                        "username": "clashkingjeet",
                        "content": "**<-----Upvote Here**\\n\\nSolution-\\n\\n\\tSELECT u.name, SUM(amount) as balance\\n\\tFROM Transactions t\\n\\tLEFT JOIN Users u ON u.account=t.account GROUP BY t.account\\n\\tHAVING SUM(amount)>10000\\n\\t\\n![image](https://assets.leetcode.com/users/images/0640b163-3097-4163-91d9-f9ab751efdc9_1654957305.362194.png)\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "how would i do it if i were to use window function with sum"
                    },
                    {
                        "username": "HimanshuBhoir",
                        "content": "\\t# Write your MySQL query statement below\\n\\tselect Users.name, sum(Transactions.amount) as balance \\n\\tfrom Transactions\\n\\tleft join Users\\n\\ton Transactions.account = users.account\\n\\tgroup by Transactions.account\\n\\tHaving sum(Transactions.amount) > 10000;"
                    },
                    {
                        "username": "sindhujaC77",
                        "content": "------- simple way ---------\\n\\nselect name, sum(amount) as balance\\nfrom users u, transactions t\\nwhere u.account=t.account\\ngroup by u.account\\nhaving sum(amount)>10000\\n"
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select Users.name as NAME,sum(amount) as BALANCE \\nfrom\\n Users\\n left join \\n Transactions on Users.account = Transactions.account\\n group by Transactions.account\\n having sum(amount)>10000;"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Coming from postgres, mysql uses HAVING MORE\\n\\nhttps://devdocs.io/postgresql~15/sql-select#SQL-HAVING\\n\\n> HAVING eliminates group rows that do not satisfy the condition. HAVING is different from WHERE: WHERE filters individual rows before the application of GROUP BY, while HAVING filters group rows created by GROUP BY. Each column referenced in condition must unambiguously reference a grouping column, unless the reference appears within an aggregate function or the ungrouped column is functionally dependent on the grouping columns."
                    },
                    {
                        "username": "Ravi_Tomar",
                        "content": "----\\nSELECT U.NAME, SUM(T.AMOUNT) AS BALANCE FROM USERS U INNER JOIN TRANSACTIONS T\\nON U.ACCOUNT=T.ACCOUNT \\nGROUP BY U.ACCOUNT\\nHAVING SUM(T.AMOUNT) > 10000"
                    },
                    {
                        "username": "Zain_ul_rab",
                        "content": "SELECT name,SUM(amount) as balance FROM Users u LEFT JOIN Transactions t ON u.account = t.account\\nGROUP BY t.account\\nHAVING SUM(amount) > 10000"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select u.name,a.balance\\nfrom users u,\\n(select account,sum(Amount) as \\'balance\\'\\nfrom Transactions\\ngroup by account) a\\nwhere u.account=a.account\\nand a.balance>10000;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select name , sum(t.amount) as balance\\nfrom users as u\\nleft JOIN Transactions as t\\non u.account = t.account\\ngroup by u.account having sum(t.amount) > 10000;"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "SOLUTION with EXPLANATION :\\n\\nFirst we have to find the total sum of every account, so for that SUM(transaction.amount) using join on condition that account should be same so, users.account = transaction.account after that we have to print only accounts with more than 10000\\nso grouping users.account having clause condition ( balance i.e SUM(transaction.amount) > 10000 ) .\\n\\nSelect u.name, SUM(t.amount) AS balance \\nFrom Users u LEFT JOIN Transactions t\\nON u.account = t.account\\nGroup by u.account having balance > 10000;\\n\\n"
                    }
                ]
            },
            {
                "id": 1795888,
                "content": [
                    {
                        "username": "clashkingjeet",
                        "content": "**<-----Upvote Here**\\n\\nSolution-\\n\\n\\tSELECT u.name, SUM(amount) as balance\\n\\tFROM Transactions t\\n\\tLEFT JOIN Users u ON u.account=t.account GROUP BY t.account\\n\\tHAVING SUM(amount)>10000\\n\\t\\n![image](https://assets.leetcode.com/users/images/0640b163-3097-4163-91d9-f9ab751efdc9_1654957305.362194.png)\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "how would i do it if i were to use window function with sum"
                    },
                    {
                        "username": "HimanshuBhoir",
                        "content": "\\t# Write your MySQL query statement below\\n\\tselect Users.name, sum(Transactions.amount) as balance \\n\\tfrom Transactions\\n\\tleft join Users\\n\\ton Transactions.account = users.account\\n\\tgroup by Transactions.account\\n\\tHaving sum(Transactions.amount) > 10000;"
                    },
                    {
                        "username": "sindhujaC77",
                        "content": "------- simple way ---------\\n\\nselect name, sum(amount) as balance\\nfrom users u, transactions t\\nwhere u.account=t.account\\ngroup by u.account\\nhaving sum(amount)>10000\\n"
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select Users.name as NAME,sum(amount) as BALANCE \\nfrom\\n Users\\n left join \\n Transactions on Users.account = Transactions.account\\n group by Transactions.account\\n having sum(amount)>10000;"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Coming from postgres, mysql uses HAVING MORE\\n\\nhttps://devdocs.io/postgresql~15/sql-select#SQL-HAVING\\n\\n> HAVING eliminates group rows that do not satisfy the condition. HAVING is different from WHERE: WHERE filters individual rows before the application of GROUP BY, while HAVING filters group rows created by GROUP BY. Each column referenced in condition must unambiguously reference a grouping column, unless the reference appears within an aggregate function or the ungrouped column is functionally dependent on the grouping columns."
                    },
                    {
                        "username": "Ravi_Tomar",
                        "content": "----\\nSELECT U.NAME, SUM(T.AMOUNT) AS BALANCE FROM USERS U INNER JOIN TRANSACTIONS T\\nON U.ACCOUNT=T.ACCOUNT \\nGROUP BY U.ACCOUNT\\nHAVING SUM(T.AMOUNT) > 10000"
                    },
                    {
                        "username": "Zain_ul_rab",
                        "content": "SELECT name,SUM(amount) as balance FROM Users u LEFT JOIN Transactions t ON u.account = t.account\\nGROUP BY t.account\\nHAVING SUM(amount) > 10000"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select u.name,a.balance\\nfrom users u,\\n(select account,sum(Amount) as \\'balance\\'\\nfrom Transactions\\ngroup by account) a\\nwhere u.account=a.account\\nand a.balance>10000;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select name , sum(t.amount) as balance\\nfrom users as u\\nleft JOIN Transactions as t\\non u.account = t.account\\ngroup by u.account having sum(t.amount) > 10000;"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "SOLUTION with EXPLANATION :\\n\\nFirst we have to find the total sum of every account, so for that SUM(transaction.amount) using join on condition that account should be same so, users.account = transaction.account after that we have to print only accounts with more than 10000\\nso grouping users.account having clause condition ( balance i.e SUM(transaction.amount) > 10000 ) .\\n\\nSelect u.name, SUM(t.amount) AS balance \\nFrom Users u LEFT JOIN Transactions t\\nON u.account = t.account\\nGroup by u.account having balance > 10000;\\n\\n"
                    }
                ]
            },
            {
                "id": 1792271,
                "content": [
                    {
                        "username": "clashkingjeet",
                        "content": "**<-----Upvote Here**\\n\\nSolution-\\n\\n\\tSELECT u.name, SUM(amount) as balance\\n\\tFROM Transactions t\\n\\tLEFT JOIN Users u ON u.account=t.account GROUP BY t.account\\n\\tHAVING SUM(amount)>10000\\n\\t\\n![image](https://assets.leetcode.com/users/images/0640b163-3097-4163-91d9-f9ab751efdc9_1654957305.362194.png)\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "how would i do it if i were to use window function with sum"
                    },
                    {
                        "username": "HimanshuBhoir",
                        "content": "\\t# Write your MySQL query statement below\\n\\tselect Users.name, sum(Transactions.amount) as balance \\n\\tfrom Transactions\\n\\tleft join Users\\n\\ton Transactions.account = users.account\\n\\tgroup by Transactions.account\\n\\tHaving sum(Transactions.amount) > 10000;"
                    },
                    {
                        "username": "sindhujaC77",
                        "content": "------- simple way ---------\\n\\nselect name, sum(amount) as balance\\nfrom users u, transactions t\\nwhere u.account=t.account\\ngroup by u.account\\nhaving sum(amount)>10000\\n"
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select Users.name as NAME,sum(amount) as BALANCE \\nfrom\\n Users\\n left join \\n Transactions on Users.account = Transactions.account\\n group by Transactions.account\\n having sum(amount)>10000;"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Coming from postgres, mysql uses HAVING MORE\\n\\nhttps://devdocs.io/postgresql~15/sql-select#SQL-HAVING\\n\\n> HAVING eliminates group rows that do not satisfy the condition. HAVING is different from WHERE: WHERE filters individual rows before the application of GROUP BY, while HAVING filters group rows created by GROUP BY. Each column referenced in condition must unambiguously reference a grouping column, unless the reference appears within an aggregate function or the ungrouped column is functionally dependent on the grouping columns."
                    },
                    {
                        "username": "Ravi_Tomar",
                        "content": "----\\nSELECT U.NAME, SUM(T.AMOUNT) AS BALANCE FROM USERS U INNER JOIN TRANSACTIONS T\\nON U.ACCOUNT=T.ACCOUNT \\nGROUP BY U.ACCOUNT\\nHAVING SUM(T.AMOUNT) > 10000"
                    },
                    {
                        "username": "Zain_ul_rab",
                        "content": "SELECT name,SUM(amount) as balance FROM Users u LEFT JOIN Transactions t ON u.account = t.account\\nGROUP BY t.account\\nHAVING SUM(amount) > 10000"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select u.name,a.balance\\nfrom users u,\\n(select account,sum(Amount) as \\'balance\\'\\nfrom Transactions\\ngroup by account) a\\nwhere u.account=a.account\\nand a.balance>10000;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select name , sum(t.amount) as balance\\nfrom users as u\\nleft JOIN Transactions as t\\non u.account = t.account\\ngroup by u.account having sum(t.amount) > 10000;"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "SOLUTION with EXPLANATION :\\n\\nFirst we have to find the total sum of every account, so for that SUM(transaction.amount) using join on condition that account should be same so, users.account = transaction.account after that we have to print only accounts with more than 10000\\nso grouping users.account having clause condition ( balance i.e SUM(transaction.amount) > 10000 ) .\\n\\nSelect u.name, SUM(t.amount) AS balance \\nFrom Users u LEFT JOIN Transactions t\\nON u.account = t.account\\nGroup by u.account having balance > 10000;\\n\\n"
                    }
                ]
            },
            {
                "id": 1777375,
                "content": [
                    {
                        "username": "clashkingjeet",
                        "content": "**<-----Upvote Here**\\n\\nSolution-\\n\\n\\tSELECT u.name, SUM(amount) as balance\\n\\tFROM Transactions t\\n\\tLEFT JOIN Users u ON u.account=t.account GROUP BY t.account\\n\\tHAVING SUM(amount)>10000\\n\\t\\n![image](https://assets.leetcode.com/users/images/0640b163-3097-4163-91d9-f9ab751efdc9_1654957305.362194.png)\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "how would i do it if i were to use window function with sum"
                    },
                    {
                        "username": "HimanshuBhoir",
                        "content": "\\t# Write your MySQL query statement below\\n\\tselect Users.name, sum(Transactions.amount) as balance \\n\\tfrom Transactions\\n\\tleft join Users\\n\\ton Transactions.account = users.account\\n\\tgroup by Transactions.account\\n\\tHaving sum(Transactions.amount) > 10000;"
                    },
                    {
                        "username": "sindhujaC77",
                        "content": "------- simple way ---------\\n\\nselect name, sum(amount) as balance\\nfrom users u, transactions t\\nwhere u.account=t.account\\ngroup by u.account\\nhaving sum(amount)>10000\\n"
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select Users.name as NAME,sum(amount) as BALANCE \\nfrom\\n Users\\n left join \\n Transactions on Users.account = Transactions.account\\n group by Transactions.account\\n having sum(amount)>10000;"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Coming from postgres, mysql uses HAVING MORE\\n\\nhttps://devdocs.io/postgresql~15/sql-select#SQL-HAVING\\n\\n> HAVING eliminates group rows that do not satisfy the condition. HAVING is different from WHERE: WHERE filters individual rows before the application of GROUP BY, while HAVING filters group rows created by GROUP BY. Each column referenced in condition must unambiguously reference a grouping column, unless the reference appears within an aggregate function or the ungrouped column is functionally dependent on the grouping columns."
                    },
                    {
                        "username": "Ravi_Tomar",
                        "content": "----\\nSELECT U.NAME, SUM(T.AMOUNT) AS BALANCE FROM USERS U INNER JOIN TRANSACTIONS T\\nON U.ACCOUNT=T.ACCOUNT \\nGROUP BY U.ACCOUNT\\nHAVING SUM(T.AMOUNT) > 10000"
                    },
                    {
                        "username": "Zain_ul_rab",
                        "content": "SELECT name,SUM(amount) as balance FROM Users u LEFT JOIN Transactions t ON u.account = t.account\\nGROUP BY t.account\\nHAVING SUM(amount) > 10000"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select u.name,a.balance\\nfrom users u,\\n(select account,sum(Amount) as \\'balance\\'\\nfrom Transactions\\ngroup by account) a\\nwhere u.account=a.account\\nand a.balance>10000;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select name , sum(t.amount) as balance\\nfrom users as u\\nleft JOIN Transactions as t\\non u.account = t.account\\ngroup by u.account having sum(t.amount) > 10000;"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "SOLUTION with EXPLANATION :\\n\\nFirst we have to find the total sum of every account, so for that SUM(transaction.amount) using join on condition that account should be same so, users.account = transaction.account after that we have to print only accounts with more than 10000\\nso grouping users.account having clause condition ( balance i.e SUM(transaction.amount) > 10000 ) .\\n\\nSelect u.name, SUM(t.amount) AS balance \\nFrom Users u LEFT JOIN Transactions t\\nON u.account = t.account\\nGroup by u.account having balance > 10000;\\n\\n"
                    }
                ]
            },
            {
                "id": 1576883,
                "content": [
                    {
                        "username": "clashkingjeet",
                        "content": "**<-----Upvote Here**\\n\\nSolution-\\n\\n\\tSELECT u.name, SUM(amount) as balance\\n\\tFROM Transactions t\\n\\tLEFT JOIN Users u ON u.account=t.account GROUP BY t.account\\n\\tHAVING SUM(amount)>10000\\n\\t\\n![image](https://assets.leetcode.com/users/images/0640b163-3097-4163-91d9-f9ab751efdc9_1654957305.362194.png)\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "how would i do it if i were to use window function with sum"
                    },
                    {
                        "username": "HimanshuBhoir",
                        "content": "\\t# Write your MySQL query statement below\\n\\tselect Users.name, sum(Transactions.amount) as balance \\n\\tfrom Transactions\\n\\tleft join Users\\n\\ton Transactions.account = users.account\\n\\tgroup by Transactions.account\\n\\tHaving sum(Transactions.amount) > 10000;"
                    },
                    {
                        "username": "sindhujaC77",
                        "content": "------- simple way ---------\\n\\nselect name, sum(amount) as balance\\nfrom users u, transactions t\\nwhere u.account=t.account\\ngroup by u.account\\nhaving sum(amount)>10000\\n"
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select Users.name as NAME,sum(amount) as BALANCE \\nfrom\\n Users\\n left join \\n Transactions on Users.account = Transactions.account\\n group by Transactions.account\\n having sum(amount)>10000;"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Coming from postgres, mysql uses HAVING MORE\\n\\nhttps://devdocs.io/postgresql~15/sql-select#SQL-HAVING\\n\\n> HAVING eliminates group rows that do not satisfy the condition. HAVING is different from WHERE: WHERE filters individual rows before the application of GROUP BY, while HAVING filters group rows created by GROUP BY. Each column referenced in condition must unambiguously reference a grouping column, unless the reference appears within an aggregate function or the ungrouped column is functionally dependent on the grouping columns."
                    },
                    {
                        "username": "Ravi_Tomar",
                        "content": "----\\nSELECT U.NAME, SUM(T.AMOUNT) AS BALANCE FROM USERS U INNER JOIN TRANSACTIONS T\\nON U.ACCOUNT=T.ACCOUNT \\nGROUP BY U.ACCOUNT\\nHAVING SUM(T.AMOUNT) > 10000"
                    },
                    {
                        "username": "Zain_ul_rab",
                        "content": "SELECT name,SUM(amount) as balance FROM Users u LEFT JOIN Transactions t ON u.account = t.account\\nGROUP BY t.account\\nHAVING SUM(amount) > 10000"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select u.name,a.balance\\nfrom users u,\\n(select account,sum(Amount) as \\'balance\\'\\nfrom Transactions\\ngroup by account) a\\nwhere u.account=a.account\\nand a.balance>10000;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select name , sum(t.amount) as balance\\nfrom users as u\\nleft JOIN Transactions as t\\non u.account = t.account\\ngroup by u.account having sum(t.amount) > 10000;"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "SOLUTION with EXPLANATION :\\n\\nFirst we have to find the total sum of every account, so for that SUM(transaction.amount) using join on condition that account should be same so, users.account = transaction.account after that we have to print only accounts with more than 10000\\nso grouping users.account having clause condition ( balance i.e SUM(transaction.amount) > 10000 ) .\\n\\nSelect u.name, SUM(t.amount) AS balance \\nFrom Users u LEFT JOIN Transactions t\\nON u.account = t.account\\nGroup by u.account having balance > 10000;\\n\\n"
                    }
                ]
            },
            {
                "id": 1576562,
                "content": [
                    {
                        "username": "clashkingjeet",
                        "content": "**<-----Upvote Here**\\n\\nSolution-\\n\\n\\tSELECT u.name, SUM(amount) as balance\\n\\tFROM Transactions t\\n\\tLEFT JOIN Users u ON u.account=t.account GROUP BY t.account\\n\\tHAVING SUM(amount)>10000\\n\\t\\n![image](https://assets.leetcode.com/users/images/0640b163-3097-4163-91d9-f9ab751efdc9_1654957305.362194.png)\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "how would i do it if i were to use window function with sum"
                    },
                    {
                        "username": "HimanshuBhoir",
                        "content": "\\t# Write your MySQL query statement below\\n\\tselect Users.name, sum(Transactions.amount) as balance \\n\\tfrom Transactions\\n\\tleft join Users\\n\\ton Transactions.account = users.account\\n\\tgroup by Transactions.account\\n\\tHaving sum(Transactions.amount) > 10000;"
                    },
                    {
                        "username": "sindhujaC77",
                        "content": "------- simple way ---------\\n\\nselect name, sum(amount) as balance\\nfrom users u, transactions t\\nwhere u.account=t.account\\ngroup by u.account\\nhaving sum(amount)>10000\\n"
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select Users.name as NAME,sum(amount) as BALANCE \\nfrom\\n Users\\n left join \\n Transactions on Users.account = Transactions.account\\n group by Transactions.account\\n having sum(amount)>10000;"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Coming from postgres, mysql uses HAVING MORE\\n\\nhttps://devdocs.io/postgresql~15/sql-select#SQL-HAVING\\n\\n> HAVING eliminates group rows that do not satisfy the condition. HAVING is different from WHERE: WHERE filters individual rows before the application of GROUP BY, while HAVING filters group rows created by GROUP BY. Each column referenced in condition must unambiguously reference a grouping column, unless the reference appears within an aggregate function or the ungrouped column is functionally dependent on the grouping columns."
                    },
                    {
                        "username": "Ravi_Tomar",
                        "content": "----\\nSELECT U.NAME, SUM(T.AMOUNT) AS BALANCE FROM USERS U INNER JOIN TRANSACTIONS T\\nON U.ACCOUNT=T.ACCOUNT \\nGROUP BY U.ACCOUNT\\nHAVING SUM(T.AMOUNT) > 10000"
                    },
                    {
                        "username": "Zain_ul_rab",
                        "content": "SELECT name,SUM(amount) as balance FROM Users u LEFT JOIN Transactions t ON u.account = t.account\\nGROUP BY t.account\\nHAVING SUM(amount) > 10000"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select u.name,a.balance\\nfrom users u,\\n(select account,sum(Amount) as \\'balance\\'\\nfrom Transactions\\ngroup by account) a\\nwhere u.account=a.account\\nand a.balance>10000;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select name , sum(t.amount) as balance\\nfrom users as u\\nleft JOIN Transactions as t\\non u.account = t.account\\ngroup by u.account having sum(t.amount) > 10000;"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "SOLUTION with EXPLANATION :\\n\\nFirst we have to find the total sum of every account, so for that SUM(transaction.amount) using join on condition that account should be same so, users.account = transaction.account after that we have to print only accounts with more than 10000\\nso grouping users.account having clause condition ( balance i.e SUM(transaction.amount) > 10000 ) .\\n\\nSelect u.name, SUM(t.amount) AS balance \\nFrom Users u LEFT JOIN Transactions t\\nON u.account = t.account\\nGroup by u.account having balance > 10000;\\n\\n"
                    }
                ]
            },
            {
                "id": 1930173,
                "content": [
                    {
                        "username": "clashkingjeet",
                        "content": "**<-----Upvote Here**\\n\\nSolution-\\n\\n\\tSELECT u.name, SUM(amount) as balance\\n\\tFROM Transactions t\\n\\tLEFT JOIN Users u ON u.account=t.account GROUP BY t.account\\n\\tHAVING SUM(amount)>10000\\n\\t\\n![image](https://assets.leetcode.com/users/images/0640b163-3097-4163-91d9-f9ab751efdc9_1654957305.362194.png)\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "how would i do it if i were to use window function with sum"
                    },
                    {
                        "username": "HimanshuBhoir",
                        "content": "\\t# Write your MySQL query statement below\\n\\tselect Users.name, sum(Transactions.amount) as balance \\n\\tfrom Transactions\\n\\tleft join Users\\n\\ton Transactions.account = users.account\\n\\tgroup by Transactions.account\\n\\tHaving sum(Transactions.amount) > 10000;"
                    },
                    {
                        "username": "sindhujaC77",
                        "content": "------- simple way ---------\\n\\nselect name, sum(amount) as balance\\nfrom users u, transactions t\\nwhere u.account=t.account\\ngroup by u.account\\nhaving sum(amount)>10000\\n"
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select Users.name as NAME,sum(amount) as BALANCE \\nfrom\\n Users\\n left join \\n Transactions on Users.account = Transactions.account\\n group by Transactions.account\\n having sum(amount)>10000;"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Coming from postgres, mysql uses HAVING MORE\\n\\nhttps://devdocs.io/postgresql~15/sql-select#SQL-HAVING\\n\\n> HAVING eliminates group rows that do not satisfy the condition. HAVING is different from WHERE: WHERE filters individual rows before the application of GROUP BY, while HAVING filters group rows created by GROUP BY. Each column referenced in condition must unambiguously reference a grouping column, unless the reference appears within an aggregate function or the ungrouped column is functionally dependent on the grouping columns."
                    },
                    {
                        "username": "Ravi_Tomar",
                        "content": "----\\nSELECT U.NAME, SUM(T.AMOUNT) AS BALANCE FROM USERS U INNER JOIN TRANSACTIONS T\\nON U.ACCOUNT=T.ACCOUNT \\nGROUP BY U.ACCOUNT\\nHAVING SUM(T.AMOUNT) > 10000"
                    },
                    {
                        "username": "Zain_ul_rab",
                        "content": "SELECT name,SUM(amount) as balance FROM Users u LEFT JOIN Transactions t ON u.account = t.account\\nGROUP BY t.account\\nHAVING SUM(amount) > 10000"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select u.name,a.balance\\nfrom users u,\\n(select account,sum(Amount) as \\'balance\\'\\nfrom Transactions\\ngroup by account) a\\nwhere u.account=a.account\\nand a.balance>10000;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select name , sum(t.amount) as balance\\nfrom users as u\\nleft JOIN Transactions as t\\non u.account = t.account\\ngroup by u.account having sum(t.amount) > 10000;"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "SOLUTION with EXPLANATION :\\n\\nFirst we have to find the total sum of every account, so for that SUM(transaction.amount) using join on condition that account should be same so, users.account = transaction.account after that we have to print only accounts with more than 10000\\nso grouping users.account having clause condition ( balance i.e SUM(transaction.amount) > 10000 ) .\\n\\nSelect u.name, SUM(t.amount) AS balance \\nFrom Users u LEFT JOIN Transactions t\\nON u.account = t.account\\nGroup by u.account having balance > 10000;\\n\\n"
                    }
                ]
            },
            {
                "id": 1851303,
                "content": [
                    {
                        "username": "clashkingjeet",
                        "content": "**<-----Upvote Here**\\n\\nSolution-\\n\\n\\tSELECT u.name, SUM(amount) as balance\\n\\tFROM Transactions t\\n\\tLEFT JOIN Users u ON u.account=t.account GROUP BY t.account\\n\\tHAVING SUM(amount)>10000\\n\\t\\n![image](https://assets.leetcode.com/users/images/0640b163-3097-4163-91d9-f9ab751efdc9_1654957305.362194.png)\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "how would i do it if i were to use window function with sum"
                    },
                    {
                        "username": "HimanshuBhoir",
                        "content": "\\t# Write your MySQL query statement below\\n\\tselect Users.name, sum(Transactions.amount) as balance \\n\\tfrom Transactions\\n\\tleft join Users\\n\\ton Transactions.account = users.account\\n\\tgroup by Transactions.account\\n\\tHaving sum(Transactions.amount) > 10000;"
                    },
                    {
                        "username": "sindhujaC77",
                        "content": "------- simple way ---------\\n\\nselect name, sum(amount) as balance\\nfrom users u, transactions t\\nwhere u.account=t.account\\ngroup by u.account\\nhaving sum(amount)>10000\\n"
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select Users.name as NAME,sum(amount) as BALANCE \\nfrom\\n Users\\n left join \\n Transactions on Users.account = Transactions.account\\n group by Transactions.account\\n having sum(amount)>10000;"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Coming from postgres, mysql uses HAVING MORE\\n\\nhttps://devdocs.io/postgresql~15/sql-select#SQL-HAVING\\n\\n> HAVING eliminates group rows that do not satisfy the condition. HAVING is different from WHERE: WHERE filters individual rows before the application of GROUP BY, while HAVING filters group rows created by GROUP BY. Each column referenced in condition must unambiguously reference a grouping column, unless the reference appears within an aggregate function or the ungrouped column is functionally dependent on the grouping columns."
                    },
                    {
                        "username": "Ravi_Tomar",
                        "content": "----\\nSELECT U.NAME, SUM(T.AMOUNT) AS BALANCE FROM USERS U INNER JOIN TRANSACTIONS T\\nON U.ACCOUNT=T.ACCOUNT \\nGROUP BY U.ACCOUNT\\nHAVING SUM(T.AMOUNT) > 10000"
                    },
                    {
                        "username": "Zain_ul_rab",
                        "content": "SELECT name,SUM(amount) as balance FROM Users u LEFT JOIN Transactions t ON u.account = t.account\\nGROUP BY t.account\\nHAVING SUM(amount) > 10000"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select u.name,a.balance\\nfrom users u,\\n(select account,sum(Amount) as \\'balance\\'\\nfrom Transactions\\ngroup by account) a\\nwhere u.account=a.account\\nand a.balance>10000;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select name , sum(t.amount) as balance\\nfrom users as u\\nleft JOIN Transactions as t\\non u.account = t.account\\ngroup by u.account having sum(t.amount) > 10000;"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "SOLUTION with EXPLANATION :\\n\\nFirst we have to find the total sum of every account, so for that SUM(transaction.amount) using join on condition that account should be same so, users.account = transaction.account after that we have to print only accounts with more than 10000\\nso grouping users.account having clause condition ( balance i.e SUM(transaction.amount) > 10000 ) .\\n\\nSelect u.name, SUM(t.amount) AS balance \\nFrom Users u LEFT JOIN Transactions t\\nON u.account = t.account\\nGroup by u.account having balance > 10000;\\n\\n"
                    }
                ]
            },
            {
                "id": 1832741,
                "content": [
                    {
                        "username": "clashkingjeet",
                        "content": "**<-----Upvote Here**\\n\\nSolution-\\n\\n\\tSELECT u.name, SUM(amount) as balance\\n\\tFROM Transactions t\\n\\tLEFT JOIN Users u ON u.account=t.account GROUP BY t.account\\n\\tHAVING SUM(amount)>10000\\n\\t\\n![image](https://assets.leetcode.com/users/images/0640b163-3097-4163-91d9-f9ab751efdc9_1654957305.362194.png)\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "how would i do it if i were to use window function with sum"
                    },
                    {
                        "username": "HimanshuBhoir",
                        "content": "\\t# Write your MySQL query statement below\\n\\tselect Users.name, sum(Transactions.amount) as balance \\n\\tfrom Transactions\\n\\tleft join Users\\n\\ton Transactions.account = users.account\\n\\tgroup by Transactions.account\\n\\tHaving sum(Transactions.amount) > 10000;"
                    },
                    {
                        "username": "sindhujaC77",
                        "content": "------- simple way ---------\\n\\nselect name, sum(amount) as balance\\nfrom users u, transactions t\\nwhere u.account=t.account\\ngroup by u.account\\nhaving sum(amount)>10000\\n"
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select Users.name as NAME,sum(amount) as BALANCE \\nfrom\\n Users\\n left join \\n Transactions on Users.account = Transactions.account\\n group by Transactions.account\\n having sum(amount)>10000;"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Coming from postgres, mysql uses HAVING MORE\\n\\nhttps://devdocs.io/postgresql~15/sql-select#SQL-HAVING\\n\\n> HAVING eliminates group rows that do not satisfy the condition. HAVING is different from WHERE: WHERE filters individual rows before the application of GROUP BY, while HAVING filters group rows created by GROUP BY. Each column referenced in condition must unambiguously reference a grouping column, unless the reference appears within an aggregate function or the ungrouped column is functionally dependent on the grouping columns."
                    },
                    {
                        "username": "Ravi_Tomar",
                        "content": "----\\nSELECT U.NAME, SUM(T.AMOUNT) AS BALANCE FROM USERS U INNER JOIN TRANSACTIONS T\\nON U.ACCOUNT=T.ACCOUNT \\nGROUP BY U.ACCOUNT\\nHAVING SUM(T.AMOUNT) > 10000"
                    },
                    {
                        "username": "Zain_ul_rab",
                        "content": "SELECT name,SUM(amount) as balance FROM Users u LEFT JOIN Transactions t ON u.account = t.account\\nGROUP BY t.account\\nHAVING SUM(amount) > 10000"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select u.name,a.balance\\nfrom users u,\\n(select account,sum(Amount) as \\'balance\\'\\nfrom Transactions\\ngroup by account) a\\nwhere u.account=a.account\\nand a.balance>10000;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select name , sum(t.amount) as balance\\nfrom users as u\\nleft JOIN Transactions as t\\non u.account = t.account\\ngroup by u.account having sum(t.amount) > 10000;"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "SOLUTION with EXPLANATION :\\n\\nFirst we have to find the total sum of every account, so for that SUM(transaction.amount) using join on condition that account should be same so, users.account = transaction.account after that we have to print only accounts with more than 10000\\nso grouping users.account having clause condition ( balance i.e SUM(transaction.amount) > 10000 ) .\\n\\nSelect u.name, SUM(t.amount) AS balance \\nFrom Users u LEFT JOIN Transactions t\\nON u.account = t.account\\nGroup by u.account having balance > 10000;\\n\\n"
                    }
                ]
            },
            {
                "id": 1811608,
                "content": [
                    {
                        "username": "clashkingjeet",
                        "content": "**<-----Upvote Here**\\n\\nSolution-\\n\\n\\tSELECT u.name, SUM(amount) as balance\\n\\tFROM Transactions t\\n\\tLEFT JOIN Users u ON u.account=t.account GROUP BY t.account\\n\\tHAVING SUM(amount)>10000\\n\\t\\n![image](https://assets.leetcode.com/users/images/0640b163-3097-4163-91d9-f9ab751efdc9_1654957305.362194.png)\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "how would i do it if i were to use window function with sum"
                    },
                    {
                        "username": "HimanshuBhoir",
                        "content": "\\t# Write your MySQL query statement below\\n\\tselect Users.name, sum(Transactions.amount) as balance \\n\\tfrom Transactions\\n\\tleft join Users\\n\\ton Transactions.account = users.account\\n\\tgroup by Transactions.account\\n\\tHaving sum(Transactions.amount) > 10000;"
                    },
                    {
                        "username": "sindhujaC77",
                        "content": "------- simple way ---------\\n\\nselect name, sum(amount) as balance\\nfrom users u, transactions t\\nwhere u.account=t.account\\ngroup by u.account\\nhaving sum(amount)>10000\\n"
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select Users.name as NAME,sum(amount) as BALANCE \\nfrom\\n Users\\n left join \\n Transactions on Users.account = Transactions.account\\n group by Transactions.account\\n having sum(amount)>10000;"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Coming from postgres, mysql uses HAVING MORE\\n\\nhttps://devdocs.io/postgresql~15/sql-select#SQL-HAVING\\n\\n> HAVING eliminates group rows that do not satisfy the condition. HAVING is different from WHERE: WHERE filters individual rows before the application of GROUP BY, while HAVING filters group rows created by GROUP BY. Each column referenced in condition must unambiguously reference a grouping column, unless the reference appears within an aggregate function or the ungrouped column is functionally dependent on the grouping columns."
                    },
                    {
                        "username": "Ravi_Tomar",
                        "content": "----\\nSELECT U.NAME, SUM(T.AMOUNT) AS BALANCE FROM USERS U INNER JOIN TRANSACTIONS T\\nON U.ACCOUNT=T.ACCOUNT \\nGROUP BY U.ACCOUNT\\nHAVING SUM(T.AMOUNT) > 10000"
                    },
                    {
                        "username": "Zain_ul_rab",
                        "content": "SELECT name,SUM(amount) as balance FROM Users u LEFT JOIN Transactions t ON u.account = t.account\\nGROUP BY t.account\\nHAVING SUM(amount) > 10000"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select u.name,a.balance\\nfrom users u,\\n(select account,sum(Amount) as \\'balance\\'\\nfrom Transactions\\ngroup by account) a\\nwhere u.account=a.account\\nand a.balance>10000;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select name , sum(t.amount) as balance\\nfrom users as u\\nleft JOIN Transactions as t\\non u.account = t.account\\ngroup by u.account having sum(t.amount) > 10000;"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "SOLUTION with EXPLANATION :\\n\\nFirst we have to find the total sum of every account, so for that SUM(transaction.amount) using join on condition that account should be same so, users.account = transaction.account after that we have to print only accounts with more than 10000\\nso grouping users.account having clause condition ( balance i.e SUM(transaction.amount) > 10000 ) .\\n\\nSelect u.name, SUM(t.amount) AS balance \\nFrom Users u LEFT JOIN Transactions t\\nON u.account = t.account\\nGroup by u.account having balance > 10000;\\n\\n"
                    }
                ]
            },
            {
                "id": 1800722,
                "content": [
                    {
                        "username": "clashkingjeet",
                        "content": "**<-----Upvote Here**\\n\\nSolution-\\n\\n\\tSELECT u.name, SUM(amount) as balance\\n\\tFROM Transactions t\\n\\tLEFT JOIN Users u ON u.account=t.account GROUP BY t.account\\n\\tHAVING SUM(amount)>10000\\n\\t\\n![image](https://assets.leetcode.com/users/images/0640b163-3097-4163-91d9-f9ab751efdc9_1654957305.362194.png)\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "how would i do it if i were to use window function with sum"
                    },
                    {
                        "username": "HimanshuBhoir",
                        "content": "\\t# Write your MySQL query statement below\\n\\tselect Users.name, sum(Transactions.amount) as balance \\n\\tfrom Transactions\\n\\tleft join Users\\n\\ton Transactions.account = users.account\\n\\tgroup by Transactions.account\\n\\tHaving sum(Transactions.amount) > 10000;"
                    },
                    {
                        "username": "sindhujaC77",
                        "content": "------- simple way ---------\\n\\nselect name, sum(amount) as balance\\nfrom users u, transactions t\\nwhere u.account=t.account\\ngroup by u.account\\nhaving sum(amount)>10000\\n"
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select Users.name as NAME,sum(amount) as BALANCE \\nfrom\\n Users\\n left join \\n Transactions on Users.account = Transactions.account\\n group by Transactions.account\\n having sum(amount)>10000;"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Coming from postgres, mysql uses HAVING MORE\\n\\nhttps://devdocs.io/postgresql~15/sql-select#SQL-HAVING\\n\\n> HAVING eliminates group rows that do not satisfy the condition. HAVING is different from WHERE: WHERE filters individual rows before the application of GROUP BY, while HAVING filters group rows created by GROUP BY. Each column referenced in condition must unambiguously reference a grouping column, unless the reference appears within an aggregate function or the ungrouped column is functionally dependent on the grouping columns."
                    },
                    {
                        "username": "Ravi_Tomar",
                        "content": "----\\nSELECT U.NAME, SUM(T.AMOUNT) AS BALANCE FROM USERS U INNER JOIN TRANSACTIONS T\\nON U.ACCOUNT=T.ACCOUNT \\nGROUP BY U.ACCOUNT\\nHAVING SUM(T.AMOUNT) > 10000"
                    },
                    {
                        "username": "Zain_ul_rab",
                        "content": "SELECT name,SUM(amount) as balance FROM Users u LEFT JOIN Transactions t ON u.account = t.account\\nGROUP BY t.account\\nHAVING SUM(amount) > 10000"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select u.name,a.balance\\nfrom users u,\\n(select account,sum(Amount) as \\'balance\\'\\nfrom Transactions\\ngroup by account) a\\nwhere u.account=a.account\\nand a.balance>10000;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select name , sum(t.amount) as balance\\nfrom users as u\\nleft JOIN Transactions as t\\non u.account = t.account\\ngroup by u.account having sum(t.amount) > 10000;"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "SOLUTION with EXPLANATION :\\n\\nFirst we have to find the total sum of every account, so for that SUM(transaction.amount) using join on condition that account should be same so, users.account = transaction.account after that we have to print only accounts with more than 10000\\nso grouping users.account having clause condition ( balance i.e SUM(transaction.amount) > 10000 ) .\\n\\nSelect u.name, SUM(t.amount) AS balance \\nFrom Users u LEFT JOIN Transactions t\\nON u.account = t.account\\nGroup by u.account having balance > 10000;\\n\\n"
                    }
                ]
            },
            {
                "id": 1795888,
                "content": [
                    {
                        "username": "clashkingjeet",
                        "content": "**<-----Upvote Here**\\n\\nSolution-\\n\\n\\tSELECT u.name, SUM(amount) as balance\\n\\tFROM Transactions t\\n\\tLEFT JOIN Users u ON u.account=t.account GROUP BY t.account\\n\\tHAVING SUM(amount)>10000\\n\\t\\n![image](https://assets.leetcode.com/users/images/0640b163-3097-4163-91d9-f9ab751efdc9_1654957305.362194.png)\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "how would i do it if i were to use window function with sum"
                    },
                    {
                        "username": "HimanshuBhoir",
                        "content": "\\t# Write your MySQL query statement below\\n\\tselect Users.name, sum(Transactions.amount) as balance \\n\\tfrom Transactions\\n\\tleft join Users\\n\\ton Transactions.account = users.account\\n\\tgroup by Transactions.account\\n\\tHaving sum(Transactions.amount) > 10000;"
                    },
                    {
                        "username": "sindhujaC77",
                        "content": "------- simple way ---------\\n\\nselect name, sum(amount) as balance\\nfrom users u, transactions t\\nwhere u.account=t.account\\ngroup by u.account\\nhaving sum(amount)>10000\\n"
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select Users.name as NAME,sum(amount) as BALANCE \\nfrom\\n Users\\n left join \\n Transactions on Users.account = Transactions.account\\n group by Transactions.account\\n having sum(amount)>10000;"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Coming from postgres, mysql uses HAVING MORE\\n\\nhttps://devdocs.io/postgresql~15/sql-select#SQL-HAVING\\n\\n> HAVING eliminates group rows that do not satisfy the condition. HAVING is different from WHERE: WHERE filters individual rows before the application of GROUP BY, while HAVING filters group rows created by GROUP BY. Each column referenced in condition must unambiguously reference a grouping column, unless the reference appears within an aggregate function or the ungrouped column is functionally dependent on the grouping columns."
                    },
                    {
                        "username": "Ravi_Tomar",
                        "content": "----\\nSELECT U.NAME, SUM(T.AMOUNT) AS BALANCE FROM USERS U INNER JOIN TRANSACTIONS T\\nON U.ACCOUNT=T.ACCOUNT \\nGROUP BY U.ACCOUNT\\nHAVING SUM(T.AMOUNT) > 10000"
                    },
                    {
                        "username": "Zain_ul_rab",
                        "content": "SELECT name,SUM(amount) as balance FROM Users u LEFT JOIN Transactions t ON u.account = t.account\\nGROUP BY t.account\\nHAVING SUM(amount) > 10000"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select u.name,a.balance\\nfrom users u,\\n(select account,sum(Amount) as \\'balance\\'\\nfrom Transactions\\ngroup by account) a\\nwhere u.account=a.account\\nand a.balance>10000;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select name , sum(t.amount) as balance\\nfrom users as u\\nleft JOIN Transactions as t\\non u.account = t.account\\ngroup by u.account having sum(t.amount) > 10000;"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "SOLUTION with EXPLANATION :\\n\\nFirst we have to find the total sum of every account, so for that SUM(transaction.amount) using join on condition that account should be same so, users.account = transaction.account after that we have to print only accounts with more than 10000\\nso grouping users.account having clause condition ( balance i.e SUM(transaction.amount) > 10000 ) .\\n\\nSelect u.name, SUM(t.amount) AS balance \\nFrom Users u LEFT JOIN Transactions t\\nON u.account = t.account\\nGroup by u.account having balance > 10000;\\n\\n"
                    }
                ]
            },
            {
                "id": 1792271,
                "content": [
                    {
                        "username": "clashkingjeet",
                        "content": "**<-----Upvote Here**\\n\\nSolution-\\n\\n\\tSELECT u.name, SUM(amount) as balance\\n\\tFROM Transactions t\\n\\tLEFT JOIN Users u ON u.account=t.account GROUP BY t.account\\n\\tHAVING SUM(amount)>10000\\n\\t\\n![image](https://assets.leetcode.com/users/images/0640b163-3097-4163-91d9-f9ab751efdc9_1654957305.362194.png)\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "how would i do it if i were to use window function with sum"
                    },
                    {
                        "username": "HimanshuBhoir",
                        "content": "\\t# Write your MySQL query statement below\\n\\tselect Users.name, sum(Transactions.amount) as balance \\n\\tfrom Transactions\\n\\tleft join Users\\n\\ton Transactions.account = users.account\\n\\tgroup by Transactions.account\\n\\tHaving sum(Transactions.amount) > 10000;"
                    },
                    {
                        "username": "sindhujaC77",
                        "content": "------- simple way ---------\\n\\nselect name, sum(amount) as balance\\nfrom users u, transactions t\\nwhere u.account=t.account\\ngroup by u.account\\nhaving sum(amount)>10000\\n"
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select Users.name as NAME,sum(amount) as BALANCE \\nfrom\\n Users\\n left join \\n Transactions on Users.account = Transactions.account\\n group by Transactions.account\\n having sum(amount)>10000;"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Coming from postgres, mysql uses HAVING MORE\\n\\nhttps://devdocs.io/postgresql~15/sql-select#SQL-HAVING\\n\\n> HAVING eliminates group rows that do not satisfy the condition. HAVING is different from WHERE: WHERE filters individual rows before the application of GROUP BY, while HAVING filters group rows created by GROUP BY. Each column referenced in condition must unambiguously reference a grouping column, unless the reference appears within an aggregate function or the ungrouped column is functionally dependent on the grouping columns."
                    },
                    {
                        "username": "Ravi_Tomar",
                        "content": "----\\nSELECT U.NAME, SUM(T.AMOUNT) AS BALANCE FROM USERS U INNER JOIN TRANSACTIONS T\\nON U.ACCOUNT=T.ACCOUNT \\nGROUP BY U.ACCOUNT\\nHAVING SUM(T.AMOUNT) > 10000"
                    },
                    {
                        "username": "Zain_ul_rab",
                        "content": "SELECT name,SUM(amount) as balance FROM Users u LEFT JOIN Transactions t ON u.account = t.account\\nGROUP BY t.account\\nHAVING SUM(amount) > 10000"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select u.name,a.balance\\nfrom users u,\\n(select account,sum(Amount) as \\'balance\\'\\nfrom Transactions\\ngroup by account) a\\nwhere u.account=a.account\\nand a.balance>10000;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select name , sum(t.amount) as balance\\nfrom users as u\\nleft JOIN Transactions as t\\non u.account = t.account\\ngroup by u.account having sum(t.amount) > 10000;"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "SOLUTION with EXPLANATION :\\n\\nFirst we have to find the total sum of every account, so for that SUM(transaction.amount) using join on condition that account should be same so, users.account = transaction.account after that we have to print only accounts with more than 10000\\nso grouping users.account having clause condition ( balance i.e SUM(transaction.amount) > 10000 ) .\\n\\nSelect u.name, SUM(t.amount) AS balance \\nFrom Users u LEFT JOIN Transactions t\\nON u.account = t.account\\nGroup by u.account having balance > 10000;\\n\\n"
                    }
                ]
            },
            {
                "id": 1777375,
                "content": [
                    {
                        "username": "clashkingjeet",
                        "content": "**<-----Upvote Here**\\n\\nSolution-\\n\\n\\tSELECT u.name, SUM(amount) as balance\\n\\tFROM Transactions t\\n\\tLEFT JOIN Users u ON u.account=t.account GROUP BY t.account\\n\\tHAVING SUM(amount)>10000\\n\\t\\n![image](https://assets.leetcode.com/users/images/0640b163-3097-4163-91d9-f9ab751efdc9_1654957305.362194.png)\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "how would i do it if i were to use window function with sum"
                    },
                    {
                        "username": "HimanshuBhoir",
                        "content": "\\t# Write your MySQL query statement below\\n\\tselect Users.name, sum(Transactions.amount) as balance \\n\\tfrom Transactions\\n\\tleft join Users\\n\\ton Transactions.account = users.account\\n\\tgroup by Transactions.account\\n\\tHaving sum(Transactions.amount) > 10000;"
                    },
                    {
                        "username": "sindhujaC77",
                        "content": "------- simple way ---------\\n\\nselect name, sum(amount) as balance\\nfrom users u, transactions t\\nwhere u.account=t.account\\ngroup by u.account\\nhaving sum(amount)>10000\\n"
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select Users.name as NAME,sum(amount) as BALANCE \\nfrom\\n Users\\n left join \\n Transactions on Users.account = Transactions.account\\n group by Transactions.account\\n having sum(amount)>10000;"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Coming from postgres, mysql uses HAVING MORE\\n\\nhttps://devdocs.io/postgresql~15/sql-select#SQL-HAVING\\n\\n> HAVING eliminates group rows that do not satisfy the condition. HAVING is different from WHERE: WHERE filters individual rows before the application of GROUP BY, while HAVING filters group rows created by GROUP BY. Each column referenced in condition must unambiguously reference a grouping column, unless the reference appears within an aggregate function or the ungrouped column is functionally dependent on the grouping columns."
                    },
                    {
                        "username": "Ravi_Tomar",
                        "content": "----\\nSELECT U.NAME, SUM(T.AMOUNT) AS BALANCE FROM USERS U INNER JOIN TRANSACTIONS T\\nON U.ACCOUNT=T.ACCOUNT \\nGROUP BY U.ACCOUNT\\nHAVING SUM(T.AMOUNT) > 10000"
                    },
                    {
                        "username": "Zain_ul_rab",
                        "content": "SELECT name,SUM(amount) as balance FROM Users u LEFT JOIN Transactions t ON u.account = t.account\\nGROUP BY t.account\\nHAVING SUM(amount) > 10000"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select u.name,a.balance\\nfrom users u,\\n(select account,sum(Amount) as \\'balance\\'\\nfrom Transactions\\ngroup by account) a\\nwhere u.account=a.account\\nand a.balance>10000;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select name , sum(t.amount) as balance\\nfrom users as u\\nleft JOIN Transactions as t\\non u.account = t.account\\ngroup by u.account having sum(t.amount) > 10000;"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "SOLUTION with EXPLANATION :\\n\\nFirst we have to find the total sum of every account, so for that SUM(transaction.amount) using join on condition that account should be same so, users.account = transaction.account after that we have to print only accounts with more than 10000\\nso grouping users.account having clause condition ( balance i.e SUM(transaction.amount) > 10000 ) .\\n\\nSelect u.name, SUM(t.amount) AS balance \\nFrom Users u LEFT JOIN Transactions t\\nON u.account = t.account\\nGroup by u.account having balance > 10000;\\n\\n"
                    }
                ]
            },
            {
                "id": 1775054,
                "content": [
                    {
                        "username": "omehdiakram",
                        "content": "SELECT U.NAME, SUM(T.AMOUNT) AS BALANCE FROM USERS U JOIN TRANSACTIONS T ON U.ACCOUNT = T.ACCOUNT\\nGROUP BY U.ACCOUNT\\nHAVING BALANCE > 10000"
                    },
                    {
                        "username": "tomar_sahab07",
                        "content": "with cte as\\n(SELECT u.name as name , sum(t.amount) over (partition by t.account) as balance \\nfrom users u join transactions t on u.account = t.account) \\n\\nselect distinct name ,balance from cte where balance > 10000"
                    },
                    {
                        "username": "sourabhgarai_98",
                        "content": "select u.name,sum(t.amount) as balance from Users u join Transactions t on u.account=t.account group by t.account having balance>10000;\\n"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nselect name,sum(amount) AS balance \\nFROM Users inner join Transactions\\nOn Users.account=Transactions.account\\nGROUP BY name HAVING sum(amount)>10000"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Use INNER JOIN --> GROUP BY --> Having"
                    },
                    {
                        "username": "deposetonprojet",
                        "content": "select\\nname as NAME,\\nsum(amount) as BALANCE\\nfrom Users\\nLEFT JOIN Transactions ON Transactions.account = Users.account\\nGROUP BY Transactions.account\\nHAVING SUM(amount)>10000"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "<b> Alternative method that beats 57.22% of submission </b>\nKindly upvote if you like it! :)\n\n## Approach\nIntuitively, we may want to simple do a left join and group them by account with the use of `HAVING()` function.\n\nWe can approach it alternatively by creating a temp table to tabulate the balance before using a simple query to get our results.\n```\n### Tabulate total balance with temp table\nWITH tempBal AS (\n    SELECT u.account, u.name, \n        SUM(t.amount) AS balance\n        FROM Users u\n        LEFT JOIN ...\n        ON ...\n        GROUP BY ...\n)\n\n### Extract results with over 10,000 in balance\nSELECT name, balance\nFROM tempBal\nWHERE ...\n```"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "select sum(t.amount) as balance,name from Users u \\njoin Transactions t  on\\nu.account = t.account\\ngroup by  t.account\\nhaving sum(t.amount) > 10000"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select u.name,\\nsum(t.amount) as balance\\nfrom Users u join Transactions t\\non u.account = t.account \\ngroup by t.account\\nhaving balance > 10000"
                    },
                    {
                        "username": "SuprajaVinayakam",
                        "content": "select u.name as NAME,sum(t.amount) as BALANCE\\nfrom Users u INNER JOIN Transactions t\\non u.account = t.account\\ngroup by t.account\\nHaving sum(t.amount)>10000"
                    }
                ]
            },
            {
                "id": 1773510,
                "content": [
                    {
                        "username": "omehdiakram",
                        "content": "SELECT U.NAME, SUM(T.AMOUNT) AS BALANCE FROM USERS U JOIN TRANSACTIONS T ON U.ACCOUNT = T.ACCOUNT\\nGROUP BY U.ACCOUNT\\nHAVING BALANCE > 10000"
                    },
                    {
                        "username": "tomar_sahab07",
                        "content": "with cte as\\n(SELECT u.name as name , sum(t.amount) over (partition by t.account) as balance \\nfrom users u join transactions t on u.account = t.account) \\n\\nselect distinct name ,balance from cte where balance > 10000"
                    },
                    {
                        "username": "sourabhgarai_98",
                        "content": "select u.name,sum(t.amount) as balance from Users u join Transactions t on u.account=t.account group by t.account having balance>10000;\\n"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nselect name,sum(amount) AS balance \\nFROM Users inner join Transactions\\nOn Users.account=Transactions.account\\nGROUP BY name HAVING sum(amount)>10000"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Use INNER JOIN --> GROUP BY --> Having"
                    },
                    {
                        "username": "deposetonprojet",
                        "content": "select\\nname as NAME,\\nsum(amount) as BALANCE\\nfrom Users\\nLEFT JOIN Transactions ON Transactions.account = Users.account\\nGROUP BY Transactions.account\\nHAVING SUM(amount)>10000"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "<b> Alternative method that beats 57.22% of submission </b>\nKindly upvote if you like it! :)\n\n## Approach\nIntuitively, we may want to simple do a left join and group them by account with the use of `HAVING()` function.\n\nWe can approach it alternatively by creating a temp table to tabulate the balance before using a simple query to get our results.\n```\n### Tabulate total balance with temp table\nWITH tempBal AS (\n    SELECT u.account, u.name, \n        SUM(t.amount) AS balance\n        FROM Users u\n        LEFT JOIN ...\n        ON ...\n        GROUP BY ...\n)\n\n### Extract results with over 10,000 in balance\nSELECT name, balance\nFROM tempBal\nWHERE ...\n```"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "select sum(t.amount) as balance,name from Users u \\njoin Transactions t  on\\nu.account = t.account\\ngroup by  t.account\\nhaving sum(t.amount) > 10000"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select u.name,\\nsum(t.amount) as balance\\nfrom Users u join Transactions t\\non u.account = t.account \\ngroup by t.account\\nhaving balance > 10000"
                    },
                    {
                        "username": "SuprajaVinayakam",
                        "content": "select u.name as NAME,sum(t.amount) as BALANCE\\nfrom Users u INNER JOIN Transactions t\\non u.account = t.account\\ngroup by t.account\\nHaving sum(t.amount)>10000"
                    }
                ]
            },
            {
                "id": 1759433,
                "content": [
                    {
                        "username": "omehdiakram",
                        "content": "SELECT U.NAME, SUM(T.AMOUNT) AS BALANCE FROM USERS U JOIN TRANSACTIONS T ON U.ACCOUNT = T.ACCOUNT\\nGROUP BY U.ACCOUNT\\nHAVING BALANCE > 10000"
                    },
                    {
                        "username": "tomar_sahab07",
                        "content": "with cte as\\n(SELECT u.name as name , sum(t.amount) over (partition by t.account) as balance \\nfrom users u join transactions t on u.account = t.account) \\n\\nselect distinct name ,balance from cte where balance > 10000"
                    },
                    {
                        "username": "sourabhgarai_98",
                        "content": "select u.name,sum(t.amount) as balance from Users u join Transactions t on u.account=t.account group by t.account having balance>10000;\\n"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nselect name,sum(amount) AS balance \\nFROM Users inner join Transactions\\nOn Users.account=Transactions.account\\nGROUP BY name HAVING sum(amount)>10000"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Use INNER JOIN --> GROUP BY --> Having"
                    },
                    {
                        "username": "deposetonprojet",
                        "content": "select\\nname as NAME,\\nsum(amount) as BALANCE\\nfrom Users\\nLEFT JOIN Transactions ON Transactions.account = Users.account\\nGROUP BY Transactions.account\\nHAVING SUM(amount)>10000"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "<b> Alternative method that beats 57.22% of submission </b>\nKindly upvote if you like it! :)\n\n## Approach\nIntuitively, we may want to simple do a left join and group them by account with the use of `HAVING()` function.\n\nWe can approach it alternatively by creating a temp table to tabulate the balance before using a simple query to get our results.\n```\n### Tabulate total balance with temp table\nWITH tempBal AS (\n    SELECT u.account, u.name, \n        SUM(t.amount) AS balance\n        FROM Users u\n        LEFT JOIN ...\n        ON ...\n        GROUP BY ...\n)\n\n### Extract results with over 10,000 in balance\nSELECT name, balance\nFROM tempBal\nWHERE ...\n```"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "select sum(t.amount) as balance,name from Users u \\njoin Transactions t  on\\nu.account = t.account\\ngroup by  t.account\\nhaving sum(t.amount) > 10000"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select u.name,\\nsum(t.amount) as balance\\nfrom Users u join Transactions t\\non u.account = t.account \\ngroup by t.account\\nhaving balance > 10000"
                    },
                    {
                        "username": "SuprajaVinayakam",
                        "content": "select u.name as NAME,sum(t.amount) as BALANCE\\nfrom Users u INNER JOIN Transactions t\\non u.account = t.account\\ngroup by t.account\\nHaving sum(t.amount)>10000"
                    }
                ]
            },
            {
                "id": 1752066,
                "content": [
                    {
                        "username": "omehdiakram",
                        "content": "SELECT U.NAME, SUM(T.AMOUNT) AS BALANCE FROM USERS U JOIN TRANSACTIONS T ON U.ACCOUNT = T.ACCOUNT\\nGROUP BY U.ACCOUNT\\nHAVING BALANCE > 10000"
                    },
                    {
                        "username": "tomar_sahab07",
                        "content": "with cte as\\n(SELECT u.name as name , sum(t.amount) over (partition by t.account) as balance \\nfrom users u join transactions t on u.account = t.account) \\n\\nselect distinct name ,balance from cte where balance > 10000"
                    },
                    {
                        "username": "sourabhgarai_98",
                        "content": "select u.name,sum(t.amount) as balance from Users u join Transactions t on u.account=t.account group by t.account having balance>10000;\\n"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nselect name,sum(amount) AS balance \\nFROM Users inner join Transactions\\nOn Users.account=Transactions.account\\nGROUP BY name HAVING sum(amount)>10000"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Use INNER JOIN --> GROUP BY --> Having"
                    },
                    {
                        "username": "deposetonprojet",
                        "content": "select\\nname as NAME,\\nsum(amount) as BALANCE\\nfrom Users\\nLEFT JOIN Transactions ON Transactions.account = Users.account\\nGROUP BY Transactions.account\\nHAVING SUM(amount)>10000"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "<b> Alternative method that beats 57.22% of submission </b>\nKindly upvote if you like it! :)\n\n## Approach\nIntuitively, we may want to simple do a left join and group them by account with the use of `HAVING()` function.\n\nWe can approach it alternatively by creating a temp table to tabulate the balance before using a simple query to get our results.\n```\n### Tabulate total balance with temp table\nWITH tempBal AS (\n    SELECT u.account, u.name, \n        SUM(t.amount) AS balance\n        FROM Users u\n        LEFT JOIN ...\n        ON ...\n        GROUP BY ...\n)\n\n### Extract results with over 10,000 in balance\nSELECT name, balance\nFROM tempBal\nWHERE ...\n```"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "select sum(t.amount) as balance,name from Users u \\njoin Transactions t  on\\nu.account = t.account\\ngroup by  t.account\\nhaving sum(t.amount) > 10000"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select u.name,\\nsum(t.amount) as balance\\nfrom Users u join Transactions t\\non u.account = t.account \\ngroup by t.account\\nhaving balance > 10000"
                    },
                    {
                        "username": "SuprajaVinayakam",
                        "content": "select u.name as NAME,sum(t.amount) as BALANCE\\nfrom Users u INNER JOIN Transactions t\\non u.account = t.account\\ngroup by t.account\\nHaving sum(t.amount)>10000"
                    }
                ]
            },
            {
                "id": 1741198,
                "content": [
                    {
                        "username": "omehdiakram",
                        "content": "SELECT U.NAME, SUM(T.AMOUNT) AS BALANCE FROM USERS U JOIN TRANSACTIONS T ON U.ACCOUNT = T.ACCOUNT\\nGROUP BY U.ACCOUNT\\nHAVING BALANCE > 10000"
                    },
                    {
                        "username": "tomar_sahab07",
                        "content": "with cte as\\n(SELECT u.name as name , sum(t.amount) over (partition by t.account) as balance \\nfrom users u join transactions t on u.account = t.account) \\n\\nselect distinct name ,balance from cte where balance > 10000"
                    },
                    {
                        "username": "sourabhgarai_98",
                        "content": "select u.name,sum(t.amount) as balance from Users u join Transactions t on u.account=t.account group by t.account having balance>10000;\\n"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nselect name,sum(amount) AS balance \\nFROM Users inner join Transactions\\nOn Users.account=Transactions.account\\nGROUP BY name HAVING sum(amount)>10000"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Use INNER JOIN --> GROUP BY --> Having"
                    },
                    {
                        "username": "deposetonprojet",
                        "content": "select\\nname as NAME,\\nsum(amount) as BALANCE\\nfrom Users\\nLEFT JOIN Transactions ON Transactions.account = Users.account\\nGROUP BY Transactions.account\\nHAVING SUM(amount)>10000"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "<b> Alternative method that beats 57.22% of submission </b>\nKindly upvote if you like it! :)\n\n## Approach\nIntuitively, we may want to simple do a left join and group them by account with the use of `HAVING()` function.\n\nWe can approach it alternatively by creating a temp table to tabulate the balance before using a simple query to get our results.\n```\n### Tabulate total balance with temp table\nWITH tempBal AS (\n    SELECT u.account, u.name, \n        SUM(t.amount) AS balance\n        FROM Users u\n        LEFT JOIN ...\n        ON ...\n        GROUP BY ...\n)\n\n### Extract results with over 10,000 in balance\nSELECT name, balance\nFROM tempBal\nWHERE ...\n```"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "select sum(t.amount) as balance,name from Users u \\njoin Transactions t  on\\nu.account = t.account\\ngroup by  t.account\\nhaving sum(t.amount) > 10000"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select u.name,\\nsum(t.amount) as balance\\nfrom Users u join Transactions t\\non u.account = t.account \\ngroup by t.account\\nhaving balance > 10000"
                    },
                    {
                        "username": "SuprajaVinayakam",
                        "content": "select u.name as NAME,sum(t.amount) as BALANCE\\nfrom Users u INNER JOIN Transactions t\\non u.account = t.account\\ngroup by t.account\\nHaving sum(t.amount)>10000"
                    }
                ]
            },
            {
                "id": 1733483,
                "content": [
                    {
                        "username": "omehdiakram",
                        "content": "SELECT U.NAME, SUM(T.AMOUNT) AS BALANCE FROM USERS U JOIN TRANSACTIONS T ON U.ACCOUNT = T.ACCOUNT\\nGROUP BY U.ACCOUNT\\nHAVING BALANCE > 10000"
                    },
                    {
                        "username": "tomar_sahab07",
                        "content": "with cte as\\n(SELECT u.name as name , sum(t.amount) over (partition by t.account) as balance \\nfrom users u join transactions t on u.account = t.account) \\n\\nselect distinct name ,balance from cte where balance > 10000"
                    },
                    {
                        "username": "sourabhgarai_98",
                        "content": "select u.name,sum(t.amount) as balance from Users u join Transactions t on u.account=t.account group by t.account having balance>10000;\\n"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nselect name,sum(amount) AS balance \\nFROM Users inner join Transactions\\nOn Users.account=Transactions.account\\nGROUP BY name HAVING sum(amount)>10000"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Use INNER JOIN --> GROUP BY --> Having"
                    },
                    {
                        "username": "deposetonprojet",
                        "content": "select\\nname as NAME,\\nsum(amount) as BALANCE\\nfrom Users\\nLEFT JOIN Transactions ON Transactions.account = Users.account\\nGROUP BY Transactions.account\\nHAVING SUM(amount)>10000"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "<b> Alternative method that beats 57.22% of submission </b>\nKindly upvote if you like it! :)\n\n## Approach\nIntuitively, we may want to simple do a left join and group them by account with the use of `HAVING()` function.\n\nWe can approach it alternatively by creating a temp table to tabulate the balance before using a simple query to get our results.\n```\n### Tabulate total balance with temp table\nWITH tempBal AS (\n    SELECT u.account, u.name, \n        SUM(t.amount) AS balance\n        FROM Users u\n        LEFT JOIN ...\n        ON ...\n        GROUP BY ...\n)\n\n### Extract results with over 10,000 in balance\nSELECT name, balance\nFROM tempBal\nWHERE ...\n```"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "select sum(t.amount) as balance,name from Users u \\njoin Transactions t  on\\nu.account = t.account\\ngroup by  t.account\\nhaving sum(t.amount) > 10000"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select u.name,\\nsum(t.amount) as balance\\nfrom Users u join Transactions t\\non u.account = t.account \\ngroup by t.account\\nhaving balance > 10000"
                    },
                    {
                        "username": "SuprajaVinayakam",
                        "content": "select u.name as NAME,sum(t.amount) as BALANCE\\nfrom Users u INNER JOIN Transactions t\\non u.account = t.account\\ngroup by t.account\\nHaving sum(t.amount)>10000"
                    }
                ]
            },
            {
                "id": 1730923,
                "content": [
                    {
                        "username": "omehdiakram",
                        "content": "SELECT U.NAME, SUM(T.AMOUNT) AS BALANCE FROM USERS U JOIN TRANSACTIONS T ON U.ACCOUNT = T.ACCOUNT\\nGROUP BY U.ACCOUNT\\nHAVING BALANCE > 10000"
                    },
                    {
                        "username": "tomar_sahab07",
                        "content": "with cte as\\n(SELECT u.name as name , sum(t.amount) over (partition by t.account) as balance \\nfrom users u join transactions t on u.account = t.account) \\n\\nselect distinct name ,balance from cte where balance > 10000"
                    },
                    {
                        "username": "sourabhgarai_98",
                        "content": "select u.name,sum(t.amount) as balance from Users u join Transactions t on u.account=t.account group by t.account having balance>10000;\\n"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nselect name,sum(amount) AS balance \\nFROM Users inner join Transactions\\nOn Users.account=Transactions.account\\nGROUP BY name HAVING sum(amount)>10000"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Use INNER JOIN --> GROUP BY --> Having"
                    },
                    {
                        "username": "deposetonprojet",
                        "content": "select\\nname as NAME,\\nsum(amount) as BALANCE\\nfrom Users\\nLEFT JOIN Transactions ON Transactions.account = Users.account\\nGROUP BY Transactions.account\\nHAVING SUM(amount)>10000"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "<b> Alternative method that beats 57.22% of submission </b>\nKindly upvote if you like it! :)\n\n## Approach\nIntuitively, we may want to simple do a left join and group them by account with the use of `HAVING()` function.\n\nWe can approach it alternatively by creating a temp table to tabulate the balance before using a simple query to get our results.\n```\n### Tabulate total balance with temp table\nWITH tempBal AS (\n    SELECT u.account, u.name, \n        SUM(t.amount) AS balance\n        FROM Users u\n        LEFT JOIN ...\n        ON ...\n        GROUP BY ...\n)\n\n### Extract results with over 10,000 in balance\nSELECT name, balance\nFROM tempBal\nWHERE ...\n```"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "select sum(t.amount) as balance,name from Users u \\njoin Transactions t  on\\nu.account = t.account\\ngroup by  t.account\\nhaving sum(t.amount) > 10000"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select u.name,\\nsum(t.amount) as balance\\nfrom Users u join Transactions t\\non u.account = t.account \\ngroup by t.account\\nhaving balance > 10000"
                    },
                    {
                        "username": "SuprajaVinayakam",
                        "content": "select u.name as NAME,sum(t.amount) as BALANCE\\nfrom Users u INNER JOIN Transactions t\\non u.account = t.account\\ngroup by t.account\\nHaving sum(t.amount)>10000"
                    }
                ]
            },
            {
                "id": 1725458,
                "content": [
                    {
                        "username": "omehdiakram",
                        "content": "SELECT U.NAME, SUM(T.AMOUNT) AS BALANCE FROM USERS U JOIN TRANSACTIONS T ON U.ACCOUNT = T.ACCOUNT\\nGROUP BY U.ACCOUNT\\nHAVING BALANCE > 10000"
                    },
                    {
                        "username": "tomar_sahab07",
                        "content": "with cte as\\n(SELECT u.name as name , sum(t.amount) over (partition by t.account) as balance \\nfrom users u join transactions t on u.account = t.account) \\n\\nselect distinct name ,balance from cte where balance > 10000"
                    },
                    {
                        "username": "sourabhgarai_98",
                        "content": "select u.name,sum(t.amount) as balance from Users u join Transactions t on u.account=t.account group by t.account having balance>10000;\\n"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nselect name,sum(amount) AS balance \\nFROM Users inner join Transactions\\nOn Users.account=Transactions.account\\nGROUP BY name HAVING sum(amount)>10000"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Use INNER JOIN --> GROUP BY --> Having"
                    },
                    {
                        "username": "deposetonprojet",
                        "content": "select\\nname as NAME,\\nsum(amount) as BALANCE\\nfrom Users\\nLEFT JOIN Transactions ON Transactions.account = Users.account\\nGROUP BY Transactions.account\\nHAVING SUM(amount)>10000"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "<b> Alternative method that beats 57.22% of submission </b>\nKindly upvote if you like it! :)\n\n## Approach\nIntuitively, we may want to simple do a left join and group them by account with the use of `HAVING()` function.\n\nWe can approach it alternatively by creating a temp table to tabulate the balance before using a simple query to get our results.\n```\n### Tabulate total balance with temp table\nWITH tempBal AS (\n    SELECT u.account, u.name, \n        SUM(t.amount) AS balance\n        FROM Users u\n        LEFT JOIN ...\n        ON ...\n        GROUP BY ...\n)\n\n### Extract results with over 10,000 in balance\nSELECT name, balance\nFROM tempBal\nWHERE ...\n```"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "select sum(t.amount) as balance,name from Users u \\njoin Transactions t  on\\nu.account = t.account\\ngroup by  t.account\\nhaving sum(t.amount) > 10000"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select u.name,\\nsum(t.amount) as balance\\nfrom Users u join Transactions t\\non u.account = t.account \\ngroup by t.account\\nhaving balance > 10000"
                    },
                    {
                        "username": "SuprajaVinayakam",
                        "content": "select u.name as NAME,sum(t.amount) as BALANCE\\nfrom Users u INNER JOIN Transactions t\\non u.account = t.account\\ngroup by t.account\\nHaving sum(t.amount)>10000"
                    }
                ]
            },
            {
                "id": 1717015,
                "content": [
                    {
                        "username": "omehdiakram",
                        "content": "SELECT U.NAME, SUM(T.AMOUNT) AS BALANCE FROM USERS U JOIN TRANSACTIONS T ON U.ACCOUNT = T.ACCOUNT\\nGROUP BY U.ACCOUNT\\nHAVING BALANCE > 10000"
                    },
                    {
                        "username": "tomar_sahab07",
                        "content": "with cte as\\n(SELECT u.name as name , sum(t.amount) over (partition by t.account) as balance \\nfrom users u join transactions t on u.account = t.account) \\n\\nselect distinct name ,balance from cte where balance > 10000"
                    },
                    {
                        "username": "sourabhgarai_98",
                        "content": "select u.name,sum(t.amount) as balance from Users u join Transactions t on u.account=t.account group by t.account having balance>10000;\\n"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nselect name,sum(amount) AS balance \\nFROM Users inner join Transactions\\nOn Users.account=Transactions.account\\nGROUP BY name HAVING sum(amount)>10000"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Use INNER JOIN --> GROUP BY --> Having"
                    },
                    {
                        "username": "deposetonprojet",
                        "content": "select\\nname as NAME,\\nsum(amount) as BALANCE\\nfrom Users\\nLEFT JOIN Transactions ON Transactions.account = Users.account\\nGROUP BY Transactions.account\\nHAVING SUM(amount)>10000"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "<b> Alternative method that beats 57.22% of submission </b>\nKindly upvote if you like it! :)\n\n## Approach\nIntuitively, we may want to simple do a left join and group them by account with the use of `HAVING()` function.\n\nWe can approach it alternatively by creating a temp table to tabulate the balance before using a simple query to get our results.\n```\n### Tabulate total balance with temp table\nWITH tempBal AS (\n    SELECT u.account, u.name, \n        SUM(t.amount) AS balance\n        FROM Users u\n        LEFT JOIN ...\n        ON ...\n        GROUP BY ...\n)\n\n### Extract results with over 10,000 in balance\nSELECT name, balance\nFROM tempBal\nWHERE ...\n```"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "select sum(t.amount) as balance,name from Users u \\njoin Transactions t  on\\nu.account = t.account\\ngroup by  t.account\\nhaving sum(t.amount) > 10000"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select u.name,\\nsum(t.amount) as balance\\nfrom Users u join Transactions t\\non u.account = t.account \\ngroup by t.account\\nhaving balance > 10000"
                    },
                    {
                        "username": "SuprajaVinayakam",
                        "content": "select u.name as NAME,sum(t.amount) as BALANCE\\nfrom Users u INNER JOIN Transactions t\\non u.account = t.account\\ngroup by t.account\\nHaving sum(t.amount)>10000"
                    }
                ]
            },
            {
                "id": 1698034,
                "content": [
                    {
                        "username": "omehdiakram",
                        "content": "SELECT U.NAME, SUM(T.AMOUNT) AS BALANCE FROM USERS U JOIN TRANSACTIONS T ON U.ACCOUNT = T.ACCOUNT\\nGROUP BY U.ACCOUNT\\nHAVING BALANCE > 10000"
                    },
                    {
                        "username": "tomar_sahab07",
                        "content": "with cte as\\n(SELECT u.name as name , sum(t.amount) over (partition by t.account) as balance \\nfrom users u join transactions t on u.account = t.account) \\n\\nselect distinct name ,balance from cte where balance > 10000"
                    },
                    {
                        "username": "sourabhgarai_98",
                        "content": "select u.name,sum(t.amount) as balance from Users u join Transactions t on u.account=t.account group by t.account having balance>10000;\\n"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nselect name,sum(amount) AS balance \\nFROM Users inner join Transactions\\nOn Users.account=Transactions.account\\nGROUP BY name HAVING sum(amount)>10000"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Use INNER JOIN --> GROUP BY --> Having"
                    },
                    {
                        "username": "deposetonprojet",
                        "content": "select\\nname as NAME,\\nsum(amount) as BALANCE\\nfrom Users\\nLEFT JOIN Transactions ON Transactions.account = Users.account\\nGROUP BY Transactions.account\\nHAVING SUM(amount)>10000"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "<b> Alternative method that beats 57.22% of submission </b>\nKindly upvote if you like it! :)\n\n## Approach\nIntuitively, we may want to simple do a left join and group them by account with the use of `HAVING()` function.\n\nWe can approach it alternatively by creating a temp table to tabulate the balance before using a simple query to get our results.\n```\n### Tabulate total balance with temp table\nWITH tempBal AS (\n    SELECT u.account, u.name, \n        SUM(t.amount) AS balance\n        FROM Users u\n        LEFT JOIN ...\n        ON ...\n        GROUP BY ...\n)\n\n### Extract results with over 10,000 in balance\nSELECT name, balance\nFROM tempBal\nWHERE ...\n```"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "select sum(t.amount) as balance,name from Users u \\njoin Transactions t  on\\nu.account = t.account\\ngroup by  t.account\\nhaving sum(t.amount) > 10000"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select u.name,\\nsum(t.amount) as balance\\nfrom Users u join Transactions t\\non u.account = t.account \\ngroup by t.account\\nhaving balance > 10000"
                    },
                    {
                        "username": "SuprajaVinayakam",
                        "content": "select u.name as NAME,sum(t.amount) as BALANCE\\nfrom Users u INNER JOIN Transactions t\\non u.account = t.account\\ngroup by t.account\\nHaving sum(t.amount)>10000"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Product Difference Between Two Pairs",
        "question_content": "<p>The <strong>product difference</strong> between two pairs <code>(a, b)</code> and <code>(c, d)</code> is defined as <code>(a * b) - (c * d)</code>.</p>\r\n\r\n<ul>\r\n\t<li>For example, the product difference between <code>(5, 6)</code> and <code>(2, 7)</code> is <code>(5 * 6) - (2 * 7) = 16</code>.</li>\r\n</ul>\r\n\r\n<p>Given an integer array <code>nums</code>, choose four <strong>distinct</strong> indices <code>w</code>, <code>x</code>, <code>y</code>, and <code>z</code> such that the <strong>product difference</strong> between pairs <code>(nums[w], nums[x])</code> and <code>(nums[y], nums[z])</code> is <strong>maximized</strong>.</p>\r\n\r\n<p>Return <em>the <strong>maximum</strong> such product difference</em>.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong class=\"example\">Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [5,6,2,7,4]\r\n<strong>Output:</strong> 34\r\n<strong>Explanation:</strong> We can choose indices 1 and 3 for the first pair (6, 7) and indices 2 and 4 for the second pair (2, 4).\r\nThe product difference is (6 * 7) - (2 * 4) = 34.\r\n</pre>\r\n\r\n<p><strong class=\"example\">Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [4,2,5,9,7,4,8]\r\n<strong>Output:</strong> 64\r\n<strong>Explanation:</strong> We can choose indices 3 and 6 for the first pair (9, 8) and indices 1 and 5 for the second pair (2, 4).\r\nThe product difference is (9 * 8) - (2 * 4) = 64.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>4 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\r\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\r\n</ul>",
        "solutions": [
            {
                "id": 1299652,
                "title": "easy-c-o-n-solution-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        //we have to return the result of\\n        // (firstMax*secondMax) - (firstMin*secondMin)\\n        int max1=INT_MIN;\\n        int max2=INT_MIN;\\n        int min1=INT_MAX;\\n        int min2=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            \\n            if(nums[i]>max1)\\n            {\\n                //assign the second max to max2\\n                max2=max1;\\n                max1=nums[i];\\n            }\\n            else if(nums[i]>max2)\\n            {\\n                //it can become second max\\n                max2= nums[i];\\n            }\\n            \\n            //check for the minimum\\n            if(nums[i]<min1)\\n            {\\n                //it can become first minimum\\n                min2=min1;\\n                min1=nums[i];\\n            }\\n            else if(nums[i]<min2)\\n            {\\n                //it can become second minimum\\n                min2=nums[i];\\n            }\\n        }\\n        return (max1*max2)- (min1*min2);\\n    }\\n};\\n```\\n**Please Upvote if this helps :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        //we have to return the result of\\n        // (firstMax*secondMax) - (firstMin*secondMin)\\n        int max1=INT_MIN;\\n        int max2=INT_MIN;\\n        int min1=INT_MAX;\\n        int min2=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            \\n            if(nums[i]>max1)\\n            {\\n                //assign the second max to max2\\n                max2=max1;\\n                max1=nums[i];\\n            }\\n            else if(nums[i]>max2)\\n            {\\n                //it can become second max\\n                max2= nums[i];\\n            }\\n            \\n            //check for the minimum\\n            if(nums[i]<min1)\\n            {\\n                //it can become first minimum\\n                min2=min1;\\n                min1=nums[i];\\n            }\\n            else if(nums[i]<min2)\\n            {\\n                //it can become second minimum\\n                min2=nums[i];\\n            }\\n        }\\n        return (max1*max2)- (min1*min2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299800,
                "title": "java-o-n",
                "content": "Time: O(N)\\n```\\npublic int maxProductDifference(int[] nums) {\\n\\tint largest = 0, secondLargest = 0, smallest = Integer.MAX_VALUE, secondSmallest = Integer.MAX_VALUE;\\n\\tfor(int i=0;i<nums.length;i++) {\\n\\t\\tif(nums[i]>=largest) {\\n\\t\\t\\tsecondLargest = largest;\\n\\t\\t\\tlargest = nums[i];\\n\\t\\t} else if(nums[i]>secondLargest) secondLargest = nums[i];\\n\\t\\tif(nums[i]<=smallest) {\\n\\t\\t\\tsecondSmallest = smallest;\\n\\t\\t\\tsmallest = nums[i];\\n\\t\\t} else if(nums[i]<secondSmallest) secondSmallest = nums[i];\\n\\t}\\n\\treturn largest * secondLargest - smallest * secondSmallest;\\n}\\n```\\n\\nAnother solution\\n with time: O(NLogN)\\n```\\npublic int maxProductDifference(int[] nums) {\\n\\tArrays.sort(nums);\\n\\treturn nums[nums.length-1] * nums[nums.length-2] - nums[0]*nums[1];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxProductDifference(int[] nums) {\\n\\tint largest = 0, secondLargest = 0, smallest = Integer.MAX_VALUE, secondSmallest = Integer.MAX_VALUE;\\n\\tfor(int i=0;i<nums.length;i++) {\\n\\t\\tif(nums[i]>=largest) {\\n\\t\\t\\tsecondLargest = largest;\\n\\t\\t\\tlargest = nums[i];\\n\\t\\t} else if(nums[i]>secondLargest) secondLargest = nums[i];\\n\\t\\tif(nums[i]<=smallest) {\\n\\t\\t\\tsecondSmallest = smallest;\\n\\t\\t\\tsmallest = nums[i];\\n\\t\\t} else if(nums[i]<secondSmallest) secondSmallest = nums[i];\\n\\t}\\n\\treturn largest * secondLargest - smallest * secondSmallest;\\n}\\n```\n```\\npublic int maxProductDifference(int[] nums) {\\n\\tArrays.sort(nums);\\n\\treturn nums[nums.length-1] * nums[nums.length-2] - nums[0]*nums[1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1303870,
                "title": "python3-two-solutions-o-nlogn-and-o-n-time",
                "content": "O(nlogn) time O(1) space\\n\\n```python\\ndef maxProductDifference(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return nums[-1]*nums[-2]-nums[0]*nums[1]\\n```\\n\\nO(n) time O(1) space\\n\\n```python\\ndef maxProductDifference(self, nums: List[int]) -> int:\\n        min1 = min2 = float(\\'inf\\')\\n        max1 = max2 = float(\\'-inf\\')\\n        for n in nums:\\n            if n <= min1:\\n                min1, min2, = n, min1\\n            elif n < min2:\\n                min2 = n\\n            if n >= max1:\\n                max1, max2 = n, max1\\n            elif n > max2:\\n                max2 = n\\n        return max1*max2-min1*min2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef maxProductDifference(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return nums[-1]*nums[-2]-nums[0]*nums[1]\\n```\n```python\\ndef maxProductDifference(self, nums: List[int]) -> int:\\n        min1 = min2 = float(\\'inf\\')\\n        max1 = max2 = float(\\'-inf\\')\\n        for n in nums:\\n            if n <= min1:\\n                min1, min2, = n, min1\\n            elif n < min2:\\n                min2 = n\\n            if n >= max1:\\n                max1, max2 = n, max1\\n            elif n > max2:\\n                max2 = n\\n        return max1*max2-min1*min2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1786754,
                "title": "easy-1ms-99-88-o-n-solution-without-sorting",
                "content": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        int max1 = Integer.MIN_VALUE;\\n        int max2 = max1;\\n\\n        int min1 = Integer.MAX_VALUE;\\n        int min2 = min1;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (max1 < nums[i]) {\\n                max2 = max1;\\n                max1 = nums[i];\\n            } else if(nums[i] > max2)\\n                max2 = nums[i];\\n\\n            if(min1 > nums[i]){\\n                min2 = min1;\\n                min1 = nums[i];\\n            }else if (nums[i] < min2)\\n                min2 = nums[i];\\n        }\\n        \\n        return (max1 * max2) - (min1 * min2);\\n    }\\n}\\n```\\nPLEASE ***UPVOTE***, if you find this solution helpful! :D",
                "solutionTags": [
                    "Java",
                    "C",
                    "C#"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        int max1 = Integer.MIN_VALUE;\\n        int max2 = max1;\\n\\n        int min1 = Integer.MAX_VALUE;\\n        int min2 = min1;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (max1 < nums[i]) {\\n                max2 = max1;\\n                max1 = nums[i];\\n            } else if(nums[i] > max2)\\n                max2 = nums[i];\\n\\n            if(min1 > nums[i]){\\n                min2 = min1;\\n                min1 = nums[i];\\n            }else if (nums[i] < min2)\\n                min2 = nums[i];\\n        }\\n        \\n        return (max1 * max2) - (min1 * min2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2611858,
                "title": "c-6-different-approaches-sort-partial-sort-nth-element-linear-scan-heap",
                "content": "Please let me know if you came up with yet another solution to this problem.\\n\\n# Approach 1: std::sort()\\n\\nThe obvious solution is to sort ```nums``` and take the last two and the first two elements.\\n\\n```cpp\\n    static int maxProductDifference(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        return nums[size(nums) - 1] * nums[size(nums) - 2] - nums[0] * nums[1];\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time Complexity: $$O(n \\\\log n)$$ -- because of the ```std::sort```.\\n  * Space Complexity: $$O(1)$$\\n\\n# Approach 2: std::partial_sort() 2x\\n\\nWe don\\'t need to sort all of ```nums```, only a partial sort to get the smallest two numbers and the largest two numbers is enough.\\n\\n```cpp\\n    static int maxProductDifference(vector<int>& nums) {\\n        partial_sort(begin(nums), next(begin(nums), 2), end(nums));\\n        partial_sort(next(begin(nums), 2), next(begin(nums), 4), end(nums), greater<>());\\n        return nums[2] * nums[3] - nums[0] * nums[1];\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time Complexity: According to cppreference.com the time complexity for std::partial_sort is approcimatly _(last - first) log (middle - first)_. In our case _(last - first)_ is _n_ and _(middle - first)_ is _2_ hence we have $$O(n \\\\log 2)$ so basically $$O(n)$$.\\n  * Space Complexity: $$O(1)$$\\n\\n# Approach 3: std::nth_element() 2x\\n\\nMultiplication is commutative, i.e. it doesn\\'t matter in which order we multiple the two largest and the two smallest element. With that the don\\'t even need to be sorted.\\n\\n```cpp\\n    static int maxProductDifference(vector<int>& nums) {\\n        nth_element(begin(nums), next(begin(nums), 2), end(nums));\\n        nth_element(next(begin(nums), 2), next(begin(nums), 4), end(nums), greater<>());\\n        return nums[2] * nums[3] - nums[0] * nums[1];\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time Complexity: $$O(n)$$ for quick select\\n  * Space Complexity: $$O(1)$$\\n\\n# Approach 4: linear scan for first and second min / max\\n\\nThe solutions so far have modified ```nums```. We can also just scan through ```nums``` and keep track of the first and second minimum / maximum element.\\n\\n\\n```cpp\\n    static int maxProductDifference(const vector<int>& nums) {\\n        int mx1 = numeric_limits<int>::min();\\n        int mx2 = numeric_limits<int>::min();\\n        int mn1 = numeric_limits<int>::max();\\n        int mn2 = numeric_limits<int>::max();\\n        for (const int n : nums) {\\n            if (n > mx1) {\\n                mx2 = mx1;\\n                mx1 = n;\\n            } else if (n > mx2) {\\n                mx2 = n;\\n            }\\n            if (n < mn1) {\\n                mn2 = mn1;\\n                mn1 = n;\\n            } else if (n < mn2) {\\n                mn2 = n;\\n            }\\n        }\\n        return mx1 * mx2 - mn1 * mn2;\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time Complexity: $$O(n)$$\\n  * Space Complexity: $$O(1)$$\\n\\n# Approach 5: sort first 4 element and then linear scan\\n\\nThis is based on a solution from @ZX007PI. With this tweak only of one series of if / else instead of two like in solution 4, and we could argue this safes a branch. This variant of approach 4 modifies the input again.\\n\\n```cpp\\n   static int maxProductDifference(vector<int>& nums) {\\n        sort(begin(nums), next(begin(nums), 4));\\n        int mx1 = nums[3];\\n        int mx2 = nums[2];\\n        int mn1 = nums[0];\\n        int mn2 = nums[1];\\n        for (int i = 4; i < size(nums); ++i) {\\n            const int n = nums[i];\\n            if (n >= mx1) {\\n                mx2 = mx1;\\n                mx1 = n;\\n            } else if (n > mx2) {\\n                mx2 = n;\\n            } else if (n <= mn1) {\\n                mn2 = mn1;\\n                mn1 = n;\\n            } else if (n < mn2) {\\n                mn2 = n;\\n            }\\n        }\\n        return mx1 * mx2 - mn1 * mn2;\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time Complexity: $$O(n)$$ we only sort 4 elements so the complexity remains linear.\\n  * Space Complexity: $$O(1)$$\\n\\n# Approach 6: min / max heap\\n\\nIt\\'s maybe a bit of an overkill to use a heap to solve this problem, but why not. I have seen some variants that push all elements on the the heap (```priority_queue```) without limiting the size to two elements, but that\\'s a waste as we can keep the size of the heap bounded, which leads to better time / space complexity.\\n\\n```cpp\\n   static int maxProductDifference(const vector<int>& nums) {\\n        // The largest element will be on top and we will always\\n        // pull of the largest element and it will result in having\\n        // the smallest element remaining.\\n        priority_queue<int> max_heap;\\n        // ... and the other way around for the min heap.\\n        priority_queue<int, vector<int>, greater<>> min_heap;\\n        for (const int n : nums) {\\n            max_heap.push(n);\\n            if (size(max_heap) == 3) {\\n                max_heap.pop();\\n            }\\n            min_heap.push(n);\\n            if (size(min_heap) == 3) {\\n                min_heap.pop();\\n            }\\n        }\\n        const int mn1 = max_heap.top(); max_heap.pop();\\n        const int mn2 = max_heap.top();\\n        const int mx1 = min_heap.top(); min_heap.pop();\\n        const int mx2 = min_heap.top();\\n       \\n        return mx1 * mx2 - mn1 * mn2;\\n    }\\n```\\n\\nThere is a variant to this solution where we only push on to the heap if that would actually make a different, either because the heap as fewer than 2 elments or the top element is other smaller or bigger so inserting would actually make a difference. The loop would like this:\\n\\n```cpp\\n        for (const int n : nums) {\\n            if (size(max_heap) < 2 || n < max_heap.top()) {\\n                max_heap.push(n);\\n                if (size(max_heap) == 3) max_heap.pop();\\n            }\\n            if (size(min_heap) < 2 || n > min_heap.top()) {\\n                min_heap.push(n);\\n                if (size(min_heap) == 3) min_heap.pop();\\n            }\\n        }\\n```\\n\\n\\n**Complexity Analysis**\\n  * Time Complexity: $$O(n)$$ we do at most 2 comparisons per heap.\\n  * Space Complexity: $$O(1)$$\\n\\n_As always: Feedback, questions, and commenst are welcome. Please upvote if you like the post._\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/Nqm4jJcyBf)!**",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```nums```\n```cpp\\n    static int maxProductDifference(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        return nums[size(nums) - 1] * nums[size(nums) - 2] - nums[0] * nums[1];\\n    }\\n```\n```std::sort```\n```nums```\n```cpp\\n    static int maxProductDifference(vector<int>& nums) {\\n        partial_sort(begin(nums), next(begin(nums), 2), end(nums));\\n        partial_sort(next(begin(nums), 2), next(begin(nums), 4), end(nums), greater<>());\\n        return nums[2] * nums[3] - nums[0] * nums[1];\\n    }\\n```\n```cpp\\n    static int maxProductDifference(vector<int>& nums) {\\n        nth_element(begin(nums), next(begin(nums), 2), end(nums));\\n        nth_element(next(begin(nums), 2), next(begin(nums), 4), end(nums), greater<>());\\n        return nums[2] * nums[3] - nums[0] * nums[1];\\n    }\\n```\n```nums```\n```nums```\n```cpp\\n    static int maxProductDifference(const vector<int>& nums) {\\n        int mx1 = numeric_limits<int>::min();\\n        int mx2 = numeric_limits<int>::min();\\n        int mn1 = numeric_limits<int>::max();\\n        int mn2 = numeric_limits<int>::max();\\n        for (const int n : nums) {\\n            if (n > mx1) {\\n                mx2 = mx1;\\n                mx1 = n;\\n            } else if (n > mx2) {\\n                mx2 = n;\\n            }\\n            if (n < mn1) {\\n                mn2 = mn1;\\n                mn1 = n;\\n            } else if (n < mn2) {\\n                mn2 = n;\\n            }\\n        }\\n        return mx1 * mx2 - mn1 * mn2;\\n    }\\n```\n```cpp\\n   static int maxProductDifference(vector<int>& nums) {\\n        sort(begin(nums), next(begin(nums), 4));\\n        int mx1 = nums[3];\\n        int mx2 = nums[2];\\n        int mn1 = nums[0];\\n        int mn2 = nums[1];\\n        for (int i = 4; i < size(nums); ++i) {\\n            const int n = nums[i];\\n            if (n >= mx1) {\\n                mx2 = mx1;\\n                mx1 = n;\\n            } else if (n > mx2) {\\n                mx2 = n;\\n            } else if (n <= mn1) {\\n                mn2 = mn1;\\n                mn1 = n;\\n            } else if (n < mn2) {\\n                mn2 = n;\\n            }\\n        }\\n        return mx1 * mx2 - mn1 * mn2;\\n    }\\n```\n```priority_queue```\n```cpp\\n   static int maxProductDifference(const vector<int>& nums) {\\n        // The largest element will be on top and we will always\\n        // pull of the largest element and it will result in having\\n        // the smallest element remaining.\\n        priority_queue<int> max_heap;\\n        // ... and the other way around for the min heap.\\n        priority_queue<int, vector<int>, greater<>> min_heap;\\n        for (const int n : nums) {\\n            max_heap.push(n);\\n            if (size(max_heap) == 3) {\\n                max_heap.pop();\\n            }\\n            min_heap.push(n);\\n            if (size(min_heap) == 3) {\\n                min_heap.pop();\\n            }\\n        }\\n        const int mn1 = max_heap.top(); max_heap.pop();\\n        const int mn2 = max_heap.top();\\n        const int mx1 = min_heap.top(); min_heap.pop();\\n        const int mx2 = min_heap.top();\\n       \\n        return mx1 * mx2 - mn1 * mn2;\\n    }\\n```\n```cpp\\n        for (const int n : nums) {\\n            if (size(max_heap) < 2 || n < max_heap.top()) {\\n                max_heap.push(n);\\n                if (size(max_heap) == 3) max_heap.pop();\\n            }\\n            if (size(min_heap) < 2 || n > min_heap.top()) {\\n                min_heap.push(n);\\n                if (size(min_heap) == 3) min_heap.pop();\\n            }\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1348190,
                "title": "java-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        int max1 = Integer.MIN_VALUE;\\n        int max2 = Integer.MIN_VALUE;\\n        \\n        int min1 = Integer.MAX_VALUE;\\n        int min2 = Integer.MAX_VALUE;\\n        \\n        for(int val : nums){\\n            if(val > max1){\\n                max2 = max1;\\n                max1 = val;\\n            } else if(val > max2){\\n                max2 = val;\\n            }\\n            \\n            if(val < min1){\\n                min2 = min1;\\n                min1 = val;\\n            } else if(val < min2){\\n                min2 = val;\\n            }\\n        }\\n        \\n        return (max1 * max2) - (min1 * min2);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        int max1 = Integer.MIN_VALUE;\\n        int max2 = Integer.MIN_VALUE;\\n        \\n        int min1 = Integer.MAX_VALUE;\\n        int min2 = Integer.MAX_VALUE;\\n        \\n        for(int val : nums){\\n            if(val > max1){\\n                max2 = max1;\\n                max1 = val;\\n            } else if(val > max2){\\n                max2 = val;\\n            }\\n            \\n            if(val < min1){\\n                min2 = min1;\\n                min1 = val;\\n            } else if(val < min2){\\n                min2 = val;\\n            }\\n        }\\n        \\n        return (max1 * max2) - (min1 * min2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317241,
                "title": "c-easy-sol-2-line-of-code-explained",
                "content": "The basic approach is to get maximum product  differnce is to chose the minimum and max product simply sort and take first two and last two numbers\\n```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return nums[nums.size()-1]*nums[nums.size()-2]-nums[0]*nums[1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return nums[nums.size()-1]*nums[nums.size()-2]-nums[0]*nums[1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084079,
                "title": "c-c-java-c-javascript-typescript-o-n-solutions-easy-to-understand",
                "content": "The difference product would always be between first two and last two elements of the [**sorted**](https://docs.microsoft.com/en-us/dotnet/api/system.array.sort?view=net-6.0#system-array-sort(system-array)) array. The time complexity would be O(NLogN). \\nThis problem can be solved with O(N) solutions also. Please see the code samples. \\n```C++ []\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        int max1=0,max2=0,min1=INT_MAX,min2=INT_MAX;\\n\\t\\tfor(int i=0;i<nums.size();i++) {\\n            if (nums[i]>max1||nums[i]>max2) {\\n                max2=max(max1,max2);\\n                max1=nums[i];\\n            }\\n            if (nums[i]<min1||nums[i]<min2) {\\n                min2=min(min1,min2);\\n                min1=nums[i];\\n            }\\n        }\\n        return (max1*max2)-(min1*min2);\\n    }\\n};\\n```\\n```csharp []\\npublic class Solution {\\n    public int MaxProductDifference(int[] nums){            \\n        int max1=Int32.MinValue,max2=max1,min1=Int32.MaxValue,min2=min1;\\n        for (int i=0;i<nums.Length; i++) {\\n            if (nums[i]>max1||nums[i]>max2) {\\n                max2=Math.Max(max1,max2);\\n                max1=nums[i];\\n            }\\n            if (nums[i]<min1||nums[i]<min2) {\\n                min2=Math.Min(min1,min2);\\n                min1=nums[i];\\n            }\\n        }\\n        return (max1*max2)-(min1*min2);   \\n    }\\n}\\n```\\n```java []\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        int max1=0,max2=0,min1=Integer.MAX_VALUE,min2=Integer.MAX_VALUE;\\n\\t\\tfor(int i=0;i<nums.length;i++) {\\n            if (nums[i]>max1||nums[i]>max2) {\\n                max2=Math.max(max1,max2);\\n                max1=nums[i];\\n            }\\n            if (nums[i]<min1||nums[i]<min2) {\\n                min2=Math.min(min1,min2);\\n                min1=nums[i];\\n            }\\n        }\\n        return (max1*max2)-(min1*min2);   \\n    }\\n}\\n```\\n```C []\\nint maxProductDifference(int* nums, int numsSize){\\n    int max1=0,max2=0,min1=INT_MAX,min2=INT_MAX;\\n    for(int i=0;i<numsSize;i++) {\\n        if (nums[i]>max1||nums[i]>max2) {\\n            max2=fmax(max1,max2);\\n            max1=nums[i];\\n        }\\n        if (nums[i]<min1||nums[i]<min2) {\\n            min2=fmin(min1,min2);\\n            min1=nums[i];\\n        }\\n    }\\n    return max1*max2-min1*min2;\\n}\\n```\\n```Javascript []\\nvar maxProductDifference = function(nums) {\\n    let min1=1e4,min2=min1,max1=0,max2=0;\\n    for (const num of nums) {\\n        if (num>max1||num>max2) {\\n            max2=Math.max(max1,max2);\\n            max1=num;\\n        }\\n        if (num<min1||num<min2) {\\n            min2=Math.min(min1,min2);\\n            min1=num;\\n        }\\n    }\\n    return max1*max2-min1*min2;\\n};\\n```\\n```TypeScript []\\nfunction maxProductDifference(nums: number[]): number {\\n    let min1=1e4,min2=min1,max1=0,max2=0;\\n    for (const num of nums) {\\n        if (num>max1||num>max2) {\\n            max2=Math.max(max1,max2);\\n            max1=num;\\n        }\\n        if (num<min1||num<min2) {\\n            min2=Math.min(min1,min2);\\n            min1=num;\\n        }\\n    }\\n    return max1*max2-min1*min2;\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Sorting"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        int max1=0,max2=0,min1=INT_MAX,min2=INT_MAX;\\n\\t\\tfor(int i=0;i<nums.size();i++) {\\n            if (nums[i]>max1||nums[i]>max2) {\\n                max2=max(max1,max2);\\n                max1=nums[i];\\n            }\\n            if (nums[i]<min1||nums[i]<min2) {\\n                min2=min(min1,min2);\\n                min1=nums[i];\\n            }\\n        }\\n        return (max1*max2)-(min1*min2);\\n    }\\n};\\n```\n```csharp []\\npublic class Solution {\\n    public int MaxProductDifference(int[] nums){            \\n        int max1=Int32.MinValue,max2=max1,min1=Int32.MaxValue,min2=min1;\\n        for (int i=0;i<nums.Length; i++) {\\n            if (nums[i]>max1||nums[i]>max2) {\\n                max2=Math.Max(max1,max2);\\n                max1=nums[i];\\n            }\\n            if (nums[i]<min1||nums[i]<min2) {\\n                min2=Math.Min(min1,min2);\\n                min1=nums[i];\\n            }\\n        }\\n        return (max1*max2)-(min1*min2);   \\n    }\\n}\\n```\n```java []\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        int max1=0,max2=0,min1=Integer.MAX_VALUE,min2=Integer.MAX_VALUE;\\n\\t\\tfor(int i=0;i<nums.length;i++) {\\n            if (nums[i]>max1||nums[i]>max2) {\\n                max2=Math.max(max1,max2);\\n                max1=nums[i];\\n            }\\n            if (nums[i]<min1||nums[i]<min2) {\\n                min2=Math.min(min1,min2);\\n                min1=nums[i];\\n            }\\n        }\\n        return (max1*max2)-(min1*min2);   \\n    }\\n}\\n```\n```C []\\nint maxProductDifference(int* nums, int numsSize){\\n    int max1=0,max2=0,min1=INT_MAX,min2=INT_MAX;\\n    for(int i=0;i<numsSize;i++) {\\n        if (nums[i]>max1||nums[i]>max2) {\\n            max2=fmax(max1,max2);\\n            max1=nums[i];\\n        }\\n        if (nums[i]<min1||nums[i]<min2) {\\n            min2=fmin(min1,min2);\\n            min1=nums[i];\\n        }\\n    }\\n    return max1*max2-min1*min2;\\n}\\n```\n```Javascript []\\nvar maxProductDifference = function(nums) {\\n    let min1=1e4,min2=min1,max1=0,max2=0;\\n    for (const num of nums) {\\n        if (num>max1||num>max2) {\\n            max2=Math.max(max1,max2);\\n            max1=num;\\n        }\\n        if (num<min1||num<min2) {\\n            min2=Math.min(min1,min2);\\n            min1=num;\\n        }\\n    }\\n    return max1*max2-min1*min2;\\n};\\n```\n```TypeScript []\\nfunction maxProductDifference(nums: number[]): number {\\n    let min1=1e4,min2=min1,max1=0,max2=0;\\n    for (const num of nums) {\\n        if (num>max1||num>max2) {\\n            max2=Math.max(max1,max2);\\n            max1=num;\\n        }\\n        if (num<min1||num<min2) {\\n            min2=Math.min(min1,min2);\\n            min1=num;\\n        }\\n    }\\n    return max1*max2-min1*min2;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299859,
                "title": "c-partial-sort-sort-traverse-nth-element",
                "content": "**1.TC:O(n)**\\n```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        int firstMin=INT_MAX,secondMin=INT_MAX,firstMax=INT_MIN,secondMax=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>firstMax){\\n                secondMax=firstMax;\\n                firstMax=nums[i];\\n            }else if(nums[i]>secondMax){\\n                secondMax=nums[i];\\n            }\\n            if(nums[i]<firstMin){\\n                secondMin=firstMin;\\n                firstMin=nums[i];\\n            }else if(nums[i]<secondMin)\\n                secondMin=nums[i];\\n        }\\n        return (firstMax*secondMax-firstMin*secondMin);\\n    }\\n};\\n```\\n**2.TC:O(nlogn)**\\n```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        return nums[n-1]*nums[n-2]-nums[0]*nums[1];\\n    }\\n};\\n```\\n**3.TC:O(nlog2)**\\n```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        int n=nums.size();\\n        partial_sort(nums.begin(),nums.begin()+2,nums.end());\\n        int firstmin=nums[0],secmin=nums[1];\\n        partial_sort(nums.begin(),nums.begin()+2,nums.end(),greater<int>());\\n        int firstmax=nums[0],secmax=nums[1];\\n        return firstmax*secmax - firstmin*secmin;\\n    }\\n};\\n```\\n**4.TC:O(n)**\\n```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        int n=nums.size();\\n        nth_element(nums.begin(), nums.begin()+1, nums.end());\\n        int firstmin=nums[0],secmin=nums[1];\\n        nth_element(nums.begin(), nums.begin()+1, nums.end(),greater<int>());\\n        int firstmax=nums[0],secmax=nums[1];\\n        return firstmax*secmax - firstmin*secmin;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Interactive"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        int firstMin=INT_MAX,secondMin=INT_MAX,firstMax=INT_MIN,secondMax=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>firstMax){\\n                secondMax=firstMax;\\n                firstMax=nums[i];\\n            }else if(nums[i]>secondMax){\\n                secondMax=nums[i];\\n            }\\n            if(nums[i]<firstMin){\\n                secondMin=firstMin;\\n                firstMin=nums[i];\\n            }else if(nums[i]<secondMin)\\n                secondMin=nums[i];\\n        }\\n        return (firstMax*secondMax-firstMin*secondMin);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        return nums[n-1]*nums[n-2]-nums[0]*nums[1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        int n=nums.size();\\n        partial_sort(nums.begin(),nums.begin()+2,nums.end());\\n        int firstmin=nums[0],secmin=nums[1];\\n        partial_sort(nums.begin(),nums.begin()+2,nums.end(),greater<int>());\\n        int firstmax=nums[0],secmax=nums[1];\\n        return firstmax*secmax - firstmin*secmin;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        int n=nums.size();\\n        nth_element(nums.begin(), nums.begin()+1, nums.end());\\n        int firstmin=nums[0],secmin=nums[1];\\n        nth_element(nums.begin(), nums.begin()+1, nums.end(),greater<int>());\\n        int firstmax=nums[0],secmax=nums[1];\\n        return firstmax*secmax - firstmin*secmin;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383572,
                "title": "two-liner-using-inbuilt-functions",
                "content": "```\\nvar maxProductDifference = function(nums) {\\n    nums= nums.sort((a,b)=> a-b)\\n    let l = nums.length;\\n    return nums[l-1]*nums[l-2] - nums[0]*nums[1]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxProductDifference = function(nums) {\\n    nums= nums.sort((a,b)=> a-b)\\n    let l = nums.length;\\n    return nums[l-1]*nums[l-2] - nums[0]*nums[1]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3210639,
                "title": "easy-to-understand-java-solution-0-ms-beats-100-in-runtime-99-72-in-memory",
                "content": "![image.png](https://assets.leetcode.com/users/images/05faf66a-a7ef-4d39-b58b-7ecda25c7888_1676948589.2442589.png)\\r\\n\\r\\nTime Complexity: O(N)\\r\\nSpace Complexity: O(1)\\r\\n\\r\\n# Approach 1:\\r\\n```\\r\\nclass Solution {\\r\\n    public static int max_numbers(int[] arr, int index){\\r\\n        int max = Integer.MIN_VALUE;\\r\\n        int ind = 0;\\r\\n        for (int i = 0; i < arr.length; i++){\\r\\n            if(arr[i] > max && i != index){\\r\\n                max = arr[i];\\r\\n                ind = i;\\r\\n            }\\r\\n        }\\r\\n        return ind;\\r\\n    }\\r\\n\\r\\n    public static int min_numbers(int[] arr, int index){\\r\\n        int min = Integer.MAX_VALUE;\\r\\n        int ind = 0;\\r\\n        for (int i = 0; i < arr.length; i++){\\r\\n            if(arr[i] < min && i != index){\\r\\n                min = arr[i];\\r\\n                ind = i;\\r\\n            }\\r\\n        }\\r\\n        return ind;\\r\\n    }\\r\\n    \\r\\n    public int maxProductDifference(int[] nums) {\\r\\n        int max1 = max_numbers(nums, -1);\\r\\n        int max2 = max_numbers(nums, max1);\\r\\n        int min1 = min_numbers(nums, -1);\\r\\n        int min2 = min_numbers(nums, min1);\\r\\n        return (nums[max1]*nums[max2]) - (nums[min1]*nums[min2]);    \\r\\n    }\\r\\n}\\r\\n\\r\\n```\\r\\n\\r\\n\\r\\n# Approach 2:\\r\\n```\\r\\nclass Solution{\\r\\n    public int maxProductDifference(int[] nums) {\\r\\n        int max1 = Integer.MIN_VALUE;\\r\\n        int max2 = Integer.MIN_VALUE;\\r\\n        int min1 = Integer.MAX_VALUE;\\r\\n        int min2 = Integer.MAX_VALUE;\\r\\n        for (int i = 0; i < nums.length; i++) {\\r\\n            if (nums[i] > max1) {\\r\\n                max2 = max1;\\r\\n                max1 = nums[i];\\r\\n            } else if (nums[i] > max2) {\\r\\n                max2 = nums[i];\\r\\n            }\\r\\n            if (nums[i] < min1) {\\r\\n                min2 = min1;\\r\\n                min1 = nums[i];\\r\\n            } else if (nums[i] < min2) {\\r\\n                min2 = nums[i];\\r\\n            }\\r\\n        }\\r\\n        return (max1 * max2) - (min1 * min2);\\r\\n    }\\r\\n} \\r\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n    public static int max_numbers(int[] arr, int index){\\r\\n        int max = Integer.MIN_VALUE;\\r\\n        int ind = 0;\\r\\n        for (int i = 0; i < arr.length; i++){\\r\\n            if(arr[i] > max && i != index){\\r\\n                max = arr[i];\\r\\n                ind = i;\\r\\n            }\\r\\n        }\\r\\n        return ind;\\r\\n    }\\r\\n\\r\\n    public static int min_numbers(int[] arr, int index){\\r\\n        int min = Integer.MAX_VALUE;\\r\\n        int ind = 0;\\r\\n        for (int i = 0; i < arr.length; i++){\\r\\n            if(arr[i] < min && i != index){\\r\\n                min = arr[i];\\r\\n                ind = i;\\r\\n            }\\r\\n        }\\r\\n        return ind;\\r\\n    }\\r\\n    \\r\\n    public int maxProductDifference(int[] nums) {\\r\\n        int max1 = max_numbers(nums, -1);\\r\\n        int max2 = max_numbers(nums, max1);\\r\\n        int min1 = min_numbers(nums, -1);\\r\\n        int min2 = min_numbers(nums, min1);\\r\\n        return (nums[max1]*nums[max2]) - (nums[min1]*nums[min2]);    \\r\\n    }\\r\\n}\\r\\n\\r\\n```\n```\\r\\nclass Solution{\\r\\n    public int maxProductDifference(int[] nums) {\\r\\n        int max1 = Integer.MIN_VALUE;\\r\\n        int max2 = Integer.MIN_VALUE;\\r\\n        int min1 = Integer.MAX_VALUE;\\r\\n        int min2 = Integer.MAX_VALUE;\\r\\n        for (int i = 0; i < nums.length; i++) {\\r\\n            if (nums[i] > max1) {\\r\\n                max2 = max1;\\r\\n                max1 = nums[i];\\r\\n            } else if (nums[i] > max2) {\\r\\n                max2 = nums[i];\\r\\n            }\\r\\n            if (nums[i] < min1) {\\r\\n                min2 = min1;\\r\\n                min1 = nums[i];\\r\\n            } else if (nums[i] < min2) {\\r\\n                min2 = nums[i];\\r\\n            }\\r\\n        }\\r\\n        return (max1 * max2) - (min1 * min2);\\r\\n    }\\r\\n} \\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3127035,
                "title": "java-with-without-sorting-explained",
                "content": "---\\n# Please Upvote \\uD83D\\uDE07\\n---\\n## 1. By sorting:\\nWe want the *maximum* and *second maximum* as well as *minimum* and *second minimum*, difference of their product will yield the maximum difference. \\n\\nWe will sort the array.\\n- The max & the second max element will be found at the last and the second last indices of the array respectively.\\n- The min and the second min element will be found at index `0` and index `1` respectively.\\n\\n#### Code:\\n\\n``` java []\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int ab = nums[0] * nums[1];\\n        int cd = nums[n-1] * nums[n-2];\\n        return cd - ab;     // return the product difference\\n    }\\n}\\n\\n// TC: , SC: O(1)\\n```\\n#### Time complexity: $$O(n * logn)$$\\n#### Space complexity: $$O(1)$$\\n---\\n\\n## 2. No sorting:\\nWe will iterate through the array and get our max, second max, min and second min on the go using some simple conditions.\\n\\nLet\\'s say we have an element `i`:\\n1. If `i` is greater than `max`, `max` becomes `second max` and `i` becomes `max`.\\n2. If `i` is greater than `second max` but smaller than `max`, `i` becomes `second max`.\\n3. If `i` is smaller than `min`, `min` becomes `second min` and `i` becomes `min`.\\n4. If `i` is smaller than `second min` but greater than `min`, `i` becomes `second min`.\\n\\n#### Code:\\n``` java []\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        // given: 1 <= nums[i] <= 10000\\n        int max = 0, max2 = 0;\\n        int min = 10001, min2 = 10001;\\n        for (int i : nums) {\\n            if (i > max) {          // 1\\n                max2 = max;\\n                max = i;\\n            } else if (i > max2) {  // 2\\n                max2 = i;\\n            }\\n            if (i < min) {          // 3\\n                min2 = min;\\n                min = i;\\n            } else if (i < min2) {  // 4\\n                min2 = i;\\n            }\\n        }\\n        // return the product difference\\n        return max * max2 - min * min2; \\n    }\\n}\\n```\\n#### Time complexity: $$O(n)$$\\n#### Space complexity: $$O(1)$$",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int ab = nums[0] * nums[1];\\n        int cd = nums[n-1] * nums[n-2];\\n        return cd - ab;     // return the product difference\\n    }\\n}\\n\\n// TC: , SC: O(1)\\n```\n``` java []\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        // given: 1 <= nums[i] <= 10000\\n        int max = 0, max2 = 0;\\n        int min = 10001, min2 = 10001;\\n        for (int i : nums) {\\n            if (i > max) {          // 1\\n                max2 = max;\\n                max = i;\\n            } else if (i > max2) {  // 2\\n                max2 = i;\\n            }\\n            if (i < min) {          // 3\\n                min2 = min;\\n                min = i;\\n            } else if (i < min2) {  // 4\\n                min2 = i;\\n            }\\n        }\\n        // return the product difference\\n        return max * max2 - min * min2; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732572,
                "title": "in-case-you-need-short-js-solution",
                "content": "// The way this problem is setup, it overlooks a lot of possible cases that makes this problem more challenging (like including negative numbers). \\n// But this solution will pass all the test cases for this problem.\\n\\n```\\nvar maxProductDifference = function(nums) {\\n    nums.sort((a,b) => a-b);\\n    return nums.slice(nums.length - 2).reduce((a,b) => a*b, 1) - nums.slice(0, 2).reduce((a,b) => a*b, 1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxProductDifference = function(nums) {\\n    nums.sort((a,b) => a-b);\\n    return nums.slice(nums.length - 2).reduce((a,b) => a*b, 1) - nums.slice(0, 2).reduce((a,b) => a*b, 1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1305508,
                "title": "java-easy",
                "content": "class Solution {\\n    public int maxProductDifference(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        return (nums[nums.length - 1] * nums[nums.length - 2])-(nums[0] * nums[1]);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxProductDifference(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        return (nums[nums.length - 1] * nums[nums.length - 2])-(nums[0] * nums[1]);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1299594,
                "title": "c-solution-using-sorting",
                "content": "class Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int diff=nums[nums.size()-1]*nums[nums.size()-2];\\n        diff-=nums[0]*nums[1];\\n        return diff;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int diff=nums[nums.size()-1]*nums[nums.size()-2];\\n        diff-=nums[0]*nums[1];\\n        return diff;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1299873,
                "title": "javascript-o-n-time-o-1-space-solution-without-sorting",
                "content": "We don\\'t need to completly sort the input array - it is enough to keep track of the 2 smallest / largest numbers:\\n\\n```\\nvar maxProductDifference = function(nums) {\\n    \\n    let min = 1e4, prevMin = min;\\n    let max = 0, prevMax = 0;\\n    \\n    for (const n of nums) {\\n        \\n        if (n > max) {\\n            prevMax = max;\\n            max = n;\\n        } else if (n > prevMax) {\\n            prevMax = n;\\n        }\\n        \\n        if (n < min) {\\n            prevMin = min;\\n            min = n;\\n        } else if (n < prevMin) {\\n            prevMin = n;\\n        }\\n    }\\n    \\n    return max*prevMax - min*prevMin;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxProductDifference = function(nums) {\\n    \\n    let min = 1e4, prevMin = min;\\n    let max = 0, prevMax = 0;\\n    \\n    for (const n of nums) {\\n        \\n        if (n > max) {\\n            prevMax = max;\\n            max = n;\\n        } else if (n > prevMax) {\\n            prevMax = n;\\n        }\\n        \\n        if (n < min) {\\n            prevMin = min;\\n            min = n;\\n        } else if (n < prevMin) {\\n            prevMin = n;\\n        }\\n    }\\n    \\n    return max*prevMax - min*prevMin;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1300402,
                "title": "c-16ms-99-38-time-o-n-clean-one-pass-solution",
                "content": "Runtime: 16 ms, faster than 99.38% of C++ online submissions for Maximum Product Difference Between Two Pairs.\\nMemory Usage: 20.3 MB, less than 62.17% of C++ online submissions for Maximum Product Difference Between Two Pairs.\\n\\n```\\nclass Solution {\\npublic:\\n  int maxProductDifference(vector<int>& nums){\\n    sort(nums.begin(), nums.begin() + 4);              //sorting ONLY FIRST FOUR NUMBERS               \\n    int mm = nums[0], m = nums[1], M = nums[2], MM = nums[3];\\n    \\n    for(int i = 4; i != nums.size(); i++)\\n      if     (nums[i] >= MM) M = MM, MM = nums[i];     //for case: mm , m , M, MM, number , else =>\\n      else if(nums[i] >   M)          M = nums[i];     //for case: mm , m , M, number, MM , else =>\\n      else if(nums[i] <= mm) m = mm, mm = nums[i];     //for case: number, mm , m , M, MM , else =>\\n      else if(nums[i] <   m)          m = nums[i];     //for case: mm , number, m , M, MM \\n    \\n    return MM*M - mm*m;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int maxProductDifference(vector<int>& nums){\\n    sort(nums.begin(), nums.begin() + 4);              //sorting ONLY FIRST FOUR NUMBERS               \\n    int mm = nums[0], m = nums[1], M = nums[2], MM = nums[3];\\n    \\n    for(int i = 4; i != nums.size(); i++)\\n      if     (nums[i] >= MM) M = MM, MM = nums[i];     //for case: mm , m , M, MM, number , else =>\\n      else if(nums[i] >   M)          M = nums[i];     //for case: mm , m , M, number, MM , else =>\\n      else if(nums[i] <= mm) m = mm, mm = nums[i];     //for case: number, mm , m , M, MM , else =>\\n      else if(nums[i] <   m)          m = nums[i];     //for case: mm , number, m , M, MM \\n    \\n    return MM*M - mm*m;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1300311,
                "title": "simple-o-n-time-solution-with-explanation-code-in-python",
                "content": "The maximum product difference of an array can be found by subtracting product of the 2 largest numbers of the array from the product of the 2 smallest.\\nIn the following code, the `max1` and `max2` variables are for 2 largest number from the input list while `min1` and `min2` are for the 2 smallest. More specifically `max1` will be the largest number and `max2` will be the 2nd largest while `min1` will be the smallest and `min2` will be the 2nd smallest.\\n\\nFirst we set max1 and max2 to the smallest possible number  (negative infinity) and min1 and min2 to the largest possible number (infinity) (which is standard practice for finding largest/smallest value from a collection of values.\\n\\nNext we iterate over the input array and for each number we do two things:\\n1) check if its larger than max1; if it is then we move the current max1 value down to max2 and set max1 to the current number. If the number isnt larger than max1 then we check if its larger than max2 (but still not larger than max1 ofcourse), and if it is we set max2 to that number\\n\\n2) check if its smaller than min1; if it is then we move the current min1 value down to min2 and set min1 to the current number. If the number isnt smaller than min1 then we check if its smaller than min2 (but still not smaller than min1 ofcourse),and if it is we set min2 to that number\\n\\nIn the end (after the loop) we just return the product of max1 and max2 minus the product of min1 and min2.\\n\\n```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        # max1 > max 2\\n        # min1 < min2\\n        \\n        max1 = max2 = float(\"-inf\")\\n        min1 = min2 = float(\"inf\")\\n        \\n        for num in nums:\\n            if num > max1:\\n                max2 = max1\\n                max1 = num\\n            elif num > max2:\\n                max2 = num\\n                \\n            if num < min1:\\n                min2 = min1\\n                min1 = num\\n            elif num < min2:\\n                min2 = num\\n                \\n        return (max1 * max2) - (min1 * min2)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        # max1 > max 2\\n        # min1 < min2\\n        \\n        max1 = max2 = float(\"-inf\")\\n        min1 = min2 = float(\"inf\")\\n        \\n        for num in nums:\\n            if num > max1:\\n                max2 = max1\\n                max1 = num\\n            elif num > max2:\\n                max2 = num\\n                \\n            if num < min1:\\n                min2 = min1\\n                min1 = num\\n            elif num < min2:\\n                min2 = num\\n                \\n        return (max1 * max2) - (min1 * min2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396739,
                "title": "very-easy-to-understand-2-line-c-code",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe product of the last two elements of a increasingly sorted array has the maximum product and the product of the first two elements of the sorted array has the minimum product. And their difference is the answer.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogn)$$ \\n\\n--> Time complexity of the STL function sort() is **\" nlogn \"**\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return ((nums[nums.size()-1]*nums[nums.size()-2])-(nums[0]*nums[1]));\\n    }\\n};\\n```\\n# Please Upvote if you liked it \\u2B06\\uFE0F",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return ((nums[nums.size()-1]*nums[nums.size()-2])-(nums[0]*nums[1]));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176791,
                "title": "beats-91-51-maximum-product-difference-between-two-pairs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-Sort the array - use reverse it will sort in reverse order\\n-nums[0] gives the first element\\n-nums[1] gives the second element\\n-nums[-2] gives the second last element\\n-nums[-1] gives the last element\\n-return there product difference.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        print(nums)\\n        return nums[0]*nums[1]-nums[-2]*nums[-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        print(nums)\\n        return nums[0]*nums[1]-nums[-2]*nums[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677771,
                "title": "simple-solution-and-easy-you-understand",
                "content": "```\\n//This is Java \\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        \\n        int left = nums[0] * nums[1];\\n        int rigth = nums[nums.length-1] * nums[nums.length-2];\\n        \\n        int res = rigth - left;\\n        \\n        return res;\\n    }\\n}\\n\\n//This is Golang\\nfunc maxProductDifference(nums []int) int {\\n    sort.Ints(nums)\\n    \\n    left := nums[0] * nums[1]\\n    rigth := nums[len(nums)-1] * nums[len(nums)-2]\\n    \\n    res := rigth - left\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Go"
                ],
                "code": "```\\n//This is Java \\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        \\n        int left = nums[0] * nums[1];\\n        int rigth = nums[nums.length-1] * nums[nums.length-2];\\n        \\n        int res = rigth - left;\\n        \\n        return res;\\n    }\\n}\\n\\n//This is Golang\\nfunc maxProductDifference(nums []int) int {\\n    sort.Ints(nums)\\n    \\n    left := nums[0] * nums[1]\\n    rigth := nums[len(nums)-1] * nums[len(nums)-2]\\n    \\n    res := rigth - left\\n    \\n    return res\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2643142,
                "title": "js-one-liner-easy-to-understand",
                "content": "```\\nvar maxProductDifference = function(nums) {\\n    nums.sort((a,b) => a-b);\\n    return -((nums[0] * nums[1]) - (nums[nums.length-1] * nums[nums.length-2]));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxProductDifference = function(nums) {\\n    nums.sort((a,b) => a-b);\\n    return -((nums[0] * nums[1]) - (nums[nums.length-1] * nums[nums.length-2]));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1454440,
                "title": "python-java-2-lines-code",
                "content": "Python:\\n```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        nums=sorted(nums)\\n        return ((nums[len(nums)-1]*nums[len(nums)-2])-(nums[0]*nums[1]))\\n```\\nJava:\\n```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        return ((nums[nums.length-1]*nums[nums.length-2])-(nums[0]*nums[1]));    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        nums=sorted(nums)\\n        return ((nums[len(nums)-1]*nums[len(nums)-2])-(nums[0]*nums[1]))\\n```\n```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        return ((nums[nums.length-1]*nums[nums.length-2])-(nums[0]*nums[1]));    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395138,
                "title": "java-2-approaches-do-checkout",
                "content": "**Do vote up if you like it :)**\\nTC : O(N)\\n```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        int n = nums.length;\\n        int min = Integer.MAX_VALUE;\\n        int secmin = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        int secmax = Integer.MIN_VALUE;\\n        \\n        for(int i = 0; i < n; i++) {\\n            \\n            //Checking for min and secmin\\n            if(nums[i] < min) {              //item smaller than min, hence both min and secmin gets updated\\n                secmin = min;\\n                min = nums[i];\\n            }\\n            else if(nums[i] < secmin) {     //item greater than min but item smaller than secmin\\n                secmin = nums[i];\\n            }\\n            \\n            \\n            //Checking for max and secmax\\n            if(nums[i] > max) {             //item greater than max, hence both max and secmax gets updated\\n                secmax = max;\\n                max = nums[i];\\n            }\\n            else if(nums[i] > secmax) {     //item smaller than max but item greater than secmax\\n                secmax = nums[i];\\n            }\\n        }    \\n        return max * secmax - min * secmin; \\n    }\\n}\\n```\\n-------------------------------------------------------------\\nTC : O(NlogN)\\n```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        return nums[n - 1] * nums[n - 2] - nums[0] * nums[1]; \\n    }\\n}\\n```\\n-------------------------------------------------------------",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        int n = nums.length;\\n        int min = Integer.MAX_VALUE;\\n        int secmin = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        int secmax = Integer.MIN_VALUE;\\n        \\n        for(int i = 0; i < n; i++) {\\n            \\n            //Checking for min and secmin\\n            if(nums[i] < min) {              //item smaller than min, hence both min and secmin gets updated\\n                secmin = min;\\n                min = nums[i];\\n            }\\n            else if(nums[i] < secmin) {     //item greater than min but item smaller than secmin\\n                secmin = nums[i];\\n            }\\n            \\n            \\n            //Checking for max and secmax\\n            if(nums[i] > max) {             //item greater than max, hence both max and secmax gets updated\\n                secmax = max;\\n                max = nums[i];\\n            }\\n            else if(nums[i] > secmax) {     //item smaller than max but item greater than secmax\\n                secmax = nums[i];\\n            }\\n        }    \\n        return max * secmax - min * secmin; \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        return nums[n - 1] * nums[n - 2] - nums[0] * nums[1]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1321423,
                "title": "2-lines-of-code-faster-than-78-26-of-c-online-submissions",
                "content": "```\\n int maxProductDifference(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return nums[nums.size()-1]*nums[nums.size()-2]-nums[0]*nums[1];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int maxProductDifference(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return nums[nums.size()-1]*nums[nums.size()-2]-nums[0]*nums[1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1311891,
                "title": "java-solution-shortest-code-beats-80-submissions",
                "content": "Code :\\n\\n```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        \\n\\t\\t//To Sort the array\\n        Arrays.sort(nums);\\n        \\n\\t\\t//Taking 2 maximum and minimum numbers\\n        return (nums[nums.length-1]*nums[nums.length-2]) - (nums[0]*nums[1]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        \\n\\t\\t//To Sort the array\\n        Arrays.sort(nums);\\n        \\n\\t\\t//Taking 2 maximum and minimum numbers\\n        return (nums[nums.length-1]*nums[nums.length-2]) - (nums[0]*nums[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299728,
                "title": "1913-return-largest-second-largest-smallest-second-smallest",
                "content": "---\\n\\n**Algo**\\n- Sort the numbers in ascending order\\n  - First two are the1st and 2nd smallest,  say `s1`, `s2`,  these are `[0]` and `[1]` elements in array\\n  - Last two are the 1st and 2nd largest, say `L1`, `L2`,  these are `[n-1]` and `[n-2]` elements in array\\n- Multiply largest ones  `L1 * L2`\\n- Multiply smallest ones `s1 * s2`\\n- Return their substraction result:   `L1 * L2  -  s1 * s2`\\n  - This produces the `maximum` of `product difference`\\n\\nHope it is simple to understand.\\n\\n---\\n\\n```\\nvar maxProductDifference = function(A) {\\n    let n = A.length;\\n\\n    A.sort((a, b) => a - b);\\n    return (A[n - 1] * A[n - 2]) - (A[0] * A[1])\\n};\\n```\\n\\n**100ms**\\n\\n![image](https://assets.leetcode.com/users/images/cf3af89b-04a6-480a-870d-66608e4fa409_1624770274.3186524.png)\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxProductDifference = function(A) {\\n    let n = A.length;\\n\\n    A.sort((a, b) => a - b);\\n    return (A[n - 1] * A[n - 2]) - (A[0] * A[1])\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3596652,
                "title": "easy-c-solution",
                "content": "class Solution {\\npublic:\\n\\n    int maxProductDifference(vector<int>& nums) {\\n        int max1=0; \\n\\t\\tint max2=0;\\n        for(int i=0;i<nums.size();i++){\\n             if(nums[i]>max1){\\n              max1=nums[i];  \\n\\t\\t       }\\n\\t     }\\n        int count = 0 ;\\n        for(int i=0 ; i<nums.size();i++){\\n            if(nums[i]==max1){\\n                count++;\\n                }\\n        }\\n        if(count!=1){\\n            max2=max1;\\n        }\\n       else {\\n\\t         for(int i=0;i<nums.size();i++){\\n             if(nums[i]>max2 && nums[i]<max1){\\n              max2=nums[i];   }\\n\\t\\t\\t  }\\n\\t  }\\n       int min1=INT_MAX; int min2=INT_MAX ;\\n        for(int i=0;i<nums.size() ;i++){\\n            if(nums[i]<min1){\\n                min1=nums[i];\\n            }\\n        }\\n        int count2 = 0 ; \\n        for(int i=0 ;i<nums.size() ;i++){\\n            if(nums[i]==min1) count2++;\\n        }\\n        if(count2!=1){\\n            min2 = min1 ; \\n        }\\n        else {\\n            for(int i=0 ; i<nums.size() ;i++){\\n                if(nums[i]<min2 && nums[i]>min1){\\n                 min2=nums[i];}\\n            }\\n        }\\n        return max1*max2 - min1*min2;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int maxProductDifference(vector<int>& nums) {\\n        int max1=0; \\n\\t\\tint max2=0;\\n        for(int i=0;i<nums.size();i++){\\n             if(nums[i]>max1){\\n              max1=nums[i];  \\n\\t\\t       }",
                "codeTag": "Java"
            },
            {
                "id": 3498691,
                "title": "excellent-logic-using-sort-in-java",
                "content": "\\n\\n#  Superb Logic in java\\n```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        int n =nums.length;\\n    return nums[n-1]*nums[n-2]-nums[0]*nums[1];\\n    }\\n}\\n```\\n# please upvote me it would encourages me so much",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        int n =nums.length;\\n    return nums[n-1]*nums[n-2]-nums[0]*nums[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287321,
                "title": "o-n-log-n-solution-just-only-4-lines-of-code-beginner-friendly-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int max = nums[n-1]*nums[n-2]- nums[0]*nums[1];\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int max = nums[n-1]*nums[n-2]- nums[0]*nums[1];\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206511,
                "title": "2-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums[nums.length-1]*nums[nums.length-2]-nums[0]*nums[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums[nums.length-1]*nums[nums.length-2]-nums[0]*nums[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013513,
                "title": "q1913-accepted-c-o-n-without-sorting-easiest-simple",
                "content": "CRUX\\n1) We calculate max 2 elements and min 2 elements.\\n2) *max1max2 -min1min2* is the answer\\n3) It could be done by sorting but the time complexity would be (n*logn)\\n```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        int max1=INT_MIN,max2=INT_MIN;\\n        int min1=INT_MAX,min2=INT_MAX;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>max1){ // Largest Element\\n                max2=max1;\\n                max1=nums[i];\\n            }\\n            else if(nums[i]>max2) // 2nd Larget Element\\n                max2=nums[i];\\n            if(nums[i]<min1){ // Smallest Element\\n                min2=min1;\\n                min1=nums[i];\\n            }\\n            else if(nums[i]<min2) // 2nd Smallest Element\\n                min2=nums[i];\\n        }\\n        return max1*max2-min1*min2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        int max1=INT_MIN,max2=INT_MIN;\\n        int min1=INT_MAX,min2=INT_MAX;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>max1){ // Largest Element\\n                max2=max1;\\n                max1=nums[i];\\n            }\\n            else if(nums[i]>max2) // 2nd Larget Element\\n                max2=nums[i];\\n            if(nums[i]<min1){ // Smallest Element\\n                min2=min1;\\n                min1=nums[i];\\n            }\\n            else if(nums[i]<min2) // 2nd Smallest Element\\n                min2=nums[i];\\n        }\\n        return max1*max2-min1*min2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2908536,
                "title": "java-simple-one-line-solution-easy-understanding",
                "content": "Java one line code\\n# Code\\n```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums[nums.length-1]*nums[nums.length-2]-nums[0]*nums[1];\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums[nums.length-1]*nums[nums.length-2]-nums[0]*nums[1];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2822079,
                "title": "python-96-20-faster-2-lines-sorting",
                "content": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return (nums[-1]*nums[-2])-(nums[0]*nums[1])\\n```\\n\\n**Upvote if you like the solution or ask if there is any query**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return (nums[-1]*nums[-2])-(nums[0]*nums[1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791491,
                "title": "just-2-line-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n        return (nums[nums.size()-1]*nums[nums.size()-2])-(nums[0]*nums[1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n        return (nums[nums.size()-1]*nums[nums.size()-2])-(nums[0]*nums[1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663309,
                "title": "python-basic",
                "content": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        return nums[0]*nums[1]-nums[-1]*nums[-2]",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        return nums[0]*nums[1]-nums[-1]*nums[-2]",
                "codeTag": "Java"
            },
            {
                "id": 2650831,
                "title": "java-easy-2-liner",
                "content": "# Please Upvote\\n\\n```\\n\\t\\tArrays.sort(nums);\\n        return nums[nums.length - 1] * nums[nums.length - 2] - nums[0] * nums[1];\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\n\\t\\tArrays.sort(nums);\\n        return nums[nums.length - 1] * nums[nums.length - 2] - nums[0] * nums[1];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2597292,
                "title": "c-fastest-easiest-solution-for-begineers",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        return (nums[nums.size()-1]*nums[nums.size()-2]) - (nums[0]*nums[1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        return (nums[nums.size()-1]*nums[nums.size()-2]) - (nums[0]*nums[1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592312,
                "title": "java-o-n-time-beats-99-runtime-and-memory-usage-without-sorting",
                "content": "Why sorting is not required? **Arrays.sort in JAVA takes O(nlogn) time**. But what we need is the largest, second-largest, the smallest and the second-smallest element, hence, when consider an array of size 10^4 (Maximum constraint), what will we do by sorting all of the elements when we have the **use of only 4 elements**?\\n\\nHence, the solution given below first uses a for loop to find the **maximum and the minimum element in O(n) time**, also noting the indices of the elements (indmx and indmn).\\n\\nNextly, we again run **another for loop** to find the second largest and second smallest elements in the array, by avoiding comparison operation at the indmx and inmdn indices for **2nd max and 2nd min element** respectively.\\n\\nHence, by **using 2 for loops with O(n) time complexity**, we can complete our work optimally. The result:\\n\\n![image](https://assets.leetcode.com/users/images/d0726f31-8118-442b-961e-a4ac46ad872e_1663496026.5537457.png)\\n\\n\\nAnd the code:\\n\\n```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        int max1,min1,indmx=0,indmn=0;\\n        max1=min1=nums[0];\\n        for(int i=0;i<nums.length;i++){\\n            if(max1<nums[i]){\\n                indmx=i;\\n                max1=nums[i];\\n            }\\n            if(min1>nums[i]){\\n                indmn=i;\\n                min1=nums[i];\\n            }\\n        }\\n        int max2=0, min2 = 10001;\\n        for(int i=0;i<nums.length;i++){\\n            if(i!=indmx){\\n                max2=Math.max(max2,nums[i]);\\n            }\\n            if(i!=indmn){\\n                min2=Math.min(min2,nums[i]);\\n            }\\n        }\\n        return max2*max1-min2*min1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        int max1,min1,indmx=0,indmn=0;\\n        max1=min1=nums[0];\\n        for(int i=0;i<nums.length;i++){\\n            if(max1<nums[i]){\\n                indmx=i;\\n                max1=nums[i];\\n            }\\n            if(min1>nums[i]){\\n                indmn=i;\\n                min1=nums[i];\\n            }\\n        }\\n        int max2=0, min2 = 10001;\\n        for(int i=0;i<nums.length;i++){\\n            if(i!=indmx){\\n                max2=Math.max(max2,nums[i]);\\n            }\\n            if(i!=indmn){\\n                min2=Math.min(min2,nums[i]);\\n            }\\n        }\\n        return max2*max1-min2*min1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2562263,
                "title": "beginner-friendly-simple-java-code",
                "content": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        int i=0,j=nums.length -1;\\n         int d= nums[j]*nums[j-1];\\n        int e=nums[i]*nums[i+1];\\n        return d-e;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        int i=0,j=nums.length -1;\\n         int d= nums[j]*nums[j-1];\\n        int e=nums[i]*nums[i+1];\\n        return d-e;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544273,
                "title": "runtime-33-ms-faster-than-90-49-of-c-online-submissions",
                "content": "```\\n\\n/*** 1913. Maximum Product Difference Between Two Pairs - CPP17 ***/\\n\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        //sorting the vector\\n        sort(nums.begin(),nums.end());\\n        int a = nums[0];\\n        int b = nums[1];\\n        int c = nums[nums.size()-1];\\n        int d = nums[nums.size()-2];\\n        \\n        return (c*d)-(a*b);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\n\\n/*** 1913. Maximum Product Difference Between Two Pairs - CPP17 ***/\\n\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        //sorting the vector\\n        sort(nums.begin(),nums.end());\\n        int a = nums[0];\\n        int b = nums[1];\\n        int c = nums[nums.size()-1];\\n        int d = nums[nums.size()-2];\\n        \\n        return (c*d)-(a*b);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2305410,
                "title": "python-3-o-n-solution",
                "content": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        max_1 = 0\\n        max_2 = 0\\n        min_1 = 10001\\n        min_2 = 10001\\n        for i in nums:\\n            if i >= max_1:\\n                max_2,max_1 = max_1,i\\n            elif i > max_2:\\n                max_2 = i\\n            if i <= min_1:\\n                min_2,min_1 = min_1,i\\n            elif i < min_2:\\n                min_2 = i\\n            \\n        return max_1*max_2 - min_1*min_2\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        max_1 = 0\\n        max_2 = 0\\n        min_1 = 10001\\n        min_2 = 10001\\n        for i in nums:\\n            if i >= max_1:\\n                max_2,max_1 = max_1,i\\n            elif i > max_2:\\n                max_2 = i\\n            if i <= min_1:\\n                min_2,min_1 = min_1,i\\n            elif i < min_2:\\n                min_2 = i\\n            \\n        return max_1*max_2 - min_1*min_2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2275935,
                "title": "python-easy-solution-by-very-python-beginner",
                "content": "If you like this solution, **UPVOTE** !\\uD83C\\uDF38\\n\\nExplanation:\\n\\n- \"a\" should be the largest and \"b\" should be the 2nd largest number\\n- \"c\" should be the smallest and \"d\" should be the 2nd smallest one\\n\\n1. Choose the largest one and remove it from List nums.\\n2. Choose the 2nd largest one and remove it from List nums.\\n3. Iterate this process on \"c\" and \"d\".\\n\\n```\\n\\t\\ta = max(nums)\\n        nums.remove(a)\\n        b = max(nums)\\n        nums.remove(b)\\n        \\n        c = min(nums)\\n        nums.remove(c)\\n        d = min(nums)\\n        \\n        return (a*b) - (c*d)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\t\\ta = max(nums)\\n        nums.remove(a)\\n        b = max(nums)\\n        nums.remove(b)\\n        \\n        c = min(nums)\\n        nums.remove(c)\\n        d = min(nums)\\n        \\n        return (a*b) - (c*d)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2069383,
                "title": "super-easy-python-max-min-remove",
                "content": "```\\nclass Solution(object):\\n    def maxProductDifference(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        a = max(nums)\\n        nums.remove(a)\\n        b = max(nums)\\n        \\n        c = min(nums)\\n        nums.remove(c)\\n        d = min(nums)\\n        \\n        return (a * b) - (c * d)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxProductDifference(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        a = max(nums)\\n        nums.remove(a)\\n        b = max(nums)\\n        \\n        c = min(nums)\\n        nums.remove(c)\\n        d = min(nums)\\n        \\n        return (a * b) - (c * d)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870128,
                "title": "python-easy-solution-using-max-and-min-functions",
                "content": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        max_num = nums.pop(nums.index(max(nums)))\\n        max_num2 = nums.pop(nums.index(max(nums)))\\n        min_num = nums.pop(nums.index(min(nums)))\\n        min_num2 = nums.pop(nums.index(min(nums)))\\n        return (max_num * max_num2) - (min_num * min_num2)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        max_num = nums.pop(nums.index(max(nums)))\\n        max_num2 = nums.pop(nums.index(max(nums)))\\n        min_num = nums.pop(nums.index(min(nums)))\\n        min_num2 = nums.pop(nums.index(min(nums)))\\n        return (max_num * max_num2) - (min_num * min_num2)",
                "codeTag": "Java"
            },
            {
                "id": 1853530,
                "title": "3-different-ways-to-solve-this-problem",
                "content": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        // Arrays.sort(nums);\\n        // return nums[nums.length-1]*nums[nums.length-2]-nums[0]*nums[1];\\n        \\n```\\n        \\n\\t//2nd method\\n//         int max1=Integer.MIN_VALUE,min1=Integer.MAX_VALUE;\\n//         int max2=max1,min2=min1;\\n\\n//         for(int i=0;i<nums.length;i++){\\n//             if(max1<nums[i]){\\n//                 max2=max1;\\n//                 max1=nums[i];\\n//             }else if(nums[i]>max2){\\n//                 max2=nums[i];\\n//             } if(nums[i]<min1){\\n//                 min2=min1;\\n//                 min1=nums[i];\\n//             }\\n//             else if(nums[i]<min2){\\n//                 min2=nums[i];\\n//             }\\n//         }\\n//         return (max1*max2)-(min1*min2);\\n\\n\\t//3rd finding max min in an array go for heap\\n        \\n        var maxheap=new PriorityQueue<Integer>(3);\\n        var minheap=new PriorityQueue<Integer>(3,(i1,i2)->i2>i1?1:i1>i2?-1:0);\\n        for(var v:nums){\\n            addToHeap(maxheap,v);\\n            addToHeap(minheap,v);\\n        }\\n        return maxheap.poll()*maxheap.poll()-minheap.poll()*minheap.poll();\\n    }\\n    private void addToHeap(PriorityQueue<Integer> heap,int n){\\n        heap.add(n);\\n        if(heap.size()>2){\\n            \\n            heap.poll();\\n        }\\n    }\\n        \\n        \\n    \\n}",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Go"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        // Arrays.sort(nums);\\n        // return nums[nums.length-1]*nums[nums.length-2]-nums[0]*nums[1];\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845605,
                "title": "c-2-lines-100-fast",
                "content": "```\\n   int maxProductDifference(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n         return (nums[nums.size()-1] * nums[nums.size()-2] - (nums[0]*nums[1]));\\n    }",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\n   int maxProductDifference(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n         return (nums[nums.size()-1] * nums[nums.size()-2] - (nums[0]*nums[1]));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1793215,
                "title": "easy-2-line-code-simple",
                "content": "```\\n        nums.sort()\\n        return ((nums[-1]*nums[-2]) - nums[0]*nums[1])\\n```\\nIF THIS HELP U KINDLY UPVOTE THIS TO HELP OTHERS TO GET THIS SOLUTION\\nIF U HAVE ANYPROBELM KINDLY COMMENT.. FEEL FREE TO ASK ANS UPVOTE\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n        nums.sort()\\n        return ((nums[-1]*nums[-2]) - nums[0]*nums[1])\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1778264,
                "title": "2-line-code-c",
                "content": "# **AN UPVOTE WOULD BE HIGHLY APPRECIATED**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return ((nums[nums.size()-1]*(nums[nums.size()-2]))-(nums[0]*nums[1]));\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return ((nums[nums.size()-1]*(nums[nums.size()-2]))-(nums[0]*nums[1]));\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661463,
                "title": "easiest-python-solution",
                "content": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return ((nums[-1]*nums[-2])-(nums[0]*nums[1]))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return ((nums[-1]*nums[-2])-(nums[0]*nums[1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645568,
                "title": "o-nlog2-solution",
                "content": "The idea is to use two priority queues (min/max heap).\\n\\nIn C++, you can construct a fixed size heap (see https://en.cppreference.com/w/cpp/container/priority_queue/priority_queue) of size 2. We perform N pushes, and pop element whenever the size of heap is greater than 2. Your heap will use an O(2) memory. The time-complexity is therefore going to be O(N log2)~O(N) because you are performing N pushes, and each push operation has time-complexity which is logarithmic in the size of heap (https://en.cppreference.com/w/cpp/container/priority_queue/push).\\n\\n```\\nint maxProductDifference(vector<int>& nums) {\\n    priority_queue<int, vector<int>, less<int>> pq1;\\n    priority_queue<int, vector<int>, greater<int>> pq2;\\n\\n    for(auto num: nums) {\\n        pq1.push(num);\\n        if(pq1.size()>2) { pq1.pop(); }\\n\\n        pq2.push(num);\\n        if(pq2.size()>2) { pq2.pop(); }            \\n    }\\n\\n    auto a=pq1.top(); pq1.pop();\\n    auto b=pq2.top(); pq2.pop();\\n    return pq2.top()*b-pq1.top()*a;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maxProductDifference(vector<int>& nums) {\\n    priority_queue<int, vector<int>, less<int>> pq1;\\n    priority_queue<int, vector<int>, greater<int>> pq2;\\n\\n    for(auto num: nums) {\\n        pq1.push(num);\\n        if(pq1.size()>2) { pq1.pop(); }\\n\\n        pq2.push(num);\\n        if(pq2.size()>2) { pq2.pop(); }            \\n    }\\n\\n    auto a=pq1.top(); pq1.pop();\\n    auto b=pq2.top(); pq2.pop();\\n    return pq2.top()*b-pq1.top()*a;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1427535,
                "title": "c-two-simple-solutions-o-nlogn-2-lines-o-n-short-and-clean",
                "content": "**Solution I:**\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(1)\\n```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        int mx1 = 0, mx2 = 0, mn1 = INT_MAX, mn2 = INT_MAX;\\n        for (auto num : nums) {\\n            if (num > mx1) {\\n                mx2 = mx1;\\n                mx1 = num;\\n            }\\n            else if (num > mx2) mx2 = num;\\n            \\n            if (num < mn1) {\\n                mn2 = mn1;\\n                mn1 = num;\\n            }\\n            else if (num < mn2) mn2 = num;\\n        }\\n        \\n        return abs(mx1 * mx2 - mn1 * mn2);\\n    }\\n};\\n```\\n****\\n**Solution II:**\\n**Time Complexity:** O(nlogn)\\n**Space Complexity:** O(1)\\n```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        return abs((nums[0] * nums[1]) - (nums[nums.size()-1] * nums[nums.size()-2]));\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        int mx1 = 0, mx2 = 0, mn1 = INT_MAX, mn2 = INT_MAX;\\n        for (auto num : nums) {\\n            if (num > mx1) {\\n                mx2 = mx1;\\n                mx1 = num;\\n            }\\n            else if (num > mx2) mx2 = num;\\n            \\n            if (num < mn1) {\\n                mn2 = mn1;\\n                mn1 = num;\\n            }\\n            else if (num < mn2) mn2 = num;\\n        }\\n        \\n        return abs(mx1 * mx2 - mn1 * mn2);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        return abs((nums[0] * nums[1]) - (nums[nums.size()-1] * nums[nums.size()-2]));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403047,
                "title": "c-90-90",
                "content": "```\\nint maxProductDifference(int* nums, int numsSize){\\n    // find 4 numbers, 2 largest (A, B) and 2 smallest (C, D)\\n    // the maximum product difference is always (AB) - (CD)\\n    \\n    int larger, largest, smaller, smallest;\\n    int i, j;\\n    larger = largest = 0;\\n    smaller = smallest = 10001;\\n    \\n    for(i=0; i<numsSize; i++) {\\n        j = nums[i];\\n        \\n        if (j > largest) {\\n            larger = largest;\\n            largest = j;\\n        } else if (j > larger) {\\n            larger = j;\\n        }\\n        \\n        if (j < smallest) {\\n            smaller = smallest;\\n            smallest = j;\\n        } else if (j < smaller) {\\n            smaller = j;\\n        }\\n        \\n        \\n    }\\n        \\n    return ( (larger * largest) - (smaller * smallest) );\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maxProductDifference(int* nums, int numsSize){\\n    // find 4 numbers, 2 largest (A, B) and 2 smallest (C, D)\\n    // the maximum product difference is always (AB) - (CD)\\n    \\n    int larger, largest, smaller, smallest;\\n    int i, j;\\n    larger = largest = 0;\\n    smaller = smallest = 10001;\\n    \\n    for(i=0; i<numsSize; i++) {\\n        j = nums[i];\\n        \\n        if (j > largest) {\\n            larger = largest;\\n            largest = j;\\n        } else if (j > larger) {\\n            larger = j;\\n        }\\n        \\n        if (j < smallest) {\\n            smaller = smallest;\\n            smallest = j;\\n        } else if (j < smaller) {\\n            smaller = j;\\n        }\\n        \\n        \\n    }\\n        \\n    return ( (larger * largest) - (smaller * smallest) );\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1357441,
                "title": "swift-variant-of-solution",
                "content": "*<- Please vote if my solution was helpful to you.*\\n```\\nclass Solution {\\n\\tfunc maxProductDifference(_ nums: [Int]) -> Int {\\n\\t\\tlet sortedNums = nums.sorted()\\n        let biggestPairValue = sortedNums[sortedNums.count-1] * sortedNums[sortedNums.count-2]\\n        let smallestPairValue =  sortedNums[0] * sortedNums[1]\\n\\t\\treturn biggestPairValue - smallestPairValue\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\tfunc maxProductDifference(_ nums: [Int]) -> Int {\\n\\t\\tlet sortedNums = nums.sorted()\\n        let biggestPairValue = sortedNums[sortedNums.count-1] * sortedNums[sortedNums.count-2]\\n        let smallestPairValue =  sortedNums[0] * sortedNums[1]\\n\\t\\treturn biggestPairValue - smallestPairValue\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325841,
                "title": "o-n",
                "content": "class Solution {\\n//     public int maxProductDifference(int[] nums) {\\n//         Arrays.sort(nums);\\n//         return (nums[nums.length - 2] * nums[nums.length - 1]) - (nums[0] * nums[1]);\\n        \\n//     }\\n    \\n    public int maxProductDifference(int[] nums) {\\n        int max = -(int)1e9, max2 = -(int)1e9;\\n        int min = (int)1e9, min2 = (int)1e9;\\n\\n            for (int i = 0; i < nums.length; i++) {\\n        if (nums[i] > max2) {\\n            if (nums[i] > max) {\\n                max2 = max;\\n                max = nums[i];\\n            } else {\\n                max2 = nums[i];\\n            }\\n        }\\n        if (nums[i] < min2) {\\n            if (nums[i] < min) {\\n                min2 = min;\\n                min = nums[i];\\n            } else {\\n                min2 = nums[i];\\n            }\\n        }\\n    } \\n        return max * max2 - min * min2;\\n    }    \\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n//     public int maxProductDifference(int[] nums) {\\n//         Arrays.sort(nums);\\n//         return (nums[nums.length - 2] * nums[nums.length - 1]) - (nums[0] * nums[1]);\\n        \\n//     }",
                "codeTag": "Java"
            },
            {
                "id": 1307540,
                "title": "java-o-nlogn-6-ms-runtime-beats-83-35",
                "content": "**Simple intution**\\n1. Sort array\\n2. starting 2 elements are smallest\\n3. ending 2 are largest\\n4. calculate and return\\n\\n\\n\\n```\\n\\n// Runtime: 6 ms, faster than 83.35% of Java online submissions for Maximum Product Difference Between Two Pairs.\\n// Memory Usage: 39.2 MB, less than 72.33% of Java online submissions for Maximum Product Difference Between Two Pairs.\\n\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        \\n        int length=nums.length;\\n        Arrays.sort(nums);\\n        return (nums[length-1]*nums[length-2])-(nums[0]*nums[1]);\\n    }\\n}\\n\\n```\\n\\nCan be optimized by 4 pointer and linear traversal \\n1. firstBiggest\\n2. secondBiggest\\n3. firstSmallest\\n4. secondSmallest\\n\\nand TC will be O( N ) , space O( 1 )",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\n\\n// Runtime: 6 ms, faster than 83.35% of Java online submissions for Maximum Product Difference Between Two Pairs.\\n// Memory Usage: 39.2 MB, less than 72.33% of Java online submissions for Maximum Product Difference Between Two Pairs.\\n\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        \\n        int length=nums.length;\\n        Arrays.sort(nums);\\n        return (nums[length-1]*nums[length-2])-(nums[0]*nums[1]);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1303012,
                "title": "javascript-100-faster-100-less-memory-usage",
                "content": "```\\n    nums.sort((a,b) =>{\\n        return a-b;\\n    })\\n    return ((nums[nums.length-1] * nums[nums.length-2]) - (nums[0]*nums[1]) )",
                "solutionTags": [],
                "code": "```\\n    nums.sort((a,b) =>{\\n        return a-b;\\n    })\\n    return ((nums[nums.length-1] * nums[nums.length-2]) - (nums[0]*nums[1]) )",
                "codeTag": "Unknown"
            },
            {
                "id": 1301522,
                "title": "linear-o-n-solutions-python-go-c",
                "content": "Python\\n```python\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return nums[-1] * nums[-2] - nums[0] * nums[1]\\n```\\n\\nGo\\n```go\\nfunc maxProductDifference(nums []int) int {\\n    b1, b2 := 0, 0\\n    l1, l2 := math.MaxInt32, math.MaxInt32\\n\\n    for _, n := range nums {\\n        if n >= b1 {\\n            b2 = b1\\n            b1 = n\\n        } else if n >= b2 {\\n            b2 = n\\n        }\\n\\n        if n <= l1 {\\n            l2 = l1\\n            l1 = n\\n        } else if n <= l2 {\\n            l2 = n\\n        }\\n    }\\n\\n    return b1*b2 - l1*l2\\n}\\n```\\n\\nC\\n```C\\nint maxProductDifference(int *nums, int numsSize)\\n{\\n    int b1 = 0;\\n    int b2 = 0;\\n    int l1 = INT_MAX;\\n    int l2 = INT_MAX;\\n\\n    for (int i = 0 ; i < numsSize ; i++) {\\n        int n = nums[i];\\n\\n        if (n >= b1) {\\n            b2 = b1;\\n            b1 = n;\\n        } else if (n >= b2) {\\n            b2 = n;\\n        }\\n\\n        if (n <= l1) {\\n            l2 = l1;\\n            l1 = n;\\n        } else if (n <= l2) {\\n            l2 = n;\\n        }\\n    }\\n\\n    return b1*b2 - l1*l2;\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return nums[-1] * nums[-2] - nums[0] * nums[1]\\n```\n```go\\nfunc maxProductDifference(nums []int) int {\\n    b1, b2 := 0, 0\\n    l1, l2 := math.MaxInt32, math.MaxInt32\\n\\n    for _, n := range nums {\\n        if n >= b1 {\\n            b2 = b1\\n            b1 = n\\n        } else if n >= b2 {\\n            b2 = n\\n        }\\n\\n        if n <= l1 {\\n            l2 = l1\\n            l1 = n\\n        } else if n <= l2 {\\n            l2 = n\\n        }\\n    }\\n\\n    return b1*b2 - l1*l2\\n}\\n```\n```C\\nint maxProductDifference(int *nums, int numsSize)\\n{\\n    int b1 = 0;\\n    int b2 = 0;\\n    int l1 = INT_MAX;\\n    int l2 = INT_MAX;\\n\\n    for (int i = 0 ; i < numsSize ; i++) {\\n        int n = nums[i];\\n\\n        if (n >= b1) {\\n            b2 = b1;\\n            b1 = n;\\n        } else if (n >= b2) {\\n            b2 = n;\\n        }\\n\\n        if (n <= l1) {\\n            l2 = l1;\\n            l1 = n;\\n        } else if (n <= l2) {\\n            l2 = n;\\n        }\\n    }\\n\\n    return b1*b2 - l1*l2;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1300221,
                "title": "swift-fast-efficient-solution-o-n-time-o-1-space",
                "content": "**Explanation:**\\n1. Define variables for minimum and maximum pairs.\\n2. Traverse an input array, compare the values & update variables.\\n3. Return product difference between the minimum and the maximum pairs.\\n```\\nclass Solution {\\n    func maxProductDifference(_ nums: [Int]) -> Int {\\n        var max = Int.min\\n        var secondMax = Int.min\\n        \\n        var min = Int.max\\n        var secondMin = Int.max\\n        \\n        for num in nums {\\n            if num > max {\\n                secondMax = max\\n                max = num\\n            } else if num > secondMax {\\n                secondMax = num\\n            }\\n            if num < min {\\n                secondMin = min\\n                min = num\\n            } else if num < secondMin {\\n                secondMin = num\\n            }\\n        }\\n        \\n        return (max * secondMax) - (min * secondMin)\\n    }\\n}\\n```\\n***Analysis:***\\n*Time complexity: O(n).*\\n*Space complexity: O(1).*",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxProductDifference(_ nums: [Int]) -> Int {\\n        var max = Int.min\\n        var secondMax = Int.min\\n        \\n        var min = Int.max\\n        var secondMin = Int.max\\n        \\n        for num in nums {\\n            if num > max {\\n                secondMax = max\\n                max = num\\n            } else if num > secondMax {\\n                secondMax = num\\n            }\\n            if num < min {\\n                secondMin = min\\n                min = num\\n            } else if num < secondMin {\\n                secondMin = num\\n            }\\n        }\\n        \\n        return (max * secondMax) - (min * secondMin)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299614,
                "title": "python-o-n-no-sorting",
                "content": "**Solution 1:**\\n``` python\\na = b = 10001\\nc = d = 0\\nfor num in nums:\\n\\tif num < a:\\n\\t\\ta, b = num, a\\n\\telif num < b:\\n\\t\\tb = num\\n\\tif num > c:\\n\\t\\tc, d = num, c\\n\\telif num > d:\\n\\t\\td = num\\nreturn c * d - a * b\\n```\\n\\n**Solution 2:**\\n``` python\\na, b, c, d = sorted(nums[ : 4])\\nfor num in nums[4 : ]:\\n\\tif num < a:\\n\\t\\ta, b = num, a\\n\\telif num < b:\\n\\t\\tb = num\\n\\telif num > d:\\n\\t\\td, c = num, d\\n\\telif num > c:\\n\\t\\tc = num\\nreturn c * d - a * b\\n```",
                "solutionTags": [],
                "code": "``` python\\na = b = 10001\\nc = d = 0\\nfor num in nums:\\n\\tif num < a:\\n\\t\\ta, b = num, a\\n\\telif num < b:\\n\\t\\tb = num\\n\\tif num > c:\\n\\t\\tc, d = num, c\\n\\telif num > d:\\n\\t\\td = num\\nreturn c * d - a * b\\n```\n``` python\\na, b, c, d = sorted(nums[ : 4])\\nfor num in nums[4 : ]:\\n\\tif num < a:\\n\\t\\ta, b = num, a\\n\\telif num < b:\\n\\t\\tb = num\\n\\telif num > d:\\n\\t\\td, c = num, d\\n\\telif num > c:\\n\\t\\tc = num\\nreturn c * d - a * b\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4021123,
                "title": "day-22-max-product-difference-between-two-pairs-java-solution",
                "content": "# Approach\\r\\n**Note : Here we are going to worry about only 4 values from the array. Max, SecondMax, Min, Second Min.**\\r\\n1. Initialized **Max** and **SecMax** with **Integer.MIN_VALUE** and **Min** and **SecMin** with **Integer.MAX_VALUES**. \\r\\n2. Used for each loop to compare each values with one another to filter out the **Max** and **SecMax** / **Min** and **SecMin**.\\r\\n3. Find the product of **Max** and **SecMax**.\\r\\n4. Find the porduct of **Min** and **SecMin**.\\r\\n5. return (Max and SecMax) - (Min and SecMin);\\r\\n\\r\\n---\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n    O(n)\\r\\n\\r\\n- Space complexity:\\r\\n    o(1)\\r\\n\\r\\n---\\r\\n\\r\\n# Request\\r\\n    If you find this post/solution helpful , please upvote.\\r\\n---\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\n    public int maxProductDifference(int[] nums) {\\r\\n        int max=Integer.MIN_VALUE, max1=Integer.MIN_VALUE, min=Integer.MAX_VALUE, min1=Integer.MAX_VALUE;\\r\\n        for (int num : nums) {\\r\\n            if (num >= max) {\\r\\n                max1 = max;\\r\\n                max = num;\\r\\n            } else if (num > max1)\\r\\n                max1 = num;\\r\\n\\r\\n            if (num <= min) {\\r\\n                min1 = min;\\r\\n                min = num;\\r\\n            } else if (num < min1)\\r\\n                min1 = num;\\r\\n        }\\r\\n        return (max * max1) - (min * min1);\\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n    public int maxProductDifference(int[] nums) {\\r\\n        int max=Integer.MIN_VALUE, max1=Integer.MIN_VALUE, min=Integer.MAX_VALUE, min1=Integer.MAX_VALUE;\\r\\n        for (int num : nums) {\\r\\n            if (num >= max) {\\r\\n                max1 = max;\\r\\n                max = num;\\r\\n            } else if (num > max1)\\r\\n                max1 = num;\\r\\n\\r\\n            if (num <= min) {\\r\\n                min1 = min;\\r\\n                min = num;\\r\\n            } else if (num < min1)\\r\\n                min1 = num;\\r\\n        }\\r\\n        return (max * max1) - (min * min1);\\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857301,
                "title": "c-only-5-lines-easyyy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int start=nums[0]*nums[1];\\n        int end=nums[n-1]*nums[n-2];\\n        return end-start;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int start=nums[0]*nums[1];\\n        int end=nums[n-1]*nums[n-2];\\n        return end-start;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786682,
                "title": "python-easy-solution-sorting",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return nums[len(nums)-1]*nums[len(nums)-2]-nums[0]*nums[1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return nums[len(nums)-1]*nums[len(nums)-2]-nums[0]*nums[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717074,
                "title": "c-using-sorting",
                "content": "# Complexity\\n- Time complexity: O(N logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\n        int front = nums[1]*nums[0];\\n        int back = nums[nums.size()-1] * nums[nums.size()-2];\\n        return back-front;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\n        int front = nums[1]*nums[0];\\n        int back = nums[nums.size()-1] * nums[nums.size()-2];\\n        return back-front;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699722,
                "title": "maximum-product-difference-between-two-pairs-java-solution-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        int prod1 = nums[0] * nums[1];\\n        int prod2 = nums[nums.length -1] * nums[nums.length -2];\\n        return prod2 - prod1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        int prod1 = nums[0] * nums[1];\\n        int prod2 = nums[nums.length -1] * nums[nums.length -2];\\n        return prod2 - prod1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693499,
                "title": "sort-using-mergesort-decreases-the-time-complexity-massively-o-nlogn",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\nSort the array using merge sort and since the last two elements will be the greatest and similarily the first two elements will be the smallest, therefore create the pairs and perform normal subtraction on them.\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\nO(nlogn)\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\nO(1), constant space\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\n    public int maxProductDifference(int[] nums) {\\r\\n\\r\\n        nums = sort(nums, 0, nums.length);\\r\\n        int ans = (nums[nums.length-1] * nums[nums.length-2]) - (nums[0] * nums[1]);\\r\\n\\r\\n        return ans;\\r\\n\\r\\n\\r\\n        \\r\\n    }\\r\\n\\r\\n    public int[] sort(int[] arr, int start, int end){\\r\\n\\r\\n        if(end-start == 1){\\r\\n            return arr;\\r\\n        }\\r\\n\\r\\n        int mid = (start + end)/2;\\r\\n\\r\\n        sort(arr, start, mid);\\r\\n        sort(arr, mid, end);\\r\\n\\r\\n        return merge(arr, start, mid, end);\\r\\n    }\\r\\n\\r\\n    private int[] merge(int[] arr, int start, int mid, int end) {\\r\\n\\r\\n        int[] result = new int[end - start];\\r\\n\\r\\n        int i=start;\\r\\n        int j=mid;\\r\\n        int k=0;\\r\\n\\r\\n        while(i<mid && j<end){\\r\\n\\r\\n            if(arr[i]<arr[j]){\\r\\n                result[k] = arr[i];\\r\\n                i++;\\r\\n            }\\r\\n            else{\\r\\n                result[k] = arr[j];\\r\\n                j++;\\r\\n            }\\r\\n\\r\\n            k++;\\r\\n        }\\r\\n\\r\\n        while(i<mid){\\r\\n            result[k] = arr[i];\\r\\n            i++;\\r\\n            k++;\\r\\n        }\\r\\n\\r\\n        while(j<end){\\r\\n            result[k] = arr[j];\\r\\n            j++;\\r\\n            k++;\\r\\n        }\\r\\n\\r\\n        for (int l = 0; l < result.length ; l++) {\\r\\n            arr[start+l] = result[l];\\r\\n        }\\r\\n\\r\\n        return arr;\\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "Java",
                    "Merge Sort"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n    public int maxProductDifference(int[] nums) {\\r\\n\\r\\n        nums = sort(nums, 0, nums.length);\\r\\n        int ans = (nums[nums.length-1] * nums[nums.length-2]) - (nums[0] * nums[1]);\\r\\n\\r\\n        return ans;\\r\\n\\r\\n\\r\\n        \\r\\n    }\\r\\n\\r\\n    public int[] sort(int[] arr, int start, int end){\\r\\n\\r\\n        if(end-start == 1){\\r\\n            return arr;\\r\\n        }\\r\\n\\r\\n        int mid = (start + end)/2;\\r\\n\\r\\n        sort(arr, start, mid);\\r\\n        sort(arr, mid, end);\\r\\n\\r\\n        return merge(arr, start, mid, end);\\r\\n    }\\r\\n\\r\\n    private int[] merge(int[] arr, int start, int mid, int end) {\\r\\n\\r\\n        int[] result = new int[end - start];\\r\\n\\r\\n        int i=start;\\r\\n        int j=mid;\\r\\n        int k=0;\\r\\n\\r\\n        while(i<mid && j<end){\\r\\n\\r\\n            if(arr[i]<arr[j]){\\r\\n                result[k] = arr[i];\\r\\n                i++;\\r\\n            }\\r\\n            else{\\r\\n                result[k] = arr[j];\\r\\n                j++;\\r\\n            }\\r\\n\\r\\n            k++;\\r\\n        }\\r\\n\\r\\n        while(i<mid){\\r\\n            result[k] = arr[i];\\r\\n            i++;\\r\\n            k++;\\r\\n        }\\r\\n\\r\\n        while(j<end){\\r\\n            result[k] = arr[j];\\r\\n            j++;\\r\\n            k++;\\r\\n        }\\r\\n\\r\\n        for (int l = 0; l < result.length ; l++) {\\r\\n            arr[start+l] = result[l];\\r\\n        }\\r\\n\\r\\n        return arr;\\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644733,
                "title": "explained-javascript-solution-with-o-n-time-and-o-1-space-complexity",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\nThe first idea is to sort the input array and take the first two and the last two numbers. It is indeed a correct solution since we have only positive numbers in the input array and the minimal product would consist of two minimal numbers.\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\nActually the solution does not need to sort any numbers in between the second minimum and the second maximum. So in the sorted array it `[1, 2, ...order does not matter here..., 99, 100]`.\\r\\nIndeed we only need two find two maximum numbers and two minimum numbers.\\r\\n\\r\\nSo I implemented two procedures to find min and max that take an array and an index to exclude from the search as inputs. Index to exclude defaults to -1, which allows to call the procedure for the first time, when we don\\'t have any values yet.\\r\\n\\r\\nThen I had a failed test with the array where the first number was the least. For this reason, I had to change the logic behind \\r\\n\\r\\n# Complexity\\r\\n\\r\\n- Time complexity:\\r\\n    + $$O(n)$$ - we\\'ll need to walk through the array 4 times to find 2 least and 2 greatest numbers\\r\\n- Space complexity:\\r\\n    + $$O(1)$$ - constant amount of variables to store all the values is required\\r\\n\\r\\n# Code\\r\\n```javascript\\r\\n// Regular maximum finding procedure, but modified to accept\\r\\n// optional `except` parameter, so it makes it possible to\\r\\n// find many greatest values. `except` defaults to -1 which does not\\r\\n// appear among array indexes, so it is possible to ignore this parameter.\\r\\nvar findMax = (array, { except = -1 } = {}) => {\\r\\n  let max = null;\\r\\n  // we also need to store this value, to skip this index later\\r\\n  let maxIndex = null;\\r\\n\\r\\n  for (let i = 0; i < array.length; i++) {\\r\\n    if (i === except) continue; // skip `except` index\\r\\n\\r\\n    if (max === null || max < array[i]) {\\r\\n      max = array[i];\\r\\n      maxIndex = i;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  // return both maximum and its index as the output\\r\\n  return { value: max, index: maxIndex };\\r\\n};\\r\\n\\r\\nvar findMin = (array, { except = -1 } = {}) => {\\r\\n  let min = null;\\r\\n  let minIndex = null;\\r\\n  for (let i = 0; i < array.length; i++) {\\r\\n    if (i === except) continue;\\r\\n\\r\\n    if (min === null || min > array[i]) {\\r\\n      min = array[i];\\r\\n      minIndex = i;\\r\\n    }\\r\\n  }\\r\\n  return { value: min, index: minIndex };\\r\\n};\\r\\n\\r\\nvar maxProductDifference = function(nums) {\\r\\n  let { value: firstMax, index: firstMaxIndex } = findMax(nums);\\r\\n  // When searching for the second greatest value, we pass the index\\r\\n  // of the first greatest value to skip it. We can\\'t use the maximum\\r\\n  // value itself, because it may appear more than once in the array.\\r\\n  let { value: secondMax } = findMax(nums, { except: firstMaxIndex });\\r\\n\\r\\n  let { value: firstMin, index: firstMinIndex } = findMin(nums);\\r\\n  let { value: secondMin } = findMin(nums, { except: firstMinIndex });\\r\\n\\r\\n  return firstMax * secondMax - firstMin * secondMin;\\r\\n};\\r\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\r\\n// Regular maximum finding procedure, but modified to accept\\r\\n// optional `except` parameter, so it makes it possible to\\r\\n// find many greatest values. `except` defaults to -1 which does not\\r\\n// appear among array indexes, so it is possible to ignore this parameter.\\r\\nvar findMax = (array, { except = -1 } = {}) => {\\r\\n  let max = null;\\r\\n  // we also need to store this value, to skip this index later\\r\\n  let maxIndex = null;\\r\\n\\r\\n  for (let i = 0; i < array.length; i++) {\\r\\n    if (i === except) continue; // skip `except` index\\r\\n\\r\\n    if (max === null || max < array[i]) {\\r\\n      max = array[i];\\r\\n      maxIndex = i;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  // return both maximum and its index as the output\\r\\n  return { value: max, index: maxIndex };\\r\\n};\\r\\n\\r\\nvar findMin = (array, { except = -1 } = {}) => {\\r\\n  let min = null;\\r\\n  let minIndex = null;\\r\\n  for (let i = 0; i < array.length; i++) {\\r\\n    if (i === except) continue;\\r\\n\\r\\n    if (min === null || min > array[i]) {\\r\\n      min = array[i];\\r\\n      minIndex = i;\\r\\n    }\\r\\n  }\\r\\n  return { value: min, index: minIndex };\\r\\n};\\r\\n\\r\\nvar maxProductDifference = function(nums) {\\r\\n  let { value: firstMax, index: firstMaxIndex } = findMax(nums);\\r\\n  // When searching for the second greatest value, we pass the index\\r\\n  // of the first greatest value to skip it. We can\\'t use the maximum\\r\\n  // value itself, because it may appear more than once in the array.\\r\\n  let { value: secondMax } = findMax(nums, { except: firstMaxIndex });\\r\\n\\r\\n  let { value: firstMin, index: firstMinIndex } = findMin(nums);\\r\\n  let { value: secondMin } = findMin(nums, { except: firstMinIndex });\\r\\n\\r\\n  return firstMax * secondMax - firstMin * secondMin;\\r\\n};\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3568391,
                "title": "c-linear-greedy",
                "content": "# Intuition\\nFirstly it is needed to know that the maximum difference will be the product of last two max int and first two min int.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSort the array and return the product difference of first and last two values.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlog n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int size = nums.size();\\n\\n        return (nums[size-1]*nums[size-2] - nums[1]*nums[0]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int size = nums.size();\\n\\n        return (nums[size-1]*nums[size-2] - nums[1]*nums[0]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534688,
                "title": "simple-solution",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    so the question is basically saying product of two least element\\n    and product of two max element \\n    and then maxproduct- leastproduct is the answer\\n    As after sorting Array, the first2 element it will the least \\n    and the max 2 element will be in last\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n       Arrays.sort(nums);\\n\\n       //select first 2 element\\n           int first2= nums[0]*nums[1];\\n       //select last 2 element \\n            int last2=nums[nums.length-1]*nums[nums.length-2];\\n\\n            return last2-first2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n       Arrays.sort(nums);\\n\\n       //select first 2 element\\n           int first2= nums[0]*nums[1];\\n       //select last 2 element \\n            int last2=nums[nums.length-1]*nums[nums.length-2];\\n\\n            return last2-first2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492686,
                "title": "simple-java-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        return (nums[nums.length - 1] * nums[nums.length - 2]) - (nums[0] * nums[1]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        return (nums[nums.length - 1] * nums[nums.length - 2]) - (nums[0] * nums[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370947,
                "title": "0-iq-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLiterally the easiest problem in the whole leetcode\\nIts on the same level as print hello world!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxProductDifference(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        max1 = max(nums)\\n        nums.remove(max1)\\n        max2 = max(nums)\\n\\n        min1 = min(nums)\\n        nums.remove(min1)\\n        min2 = min(nums)\\n\\n        return max1*max2-min1*min2\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxProductDifference(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        max1 = max(nums)\\n        nums.remove(max1)\\n        max2 = max(nums)\\n\\n        min1 = min(nums)\\n        nums.remove(min1)\\n        min2 = min(nums)\\n\\n        return max1*max2-min1*min2\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345265,
                "title": "easy-c-in-o-n-and-o-1-in-most-optimized-way",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: O(N)\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:O(1)\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int maxProductDifference(vector<int>& nums) \\r\\n    {\\r\\n        int max1 = INT_MIN;\\r\\n        int max2 = INT_MIN;\\r\\n        int min1 = INT_MAX;\\r\\n        int min2 = INT_MAX;\\r\\n        for(int i=0;i<nums.size();i++)\\r\\n        {\\r\\n            int a = nums[i];\\r\\n            if(a>=max1)\\r\\n            {\\r\\n                max2=max1;\\r\\n                max1=a;\\r\\n            }\\r\\n            else if(a>=max2)\\r\\n            {\\r\\n                max2=a;\\r\\n            }\\r\\n            if(a<=min1)\\r\\n            {\\r\\n                min2=min1;\\r\\n                min1 = a;\\r\\n            }\\r\\n            else if(a<=min2)\\r\\n            {\\r\\n                min2=a;\\r\\n            }\\r\\n            \\r\\n        }\\r\\n        return max1*max2 - min1*min2;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int maxProductDifference(vector<int>& nums) \\r\\n    {\\r\\n        int max1 = INT_MIN;\\r\\n        int max2 = INT_MIN;\\r\\n        int min1 = INT_MAX;\\r\\n        int min2 = INT_MAX;\\r\\n        for(int i=0;i<nums.size();i++)\\r\\n        {\\r\\n            int a = nums[i];\\r\\n            if(a>=max1)\\r\\n            {\\r\\n                max2=max1;\\r\\n                max1=a;\\r\\n            }\\r\\n            else if(a>=max2)\\r\\n            {\\r\\n                max2=a;\\r\\n            }\\r\\n            if(a<=min1)\\r\\n            {\\r\\n                min2=min1;\\r\\n                min1 = a;\\r\\n            }\\r\\n            else if(a<=min2)\\r\\n            {\\r\\n                min2=a;\\r\\n            }\\r\\n            \\r\\n        }\\r\\n        return max1*max2 - min1*min2;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248536,
                "title": "maximum-product-difference-between-two-pairs-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        return abs((nums[nums.size()-1]*nums[nums.size()-2])-(nums[0]*nums[1]));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        return abs((nums[nums.size()-1]*nums[nums.size()-2])-(nums[0]*nums[1]));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146605,
                "title": "1913-maximum-product-difference-between-two-pairs-java-very-very-easy-2-lines",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        return ((nums[nums.length - 1] * nums[nums.length - 2]) - (nums[0] * nums[1]));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        return ((nums[nums.length - 1] * nums[nums.length - 2]) - (nums[0] * nums[1]));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3122327,
                "title": "java-1-liner-solution-simple",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        return nums[nums.length-1]*nums[nums.length-2] - nums[0]*nums[1]; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        return nums[nums.length-1]*nums[nums.length-2] - nums[0]*nums[1]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102585,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        int a = nums[nums.length-1];\\n        int b = nums[nums.length-2];\\n\\n        int c = nums[0];\\n        int d = nums[1];\\n\\n        return(a*b) - (c*d);\\n\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        int a = nums[nums.length-1];\\n        int b = nums[nums.length-2];\\n\\n        int c = nums[0];\\n        int d = nums[1];\\n\\n        return(a*b) - (c*d);\\n\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065037,
                "title": "5-lines-easy-c-code",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int size=nums.size();\\n        int m1=nums[size-1]*nums[size-2];\\n        int m2=nums[0]*nums[1];\\n        return m1-m2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int size=nums.size();\\n        int m1=nums[size-1]*nums[size-2];\\n        int m2=nums[0]*nums[1];\\n        return m1-m2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011043,
                "title": "easy-c-solution",
                "content": "\\r\\n\\r\\n# Code\\r\\n```\\r\\nint maxProductDifference(int* nums, int numsSize){\\r\\n    int max1, max2, min1, min2;\\r\\n    int temp;\\r\\n    int res;\\r\\n    int count = 0;\\r\\n    max1 = max2 = 0;\\r\\n    min1 = min2 = 10001;\\r\\n\\r\\n    for (int i = 0; i<numsSize; i++){\\r\\n        if (nums[i]>max1){\\r\\n            max1 = nums[i];\\r\\n            temp = i;\\r\\n        }\\r\\n    }\\r\\n    for (int i = 0; i<numsSize; i++){\\r\\n        if(nums[i]>max2 && i != temp){\\r\\n            max2 = nums[i];\\r\\n        }\\r\\n    }\\r\\n    for (int i = 0; i<numsSize; i++){\\r\\n        if (nums[i]<min1){\\r\\n            min1 = nums[i];\\r\\n            temp = i;\\r\\n        }\\r\\n    }\\r\\n    for (int i = 0; i<numsSize; i++){\\r\\n        if(nums[i]<min2 && i != temp){\\r\\n            min2 = nums[i];\\r\\n        }\\r\\n    }\\r\\n    printf(\"%d %d %d %d\", max1, max2, min1, min2);\\r\\n    res = (max1*max2)-(min1*min2);\\r\\n    return res;\\r\\n}\\r\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\r\\nint maxProductDifference(int* nums, int numsSize){\\r\\n    int max1, max2, min1, min2;\\r\\n    int temp;\\r\\n    int res;\\r\\n    int count = 0;\\r\\n    max1 = max2 = 0;\\r\\n    min1 = min2 = 10001;\\r\\n\\r\\n    for (int i = 0; i<numsSize; i++){\\r\\n        if (nums[i]>max1){\\r\\n            max1 = nums[i];\\r\\n            temp = i;\\r\\n        }\\r\\n    }\\r\\n    for (int i = 0; i<numsSize; i++){\\r\\n        if(nums[i]>max2 && i != temp){\\r\\n            max2 = nums[i];\\r\\n        }\\r\\n    }\\r\\n    for (int i = 0; i<numsSize; i++){\\r\\n        if (nums[i]<min1){\\r\\n            min1 = nums[i];\\r\\n            temp = i;\\r\\n        }\\r\\n    }\\r\\n    for (int i = 0; i<numsSize; i++){\\r\\n        if(nums[i]<min2 && i != temp){\\r\\n            min2 = nums[i];\\r\\n        }\\r\\n    }\\r\\n    printf(\"%d %d %d %d\", max1, max2, min1, min2);\\r\\n    res = (max1*max2)-(min1*min2);\\r\\n    return res;\\r\\n}\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3010206,
                "title": "very-easy-to-understand-c-solution-4-lines",
                "content": "# Intuition\\nMaximum Product difference is achieved by knowing the maximum, 2nd maximum, minimum and 2nd minimum values of the array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        int max=nums[0],maxp=nums[0],min=nums[0],minp=nums[0];\\n        int product,n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        product=(nums[n-1]*nums[n-2])-(nums[0]*nums[1]);\\n        return product;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        int max=nums[0],maxp=nums[0],min=nums[0],minp=nums[0];\\n        int product,n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        product=(nums[n-1]*nums[n-2])-(nums[0]*nums[1]);\\n        return product;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000510,
                "title": "o-n-solution-without-sorting",
                "content": "# Complexity\\r\\n- Time complexity:\\r\\n$$O(N)$$\\r\\n- Space complexity:\\r\\n$$O(1)$$\\r\\n\\r\\n# Code\\r\\n```\\r\\n/**\\r\\n * @param {number[]} nums\\r\\n * @return {number}\\r\\n */\\r\\nvar maxProductDifference = function(nums) {\\r\\n    const min2nums = [nums[0], nums[1]].sort((a, b) => a - b);\\r\\n    const max2nums = [nums[0], nums[1]].sort((a, b) => a - b);\\r\\n\\r\\n    for (let i = 2; i < nums.length; i++) {\\r\\n        const num = nums[i];\\r\\n\\r\\n        if (num < min2nums[0]) {\\r\\n            min2nums[1] = min2nums[0];\\r\\n            min2nums[0] = num;\\r\\n        } else if (num < min2nums[1]) {\\r\\n            min2nums[1] = num;\\r\\n        }\\r\\n\\r\\n        if (num > max2nums[1]) {\\r\\n            max2nums[0] = max2nums[1];\\r\\n            max2nums[1] = num;\\r\\n        } else if (num > max2nums[0]) {\\r\\n            max2nums[0] = num;\\r\\n        }\\r\\n    };\\r\\n\\r\\n    return max2nums[0] * max2nums[1] - min2nums[0] * min2nums[1];\\r\\n};\\r\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\r\\n/**\\r\\n * @param {number[]} nums\\r\\n * @return {number}\\r\\n */\\r\\nvar maxProductDifference = function(nums) {\\r\\n    const min2nums = [nums[0], nums[1]].sort((a, b) => a - b);\\r\\n    const max2nums = [nums[0], nums[1]].sort((a, b) => a - b);\\r\\n\\r\\n    for (let i = 2; i < nums.length; i++) {\\r\\n        const num = nums[i];\\r\\n\\r\\n        if (num < min2nums[0]) {\\r\\n            min2nums[1] = min2nums[0];\\r\\n            min2nums[0] = num;\\r\\n        } else if (num < min2nums[1]) {\\r\\n            min2nums[1] = num;\\r\\n        }\\r\\n\\r\\n        if (num > max2nums[1]) {\\r\\n            max2nums[0] = max2nums[1];\\r\\n            max2nums[1] = num;\\r\\n        } else if (num > max2nums[0]) {\\r\\n            max2nums[0] = num;\\r\\n        }\\r\\n    };\\r\\n\\r\\n    return max2nums[0] * max2nums[1] - min2nums[0] * min2nums[1];\\r\\n};\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2636918,
                "title": "c-easy-to-understand-detailed",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        return (nums[nums.size()-1]*nums[nums.size()-2]) - (nums[0]*nums[1]);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        return (nums[nums.size()-1]*nums[nums.size()-2]) - (nums[0]*nums[1]);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2636194,
                "title": "easy-c-solution",
                "content": "class Solution {\\npublic:\\n\\n    int maxProductDifference(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int a1=nums[n-1]*nums[n-2];\\n        int a2=nums[0]*nums[1];\\n        return a1-a2;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int maxProductDifference(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int a1=nums[n-1]*nums[n-2];\\n        int a2=nums[0]*nums[1];\\n        return a1-a2;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2574984,
                "title": "python-solution-o-n-faster-than-99-of-solutions",
                "content": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        mx1 = max(nums)\\n        nums.remove(mx1)\\n        mx2 = max(nums)\\n        nums.remove(mx2)\\n        mn1 = min(nums)\\n        nums.remove(mn1)\\n        mn2 = min(nums)\\n        nums.remove(mn2)\\n        result =  (mx1*mx2) - (mn1*mn2)\\n        return result\\n```\\n        \\n        \\n        \"\"\"max1 = max(nums)\\n        nums.remove(max1)\\n        max2 = max(nums)\\n        min1 = min(nums)\\n        nums.remove(min1)\\n        min2 = min(nums)\\n        result = (max2*max1)-(min2*min1)\\n        return result\"\"\"",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        mx1 = max(nums)\\n        nums.remove(mx1)\\n        mx2 = max(nums)\\n        nums.remove(mx2)\\n        mn1 = min(nums)\\n        nums.remove(mn1)\\n        mn2 = min(nums)\\n        nums.remove(mn2)\\n        result =  (mx1*mx2) - (mn1*mn2)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563804,
                "title": "c-single-pass-solution-100-time-12ms-66-space-20-4mb",
                "content": "The obvious solutions would be to sort the input, but that would be needlessly expensive if we only need the two lower and the two higher values; we can do better, in a single pass nonetheless!\\n\\nWe will declare the two pairs of values (respectively: `minA` and `minB`, `maxA` and `maxB`), setting the `minA` to be `INT_MAX` and `maxA` o be `INT_MIN`.\\n\\nWe will then loop through each value `n` in `nums` and:\\n* check if `n < minA`, in which case we:\\n\\t* shift the value of `minA` to `minB`;\\n\\t* overwrite `minA` with `n`;\\n* else if `n < minB`, we will simply write `n` in `minB`;\\n\\t* check if `n > maxA`, in which case we:\\n\\t* shift the value of `maxA` to `maxB`;\\n\\t* overwrite `maxA` with `n`;\\n* else if `n > maxB`, we will simply write `n` in `maxB`.\\n\\nOnce done, as the specs require, we can just `return` `(maxA * maxB) - (minA * minB)`.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        // support variables\\n        int minA = INT_MAX, minB,  maxA = INT_MIN, maxB;\\n        // parsing nums\\n        for (int n: nums) {\\n            if (n < minA) minB = minA, minA = n;\\n            else if (n < minB) minB = n;\\n            if (n > maxA) maxB = maxA, maxA = n;\\n            else if (n > maxB) maxB = n;\\n        }\\n        return (maxA * maxB) - (minA * minB);\\n    }\\n};\\n```\\n\\nThe brag:\\n![image](https://assets.leetcode.com/users/images/bd892af3-1f43-4f23-9971-696c8a5b1f15_1662925656.6989312.png)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        // support variables\\n        int minA = INT_MAX, minB,  maxA = INT_MIN, maxB;\\n        // parsing nums\\n        for (int n: nums) {\\n            if (n < minA) minB = minA, minA = n;\\n            else if (n < minB) minB = n;\\n            if (n > maxA) maxB = maxA, maxA = n;\\n            else if (n > maxB) maxB = n;\\n        }\\n        return (maxA * maxB) - (minA * minB);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2515887,
                "title": "maximum-product-difference-between-two-pairs-very-easy-solution",
                "content": "\\timport java.util.Arrays;\\n\\n\\tclass Solution {\\n\\t\\tstatic int maxProductDifference(int[] nums) {\\n\\t\\t\\tArrays.sort(nums);\\n\\t\\t\\tint n = nums.length;\\n\\t\\t\\treturn (nums[n-1] * nums[n-2])-(nums[0]*nums[1]);\\n\\t\\t}\\n\\t\\tpublic static void main(String[] args) {\\n\\t\\t\\tint[] nums = {4,2,5,9,7,4,8};\\n\\t\\t\\tSystem.out.print(maxProductDifference(nums));\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tstatic int maxProductDifference(int[] nums) {\\n\\t\\t\\tArrays.sort(nums);\\n\\t\\t\\tint n = nums.length;\\n\\t\\t\\treturn (nums[n-1] * nums[n-2])-(nums[0]*nums[1]);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2513892,
                "title": "c-easy-solution-o-log-n-o-1-space-with-comments",
                "content": "class Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n     \\n        sort(nums.begin() , nums.end());\\n        \\n        // We have sorted the array to get two largest and two smallest numbers from array\\n\\t\\t// The idea is difference will be greatest when we substract product of two smaller numbers \\n\\t\\t// from product of two larger numbers\\n        int x = 1 , y = nums.size()-2;\\n         return (nums[y+1] * nums[y] ) - (nums[x-1] * nums[x] );\\n\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n     \\n        sort(nums.begin() , nums.end());\\n        \\n        // We have sorted the array to get two largest and two smallest numbers from array\\n\\t\\t// The idea is difference will be greatest when we substract product of two smaller numbers \\n\\t\\t// from product of two larger numbers\\n        int x = 1 , y = nums.size()-2;\\n         return (nums[y+1] * nums[y] ) - (nums[x-1] * nums[x] );\\n\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2505364,
                "title": "java-2-line-solution",
                "content": "//Dev Bhayani\\n\\nclass Solution {\\n    public int maxProductDifference(int[] a) {\\n        Arrays.sort(a);\\n        return((a[a.length-1]*a[a.length-2])-(a[0]*a[1]));\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int maxProductDifference(int[] a) {\\n        Arrays.sort(a);\\n        return((a[a.length-1]*a[a.length-2])-(a[0]*a[1]));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2494750,
                "title": "java-solution-99-faster-o-n-complexity-explained",
                "content": "So, I didn\\'t use sorting since complexity of these algorithms are from O(n * logn) to O(n^2).\\nI find the max, second max, min, and second min just in one run and returning the value of product difference of them.\\n```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        int max = 0, maxNext = 0, min = 10000, minNext = 10000;\\n        for (int i = 0; i < nums.length; i++) {\\n            int n = nums[i];\\n            if (max < n) {\\n                maxNext = max;\\n                max = n;\\n            } else if (maxNext < n) {\\n                maxNext = n;\\n            }\\n\\n            if (min > n) {\\n                minNext = min;\\n                min = n;\\n            } else if (minNext > n) {\\n                minNext = n;\\n            }\\n        }\\n        return (max * maxNext) - (min * minNext);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxProductDifference(int[] nums) {\\n        int max = 0, maxNext = 0, min = 10000, minNext = 10000;\\n        for (int i = 0; i < nums.length; i++) {\\n            int n = nums[i];\\n            if (max < n) {\\n                maxNext = max;\\n                max = n;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2491932,
                "title": "java-3-line-solution",
                "content": "**//Dev Bhayani**\\n\\nclass Solution {\\n    public int maxProductDifference(int[] a) {\\n        Arrays.sort(a);\\n        int n=a.length;\\n        return((a[n-1]*a[n-2])-(a[0]*a[1]));\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int maxProductDifference(int[] a) {\\n        Arrays.sort(a);\\n        int n=a.length;\\n        return((a[n-1]*a[n-2])-(a[0]*a[1]));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2472661,
                "title": "python-fast-o-n-solution",
                "content": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        firstMin, secondMin = float(\\'inf\\'), float(\\'inf\\')\\n        firstMax, secondMax = -float(\\'inf\\'), -float(\\'inf\\')\\n        for num in nums:\\n            if num < firstMin:\\n                secondMin = firstMin\\n                firstMin = num\\n            elif num < secondMin:\\n                secondMin = num\\n            if num > firstMax:\\n                secondMax = firstMax\\n                firstMax = num\\n            elif num > secondMax:\\n                secondMax = num\\n        return (firstMax * secondMax) - (firstMin * secondMin)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        firstMin, secondMin = float(\\'inf\\'), float(\\'inf\\')\\n        firstMax, secondMax = -float(\\'inf\\'), -float(\\'inf\\')\\n        for num in nums:\\n            if num < firstMin:\\n                secondMin = firstMin\\n                firstMin = num\\n            elif num < secondMin:\\n                secondMin = num\\n            if num > firstMax:\\n                secondMax = firstMax\\n                firstMax = num\\n            elif num > secondMax:\\n                secondMax = num\\n        return (firstMax * secondMax) - (firstMin * secondMin)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459958,
                "title": "easy-c-solution-o-n",
                "content": "Algorithm:\\n1. Sorted the array in increasing order.\\n2. Taken first two and last two elements and performed the operations.\\n3. Return it as output\\n\\nTime Complexity: O(n)\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        return (nums[n-1]*nums[n-2])-(nums[0]*nums[1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        return (nums[n-1]*nums[n-2])-(nums[0]*nums[1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2452118,
                "title": "2-lines-of-code-c-easy",
                "content": "```\\nint maxProductDifference(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return nums[nums.size()-1]*nums[nums.size()-2]-nums[0]*nums[1];\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nint maxProductDifference(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return nums[nums.size()-1]*nums[nums.size()-2]-nums[0]*nums[1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2426005,
                "title": "java-with-comments-2-approaches-o-n-o-nlogn",
                "content": "``` class Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);    // sort array\\n\\t\\t\\n        int n=nums.length;    // length of array\\n        \\n\\t\\tint l2=nums[n-2];     // second last element  //a\\n        int l=nums[n-1];      // last element   //b\\n        int f=nums[0];        //first element   //c\\n        int f2=nums[1];       //second element  //d\\n        \\n        return ((l2*l)-(f2*f));   //(a * b) - (c * d)\\n    }\\n}  \\n\\n---> O(nlogn)\\n\\n\\n\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n\\n        int n=nums.length;\\n        \\n        int a=Integer.MIN_VALUE;\\n        int b=a;\\n        int c=Integer.MAX_VALUE;\\n        int d=c;\\n        \\n        for(int i=0; i<n; i++){\\n            if(nums[i]>a){\\n                b=a;\\n                a=nums[i];\\n            }else if(nums[i]>b){\\n                b=nums[i];\\n            }\\n            if(nums[i] < c) {\\n                d = c;\\n                c = nums[i];\\n            } else if(nums[i] < d) {\\n                d = nums[i];\\n            }\\n        }\\n        \\n        return (a * b) - (c * d);\\n    }\\n}\\n\\n\\n----> O(n)\\n\\nIn Both cases space complexity O(1), as we are not using any extra space",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);    // sort array\\n\\t\\t\\n        int n=nums.length;    // length of array\\n        \\n\\t\\tint l2=nums[n-2];     // second last element  //a\\n        int l=nums[n-1];      // last element   //b\\n        int f=nums[0];        //first element   //c\\n        int f2=nums[1];       //second element  //d\\n        \\n        return ((l2*l)-(f2*f));   //(a * b) - (c * d)\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2424790,
                "title": "java-solution-brute-force-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int maxProductDifference(int[] arr) {\\n        int max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;\\n        for (int i = 0; i < arr.length - 1; i++) {\\n            for (int j = i+1; j < arr.length; j++) {\\n                max = Integer.max(max, (arr[i] * arr[j]));\\n                min = Integer.min(min, (arr[i] * arr[j]));\\n            }\\n        }\\n        return max - min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProductDifference(int[] arr) {\\n        int max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;\\n        for (int i = 0; i < arr.length - 1; i++) {\\n            for (int j = i+1; j < arr.length; j++) {\\n                max = Integer.max(max, (arr[i] * arr[j]));\\n                min = Integer.min(min, (arr[i] * arr[j]));\\n            }\\n        }\\n        return max - min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2405946,
                "title": "easy-c-solution-2-liner-code-simple-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxProductDifference(vector<int>& nums) {\\n\\n\\t\\t\\tint n= nums.size();\\n\\t\\t\\tsort(nums.begin(), nums.end());\\n\\n\\t\\t\\treturn (nums[n-1]*nums[n-2]) - (nums[0]*nums[1]);\\n\\t\\t}\\n\\t};\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maxProductDifference(vector<int>& nums) {\\n\\n\\t\\t\\tint n= nums.size();\\n\\t\\t\\tsort(nums.begin(), nums.end());\\n\\n\\t\\t\\treturn (nums[n-1]*nums[n-2]) - (nums[0]*nums[1]);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2383434,
                "title": "easy-3-line-solution",
                "content": "class Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        int s  = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int min = nums[0] * nums[1]; //Finding product of two smallest number\\n        int max = nums[s-1] * nums[s-2];  //Finding product of two largest number\\n        return max-min;  //Printing maximum difference\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        int s  = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int min = nums[0] * nums[1]; //Finding product of two smallest number\\n        int max = nums[s-1] * nums[s-2];  //Finding product of two largest number\\n        return max-min;  //Printing maximum difference\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2375372,
                "title": "2-java-approaches-in-o-n-and-o-n-logn",
                "content": "**Brute force solution**\\n\\n```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        \\n        int len = nums.length;\\n        \\n        return (nums[len - 1] * nums[len - 2]) - (nums[0] * nums[1]);\\n    }\\n}\\n```\\n\\n**Tc: O(n logn)**\\n**Sc: O(1)**\\n\\n\\n**Optimal solution**\\n\\n```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        int len = nums.length;\\n        \\n        // variables names according to question\\n        int a = Integer.MIN_VALUE; // first largest\\n        int b = a;                 // second largest\\n        int c = Integer.MAX_VALUE; // first smallest\\n        int d = c;                 // second smallest\\n        \\n        for(int i = 0; i < len; i++) {\\n            if(nums[i] > a) {\\n                b = a;\\n                a = nums[i];\\n            } else if(nums[i] > b) {\\n                b = nums[i];\\n            }\\n            \\n            if(nums[i] < c) {\\n                d = c;\\n                c = nums[i];\\n            } else if(nums[i] < d) {\\n                d = nums[i];\\n            }\\n        }\\n        \\n        return (a * b) - (c * d);\\n    }\\n}\\n```\\n\\n**Tc: O(n)**\\n**Sc: O(1)**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        \\n        int len = nums.length;\\n        \\n        return (nums[len - 1] * nums[len - 2]) - (nums[0] * nums[1]);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        int len = nums.length;\\n        \\n        // variables names according to question\\n        int a = Integer.MIN_VALUE; // first largest\\n        int b = a;                 // second largest\\n        int c = Integer.MAX_VALUE; // first smallest\\n        int d = c;                 // second smallest\\n        \\n        for(int i = 0; i < len; i++) {\\n            if(nums[i] > a) {\\n                b = a;\\n                a = nums[i];\\n            } else if(nums[i] > b) {\\n                b = nums[i];\\n            }\\n            \\n            if(nums[i] < c) {\\n                d = c;\\n                c = nums[i];\\n            } else if(nums[i] < d) {\\n                d = nums[i];\\n            }\\n        }\\n        \\n        return (a * b) - (c * d);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2369211,
                "title": "two-simple-javascript-approaches",
                "content": "Normal way:\\n\\n\\tconst maxProductDifference = function(nums) {\\n\\t\\tlet max1 = Math.max(...nums)\\n\\t\\tnums.splice(nums.indexOf(max1), 1)\\n\\t\\tlet max2 = Math.max(...nums)\\n\\n\\t\\tlet min1 = Math.min(...nums)\\n\\t\\tnums.splice(nums.indexOf(min1), 1)\\n\\t\\tlet min2 = Math.min(...nums)\\n\\n\\t\\treturn (max1 * max2) - (min1 * min2)\\n\\t};\\n\\t\\nTwo-Liner way:\\n\\n\\tconst maxProductDifference = function(nums) {\\n\\t\\tnums.sort((a, b) => a - b)\\n\\t\\treturn (nums[nums.length - 1] * nums[nums.length - 2]) - (nums[0] * nums[1])\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "Normal way:\\n\\n\\tconst maxProductDifference = function(nums) {\\n\\t\\tlet max1 = Math.max(...nums)\\n\\t\\tnums.splice(nums.indexOf(max1), 1)\\n\\t\\tlet max2 = Math.max(...nums)\\n\\n\\t\\tlet min1 = Math.min(...nums)\\n\\t\\tnums.splice(nums.indexOf(min1), 1)\\n\\t\\tlet min2 = Math.min(...nums)\\n\\n\\t\\treturn (max1 * max2) - (min1 * min2)\\n\\t};\\n\\t\\nTwo-Liner way:\\n\\n\\tconst maxProductDifference = function(nums) {\\n\\t\\tnums.sort((a, b) => a - b)\\n\\t\\treturn (nums[nums.length - 1] * nums[nums.length - 2]) - (nums[0] * nums[1])\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 2368712,
                "title": "javascript-easy-solution",
                "content": "```\\n   let ln = nums.length;\\n    let a = nums.sort((a,b) => a - b)\\n    return (a[ln - 1] * a[ln - 2]) - (a[1] * a[0])\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n   let ln = nums.length;\\n    let a = nums.sort((a,b) => a - b)\\n    return (a[ln - 1] * a[ln - 2]) - (a[1] * a[0])\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2354100,
                "title": "3-line-solution",
                "content": "var maxProductDifference = function(nums) {\\n    nums.sort((a,b) => a-b);\\n        return ((nums[nums.length-1]*nums[nums.length-2])-nums[0]*nums[1]);\\n};\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var maxProductDifference = function(nums) {\\n    nums.sort((a,b) => a-b);\\n        return ((nums[nums.length-1]*nums[nums.length-2])-nums[0]*nums[1]);\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2321575,
                "title": "using-heapq-python-oneliner",
                "content": "using heapq is faster than using sorting and indexing for larger lists theoritically. \\n```\\n        return math.prod(heapq.nlargest(2,nums)) -math.prod(heapq.nsmallest(2,nums))\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n        return math.prod(heapq.nlargest(2,nums)) -math.prod(heapq.nsmallest(2,nums))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2272573,
                "title": "c-simple-withoutsorting-o-n-solution",
                "content": "class Solution {\\npublic:\\n```\\n    int maxProductDifference(vector<int>& arr) {\\n        int n = arr.size();\\n        \\n        int a = INT_MAX,b = INT_MAX,c = INT_MIN,d = INT_MIN;\\n        for(int i=0;i<n;i++) {\\n            if(a > arr[i]) {\\n                b = a;\\n                a = arr[i];\\n            } else if(b > arr[i]) {\\n                b = arr[i];\\n            }\\n            \\n            if(c < arr[i]) {\\n                d = c;\\n                c = arr[i];\\n            } else if(d < arr[i]) {\\n                d = arr[i];\\n            }\\n        }\\n        \\n        \\n        int ans = (d*c)-(a*b);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int maxProductDifference(vector<int>& arr) {\\n        int n = arr.size();\\n        \\n        int a = INT_MAX,b = INT_MAX,c = INT_MIN,d = INT_MIN;\\n        for(int i=0;i<n;i++) {\\n            if(a > arr[i]) {\\n                b = a;\\n                a = arr[i];\\n            } else if(b > arr[i]) {\\n                b = arr[i];\\n            }\\n            \\n            if(c < arr[i]) {\\n                d = c;\\n                c = arr[i];\\n            } else if(d < arr[i]) {\\n                d = arr[i];\\n            }\\n        }\\n        \\n        \\n        int ans = (d*c)-(a*b);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2232262,
                "title": "all-appraoches-o-nlog-n-and-o-n-using-c",
                "content": "1. With sorting : O(nlog(n))\\n```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& v) {\\n        sort ( v.begin() , v.end() ) ;\\n        int a = 0 ;\\n        int b = 1 ;\\n        int d = v.size() - 1 ;\\n        int c = v.size() - 2 ;\\n        return v[c]*v[d]-v[a]*v[b] ;\\n    }\\n};\\n```\\n2. Without sorting : O(n)\\n```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& v) {\\n\\t\\n        int max = 0 ;\\n\\t\\tint min = INT_MAX ;\\n        int maxind = -1 ; \\n        int minind  = -1 ;\\n        \\n        for ( int i = 0 ; i < v.size() ; i++ ) {\\n            if( v[i] > max ) {\\n                maxind = i ;\\n                max = v[i] ;\\n            }\\n            if( v[i] < min ) {\\n                minind = i ;\\n                min = v[i] ;\\n            } \\n        }\\n\\t\\t\\n        // int d = max ;\\n        // int a = min ;\\n        int max2 = 0 ;\\n        int min2 = INT_MAX ;\\n\\t\\t\\n        for ( int i = 0 ; i < v.size() ; i++ ) {\\n            if ( i != maxind and i != minind ) {\\n                if( v[i] > max2 ) max2 = v[i] ;\\n                if( v[i] < min2 ) min2 = v[i] ;\\n            }\\n        }\\n\\t\\t\\n        // int b = min2 ;\\n        // int c = max2 ;\\n        // return d*c - a*b ;\\n\\t\\t\\n        return max * max2 - min * min2 ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& v) {\\n        sort ( v.begin() , v.end() ) ;\\n        int a = 0 ;\\n        int b = 1 ;\\n        int d = v.size() - 1 ;\\n        int c = v.size() - 2 ;\\n        return v[c]*v[d]-v[a]*v[b] ;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& v) {\\n\\t\\n        int max = 0 ;\\n\\t\\tint min = INT_MAX ;\\n        int maxind = -1 ; \\n        int minind  = -1 ;\\n        \\n        for ( int i = 0 ; i < v.size() ; i++ ) {\\n            if( v[i] > max ) {\\n                maxind = i ;\\n                max = v[i] ;\\n            }\\n            if( v[i] < min ) {\\n                minind = i ;\\n                min = v[i] ;\\n            } \\n        }\\n\\t\\t\\n        // int d = max ;\\n        // int a = min ;\\n        int max2 = 0 ;\\n        int min2 = INT_MAX ;\\n\\t\\t\\n        for ( int i = 0 ; i < v.size() ; i++ ) {\\n            if ( i != maxind and i != minind ) {\\n                if( v[i] > max2 ) max2 = v[i] ;\\n                if( v[i] < min2 ) min2 = v[i] ;\\n            }\\n        }\\n\\t\\t\\n        // int b = min2 ;\\n        // int c = max2 ;\\n        // return d*c - a*b ;\\n\\t\\t\\n        return max * max2 - min * min2 ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2201481,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums[nums.length-1]*nums[nums.length-2]-nums[1]*nums[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums[nums.length-1]*nums[nums.length-2]-nums[1]*nums[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2190857,
                "title": "java-easy-solution",
                "content": "If u like the code so plz upvote me plzz.\\n\\n\\tclass Solution {\\n\\t\\t\\t\\tpublic int maxProductDifference(int[] nums) {\\n\\t\\t\\t\\t\\tArrays.sort(nums);\\n\\n\\t\\t\\t\\t\\treturn (nums[nums.length-2]*nums[nums.length-1])-(nums[0]*nums[1]);\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\t\\t\\t\\tpublic int maxProductDifference(int[] nums) {\\n\\t\\t\\t\\t\\tArrays.sort(nums);\\n\\n\\t\\t\\t\\t\\treturn (nums[nums.length-2]*nums[nums.length-1])-(nums[0]*nums[1]);\\n\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2167588,
                "title": "two-steps-javascript-solution",
                "content": "1. sort the array\\n2. the result is the difference between: the product of last two elements and the product of the first two elements\\n```\\nvar maxProductDifference = function(nums) {\\n   const result = nums.sort((a,b) => a-b);\\n    return (result[result.length-1] * result[result.length-2]) - (result[0] * result[1]);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxProductDifference = function(nums) {\\n   const result = nums.sort((a,b) => a-b);\\n    return (result[result.length-1] * result[result.length-2]) - (result[0] * result[1]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2156862,
                "title": "javascript-faster-than-96",
                "content": "```\\nvar maxProductDifference = function(nums) {\\n    let max1 = Math.max(...nums)\\n    nums.splice(nums.indexOf(max1), 1)\\n    let max2 = Math.max(...nums)\\n    \\n    let min1 = Math.min(...nums)\\n    nums.splice(nums.indexOf(min1), 1)\\n    let min2 = Math.min(...nums)\\n    \\n    return (max1 * max2) - (min1 * min2)\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/0bd4a509-5e9a-4e01-847f-61a71e205300_1655347372.6472144.png)\\n",
                "solutionTags": [],
                "code": "```\\nvar maxProductDifference = function(nums) {\\n    let max1 = Math.max(...nums)\\n    nums.splice(nums.indexOf(max1), 1)\\n    let max2 = Math.max(...nums)\\n    \\n    let min1 = Math.min(...nums)\\n    nums.splice(nums.indexOf(min1), 1)\\n    let min2 = Math.min(...nums)\\n    \\n    return (max1 * max2) - (min1 * min2)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2091209,
                "title": "java-with-max-and-min-value-find-for-loop-without-sorting",
                "content": "```java\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        int first_max = Integer.MIN_VALUE;\\n        int second_max = Integer.MIN_VALUE;\\n        int first_min = Integer.MAX_VALUE;\\n        int second_min = Integer.MAX_VALUE;\\n    \\n        for(int i : nums){\\n            if(i >= first_max){\\n                second_max = first_max;\\n                first_max = i;\\n            }\\n            else if( i >= second_max && i <= first_max){\\n                second_max = i;\\n            }\\n            \\n            if(i <= first_min){\\n                second_min = first_min;\\n                first_min = i;\\n            }\\n            else if ( i <= second_min && i >= first_min){\\n                second_min = i;\\n            }            \\n        }\\n        \\n        int val = (first_max * second_max) - (first_min * second_min);\\n        return val;\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```java\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        int first_max = Integer.MIN_VALUE;\\n        int second_max = Integer.MIN_VALUE;\\n        int first_min = Integer.MAX_VALUE;\\n        int second_min = Integer.MAX_VALUE;\\n    \\n        for(int i : nums){\\n            if(i >= first_max){\\n                second_max = first_max;\\n                first_max = i;\\n            }\\n            else if( i >= second_max && i <= first_max){\\n                second_max = i;\\n            }\\n            \\n            if(i <= first_min){\\n                second_min = first_min;\\n                first_min = i;\\n            }\\n            else if ( i <= second_min && i >= first_min){\\n                second_min = i;\\n            }            \\n        }\\n        \\n        int val = (first_max * second_max) - (first_min * second_min);\\n        return val;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040778,
                "title": "java-easy-solution-8ms",
                "content": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        int n =nums.length;\\n        return (nums[n-1]*nums[n-2])-(nums[0]*nums[1]);\\n    }\\n}\\n```\\n**Please upvote if you understand my code and comment your best approach**",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        int n =nums.length;\\n        return (nums[n-1]*nums[n-2])-(nums[0]*nums[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2029983,
                "title": "python-o-n-approach-first-second-max-min-explained",
                "content": "```\\n/*\\nwe can solve this problem by sorting the array first and then\\nchosing maximum and second maximum element as one point (w, x)\\nand minimum and second minimum element as the other point (y, z)\\nresult will be (w * x) - (y * z)\\nAlso, we don\\'t have to sort but we can keep track of first, second max and min \\nelement in O(n)\\n*/\\n```\\n\\n```\\nclass Solution:\\n\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        first_min, second_min, first_max, second_max = nums[0], None, nums[0], None\\n        for num in nums[1:]:\\n            if num >= first_max:\\n                second_max, first_max = first_max, num\\n            else: \\n                if second_max is None or num > second_max:\\n                    second_max = num\\n            \\n            if num <= first_min:\\n                second_min, first_min = first_min, num\\n            else:\\n                if second_min is None or num < second_min:\\n                    second_min = num\\n        return (first_max * second_max) - (first_min * second_min)\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n/*\\nwe can solve this problem by sorting the array first and then\\nchosing maximum and second maximum element as one point (w, x)\\nand minimum and second minimum element as the other point (y, z)\\nresult will be (w * x) - (y * z)\\nAlso, we don\\'t have to sort but we can keep track of first, second max and min \\nelement in O(n)\\n*/\\n```\n```\\nclass Solution:\\n\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        first_min, second_min, first_max, second_max = nums[0], None, nums[0], None\\n        for num in nums[1:]:\\n            if num >= first_max:\\n                second_max, first_max = first_max, num\\n            else: \\n                if second_max is None or num > second_max:\\n                    second_max = num\\n            \\n            if num <= first_min:\\n                second_min, first_min = first_min, num\\n            else:\\n                if second_min is None or num < second_min:\\n                    second_min = num\\n        return (first_max * second_max) - (first_min * second_min)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005144,
                "title": "easy-java-solution-using-sort",
                "content": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) \\n    {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        return nums[n-1]*nums[n-2] - nums[1]*nums[0];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int maxProductDifference(int[] nums) \\n    {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        return nums[n-1]*nums[n-2] - nums[1]*nums[0];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2001770,
                "title": "cpp-2-lines-code-easy-to-understand",
                "content": "Find This - https://github.com/dhirajmishra98/LeetCodeSolutions\\n```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return (nums[nums.size()-1]*nums[nums.size()-2])-(nums[0]*nums[1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return (nums[nums.size()-1]*nums[nums.size()-2])-(nums[0]*nums[1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1988209,
                "title": "python-easiest-solution-with-explanation-sorting-beg-to-adv",
                "content": "```python\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        \\n        nums.sort() # sorting the list, to access first 2 lowest elems & 2 highest elems as we have to calulate max diff of pairs after product. \\n        \\n        prod_pair_1 = nums[0] * nums[1] # product of 2 lowest elems in the list. \\n        prod_pair_2 = nums[-1] *  nums[-2] # product of 2 highest elems in the list. \\n        \\n        max_diff = prod_pair_2 - prod_pair_1 # calulating the diff of the product of the above mentioend two paris. \\n        \\n        return max_diff # returning the max difference bet the product. \\n```\\n```python\\n        \"\"\"\\n        Shorter form of the above solution. \\n        \"\"\"\\n        \\n        nums.sort()\\n        return nums[-1]*nums[-2]-nums[0]*nums[1]\\n```\\n***Found helpful, Do upvote !!!***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```python\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        \\n        nums.sort() # sorting the list, to access first 2 lowest elems & 2 highest elems as we have to calulate max diff of pairs after product. \\n        \\n        prod_pair_1 = nums[0] * nums[1] # product of 2 lowest elems in the list. \\n        prod_pair_2 = nums[-1] *  nums[-2] # product of 2 highest elems in the list. \\n        \\n        max_diff = prod_pair_2 - prod_pair_1 # calulating the diff of the product of the above mentioend two paris. \\n        \\n        return max_diff # returning the max difference bet the product. \\n```\n```python\\n        \"\"\"\\n        Shorter form of the above solution. \\n        \"\"\"\\n        \\n        nums.sort()\\n        return nums[-1]*nums[-2]-nums[0]*nums[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918595,
                "title": "python3-no-sort",
                "content": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:      \\n        first, second = 0,0\\n        last, last2 = 1e4, 1e4\\n        \\n        for num in nums:\\n            if num > second:\\n                if num > first:\\n                    first, second = num, first\\n                else:\\n                    second = num\\n            \\n            if num < last2:\\n                if num < last:\\n                    last, last2 = num, last\\n                else:\\n                    last2 = num\\n        \\n        return first*second - last*last2",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:      \\n        first, second = 0,0\\n        last, last2 = 1e4, 1e4\\n        \\n        for num in nums:\\n            if num > second:\\n                if num > first:\\n                    first, second = num, first\\n                else:\\n                    second = num\\n            \\n            if num < last2:\\n                if num < last:\\n                    last, last2 = num, last\\n                else:\\n                    last2 = num\\n        \\n        return first*second - last*last2",
                "codeTag": "Java"
            },
            {
                "id": 1900027,
                "title": "easiest-solutions-with-o-nlogn-and-o-n-time-complexity-and-o-1-space-complexity",
                "content": "The following code takes O(1) space complexity and for sorting O(nlogn) Time complexity!\\n```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return (nums[len(nums)-1]*nums[len(nums)-2]) - (nums[0]*nums[1]) \\n```\\t\\t\\n\\t\\t\\n\\t\\t\\nAnother Solution with more optimised Time Complexity is as follows. It takes merely O(n) Time Complexity\\n\\n```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        m,n= max(nums),min(nums)\\n        nums.remove(m)\\n        nums.remove(n)\\n        return (m*max(nums)) - (n*min(nums))\\n```\\n\\n       \\n\\t\\t\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return (nums[len(nums)-1]*nums[len(nums)-2]) - (nums[0]*nums[1]) \\n```\n```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        m,n= max(nums),min(nums)\\n        nums.remove(m)\\n        nums.remove(n)\\n        return (m*max(nums)) - (n*min(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859925,
                "title": "python-solution",
                "content": "def maxProductDifference(self, nums: List[int]) -> int:\\n        nums=sorted(nums)\\n        if(len(nums)<4):\\n            return -1\\n        return (-(nums[0]*nums[1])+nums[-1]*nums[-2])",
                "solutionTags": [],
                "code": "def maxProductDifference(self, nums: List[int]) -> int:\\n        nums=sorted(nums)\\n        if(len(nums)<4):\\n            return -1\\n        return (-(nums[0]*nums[1])+nums[-1]*nums[-2])",
                "codeTag": "Python3"
            },
            {
                "id": 1857681,
                "title": "easy-4-line-solution-c",
                "content": "class Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        int x = nums[nums.size()-1]*nums[nums.size()-2];\\n        int y = nums[0]*nums[1];\\n        \\n        return (x-y);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        int x = nums[nums.size()-1]*nums[nums.size()-2];\\n        int y = nums[0]*nums[1];\\n        \\n        return (x-y);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1813900,
                "title": "3-line-code-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums)\\n    {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        return nums[n-1]*nums[n-2]-nums[0]*nums[1];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums)\\n    {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        return nums[n-1]*nums[n-2]-nums[0]*nums[1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1801003,
                "title": "java-faster-than-50-o-nlogn-very-simple",
                "content": "class Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums[nums.length-1]*nums[nums.length-2]-nums[0]*nums[1];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums[nums.length-1]*nums[nums.length-2]-nums[0]*nums[1];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1760579,
                "title": "simple-java-2-lines-of-code",
                "content": "just these two lines of code are enough \\n1.) first we sort the array and then we multiply the greatest two elements and subtract the product of the smallest two elements from it;\\n```\\nArrays.sort(nums);\\n        return ((nums[nums.length-1]*nums[nums.length-2])-(nums[0]*nums[1]));\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nArrays.sort(nums);\\n        return ((nums[nums.length-1]*nums[nums.length-2])-(nums[0]*nums[1]));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1753850,
                "title": "java-easy-time-3ms",
                "content": "public int maxProductDifference(int[] nums) {\\nint firstMax = Integer.MIN_VALUE;\\n        firstMax = nums[0] > nums[1] ? nums[0] : nums[1];\\n        int secondMax = firstMax == nums[0] ? nums[1] : nums[0];\\n        for (int i = 2; i < nums.length; i++) {\\n            if (nums[i] > firstMax && nums[i] > secondMax) {\\n                secondMax = firstMax;\\n                firstMax = nums[i];\\n            } else if (nums[i] > secondMax) {\\n                secondMax = nums[i];\\n            }\\n        }\\n        int n = firstMax * secondMax;\\n        System.out.println(n);\\n\\n        int firstMin = Integer.MIN_VALUE;\\n        firstMin = nums[0] < nums[1] ? nums[0] : nums[1];\\n        int secondMin = firstMin == nums[0] ? nums[1] : nums[0];\\n        for (int i = 2; i < nums.length; i++) {\\n            if (nums[i] < firstMin && nums[i] < secondMin) {\\n                secondMin = firstMin;\\n                firstMin = nums[i];\\n            } else if (nums[i] < secondMin) {\\n                secondMin = nums[i];\\n            }\\n        }\\n        int m = firstMin * secondMin;\\n        System.out.println(m);\\n        return n - m;\\n        }",
                "solutionTags": [],
                "code": "public int maxProductDifference(int[] nums) {\\nint firstMax = Integer.MIN_VALUE;\\n        firstMax = nums[0] > nums[1] ? nums[0] : nums[1];\\n        int secondMax = firstMax == nums[0] ? nums[1] : nums[0];\\n        for (int i = 2; i < nums.length; i++) {\\n            if (nums[i] > firstMax && nums[i] > secondMax) {\\n                secondMax = firstMax;\\n                firstMax = nums[i];\\n            } else if (nums[i] > secondMax) {\\n                secondMax = nums[i];\\n            }\\n        }\\n        int n = firstMax * secondMax;\\n        System.out.println(n);\\n\\n        int firstMin = Integer.MIN_VALUE;\\n        firstMin = nums[0] < nums[1] ? nums[0] : nums[1];\\n        int secondMin = firstMin == nums[0] ? nums[1] : nums[0];\\n        for (int i = 2; i < nums.length; i++) {\\n            if (nums[i] < firstMin && nums[i] < secondMin) {\\n                secondMin = firstMin;\\n                firstMin = nums[i];\\n            } else if (nums[i] < secondMin) {\\n                secondMin = nums[i];\\n            }\\n        }\\n        int m = firstMin * secondMin;\\n        System.out.println(m);\\n        return n - m;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1749183,
                "title": "c-easy-2-methods",
                "content": "**Upvote if you found solution helpful**\\n\\n#### Method 1(sort)\\n---\\n```C++\\nclass Solution\\n{\\npublic:\\n    int maxProductDifference(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        return ((nums[n - 1] * nums[n - 2]) - (nums[0] * nums[1]));\\n    }\\n};\\n```\\n\\n---\\n#### Method 2 (simple traversal)\\n---\\n```C++\\nclass Solution\\n{\\npublic:\\n    int maxProductDifference(vector<int> &nums)\\n    {\\n        int max1 = INT_MIN, max2 = INT_MIN;\\n        int min1 = INT_MAX, min2 = INT_MAX;\\n        for (auto x : nums)\\n        {\\n            if (x > max1)\\n            {\\n                // we have new maximum\\n                max2 = max1;\\n                max1 = x;\\n            }\\n            else if (x > max2)\\n            {\\n                max2 = x;\\n            }\\n            // similarly for getting minimum\\n            if (x < min1)\\n            {\\n                min2 = min1;\\n                min1 = x;\\n            }\\n            else if (x < min2)\\n            {\\n                min2 = x;\\n            }\\n        }\\n        return (max1 * max2) - (min1 * min2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution\\n{\\npublic:\\n    int maxProductDifference(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        return ((nums[n - 1] * nums[n - 2]) - (nums[0] * nums[1]));\\n    }\\n};\\n```\n```C++\\nclass Solution\\n{\\npublic:\\n    int maxProductDifference(vector<int> &nums)\\n    {\\n        int max1 = INT_MIN, max2 = INT_MIN;\\n        int min1 = INT_MAX, min2 = INT_MAX;\\n        for (auto x : nums)\\n        {\\n            if (x > max1)\\n            {\\n                // we have new maximum\\n                max2 = max1;\\n                max1 = x;\\n            }\\n            else if (x > max2)\\n            {\\n                max2 = x;\\n            }\\n            // similarly for getting minimum\\n            if (x < min1)\\n            {\\n                min2 = min1;\\n                min1 = x;\\n            }\\n            else if (x < min2)\\n            {\\n                min2 = x;\\n            }\\n        }\\n        return (max1 * max2) - (min1 * min2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1722373,
                "title": "java-linear-time-explained",
                "content": "**Idea:** \\n* Find the 2 greatest and smallest numbers using heaps and return the difference of their products\\n* Use a heap of size 3 so that when 3rd number is added, you can pop the heap root (smallest or largest depending on the heap), thereby reducing the size of the heap to 2 again. We want to maintain the heap size to 2 so that it contains 2 smallest/2 greatest numbers.\\n>**T/S:** O(n)/O(1), where n = size(nums)\\n```\\npublic int maxProductDifference(int[] nums) {\\n\\tvar maxHeap = new PriorityQueue<Integer>(3);\\n\\tvar minHeap = new PriorityQueue<Integer>(3, Comparator.reverseOrder());\\n\\t\\n\\tfor (var num : nums) {\\n\\t\\taddToHeap(maxHeap, num);\\n\\t\\taddToHeap(minHeap, num);\\n\\t}\\n\\t\\n\\treturn maxHeap.poll() * maxHeap.poll() - minHeap.poll() * minHeap.poll();\\n}\\n\\nprivate void addToHeap(Queue<Integer> heap, int num) {\\n\\theap.add(num);\\n\\tif (heap.size() == 3)\\n\\t\\theap.poll();\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic int maxProductDifference(int[] nums) {\\n\\tvar maxHeap = new PriorityQueue<Integer>(3);\\n\\tvar minHeap = new PriorityQueue<Integer>(3, Comparator.reverseOrder());\\n\\t\\n\\tfor (var num : nums) {\\n\\t\\taddToHeap(maxHeap, num);\\n\\t\\taddToHeap(minHeap, num);\\n\\t}\\n\\t\\n\\treturn maxHeap.poll() * maxHeap.poll() - minHeap.poll() * minHeap.poll();\\n}\\n\\nprivate void addToHeap(Queue<Integer> heap, int num) {\\n\\theap.add(num);\\n\\tif (heap.size() == 3)\\n\\t\\theap.poll();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1688782,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        nums.sort()\\n        s=len(nums)\\n        return (nums[s-1]*nums[s-2])-(nums[0]*nums[1])\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        nums.sort()\\n        s=len(nums)\\n        return (nums[s-1]*nums[s-2])-(nums[0]*nums[1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648556,
                "title": "python-straight-forward-solution-with-sorted",
                "content": "\\tclass Solution(object):\\n\\t\\tdef maxProductDifference(self, nums):\\n\\t\\t\\tlis = sorted(nums)\\n\\t\\t\\treturn (lis[-1]*lis[-2])-(lis[1]*lis[0])",
                "solutionTags": [],
                "code": "\\tclass Solution(object):\\n\\t\\tdef maxProductDifference(self, nums):\\n\\t\\t\\tlis = sorted(nums)\\n\\t\\t\\treturn (lis[-1]*lis[-2])-(lis[1]*lis[0])",
                "codeTag": "Java"
            },
            {
                "id": 1646938,
                "title": "easy-java-solution",
                "content": "class Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        int prod=1;\\n        int a=nums[0];\\n        int b=nums[1];\\n        int c=nums[nums.length-1];\\n        int d=nums[nums.length-2];\\n        prod=(c*d) - (a*b);\\n        return prod;\\n    }\\n}",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        int prod=1;\\n        int a=nums[0];\\n        int b=nums[1];\\n        int c=nums[nums.length-1];\\n        int d=nums[nums.length-2];\\n        prod=(c*d) - (a*b);\\n        return prod;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1641545,
                "title": "java-solutions-by-sorting",
                "content": "class Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        int start = 0;\\n        int end   = nums.length-1;\\n        return (nums[end]*nums[end-1])-(nums[start]*nums[start+1]);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        int start = 0;\\n        int end   = nums.length-1;\\n        return (nums[end]*nums[end-1])-(nums[start]*nums[start+1]);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1631253,
                "title": "java-o-n-time-o-1-space-99-7-faster",
                "content": "```\\nclass Solution {\\n    private void updateNums(int[] nums, int num) {\\n        if (num > nums[0]) {\\n            nums[1] = nums[0];\\n            nums[0] = num;\\n        } else if (num > nums[1]) {\\n            nums[1] = num;\\n        }\\n        \\n        if (num < nums[2]) {\\n            nums[3] = nums[2];\\n            nums[2] = num;\\n        } else if (num < nums[3]) {\\n            nums[3] = num;\\n        }\\n    }\\n    \\n    public int maxProductDifference(int[] nums) {\\n        var pNums = new int[]{0, 0, Integer.MAX_VALUE, Integer.MAX_VALUE};\\n        \\n        for (int i = 0; i < nums.length; ++i) {\\n            updateNums(pNums, nums[i]);\\n        }\\n        \\n        return pNums[0] * pNums[1] - pNums[2] * pNums[3];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private void updateNums(int[] nums, int num) {\\n        if (num > nums[0]) {\\n            nums[1] = nums[0];\\n            nums[0] = num;\\n        } else if (num > nums[1]) {\\n            nums[1] = num;\\n        }\\n        \\n        if (num < nums[2]) {\\n            nums[3] = nums[2];\\n            nums[2] = num;\\n        } else if (num < nums[3]) {\\n            nums[3] = num;\\n        }\\n    }\\n    \\n    public int maxProductDifference(int[] nums) {\\n        var pNums = new int[]{0, 0, Integer.MAX_VALUE, Integer.MAX_VALUE};\\n        \\n        for (int i = 0; i < nums.length; ++i) {\\n            updateNums(pNums, nums[i]);\\n        }\\n        \\n        return pNums[0] * pNums[1] - pNums[2] * pNums[3];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625540,
                "title": "simple-logical-commented-python-solution",
                "content": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        # Pick Largest Possible a and b and Smallest Possible c and d\\n        a = max(nums)\\n        nums.remove(a)\\n        b = max(nums)\\n        c = min(nums)\\n        nums.remove(c)\\n        d = min(nums)\\n        return a * b - c * d\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        # Pick Largest Possible a and b and Smallest Possible c and d\\n        a = max(nums)\\n        nums.remove(a)\\n        b = max(nums)\\n        c = min(nums)\\n        nums.remove(c)\\n        d = min(nums)\\n        return a * b - c * d\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594625,
                "title": "javascript-destructuring-assignment",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst maxProductDifference = nums => {\\n    const [a, b] = nums.sort((a, b) => b - a)\\n    const [c, d] = nums.reverse()\\n    return (a * b) - (c * d)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst maxProductDifference = nums => {\\n    const [a, b] = nums.sort((a, b) => b - a)\\n    const [c, d] = nums.reverse()\\n    return (a * b) - (c * d)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1579552,
                "title": "c-basic-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return (nums[nums.size()-1]*nums[nums.size()-2]) - (nums[0]*nums[1]);\\n    }\\n};\\n\\n```\\n**Feel free to ask any question in the comment section.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return (nums[nums.size()-1]*nums[nums.size()-2]) - (nums[0]*nums[1]);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1560176,
                "title": "99-8-faster-o-n-java",
                "content": "```\\nclass Solution {\\n    int max;\\n    int min;\\n    public int maxProductDifference(int[] nums) {\\n            getMax(nums);//for biggest element\\n        int max1=max;\\n            getMax(nums);//again for 2nd biggest element\\n        int max2=max;\\n            getMin(nums);//for smallest\\n        int min1=min;\\n            getMin(nums);//for second smallest\\n        int min2=min;\\n        \\n        return ((max1*max2)-(min1*min2));\\n        \\n        \\n        \\n    }\\n    public void getMax(int[] nums)\\n    {\\n        max=Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]>max)\\n                max=nums[i];\\n            \\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==max)\\n            {nums[i]=Integer.MIN_VALUE;\\n             break;}\\n            \\n        }\\n    }\\n    \\n    public void getMin(int[] nums)\\n    {\\n        min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]<min && nums[i]!=Integer.MIN_VALUE)\\n                min=nums[i];\\n            \\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==min)\\n            {nums[i]=Integer.MIN_VALUE;\\n             break;}\\n            \\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int max;\\n    int min;\\n    public int maxProductDifference(int[] nums) {\\n            getMax(nums);//for biggest element\\n        int max1=max;\\n            getMax(nums);//again for 2nd biggest element\\n        int max2=max;\\n            getMin(nums);//for smallest\\n        int min1=min;\\n            getMin(nums);//for second smallest\\n        int min2=min;\\n        \\n        return ((max1*max2)-(min1*min2));\\n        \\n        \\n        \\n    }\\n    public void getMax(int[] nums)\\n    {\\n        max=Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]>max)\\n                max=nums[i];\\n            \\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==max)\\n            {nums[i]=Integer.MIN_VALUE;\\n             break;}\\n            \\n        }\\n    }\\n    \\n    public void getMin(int[] nums)\\n    {\\n        min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]<min && nums[i]!=Integer.MIN_VALUE)\\n                min=nums[i];\\n            \\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==min)\\n            {nums[i]=Integer.MIN_VALUE;\\n             break;}\\n            \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1551044,
                "title": "python3-93-66-faster-solution",
                "content": "Sort and calculate\\n```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        nums = sorted(nums, reverse=True)\\n        prod_max = nums[0] * nums[1]\\n        prod_min = nums[-1] * nums[-2]\\n        return prod_max - prod_min\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        nums = sorted(nums, reverse=True)\\n        prod_max = nums[0] * nums[1]\\n        prod_min = nums[-1] * nums[-2]\\n        return prod_max - prod_min\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1541952,
                "title": "java-solution-runtime-1ms-time-complexity-o-n-faster-than-99-77-submission",
                "content": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        int max = 0; // Integer.Min_Value\\n        int secMax = 0; // Integer.Min_Value\\n        int low = 10001; // Integer.Max_Value\\n        int secLow = 10001; // Integer.Max_Value\\n        \\n\\t\\t\\n        for(int i:nums){\\n\\t\\t// find max and 2nd max\\n            if(i>max){\\n                secMax=max;\\n                max = i;\\n            } else if(i>secMax){\\n                secMax=i;\\n            }\\n\\t\\t\\t// find lowest and 2nd lowest\\n\\t\\t\\t if(i<low){\\n                secLow=low;\\n                low = i;\\n            } else if(i<secLow){\\n                secLow=i;\\n            }\\n        }\\n        // diif between product of (max and second max) and (low and second lowest)\\n        return max*secMax-low*secLow;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        int max = 0; // Integer.Min_Value\\n        int secMax = 0; // Integer.Min_Value\\n        int low = 10001; // Integer.Max_Value\\n        int secLow = 10001; // Integer.Max_Value\\n        \\n\\t\\t\\n        for(int i:nums){\\n\\t\\t// find max and 2nd max\\n            if(i>max){\\n                secMax=max;\\n                max = i;\\n            } else if(i>secMax){\\n                secMax=i;\\n            }\\n\\t\\t\\t// find lowest and 2nd lowest\\n\\t\\t\\t if(i<low){\\n                secLow=low;\\n                low = i;\\n            } else if(i<secLow){\\n                secLow=i;\\n            }\\n        }\\n        // diif between product of (max and second max) and (low and second lowest)\\n        return max*secMax-low*secLow;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538479,
                "title": "one-pass-to-find-4-values-99-speed",
                "content": "![image](https://assets.leetcode.com/users/images/2c0bb780-7776-40d1-9edb-ef0c06846f3a_1635080170.3722925.png)\\n```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        min1 = min2 = inf\\n        max1 = max2 = 0\\n        for n in nums:\\n            if n < min1:\\n                min2 = min1\\n                min1 = n\\n            elif n < min2:\\n                min2 = n\\n            if n > max2:\\n                max1 = max2\\n                max2 = n\\n            elif n > max1:\\n                max1 = n\\n        return max1 * max2 - min1 * min2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        min1 = min2 = inf\\n        max1 = max2 = 0\\n        for n in nums:\\n            if n < min1:\\n                min2 = min1\\n                min1 = n\\n            elif n < min2:\\n                min2 = n\\n            if n > max2:\\n                max1 = max2\\n                max2 = n\\n            elif n > max1:\\n                max1 = n\\n        return max1 * max2 - min1 * min2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523915,
                "title": "python-intutive-o-nlogn-solution",
                "content": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return nums[-2]*nums[-1] - nums[0]*nums[1]",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return nums[-2]*nums[-1] - nums[0]*nums[1]",
                "codeTag": "Java"
            },
            {
                "id": 1521538,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return nums[-1]*nums[-2]-(nums[0]*nums[1])\\n\\t\\t\\n\\t\\t#res = (max1*max2) - (min1*min2)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return nums[-1]*nums[-2]-(nums[0]*nums[1])\\n\\t\\t\\n\\t\\t#res = (max1*max2) - (min1*min2)",
                "codeTag": "Java"
            },
            {
                "id": 1519941,
                "title": "java-less-than-2msec-no-sorting-one-loop",
                "content": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n      \\n        int topOne, topTwo;\\n        int lowOne, lowTwo;\\n        topOne=topTwo=0;   //Based on constraints\\n        lowOne=lowTwo=10001;   //Based on constraints\\n    \\n        // The order is ----->          lowOne< lowTwo < topTwo < topOne\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]>=topOne)\\n            {\\n                topTwo=topOne;\\n                topOne=nums[i];\\n            }\\n        else if ((nums[i]<topOne)&&(nums[i]>=topTwo))\\n            {\\n                topTwo=nums[i];\\n            }\\n            \\n         if(nums[i]<=lowOne)\\n            {\\n                lowTwo=lowOne;\\n                lowOne=nums[i];\\n            }\\n       else  if((nums[i]>lowOne)&&(nums[i]<=lowTwo))\\n            {\\n                lowTwo=nums[i];\\n            }\\n        }\\n        \\n        return (topOne*topTwo - lowOne*lowTwo);\\n        \\n        \\n        // Arrays.sort(nums);\\n        // return (nums[nums.length-1]*nums[nums.length-2] - nums[0]*nums[1]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n      \\n        int topOne, topTwo;\\n        int lowOne, lowTwo;\\n        topOne=topTwo=0;   //Based on constraints\\n        lowOne=lowTwo=10001;   //Based on constraints\\n    \\n        // The order is ----->          lowOne< lowTwo < topTwo < topOne\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]>=topOne)\\n            {\\n                topTwo=topOne;\\n                topOne=nums[i];\\n            }\\n        else if ((nums[i]<topOne)&&(nums[i]>=topTwo))\\n            {\\n                topTwo=nums[i];\\n            }\\n            \\n         if(nums[i]<=lowOne)\\n            {\\n                lowTwo=lowOne;\\n                lowOne=nums[i];\\n            }\\n       else  if((nums[i]>lowOne)&&(nums[i]<=lowTwo))\\n            {\\n                lowTwo=nums[i];\\n            }\\n        }\\n        \\n        return (topOne*topTwo - lowOne*lowTwo);\\n        \\n        \\n        // Arrays.sort(nums);\\n        // return (nums[nums.length-1]*nums[nums.length-2] - nums[0]*nums[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1497486,
                "title": "pythonic-solution",
                "content": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        [a, b, *rest, c, d] = sorted(nums)\\n        return abs(a * b - c * d)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        [a, b, *rest, c, d] = sorted(nums)\\n        return abs(a * b - c * d)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1484979,
                "title": "easy-to-understand-c-solution",
                "content": "**Explanation**\\nTo maximise (a* b) - (c * d) we need to maximise a and b and minimise c and d. So we sort the vector and the last two will be highest (a,b) and the first 2 value will be the lowest       ( c,d ) and then we return the difference of their products.\\n\\nPlease upvote the solution if you find it helpful and comment down if you have any questions!\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size()-1;\\n        return (nums[n]*nums[n-1])-(nums[0]*nums[1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size()-1;\\n        return (nums[n]*nums[n-1])-(nums[0]*nums[1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1464694,
                "title": "java-using-sort-o-nlogn",
                "content": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        return (nums[nums.length - 1] * nums[nums.length - 2]) - (nums[0] * nums[1]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        return (nums[nums.length - 1] * nums[nums.length - 2]) - (nums[0] * nums[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1459495,
                "title": "java-faster-then-98-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        int minimum = 10001;\\n        int secondMinimum = 10001;\\n        int maximum = 0;\\n        int secondMaximum = 0;\\n        int minimumIndex = 0;\\n        int maximumIndex = 0;\\n        \\n        for(int i =0;i<nums.length;i++){\\n            int item = nums[i];\\n            if(minimum>item){\\n                minimum = item;\\n                minimumIndex = i;\\n            }\\n            if(maximum<item){\\n                maximum = item;\\n                maximumIndex = i;\\n            }\\n        }\\n        for(int i =0;i<nums.length;i++){\\n            int item = nums[i];\\n            if(secondMinimum>item && minimumIndex != i){\\n                secondMinimum = item;\\n            }\\n            if(secondMaximum<item && maximumIndex != i){\\n                secondMaximum = item;\\n            }\\n        }\\n        return (maximum*secondMaximum) - (minimum*secondMinimum);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        int minimum = 10001;\\n        int secondMinimum = 10001;\\n        int maximum = 0;\\n        int secondMaximum = 0;\\n        int minimumIndex = 0;\\n        int maximumIndex = 0;\\n        \\n        for(int i =0;i<nums.length;i++){\\n            int item = nums[i];\\n            if(minimum>item){\\n                minimum = item;\\n                minimumIndex = i;\\n            }\\n            if(maximum<item){\\n                maximum = item;\\n                maximumIndex = i;\\n            }\\n        }\\n        for(int i =0;i<nums.length;i++){\\n            int item = nums[i];\\n            if(secondMinimum>item && minimumIndex != i){\\n                secondMinimum = item;\\n            }\\n            if(secondMaximum<item && maximumIndex != i){\\n                secondMaximum = item;\\n            }\\n        }\\n        return (maximum*secondMaximum) - (minimum*secondMinimum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456715,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n\\t\\n\\t\\tint result=0,n=nums.size()-1;\\n        sort(nums.begin(), nums.end()); \\n        result=(nums[n]*nums[n-1])-(nums[0]*nums[1]);\\n\\t\\t\\n       return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n\\t\\n\\t\\tint result=0,n=nums.size()-1;\\n        sort(nums.begin(), nums.end()); \\n        result=(nums[n]*nums[n-1])-(nums[0]*nums[1]);\\n\\t\\t\\n       return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1453925,
                "title": "easy-c-code-with-comments-easy-to-understand",
                "content": "sort the array and store first two values as smaller and last two as bigger and return the answer\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int c=nums[nums.size()-1];\\n        int d=nums[nums.size()-2];\\n        int a=nums[0];\\n        int b=nums[1];\\n        return (c*d - a*b);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProductDifference(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int c=nums[nums.size()-1];\\n        int d=nums[nums.size()-2];\\n        int a=nums[0];\\n        int b=nums[1];\\n        return (c*d - a*b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446426,
                "title": "java-2-liner-less-code-faster-code",
                "content": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        return (nums[nums.length-1] * nums[nums.length-2] ) - (nums[0] * nums[1]);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        return (nums[nums.length-1] * nums[nums.length-2] ) - (nums[0] * nums[1]);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1441867,
                "title": "c-o-n-solution",
                "content": "**Please Upvote if it helped You**\\n```\\nint maxProductDifference(vector<int>& nums) \\n    {\\n        int max1=INT_MIN;\\n        int max2=INT_MIN;\\n        int min1=INT_MAX;\\n        int min2=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            \\n            if(nums[i]>max1)\\n            {\\n                max2=max1;//assign the second max to max2\\n                max1=nums[i];\\n            }\\n            else if(nums[i]>max2)\\n            {\\n                max2= nums[i];\\n            }\\n            \\n            //for minimum\\n            if(nums[i]<min1)\\n            {\\n                min2=min1;\\n                min1=nums[i];\\n            }\\n            else if(nums[i]<min2)\\n            {\\n                min2=nums[i];\\n            }\\n        }\\n        return (max1*max2)- (min1*min2);    \\n    }\\n};\\n```\\n**Please Upvote if it helped You**",
                "solutionTags": [],
                "code": "```\\nint maxProductDifference(vector<int>& nums) \\n    {\\n        int max1=INT_MIN;\\n        int max2=INT_MIN;\\n        int min1=INT_MAX;\\n        int min2=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            \\n            if(nums[i]>max1)\\n            {\\n                max2=max1;//assign the second max to max2\\n                max1=nums[i];\\n            }\\n            else if(nums[i]>max2)\\n            {\\n                max2= nums[i];\\n            }\\n            \\n            //for minimum\\n            if(nums[i]<min1)\\n            {\\n                min2=min1;\\n                min1=nums[i];\\n            }\\n            else if(nums[i]<min2)\\n            {\\n                min2=nums[i];\\n            }\\n        }\\n        return (max1*max2)- (min1*min2);    \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1427265,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return (nums[-1] * nums[-2]) - (nums[0] * nums[1])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return (nums[-1] * nums[-2]) - (nums[0] * nums[1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418321,
                "title": "java-not-fastest-bur-shortest-2-line",
                "content": "if you like it pls upvote\\n\\nJava\\n```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums[nums.length-1]* nums[nums.length-2] - nums[0]*nums[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums[nums.length-1]* nums[nums.length-2] - nums[0]*nums[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414796,
                "title": "ruby-one-liner-faster-than-97-56",
                "content": "```\\ndef max_product_difference(nums)\\n    nums.max(2).reduce(:*) - nums.min(2).reduce(:*)\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef max_product_difference(nums)\\n    nums.max(2).reduce(:*) - nums.min(2).reduce(:*)\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1402627,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return ((nums[-1]*nums[-2]) - (nums[0]*nums[1]))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProductDifference(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return ((nums[-1]*nums[-2]) - (nums[0]*nums[1]))\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1808503,
                "content": [
                    {
                        "username": "maximbazadji",
                        "content": "test cases are not right as in the description. It says \"choose four distinct indices\" but in reality many testcases rely on the same values"
                    },
                    {
                        "username": "JordiBustos",
                        "content": "yeah but the indices of those same values are differents"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Simple Approach: \\nSort using STL \\nReturn the difference but first multiply two maximum digits (that will be at the end) and two minimum digits that will be at the front of the array."
                    },
                    {
                        "username": "Ashu07",
                        "content": " int ans=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            int min =i;\\n            for(int j=i+1;j<arr.length;j++)\\n            {\\n                if(arr[i]>arr[j])\\n                {\\n                    int temp=arr[i];\\n                    arr[i]= arr[j];\\n                    arr[j]=temp;\\n                }\\n            }\\n        }   \\n        for(int i=0;i<arr.length;i++)\\n        {\\n             ans= (arr[arr.length-1]*arr[arr.length-2])-arr[0]*arr[1];\\n        }\\n    return ans;\\n    }"
                    },
                    {
                        "username": "ramziddinrustamov",
                        "content": "At the beginning, I didn\\'t know which element to get, the description was not mentioned, so you can get whatever elements you want, it just depends on this array! for example $nums[$count-1] $nums[$count-2] "
                    },
                    {
                        "username": "meanup",
                        "content": "The maximum product difference in a sorted list of integers can be found by subtracting the greatest and least numbers in the array.\n\n`Hint`"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": " one can simply sort the given array and access 2 max value and 2 min value using index\\n\\n\\n```let length = nums.length;\\nnums.sort((a,b) => a-b);\\nreturn nums[length-2] * nums[length-1] - (nums[0] * nums[1])```"
                    }
                ]
            },
            {
                "id": 1914109,
                "content": [
                    {
                        "username": "maximbazadji",
                        "content": "test cases are not right as in the description. It says \"choose four distinct indices\" but in reality many testcases rely on the same values"
                    },
                    {
                        "username": "JordiBustos",
                        "content": "yeah but the indices of those same values are differents"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Simple Approach: \\nSort using STL \\nReturn the difference but first multiply two maximum digits (that will be at the end) and two minimum digits that will be at the front of the array."
                    },
                    {
                        "username": "Ashu07",
                        "content": " int ans=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            int min =i;\\n            for(int j=i+1;j<arr.length;j++)\\n            {\\n                if(arr[i]>arr[j])\\n                {\\n                    int temp=arr[i];\\n                    arr[i]= arr[j];\\n                    arr[j]=temp;\\n                }\\n            }\\n        }   \\n        for(int i=0;i<arr.length;i++)\\n        {\\n             ans= (arr[arr.length-1]*arr[arr.length-2])-arr[0]*arr[1];\\n        }\\n    return ans;\\n    }"
                    },
                    {
                        "username": "ramziddinrustamov",
                        "content": "At the beginning, I didn\\'t know which element to get, the description was not mentioned, so you can get whatever elements you want, it just depends on this array! for example $nums[$count-1] $nums[$count-2] "
                    },
                    {
                        "username": "meanup",
                        "content": "The maximum product difference in a sorted list of integers can be found by subtracting the greatest and least numbers in the array.\n\n`Hint`"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": " one can simply sort the given array and access 2 max value and 2 min value using index\\n\\n\\n```let length = nums.length;\\nnums.sort((a,b) => a-b);\\nreturn nums[length-2] * nums[length-1] - (nums[0] * nums[1])```"
                    }
                ]
            },
            {
                "id": 1810561,
                "content": [
                    {
                        "username": "maximbazadji",
                        "content": "test cases are not right as in the description. It says \"choose four distinct indices\" but in reality many testcases rely on the same values"
                    },
                    {
                        "username": "JordiBustos",
                        "content": "yeah but the indices of those same values are differents"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Simple Approach: \\nSort using STL \\nReturn the difference but first multiply two maximum digits (that will be at the end) and two minimum digits that will be at the front of the array."
                    },
                    {
                        "username": "Ashu07",
                        "content": " int ans=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            int min =i;\\n            for(int j=i+1;j<arr.length;j++)\\n            {\\n                if(arr[i]>arr[j])\\n                {\\n                    int temp=arr[i];\\n                    arr[i]= arr[j];\\n                    arr[j]=temp;\\n                }\\n            }\\n        }   \\n        for(int i=0;i<arr.length;i++)\\n        {\\n             ans= (arr[arr.length-1]*arr[arr.length-2])-arr[0]*arr[1];\\n        }\\n    return ans;\\n    }"
                    },
                    {
                        "username": "ramziddinrustamov",
                        "content": "At the beginning, I didn\\'t know which element to get, the description was not mentioned, so you can get whatever elements you want, it just depends on this array! for example $nums[$count-1] $nums[$count-2] "
                    },
                    {
                        "username": "meanup",
                        "content": "The maximum product difference in a sorted list of integers can be found by subtracting the greatest and least numbers in the array.\n\n`Hint`"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": " one can simply sort the given array and access 2 max value and 2 min value using index\\n\\n\\n```let length = nums.length;\\nnums.sort((a,b) => a-b);\\nreturn nums[length-2] * nums[length-1] - (nums[0] * nums[1])```"
                    }
                ]
            },
            {
                "id": 2071349,
                "content": [
                    {
                        "username": "maximbazadji",
                        "content": "test cases are not right as in the description. It says \"choose four distinct indices\" but in reality many testcases rely on the same values"
                    },
                    {
                        "username": "JordiBustos",
                        "content": "yeah but the indices of those same values are differents"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Simple Approach: \\nSort using STL \\nReturn the difference but first multiply two maximum digits (that will be at the end) and two minimum digits that will be at the front of the array."
                    },
                    {
                        "username": "Ashu07",
                        "content": " int ans=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            int min =i;\\n            for(int j=i+1;j<arr.length;j++)\\n            {\\n                if(arr[i]>arr[j])\\n                {\\n                    int temp=arr[i];\\n                    arr[i]= arr[j];\\n                    arr[j]=temp;\\n                }\\n            }\\n        }   \\n        for(int i=0;i<arr.length;i++)\\n        {\\n             ans= (arr[arr.length-1]*arr[arr.length-2])-arr[0]*arr[1];\\n        }\\n    return ans;\\n    }"
                    },
                    {
                        "username": "ramziddinrustamov",
                        "content": "At the beginning, I didn\\'t know which element to get, the description was not mentioned, so you can get whatever elements you want, it just depends on this array! for example $nums[$count-1] $nums[$count-2] "
                    },
                    {
                        "username": "meanup",
                        "content": "The maximum product difference in a sorted list of integers can be found by subtracting the greatest and least numbers in the array.\n\n`Hint`"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": " one can simply sort the given array and access 2 max value and 2 min value using index\\n\\n\\n```let length = nums.length;\\nnums.sort((a,b) => a-b);\\nreturn nums[length-2] * nums[length-1] - (nums[0] * nums[1])```"
                    }
                ]
            },
            {
                "id": 1895168,
                "content": [
                    {
                        "username": "maximbazadji",
                        "content": "test cases are not right as in the description. It says \"choose four distinct indices\" but in reality many testcases rely on the same values"
                    },
                    {
                        "username": "JordiBustos",
                        "content": "yeah but the indices of those same values are differents"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Simple Approach: \\nSort using STL \\nReturn the difference but first multiply two maximum digits (that will be at the end) and two minimum digits that will be at the front of the array."
                    },
                    {
                        "username": "Ashu07",
                        "content": " int ans=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            int min =i;\\n            for(int j=i+1;j<arr.length;j++)\\n            {\\n                if(arr[i]>arr[j])\\n                {\\n                    int temp=arr[i];\\n                    arr[i]= arr[j];\\n                    arr[j]=temp;\\n                }\\n            }\\n        }   \\n        for(int i=0;i<arr.length;i++)\\n        {\\n             ans= (arr[arr.length-1]*arr[arr.length-2])-arr[0]*arr[1];\\n        }\\n    return ans;\\n    }"
                    },
                    {
                        "username": "ramziddinrustamov",
                        "content": "At the beginning, I didn\\'t know which element to get, the description was not mentioned, so you can get whatever elements you want, it just depends on this array! for example $nums[$count-1] $nums[$count-2] "
                    },
                    {
                        "username": "meanup",
                        "content": "The maximum product difference in a sorted list of integers can be found by subtracting the greatest and least numbers in the array.\n\n`Hint`"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": " one can simply sort the given array and access 2 max value and 2 min value using index\\n\\n\\n```let length = nums.length;\\nnums.sort((a,b) => a-b);\\nreturn nums[length-2] * nums[length-1] - (nums[0] * nums[1])```"
                    }
                ]
            },
            {
                "id": 1816195,
                "content": [
                    {
                        "username": "maximbazadji",
                        "content": "test cases are not right as in the description. It says \"choose four distinct indices\" but in reality many testcases rely on the same values"
                    },
                    {
                        "username": "JordiBustos",
                        "content": "yeah but the indices of those same values are differents"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Simple Approach: \\nSort using STL \\nReturn the difference but first multiply two maximum digits (that will be at the end) and two minimum digits that will be at the front of the array."
                    },
                    {
                        "username": "Ashu07",
                        "content": " int ans=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            int min =i;\\n            for(int j=i+1;j<arr.length;j++)\\n            {\\n                if(arr[i]>arr[j])\\n                {\\n                    int temp=arr[i];\\n                    arr[i]= arr[j];\\n                    arr[j]=temp;\\n                }\\n            }\\n        }   \\n        for(int i=0;i<arr.length;i++)\\n        {\\n             ans= (arr[arr.length-1]*arr[arr.length-2])-arr[0]*arr[1];\\n        }\\n    return ans;\\n    }"
                    },
                    {
                        "username": "ramziddinrustamov",
                        "content": "At the beginning, I didn\\'t know which element to get, the description was not mentioned, so you can get whatever elements you want, it just depends on this array! for example $nums[$count-1] $nums[$count-2] "
                    },
                    {
                        "username": "meanup",
                        "content": "The maximum product difference in a sorted list of integers can be found by subtracting the greatest and least numbers in the array.\n\n`Hint`"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": " one can simply sort the given array and access 2 max value and 2 min value using index\\n\\n\\n```let length = nums.length;\\nnums.sort((a,b) => a-b);\\nreturn nums[length-2] * nums[length-1] - (nums[0] * nums[1])```"
                    }
                ]
            }
        ]
    }
]